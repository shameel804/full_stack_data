[
    {
        "q": "What is Angular's default testing framework?",
        "type": "mcq",
        "o": [
            "Jasmine",
            "Mocha",
            "Jest",
            "Tape"
        ]
    },
    {
        "q": "Karma is a test runner for Angular.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What command runs Angular tests?",
        "type": "mcq",
        "c": "ng test",
        "o": [
            "Runs unit tests with Karma",
            "Builds the app",
            "Serves the app",
            "Generates code"
        ]
    },
    {
        "q": "Angular CLI generates _____ files for components.",
        "type": "fill_blank",
        "answers": [
            "spec"
        ],
        "other_options": [
            "test",
            "unit",
            "mock"
        ]
    },
    {
        "q": "Match testing concepts:",
        "type": "match",
        "left": [
            "Jasmine",
            "Karma",
            "Protractor"
        ],
        "right": [
            "Testing framework",
            "Test runner",
            "E2E testing"
        ]
    },
    {
        "q": "What is a describe() block?",
        "type": "mcq",
        "o": [
            "Groups related tests together",
            "Runs a single test",
            "Mocks a service",
            "Creates component"
        ]
    },
    {
        "q": "describe() blocks can be nested.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "describe('MyComponent', () => { ... })",
        "o": [
            "Test suite for MyComponent",
            "Component instance",
            "Service mock",
            "Nothing"
        ]
    },
    {
        "q": "describe() is for organizing _____ logically.",
        "type": "fill_blank",
        "answers": [
            "tests"
        ],
        "other_options": [
            "components",
            "services",
            "modules"
        ]
    },
    {
        "q": "Match test structure:",
        "type": "match",
        "left": [
            "describe",
            "it",
            "expect"
        ],
        "right": [
            "Test suite",
            "Test case",
            "Assertion"
        ]
    },
    {
        "q": "What is an it() block?",
        "type": "mcq",
        "o": [
            "Individual test case",
            "Test suite",
            "Setup function",
            "Teardown function"
        ]
    },
    {
        "q": "it() should describe expected behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test?",
        "type": "mcq",
        "c": "it('should create the component', () => { expect(component).toBeTruthy(); })",
        "o": [
            "Component is created successfully",
            "Component fails",
            "Service works",
            "Nothing"
        ]
    },
    {
        "q": "it() descriptions should start with _____.",
        "type": "fill_blank",
        "answers": [
            "should"
        ],
        "other_options": [
            "will",
            "must",
            "can"
        ]
    },
    {
        "q": "Match Jasmine functions:",
        "type": "match",
        "left": [
            "it()",
            "xit()",
            "fit()"
        ],
        "right": [
            "Normal test",
            "Skipped test",
            "Focused test"
        ]
    },
    {
        "q": "What is expect()?",
        "type": "mcq",
        "o": [
            "Creates an assertion",
            "Runs test",
            "Skips test",
            "Creates mock"
        ]
    },
    {
        "q": "expect() is followed by a matcher.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this assert?",
        "type": "mcq",
        "c": "expect(result).toBe(42)",
        "o": [
            "result equals 42",
            "result is truthy",
            "result exists",
            "Nothing"
        ]
    },
    {
        "q": "expect() takes the _____ value.",
        "type": "fill_blank",
        "answers": [
            "actual"
        ],
        "other_options": [
            "expected",
            "mock",
            "test"
        ]
    },
    {
        "q": "Match matchers:",
        "type": "match",
        "left": [
            "toBe",
            "toEqual",
            "toBeTruthy"
        ],
        "right": [
            "Strict equality",
            "Deep equality",
            "Truthy value"
        ]
    },
    {
        "q": "What is toBe() matcher?",
        "type": "mcq",
        "o": [
            "Checks strict equality (===)",
            "Checks deep equality",
            "Checks truthiness",
            "Checks type"
        ]
    },
    {
        "q": "toBe() uses === comparison.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does toBe() compare?",
        "type": "mcq",
        "c": "expect(a).toBe(b)",
        "o": [
            "Reference equality for objects",
            "Deep comparison",
            "Property comparison",
            "Nothing"
        ]
    },
    {
        "q": "toBe() is best for _____ values.",
        "type": "fill_blank",
        "answers": [
            "primitive"
        ],
        "other_options": [
            "object",
            "array",
            "complex"
        ]
    },
    {
        "q": "Match equality matchers:",
        "type": "match",
        "left": [
            "toBe",
            "toEqual",
            "toStrictEqual"
        ],
        "right": [
            "Same reference",
            "Same content",
            "Same type and content"
        ]
    },
    {
        "q": "What is toEqual() matcher?",
        "type": "mcq",
        "o": [
            "Checks deep equality of objects",
            "Checks reference equality",
            "Checks truthiness",
            "Checks type only"
        ]
    },
    {
        "q": "toEqual() compares object contents.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use toEqual()?",
        "type": "mcq",
        "o": [
            "Comparing objects and arrays",
            "Comparing primitives",
            "Checking truthy",
            "Checking null"
        ]
    },
    {
        "q": "toEqual() does _____ comparison.",
        "type": "fill_blank",
        "answers": [
            "deep"
        ],
        "other_options": [
            "shallow",
            "reference",
            "strict"
        ]
    },
    {
        "q": "Match object matchers:",
        "type": "match",
        "left": [
            "toEqual",
            "toContain",
            "toHaveSize"
        ],
        "right": [
            "Full equality",
            "Has element",
            "Length check"
        ]
    },
    {
        "q": "What is beforeEach()?",
        "type": "mcq",
        "o": [
            "Runs setup before each test",
            "Runs after each test",
            "Runs once before all",
            "Runs once after all"
        ]
    },
    {
        "q": "beforeEach() runs before every it() block.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is beforeEach used for?",
        "type": "mcq",
        "o": [
            "Common test setup",
            "Cleanup",
            "Assertions",
            "Mocking"
        ]
    },
    {
        "q": "beforeEach() ensures _____ test state.",
        "type": "fill_blank",
        "answers": [
            "fresh"
        ],
        "other_options": [
            "shared",
            "cached",
            "old"
        ]
    },
    {
        "q": "Match lifecycle hooks:",
        "type": "match",
        "left": [
            "beforeEach",
            "afterEach",
            "beforeAll",
            "afterAll"
        ],
        "right": [
            "Before each test",
            "After each test",
            "Once before suite",
            "Once after suite"
        ]
    },
    {
        "q": "What is afterEach()?",
        "type": "mcq",
        "o": [
            "Runs cleanup after each test",
            "Runs setup",
            "Runs assertions",
            "Runs mocks"
        ]
    },
    {
        "q": "afterEach() is for cleanup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What to do in afterEach()?",
        "type": "mcq",
        "o": [
            "Reset state, unsubscribe",
            "Create components",
            "Run assertions",
            "Mock services"
        ]
    },
    {
        "q": "afterEach() runs after every _____ block.",
        "type": "fill_blank",
        "answers": [
            "it"
        ],
        "other_options": [
            "describe",
            "beforeEach",
            "expect"
        ]
    },
    {
        "q": "Rearrange test lifecycle:",
        "type": "rearrange",
        "words": [
            "beforeAll",
            "beforeEach",
            "it() test runs",
            "afterEach",
            "afterAll"
        ]
    },
    {
        "q": "What is TestBed?",
        "type": "mcq",
        "o": [
            "Angular testing utility for configuring test modules",
            "Test runner",
            "Mock library",
            "Assertion library"
        ]
    },
    {
        "q": "TestBed is from @angular/core/testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does TestBed create?",
        "type": "mcq",
        "o": [
            "Testing module environment",
            "Production build",
            "HTTP client",
            "Router"
        ]
    },
    {
        "q": "TestBed simulates an Angular _____.",
        "type": "fill_blank",
        "answers": [
            "module"
        ],
        "other_options": [
            "component",
            "service",
            "pipe"
        ]
    },
    {
        "q": "Match TestBed methods:",
        "type": "match",
        "left": [
            "configureTestingModule",
            "createComponent",
            "inject"
        ],
        "right": [
            "Setup module",
            "Create instance",
            "Get service"
        ]
    },
    {
        "q": "What is configureTestingModule()?",
        "type": "mcq",
        "o": [
            "Configures testing module with declarations and providers",
            "Creates component",
            "Runs tests",
            "Mocks services"
        ]
    },
    {
        "q": "configureTestingModule takes module metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "TestBed.configureTestingModule({declarations: [MyComponent], providers: [MyService]})",
        "o": [
            "Test module with component and service",
            "Production module",
            "Routes",
            "Nothing"
        ]
    },
    {
        "q": "configureTestingModule accepts declarations and _____.",
        "type": "fill_blank",
        "answers": [
            "providers"
        ],
        "other_options": [
            "components",
            "services",
            "tests"
        ]
    },
    {
        "q": "Match module config:",
        "type": "match",
        "left": [
            "declarations",
            "imports",
            "providers"
        ],
        "right": [
            "Components/Directives/Pipes",
            "Other modules",
            "Services"
        ]
    },
    {
        "q": "What is ComponentFixture?",
        "type": "mcq",
        "o": [
            "Wrapper around component for testing",
            "Component class",
            "Service",
            "Module"
        ]
    },
    {
        "q": "ComponentFixture provides access to component instance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does fixture.componentInstance return?",
        "type": "mcq",
        "o": [
            "The actual component instance",
            "DOM element",
            "Service",
            "Nothing"
        ]
    },
    {
        "q": "ComponentFixture has debugElement and _____.",
        "type": "fill_blank",
        "answers": [
            "nativeElement"
        ],
        "other_options": [
            "component",
            "service",
            "module"
        ]
    },
    {
        "q": "Match fixture properties:",
        "type": "match",
        "left": [
            "componentInstance",
            "debugElement",
            "nativeElement"
        ],
        "right": [
            "Component class",
            "Debug wrapper",
            "DOM element"
        ]
    },
    {
        "q": "What is fixture.detectChanges()?",
        "type": "mcq",
        "o": [
            "Triggers change detection manually",
            "Creates component",
            "Destroys component",
            "Mocks service"
        ]
    },
    {
        "q": "detectChanges() must be called after property changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why call detectChanges()?",
        "type": "mcq",
        "o": [
            "Update template bindings",
            "Create component",
            "Mock services",
            "Run assertions"
        ]
    },
    {
        "q": "detectChanges() updates the component _____.",
        "type": "fill_blank",
        "answers": [
            "view"
        ],
        "other_options": [
            "class",
            "service",
            "module"
        ]
    },
    {
        "q": "Rearrange component test setup:",
        "type": "rearrange",
        "words": [
            "configureTestingModule",
            "createComponent",
            "get componentInstance",
            "modify properties",
            "detectChanges"
        ]
    },
    {
        "q": "What is DebugElement?",
        "type": "mcq",
        "o": [
            "Angular wrapper around DOM element",
            "Plain DOM element",
            "Component instance",
            "Service"
        ]
    },
    {
        "q": "DebugElement has query methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does debugElement.query() return?",
        "type": "mcq",
        "o": [
            "First matching DebugElement",
            "All matches",
            "DOM element",
            "Nothing"
        ]
    },
    {
        "q": "DebugElement provides testing _____ around DOM.",
        "type": "fill_blank",
        "answers": [
            "utilities"
        ],
        "other_options": [
            "elements",
            "services",
            "components"
        ]
    },
    {
        "q": "Match DebugElement methods:",
        "type": "match",
        "left": [
            "query",
            "queryAll",
            "triggerEventHandler"
        ],
        "right": [
            "Find one",
            "Find all",
            "Fire event"
        ]
    },
    {
        "q": "What is By.css()?",
        "type": "mcq",
        "o": [
            "Creates CSS selector predicate",
            "Creates directive predicate",
            "Creates component predicate",
            "Nothing"
        ]
    },
    {
        "q": "By.css() is used with query().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this find?",
        "type": "mcq",
        "c": "debugElement.query(By.css('.submit-btn'))",
        "o": [
            "Element with class submit-btn",
            "All buttons",
            "Submit form",
            "Nothing"
        ]
    },
    {
        "q": "By.css() accepts CSS _____ string.",
        "type": "fill_blank",
        "answers": [
            "selector"
        ],
        "other_options": [
            "class",
            "id",
            "tag"
        ]
    },
    {
        "q": "Match By predicates:",
        "type": "match",
        "left": [
            "By.css",
            "By.directive",
            "By.all"
        ],
        "right": [
            "CSS selector",
            "Directive type",
            "All elements"
        ]
    },
    {
        "q": "What is By.directive()?",
        "type": "mcq",
        "o": [
            "Finds elements by directive type",
            "Finds by CSS",
            "Finds by ID",
            "Finds by class"
        ]
    },
    {
        "q": "By.directive() takes directive class.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this find?",
        "type": "mcq",
        "c": "debugElement.query(By.directive(HighlightDirective))",
        "o": [
            "Element with HighlightDirective",
            "All directives",
            "CSS selector",
            "Nothing"
        ]
    },
    {
        "q": "By.directive() finds elements with specific _____.",
        "type": "fill_blank",
        "answers": [
            "directive"
        ],
        "other_options": [
            "component",
            "service",
            "pipe"
        ]
    },
    {
        "q": "Match query patterns:",
        "type": "match",
        "left": [
            "query(By.css('#id'))",
            "query(By.directive(Dir))",
            "queryAll(By.css('.class'))"
        ],
        "right": [
            "Find by ID",
            "Find by directive",
            "Find all by class"
        ]
    },
    {
        "q": "What is triggerEventHandler()?",
        "type": "mcq",
        "o": [
            "Simulates DOM event on element",
            "Creates event",
            "Destroys event",
            "Nothing"
        ]
    },
    {
        "q": "triggerEventHandler fires events on DebugElement.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "button.triggerEventHandler('click', null)",
        "o": [
            "Simulates click on button",
            "Creates button",
            "Destroys button",
            "Nothing"
        ]
    },
    {
        "q": "triggerEventHandler takes event name and _____ object.",
        "type": "fill_blank",
        "answers": [
            "event"
        ],
        "other_options": [
            "element",
            "component",
            "service"
        ]
    },
    {
        "q": "Match event testing:",
        "type": "match",
        "left": [
            "triggerEventHandler",
            "nativeElement.click()",
            "dispatchEvent"
        ],
        "right": [
            "Angular event",
            "DOM click",
            "Custom event"
        ]
    },
    {
        "q": "What is spyOn()?",
        "type": "mcq",
        "o": [
            "Creates a spy on object method",
            "Runs test",
            "Mocks service",
            "Asserts value"
        ]
    },
    {
        "q": "spyOn() tracks method calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "spyOn(service, 'getData')",
        "o": [
            "Spy on getData method",
            "Mock service",
            "Real call",
            "Nothing"
        ]
    },
    {
        "q": "spyOn() replaces method with _____.",
        "type": "fill_blank",
        "answers": [
            "spy"
        ],
        "other_options": [
            "mock",
            "stub",
            "fake"
        ]
    },
    {
        "q": "Match spy methods:",
        "type": "match",
        "left": [
            "spyOn",
            "and.returnValue",
            "and.callThrough"
        ],
        "right": [
            "Create spy",
            "Return fake value",
            "Call original"
        ]
    },
    {
        "q": "What is and.returnValue()?",
        "type": "mcq",
        "o": [
            "Makes spy return specific value",
            "Calls original method",
            "Throws error",
            "Nothing"
        ]
    },
    {
        "q": "and.returnValue() provides fake return.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this return?",
        "type": "mcq",
        "c": "spyOn(service, 'getData').and.returnValue(of([1,2,3]))",
        "o": [
            "Observable of array",
            "Real data",
            "Undefined",
            "Error"
        ]
    },
    {
        "q": "and.returnValue() bypasses _____ implementation.",
        "type": "fill_blank",
        "answers": [
            "real"
        ],
        "other_options": [
            "mock",
            "fake",
            "test"
        ]
    },
    {
        "q": "Match spy configurations:",
        "type": "match",
        "left": [
            "and.returnValue",
            "and.callFake",
            "and.throwError"
        ],
        "right": [
            "Static return",
            "Custom function",
            "Simulate error"
        ]
    },
    {
        "q": "What is toHaveBeenCalled()?",
        "type": "mcq",
        "o": [
            "Checks if spy was called",
            "Checks return value",
            "Creates spy",
            "Destroys spy"
        ]
    },
    {
        "q": "toHaveBeenCalled() verifies spy invocation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this assert?",
        "type": "mcq",
        "c": "expect(spy).toHaveBeenCalled()",
        "o": [
            "Spy was called at least once",
            "Spy returned value",
            "Spy was not called",
            "Nothing"
        ]
    },
    {
        "q": "toHaveBeenCalled() checks if spy was _____.",
        "type": "fill_blank",
        "answers": [
            "invoked"
        ],
        "other_options": [
            "created",
            "destroyed",
            "returned"
        ]
    },
    {
        "q": "Match spy matchers:",
        "type": "match",
        "left": [
            "toHaveBeenCalled",
            "toHaveBeenCalledWith",
            "toHaveBeenCalledTimes"
        ],
        "right": [
            "Was called",
            "Called with args",
            "Called n times"
        ]
    },
    {
        "q": "What is toHaveBeenCalledWith()?",
        "type": "mcq",
        "o": [
            "Checks spy was called with specific arguments",
            "Checks call count",
            "Checks return value",
            "Nothing"
        ]
    },
    {
        "q": "toHaveBeenCalledWith() verifies arguments.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this assert?",
        "type": "mcq",
        "c": "expect(spy).toHaveBeenCalledWith('test', 42)",
        "o": [
            "Spy called with 'test' and 42",
            "Any call happened",
            "Specific return",
            "Nothing"
        ]
    },
    {
        "q": "toHaveBeenCalledWith() checks call _____.",
        "type": "fill_blank",
        "answers": [
            "arguments"
        ],
        "other_options": [
            "count",
            "return",
            "timing"
        ]
    },
    {
        "q": "Match argument matchers:",
        "type": "match",
        "left": [
            "toHaveBeenCalledWith(x)",
            "jasmine.any(String)",
            "jasmine.objectContaining"
        ],
        "right": [
            "Exact match",
            "Type match",
            "Partial object"
        ]
    },
    {
        "q": "What is TestBed.inject()?",
        "type": "mcq",
        "o": [
            "Gets service instance from testing module",
            "Creates service",
            "Mocks service",
            "Nothing"
        ]
    },
    {
        "q": "TestBed.inject() replaces deprecated inject().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this return?",
        "type": "mcq",
        "c": "const service = TestBed.inject(MyService);",
        "o": [
            "Instance of MyService",
            "Mock service",
            "Undefined",
            "Nothing"
        ]
    },
    {
        "q": "TestBed.inject() is used to get _____ instances.",
        "type": "fill_blank",
        "answers": [
            "service"
        ],
        "other_options": [
            "component",
            "module",
            "pipe"
        ]
    },
    {
        "q": "Match injection methods:",
        "type": "match",
        "left": [
            "TestBed.inject(Service)",
            "fixture.debugElement.injector",
            "Component constructor"
        ],
        "right": [
            "Root injector",
            "Element injector",
            "Real DI"
        ]
    },
    {
        "q": "What is HttpClientTestingModule?",
        "type": "mcq",
        "o": [
            "Module for mocking HTTP requests in tests",
            "Real HTTP module",
            "Router module",
            "Forms module"
        ]
    },
    {
        "q": "HttpClientTestingModule replaces HttpClientModule in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does HttpClientTestingModule provide?",
        "type": "mcq",
        "o": [
            "Mock HTTP backend",
            "Real HTTP calls",
            "Router",
            "Forms"
        ]
    },
    {
        "q": "HttpClientTestingModule is from @angular/common/http/_____.",
        "type": "fill_blank",
        "answers": [
            "testing"
        ],
        "other_options": [
            "core",
            "http",
            "mock"
        ]
    },
    {
        "q": "Match HTTP testing:",
        "type": "match",
        "left": [
            "HttpClientTestingModule",
            "HttpTestingController",
            "TestRequest"
        ],
        "right": [
            "Mock module",
            "Request controller",
            "Captured request"
        ]
    },
    {
        "q": "What is HttpTestingController?",
        "type": "mcq",
        "o": [
            "Controls and verifies HTTP requests",
            "Makes real requests",
            "Creates responses",
            "Nothing"
        ]
    },
    {
        "q": "HttpTestingController expects and flushes requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does httpController.expectOne() do?",
        "type": "mcq",
        "o": [
            "Expects exactly one matching request",
            "Makes request",
            "Ignores request",
            "Nothing"
        ]
    },
    {
        "q": "expectOne() matches by _____ or predicate.",
        "type": "fill_blank",
        "answers": [
            "URL"
        ],
        "other_options": [
            "body",
            "header",
            "method"
        ]
    },
    {
        "q": "Match controller methods:",
        "type": "match",
        "left": [
            "expectOne",
            "expectNone",
            "verify"
        ],
        "right": [
            "One request expected",
            "No requests expected",
            "No outstanding requests"
        ]
    },
    {
        "q": "What is req.flush()?",
        "type": "mcq",
        "o": [
            "Provides mock response data",
            "Cancels request",
            "Real response",
            "Nothing"
        ]
    },
    {
        "q": "flush() completes the request with response.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "req.flush({name: 'Test'})",
        "o": [
            "Returns mock JSON response",
            "Errors request",
            "Cancels request",
            "Nothing"
        ]
    },
    {
        "q": "flush() simulates successful _____ response.",
        "type": "fill_blank",
        "answers": [
            "HTTP"
        ],
        "other_options": [
            "error",
            "timeout",
            "cancel"
        ]
    },
    {
        "q": "Match request methods:",
        "type": "match",
        "left": [
            "flush(data)",
            "error(errorEvent)",
            "flush(error, {status: 404})"
        ],
        "right": [
            "Success response",
            "Network error",
            "HTTP error"
        ]
    },
    {
        "q": "What is httpController.verify()?",
        "type": "mcq",
        "o": [
            "Verifies no outstanding requests",
            "Makes requests",
            "Ignores requests",
            "Nothing"
        ]
    },
    {
        "q": "verify() should be called in afterEach.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why call verify()?",
        "type": "mcq",
        "o": [
            "Ensure no unexpected HTTP calls",
            "Make calls",
            "Ignore calls",
            "Nothing"
        ]
    },
    {
        "q": "verify() fails if there are _____ requests.",
        "type": "fill_blank",
        "answers": [
            "outstanding"
        ],
        "other_options": [
            "completed",
            "flushed",
            "no"
        ]
    },
    {
        "q": "Rearrange HTTP test:",
        "type": "rearrange",
        "words": [
            "Configure module with HttpClientTestingModule",
            "Inject service and HttpTestingController",
            "Call service method",
            "expectOne and flush response",
            "verify no outstanding"
        ]
    },
    {
        "q": "What is fakeAsync()?",
        "type": "mcq",
        "o": [
            "Zone for controlling async timing",
            "Real async",
            "Sync only",
            "Nothing"
        ]
    },
    {
        "q": "fakeAsync() simulates passage of time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does fakeAsync enable?",
        "type": "mcq",
        "o": [
            "Synchronous-style async testing",
            "Real timeouts",
            "Network calls",
            "Nothing"
        ]
    },
    {
        "q": "fakeAsync() wraps test _____ function.",
        "type": "fill_blank",
        "answers": [
            "callback"
        ],
        "other_options": [
            "assertion",
            "setup",
            "teardown"
        ]
    },
    {
        "q": "Match async testing:",
        "type": "match",
        "left": [
            "fakeAsync",
            "waitForAsync",
            "done callback"
        ],
        "right": [
            "Simulated time",
            "Real async",
            "Manual callback"
        ]
    },
    {
        "q": "What is tick()?",
        "type": "mcq",
        "o": [
            "Advances simulated time in fakeAsync",
            "Real delay",
            "Stops time",
            "Nothing"
        ]
    },
    {
        "q": "tick() only works inside fakeAsync.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "tick(1000)",
        "o": [
            "Advances time by 1000ms",
            "Waits 1 second",
            "Does nothing",
            "Errors"
        ]
    },
    {
        "q": "tick() advances _____ timers.",
        "type": "fill_blank",
        "answers": [
            "simulated"
        ],
        "other_options": [
            "real",
            "no",
            "all"
        ]
    },
    {
        "q": "Match tick usage:",
        "type": "match",
        "left": [
            "tick()",
            "tick(500)",
            "flush()"
        ],
        "right": [
            "Process microtasks",
            "Advance 500ms",
            "Drain all timers"
        ]
    },
    {
        "q": "What is flush()?",
        "type": "mcq",
        "o": [
            "Drains all pending timers in fakeAsync",
            "Advances one timer",
            "Does nothing",
            "Real delay"
        ]
    },
    {
        "q": "flush() processes all pending async tasks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use flush()?",
        "type": "mcq",
        "o": [
            "When timer duration is unknown",
            "Always",
            "Never",
            "For sync code"
        ]
    },
    {
        "q": "flush() returns total _____ elapsed.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "tasks",
            "timers",
            "callbacks"
        ]
    },
    {
        "q": "Match fakeAsync utilities:",
        "type": "match",
        "left": [
            "tick(n)",
            "flush()",
            "flushMicrotasks()"
        ],
        "right": [
            "Advance n ms",
            "Drain all timers",
            "Process microtasks"
        ]
    },
    {
        "q": "What is waitForAsync()?",
        "type": "mcq",
        "o": [
            "Wrapper for real async operations",
            "Fake async",
            "Sync testing",
            "Nothing"
        ]
    },
    {
        "q": "waitForAsync() replaced async() function.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use waitForAsync()?",
        "type": "mcq",
        "o": [
            "For real HTTP calls in tests",
            "For setTimeout",
            "For sync code",
            "Never"
        ]
    },
    {
        "q": "waitForAsync() waits for async _____ to complete.",
        "type": "fill_blank",
        "answers": [
            "operations"
        ],
        "other_options": [
            "errors",
            "failures",
            "nothing"
        ]
    },
    {
        "q": "Match async approaches:",
        "type": "match",
        "left": [
            "fakeAsync + tick",
            "waitForAsync",
            "done callback"
        ],
        "right": [
            "Simulated timing",
            "Wait for completion",
            "Manual signal"
        ]
    },
    {
        "q": "What is fixture.whenStable()?",
        "type": "mcq",
        "o": [
            "Waits for async operations to complete",
            "Creates fixture",
            "Destroys fixture",
            "Nothing"
        ]
    },
    {
        "q": "whenStable() returns a Promise.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use whenStable()?",
        "type": "mcq",
        "o": [
            "After async operations in component",
            "Always",
            "Never",
            "For sync code"
        ]
    },
    {
        "q": "whenStable() waits for pending _____ tasks.",
        "type": "fill_blank",
        "answers": [
            "async"
        ],
        "other_options": [
            "sync",
            "no",
            "all"
        ]
    },
    {
        "q": "Match stability methods:",
        "type": "match",
        "left": [
            "whenStable()",
            "isStable()"
        ],
        "right": [
            "Wait for stable",
            "Check if stable"
        ]
    },
    {
        "q": "What is done callback?",
        "type": "mcq",
        "o": [
            "Jasmine callback for async tests",
            "Sync callback",
            "Error callback",
            "Nothing"
        ]
    },
    {
        "q": "done() signals async test completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this pattern do?",
        "type": "mcq",
        "c": "it('async test', (done) => { service.get().subscribe(r => { expect(r).toBe(true); done(); }); })",
        "o": [
            "Waits for subscribe callback",
            "Runs sync",
            "Skips test",
            "Nothing"
        ]
    },
    {
        "q": "done() must be called to _____ async test.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "start",
            "skip",
            "fail"
        ]
    },
    {
        "q": "Match async patterns:",
        "type": "match",
        "left": [
            "done()",
            "done.fail()",
            "No done"
        ],
        "right": [
            "Success",
            "Failure",
            "Sync test"
        ]
    },
    {
        "q": "What is a mock service?",
        "type": "mcq",
        "o": [
            "Fake service replacing real implementation",
            "Real service",
            "Component",
            "Module"
        ]
    },
    {
        "q": "Mock services isolate unit tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to provide mock service?",
        "type": "mcq",
        "c": "providers: [{provide: RealService, useClass: MockService}]",
        "o": [
            "Replace with mock class",
            "Use real service",
            "No providers",
            "Import module"
        ]
    },
    {
        "q": "Mock services avoid _____ dependencies.",
        "type": "fill_blank",
        "answers": [
            "external"
        ],
        "other_options": [
            "internal",
            "no",
            "all"
        ]
    },
    {
        "q": "Match mock patterns:",
        "type": "match",
        "left": [
            "useClass",
            "useValue",
            "useFactory"
        ],
        "right": [
            "Mock class",
            "Mock object",
            "Factory function"
        ]
    },
    {
        "q": "What is jasmine.createSpyObj()?",
        "type": "mcq",
        "o": [
            "Creates object with spy methods",
            "Creates real object",
            "Destroys object",
            "Nothing"
        ]
    },
    {
        "q": "createSpyObj() creates mock with multiple spies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "jasmine.createSpyObj('service', ['get', 'post'])",
        "o": [
            "Object with get and post spies",
            "Real service",
            "Empty object",
            "Nothing"
        ]
    },
    {
        "q": "createSpyObj() takes name and _____ array.",
        "type": "fill_blank",
        "answers": [
            "methods"
        ],
        "other_options": [
            "properties",
            "values",
            "nothing"
        ]
    },
    {
        "q": "Match spy creation:",
        "type": "match",
        "left": [
            "spyOn(obj, 'method')",
            "jasmine.createSpy('name')",
            "jasmine.createSpyObj('name', [])"
        ],
        "right": [
            "Spy existing method",
            "Standalone spy",
            "Object with spies"
        ]
    },
    {
        "q": "What is component input testing?",
        "type": "mcq",
        "o": [
            "Testing @Input() properties",
            "Testing outputs",
            "Testing services",
            "Testing routes"
        ]
    },
    {
        "q": "Input properties can be set directly in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test input?",
        "type": "mcq",
        "c": "component.name = 'Test'; fixture.detectChanges();",
        "o": [
            "Set property and detect changes",
            "Call method",
            "Mock service",
            "Nothing"
        ]
    },
    {
        "q": "After setting input, call _____.",
        "type": "fill_blank",
        "answers": [
            "detectChanges"
        ],
        "other_options": [
            "createComponent",
            "inject",
            "nothing"
        ]
    },
    {
        "q": "Match input testing:",
        "type": "match",
        "left": [
            "component.input = value",
            "fixture.detectChanges()",
            "Check template"
        ],
        "right": [
            "Set input",
            "Update view",
            "Verify binding"
        ]
    },
    {
        "q": "What is component output testing?",
        "type": "mcq",
        "o": [
            "Testing @Output() EventEmitter",
            "Testing inputs",
            "Testing services",
            "Testing routes"
        ]
    },
    {
        "q": "Outputs emit events that can be subscribed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test output?",
        "type": "mcq",
        "c": "component.clicked.subscribe(e => expect(e).toBe(true));",
        "o": [
            "Subscribe and trigger event",
            "Set property",
            "Mock service",
            "Nothing"
        ]
    },
    {
        "q": "Output testing requires _____ to event.",
        "type": "fill_blank",
        "answers": [
            "subscribing"
        ],
        "other_options": [
            "setting",
            "mocking",
            "nothing"
        ]
    },
    {
        "q": "Match output testing:",
        "type": "match",
        "left": [
            "Subscribe to output",
            "Trigger action",
            "Assert emitted value"
        ],
        "right": [
            "Listen for event",
            "Click button",
            "Verify data"
        ]
    },
    {
        "q": "What is template testing?",
        "type": "mcq",
        "o": [
            "Testing rendered HTML content",
            "Testing component logic",
            "Testing service",
            "Testing route"
        ]
    },
    {
        "q": "Template testing verifies DOM output.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to check template text?",
        "type": "mcq",
        "c": "expect(element.textContent).toContain('Hello')",
        "o": [
            "Use textContent property",
            "Use innerHTML",
            "Use value",
            "Nothing"
        ]
    },
    {
        "q": "Template testing uses _____ or debugElement.",
        "type": "fill_blank",
        "answers": [
            "nativeElement"
        ],
        "other_options": [
            "component",
            "service",
            "module"
        ]
    },
    {
        "q": "Match template testing:",
        "type": "match",
        "left": [
            "textContent",
            "innerHTML",
            "querySelector"
        ],
        "right": [
            "Text only",
            "HTML content",
            "Find element"
        ]
    },
    {
        "q": "What is testing directive?",
        "type": "mcq",
        "o": [
            "Testing custom directive behavior",
            "Testing component",
            "Testing service",
            "Testing route"
        ]
    },
    {
        "q": "Directives need host components for testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test directive?",
        "type": "mcq",
        "o": [
            "Create test host component",
            "Test directly",
            "Mock directive",
            "Skip testing"
        ]
    },
    {
        "q": "Directive tests use test _____ component.",
        "type": "fill_blank",
        "answers": [
            "host"
        ],
        "other_options": [
            "mock",
            "fake",
            "real"
        ]
    },
    {
        "q": "Match directive testing:",
        "type": "match",
        "left": [
            "Test host component",
            "Apply directive",
            "Check effect"
        ],
        "right": [
            "Container for directive",
            "In template",
            "Verify behavior"
        ]
    },
    {
        "q": "What is testing pipe?",
        "type": "mcq",
        "o": [
            "Testing pipe transform method",
            "Testing component",
            "Testing service",
            "Testing directive"
        ]
    },
    {
        "q": "Pipes can be tested without TestBed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test pipe?",
        "type": "mcq",
        "c": "const pipe = new MyPipe(); expect(pipe.transform('test')).toBe('TEST');",
        "o": [
            "Instantiate and call transform",
            "Use TestBed",
            "Mock pipe",
            "Nothing"
        ]
    },
    {
        "q": "Pipes are tested by calling _____ method.",
        "type": "fill_blank",
        "answers": [
            "transform"
        ],
        "other_options": [
            "pipe",
            "apply",
            "run"
        ]
    },
    {
        "q": "Match pipe testing:",
        "type": "match",
        "left": [
            "Pure pipe",
            "Impure pipe"
        ],
        "right": [
            "Simple unit test",
            "May need TestBed"
        ]
    },
    {
        "q": "What is testing service without dependencies?",
        "type": "mcq",
        "o": [
            "Instantiate service directly",
            "Use TestBed",
            "Mock everything",
            "Skip testing"
        ]
    },
    {
        "q": "Simple services can be tested without TestBed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test simple service?",
        "type": "mcq",
        "c": "const service = new MyService(); expect(service.getValue()).toBe(5);",
        "o": [
            "Create instance and test",
            "Use TestBed always",
            "Mock service",
            "Nothing"
        ]
    },
    {
        "q": "Services without DI are tested by direct _____.",
        "type": "fill_blank",
        "answers": [
            "instantiation"
        ],
        "other_options": [
            "mocking",
            "injection",
            "nothing"
        ]
    },
    {
        "q": "Match service testing:",
        "type": "match",
        "left": [
            "No dependencies",
            "With dependencies"
        ],
        "right": [
            "Direct new",
            "TestBed inject"
        ]
    },
    {
        "q": "What is testing service with HttpClient?",
        "type": "mcq",
        "o": [
            "Using HttpClientTestingModule",
            "Real HTTP calls",
            "No testing",
            "Mock manually"
        ]
    },
    {
        "q": "HttpClient services need HttpClientTestingModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What to inject for HTTP service testing?",
        "type": "mcq",
        "o": [
            "Service and HttpTestingController",
            "Only service",
            "Only controller",
            "Nothing"
        ]
    },
    {
        "q": "HTTP service tests use _____ controller.",
        "type": "fill_blank",
        "answers": [
            "HttpTestingController"
        ],
        "other_options": [
            "HttpClient",
            "HttpModule",
            "nothing"
        ]
    },
    {
        "q": "Rearrange HTTP service test:",
        "type": "rearrange",
        "words": [
            "Import HttpClientTestingModule",
            "Inject service and controller",
            "Call service method",
            "expectOne on URL",
            "flush response and verify"
        ]
    },
    {
        "q": "What is NO_ERRORS_SCHEMA?",
        "type": "mcq",
        "o": [
            "Ignores unknown elements in template",
            "Reports all errors",
            "Stops testing",
            "Nothing"
        ]
    },
    {
        "q": "NO_ERRORS_SCHEMA helps with shallow testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use NO_ERRORS_SCHEMA?",
        "type": "mcq",
        "o": [
            "Testing component without child components",
            "Always",
            "Never",
            "For services"
        ]
    },
    {
        "q": "NO_ERRORS_SCHEMA ignores _____ elements.",
        "type": "fill_blank",
        "answers": [
            "unknown"
        ],
        "other_options": [
            "known",
            "all",
            "no"
        ]
    },
    {
        "q": "Match schemas:",
        "type": "match",
        "left": [
            "NO_ERRORS_SCHEMA",
            "CUSTOM_ELEMENTS_SCHEMA"
        ],
        "right": [
            "Ignore all unknown",
            "Allow custom elements"
        ]
    },
    {
        "q": "What is shallow testing?",
        "type": "mcq",
        "o": [
            "Testing component without child components",
            "Full integration test",
            "E2E testing",
            "No testing"
        ]
    },
    {
        "q": "Shallow tests are faster than deep tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to do shallow testing?",
        "type": "mcq",
        "o": [
            "Use NO_ERRORS_SCHEMA or stub children",
            "Import all modules",
            "Test everything",
            "Skip children"
        ]
    },
    {
        "q": "Shallow testing focuses on _____ component.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "all",
            "no",
            "multiple"
        ]
    },
    {
        "q": "Match testing depth:",
        "type": "match",
        "left": [
            "Shallow",
            "Deep",
            "E2E"
        ],
        "right": [
            "Single component",
            "Component tree",
            "Full app"
        ]
    },
    {
        "q": "What is RouterTestingModule?",
        "type": "mcq",
        "o": [
            "Module for testing routing in isolation",
            "Real routing module",
            "HTTP module",
            "Forms module"
        ]
    },
    {
        "q": "RouterTestingModule replaces RouterModule in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does RouterTestingModule provide?",
        "type": "mcq",
        "o": [
            "Mock router and location",
            "Real navigation",
            "HTTP client",
            "Forms"
        ]
    },
    {
        "q": "RouterTestingModule is from @angular/router/_____.",
        "type": "fill_blank",
        "answers": [
            "testing"
        ],
        "other_options": [
            "core",
            "module",
            "mock"
        ]
    },
    {
        "q": "Match router testing:",
        "type": "match",
        "left": [
            "RouterTestingModule",
            "SpyLocation",
            "MockActivatedRoute"
        ],
        "right": [
            "Mock router",
            "Mock location",
            "Mock route"
        ]
    },
    {
        "q": "What is testing route guards?",
        "type": "mcq",
        "o": [
            "Testing canActivate, canDeactivate, etc.",
            "Testing components",
            "Testing services",
            "Testing pipes"
        ]
    },
    {
        "q": "Guards can be tested like services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test canActivate guard?",
        "type": "mcq",
        "o": [
            "Instantiate guard and call canActivate",
            "Use RouterTestingModule only",
            "Skip testing",
            "Mock everything"
        ]
    },
    {
        "q": "Guards return boolean or _____.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "string",
            "number",
            "nothing"
        ]
    },
    {
        "q": "Match guard testing:",
        "type": "match",
        "left": [
            "canActivate",
            "canDeactivate",
            "resolve"
        ],
        "right": [
            "Check access",
            "Confirm leave",
            "Pre-fetch data"
        ]
    },
    {
        "q": "What is testing resolvers?",
        "type": "mcq",
        "o": [
            "Testing route data pre-fetching",
            "Testing components",
            "Testing guards",
            "Testing services"
        ]
    },
    {
        "q": "Resolvers return data for routes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test resolver?",
        "type": "mcq",
        "o": [
            "Call resolve() and verify data",
            "Skip testing",
            "Mock route only",
            "Nothing"
        ]
    },
    {
        "q": "Resolvers can return _____ or Observable.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "void",
            "nothing",
            "error"
        ]
    },
    {
        "q": "Match resolver testing:",
        "type": "match",
        "left": [
            "Mock dependencies",
            "Call resolve()",
            "Verify result"
        ],
        "right": [
            "Inject mocks",
            "Execute resolver",
            "Check data"
        ]
    },
    {
        "q": "What is Router.navigate testing?",
        "type": "mcq",
        "o": [
            "Testing navigation trigger",
            "Testing components",
            "Testing services",
            "Testing pipes"
        ]
    },
    {
        "q": "Router navigation can be spied on.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to verify navigation?",
        "type": "mcq",
        "c": "spyOn(router, 'navigate')",
        "o": [
            "Spy on router.navigate",
            "Real navigation",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Spy on navigate to verify _____ calls.",
        "type": "fill_blank",
        "answers": [
            "navigation"
        ],
        "other_options": [
            "service",
            "component",
            "nothing"
        ]
    },
    {
        "q": "Match navigation testing:",
        "type": "match",
        "left": [
            "spyOn(router, 'navigate')",
            "toHaveBeenCalledWith(['/path'])"
        ],
        "right": [
            "Capture navigation",
            "Verify route"
        ]
    },
    {
        "q": "What is ActivatedRoute mocking?",
        "type": "mcq",
        "o": [
            "Providing fake route params/data",
            "Real route",
            "No mocking",
            "Component"
        ]
    },
    {
        "q": "ActivatedRoute can be mocked with stub.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to mock route params?",
        "type": "mcq",
        "c": "{provide: ActivatedRoute, useValue: {params: of({id: 1})}}",
        "o": [
            "Provide mock ActivatedRoute",
            "Use real route",
            "Skip params",
            "Nothing"
        ]
    },
    {
        "q": "Mock ActivatedRoute using _____ provider.",
        "type": "fill_blank",
        "answers": [
            "useValue"
        ],
        "other_options": [
            "useClass",
            "useFactory",
            "nothing"
        ]
    },
    {
        "q": "Match route mocking:",
        "type": "match",
        "left": [
            "params",
            "queryParams",
            "data"
        ],
        "right": [
            "Route params",
            "Query string",
            "Resolved data"
        ]
    },
    {
        "q": "What is integration testing?",
        "type": "mcq",
        "o": [
            "Testing multiple units together",
            "Unit testing",
            "E2E testing",
            "No testing"
        ]
    },
    {
        "q": "Integration tests verify component interactions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to do integration testing?",
        "type": "mcq",
        "o": [
            "Include real child components",
            "Mock everything",
            "Use NO_ERRORS_SCHEMA",
            "Skip children"
        ]
    },
    {
        "q": "Integration tests are _____ than unit tests.",
        "type": "fill_blank",
        "answers": [
            "slower"
        ],
        "other_options": [
            "faster",
            "same",
            "shorter"
        ]
    },
    {
        "q": "Match test types:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "E2E"
        ],
        "right": [
            "Isolated",
            "Combined",
            "Full app"
        ]
    },
    {
        "q": "What is testing with real services?",
        "type": "mcq",
        "o": [
            "Using actual service in tests",
            "Always mock",
            "No services",
            "Components only"
        ]
    },
    {
        "q": "Real services can be used in integration tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use real services?",
        "type": "mcq",
        "o": [
            "Testing service-component integration",
            "Always",
            "Never",
            "Unit tests only"
        ]
    },
    {
        "q": "Real services test actual _____ flow.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "mock",
            "fake",
            "nothing"
        ]
    },
    {
        "q": "Match service usage:",
        "type": "match",
        "left": [
            "Unit test",
            "Integration test"
        ],
        "right": [
            "Mock service",
            "Real service"
        ]
    },
    {
        "q": "What is ComponentHarness?",
        "type": "mcq",
        "o": [
            "API for testing component interactions",
            "Component fixture",
            "Test runner",
            "Mock library"
        ]
    },
    {
        "q": "ComponentHarness is from @angular/cdk/testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ComponentHarness provide?",
        "type": "mcq",
        "o": [
            "Stable selectors and async API",
            "Sync testing only",
            "Mock components",
            "Nothing"
        ]
    },
    {
        "q": "ComponentHarness abstracts _____ implementation.",
        "type": "fill_blank",
        "answers": [
            "DOM"
        ],
        "other_options": [
            "service",
            "module",
            "pipe"
        ]
    },
    {
        "q": "Match harness concepts:",
        "type": "match",
        "left": [
            "ComponentHarness",
            "HarnessLoader",
            "TestElement"
        ],
        "right": [
            "Test API",
            "Harness loader",
            "DOM wrapper"
        ]
    },
    {
        "q": "What is HarnessLoader?",
        "type": "mcq",
        "o": [
            "Loads component harnesses",
            "Creates components",
            "Mocks services",
            "Nothing"
        ]
    },
    {
        "q": "HarnessLoader finds harnesses in DOM.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to get HarnessLoader?",
        "type": "mcq",
        "c": "TestbedHarnessEnvironment.loader(fixture)",
        "o": [
            "From TestbedHarnessEnvironment",
            "Direct instantiation",
            "Injection",
            "Nothing"
        ]
    },
    {
        "q": "HarnessLoader finds harnesses by _____ or selector.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "name",
            "id",
            "nothing"
        ]
    },
    {
        "q": "Match harness methods:",
        "type": "match",
        "left": [
            "getHarness",
            "getAllHarnesses",
            "getChildLoader"
        ],
        "right": [
            "Get single",
            "Get all",
            "Nested loader"
        ]
    },
    {
        "q": "What is code coverage?",
        "type": "mcq",
        "o": [
            "Percentage of code executed by tests",
            "Number of tests",
            "Test speed",
            "Nothing"
        ]
    },
    {
        "q": "Code coverage shows tested code percentage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to generate coverage?",
        "type": "mcq",
        "c": "ng test --code-coverage",
        "o": [
            "Use --code-coverage flag",
            "Automatic",
            "Manual calculation",
            "Nothing"
        ]
    },
    {
        "q": "Coverage report shows lines, branches, and _____.",
        "type": "fill_blank",
        "answers": [
            "functions"
        ],
        "other_options": [
            "classes",
            "modules",
            "nothing"
        ]
    },
    {
        "q": "Match coverage metrics:",
        "type": "match",
        "left": [
            "Line coverage",
            "Branch coverage",
            "Function coverage"
        ],
        "right": [
            "% lines run",
            "% conditions",
            "% functions called"
        ]
    },
    {
        "q": "What is coverage threshold?",
        "type": "mcq",
        "o": [
            "Minimum required coverage percentage",
            "Maximum tests",
            "Test speed limit",
            "Nothing"
        ]
    },
    {
        "q": "Thresholds can fail builds on low coverage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Where to set coverage thresholds?",
        "type": "mcq",
        "o": [
            "karma.conf.js or angular.json",
            "No configuration",
            "In code",
            "Nothing"
        ]
    },
    {
        "q": "Coverage thresholds enforce _____ standards.",
        "type": "fill_blank",
        "answers": [
            "quality"
        ],
        "other_options": [
            "speed",
            "size",
            "nothing"
        ]
    },
    {
        "q": "Match threshold settings:",
        "type": "match",
        "left": [
            "global threshold",
            "per-file threshold"
        ],
        "right": [
            "Overall minimum",
            "File-level minimum"
        ]
    },
    {
        "q": "What is Jest?",
        "type": "mcq",
        "o": [
            "Alternative testing framework to Jasmine",
            "Test runner only",
            "E2E tool",
            "Nothing"
        ]
    },
    {
        "q": "Jest can replace Jasmine + Karma.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does Jest provide?",
        "type": "mcq",
        "o": [
            "Faster tests, snapshot testing, built-in mocks",
            "Only assertions",
            "Only runner",
            "Nothing"
        ]
    },
    {
        "q": "Jest is popular alternative to _____.",
        "type": "fill_blank",
        "answers": [
            "Jasmine"
        ],
        "other_options": [
            "Mocha",
            "Protractor",
            "nothing"
        ]
    },
    {
        "q": "Match testing tools:",
        "type": "match",
        "left": [
            "Jest",
            "Jasmine",
            "Karma"
        ],
        "right": [
            "Framework + runner",
            "Framework only",
            "Runner only"
        ]
    },
    {
        "q": "What is snapshot testing?",
        "type": "mcq",
        "o": [
            "Comparing output to saved snapshot",
            "Screenshot testing",
            "Visual testing",
            "Nothing"
        ]
    },
    {
        "q": "Snapshots detect unexpected changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to use snapshots?",
        "type": "mcq",
        "c": "expect(component).toMatchSnapshot()",
        "o": [
            "Use toMatchSnapshot matcher",
            "Manual comparison",
            "Visual check",
            "Nothing"
        ]
    },
    {
        "q": "Snapshots are stored as _____ files.",
        "type": "fill_blank",
        "answers": [
            "snap"
        ],
        "other_options": [
            "json",
            "txt",
            "nothing"
        ]
    },
    {
        "q": "Match snapshot concepts:",
        "type": "match",
        "left": [
            "First run",
            "Subsequent runs",
            "Update snapshots"
        ],
        "right": [
            "Creates snapshot",
            "Compares to saved",
            "-u flag"
        ]
    },
    {
        "q": "What is test isolation?",
        "type": "mcq",
        "o": [
            "Tests don't affect each other",
            "Tests share state",
            "No tests",
            "Nothing"
        ]
    },
    {
        "q": "Each test should be independent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to ensure isolation?",
        "type": "mcq",
        "o": [
            "Reset state in beforeEach",
            "Share state",
            "Skip setup",
            "Nothing"
        ]
    },
    {
        "q": "Isolation prevents _____ between tests.",
        "type": "fill_blank",
        "answers": [
            "interference"
        ],
        "other_options": [
            "running",
            "passing",
            "nothing"
        ]
    },
    {
        "q": "Match isolation patterns:",
        "type": "match",
        "left": [
            "beforeEach setup",
            "afterEach cleanup",
            "Fresh instances"
        ],
        "right": [
            "Reset state",
            "Clean resources",
            "No shared refs"
        ]
    },
    {
        "q": "What is marbles testing?",
        "type": "mcq",
        "o": [
            "Testing RxJS with marble diagrams",
            "Visual testing",
            "Screenshot testing",
            "Nothing"
        ]
    },
    {
        "q": "Marbles test Observable timing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does marble syntax represent?",
        "type": "mcq",
        "c": "-a-b-c|",
        "o": [
            "Time frames and emissions",
            "Just values",
            "Errors only",
            "Nothing"
        ]
    },
    {
        "q": "Marble testing uses _____ notation.",
        "type": "fill_blank",
        "answers": [
            "ASCII"
        ],
        "other_options": [
            "JSON",
            "XML",
            "nothing"
        ]
    },
    {
        "q": "Match marble symbols:",
        "type": "match",
        "left": [
            "-",
            "a",
            "|",
            "#"
        ],
        "right": [
            "Time frame",
            "Value",
            "Complete",
            "Error"
        ]
    },
    {
        "q": "What is TestScheduler?",
        "type": "mcq",
        "o": [
            "RxJS scheduler for marble testing",
            "Test runner",
            "Framework",
            "Nothing"
        ]
    },
    {
        "q": "TestScheduler controls virtual time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to use TestScheduler?",
        "type": "mcq",
        "c": "scheduler.run(({expectObservable}) => { ... })",
        "o": [
            "Run with callback",
            "Direct use",
            "Injection",
            "Nothing"
        ]
    },
    {
        "q": "TestScheduler provides _____ Observable testing.",
        "type": "fill_blank",
        "answers": [
            "synchronous"
        ],
        "other_options": [
            "async",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match scheduler methods:",
        "type": "match",
        "left": [
            "run()",
            "expectObservable()",
            "cold()"
        ],
        "right": [
            "Execute test",
            "Assert stream",
            "Create cold obs"
        ]
    },
    {
        "q": "What is testing with ng-mocks?",
        "type": "mcq",
        "o": [
            "Library for mocking Angular dependencies",
            "Built-in Angular",
            "Test runner",
            "Nothing"
        ]
    },
    {
        "q": "ng-mocks simplifies mock creation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ng-mocks provide?",
        "type": "mcq",
        "o": [
            "MockComponent, MockService, MockModule",
            "Only spies",
            "Only TestBed",
            "Nothing"
        ]
    },
    {
        "q": "ng-mocks auto-generates _____ mocks.",
        "type": "fill_blank",
        "answers": [
            "component"
        ],
        "other_options": [
            "service",
            "nothing",
            "test"
        ]
    },
    {
        "q": "Match ng-mocks utilities:",
        "type": "match",
        "left": [
            "MockComponent",
            "MockService",
            "MockModule"
        ],
        "right": [
            "Mock component",
            "Mock service",
            "Mock module"
        ]
    },
    {
        "q": "What is testing error handling?",
        "type": "mcq",
        "o": [
            "Testing how app handles errors",
            "Testing success only",
            "No error tests",
            "Nothing"
        ]
    },
    {
        "q": "Error paths should be tested.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test errors?",
        "type": "mcq",
        "o": [
            "Mock service to throw or return error",
            "Skip errors",
            "Only test success",
            "Nothing"
        ]
    },
    {
        "q": "Error testing verifies _____ handling.",
        "type": "fill_blank",
        "answers": [
            "exception"
        ],
        "other_options": [
            "success",
            "nothing",
            "all"
        ]
    },
    {
        "q": "Match error testing:",
        "type": "match",
        "left": [
            "throwError()",
            "catchError",
            "error message display"
        ],
        "right": [
            "Simulate error",
            "Handle error",
            "UI feedback"
        ]
    },
    {
        "q": "What is testing observables?",
        "type": "mcq",
        "o": [
            "Testing async streams",
            "Testing sync code",
            "Testing components only",
            "Nothing"
        ]
    },
    {
        "q": "Observable tests verify emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test Observable?",
        "type": "mcq",
        "c": "service.get().subscribe(v => expect(v).toBe(expected))",
        "o": [
            "Subscribe and assert",
            "Direct comparison",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Observable tests often use _____ callback.",
        "type": "fill_blank",
        "answers": [
            "done"
        ],
        "other_options": [
            "fail",
            "skip",
            "nothing"
        ]
    },
    {
        "q": "Match Observable testing:",
        "type": "match",
        "left": [
            "subscribe in test",
            "marbles",
            "firstValueFrom"
        ],
        "right": [
            "Manual assertion",
            "Time-based testing",
            "Promise conversion"
        ]
    },
    {
        "q": "What is testing animations?",
        "type": "mcq",
        "o": [
            "Testing Angular animations behavior",
            "Testing components only",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Animations can be disabled in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to disable animations?",
        "type": "mcq",
        "c": "imports: [NoopAnimationsModule]",
        "o": [
            "Use NoopAnimationsModule",
            "Remove animations",
            "Skip tests",
            "Nothing"
        ]
    },
    {
        "q": "NoopAnimationsModule provides _____ animations.",
        "type": "fill_blank",
        "answers": [
            "no-op"
        ],
        "other_options": [
            "real",
            "slow",
            "nothing"
        ]
    },
    {
        "q": "Match animation testing:",
        "type": "match",
        "left": [
            "NoopAnimationsModule",
            "BrowserAnimationsModule"
        ],
        "right": [
            "Skip animations",
            "Real animations"
        ]
    },
    {
        "q": "What is AAA pattern?",
        "type": "mcq",
        "o": [
            "Arrange, Act, Assert",
            "Assert, Act, Arrange",
            "Act, Arrange, Assert",
            "Nothing"
        ]
    },
    {
        "q": "AAA is common test structure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Arrange phase?",
        "type": "mcq",
        "o": [
            "Setup test preconditions",
            "Run test action",
            "Verify result",
            "Nothing"
        ]
    },
    {
        "q": "AAA stands for Arrange, Act, _____.",
        "type": "fill_blank",
        "answers": [
            "Assert"
        ],
        "other_options": [
            "Assume",
            "Access",
            "nothing"
        ]
    },
    {
        "q": "Match AAA phases:",
        "type": "match",
        "left": [
            "Arrange",
            "Act",
            "Assert"
        ],
        "right": [
            "Setup",
            "Execute",
            "Verify"
        ]
    },
    {
        "q": "What is test naming?",
        "type": "mcq",
        "o": [
            "Descriptive names for tests",
            "Random names",
            "No names",
            "Nothing"
        ]
    },
    {
        "q": "Test names should describe behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good test name?",
        "type": "mcq",
        "c": "it('should return empty array when no items')",
        "o": [
            "Describes expected behavior",
            "Just 'test1'",
            "Random string",
            "Nothing"
        ]
    },
    {
        "q": "Good test names start with _____.",
        "type": "fill_blank",
        "answers": [
            "should"
        ],
        "other_options": [
            "test",
            "check",
            "nothing"
        ]
    },
    {
        "q": "Match naming patterns:",
        "type": "match",
        "left": [
            "should do X when Y",
            "test feature",
            "methodName returns"
        ],
        "right": [
            "Behavior-driven",
            "Too vague",
            "Implementation focus"
        ]
    },
    {
        "q": "What is testing forms?",
        "type": "mcq",
        "o": [
            "Testing reactive and template forms",
            "Testing components only",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Form testing verifies validation and values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test reactive form?",
        "type": "mcq",
        "c": "component.form.setValue({name: 'test'}); expect(component.form.valid).toBe(true);",
        "o": [
            "Set values and check validity",
            "Skip form tests",
            "Mock form",
            "Nothing"
        ]
    },
    {
        "q": "Form tests check _____ and values.",
        "type": "fill_blank",
        "answers": [
            "validation"
        ],
        "other_options": [
            "rendering",
            "styling",
            "nothing"
        ]
    },
    {
        "q": "Match form testing:",
        "type": "match",
        "left": [
            "setValue()",
            "valid/invalid",
            "errors"
        ],
        "right": [
            "Set form values",
            "Check validity",
            "Validation errors"
        ]
    },
    {
        "q": "What is testing form controls?",
        "type": "mcq",
        "o": [
            "Testing individual FormControl instances",
            "Testing full form only",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "FormControl can be tested independently.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test FormControl?",
        "type": "mcq",
        "c": "const control = new FormControl('', Validators.required); expect(control.valid).toBe(false);",
        "o": [
            "Create control and test validation",
            "Use full form",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "FormControl tests verify _____ independently.",
        "type": "fill_blank",
        "answers": [
            "validators"
        ],
        "other_options": [
            "services",
            "components",
            "nothing"
        ]
    },
    {
        "q": "Match control testing:",
        "type": "match",
        "left": [
            "control.setValue()",
            "control.valid",
            "control.errors"
        ],
        "right": [
            "Set value",
            "Check validity",
            "Get errors"
        ]
    },
    {
        "q": "What is testing NgRx?",
        "type": "mcq",
        "o": [
            "Testing store, actions, reducers, effects, selectors",
            "Testing components only",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "NgRx provides testing utilities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is provideMockStore?",
        "type": "mcq",
        "o": [
            "Provides mock store for testing",
            "Real store",
            "Component mock",
            "Nothing"
        ]
    },
    {
        "q": "NgRx testing uses _____ store.",
        "type": "fill_blank",
        "answers": [
            "mock"
        ],
        "other_options": [
            "real",
            "fake",
            "nothing"
        ]
    },
    {
        "q": "Match NgRx testing:",
        "type": "match",
        "left": [
            "provideMockStore",
            "provideMockActions",
            "overrideSelector"
        ],
        "right": [
            "Mock store",
            "Mock actions",
            "Override selector"
        ]
    },
    {
        "q": "What is E2E testing?",
        "type": "mcq",
        "o": [
            "End-to-end testing of complete application",
            "Unit testing",
            "Integration testing",
            "Nothing"
        ]
    },
    {
        "q": "E2E tests verify full user flows.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What do E2E tests verify?",
        "type": "mcq",
        "o": [
            "Complete user journeys through app",
            "Single functions",
            "Individual components",
            "Nothing"
        ]
    },
    {
        "q": "E2E tests run against _____ application.",
        "type": "fill_blank",
        "answers": [
            "running"
        ],
        "other_options": [
            "compiled",
            "mocked",
            "nothing"
        ]
    },
    {
        "q": "Match test types:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "E2E"
        ],
        "right": [
            "Function level",
            "Component level",
            "User flow level"
        ]
    },
    {
        "q": "What is Cypress?",
        "type": "mcq",
        "o": [
            "Modern E2E testing framework",
            "Unit test framework",
            "Angular CLI tool",
            "Nothing"
        ]
    },
    {
        "q": "Cypress runs in browser.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does Cypress provide?",
        "type": "mcq",
        "o": [
            "Time-travel debugging, automatic waiting",
            "Only assertions",
            "Only runner",
            "Nothing"
        ]
    },
    {
        "q": "Cypress has built-in _____ waiting.",
        "type": "fill_blank",
        "answers": [
            "automatic"
        ],
        "other_options": [
            "manual",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match Cypress features:",
        "type": "match",
        "left": [
            "cy.visit()",
            "cy.get()",
            "cy.contains()"
        ],
        "right": [
            "Navigate to URL",
            "Select element",
            "Find by text"
        ]
    },
    {
        "q": "What is Playwright?",
        "type": "mcq",
        "o": [
            "Cross-browser E2E testing framework",
            "Unit testing only",
            "Angular specific",
            "Nothing"
        ]
    },
    {
        "q": "Playwright supports multiple browsers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What browsers does Playwright support?",
        "type": "mcq",
        "o": [
            "Chromium, Firefox, WebKit",
            "Chrome only",
            "Firefox only",
            "Nothing"
        ]
    },
    {
        "q": "Playwright is from _____.",
        "type": "fill_blank",
        "answers": [
            "Microsoft"
        ],
        "other_options": [
            "Google",
            "Facebook",
            "nothing"
        ]
    },
    {
        "q": "Match E2E tools:",
        "type": "match",
        "left": [
            "Cypress",
            "Playwright",
            "Protractor"
        ],
        "right": [
            "Browser-based",
            "Cross-browser",
            "Deprecated"
        ]
    },
    {
        "q": "What is testing standalone components?",
        "type": "mcq",
        "o": [
            "Testing components without NgModule",
            "Testing NgModule components",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Standalone components simplify test setup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test standalone component?",
        "type": "mcq",
        "o": [
            "Import dependencies directly in test",
            "Create NgModule",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Standalone tests don't need _____.",
        "type": "fill_blank",
        "answers": [
            "NgModule"
        ],
        "other_options": [
            "TestBed",
            "fixture",
            "nothing"
        ]
    },
    {
        "q": "Match standalone testing:",
        "type": "match",
        "left": [
            "imports in component",
            "imports in test config"
        ],
        "right": [
            "Component deps",
            "Test deps"
        ]
    },
    {
        "q": "What is testing signals?",
        "type": "mcq",
        "o": [
            "Testing Angular Signals behavior",
            "Testing Observables",
            "Testing events",
            "Nothing"
        ]
    },
    {
        "q": "Signals are synchronous in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test signal?",
        "type": "mcq",
        "c": "const count = signal(0); count.set(5); expect(count()).toBe(5);",
        "o": [
            "Set and read synchronously",
            "Use async",
            "Mock signal",
            "Nothing"
        ]
    },
    {
        "q": "Signal tests are _____.",
        "type": "fill_blank",
        "answers": [
            "synchronous"
        ],
        "other_options": [
            "async",
            "complex",
            "nothing"
        ]
    },
    {
        "q": "Match signal testing:",
        "type": "match",
        "left": [
            "signal()",
            "computed()",
            "effect()"
        ],
        "right": [
            "Writable signal",
            "Derived signal",
            "Side effect"
        ]
    },
    {
        "q": "What is testing computed signals?",
        "type": "mcq",
        "o": [
            "Testing derived signal values",
            "Testing writable signals",
            "Testing effects",
            "Nothing"
        ]
    },
    {
        "q": "Computed signals update automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test computed?",
        "type": "mcq",
        "c": "const count = signal(2); const double = computed(() => count() * 2); expect(double()).toBe(4);",
        "o": [
            "Read computed after changing source",
            "Mock computed",
            "Async wait",
            "Nothing"
        ]
    },
    {
        "q": "Computed signals _____ on dependency change.",
        "type": "fill_blank",
        "answers": [
            "recompute"
        ],
        "other_options": [
            "cache",
            "ignore",
            "nothing"
        ]
    },
    {
        "q": "Match signal types:",
        "type": "match",
        "left": [
            "Writable signal",
            "Computed signal"
        ],
        "right": [
            "Can set value",
            "Derived only"
        ]
    },
    {
        "q": "What is testing effects?",
        "type": "mcq",
        "o": [
            "Testing signal side effects",
            "Testing computed",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Effects run when signals change.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test effect?",
        "type": "mcq",
        "o": [
            "Trigger signal change and verify side effect",
            "Mock effect",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Effects cause _____ when signals change.",
        "type": "fill_blank",
        "answers": [
            "side effects"
        ],
        "other_options": [
            "nothing",
            "errors",
            "delays"
        ]
    },
    {
        "q": "Match effect testing:",
        "type": "match",
        "left": [
            "Change signal",
            "TestBed.flushEffects()"
        ],
        "right": [
            "Trigger effect",
            "Run pending effects"
        ]
    },
    {
        "q": "What is flushEffects?",
        "type": "mcq",
        "o": [
            "Runs pending signal effects in tests",
            "Clears effects",
            "Deletes effects",
            "Nothing"
        ]
    },
    {
        "q": "flushEffects() is for testing effects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use flushEffects()?",
        "type": "mcq",
        "o": [
            "After signal changes to run effects",
            "Always",
            "Never",
            "Before changes"
        ]
    },
    {
        "q": "flushEffects() runs _____ effects.",
        "type": "fill_blank",
        "answers": [
            "pending"
        ],
        "other_options": [
            "all",
            "no",
            "old"
        ]
    },
    {
        "q": "Match effect utilities:",
        "type": "match",
        "left": [
            "flushEffects()",
            "effect()"
        ],
        "right": [
            "Run pending",
            "Create effect"
        ]
    },
    {
        "q": "What is testing with inject function?",
        "type": "mcq",
        "o": [
            "Testing code using inject() for DI",
            "Old injection",
            "No DI",
            "Nothing"
        ]
    },
    {
        "q": "inject() works in tests with proper context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test inject-based code?",
        "type": "mcq",
        "o": [
            "Use runInInjectionContext",
            "Direct call",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "inject() requires injection _____.",
        "type": "fill_blank",
        "answers": [
            "context"
        ],
        "other_options": [
            "token",
            "nothing",
            "scope"
        ]
    },
    {
        "q": "Match inject testing:",
        "type": "match",
        "left": [
            "runInInjectionContext",
            "TestBed.inject"
        ],
        "right": [
            "Provide context",
            "Get service"
        ]
    },
    {
        "q": "What is testing defer blocks?",
        "type": "mcq",
        "o": [
            "Testing @defer template syntax",
            "Testing async code",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Defer blocks can be tested.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers defer content?",
        "type": "mcq",
        "o": [
            "Visibility, interaction, or timer",
            "Always immediate",
            "Never",
            "Nothing"
        ]
    },
    {
        "q": "@defer loads content _____ in tests.",
        "type": "fill_blank",
        "answers": [
            "conditionally"
        ],
        "other_options": [
            "always",
            "never",
            "nothing"
        ]
    },
    {
        "q": "Match defer testing:",
        "type": "match",
        "left": [
            "@defer",
            "@placeholder",
            "@loading"
        ],
        "right": [
            "Lazy content",
            "Before load",
            "While loading"
        ]
    },
    {
        "q": "What is testing with providers?",
        "type": "mcq",
        "o": [
            "Configuring test providers",
            "No providers",
            "Real services only",
            "Nothing"
        ]
    },
    {
        "q": "Test providers override real providers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to override provider?",
        "type": "mcq",
        "c": "providers: [{provide: Service, useClass: MockService}]",
        "o": [
            "Use provide in test config",
            "No override",
            "Always real",
            "Nothing"
        ]
    },
    {
        "q": "Test providers replace _____ in module.",
        "type": "fill_blank",
        "answers": [
            "production"
        ],
        "other_options": [
            "test",
            "mock",
            "nothing"
        ]
    },
    {
        "q": "Match provider patterns:",
        "type": "match",
        "left": [
            "provide",
            "useClass",
            "useValue"
        ],
        "right": [
            "Token",
            "Class implementation",
            "Static value"
        ]
    },
    {
        "q": "What is overrideComponent?",
        "type": "mcq",
        "o": [
            "TestBed method to modify component config",
            "Creates component",
            "Destroys component",
            "Nothing"
        ]
    },
    {
        "q": "overrideComponent changes component metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can overrideComponent change?",
        "type": "mcq",
        "o": [
            "Template, providers, imports",
            "Only template",
            "Only providers",
            "Nothing"
        ]
    },
    {
        "q": "overrideComponent changes _____ for testing.",
        "type": "fill_blank",
        "answers": [
            "metadata"
        ],
        "other_options": [
            "logic",
            "style",
            "nothing"
        ]
    },
    {
        "q": "Match override methods:",
        "type": "match",
        "left": [
            "overrideComponent",
            "overrideModule",
            "overrideDirective"
        ],
        "right": [
            "Component config",
            "Module config",
            "Directive config"
        ]
    },
    {
        "q": "What is testing lazy loaded modules?",
        "type": "mcq",
        "o": [
            "Testing modules loaded on demand",
            "Testing eager modules",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Lazy modules can be tested with RouterTestingModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test lazy route?",
        "type": "mcq",
        "o": [
            "Configure route with loadChildren in test",
            "Skip lazy testing",
            "Only test eager",
            "Nothing"
        ]
    },
    {
        "q": "Lazy modules test _____ loading behavior.",
        "type": "fill_blank",
        "answers": [
            "dynamic"
        ],
        "other_options": [
            "static",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match lazy testing:",
        "type": "match",
        "left": [
            "loadChildren",
            "loadComponent"
        ],
        "right": [
            "Lazy module",
            "Lazy component"
        ]
    },
    {
        "q": "What is testing interceptors?",
        "type": "mcq",
        "o": [
            "Testing HTTP interceptors",
            "Testing components",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Interceptors modify HTTP requests/responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test interceptor?",
        "type": "mcq",
        "o": [
            "Use HttpClientTestingModule with interceptor",
            "Skip testing",
            "Mock interceptor",
            "Nothing"
        ]
    },
    {
        "q": "Interceptors test request _____ behavior.",
        "type": "fill_blank",
        "answers": [
            "modification"
        ],
        "other_options": [
            "creation",
            "deletion",
            "nothing"
        ]
    },
    {
        "q": "Match interceptor testing:",
        "type": "match",
        "left": [
            "HTTP_INTERCEPTORS",
            "TestRequest"
        ],
        "right": [
            "Register interceptor",
            "Verify request"
        ]
    },
    {
        "q": "What is testing async validators?",
        "type": "mcq",
        "o": [
            "Testing validators returning Observable/Promise",
            "Testing sync validators",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Async validators need async testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test async validator?",
        "type": "mcq",
        "o": [
            "Use fakeAsync or waitForAsync",
            "Sync test",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Async validators check after _____ completes.",
        "type": "fill_blank",
        "answers": [
            "async operation"
        ],
        "other_options": [
            "sync check",
            "nothing",
            "timeout"
        ]
    },
    {
        "q": "Match validator testing:",
        "type": "match",
        "left": [
            "Sync validator",
            "Async validator"
        ],
        "right": [
            "Immediate result",
            "Delayed result"
        ]
    },
    {
        "q": "What is testing custom matchers?",
        "type": "mcq",
        "o": [
            "Creating project-specific Jasmine matchers",
            "Using built-in only",
            "No matchers",
            "Nothing"
        ]
    },
    {
        "q": "Custom matchers improve test readability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to create custom matcher?",
        "type": "mcq",
        "o": [
            "Use jasmine.addMatchers",
            "Modify Jasmine core",
            "Not possible",
            "Nothing"
        ]
    },
    {
        "q": "Custom matchers add domain-specific _____.",
        "type": "fill_blank",
        "answers": [
            "assertions"
        ],
        "other_options": [
            "tests",
            "mocks",
            "nothing"
        ]
    },
    {
        "q": "Match matcher patterns:",
        "type": "match",
        "left": [
            "addMatchers",
            "compare function"
        ],
        "right": [
            "Register matcher",
            "Comparison logic"
        ]
    },
    {
        "q": "What is test debugging?",
        "type": "mcq",
        "o": [
            "Finding and fixing test failures",
            "Writing tests",
            "Skipping tests",
            "Nothing"
        ]
    },
    {
        "q": "Browser DevTools help debug tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to debug tests?",
        "type": "mcq",
        "o": [
            "Use debugger statement, browser tools",
            "No debugging",
            "Read code only",
            "Nothing"
        ]
    },
    {
        "q": "fit() runs _____ test for debugging.",
        "type": "fill_blank",
        "answers": [
            "focused"
        ],
        "other_options": [
            "all",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match debug patterns:",
        "type": "match",
        "left": [
            "fit()",
            "fdescribe()",
            "debugger"
        ],
        "right": [
            "Focus test",
            "Focus suite",
            "Breakpoint"
        ]
    },
    {
        "q": "What is test selection?",
        "type": "mcq",
        "o": [
            "Running specific tests",
            "Running all tests",
            "Skipping tests",
            "Nothing"
        ]
    },
    {
        "q": "fit() runs only focused tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to skip test?",
        "type": "mcq",
        "c": "xit('should be skipped', () => {})",
        "o": [
            "Use xit() or xdescribe()",
            "Delete test",
            "Comment out",
            "Nothing"
        ]
    },
    {
        "q": "xit() _____ the test temporarily.",
        "type": "fill_blank",
        "answers": [
            "skips"
        ],
        "other_options": [
            "runs",
            "deletes",
            "nothing"
        ]
    },
    {
        "q": "Match selection patterns:",
        "type": "match",
        "left": [
            "it()",
            "fit()",
            "xit()"
        ],
        "right": [
            "Normal test",
            "Focused only",
            "Skipped"
        ]
    },
    {
        "q": "What is testing environment variables?",
        "type": "mcq",
        "o": [
            "Testing with different environment configs",
            "No environments",
            "Only production",
            "Nothing"
        ]
    },
    {
        "q": "Environment can be mocked in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to mock environment?",
        "type": "mcq",
        "o": [
            "Provide mock environment object",
            "Use real environment",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Environment mocking enables _____ configuration.",
        "type": "fill_blank",
        "answers": [
            "test-specific"
        ],
        "other_options": [
            "production",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match environment testing:",
        "type": "match",
        "left": [
            "environment.ts",
            "environment.test.ts"
        ],
        "right": [
            "Production config",
            "Test config"
        ]
    },
    {
        "q": "What is testing LocalStorage?",
        "type": "mcq",
        "o": [
            "Testing code using browser storage",
            "Testing components",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "LocalStorage can be mocked in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to mock LocalStorage?",
        "type": "mcq",
        "o": [
            "Spy on getItem/setItem or use mock object",
            "Use real storage",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "LocalStorage mocks prevent _____ side effects.",
        "type": "fill_blank",
        "answers": [
            "persistent"
        ],
        "other_options": [
            "temporary",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match storage testing:",
        "type": "match",
        "left": [
            "spyOn(localStorage, 'getItem')",
            "localStorage.clear()"
        ],
        "right": [
            "Mock read",
            "Clear in afterEach"
        ]
    },
    {
        "q": "What is performance testing?",
        "type": "mcq",
        "o": [
            "Testing app speed and efficiency",
            "Testing correctness",
            "Testing layout",
            "Nothing"
        ]
    },
    {
        "q": "Performance tests measure speed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test performance?",
        "type": "mcq",
        "o": [
            "Measure time, memory usage",
            "Visual check",
            "Unit tests",
            "Nothing"
        ]
    },
    {
        "q": "Performance testing measures _____ and resources.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "logic",
            "style",
            "nothing"
        ]
    },
    {
        "q": "Match performance testing:",
        "type": "match",
        "left": [
            "Lighthouse",
            "performance.now()"
        ],
        "right": [
            "Browser audit",
            "Manual timing"
        ]
    },
    {
        "q": "What is testing accessibility?",
        "type": "mcq",
        "o": [
            "Testing for a11y compliance",
            "Testing performance",
            "Testing logic",
            "Nothing"
        ]
    },
    {
        "q": "Accessibility testing ensures usability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test accessibility?",
        "type": "mcq",
        "o": [
            "Use axe-core, Lighthouse, manual tests",
            "Skip testing",
            "Visual only",
            "Nothing"
        ]
    },
    {
        "q": "A11y testing verifies _____ for all users.",
        "type": "fill_blank",
        "answers": [
            "accessibility"
        ],
        "other_options": [
            "performance",
            "styling",
            "nothing"
        ]
    },
    {
        "q": "Match a11y testing:",
        "type": "match",
        "left": [
            "axe-core",
            "ARIA attributes"
        ],
        "right": [
            "Automated a11y",
            "Semantic markup"
        ]
    },
    {
        "q": "What is visual regression testing?",
        "type": "mcq",
        "o": [
            "Testing for visual changes in UI",
            "Testing logic",
            "Testing API",
            "Nothing"
        ]
    },
    {
        "q": "Visual tests compare screenshots.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to do visual testing?",
        "type": "mcq",
        "o": [
            "Use tools like Percy, Chromatic",
            "Manual review",
            "Unit tests",
            "Nothing"
        ]
    },
    {
        "q": "Visual tests detect _____ changes.",
        "type": "fill_blank",
        "answers": [
            "UI"
        ],
        "other_options": [
            "logic",
            "data",
            "nothing"
        ]
    },
    {
        "q": "Match visual testing:",
        "type": "match",
        "left": [
            "Screenshot comparison",
            "Baseline image"
        ],
        "right": [
            "Detect changes",
            "Reference image"
        ]
    },
    {
        "q": "What is testing utilities pattern?",
        "type": "mcq",
        "o": [
            "Creating reusable test helpers",
            "No utilities",
            "Copy-paste code",
            "Nothing"
        ]
    },
    {
        "q": "Test utilities reduce duplication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is test utility?",
        "type": "mcq",
        "o": [
            "Shared helper function for tests",
            "Production code",
            "Component",
            "Nothing"
        ]
    },
    {
        "q": "Utilities provide _____ test helpers.",
        "type": "fill_blank",
        "answers": [
            "reusable"
        ],
        "other_options": [
            "one-time",
            "no",
            "nothing"
        ]
    },
    {
        "q": "Match utility patterns:",
        "type": "match",
        "left": [
            "Factory functions",
            "Custom matchers",
            "Mock builders"
        ],
        "right": [
            "Create test data",
            "Custom assertions",
            "Build mocks"
        ]
    },
    {
        "q": "What is testing best practices?",
        "type": "mcq",
        "o": [
            "Guidelines for effective testing",
            "No guidelines",
            "Random testing",
            "Nothing"
        ]
    },
    {
        "q": "Tests should be fast and isolated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What makes good test?",
        "type": "mcq",
        "o": [
            "Fast, isolated, repeatable, deterministic",
            "Slow, shared state",
            "Random results",
            "Nothing"
        ]
    },
    {
        "q": "Good tests are _____ and reliable.",
        "type": "fill_blank",
        "answers": [
            "deterministic"
        ],
        "other_options": [
            "random",
            "slow",
            "nothing"
        ]
    },
    {
        "q": "Match best practices:",
        "type": "match",
        "left": [
            "FIRST",
            "AAA pattern",
            "One assert per test"
        ],
        "right": [
            "Fast/Isolated/Repeatable/Self-validating/Timely",
            "Arrange/Act/Assert",
            "Single responsibility"
        ]
    },
    {
        "q": "What is test maintenance?",
        "type": "mcq",
        "o": [
            "Keeping tests up to date with code",
            "Ignoring tests",
            "Deleting tests",
            "Nothing"
        ]
    },
    {
        "q": "Tests need regular maintenance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why maintain tests?",
        "type": "mcq",
        "o": [
            "Keep pace with code changes",
            "No reason",
            "Waste time",
            "Nothing"
        ]
    },
    {
        "q": "Test maintenance ensures continued _____.",
        "type": "fill_blank",
        "answers": [
            "reliability"
        ],
        "other_options": [
            "failure",
            "deletion",
            "nothing"
        ]
    },
    {
        "q": "Match maintenance:",
        "type": "match",
        "left": [
            "Update tests",
            "Remove obsolete",
            "Refactor"
        ],
        "right": [
            "Match new code",
            "Delete unused",
            "Improve structure"
        ]
    },
    {
        "q": "What is test pyramid?",
        "type": "mcq",
        "o": [
            "Testing strategy with unit at base",
            "E2E at base",
            "No structure",
            "Nothing"
        ]
    },
    {
        "q": "More unit tests than E2E tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is pyramid structure?",
        "type": "mcq",
        "o": [
            "Many unit, some integration, few E2E",
            "Equal all",
            "Only E2E",
            "Nothing"
        ]
    },
    {
        "q": "Pyramid has many _____ tests.",
        "type": "fill_blank",
        "answers": [
            "unit"
        ],
        "other_options": [
            "E2E",
            "manual",
            "nothing"
        ]
    },
    {
        "q": "Rearrange test pyramid:",
        "type": "rearrange",
        "words": [
            "Unit tests (many)",
            "Integration tests (some)",
            "E2E tests (few)"
        ]
    },
    {
        "q": "What is flaky test?",
        "type": "mcq",
        "o": [
            "Test that sometimes passes, sometimes fails",
            "Always passes",
            "Always fails",
            "Nothing"
        ]
    },
    {
        "q": "Flaky tests reduce confidence.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What causes flaky tests?",
        "type": "mcq",
        "o": [
            "Timing issues, shared state, external deps",
            "Good code",
            "Isolation",
            "Nothing"
        ]
    },
    {
        "q": "Flaky tests are _____ to debug.",
        "type": "fill_blank",
        "answers": [
            "difficult"
        ],
        "other_options": [
            "easy",
            "impossible",
            "nothing"
        ]
    },
    {
        "q": "Match flaky causes:",
        "type": "match",
        "left": [
            "Race conditions",
            "Shared state",
            "External services"
        ],
        "right": [
            "Timing issues",
            "Test interference",
            "Network problems"
        ]
    },
    {
        "q": "What is CI testing?",
        "type": "mcq",
        "o": [
            "Running tests in continuous integration",
            "Manual testing",
            "No testing",
            "Nothing"
        ]
    },
    {
        "q": "CI runs tests automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why CI testing?",
        "type": "mcq",
        "o": [
            "Catch issues early, automate verification",
            "Slow down",
            "Manual work",
            "Nothing"
        ]
    },
    {
        "q": "CI testing runs on every _____.",
        "type": "fill_blank",
        "answers": [
            "commit"
        ],
        "other_options": [
            "year",
            "never",
            "nothing"
        ]
    },
    {
        "q": "Match CI patterns:",
        "type": "match",
        "left": [
            "GitHub Actions",
            "CircleCI",
            "Jenkins"
        ],
        "right": [
            "GitHub CI",
            "Cloud CI",
            "Self-hosted CI"
        ]
    },
    {
        "q": "What is test coverage reports?",
        "type": "mcq",
        "o": [
            "Detailed report of covered code",
            "Just percentage",
            "No report",
            "Nothing"
        ]
    },
    {
        "q": "Coverage reports show untested code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is in coverage report?",
        "type": "mcq",
        "o": [
            "Lines, branches, functions, statements",
            "Only lines",
            "Only functions",
            "Nothing"
        ]
    },
    {
        "q": "Coverage reports highlight _____ code.",
        "type": "fill_blank",
        "answers": [
            "uncovered"
        ],
        "other_options": [
            "all",
            "covered",
            "nothing"
        ]
    },
    {
        "q": "Match coverage reports:",
        "type": "match",
        "left": [
            "HTML report",
            "LCOV format",
            "Console output"
        ],
        "right": [
            "Visual browser",
            "CI integration",
            "Quick view"
        ]
    },
    {
        "q": "What is test organization?",
        "type": "mcq",
        "o": [
            "Structuring test files and suites",
            "Random files",
            "No organization",
            "Nothing"
        ]
    },
    {
        "q": "Tests should be well organized.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to organize tests?",
        "type": "mcq",
        "o": [
            "By feature, co-locate with code",
            "One file",
            "Random",
            "Nothing"
        ]
    },
    {
        "q": "Good organization improves test _____.",
        "type": "fill_blank",
        "answers": [
            "maintainability"
        ],
        "other_options": [
            "speed",
            "coverage",
            "nothing"
        ]
    },
    {
        "q": "Match organization patterns:",
        "type": "match",
        "left": [
            "component.spec.ts",
            "__tests__ folder",
            "test/ directory"
        ],
        "right": [
            "Co-located",
            "Grouped folder",
            "Separate directory"
        ]
    },
    {
        "q": "What is testing change detection?",
        "type": "mcq",
        "o": [
            "Testing how Angular updates views",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "detectChanges() triggers change detection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why test change detection?",
        "type": "mcq",
        "o": [
            "Verify template updates after data changes",
            "No reason",
            "Skip it",
            "Nothing"
        ]
    },
    {
        "q": "Change detection updates component _____.",
        "type": "fill_blank",
        "answers": [
            "template"
        ],
        "other_options": [
            "class",
            "service",
            "nothing"
        ]
    },
    {
        "q": "Match change detection:",
        "type": "match",
        "left": [
            "detectChanges()",
            "autoDetectChanges"
        ],
        "right": [
            "Manual trigger",
            "Auto trigger"
        ]
    },
    {
        "q": "What is autoDetectChanges?",
        "type": "mcq",
        "o": [
            "Automatic change detection in tests",
            "Manual detection",
            "No detection",
            "Nothing"
        ]
    },
    {
        "q": "autoDetectChanges removes need for manual calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to enable autoDetectChanges?",
        "type": "mcq",
        "c": "fixture.autoDetectChanges(true)",
        "o": [
            "Call with true",
            "Default enabled",
            "Not possible",
            "Nothing"
        ]
    },
    {
        "q": "autoDetectChanges runs detection _____.",
        "type": "fill_blank",
        "answers": [
            "automatically"
        ],
        "other_options": [
            "manually",
            "never",
            "nothing"
        ]
    },
    {
        "q": "Match detection methods:",
        "type": "match",
        "left": [
            "fixture.detectChanges()",
            "fixture.autoDetectChanges()"
        ],
        "right": [
            "Once",
            "Continuous"
        ]
    },
    {
        "q": "What is test double?",
        "type": "mcq",
        "o": [
            "Generic term for test replacement objects",
            "Real object",
            "Component",
            "Nothing"
        ]
    },
    {
        "q": "Test doubles replace real dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What are test double types?",
        "type": "mcq",
        "o": [
            "Stub, mock, spy, fake, dummy",
            "Only mocks",
            "Only stubs",
            "Nothing"
        ]
    },
    {
        "q": "Test doubles are testing _____.",
        "type": "fill_blank",
        "answers": [
            "substitutes"
        ],
        "other_options": [
            "originals",
            "nothing",
            "components"
        ]
    },
    {
        "q": "Match test doubles:",
        "type": "match",
        "left": [
            "Stub",
            "Mock",
            "Spy",
            "Fake"
        ],
        "right": [
            "Canned responses",
            "Verifies calls",
            "Wraps and records",
            "Working implementation"
        ]
    },
    {
        "q": "What is stub?",
        "type": "mcq",
        "o": [
            "Returns canned responses",
            "Verifies calls",
            "Real implementation",
            "Nothing"
        ]
    },
    {
        "q": "Stubs provide predetermined responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use stub?",
        "type": "mcq",
        "o": [
            "When method return value is needed",
            "Always",
            "Never",
            "For verification"
        ]
    },
    {
        "q": "Stubs return _____ values.",
        "type": "fill_blank",
        "answers": [
            "fixed"
        ],
        "other_options": [
            "random",
            "no",
            "dynamic"
        ]
    },
    {
        "q": "Match stub usage:",
        "type": "match",
        "left": [
            "and.returnValue()",
            "Real call"
        ],
        "right": [
            "Stub behavior",
            "Not stub"
        ]
    },
    {
        "q": "What is fake?",
        "type": "mcq",
        "o": [
            "Working but simplified implementation",
            "No implementation",
            "Real service",
            "Nothing"
        ]
    },
    {
        "q": "Fakes have working implementations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use fake?",
        "type": "mcq",
        "o": [
            "When behavior matters but real impl too complex",
            "Always",
            "Never",
            "For stubs"
        ]
    },
    {
        "q": "Fakes provide _____ implementations.",
        "type": "fill_blank",
        "answers": [
            "simplified"
        ],
        "other_options": [
            "full",
            "no",
            "complex"
        ]
    },
    {
        "q": "Match fake examples:",
        "type": "match",
        "left": [
            "In-memory database",
            "Real database"
        ],
        "right": [
            "Fake",
            "Not fake"
        ]
    },
    {
        "q": "What is dummy?",
        "type": "mcq",
        "o": [
            "Object passed but never used",
            "Used object",
            "Real service",
            "Nothing"
        ]
    },
    {
        "q": "Dummies satisfy parameter requirements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use dummy?",
        "type": "mcq",
        "o": [
            "When parameter required but not used",
            "Always",
            "Never",
            "For logic"
        ]
    },
    {
        "q": "Dummies are _____ values.",
        "type": "fill_blank",
        "answers": [
            "placeholder"
        ],
        "other_options": [
            "real",
            "used",
            "dynamic"
        ]
    },
    {
        "q": "Match dummy usage:",
        "type": "match",
        "left": [
            "null parameter",
            "Used parameter"
        ],
        "right": [
            "Dummy",
            "Not dummy"
        ]
    },
    {
        "q": "What is testing with ngModel?",
        "type": "mcq",
        "o": [
            "Testing two-way binding",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "ngModel requires FormsModule in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ngModel?",
        "type": "mcq",
        "o": [
            "Import FormsModule, set value, verify binding",
            "Skip testing",
            "Mock ngModel",
            "Nothing"
        ]
    },
    {
        "q": "ngModel tests verify _____ binding.",
        "type": "fill_blank",
        "answers": [
            "two-way"
        ],
        "other_options": [
            "one-way",
            "no",
            "three-way"
        ]
    },
    {
        "q": "Match ngModel testing:",
        "type": "match",
        "left": [
            "Import FormsModule",
            "Set input value"
        ],
        "right": [
            "Enable ngModel",
            "Test binding"
        ]
    },
    {
        "q": "What is testing content projection?",
        "type": "mcq",
        "o": [
            "Testing ng-content behavior",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "Content projection tested via wrapper.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ng-content?",
        "type": "mcq",
        "o": [
            "Create wrapper component with projected content",
            "Direct test",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "ng-content tests use _____ components.",
        "type": "fill_blank",
        "answers": [
            "wrapper"
        ],
        "other_options": [
            "real",
            "no",
            "mocked"
        ]
    },
    {
        "q": "Match projection testing:",
        "type": "match",
        "left": [
            "Test host with content",
            "Verify projected text"
        ],
        "right": [
            "Setup",
            "Assertion"
        ]
    },
    {
        "q": "What is testing ViewChild?",
        "type": "mcq",
        "o": [
            "Testing @ViewChild references",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "ViewChild available after view init.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ViewChild?",
        "type": "mcq",
        "o": [
            "Access after detectChanges()",
            "Access before init",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "ViewChild tests ensure _____ access.",
        "type": "fill_blank",
        "answers": [
            "child element"
        ],
        "other_options": [
            "parent",
            "service",
            "nothing"
        ]
    },
    {
        "q": "Match ViewChild testing:",
        "type": "match",
        "left": [
            "detectChanges()",
            "component.viewChild"
        ],
        "right": [
            "Initialize view",
            "Access reference"
        ]
    },
    {
        "q": "What is testing ContentChild?",
        "type": "mcq",
        "o": [
            "Testing @ContentChild references",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "ContentChild queries projected content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ContentChild?",
        "type": "mcq",
        "o": [
            "Use wrapper with projected content",
            "Direct test",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "ContentChild queries _____ content.",
        "type": "fill_blank",
        "answers": [
            "projected"
        ],
        "other_options": [
            "template",
            "no",
            "all"
        ]
    },
    {
        "q": "Match content queries:",
        "type": "match",
        "left": [
            "ContentChild",
            "ViewChild"
        ],
        "right": [
            "Projected content",
            "View content"
        ]
    },
    {
        "q": "What is testing HostBinding?",
        "type": "mcq",
        "o": [
            "Testing host element bindings",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "HostBinding modifies host element.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test HostBinding?",
        "type": "mcq",
        "o": [
            "Check host element properties",
            "Check template",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "HostBinding tests verify _____ element.",
        "type": "fill_blank",
        "answers": [
            "host"
        ],
        "other_options": [
            "child",
            "parent",
            "nothing"
        ]
    },
    {
        "q": "Match host testing:",
        "type": "match",
        "left": [
            "HostBinding",
            "HostListener"
        ],
        "right": [
            "Property binding",
            "Event binding"
        ]
    },
    {
        "q": "What is testing HostListener?",
        "type": "mcq",
        "o": [
            "Testing host element event handlers",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "HostListener handles host events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test HostListener?",
        "type": "mcq",
        "o": [
            "Trigger event on host element",
            "Call method directly",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "HostListener tests _____ event handling.",
        "type": "fill_blank",
        "answers": [
            "host"
        ],
        "other_options": [
            "child",
            "parent",
            "nothing"
        ]
    },
    {
        "q": "Match listener testing:",
        "type": "match",
        "left": [
            "Trigger event",
            "Verify handler"
        ],
        "right": [
            "Simulate event",
            "Check callback"
        ]
    },
    {
        "q": "What is testing lifecycle hooks?",
        "type": "mcq",
        "o": [
            "Testing ngOnInit, ngOnDestroy, etc.",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "Hooks are called during component lifecycle.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ngOnInit?",
        "type": "mcq",
        "o": [
            "Verify initialization after detectChanges",
            "Call directly",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Lifecycle tests verify _____ behavior.",
        "type": "fill_blank",
        "answers": [
            "initialization"
        ],
        "other_options": [
            "service",
            "route",
            "nothing"
        ]
    },
    {
        "q": "Match lifecycle testing:",
        "type": "match",
        "left": [
            "ngOnInit",
            "ngOnDestroy"
        ],
        "right": [
            "After creation",
            "Before removal"
        ]
    },
    {
        "q": "What is testing ngOnChanges?",
        "type": "mcq",
        "o": [
            "Testing input change handler",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "ngOnChanges receives SimpleChanges.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test ngOnChanges?",
        "type": "mcq",
        "o": [
            "Change input and verify reaction",
            "Call directly",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "ngOnChanges tests input _____ reactions.",
        "type": "fill_blank",
        "answers": [
            "change"
        ],
        "other_options": [
            "creation",
            "deletion",
            "nothing"
        ]
    },
    {
        "q": "Match changes testing:",
        "type": "match",
        "left": [
            "First change",
            "Subsequent change"
        ],
        "right": [
            "isFirstChange() true",
            "isFirstChange() false"
        ]
    },
    {
        "q": "What is browser testing?",
        "type": "mcq",
        "o": [
            "Testing in real browser environment",
            "Testing in Node",
            "No browser",
            "Nothing"
        ]
    },
    {
        "q": "Karma runs tests in browser.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What browsers for testing?",
        "type": "mcq",
        "o": [
            "Chrome, Firefox, Safari, headless",
            "Chrome only",
            "No browser",
            "Nothing"
        ]
    },
    {
        "q": "Browser testing uses _____ DOM.",
        "type": "fill_blank",
        "answers": [
            "real"
        ],
        "other_options": [
            "fake",
            "no",
            "emulated"
        ]
    },
    {
        "q": "Match browser testing:",
        "type": "match",
        "left": [
            "Chrome",
            "ChromeHeadless"
        ],
        "right": [
            "Full browser",
            "No UI"
        ]
    },
    {
        "q": "What is headless testing?",
        "type": "mcq",
        "o": [
            "Testing without visible browser UI",
            "With UI",
            "No browser",
            "Nothing"
        ]
    },
    {
        "q": "Headless is faster in CI.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use headless?",
        "type": "mcq",
        "o": [
            "CI environments, automation",
            "Never",
            "Development only",
            "Nothing"
        ]
    },
    {
        "q": "Headless runs _____ browser UI.",
        "type": "fill_blank",
        "answers": [
            "without"
        ],
        "other_options": [
            "with",
            "no",
            "partial"
        ]
    },
    {
        "q": "Match headless browsers:",
        "type": "match",
        "left": [
            "ChromeHeadless",
            "Puppeteer"
        ],
        "right": [
            "Karma config",
            "Node API"
        ]
    },
    {
        "q": "What is test parallelization?",
        "type": "mcq",
        "o": [
            "Running tests concurrently",
            "Sequential only",
            "No tests",
            "Nothing"
        ]
    },
    {
        "q": "Parallel tests run faster.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to parallelize tests?",
        "type": "mcq",
        "o": [
            "Configure test runner for workers",
            "Not possible",
            "Always parallel",
            "Nothing"
        ]
    },
    {
        "q": "Parallel tests use multiple _____.",
        "type": "fill_blank",
        "answers": [
            "workers"
        ],
        "other_options": [
            "browsers",
            "files",
            "nothing"
        ]
    },
    {
        "q": "Match parallelization:",
        "type": "match",
        "left": [
            "Jest workers",
            "Karma parallel"
        ],
        "right": [
            "Built-in",
            "Plugin"
        ]
    },
    {
        "q": "What is test timeout?",
        "type": "mcq",
        "o": [
            "Maximum time for test to complete",
            "No limit",
            "Test delay",
            "Nothing"
        ]
    },
    {
        "q": "Timeouts prevent hanging tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to set timeout?",
        "type": "mcq",
        "c": "jasmine.DEFAULT_TIMEOUT_INTERVAL",
        "o": [
            "Set Jasmine config",
            "Not configurable",
            "Always default",
            "Nothing"
        ]
    },
    {
        "q": "Timeout fails test if exceeds _____ ms.",
        "type": "fill_blank",
        "answers": [
            "interval"
        ],
        "other_options": [
            "default",
            "zero",
            "nothing"
        ]
    },
    {
        "q": "Match timeout settings:",
        "type": "match",
        "left": [
            "Long async tests",
            "Fast tests"
        ],
        "right": [
            "Increase timeout",
            "Default ok"
        ]
    },
    {
        "q": "What is test reporting?",
        "type": "mcq",
        "o": [
            "Generating test result reports",
            "No reports",
            "Running tests",
            "Nothing"
        ]
    },
    {
        "q": "Reports show pass/fail status.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What reporting formats?",
        "type": "mcq",
        "o": [
            "HTML, JUnit XML, JSON",
            "Only console",
            "No formats",
            "Nothing"
        ]
    },
    {
        "q": "Reports provide test _____ summary.",
        "type": "fill_blank",
        "answers": [
            "results"
        ],
        "other_options": [
            "code",
            "coverage",
            "nothing"
        ]
    },
    {
        "q": "Match report formats:",
        "type": "match",
        "left": [
            "HTML",
            "JUnit XML"
        ],
        "right": [
            "Human readable",
            "CI integration"
        ]
    },
    {
        "q": "What is test fixtures?",
        "type": "mcq",
        "o": [
            "Shared test data and setup",
            "Real data",
            "Components",
            "Nothing"
        ]
    },
    {
        "q": "Fixtures provide reusable test data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to use fixtures?",
        "type": "mcq",
        "o": [
            "Import shared data objects",
            "Create each test",
            "Skip fixtures",
            "Nothing"
        ]
    },
    {
        "q": "Fixtures ensure consistent test _____.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "speed",
            "coverage",
            "nothing"
        ]
    },
    {
        "q": "Match fixture patterns:",
        "type": "match",
        "left": [
            "Factory function",
            "JSON file"
        ],
        "right": [
            "Dynamic fixture",
            "Static fixture"
        ]
    },
    {
        "q": "What is testing with ChangeDetectionStrategy.OnPush?",
        "type": "mcq",
        "o": [
            "Testing components with OnPush strategy",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "OnPush components require explicit change detection trigger.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test OnPush component?",
        "type": "mcq",
        "o": [
            "Change input reference and detectChanges",
            "Just detectChanges",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "OnPush tests must change _____ references.",
        "type": "fill_blank",
        "answers": [
            "input"
        ],
        "other_options": [
            "output",
            "service",
            "nothing"
        ]
    },
    {
        "q": "Match OnPush testing:",
        "type": "match",
        "left": [
            "Input reference change",
            "markForCheck()"
        ],
        "right": [
            "Triggers detection",
            "Manual trigger"
        ]
    },
    {
        "q": "What is testing private methods?",
        "type": "mcq",
        "o": [
            "Testing internal implementation details",
            "Testing public API only",
            "Required testing",
            "Nothing"
        ]
    },
    {
        "q": "Private methods typically tested through public API.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why avoid testing private methods?",
        "type": "mcq",
        "o": [
            "Coupling tests to implementation",
            "Not possible",
            "Always test them",
            "Nothing"
        ]
    },
    {
        "q": "Private testing creates _____ coupling.",
        "type": "fill_blank",
        "answers": [
            "tight"
        ],
        "other_options": [
            "loose",
            "no",
            "good"
        ]
    },
    {
        "q": "Match testing approach:",
        "type": "match",
        "left": [
            "Public methods",
            "Private methods"
        ],
        "right": [
            "Test directly",
            "Test through public"
        ]
    },
    {
        "q": "What is testing with providers array?",
        "type": "mcq",
        "o": [
            "Configuring test module providers",
            "No providers",
            "Real services only",
            "Nothing"
        ]
    },
    {
        "q": "Providers array overrides dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to provide mock?",
        "type": "mcq",
        "c": "providers: [{provide: Service, useValue: mockService}]",
        "o": [
            "Use provide/useValue pattern",
            "Import real",
            "Skip mocking",
            "Nothing"
        ]
    },
    {
        "q": "Providers configure _____ injection.",
        "type": "fill_blank",
        "answers": [
            "dependency"
        ],
        "other_options": [
            "component",
            "template",
            "nothing"
        ]
    },
    {
        "q": "Match provider options:",
        "type": "match",
        "left": [
            "useValue",
            "useClass",
            "useFactory"
        ],
        "right": [
            "Static object",
            "Class type",
            "Factory function"
        ]
    },
    {
        "q": "What is testing DOM events?",
        "type": "mcq",
        "o": [
            "Simulating user interactions",
            "Testing services",
            "Testing routes",
            "Nothing"
        ]
    },
    {
        "q": "DOM events can be triggered programmatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to trigger click?",
        "type": "mcq",
        "c": "element.triggerEventHandler('click', null)",
        "o": [
            "Use triggerEventHandler",
            "Real click",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "DOM events simulate _____ interactions.",
        "type": "fill_blank",
        "answers": [
            "user"
        ],
        "other_options": [
            "service",
            "route",
            "nothing"
        ]
    },
    {
        "q": "Match event testing:",
        "type": "match",
        "left": [
            "click",
            "input",
            "submit"
        ],
        "right": [
            "Button action",
            "Text entry",
            "Form action"
        ]
    },
    {
        "q": "What is testing async pipe?",
        "type": "mcq",
        "o": [
            "Testing Observable/Promise in templates",
            "Testing sync data",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Async pipe subscribes to Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test async pipe?",
        "type": "mcq",
        "o": [
            "Use fakeAsync or mock Observable",
            "Skip testing",
            "Real async",
            "Nothing"
        ]
    },
    {
        "q": "Async pipe tests verify _____ data display.",
        "type": "fill_blank",
        "answers": [
            "async"
        ],
        "other_options": [
            "sync",
            "no",
            "static"
        ]
    },
    {
        "q": "Match async pipe testing:",
        "type": "match",
        "left": [
            "Observable",
            "Promise"
        ],
        "right": [
            "Stream of values",
            "Single value"
        ]
    },
    {
        "q": "What is testing attribute directives?",
        "type": "mcq",
        "o": [
            "Testing directives that modify elements",
            "Testing components",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Attribute directives need host element.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test attribute directive?",
        "type": "mcq",
        "o": [
            "Apply to test host and verify effects",
            "Direct instantiation",
            "Skip testing",
            "Nothing"
        ]
    },
    {
        "q": "Attribute directives modify element _____.",
        "type": "fill_blank",
        "answers": [
            "behavior"
        ],
        "other_options": [
            "content",
            "routing",
            "nothing"
        ]
    },
    {
        "q": "Match directive types:",
        "type": "match",
        "left": [
            "Attribute",
            "Structural"
        ],
        "right": [
            "Modifies element",
            "Changes DOM"
        ]
    },
    {
        "q": "What is testing structural directives?",
        "type": "mcq",
        "o": [
            "Testing directives that modify DOM structure",
            "Testing attribute directives",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "Structural directives add/remove elements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test *ngIf behavior?",
        "type": "mcq",
        "o": [
            "Toggle condition and verify elements",
            "Skip testing",
            "Mock ngIf",
            "Nothing"
        ]
    },
    {
        "q": "Structural directives change DOM _____.",
        "type": "fill_blank",
        "answers": [
            "structure"
        ],
        "other_options": [
            "content",
            "style",
            "nothing"
        ]
    },
    {
        "q": "Match structural testing:",
        "type": "match",
        "left": [
            "*ngIf",
            "*ngFor"
        ],
        "right": [
            "Conditional render",
            "List render"
        ]
    },
    {
        "q": "What is testing with DeferBlockBehavior?",
        "type": "mcq",
        "o": [
            "Controlling defer block behavior in tests",
            "Testing components",
            "Testing services",
            "Nothing"
        ]
    },
    {
        "q": "DeferBlockBehavior controls defer in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What values for DeferBlockBehavior?",
        "type": "mcq",
        "o": [
            "Manual, Playthrough",
            "Auto only",
            "Skip only",
            "Nothing"
        ]
    },
    {
        "q": "DeferBlockBehavior.Manual requires _____ triggering.",
        "type": "fill_blank",
        "answers": [
            "explicit"
        ],
        "other_options": [
            "auto",
            "no",
            "default"
        ]
    },
    {
        "q": "Match defer behavior:",
        "type": "match",
        "left": [
            "Manual",
            "Playthrough"
        ],
        "right": [
            "Control loading",
            "Auto load"
        ]
    }
]