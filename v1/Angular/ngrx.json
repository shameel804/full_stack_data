[
    {
        "q": "What is NgRx?",
        "type": "mcq",
        "o": [
            "Reactive state management for Angular",
            "HTTP library",
            "Routing library",
            "Forms library"
        ]
    },
    {
        "q": "NgRx is based on Redux pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does NgRx provide?",
        "type": "mcq",
        "o": [
            "Predictable state container",
            "Random state management",
            "No state management",
            "Local storage only"
        ]
    },
    {
        "q": "NgRx uses _____ for async operations.",
        "type": "fill_blank",
        "answers": [
            "RxJS"
        ],
        "other_options": [
            "Promises",
            "callbacks",
            "async/await"
        ]
    },
    {
        "q": "Match NgRx concepts:",
        "type": "match",
        "left": [
            "Store",
            "Actions",
            "Reducers",
            "Selectors"
        ],
        "right": [
            "State container",
            "Events",
            "State changes",
            "State queries"
        ]
    },
    {
        "q": "What is the Store?",
        "type": "mcq",
        "o": [
            "Single source of truth for state",
            "Database",
            "Service",
            "Component"
        ]
    },
    {
        "q": "Store is immutable in NgRx.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you access the Store?",
        "type": "mcq",
        "c": "constructor(private store: Store) {}",
        "o": [
            "Inject it via constructor",
            "Import directly",
            "Create instance",
            "Use global variable"
        ]
    },
    {
        "q": "Store holds the entire application _____.",
        "type": "fill_blank",
        "answers": [
            "state"
        ],
        "other_options": [
            "data",
            "logic",
            "view"
        ]
    },
    {
        "q": "Match Store methods:",
        "type": "match",
        "left": [
            "select",
            "dispatch",
            "pipe"
        ],
        "right": [
            "Query state",
            "Send action",
            "Compose operators"
        ]
    },
    {
        "q": "What is an Action?",
        "type": "mcq",
        "o": [
            "Event describing what happened",
            "State directly",
            "Selector",
            "Service"
        ]
    },
    {
        "q": "Actions are the only way to trigger state changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "export const loadUsers = createAction('[Users] Load');",
        "o": [
            "Action creator function",
            "Reducer",
            "Selector",
            "Effect"
        ]
    },
    {
        "q": "Action type format is typically [Source] _____.",
        "type": "fill_blank",
        "answers": [
            "Event"
        ],
        "other_options": [
            "Data",
            "State",
            "Action"
        ]
    },
    {
        "q": "Match action patterns:",
        "type": "match",
        "left": [
            "[Users] Load",
            "[Users API] Load Success",
            "[Users API] Load Failure"
        ],
        "right": [
            "Request action",
            "Success response",
            "Error response"
        ]
    },
    {
        "q": "What is createAction()?",
        "type": "mcq",
        "o": [
            "Factory function for action creators",
            "Reducer creator",
            "Selector creator",
            "Effect creator"
        ]
    },
    {
        "q": "createAction is from @ngrx/store.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does props() do?",
        "type": "mcq",
        "c": "createAction('[Users] Add', props<{user: User}>())",
        "o": [
            "Defines action payload type",
            "Creates reducer",
            "Creates selector",
            "Creates effect"
        ]
    },
    {
        "q": "props<T>() adds _____ to action.",
        "type": "fill_blank",
        "answers": [
            "payload"
        ],
        "other_options": [
            "type",
            "reducer",
            "effect"
        ]
    },
    {
        "q": "Rearrange action creation:",
        "type": "rearrange",
        "words": [
            "Import createAction",
            "Define action type string",
            "Add props if needed",
            "Export action creator",
            "Dispatch in component"
        ]
    },
    {
        "q": "What is a Reducer?",
        "type": "mcq",
        "o": [
            "Pure function that handles state transitions",
            "Service",
            "Component",
            "API call"
        ]
    },
    {
        "q": "Reducers must be pure functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does createReducer() do?",
        "type": "mcq",
        "o": [
            "Creates reducer from initial state and handlers",
            "Creates action",
            "Creates selector",
            "Creates effect"
        ]
    },
    {
        "q": "Reducer takes current state and _____ as input.",
        "type": "fill_blank",
        "answers": [
            "action"
        ],
        "other_options": [
            "selector",
            "effect",
            "service"
        ]
    },
    {
        "q": "Match reducer concepts:",
        "type": "match",
        "left": [
            "initialState",
            "on()",
            "createReducer",
            "pure function"
        ],
        "right": [
            "Starting state",
            "Action handler",
            "Factory function",
            "No side effects"
        ]
    },
    {
        "q": "What is on() function?",
        "type": "mcq",
        "o": [
            "Associates action with state change logic",
            "Creates action",
            "Creates selector",
            "Dispatches action"
        ]
    },
    {
        "q": "on() can handle multiple actions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "on(loadUsersSuccess, (state, {users}) => ({...state, users}))",
        "o": [
            "Updates state with users on success",
            "Loads users",
            "Creates action",
            "Dispatches action"
        ]
    },
    {
        "q": "on() returns new state _____.",
        "type": "fill_blank",
        "answers": [
            "immutably"
        ],
        "other_options": [
            "mutably",
            "synchronously",
            "slowly"
        ]
    },
    {
        "q": "Match on() patterns:",
        "type": "match",
        "left": [
            "Return new object",
            "Spread operator",
            "Never mutate"
        ],
        "right": [
            "Immutable update",
            "Copy properties",
            "Pure function rule"
        ]
    },
    {
        "q": "What is initialState?",
        "type": "mcq",
        "o": [
            "Default state before any actions",
            "Final state",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "initialState should have type annotation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this define?",
        "type": "mcq",
        "c": "const initialState: UserState = { users: [], loading: false };",
        "o": [
            "Initial state with typed interface",
            "Action",
            "Reducer",
            "Effect"
        ]
    },
    {
        "q": "initialState is passed to _____.",
        "type": "fill_blank",
        "answers": [
            "createReducer"
        ],
        "other_options": [
            "createAction",
            "createEffect",
            "createSelector"
        ]
    },
    {
        "q": "Match state structure:",
        "type": "match",
        "left": [
            "data",
            "loading",
            "error",
            "loaded"
        ],
        "right": [
            "Actual items",
            "Request in progress",
            "Error message",
            "Data fetched"
        ]
    },
    {
        "q": "What is a Selector?",
        "type": "mcq",
        "o": [
            "Pure function to select state slices",
            "Action",
            "Reducer",
            "Effect"
        ]
    },
    {
        "q": "Selectors are memoized by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does createSelector() do?",
        "type": "mcq",
        "o": [
            "Creates memoized selector function",
            "Creates action",
            "Creates reducer",
            "Creates effect"
        ]
    },
    {
        "q": "Selectors derive _____ from state.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "actions",
            "effects",
            "reducers"
        ]
    },
    {
        "q": "Match selector patterns:",
        "type": "match",
        "left": [
            "Feature selector",
            "createSelector",
            "Memoization"
        ],
        "right": [
            "Gets feature state",
            "Compose selectors",
            "Cache results"
        ]
    },
    {
        "q": "What is createFeatureSelector()?",
        "type": "mcq",
        "o": [
            "Creates selector for feature state slice",
            "Creates action",
            "Creates reducer",
            "Creates effect"
        ]
    },
    {
        "q": "Feature selectors are the starting point.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this select?",
        "type": "mcq",
        "c": "const selectUserState = createFeatureSelector<UserState>('users');",
        "o": [
            "User feature state from store",
            "Single user",
            "All actions",
            "Effects"
        ]
    },
    {
        "q": "createFeatureSelector uses feature _____ as key.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "action",
            "reducer",
            "effect"
        ]
    },
    {
        "q": "Rearrange selector creation:",
        "type": "rearrange",
        "words": [
            "Create feature selector",
            "Create property selectors",
            "Compose with createSelector",
            "Export selectors",
            "Use in component"
        ]
    },
    {
        "q": "What is an Effect?",
        "type": "mcq",
        "o": [
            "Handles side effects like API calls",
            "Pure state change",
            "Selector",
            "Action"
        ]
    },
    {
        "q": "Effects are from @ngrx/effects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does createEffect() do?",
        "type": "mcq",
        "o": [
            "Creates effect that listens for actions",
            "Creates action",
            "Creates reducer",
            "Creates selector"
        ]
    },
    {
        "q": "Effects use _____ for action stream.",
        "type": "fill_blank",
        "answers": [
            "Actions"
        ],
        "other_options": [
            "Store",
            "Reducers",
            "Selectors"
        ]
    },
    {
        "q": "Match effect patterns:",
        "type": "match",
        "left": [
            "ofType",
            "switchMap",
            "catchError",
            "map"
        ],
        "right": [
            "Filter actions",
            "Call API",
            "Handle errors",
            "Transform to action"
        ]
    },
    {
        "q": "What is ofType()?",
        "type": "mcq",
        "o": [
            "Filters actions by type",
            "Creates action",
            "Dispatches action",
            "Reduces state"
        ]
    },
    {
        "q": "ofType can filter multiple actions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this filter?",
        "type": "mcq",
        "c": "this.actions$.pipe(ofType(loadUsers, refreshUsers))",
        "o": [
            "Both load and refresh actions",
            "Only load",
            "Only refresh",
            "All actions"
        ]
    },
    {
        "q": "ofType is an RxJS _____ operator.",
        "type": "fill_blank",
        "answers": [
            "pipeable"
        ],
        "other_options": [
            "creation",
            "combination",
            "utility"
        ]
    },
    {
        "q": "Match effect operators:",
        "type": "match",
        "left": [
            "ofType",
            "mergeMap",
            "exhaustMap",
            "concatMap"
        ],
        "right": [
            "Action filter",
            "Parallel requests",
            "Ignore while busy",
            "Sequential requests"
        ]
    },
    {
        "q": "What happens in this effect?",
        "type": "mcq",
        "c": "loadUsers$ = createEffect(() => this.actions$.pipe(ofType(loadUsers), switchMap(() => this.api.getUsers().pipe(map(users => loadUsersSuccess({users}))))))",
        "o": [
            "Loads users and dispatches success",
            "Only loads users",
            "Only dispatches",
            "Nothing"
        ]
    },
    {
        "q": "Effects should return Observable of actions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does {dispatch: false} do?",
        "type": "mcq",
        "c": "createEffect(() => ..., {dispatch: false})",
        "o": [
            "Effect doesn't dispatch action",
            "Disables effect",
            "Dispatches always",
            "Errors"
        ]
    },
    {
        "q": "Non-dispatching effects return _____.",
        "type": "fill_blank",
        "answers": [
            "void"
        ],
        "other_options": [
            "action",
            "state",
            "error"
        ]
    },
    {
        "q": "Match effect configurations:",
        "type": "match",
        "left": [
            "{dispatch: false}",
            "Default",
            "Error handling"
        ],
        "right": [
            "Side effects only",
            "Dispatch action",
            "catchError with of()"
        ]
    },
    {
        "q": "What is StoreModule.forRoot()?",
        "type": "mcq",
        "o": [
            "Registers root state and reducers",
            "Registers effects",
            "Registers selectors",
            "Registers actions"
        ]
    },
    {
        "q": "forRoot() is called once in AppModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "StoreModule.forRoot({router: routerReducer})",
        "o": [
            "Root reducer map",
            "Feature reducer",
            "Effects",
            "Selectors"
        ]
    },
    {
        "q": "forRoot accepts reducer _____ as argument.",
        "type": "fill_blank",
        "answers": [
            "map"
        ],
        "other_options": [
            "array",
            "function",
            "class"
        ]
    },
    {
        "q": "Match module methods:",
        "type": "match",
        "left": [
            "forRoot",
            "forFeature"
        ],
        "right": [
            "Root module",
            "Feature module"
        ]
    },
    {
        "q": "What is StoreModule.forFeature()?",
        "type": "mcq",
        "o": [
            "Registers feature state lazily",
            "Registers root state",
            "Registers effects",
            "Registers selectors"
        ]
    },
    {
        "q": "forFeature enables lazy loading of state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this register?",
        "type": "mcq",
        "c": "StoreModule.forFeature('users', userReducer)",
        "o": [
            "Users feature state",
            "Root state",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "forFeature first argument is feature _____.",
        "type": "fill_blank",
        "answers": [
            "key"
        ],
        "other_options": [
            "reducer",
            "action",
            "effect"
        ]
    },
    {
        "q": "Rearrange feature setup:",
        "type": "rearrange",
        "words": [
            "Create feature state interface",
            "Create reducer",
            "Register with forFeature",
            "Create selectors",
            "Create effects"
        ]
    },
    {
        "q": "What is EffectsModule.forRoot()?",
        "type": "mcq",
        "o": [
            "Registers root effects",
            "Registers reducers",
            "Registers selectors",
            "Registers actions"
        ]
    },
    {
        "q": "forRoot([]) is needed even with no root effects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this register?",
        "type": "mcq",
        "c": "EffectsModule.forRoot([AppEffects])",
        "o": [
            "App-level effects class",
            "Feature effects",
            "Reducers",
            "Actions"
        ]
    },
    {
        "q": "EffectsModule.forRoot takes array of _____ classes.",
        "type": "fill_blank",
        "answers": [
            "effects"
        ],
        "other_options": [
            "reducer",
            "action",
            "selector"
        ]
    },
    {
        "q": "Match effects registration:",
        "type": "match",
        "left": [
            "EffectsModule.forRoot",
            "EffectsModule.forFeature"
        ],
        "right": [
            "App module",
            "Feature module"
        ]
    },
    {
        "q": "What is store.dispatch()?",
        "type": "mcq",
        "o": [
            "Sends action to store",
            "Selects state",
            "Creates reducer",
            "Creates effect"
        ]
    },
    {
        "q": "dispatch() triggers reducer execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "this.store.dispatch(loadUsers())",
        "o": [
            "Dispatches loadUsers action",
            "Loads users directly",
            "Selects users",
            "Creates users"
        ]
    },
    {
        "q": "dispatch() accepts _____ object.",
        "type": "fill_blank",
        "answers": [
            "action"
        ],
        "other_options": [
            "state",
            "reducer",
            "selector"
        ]
    },
    {
        "q": "Match dispatch flow:",
        "type": "match",
        "left": [
            "Component dispatches",
            "Effects intercept",
            "Reducer processes",
            "Store updates"
        ],
        "right": [
            "Trigger action",
            "Side effects",
            "State change",
            "Notify subscribers"
        ]
    },
    {
        "q": "What is store.select()?",
        "type": "mcq",
        "o": [
            "Returns Observable of state slice",
            "Dispatches action",
            "Creates reducer",
            "Creates effect"
        ]
    },
    {
        "q": "select() returns Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this return?",
        "type": "mcq",
        "c": "this.users$ = this.store.select(selectAllUsers);",
        "o": [
            "Observable of users array",
            "Users directly",
            "Action",
            "Reducer"
        ]
    },
    {
        "q": "select() accepts _____ as argument.",
        "type": "fill_blank",
        "answers": [
            "selector"
        ],
        "other_options": [
            "action",
            "reducer",
            "effect"
        ]
    },
    {
        "q": "Match select patterns:",
        "type": "match",
        "left": [
            "select(selector)",
            "selectSignal(selector)"
        ],
        "right": [
            "Observable",
            "Signal"
        ]
    },
    {
        "q": "What is EntityState?",
        "type": "mcq",
        "o": [
            "Predefined state shape for collections",
            "Single entity",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "EntityState has ids and entities properties.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does EntityState include?",
        "type": "mcq",
        "o": [
            "ids array and entities dictionary",
            "Single array",
            "Only objects",
            "Only ids"
        ]
    },
    {
        "q": "EntityState uses _____ for fast lookup.",
        "type": "fill_blank",
        "answers": [
            "dictionary"
        ],
        "other_options": [
            "array",
            "set",
            "list"
        ]
    },
    {
        "q": "Match entity structure:",
        "type": "match",
        "left": [
            "ids",
            "entities"
        ],
        "right": [
            "Ordered array",
            "Id-to-entity map"
        ]
    },
    {
        "q": "What is EntityAdapter?",
        "type": "mcq",
        "o": [
            "Helper for CRUD operations on entities",
            "Single entity",
            "Action creator",
            "Effect creator"
        ]
    },
    {
        "q": "EntityAdapter provides pre-built reducers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does createEntityAdapter() return?",
        "type": "mcq",
        "o": [
            "Adapter with CRUD methods",
            "Reducer",
            "Selector",
            "Effect"
        ]
    },
    {
        "q": "EntityAdapter simplifies _____ operations.",
        "type": "fill_blank",
        "answers": [
            "entity"
        ],
        "other_options": [
            "action",
            "effect",
            "selector"
        ]
    },
    {
        "q": "Match adapter methods:",
        "type": "match",
        "left": [
            "addOne",
            "addMany",
            "updateOne",
            "removeOne"
        ],
        "right": [
            "Add single entity",
            "Add multiple entities",
            "Update entity",
            "Delete entity"
        ]
    },
    {
        "q": "What is adapter.getInitialState()?",
        "type": "mcq",
        "o": [
            "Creates empty EntityState",
            "Gets current state",
            "Gets entities",
            "Gets ids"
        ]
    },
    {
        "q": "getInitialState can include extra state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "adapter.getInitialState({loading: false, error: null})",
        "o": [
            "Initial state with custom properties",
            "Entities only",
            "Ids only",
            "Empty object"
        ]
    },
    {
        "q": "getInitialState adds ids and _____ properties.",
        "type": "fill_blank",
        "answers": [
            "entities"
        ],
        "other_options": [
            "actions",
            "effects",
            "selectors"
        ]
    },
    {
        "q": "Rearrange entity setup:",
        "type": "rearrange",
        "words": [
            "Create entity adapter",
            "Get initial state",
            "Create reducer with adapter methods",
            "Export adapter selectors",
            "Use in component"
        ]
    },
    {
        "q": "What is adapter.getSelectors()?",
        "type": "mcq",
        "o": [
            "Creates entity collection selectors",
            "Creates actions",
            "Creates effects",
            "Creates reducer"
        ]
    },
    {
        "q": "getSelectors returns selectAll and selectEntities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "const {selectAll, selectTotal} = adapter.getSelectors();",
        "o": [
            "Entity selectors for array and count",
            "Actions",
            "Reducers",
            "Effects"
        ]
    },
    {
        "q": "getSelectors provides selectAll, selectIds, selectEntities, and _____.",
        "type": "fill_blank",
        "answers": [
            "selectTotal"
        ],
        "other_options": [
            "selectOne",
            "selectFirst",
            "selectLast"
        ]
    },
    {
        "q": "Match entity selectors:",
        "type": "match",
        "left": [
            "selectAll",
            "selectIds",
            "selectEntities",
            "selectTotal"
        ],
        "right": [
            "Array of entities",
            "Array of ids",
            "Entity dictionary",
            "Count"
        ]
    },
    {
        "q": "What is adapter.upsertOne()?",
        "type": "mcq",
        "o": [
            "Updates if exists, adds if not",
            "Only adds",
            "Only updates",
            "Deletes"
        ]
    },
    {
        "q": "upsertOne combines add and update logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does upsertOne do?",
        "type": "mcq",
        "c": "adapter.upsertOne(entity, state)",
        "o": [
            "Add or update entity based on id",
            "Only add",
            "Only update",
            "Delete"
        ]
    },
    {
        "q": "upsertOne uses _____ to check existence.",
        "type": "fill_blank",
        "answers": [
            "id"
        ],
        "other_options": [
            "name",
            "index",
            "type"
        ]
    },
    {
        "q": "Match upsert operations:",
        "type": "match",
        "left": [
            "upsertOne",
            "upsertMany",
            "setAll"
        ],
        "right": [
            "Single entity",
            "Multiple entities",
            "Replace all"
        ]
    },
    {
        "q": "What is adapter.setAll()?",
        "type": "mcq",
        "o": [
            "Replaces all entities with new array",
            "Adds entities",
            "Updates entities",
            "Removes entities"
        ]
    },
    {
        "q": "setAll clears existing entities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does setAll do?",
        "type": "mcq",
        "c": "adapter.setAll(users, state)",
        "o": [
            "Replace all entities with new users",
            "Add to existing",
            "Update existing",
            "Nothing"
        ]
    },
    {
        "q": "setAll is useful for _____ data loading.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "partial",
            "incremental",
            "delayed"
        ]
    },
    {
        "q": "Match batch operations:",
        "type": "match",
        "left": [
            "setAll",
            "addMany",
            "removeMany"
        ],
        "right": [
            "Replace all",
            "Append multiple",
            "Delete multiple"
        ]
    },
    {
        "q": "What is @ngrx/router-store?",
        "type": "mcq",
        "o": [
            "Syncs router state to NgRx store",
            "HTTP library",
            "Forms library",
            "Animation library"
        ]
    },
    {
        "q": "Router store tracks navigation in state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does StoreRouterConnectingModule do?",
        "type": "mcq",
        "o": [
            "Connects Angular router to NgRx store",
            "Creates routes",
            "Lazy loads modules",
            "Handles guards"
        ]
    },
    {
        "q": "Router store stores route _____ in state.",
        "type": "fill_blank",
        "answers": [
            "params"
        ],
        "other_options": [
            "components",
            "guards",
            "resolvers"
        ]
    },
    {
        "q": "Match router store features:",
        "type": "match",
        "left": [
            "routerReducer",
            "RouterState",
            "getRouterSelectors"
        ],
        "right": [
            "State updates",
            "State shape",
            "Query selectors"
        ]
    },
    {
        "q": "What is getRouterSelectors()?",
        "type": "mcq",
        "o": [
            "Creates selectors for router state",
            "Creates actions",
            "Creates reducers",
            "Creates effects"
        ]
    },
    {
        "q": "getRouterSelectors provides selectUrl.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does selectRouteParams select?",
        "type": "mcq",
        "o": [
            "Current route parameters",
            "All routes",
            "Route config",
            "Guards"
        ]
    },
    {
        "q": "Router selectors include selectUrl and _____.",
        "type": "fill_blank",
        "answers": [
            "selectRouteParams"
        ],
        "other_options": [
            "selectRoute",
            "selectPath",
            "selectModule"
        ]
    },
    {
        "q": "Match router selectors:",
        "type": "match",
        "left": [
            "selectUrl",
            "selectRouteParams",
            "selectQueryParams"
        ],
        "right": [
            "Current URL",
            "Path parameters",
            "Query string"
        ]
    },
    {
        "q": "What is CustomSerializer?",
        "type": "mcq",
        "o": [
            "Custom router state serialization",
            "JSON serializer",
            "Action serializer",
            "Effect serializer"
        ]
    },
    {
        "q": "Custom serializer reduces router state size.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why use custom serializer?",
        "type": "mcq",
        "o": [
            "Extract only needed route data",
            "Full snapshot",
            "All data",
            "Nothing"
        ]
    },
    {
        "q": "Custom serializer implements _____.",
        "type": "fill_blank",
        "answers": [
            "RouterStateSerializer"
        ],
        "other_options": [
            "JsonSerializer",
            "StateSerializer",
            "DataSerializer"
        ]
    },
    {
        "q": "Rearrange router store setup:",
        "type": "rearrange",
        "words": [
            "Import StoreRouterConnectingModule",
            "Add routerReducer to store",
            "Create custom serializer",
            "Register selectors",
            "Use in components"
        ]
    },
    {
        "q": "What is @ngrx/store-devtools?",
        "type": "mcq",
        "o": [
            "Browser extension for debugging",
            "Testing library",
            "Logging library",
            "Analytics library"
        ]
    },
    {
        "q": "DevTools shows action history.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can DevTools do?",
        "type": "mcq",
        "o": [
            "Time-travel debugging",
            "Only logging",
            "Only testing",
            "Nothing"
        ]
    },
    {
        "q": "DevTools allows _____ state changes.",
        "type": "fill_blank",
        "answers": [
            "replaying"
        ],
        "other_options": [
            "deleting",
            "creating",
            "ignoring"
        ]
    },
    {
        "q": "Match DevTools features:",
        "type": "match",
        "left": [
            "Record",
            "Replay",
            "Import/Export"
        ],
        "right": [
            "Track actions",
            "Time-travel",
            "Share state"
        ]
    },
    {
        "q": "What is StoreDevtoolsModule.instrument()?",
        "type": "mcq",
        "o": [
            "Configures DevTools for store",
            "Creates store",
            "Creates actions",
            "Creates effects"
        ]
    },
    {
        "q": "instrument() should only be in development.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "StoreDevtoolsModule.instrument({maxAge: 25, logOnly: environment.production})",
        "o": [
            "DevTools with history limit",
            "Store only",
            "Effects only",
            "Actions only"
        ]
    },
    {
        "q": "maxAge limits _____ history.",
        "type": "fill_blank",
        "answers": [
            "action"
        ],
        "other_options": [
            "state",
            "effect",
            "selector"
        ]
    },
    {
        "q": "Match DevTools config:",
        "type": "match",
        "left": [
            "maxAge",
            "logOnly",
            "autoPause"
        ],
        "right": [
            "History limit",
            "Production mode",
            "Pause on load"
        ]
    },
    {
        "q": "What is createActionGroup()?",
        "type": "mcq",
        "o": [
            "Creates multiple related actions",
            "Single action",
            "Reducer",
            "Selector"
        ]
    },
    {
        "q": "createActionGroup reduces boilerplate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "createActionGroup({source: 'Users', events: {Load: emptyProps(), 'Load Success': props<{users: User[]}>()}})",
        "o": [
            "Load and Load Success actions",
            "Single action",
            "Reducer",
            "Effect"
        ]
    },
    {
        "q": "createActionGroup source becomes action _____ prefix.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "name",
            "payload",
            "value"
        ]
    },
    {
        "q": "Match action group concepts:",
        "type": "match",
        "left": [
            "source",
            "events",
            "emptyProps"
        ],
        "right": [
            "Action prefix",
            "Action definitions",
            "No payload"
        ]
    },
    {
        "q": "What is emptyProps()?",
        "type": "mcq",
        "o": [
            "Action with no payload",
            "Action with payload",
            "Empty reducer",
            "Empty effect"
        ]
    },
    {
        "q": "emptyProps() replaces props<void>().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When use emptyProps()?",
        "type": "mcq",
        "o": [
            "Actions that need no data",
            "All actions",
            "Never",
            "Effects only"
        ]
    },
    {
        "q": "emptyProps indicates no _____ needed.",
        "type": "fill_blank",
        "answers": [
            "payload"
        ],
        "other_options": [
            "type",
            "action",
            "effect"
        ]
    },
    {
        "q": "Match props patterns:",
        "type": "match",
        "left": [
            "emptyProps()",
            "props<{id: number}>()",
            "props<{data: User[]}>()"
        ],
        "right": [
            "No payload",
            "Single property",
            "Array payload"
        ]
    },
    {
        "q": "What is ComponentStore?",
        "type": "mcq",
        "o": [
            "Local state management for components",
            "Global store",
            "Service",
            "Directive"
        ]
    },
    {
        "q": "ComponentStore is from @ngrx/component-store.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When use ComponentStore?",
        "type": "mcq",
        "o": [
            "Component-specific state not needed globally",
            "Always",
            "Never",
            "Only services"
        ]
    },
    {
        "q": "ComponentStore is alternative to _____ for local state.",
        "type": "fill_blank",
        "answers": [
            "global"
        ],
        "other_options": [
            "local",
            "service",
            "component"
        ]
    },
    {
        "q": "Match state scope:",
        "type": "match",
        "left": [
            "NgRx Store",
            "ComponentStore"
        ],
        "right": [
            "Global state",
            "Component state"
        ]
    },
    {
        "q": "What is ComponentStore.select()?",
        "type": "mcq",
        "o": [
            "Creates observable from state slice",
            "Updates state",
            "Creates effect",
            "Dispatches action"
        ]
    },
    {
        "q": "ComponentStore select is reactive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "readonly count$ = this.select(state => state.count);",
        "o": [
            "Observable of count property",
            "Count value",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "ComponentStore select returns _____.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "value",
            "Promise",
            "signal"
        ]
    },
    {
        "q": "Match ComponentStore methods:",
        "type": "match",
        "left": [
            "select",
            "updater",
            "effect"
        ],
        "right": [
            "Read state",
            "Modify state",
            "Side effects"
        ]
    },
    {
        "q": "What is ComponentStore.updater()?",
        "type": "mcq",
        "o": [
            "Creates state update function",
            "Creates selector",
            "Creates effect",
            "Creates action"
        ]
    },
    {
        "q": "updater replaces state immutably.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this updater do?",
        "type": "mcq",
        "c": "readonly increment = this.updater(state => ({...state, count: state.count + 1}));",
        "o": [
            "Increases count by 1",
            "Decreases count",
            "Resets count",
            "Nothing"
        ]
    },
    {
        "q": "updater takes state and returns new _____.",
        "type": "fill_blank",
        "answers": [
            "state"
        ],
        "other_options": [
            "action",
            "effect",
            "selector"
        ]
    },
    {
        "q": "Match updater patterns:",
        "type": "match",
        "left": [
            "Synchronous updater",
            "Updater with value",
            "Updater with Observable"
        ],
        "right": [
            "Direct call",
            "Pass parameter",
            "Reactive updates"
        ]
    },
    {
        "q": "What is ComponentStore.effect()?",
        "type": "mcq",
        "o": [
            "Handles side effects for local state",
            "Pure state update",
            "Selector",
            "Action"
        ]
    },
    {
        "q": "ComponentStore effects handle async operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this effect do?",
        "type": "mcq",
        "c": "readonly loadData = this.effect<void>(trigger$ => trigger$.pipe(switchMap(() => this.api.getData())))",
        "o": [
            "Loads data on trigger",
            "Updates state",
            "Creates selector",
            "Nothing"
        ]
    },
    {
        "q": "ComponentStore effects receive _____ of triggers.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "value",
            "Promise",
            "array"
        ]
    },
    {
        "q": "Match ComponentStore lifecycle:",
        "type": "match",
        "left": [
            "constructor",
            "setState",
            "destroy"
        ],
        "right": [
            "Initialize",
            "Update",
            "Cleanup"
        ]
    },
    {
        "q": "What is setState()?",
        "type": "mcq",
        "o": [
            "Directly sets entire state",
            "Partial update",
            "Selector",
            "Effect"
        ]
    },
    {
        "q": "setState can take object or callback.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "this.setState({count: 0, items: []})",
        "o": [
            "Sets entire state",
            "Partial update",
            "Creates selector",
            "Triggers effect"
        ]
    },
    {
        "q": "setState replaces _____ state.",
        "type": "fill_blank",
        "answers": [
            "entire"
        ],
        "other_options": [
            "partial",
            "single",
            "no"
        ]
    },
    {
        "q": "Match state update methods:",
        "type": "match",
        "left": [
            "setState",
            "updater",
            "patchState"
        ],
        "right": [
            "Replace all",
            "Custom update",
            "Partial update"
        ]
    },
    {
        "q": "What is patchState()?",
        "type": "mcq",
        "o": [
            "Partially updates state",
            "Replaces entire state",
            "Selector",
            "Effect"
        ]
    },
    {
        "q": "patchState merges with existing state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "this.patchState({loading: true})",
        "o": [
            "Updates only loading property",
            "Replaces all",
            "Clears state",
            "Nothing"
        ]
    },
    {
        "q": "patchState is useful for _____ updates.",
        "type": "fill_blank",
        "answers": [
            "partial"
        ],
        "other_options": [
            "full",
            "no",
            "delayed"
        ]
    },
    {
        "q": "Rearrange ComponentStore setup:",
        "type": "rearrange",
        "words": [
            "Extend ComponentStore",
            "Define initial state",
            "Create selectors",
            "Create updaters",
            "Create effects"
        ]
    },
    {
        "q": "What is selectSignal()?",
        "type": "mcq",
        "o": [
            "Returns Signal instead of Observable",
            "Returns Observable",
            "Creates action",
            "Creates effect"
        ]
    },
    {
        "q": "selectSignal is for Angular Signals integration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does selectSignal return?",
        "type": "mcq",
        "c": "this.store.selectSignal(selectAllUsers)",
        "o": [
            "Signal of users",
            "Observable",
            "Promise",
            "Array"
        ]
    },
    {
        "q": "selectSignal works with Angular _____.",
        "type": "fill_blank",
        "answers": [
            "Signals"
        ],
        "other_options": [
            "Observables",
            "Promises",
            "Events"
        ]
    },
    {
        "q": "Match signal integration:",
        "type": "match",
        "left": [
            "selectSignal",
            "select"
        ],
        "right": [
            "Signal output",
            "Observable output"
        ]
    },
    {
        "q": "What is meta-reducer?",
        "type": "mcq",
        "o": [
            "Reducer that wraps other reducers",
            "Regular reducer",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "Meta-reducers run before regular reducers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can meta-reducers do?",
        "type": "mcq",
        "o": [
            "Logging, error handling, state persistence",
            "Nothing special",
            "Only logging",
            "Only errors"
        ]
    },
    {
        "q": "Meta-reducers are higher-order _____.",
        "type": "fill_blank",
        "answers": [
            "functions"
        ],
        "other_options": [
            "components",
            "services",
            "pipes"
        ]
    },
    {
        "q": "Match meta-reducer uses:",
        "type": "match",
        "left": [
            "Logger",
            "Clear state",
            "Persist state"
        ],
        "right": [
            "Debug actions",
            "Reset on logout",
            "Local storage"
        ]
    },
    {
        "q": "What is this meta-reducer for?",
        "type": "mcq",
        "c": "function logger(reducer) { return (state, action) => { console.log('action', action); return reducer(state, action); }; }",
        "o": [
            "Logging all actions",
            "Error handling",
            "State persistence",
            "Nothing"
        ]
    },
    {
        "q": "Meta-reducers are registered in forRoot.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "StoreModule.forRoot(reducers, {metaReducers: [logger]})",
        "o": [
            "Root store with logging meta-reducer",
            "Effects",
            "Selectors",
            "Actions"
        ]
    },
    {
        "q": "Meta-reducers array order determines execution _____.",
        "type": "fill_blank",
        "answers": [
            "order"
        ],
        "other_options": [
            "type",
            "speed",
            "priority"
        ]
    },
    {
        "q": "Match forRoot options:",
        "type": "match",
        "left": [
            "metaReducers",
            "runtimeChecks",
            "initialState"
        ],
        "right": [
            "Wrapper reducers",
            "Development checks",
            "Preload state"
        ]
    },
    {
        "q": "What is runtimeChecks?",
        "type": "mcq",
        "o": [
            "Development-time checks for NgRx rules",
            "Production optimizations",
            "Testing utilities",
            "Logging"
        ]
    },
    {
        "q": "runtimeChecks help catch common NgRx mistakes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does strictStateImmutability check?",
        "type": "mcq",
        "o": [
            "State mutations are prohibited",
            "Actions are valid",
            "Effects work",
            "Selectors memoize"
        ]
    },
    {
        "q": "runtimeChecks are for _____ environment only.",
        "type": "fill_blank",
        "answers": [
            "development"
        ],
        "other_options": [
            "production",
            "testing",
            "staging"
        ]
    },
    {
        "q": "Match runtime checks:",
        "type": "match",
        "left": [
            "strictStateImmutability",
            "strictActionImmutability",
            "strictActionSerializability"
        ],
        "right": [
            "No state mutation",
            "No action mutation",
            "Actions serializable"
        ]
    },
    {
        "q": "What is strictActionSerializability?",
        "type": "mcq",
        "o": [
            "Checks actions can be serialized",
            "Checks state",
            "Checks effects",
            "Checks selectors"
        ]
    },
    {
        "q": "Serializable actions work with DevTools.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should actions not contain?",
        "type": "mcq",
        "o": [
            "Functions, Dates, Maps, Sets",
            "Strings",
            "Numbers",
            "Plain objects"
        ]
    },
    {
        "q": "DevTools needs _____ actions and state.",
        "type": "fill_blank",
        "answers": [
            "serializable"
        ],
        "other_options": [
            "complex",
            "typed",
            "validated"
        ]
    },
    {
        "q": "Match serialization rules:",
        "type": "match",
        "left": [
            "Plain object",
            "Date object",
            "Function"
        ],
        "right": [
            "Allowed",
            "Not serializable",
            "Not serializable"
        ]
    },
    {
        "q": "What is strictActionWithinNgZone?",
        "type": "mcq",
        "o": [
            "Checks actions dispatched in Angular zone",
            "Checks state",
            "Checks effects",
            "Checks selectors"
        ]
    },
    {
        "q": "Actions should be dispatched within NgZone.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What happens if action outside NgZone?",
        "type": "mcq",
        "o": [
            "Change detection may not trigger",
            "Always works",
            "Faster execution",
            "Nothing"
        ]
    },
    {
        "q": "NgZone ensures Angular _____ detection.",
        "type": "fill_blank",
        "answers": [
            "change"
        ],
        "other_options": [
            "error",
            "type",
            "state"
        ]
    },
    {
        "q": "Match zone patterns:",
        "type": "match",
        "left": [
            "Inside NgZone",
            "Outside NgZone"
        ],
        "right": [
            "UI updates",
            "May miss updates"
        ]
    },
    {
        "q": "What is @ngrx/effects testing?",
        "type": "mcq",
        "o": [
            "Testing effects with marble testing",
            "Testing reducers",
            "Testing selectors",
            "Testing actions"
        ]
    },
    {
        "q": "Effects can be tested with provideMockActions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does provideMockActions do?",
        "type": "mcq",
        "o": [
            "Provides fake actions stream for testing",
            "Creates real actions",
            "Creates reducers",
            "Creates selectors"
        ]
    },
    {
        "q": "provideMockActions injects mock _____ stream.",
        "type": "fill_blank",
        "answers": [
            "actions"
        ],
        "other_options": [
            "state",
            "effects",
            "selectors"
        ]
    },
    {
        "q": "Match testing utilities:",
        "type": "match",
        "left": [
            "provideMockActions",
            "provideMockStore",
            "getMockStore"
        ],
        "right": [
            "Mock actions",
            "Mock store",
            "Store instance"
        ]
    },
    {
        "q": "What is provideMockStore()?",
        "type": "mcq",
        "o": [
            "Provides mock store for testing",
            "Real store",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "provideMockStore allows setting initial state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "provideMockStore({initialState: {users: []}})",
        "o": [
            "Mock store with initial users state",
            "Real store",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "provideMockStore is from @ngrx/store/_____.",
        "type": "fill_blank",
        "answers": [
            "testing"
        ],
        "other_options": [
            "core",
            "utils",
            "helpers"
        ]
    },
    {
        "q": "Match testing imports:",
        "type": "match",
        "left": [
            "@ngrx/store/testing",
            "@ngrx/effects/testing"
        ],
        "right": [
            "Store testing",
            "Effects testing"
        ]
    },
    {
        "q": "What is overrideSelector()?",
        "type": "mcq",
        "o": [
            "Replaces selector return value for testing",
            "Creates selector",
            "Deletes selector",
            "Nothing"
        ]
    },
    {
        "q": "overrideSelector simplifies testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "mockStore.overrideSelector(selectUsers, [{id: 1}])",
        "o": [
            "Returns mock users for selectUsers",
            "Creates users",
            "Deletes users",
            "Nothing"
        ]
    },
    {
        "q": "overrideSelector bypasses actual _____ logic.",
        "type": "fill_blank",
        "answers": [
            "selector"
        ],
        "other_options": [
            "reducer",
            "effect",
            "action"
        ]
    },
    {
        "q": "Match testing patterns:",
        "type": "match",
        "left": [
            "overrideSelector",
            "setState",
            "dispatch"
        ],
        "right": [
            "Mock return value",
            "Set state directly",
            "Trigger action"
        ]
    },
    {
        "q": "What is concatLatestFrom()?",
        "type": "mcq",
        "o": [
            "Combines action with latest store state",
            "Concatenates observables",
            "Combines actions",
            "Nothing"
        ]
    },
    {
        "q": "concatLatestFrom is alternative to withLatestFrom.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why use concatLatestFrom over withLatestFrom?",
        "type": "mcq",
        "o": [
            "Lazy evaluation for better performance",
            "Same behavior",
            "Faster",
            "No difference"
        ]
    },
    {
        "q": "concatLatestFrom uses _____ evaluation.",
        "type": "fill_blank",
        "answers": [
            "lazy"
        ],
        "other_options": [
            "eager",
            "immediate",
            "sync"
        ]
    },
    {
        "q": "Match operator patterns:",
        "type": "match",
        "left": [
            "concatLatestFrom",
            "withLatestFrom"
        ],
        "right": [
            "Lazy NgRx",
            "Eager RxJS"
        ]
    },
    {
        "q": "What does this effect do?",
        "type": "mcq",
        "c": "this.actions$.pipe(ofType(saveUser), concatLatestFrom(() => this.store.select(selectCurrentUser)), map(([action, user]) => ...))",
        "o": [
            "Gets current user when save dispatched",
            "Saves directly",
            "Nothing",
            "Errors"
        ]
    },
    {
        "q": "concatLatestFrom accepts function returning Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the function syntax for?",
        "type": "mcq",
        "c": "concatLatestFrom(action => this.store.select(selectItemById(action.id)))",
        "o": [
            "Access action in selector",
            "No access",
            "Access state",
            "Nothing"
        ]
    },
    {
        "q": "concatLatestFrom subscribes to selector only when action _____.",
        "type": "fill_blank",
        "answers": [
            "arrives"
        ],
        "other_options": [
            "creates",
            "dispatches",
            "completes"
        ]
    },
    {
        "q": "Rearrange effect with concatLatestFrom:",
        "type": "rearrange",
        "words": [
            "Listen for action",
            "Get latest state lazily",
            "Destructure action and state",
            "Process data",
            "Return new action"
        ]
    },
    {
        "q": "What is @ngrx/data?",
        "type": "mcq",
        "o": [
            "Simplified entity management library",
            "Database library",
            "Forms library",
            "HTTP library"
        ]
    },
    {
        "q": "@ngrx/data reduces boilerplate for CRUD.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does @ngrx/data provide?",
        "type": "mcq",
        "o": [
            "Pre-built actions, reducers, selectors for entities",
            "Custom everything",
            "Nothing pre-built",
            "Only actions"
        ]
    },
    {
        "q": "@ngrx/data is built on @ngrx/_____.",
        "type": "fill_blank",
        "answers": [
            "entity"
        ],
        "other_options": [
            "store",
            "effects",
            "router"
        ]
    },
    {
        "q": "Match data patterns:",
        "type": "match",
        "left": [
            "@ngrx/entity",
            "@ngrx/data"
        ],
        "right": [
            "Manual CRUD setup",
            "Automatic CRUD setup"
        ]
    },
    {
        "q": "What is EntityCollectionService?",
        "type": "mcq",
        "o": [
            "Service for entity CRUD operations",
            "Store",
            "Effect",
            "Reducer"
        ]
    },
    {
        "q": "EntityCollectionService provides getAll, add, update, delete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "this.userService.getAll()",
        "o": [
            "Fetches and stores all users",
            "Returns users only",
            "Deletes users",
            "Nothing"
        ]
    },
    {
        "q": "EntityCollectionService handles HTTP and _____ updates.",
        "type": "fill_blank",
        "answers": [
            "store"
        ],
        "other_options": [
            "local",
            "cache",
            "session"
        ]
    },
    {
        "q": "Match EntityCollectionService methods:",
        "type": "match",
        "left": [
            "getAll",
            "add",
            "update",
            "delete"
        ],
        "right": [
            "Fetch all",
            "Create entity",
            "Modify entity",
            "Remove entity"
        ]
    },
    {
        "q": "What is entityMetadata?",
        "type": "mcq",
        "o": [
            "Configuration for entity collections",
            "Actions",
            "Effects",
            "Reducers"
        ]
    },
    {
        "q": "entityMetadata defines entity name and config.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "entityMetadata: {User: {}}",
        "o": [
            "User entity with default config",
            "Custom config",
            "No config",
            "Nothing"
        ]
    },
    {
        "q": "entityMetadata key is entity _____ name.",
        "type": "fill_blank",
        "answers": [
            "collection"
        ],
        "other_options": [
            "action",
            "reducer",
            "effect"
        ]
    },
    {
        "q": "Match metadata options:",
        "type": "match",
        "left": [
            "entityName",
            "selectId",
            "sortComparer"
        ],
        "right": [
            "Collection name",
            "ID function",
            "Sorting"
        ]
    },
    {
        "q": "What is DefaultDataService?",
        "type": "mcq",
        "o": [
            "Default HTTP service for entities",
            "Store service",
            "Effect service",
            "Reducer service"
        ]
    },
    {
        "q": "DefaultDataService uses /api/entity-name pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does DefaultDataService handle?",
        "type": "mcq",
        "o": [
            "HTTP CRUD operations",
            "Store operations",
            "Effect operations",
            "Reducer operations"
        ]
    },
    {
        "q": "DefaultDataService can be _____ per entity.",
        "type": "fill_blank",
        "answers": [
            "customized"
        ],
        "other_options": [
            "deleted",
            "ignored",
            "removed"
        ]
    },
    {
        "q": "Match data service patterns:",
        "type": "match",
        "left": [
            "DefaultDataService",
            "Custom DataService",
            "EntityDataService"
        ],
        "right": [
            "Standard REST",
            "Custom endpoints",
            "Register services"
        ]
    },
    {
        "q": "What is facade pattern in NgRx?",
        "type": "mcq",
        "o": [
            "Service abstracting store interactions",
            "Reducer pattern",
            "Effect pattern",
            "Selector pattern"
        ]
    },
    {
        "q": "Facades simplify component-store interaction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does facade hide?",
        "type": "mcq",
        "o": [
            "Store dispatch and select details",
            "Components",
            "Templates",
            "Styles"
        ]
    },
    {
        "q": "Facades provide cleaner _____ for components.",
        "type": "fill_blank",
        "answers": [
            "API"
        ],
        "other_options": [
            "store",
            "actions",
            "effects"
        ]
    },
    {
        "q": "Match facade benefits:",
        "type": "match",
        "left": [
            "Encapsulation",
            "Testability",
            "Reusability"
        ],
        "right": [
            "Hide complexity",
            "Easy to mock",
            "Share logic"
        ]
    },
    {
        "q": "What is effect lifecycle?",
        "type": "mcq",
        "o": [
            "Init, normal, error, complete",
            "Start only",
            "End only",
            "No lifecycle"
        ]
    },
    {
        "q": "Effects have OnInitEffects interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is OnInitEffects?",
        "type": "mcq",
        "o": [
            "Interface to run action when effects initialize",
            "Destroy hook",
            "Error hook",
            "Nothing"
        ]
    },
    {
        "q": "OnInitEffects ngrxOnInitEffects returns _____.",
        "type": "fill_blank",
        "answers": [
            "Action"
        ],
        "other_options": [
            "Observable",
            "void",
            "state"
        ]
    },
    {
        "q": "Match effect lifecycle:",
        "type": "match",
        "left": [
            "OnInitEffects",
            "OnRunEffects",
            "OnIdentifyEffects"
        ],
        "right": [
            "Init action",
            "Control lifecycle",
            "Instance identification"
        ]
    },
    {
        "q": "What is OnRunEffects?",
        "type": "mcq",
        "o": [
            "Controls effect lifecycle with custom logic",
            "Init effects",
            "Destroy effects",
            "Nothing"
        ]
    },
    {
        "q": "OnRunEffects can pause effects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ngrxOnRunEffects do?",
        "type": "mcq",
        "o": [
            "Wraps resolvedEffects$ with custom Observable",
            "Creates effects",
            "Destroys effects",
            "Nothing"
        ]
    },
    {
        "q": "OnRunEffects receives resolvedEffects$ _____.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "array",
            "value",
            "action"
        ]
    },
    {
        "q": "Match lifecycle interfaces:",
        "type": "match",
        "left": [
            "ngrxOnInitEffects",
            "ngrxOnRunEffects"
        ],
        "right": [
            "Return init action",
            "Return modified effects$"
        ]
    },
    {
        "q": "What is functional effects?",
        "type": "mcq",
        "o": [
            "Effects without class using functions",
            "Class effects",
            "No effects",
            "Reducers"
        ]
    },
    {
        "q": "Functional effects reduce boilerplate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "export const loadUsers$ = createEffect(actions$ => actions$.pipe(ofType(load), ...))",
        "o": [
            "Functional effect outside class",
            "Class effect",
            "Reducer",
            "Selector"
        ]
    },
    {
        "q": "Functional effects use _____ injection.",
        "type": "fill_blank",
        "answers": [
            "inject"
        ],
        "other_options": [
            "constructor",
            "Input",
            "Output"
        ]
    },
    {
        "q": "Match effect styles:",
        "type": "match",
        "left": [
            "Class effects",
            "Functional effects"
        ],
        "right": [
            "Injectable class",
            "Exported functions"
        ]
    },
    {
        "q": "What is inject() in functional effects?",
        "type": "mcq",
        "o": [
            "Gets dependencies without constructor",
            "Creates effect",
            "Destroys effect",
            "Nothing"
        ]
    },
    {
        "q": "inject() works in injection context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this inject?",
        "type": "mcq",
        "c": "const actions$ = inject(Actions);",
        "o": [
            "Actions stream",
            "Store",
            "Service",
            "Nothing"
        ]
    },
    {
        "q": "inject() from @angular/core replaces _____.",
        "type": "fill_blank",
        "answers": [
            "constructor"
        ],
        "other_options": [
            "provide",
            "imports",
            "exports"
        ]
    },
    {
        "q": "Match injection patterns:",
        "type": "match",
        "left": [
            "Constructor DI",
            "inject() function"
        ],
        "right": [
            "Class-based",
            "Function-based"
        ]
    },
    {
        "q": "What is feature state interface?",
        "type": "mcq",
        "o": [
            "TypeScript interface for feature state shape",
            "Action interface",
            "Effect interface",
            "Selector interface"
        ]
    },
    {
        "q": "Feature state should be typed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this define?",
        "type": "mcq",
        "c": "interface UserState { users: User[]; loading: boolean; error: string | null; }",
        "o": [
            "User feature state shape",
            "Action shape",
            "Effect shape",
            "Selector shape"
        ]
    },
    {
        "q": "Feature state interfaces ensure type _____.",
        "type": "fill_blank",
        "answers": [
            "safety"
        ],
        "other_options": [
            "errors",
            "casting",
            "checking"
        ]
    },
    {
        "q": "Match state patterns:",
        "type": "match",
        "left": [
            "Feature state",
            "App state",
            "Entity state"
        ],
        "right": [
            "Module-specific",
            "Root-level",
            "Collection state"
        ]
    },
    {
        "q": "What is AppState?",
        "type": "mcq",
        "o": [
            "Root interface combining all feature states",
            "Single feature",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "AppState maps feature names to state interfaces.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this define?",
        "type": "mcq",
        "c": "interface AppState { users: UserState; products: ProductState; }",
        "o": [
            "Root state with multiple features",
            "Single feature",
            "Action",
            "Effect"
        ]
    },
    {
        "q": "AppState is passed to Store<_____> generic.",
        "type": "fill_blank",
        "answers": [
            "AppState"
        ],
        "other_options": [
            "State",
            "Root",
            "Feature"
        ]
    },
    {
        "q": "Match typing patterns:",
        "type": "match",
        "left": [
            "Store<AppState>",
            "Store<UserState>",
            "Store"
        ],
        "right": [
            "Full app typing",
            "Feature typing",
            "No typing"
        ]
    },
    {
        "q": "What is createFeature()?",
        "type": "mcq",
        "o": [
            "Creates feature state with auto-generated selectors",
            "Creates action",
            "Creates effect",
            "Creates reducer only"
        ]
    },
    {
        "q": "createFeature auto-generates selectors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does createFeature provide?",
        "type": "mcq",
        "c": "createFeature({name: 'users', reducer: userReducer})",
        "o": [
            "Reducer, feature key, and selectors",
            "Only reducer",
            "Only selectors",
            "Only name"
        ]
    },
    {
        "q": "createFeature reduces _____ for feature setup.",
        "type": "fill_blank",
        "answers": [
            "boilerplate"
        ],
        "other_options": [
            "speed",
            "size",
            "complexity"
        ]
    },
    {
        "q": "Match createFeature outputs:",
        "type": "match",
        "left": [
            "name",
            "reducer",
            "selectXyzState",
            "selectProperty"
        ],
        "right": [
            "Feature key",
            "Feature reducer",
            "Feature selector",
            "Property selectors"
        ]
    },
    {
        "q": "What selectors does createFeature generate?",
        "type": "mcq",
        "o": [
            "One for feature and one per state property",
            "Only feature selector",
            "No selectors",
            "Custom selectors"
        ]
    },
    {
        "q": "createFeature property selectors are prefixed with select.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this generate?",
        "type": "mcq",
        "c": "createFeature({name: 'counter', reducer, extraSelectors: ({selectCount}) => ({doubled: createSelector(selectCount, c => c * 2)})})",
        "o": [
            "Feature with custom doubled selector",
            "Only reducer",
            "Only count selector",
            "Nothing extra"
        ]
    },
    {
        "q": "extraSelectors receives _____ for composition.",
        "type": "fill_blank",
        "answers": [
            "generated selectors"
        ],
        "other_options": [
            "actions",
            "effects",
            "reducers"
        ]
    },
    {
        "q": "Rearrange createFeature usage:",
        "type": "rearrange",
        "words": [
            "Define initial state",
            "Create reducer with createReducer",
            "Call createFeature",
            "Destructure name and selectors",
            "Use in module and components"
        ]
    },
    {
        "q": "What is signalStore?",
        "type": "mcq",
        "o": [
            "Signal-based reactive store",
            "Observable store",
            "Promise store",
            "Callback store"
        ]
    },
    {
        "q": "signalStore integrates with Angular Signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does signalStore use?",
        "type": "mcq",
        "o": [
            "Signals instead of Observables",
            "Observables only",
            "Promises",
            "Events"
        ]
    },
    {
        "q": "signalStore is alternative to _____ for signal apps.",
        "type": "fill_blank",
        "answers": [
            "ComponentStore"
        ],
        "other_options": [
            "Store",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "Match store types:",
        "type": "match",
        "left": [
            "Store",
            "ComponentStore",
            "signalStore"
        ],
        "right": [
            "Global Observable",
            "Local Observable",
            "Local Signals"
        ]
    },
    {
        "q": "What is withState() in signalStore?",
        "type": "mcq",
        "o": [
            "Defines initial state shape",
            "Adds methods",
            "Adds effects",
            "Nothing"
        ]
    },
    {
        "q": "withState creates signal from initial state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this define?",
        "type": "mcq",
        "c": "signalStore(withState({count: 0}))",
        "o": [
            "Signal store with count state",
            "Observable store",
            "Just value",
            "Nothing"
        ]
    },
    {
        "q": "withState is first _____ for signalStore.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "effect",
            "action",
            "reducer"
        ]
    },
    {
        "q": "Match signalStore features:",
        "type": "match",
        "left": [
            "withState",
            "withMethods",
            "withComputed"
        ],
        "right": [
            "Define state",
            "Add actions",
            "Computed values"
        ]
    },
    {
        "q": "What is action hygiene?",
        "type": "mcq",
        "o": [
            "Best practices for action naming and structure",
            "Action cleanup",
            "Action deletion",
            "Action testing"
        ]
    },
    {
        "q": "Actions should be descriptive and unique.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good action naming?",
        "type": "mcq",
        "o": [
            "[Source] Event description",
            "Random names",
            "Short codes",
            "Numbers"
        ]
    },
    {
        "q": "Action type should describe _____ not command.",
        "type": "fill_blank",
        "answers": [
            "event"
        ],
        "other_options": [
            "command",
            "data",
            "state"
        ]
    },
    {
        "q": "Match action naming:",
        "type": "match",
        "left": [
            "[Login Page] Login",
            "[Auth API] Login Success",
            "[Auth API] Login Failure"
        ],
        "right": [
            "User initiated",
            "API success",
            "API error"
        ]
    },
    {
        "q": "What is single responsibility for actions?",
        "type": "mcq",
        "o": [
            "One action per event type",
            "Multiple events per action",
            "No actions",
            "Shared actions"
        ]
    },
    {
        "q": "Actions should not be reused across features.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why unique actions per feature?",
        "type": "mcq",
        "o": [
            "Better debugging and traceability",
            "Less code",
            "Faster execution",
            "No reason"
        ]
    },
    {
        "q": "Unique actions improve _____ in DevTools.",
        "type": "fill_blank",
        "answers": [
            "debugging"
        ],
        "other_options": [
            "speed",
            "size",
            "memory"
        ]
    },
    {
        "q": "Match action best practices:",
        "type": "match",
        "left": [
            "Unique per feature",
            "Descriptive names",
            "Event not command"
        ],
        "right": [
            "Avoid conflicts",
            "Self-documenting",
            "Declarative style"
        ]
    },
    {
        "q": "What is selector composition?",
        "type": "mcq",
        "o": [
            "Building complex selectors from simple ones",
            "Single selector",
            "No selectors",
            "Inline selections"
        ]
    },
    {
        "q": "Composed selectors are memoized.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this compose?",
        "type": "mcq",
        "c": "createSelector(selectUsers, selectFilter, (users, filter) => users.filter(u => u.name.includes(filter)))",
        "o": [
            "Filtered users from two selectors",
            "All users",
            "Filter only",
            "Nothing"
        ]
    },
    {
        "q": "Composed selectors recalculate only when inputs _____.",
        "type": "fill_blank",
        "answers": [
            "change"
        ],
        "other_options": [
            "exist",
            "load",
            "initialize"
        ]
    },
    {
        "q": "Match composition patterns:",
        "type": "match",
        "left": [
            "Simple selector",
            "Composed selector",
            "Parameterized selector"
        ],
        "right": [
            "Direct property",
            "Combined data",
            "Factory function"
        ]
    },
    {
        "q": "What is parameterized selector?",
        "type": "mcq",
        "o": [
            "Selector factory that accepts arguments",
            "Fixed selector",
            "No parameters",
            "Action"
        ]
    },
    {
        "q": "Parameterized selectors use factory pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "export const selectUserById = (id: number) => createSelector(selectUsers, users => users.find(u => u.id === id));",
        "o": [
            "Factory returning selector for specific user",
            "All users",
            "Fixed user",
            "Nothing"
        ]
    },
    {
        "q": "Parameterized selectors return _____ per call.",
        "type": "fill_blank",
        "answers": [
            "new selector"
        ],
        "other_options": [
            "same selector",
            "cached value",
            "no selector"
        ]
    },
    {
        "q": "Match selector types:",
        "type": "match",
        "left": [
            "selectAll",
            "selectById(id)",
            "selectFiltered(filter)"
        ],
        "right": [
            "Fixed selector",
            "Parameterized",
            "Parameterized"
        ]
    },
    {
        "q": "What is effect error handling?",
        "type": "mcq",
        "o": [
            "Using catchError to handle API failures",
            "Ignoring errors",
            "Throwing errors",
            "No handling"
        ]
    },
    {
        "q": "Effects should catch errors inside switchMap.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why catch inside switchMap?",
        "type": "mcq",
        "o": [
            "Keeps effect stream alive",
            "Stops effect",
            "No reason",
            "Better performance"
        ]
    },
    {
        "q": "Error handling prevents effect stream from _____.",
        "type": "fill_blank",
        "answers": [
            "dying"
        ],
        "other_options": [
            "starting",
            "loading",
            "completing"
        ]
    },
    {
        "q": "Match error patterns:",
        "type": "match",
        "left": [
            "catchError inside",
            "catchError outside",
            "No catchError"
        ],
        "right": [
            "Effect survives",
            "Effect dies",
            "Effect dies"
        ]
    },
    {
        "q": "What is optimistic update?",
        "type": "mcq",
        "o": [
            "Update UI before API confirms",
            "Wait for API",
            "No update",
            "Pessimistic update"
        ]
    },
    {
        "q": "Optimistic updates improve perceived performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does optimistic update require?",
        "type": "mcq",
        "o": [
            "Rollback on failure",
            "No rollback",
            "No error handling",
            "Wait always"
        ]
    },
    {
        "q": "Optimistic update updates state _____ API response.",
        "type": "fill_blank",
        "answers": [
            "before"
        ],
        "other_options": [
            "after",
            "during",
            "never"
        ]
    },
    {
        "q": "Match update strategies:",
        "type": "match",
        "left": [
            "Optimistic",
            "Pessimistic"
        ],
        "right": [
            "Immediate UI update",
            "Wait for confirmation"
        ]
    },
    {
        "q": "What is state normalization?",
        "type": "mcq",
        "o": [
            "Flattening nested data into entities",
            "Nesting data",
            "Duplicating data",
            "No structure"
        ]
    },
    {
        "q": "Normalized state uses entity dictionaries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why normalize state?",
        "type": "mcq",
        "o": [
            "Avoid duplication and simplify updates",
            "More duplication",
            "Complex updates",
            "No benefit"
        ]
    },
    {
        "q": "Normalized state stores entities by _____.",
        "type": "fill_blank",
        "answers": [
            "id"
        ],
        "other_options": [
            "name",
            "index",
            "type"
        ]
    },
    {
        "q": "Match normalization patterns:",
        "type": "match",
        "left": [
            "Entities dictionary",
            "Ids array",
            "References by id"
        ],
        "right": [
            "Fast lookup",
            "Order preservation",
            "Relationships"
        ]
    },
    {
        "q": "What is lazy loading state?",
        "type": "mcq",
        "o": [
            "Loading feature state when module loads",
            "Loading all at start",
            "No loading",
            "Eager loading"
        ]
    },
    {
        "q": "Lazy loaded modules can have own state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What enables lazy state loading?",
        "type": "mcq",
        "o": [
            "StoreModule.forFeature in lazy module",
            "forRoot only",
            "No module",
            "Effects only"
        ]
    },
    {
        "q": "Lazy state loads with _____ module.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "root",
            "app",
            "core"
        ]
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "Eager state",
            "Lazy state"
        ],
        "right": [
            "App startup",
            "On navigation"
        ]
    },
    {
        "q": "What is state persistence?",
        "type": "mcq",
        "o": [
            "Saving state to local storage",
            "Memory only",
            "No saving",
            "Server only"
        ]
    },
    {
        "q": "Meta-reducers can persist state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern persists state?",
        "type": "mcq",
        "o": [
            "Meta-reducer writing to localStorage",
            "Effect",
            "Selector",
            "Action"
        ]
    },
    {
        "q": "State persistence uses _____ meta-reducer.",
        "type": "fill_blank",
        "answers": [
            "hydration"
        ],
        "other_options": [
            "logging",
            "error",
            "testing"
        ]
    },
    {
        "q": "Match persistence patterns:",
        "type": "match",
        "left": [
            "Save state",
            "Load state",
            "Clear state"
        ],
        "right": [
            "On action",
            "On app start",
            "On logout"
        ]
    },
    {
        "q": "What is rehydration?",
        "type": "mcq",
        "o": [
            "Restoring state from storage",
            "Clearing state",
            "Creating state",
            "No restoration"
        ]
    },
    {
        "q": "Rehydration sets initial state from storage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does rehydration meta-reducer do?",
        "type": "mcq",
        "o": [
            "Checks storage and returns saved state",
            "Clears storage",
            "Ignores storage",
            "Nothing"
        ]
    },
    {
        "q": "Rehydration happens on app _____.",
        "type": "fill_blank",
        "answers": [
            "startup"
        ],
        "other_options": [
            "shutdown",
            "navigation",
            "action"
        ]
    },
    {
        "q": "Rearrange hydration flow:",
        "type": "rearrange",
        "words": [
            "App starts",
            "Meta-reducer checks localStorage",
            "Return stored or initial state",
            "On state change save to storage",
            "On logout clear storage"
        ]
    },
    {
        "q": "What is ngrx-store-freeze?",
        "type": "mcq",
        "o": [
            "Prevents state mutations in development",
            "Freezes UI",
            "Stops effects",
            "Nothing"
        ]
    },
    {
        "q": "store-freeze is replaced by runtimeChecks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does strictStateImmutability replace?",
        "type": "mcq",
        "o": [
            "ngrx-store-freeze functionality",
            "DevTools",
            "Effects",
            "Nothing"
        ]
    },
    {
        "q": "runtimeChecks provides built-in _____ checks.",
        "type": "fill_blank",
        "answers": [
            "immutability"
        ],
        "other_options": [
            "performance",
            "logging",
            "testing"
        ]
    },
    {
        "q": "Match mutation prevention:",
        "type": "match",
        "left": [
            "Legacy: ngrx-store-freeze",
            "Modern: runtimeChecks"
        ],
        "right": [
            "Separate package",
            "Built-in"
        ]
    },
    {
        "q": "What is action creator typing?",
        "type": "mcq",
        "o": [
            "TypeScript types for action payloads",
            "No typing",
            "String types",
            "Any types"
        ]
    },
    {
        "q": "props<T>() provides type safety.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this type?",
        "type": "mcq",
        "c": "createAction('[Users] Add', props<{user: User}>())",
        "o": [
            "Action payload must have user property",
            "Any payload",
            "No payload",
            "String payload"
        ]
    },
    {
        "q": "Typed actions catch _____ at compile time.",
        "type": "fill_blank",
        "answers": [
            "errors"
        ],
        "other_options": [
            "values",
            "state",
            "effects"
        ]
    },
    {
        "q": "Match typing benefits:",
        "type": "match",
        "left": [
            "Compile-time checks",
            "IDE autocomplete",
            "Refactoring safety"
        ],
        "right": [
            "Catch errors early",
            "Better DX",
            "Safe changes"
        ]
    },
    {
        "q": "What is effect testing with marble?",
        "type": "mcq",
        "o": [
            "Testing async effects with time diagrams",
            "Manual testing",
            "No testing",
            "UI testing"
        ]
    },
    {
        "q": "Marble testing uses ASCII diagrams.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does '-a-b-c|' represent?",
        "type": "mcq",
        "o": [
            "Emissions a, b, c with time gaps",
            "Errors",
            "Nothing",
            "Sync values"
        ]
    },
    {
        "q": "Marble '-' represents one _____ of time.",
        "type": "fill_blank",
        "answers": [
            "frame"
        ],
        "other_options": [
            "value",
            "error",
            "complete"
        ]
    },
    {
        "q": "Match marble syntax:",
        "type": "match",
        "left": [
            "-",
            "a",
            "|",
            "#"
        ],
        "right": [
            "Time frame",
            "Emission",
            "Complete",
            "Error"
        ]
    },
    {
        "q": "What is hot vs cold in effects?",
        "type": "mcq",
        "o": [
            "Actions$ is hot, API call is cold",
            "All hot",
            "All cold",
            "No difference"
        ]
    },
    {
        "q": "Actions stream is a hot Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why is understanding hot/cold important for effects?",
        "type": "mcq",
        "o": [
            "Affects subscription and data flow",
            "No impact",
            "Only UI",
            "Only styling"
        ]
    },
    {
        "q": "Actions$ emits for _____ subscribers.",
        "type": "fill_blank",
        "answers": [
            "all"
        ],
        "other_options": [
            "no",
            "one",
            "some"
        ]
    },
    {
        "q": "Match Observable temperature:",
        "type": "match",
        "left": [
            "Actions$",
            "HTTP request",
            "Store.select"
        ],
        "right": [
            "Hot",
            "Cold",
            "Hot"
        ]
    },
    {
        "q": "What is action dispatch timing?",
        "type": "mcq",
        "o": [
            "When and how actions are dispatched",
            "Action content",
            "Action type",
            "Action payload"
        ]
    },
    {
        "q": "Actions should be dispatched in response to events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to dispatch actions?",
        "type": "mcq",
        "o": [
            "User interactions, lifecycle, API responses",
            "Only user clicks",
            "Only API",
            "Never"
        ]
    },
    {
        "q": "Dispatch timing affects _____ predictability.",
        "type": "fill_blank",
        "answers": [
            "state"
        ],
        "other_options": [
            "UI",
            "style",
            "template"
        ]
    },
    {
        "q": "Match dispatch triggers:",
        "type": "match",
        "left": [
            "ngOnInit",
            "Button click",
            "API response"
        ],
        "right": [
            "Load action",
            "User action",
            "Success/Failure"
        ]
    },
    {
        "q": "What is reducer immutability?",
        "type": "mcq",
        "o": [
            "Never mutate state, return new objects",
            "Mutate directly",
            "No return",
            "Any approach"
        ]
    },
    {
        "q": "Reducers must return new state objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is wrong here?",
        "type": "mcq",
        "c": "on(addUser, (state, {user}) => { state.users.push(user); return state; })",
        "o": [
            "Mutates existing array",
            "Nothing wrong",
            "Returns correctly",
            "Valid pattern"
        ]
    },
    {
        "q": "Immutable updates use _____ operator.",
        "type": "fill_blank",
        "answers": [
            "spread"
        ],
        "other_options": [
            "assign",
            "copy",
            "clone"
        ]
    },
    {
        "q": "Match immutability patterns:",
        "type": "match",
        "left": [
            "[...arr, item]",
            "{...obj, prop: value}",
            "arr.push(item)"
        ],
        "right": [
            "Immutable add",
            "Immutable update",
            "Mutation (bad)"
        ]
    },
    {
        "q": "What is effect operator choice?",
        "type": "mcq",
        "o": [
            "Choosing switchMap vs mergeMap vs concatMap vs exhaustMap",
            "Any operator",
            "No choice",
            "Always switchMap"
        ]
    },
    {
        "q": "Different flattening operators have different behaviors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use exhaustMap?",
        "type": "mcq",
        "o": [
            "Ignore new requests while one is pending",
            "Cancel previous",
            "Queue all",
            "Run parallel"
        ]
    },
    {
        "q": "switchMap cancels _____ requests.",
        "type": "fill_blank",
        "answers": [
            "previous"
        ],
        "other_options": [
            "new",
            "all",
            "no"
        ]
    },
    {
        "q": "Match operator use cases:",
        "type": "match",
        "left": [
            "Search autocomplete",
            "Save button spam prevention",
            "Parallel loading",
            "Ordered queue"
        ],
        "right": [
            "switchMap",
            "exhaustMap",
            "mergeMap",
            "concatMap"
        ]
    },
    {
        "q": "What is selector performance?",
        "type": "mcq",
        "o": [
            "Memoization prevents unnecessary recalculation",
            "Always recalculates",
            "Never calculates",
            "No performance impact"
        ]
    },
    {
        "q": "Memoized selectors improve performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does memoization do?",
        "type": "mcq",
        "o": [
            "Caches result until inputs change",
            "Always recalculates",
            "Clears cache",
            "Nothing"
        ]
    },
    {
        "q": "Selectors recalculate only when _____ change.",
        "type": "fill_blank",
        "answers": [
            "inputs"
        ],
        "other_options": [
            "outputs",
            "components",
            "templates"
        ]
    },
    {
        "q": "Match performance patterns:",
        "type": "match",
        "left": [
            "Memoized selector",
            "Inline computation",
            "Composed selectors"
        ],
        "right": [
            "Cached result",
            "Recalculates always",
            "Efficient chain"
        ]
    },
    {
        "q": "What is state shape design?",
        "type": "mcq",
        "o": [
            "Planning structure of application state",
            "Random structure",
            "No planning",
            "Copy objects"
        ]
    },
    {
        "q": "Good state design improves maintainability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What makes good state shape?",
        "type": "mcq",
        "o": [
            "Flat, normalized, minimal duplication",
            "Deep nesting",
            "Duplicated data",
            "No structure"
        ]
    },
    {
        "q": "State should be _____ not deeply nested.",
        "type": "fill_blank",
        "answers": [
            "flat"
        ],
        "other_options": [
            "deep",
            "complex",
            "random"
        ]
    },
    {
        "q": "Match state design principles:",
        "type": "match",
        "left": [
            "Flat structure",
            "Normalized data",
            "Derived data in selectors"
        ],
        "right": [
            "Easy updates",
            "No duplication",
            "Computed on demand"
        ]
    },
    {
        "q": "What is loading state pattern?",
        "type": "mcq",
        "o": [
            "Tracking isLoading, loaded, error status",
            "No tracking",
            "Only data",
            "Only errors"
        ]
    },
    {
        "q": "Loading state helps show UI feedback.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What properties track loading?",
        "type": "mcq",
        "c": "interface State { data: Item[]; loading: boolean; loaded: boolean; error: string | null; }",
        "o": [
            "loading, loaded, error",
            "Only data",
            "Only loading",
            "Nothing"
        ]
    },
    {
        "q": "Loading state enables _____ indicators.",
        "type": "fill_blank",
        "answers": [
            "spinner"
        ],
        "other_options": [
            "data",
            "error",
            "action"
        ]
    },
    {
        "q": "Match loading states:",
        "type": "match",
        "left": [
            "loading: true",
            "loaded: true",
            "error: 'message'"
        ],
        "right": [
            "In progress",
            "Completed",
            "Failed"
        ]
    },
    {
        "q": "What is error state pattern?",
        "type": "mcq",
        "o": [
            "Tracking and displaying errors in state",
            "Ignoring errors",
            "Throwing errors",
            "No pattern"
        ]
    },
    {
        "q": "Error state should be stored for display.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to store errors?",
        "type": "mcq",
        "c": "error: string | null",
        "o": [
            "Nullable error property in state",
            "Throw always",
            "Console only",
            "No storage"
        ]
    },
    {
        "q": "Error state enables showing _____ to user.",
        "type": "fill_blank",
        "answers": [
            "messages"
        ],
        "other_options": [
            "data",
            "loading",
            "nothing"
        ]
    },
    {
        "q": "Match error handling flow:",
        "type": "match",
        "left": [
            "API fails",
            "Effect catches",
            "Reducer stores",
            "UI displays"
        ],
        "right": [
            "Error thrown",
            "Dispatch failure",
            "Set error state",
            "Show message"
        ]
    },
    {
        "q": "What is NgRx Signals?",
        "type": "mcq",
        "o": [
            "Signal-based state management in NgRx",
            "Observable signals",
            "Events",
            "Callbacks"
        ]
    },
    {
        "q": "NgRx Signals uses Angular Signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does NgRx Signals provide?",
        "type": "mcq",
        "o": [
            "Signal-based store alternative",
            "Observable store only",
            "No store",
            "Events"
        ]
    },
    {
        "q": "NgRx Signals integrates with Angular _____ API.",
        "type": "fill_blank",
        "answers": [
            "Signals"
        ],
        "other_options": [
            "Observable",
            "Promise",
            "Event"
        ]
    },
    {
        "q": "Match signal approaches:",
        "type": "match",
        "left": [
            "Traditional NgRx",
            "NgRx Signals"
        ],
        "right": [
            "Observable-based",
            "Signal-based"
        ]
    },
    {
        "q": "What is action payload typing?",
        "type": "mcq",
        "o": [
            "TypeScript types for action data",
            "No types",
            "Any type",
            "String only"
        ]
    },
    {
        "q": "Typed payloads prevent runtime errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ensure?",
        "type": "mcq",
        "c": "props<{userId: number; name: string}>()",
        "o": [
            "Type-safe payload with userId and name",
            "Any payload",
            "No payload",
            "Nothing"
        ]
    },
    {
        "q": "Typed payloads catch errors at _____ time.",
        "type": "fill_blank",
        "answers": [
            "compile"
        ],
        "other_options": [
            "run",
            "deploy",
            "test"
        ]
    },
    {
        "q": "Match typing benefits:",
        "type": "match",
        "left": [
            "Early error detection",
            "Better IDE support",
            "Self-documenting"
        ],
        "right": [
            "Compile checks",
            "Autocomplete",
            "Clear structure"
        ]
    },
    {
        "q": "What is feature module architecture?",
        "type": "mcq",
        "o": [
            "Separate state per Angular feature module",
            "Single state",
            "No modules",
            "Random structure"
        ]
    },
    {
        "q": "Features should have isolated state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What enables feature isolation?",
        "type": "mcq",
        "o": [
            "StoreModule.forFeature per module",
            "forRoot only",
            "No modules",
            "Effects only"
        ]
    },
    {
        "q": "Feature modules enable _____ loading of state.",
        "type": "fill_blank",
        "answers": [
            "lazy"
        ],
        "other_options": [
            "eager",
            "sync",
            "fast"
        ]
    },
    {
        "q": "Match architecture patterns:",
        "type": "match",
        "left": [
            "Core module",
            "Feature module",
            "Shared module"
        ],
        "right": [
            "Root state",
            "Feature state",
            "No state"
        ]
    },
    {
        "q": "What is action categorization?",
        "type": "mcq",
        "o": [
            "Organizing actions by source/feature",
            "Random actions",
            "Single file",
            "No organization"
        ]
    },
    {
        "q": "Actions should be grouped by feature.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good action file structure?",
        "type": "mcq",
        "o": [
            "users.actions.ts, products.actions.ts per feature",
            "Single actions.ts",
            "No files",
            "Random"
        ]
    },
    {
        "q": "Action files should match _____ modules.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "root",
            "app",
            "core"
        ]
    },
    {
        "q": "Match file organization:",
        "type": "match",
        "left": [
            "users.actions.ts",
            "users.reducer.ts",
            "users.selectors.ts"
        ],
        "right": [
            "User actions",
            "User reducer",
            "User selectors"
        ]
    },
    {
        "q": "What is barrel export?",
        "type": "mcq",
        "o": [
            "Index file re-exporting module contents",
            "Single export",
            "No export",
            "Random exports"
        ]
    },
    {
        "q": "Barrel exports simplify imports.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does index.ts barrel do?",
        "type": "mcq",
        "c": "export * from './users.actions'; export * from './users.reducer'; export * from './users.selectors';",
        "o": [
            "Re-exports all user state files",
            "Exports nothing",
            "Creates actions",
            "Creates reducer"
        ]
    },
    {
        "q": "Barrel exports enable _____ imports.",
        "type": "fill_blank",
        "answers": [
            "cleaner"
        ],
        "other_options": [
            "longer",
            "complex",
            "no"
        ]
    },
    {
        "q": "Match import patterns:",
        "type": "match",
        "left": [
            "import { x } from './store'",
            "import { x } from './store/users.actions'"
        ],
        "right": [
            "Barrel import",
            "Direct import"
        ]
    },
    {
        "q": "What is selector file organization?",
        "type": "mcq",
        "o": [
            "Grouping selectors by feature",
            "Single file",
            "No files",
            "Random"
        ]
    },
    {
        "q": "Selectors should be in dedicated files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good selector organization?",
        "type": "mcq",
        "o": [
            "users.selectors.ts with all user selectors",
            "In reducer file",
            "In component",
            "No organization"
        ]
    },
    {
        "q": "Selector files make selectors _____.",
        "type": "fill_blank",
        "answers": [
            "reusable"
        ],
        "other_options": [
            "hidden",
            "private",
            "deleted"
        ]
    },
    {
        "q": "Match selector patterns:",
        "type": "match",
        "left": [
            "Feature selector",
            "Property selectors",
            "Computed selectors"
        ],
        "right": [
            "Top-level",
            "Simple access",
            "Derived data"
        ]
    },
    {
        "q": "What is effect file organization?",
        "type": "mcq",
        "o": [
            "Grouping effects by feature",
            "Single file",
            "No files",
            "Random"
        ]
    },
    {
        "q": "Effects should be in dedicated files per feature.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good effect organization?",
        "type": "mcq",
        "o": [
            "users.effects.ts with all user effects",
            "In reducer",
            "In component",
            "No organization"
        ]
    },
    {
        "q": "Effect files contain related _____ effects.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "random",
            "no",
            "all"
        ]
    },
    {
        "q": "Match effect patterns:",
        "type": "match",
        "left": [
            "Load effect",
            "Save effect",
            "Navigation effect"
        ],
        "right": [
            "Fetch data",
            "Persist data",
            "Route change"
        ]
    },
    {
        "q": "What is testing reducer?",
        "type": "mcq",
        "o": [
            "Unit testing reducer pure functions",
            "Integration testing",
            "E2E testing",
            "No testing"
        ]
    },
    {
        "q": "Reducers are easy to test as pure functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test reducer?",
        "type": "mcq",
        "c": "const result = reducer(initialState, action); expect(result).toEqual(expectedState);",
        "o": [
            "Call reducer and assert result",
            "Mock everything",
            "No assertion",
            "Skip testing"
        ]
    },
    {
        "q": "Reducer tests verify state _____ logic.",
        "type": "fill_blank",
        "answers": [
            "transition"
        ],
        "other_options": [
            "loading",
            "display",
            "routing"
        ]
    },
    {
        "q": "Match testing patterns:",
        "type": "match",
        "left": [
            "Reducer test",
            "Selector test",
            "Effect test"
        ],
        "right": [
            "Pure function",
            "Memoization",
            "Async/marble"
        ]
    },
    {
        "q": "What is testing selector?",
        "type": "mcq",
        "o": [
            "Unit testing selector functions",
            "Integration",
            "E2E",
            "No testing"
        ]
    },
    {
        "q": "Selectors can be tested with projector.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to test selector?",
        "type": "mcq",
        "c": "expect(selectTotal.projector(users)).toEqual(5);",
        "o": [
            "Use projector with mock state",
            "Full store",
            "No testing",
            "Skip"
        ]
    },
    {
        "q": "Selector projector tests the _____ function.",
        "type": "fill_blank",
        "answers": [
            "projection"
        ],
        "other_options": [
            "memoization",
            "selection",
            "store"
        ]
    },
    {
        "q": "Match selector testing:",
        "type": "match",
        "left": [
            "projector method",
            "Full state test"
        ],
        "right": [
            "Unit test last function",
            "Integration test"
        ]
    },
    {
        "q": "What is testing effect mocking?",
        "type": "mcq",
        "o": [
            "Mocking services and actions for effect tests",
            "No mocking",
            "Real services",
            "Skip testing"
        ]
    },
    {
        "q": "Effects need mocked services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should be mocked?",
        "type": "mcq",
        "o": [
            "HTTP service, Actions$, Store",
            "Nothing",
            "Only HTTP",
            "Only Store"
        ]
    },
    {
        "q": "Mocking isolates effect from _____.",
        "type": "fill_blank",
        "answers": [
            "dependencies"
        ],
        "other_options": [
            "state",
            "actions",
            "reducers"
        ]
    },
    {
        "q": "Match mocking patterns:",
        "type": "match",
        "left": [
            "provideMockActions",
            "Mock HTTP",
            "provideMockStore"
        ],
        "right": [
            "Fake actions stream",
            "Fake API response",
            "Fake store"
        ]
    },
    {
        "q": "What is NgRx vs simple services?",
        "type": "mcq",
        "o": [
            "NgRx for complex state, services for simple",
            "Always NgRx",
            "Never NgRx",
            "No difference"
        ]
    },
    {
        "q": "NgRx adds complexity for benefits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use NgRx?",
        "type": "mcq",
        "o": [
            "Complex shared state, debugging needs",
            "Always",
            "Never",
            "Small apps"
        ]
    },
    {
        "q": "NgRx is overkill for _____ applications.",
        "type": "fill_blank",
        "answers": [
            "simple"
        ],
        "other_options": [
            "complex",
            "large",
            "enterprise"
        ]
    },
    {
        "q": "Match state solutions:",
        "type": "match",
        "left": [
            "Simple state",
            "Shared state",
            "Complex state"
        ],
        "right": [
            "Service",
            "BehaviorSubject",
            "NgRx"
        ]
    },
    {
        "q": "What is NgRx migration?",
        "type": "mcq",
        "o": [
            "Gradually adopting NgRx in existing app",
            "Full rewrite",
            "No migration",
            "Start fresh"
        ]
    },
    {
        "q": "Migration can be done incrementally.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to start migration?",
        "type": "mcq",
        "o": [
            "One feature at a time",
            "All at once",
            "Never start",
            "Full rewrite"
        ]
    },
    {
        "q": "Incremental migration reduces _____ risk.",
        "type": "fill_blank",
        "answers": [
            "project"
        ],
        "other_options": [
            "code",
            "file",
            "style"
        ]
    },
    {
        "q": "Rearrange migration steps:",
        "type": "rearrange",
        "words": [
            "Install NgRx packages",
            "Set up root store",
            "Migrate one feature",
            "Test thoroughly",
            "Repeat for other features"
        ]
    },
    {
        "q": "What is NgRx performance optimization?",
        "type": "mcq",
        "o": [
            "Improving NgRx app speed and efficiency",
            "No optimization",
            "Always slow",
            "Ignore performance"
        ]
    },
    {
        "q": "Memoized selectors improve performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What optimizations help?",
        "type": "mcq",
        "o": [
            "Memoization, lazy loading, OnPush",
            "None",
            "Default detection",
            "Eager loading"
        ]
    },
    {
        "q": "OnPush change detection works well with _____.",
        "type": "fill_blank",
        "answers": [
            "NgRx"
        ],
        "other_options": [
            "services",
            "forms",
            "routing"
        ]
    },
    {
        "q": "Match optimization patterns:",
        "type": "match",
        "left": [
            "OnPush + async pipe",
            "Memoized selectors",
            "Lazy state"
        ],
        "right": [
            "Efficient rendering",
            "Cached computations",
            "Reduced bundle"
        ]
    },
    {
        "q": "What is debugging NgRx?",
        "type": "mcq",
        "o": [
            "Using DevTools and logging to find issues",
            "Console only",
            "No debugging",
            "Print statements"
        ]
    },
    {
        "q": "Redux DevTools is primary debugging tool.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can DevTools show?",
        "type": "mcq",
        "o": [
            "Action history, state diff, time-travel",
            "Only actions",
            "Only state",
            "Nothing"
        ]
    },
    {
        "q": "DevTools enable _____ debugging.",
        "type": "fill_blank",
        "answers": [
            "time-travel"
        ],
        "other_options": [
            "console",
            "print",
            "step"
        ]
    },
    {
        "q": "Match debugging techniques:",
        "type": "match",
        "left": [
            "DevTools inspection",
            "Logger meta-reducer",
            "tap() in effects"
        ],
        "right": [
            "Visual debugging",
            "Console logging",
            "Effect debugging"
        ]
    },
    {
        "q": "What is state serialization?",
        "type": "mcq",
        "o": [
            "Converting state to JSON-compatible format",
            "No conversion",
            "Binary format",
            "Random format"
        ]
    },
    {
        "q": "Serializable state works with DevTools.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should state avoid?",
        "type": "mcq",
        "o": [
            "Functions, class instances, Dates",
            "Strings",
            "Numbers",
            "Arrays"
        ]
    },
    {
        "q": "Serialization ensures state is _____.",
        "type": "fill_blank",
        "answers": [
            "JSON-compatible"
        ],
        "other_options": [
            "complex",
            "typed",
            "validated"
        ]
    },
    {
        "q": "Match serialization rules:",
        "type": "match",
        "left": [
            "Plain objects",
            "ISO date strings",
            "Primitives"
        ],
        "right": [
            "Allowed",
            "For dates",
            "Allowed"
        ]
    },
    {
        "q": "What is action creator vs action type?",
        "type": "mcq",
        "o": [
            "Creator is function, type is string identifier",
            "Same thing",
            "Type is function",
            "No difference"
        ]
    },
    {
        "q": "createAction returns action creator function.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is action type?",
        "type": "mcq",
        "c": "[Users] Load",
        "o": [
            "String identifying the action",
            "Function",
            "Object",
            "Nothing"
        ]
    },
    {
        "q": "Action type is used for _____ in reducers.",
        "type": "fill_blank",
        "answers": [
            "matching"
        ],
        "other_options": [
            "payload",
            "creating",
            "dispatching"
        ]
    },
    {
        "q": "Match action concepts:",
        "type": "match",
        "left": [
            "loadUsers()",
            "'[Users] Load'",
            "{type, payload}"
        ],
        "right": [
            "Creator call",
            "Type string",
            "Action object"
        ]
    },
    {
        "q": "What is standalone NgRx?",
        "type": "mcq",
        "o": [
            "Using NgRx with standalone components",
            "Module-based only",
            "No standalone",
            "Deprecated"
        ]
    },
    {
        "q": "NgRx works with standalone components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to use NgRx with standalone?",
        "type": "mcq",
        "o": [
            "provideStore, provideEffects in app config",
            "Only modules",
            "Not possible",
            "Deprecated"
        ]
    },
    {
        "q": "provideStore replaces _____ for standalone.",
        "type": "fill_blank",
        "answers": [
            "StoreModule"
        ],
        "other_options": [
            "EffectsModule",
            "Actions",
            "Store"
        ]
    },
    {
        "q": "Match standalone providers:",
        "type": "match",
        "left": [
            "provideStore",
            "provideEffects",
            "provideStoreDevtools"
        ],
        "right": [
            "Store setup",
            "Effects setup",
            "DevTools setup"
        ]
    },
    {
        "q": "What is provideStore()?",
        "type": "mcq",
        "o": [
            "Standalone function to configure store",
            "Creates action",
            "Creates reducer",
            "Module method"
        ]
    },
    {
        "q": "provideStore is for standalone applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "provideStore({router: routerReducer})",
        "o": [
            "Root store with router state",
            "Feature only",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "provideStore goes in app _____ providers.",
        "type": "fill_blank",
        "answers": [
            "config"
        ],
        "other_options": [
            "module",
            "component",
            "service"
        ]
    },
    {
        "q": "Match provider functions:",
        "type": "match",
        "left": [
            "provideStore",
            "provideState",
            "provideEffects"
        ],
        "right": [
            "Root store",
            "Feature state",
            "Effects registration"
        ]
    },
    {
        "q": "What is provideState()?",
        "type": "mcq",
        "o": [
            "Standalone function for feature state",
            "Root state",
            "Actions",
            "Effects"
        ]
    },
    {
        "q": "provideState replaces StoreModule.forFeature.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this register?",
        "type": "mcq",
        "c": "provideState('users', userReducer)",
        "o": [
            "Users feature state",
            "Root state",
            "Effects",
            "Actions"
        ]
    },
    {
        "q": "provideState is used in feature _____.",
        "type": "fill_blank",
        "answers": [
            "routes"
        ],
        "other_options": [
            "modules",
            "components",
            "services"
        ]
    },
    {
        "q": "Match standalone registration:",
        "type": "match",
        "left": [
            "App providers",
            "Route providers"
        ],
        "right": [
            "provideStore",
            "provideState"
        ]
    },
    {
        "q": "What is provideEffects()?",
        "type": "mcq",
        "o": [
            "Standalone function to register effects",
            "Creates effect",
            "Creates action",
            "Module method"
        ]
    },
    {
        "q": "provideEffects replaces EffectsModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this register?",
        "type": "mcq",
        "c": "provideEffects(UserEffects, ProductEffects)",
        "o": [
            "Multiple effect classes",
            "Single effect",
            "Store only",
            "Actions"
        ]
    },
    {
        "q": "provideEffects registers effect _____ classes.",
        "type": "fill_blank",
        "answers": [
            "injectable"
        ],
        "other_options": [
            "action",
            "reducer",
            "selector"
        ]
    },
    {
        "q": "Match effects registration:",
        "type": "match",
        "left": [
            "EffectsModule.forRoot",
            "provideEffects"
        ],
        "right": [
            "Module-based",
            "Standalone"
        ]
    },
    {
        "q": "What is NGRX_FEATURE_SELECTORS?",
        "type": "mcq",
        "o": [
            "Token for injecting feature selectors",
            "Action token",
            "Reducer token",
            "Store token"
        ]
    },
    {
        "q": "Tokens enable dependency injection of NgRx artifacts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use injection tokens?",
        "type": "mcq",
        "o": [
            "Advanced DI scenarios",
            "Always",
            "Never",
            "Simple cases"
        ]
    },
    {
        "q": "Injection tokens provide _____ configuration.",
        "type": "fill_blank",
        "answers": [
            "flexible"
        ],
        "other_options": [
            "fixed",
            "simple",
            "basic"
        ]
    },
    {
        "q": "Match tokens:",
        "type": "match",
        "left": [
            "FEATURE_STATE_PROVIDER",
            "INITIAL_STATE_TOKEN"
        ],
        "right": [
            "Feature registration",
            "Initial state"
        ]
    },
    {
        "q": "What is action union type?",
        "type": "mcq",
        "o": [
            "TypeScript union of all action types",
            "Single action",
            "No types",
            "Any type"
        ]
    },
    {
        "q": "Action union helps with type narrowing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this define?",
        "type": "mcq",
        "c": "type UserActions = ReturnType<typeof loadUsers | typeof loadUsersSuccess>;",
        "o": [
            "Union type of user actions",
            "Single action",
            "Reducer",
            "Selector"
        ]
    },
    {
        "q": "Union types enable _____ exhaustiveness checks.",
        "type": "fill_blank",
        "answers": [
            "TypeScript"
        ],
        "other_options": [
            "runtime",
            "manual",
            "no"
        ]
    },
    {
        "q": "Match typing patterns:",
        "type": "match",
        "left": [
            "Action union",
            "ReturnType",
            "typeof action"
        ],
        "right": [
            "All actions",
            "Infer type",
            "Action type"
        ]
    },
    {
        "q": "What is selector projector?",
        "type": "mcq",
        "o": [
            "Last function in composed selector",
            "First function",
            "No function",
            "Reducer"
        ]
    },
    {
        "q": "Projector is the transformation function.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the projector here?",
        "type": "mcq",
        "c": "createSelector(selectUsers, selectFilter, (users, filter) => users.filter(...))",
        "o": [
            "The arrow function filtering users",
            "selectUsers",
            "selectFilter",
            "createSelector"
        ]
    },
    {
        "q": "Projector receives _____ selector outputs.",
        "type": "fill_blank",
        "answers": [
            "input"
        ],
        "other_options": [
            "output",
            "no",
            "some"
        ]
    },
    {
        "q": "Match selector parts:",
        "type": "match",
        "left": [
            "Input selectors",
            "Projector function"
        ],
        "right": [
            "Dependencies",
            "Transformation"
        ]
    },
    {
        "q": "What is reducer composition?",
        "type": "mcq",
        "o": [
            "Combining multiple reducers",
            "Single reducer",
            "No reducers",
            "Actions"
        ]
    },
    {
        "q": "combineReducers composes reducers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use combineReducers?",
        "type": "mcq",
        "o": [
            "Complex nested state",
            "Simple state",
            "Never",
            "Always"
        ]
    },
    {
        "q": "combineReducers creates _____ reducer from multiple.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "multiple",
            "no",
            "partial"
        ]
    },
    {
        "q": "Match composition patterns:",
        "type": "match",
        "left": [
            "combineReducers",
            "Single reducer"
        ],
        "right": [
            "Complex state",
            "Simple state"
        ]
    },
    {
        "q": "What is action.type property?",
        "type": "mcq",
        "o": [
            "String identifier for the action",
            "Payload",
            "Function",
            "State"
        ]
    },
    {
        "q": "Every action has a type property.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is action.type used for?",
        "type": "mcq",
        "o": [
            "Matching in reducers and effects",
            "Nothing",
            "Payload",
            "State"
        ]
    },
    {
        "q": "ofType filters by action _____ property.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "payload",
            "name",
            "id"
        ]
    },
    {
        "q": "Match action properties:",
        "type": "match",
        "left": [
            "type",
            "payload properties"
        ],
        "right": [
            "Identifier",
            "Data"
        ]
    },
    {
        "q": "What is multiple store subscriptions?",
        "type": "mcq",
        "o": [
            "Multiple select() calls in component",
            "Single subscription",
            "No subscriptions",
            "Action calls"
        ]
    },
    {
        "q": "Multiple subscriptions should be combined when possible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to combine subscriptions?",
        "type": "mcq",
        "o": [
            "Create selector combining data",
            "Keep separate",
            "Remove",
            "Ignore"
        ]
    },
    {
        "q": "Combined selectors reduce _____ count.",
        "type": "fill_blank",
        "answers": [
            "subscription"
        ],
        "other_options": [
            "action",
            "effect",
            "reducer"
        ]
    },
    {
        "q": "Match subscription patterns:",
        "type": "match",
        "left": [
            "Multiple separate",
            "Single combined"
        ],
        "right": [
            "More subscriptions",
            "Fewer subscriptions"
        ]
    },
    {
        "q": "What is selector negation?",
        "type": "mcq",
        "o": [
            "Selector returning opposite boolean",
            "Positive selector",
            "No selector",
            "Action"
        ]
    },
    {
        "q": "Negation selectors invert boolean values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "selectNotLoading = createSelector(selectLoading, loading => !loading)",
        "o": [
            "Selector for not-loading state",
            "Loading selector",
            "Error selector",
            "Nothing"
        ]
    },
    {
        "q": "Negation uses _____ operator.",
        "type": "fill_blank",
        "answers": [
            "logical NOT"
        ],
        "other_options": [
            "AND",
            "OR",
            "XOR"
        ]
    },
    {
        "q": "Match boolean selectors:",
        "type": "match",
        "left": [
            "selectLoading",
            "selectNotLoading",
            "selectHasError"
        ],
        "right": [
            "Is loading",
            "Not loading",
            "Has error"
        ]
    },
    {
        "q": "What is derived state?",
        "type": "mcq",
        "o": [
            "State computed from other state via selectors",
            "Stored state",
            "Action state",
            "Effect state"
        ]
    },
    {
        "q": "Derived state should not be stored.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why compute derived state in selectors?",
        "type": "mcq",
        "o": [
            "Single source of truth, memoization",
            "Store everything",
            "No computation",
            "Better performance"
        ]
    },
    {
        "q": "Derived state avoids _____ issues.",
        "type": "fill_blank",
        "answers": [
            "synchronization"
        ],
        "other_options": [
            "speed",
            "size",
            "type"
        ]
    },
    {
        "q": "Match state types:",
        "type": "match",
        "left": [
            "Stored state",
            "Derived state"
        ],
        "right": [
            "In reducer",
            "In selector"
        ]
    },
    {
        "q": "What is entity sorting?",
        "type": "mcq",
        "o": [
            "Ordering entities by sortComparer",
            "Random order",
            "No order",
            "ID order only"
        ]
    },
    {
        "q": "EntityAdapter can sort entities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does sortComparer do?",
        "type": "mcq",
        "c": "createEntityAdapter({sortComparer: (a, b) => a.name.localeCompare(b.name)})",
        "o": [
            "Sorts entities by name",
            "No sorting",
            "Random order",
            "ID order"
        ]
    },
    {
        "q": "sortComparer returns number for _____.",
        "type": "fill_blank",
        "answers": [
            "comparison"
        ],
        "other_options": [
            "sorting",
            "filtering",
            "mapping"
        ]
    },
    {
        "q": "Match adapter options:",
        "type": "match",
        "left": [
            "selectId",
            "sortComparer"
        ],
        "right": [
            "ID extraction",
            "Ordering"
        ]
    },
    {
        "q": "What is entity selectId?",
        "type": "mcq",
        "o": [
            "Function to extract entity ID",
            "Entity data",
            "Sorting",
            "State"
        ]
    },
    {
        "q": "selectId customizes ID extraction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use custom selectId?",
        "type": "mcq",
        "o": [
            "Entity ID is not named 'id'",
            "Always",
            "Never",
            "Default only"
        ]
    },
    {
        "q": "Default selectId extracts _____ property.",
        "type": "fill_blank",
        "answers": [
            "id"
        ],
        "other_options": [
            "name",
            "key",
            "type"
        ]
    },
    {
        "q": "Match ID patterns:",
        "type": "match",
        "left": [
            "entity.id",
            "entity.uuid",
            "entity.key"
        ],
        "right": [
            "Default",
            "Custom selectId",
            "Custom selectId"
        ]
    },
    {
        "q": "What is action source naming?",
        "type": "mcq",
        "o": [
            "Naming convention for action[Source] prefix",
            "No naming",
            "Random names",
            "Numbers"
        ]
    },
    {
        "q": "Source prefix identifies action origin.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is good source naming?",
        "type": "mcq",
        "c": "[Auth API] Login Success",
        "o": [
            "Source in brackets describes origin",
            "No brackets",
            "Random text",
            "Numbers"
        ]
    },
    {
        "q": "Source naming helps _____ in DevTools.",
        "type": "fill_blank",
        "answers": [
            "debugging"
        ],
        "other_options": [
            "coding",
            "testing",
            "deploying"
        ]
    },
    {
        "q": "Match source patterns:",
        "type": "match",
        "left": [
            "[Login Page]",
            "[Auth API]",
            "[Auth Guard]"
        ],
        "right": [
            "UI component",
            "API response",
            "Router guard"
        ]
    },
    {
        "q": "What is effect cancellation?",
        "type": "mcq",
        "o": [
            "Canceling pending effect with takeUntil",
            "No cancellation",
            "Always complete",
            "Error only"
        ]
    },
    {
        "q": "Effects can be canceled on action.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to cancel effect?",
        "type": "mcq",
        "c": "takeUntil(this.actions$.pipe(ofType(cancelAction)))",
        "o": [
            "Cancel on specific action",
            "Never cancel",
            "Always cancel",
            "Auto cancel"
        ]
    },
    {
        "q": "takeUntil cancels when _____ emits.",
        "type": "fill_blank",
        "answers": [
            "notifier"
        ],
        "other_options": [
            "source",
            "action",
            "effect"
        ]
    },
    {
        "q": "Match cancellation patterns:",
        "type": "match",
        "left": [
            "takeUntil",
            "switchMap",
            "exhaustMap"
        ],
        "right": [
            "Explicit cancel",
            "Auto cancel previous",
            "Ignore new"
        ]
    },
    {
        "q": "What is effect debouncing?",
        "type": "mcq",
        "o": [
            "Delaying effect execution with debounceTime",
            "Immediate execution",
            "No delay",
            "Throttling"
        ]
    },
    {
        "q": "debounceTime waits for pause in emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to use debounceTime in effects?",
        "type": "mcq",
        "o": [
            "Search autocomplete, rapid input",
            "All effects",
            "Never",
            "Only API"
        ]
    },
    {
        "q": "debounceTime reduces _____ API calls.",
        "type": "fill_blank",
        "answers": [
            "unnecessary"
        ],
        "other_options": [
            "necessary",
            "all",
            "no"
        ]
    },
    {
        "q": "Match timing operators:",
        "type": "match",
        "left": [
            "debounceTime",
            "throttleTime",
            "delay"
        ],
        "right": [
            "Wait for pause",
            "Rate limit",
            "Fixed delay"
        ]
    },
    {
        "q": "What is effect retry?",
        "type": "mcq",
        "o": [
            "Retrying failed effect with retry operator",
            "No retry",
            "Always fail",
            "Manual retry"
        ]
    },
    {
        "q": "Effects can retry failed API calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to implement retry?",
        "type": "mcq",
        "c": "pipe(retry(3))",
        "o": [
            "Retry up to 3 times",
            "Retry once",
            "Never retry",
            "Infinite retry"
        ]
    },
    {
        "q": "Retry improves _____ resilience.",
        "type": "fill_blank",
        "answers": [
            "network"
        ],
        "other_options": [
            "code",
            "state",
            "UI"
        ]
    },
    {
        "q": "Match retry patterns:",
        "type": "match",
        "left": [
            "retry(n)",
            "retryWhen",
            "No retry"
        ],
        "right": [
            "Fixed count",
            "Custom logic",
            "Fail immediately"
        ]
    },
    {
        "q": "What is effect logging?",
        "type": "mcq",
        "o": [
            "Using tap to log effect activity",
            "No logging",
            "Console only",
            "DevTools only"
        ]
    },
    {
        "q": "tap operator helps debug effects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "pipe(tap(action => console.log('Action:', action)))",
        "o": [
            "Logs action without affecting stream",
            "Transforms action",
            "Stops execution",
            "Nothing"
        ]
    },
    {
        "q": "tap performs _____ without modifying stream.",
        "type": "fill_blank",
        "answers": [
            "side effects"
        ],
        "other_options": [
            "transformations",
            "filtering",
            "errors"
        ]
    },
    {
        "q": "Match debugging operators:",
        "type": "match",
        "left": [
            "tap for logging",
            "DevTools",
            "Meta-reducer logger"
        ],
        "right": [
            "Effect level",
            "Visual debugging",
            "Action level"
        ]
    },
    {
        "q": "What is effect dispatching multiple actions?",
        "type": "mcq",
        "o": [
            "Effect returning multiple actions from one trigger",
            "Single action only",
            "No actions",
            "Reducer"
        ]
    },
    {
        "q": "Effects can dispatch multiple actions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to dispatch multiple?",
        "type": "mcq",
        "c": "mergeMap(() => [action1(), action2()])",
        "o": [
            "Return array of actions",
            "Return single",
            "No return",
            "Return void"
        ]
    },
    {
        "q": "Multiple actions from effect use _____ return.",
        "type": "fill_blank",
        "answers": [
            "array"
        ],
        "other_options": [
            "object",
            "single",
            "void"
        ]
    },
    {
        "q": "Match action return patterns:",
        "type": "match",
        "left": [
            "map(() => action())",
            "mergeMap(() => [a1(), a2()])"
        ],
        "right": [
            "Single action",
            "Multiple actions"
        ]
    },
    {
        "q": "What is conditional action dispatch?",
        "type": "mcq",
        "o": [
            "Dispatching different actions based on conditions",
            "Always same action",
            "No actions",
            "Random"
        ]
    },
    {
        "q": "Effects can conditionally dispatch actions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to implement conditional dispatch?",
        "type": "mcq",
        "c": "map(data => data.success ? successAction() : failureAction())",
        "o": [
            "Use conditional expression",
            "Always success",
            "Always failure",
            "No action"
        ]
    },
    {
        "q": "Conditional dispatch uses _____ operators.",
        "type": "fill_blank",
        "answers": [
            "ternary"
        ],
        "other_options": [
            "binary",
            "unary",
            "no"
        ]
    },
    {
        "q": "Match conditional patterns:",
        "type": "match",
        "left": [
            "condition ? a : b",
            "iif(() => cond, a$, b$)"
        ],
        "right": [
            "Ternary in map",
            "RxJS conditional"
        ]
    },
    {
        "q": "What is EMPTY in effects?",
        "type": "mcq",
        "o": [
            "Observable completing without emission",
            "Error",
            "Value",
            "Action"
        ]
    },
    {
        "q": "EMPTY is used for non-dispatching branches.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When to return EMPTY?",
        "type": "mcq",
        "o": [
            "Effect branch should not dispatch",
            "Always",
            "Never",
            "Error only"
        ]
    },
    {
        "q": "EMPTY completes _____ emitting.",
        "type": "fill_blank",
        "answers": [
            "without"
        ],
        "other_options": [
            "after",
            "before",
            "while"
        ]
    },
    {
        "q": "Match EMPTY patterns:",
        "type": "match",
        "left": [
            "EMPTY",
            "of(action)"
        ],
        "right": [
            "No emission",
            "One emission"
        ]
    },
    {
        "q": "What is effect filtering?",
        "type": "mcq",
        "o": [
            "Using filter to skip certain conditions",
            "Process all",
            "No filtering",
            "Reduce only"
        ]
    },
    {
        "q": "filter operator skips non-matching values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this filter?",
        "type": "mcq",
        "c": "filter(action => action.payload.type === 'admin')",
        "o": [
            "Only admin type actions",
            "All actions",
            "No actions",
            "User actions"
        ]
    },
    {
        "q": "filter passes values matching _____ function.",
        "type": "fill_blank",
        "answers": [
            "predicate"
        ],
        "other_options": [
            "projection",
            "selector",
            "reducer"
        ]
    },
    {
        "q": "Match filtering patterns:",
        "type": "match",
        "left": [
            "ofType",
            "filter"
        ],
        "right": [
            "Action type",
            "Custom condition"
        ]
    },
    {
        "q": "What is store select performance?",
        "type": "mcq",
        "o": [
            "Optimizing select calls with memoization",
            "No optimization",
            "Always slow",
            "Always fast"
        ]
    },
    {
        "q": "Memoized selectors prevent unnecessary emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How to optimize select?",
        "type": "mcq",
        "o": [
            "Use memoized selectors instead of inline",
            "Inline always",
            "No selectors",
            "Select all"
        ]
    },
    {
        "q": "Inline select creates _____ subscriptions.",
        "type": "fill_blank",
        "answers": [
            "new"
        ],
        "other_options": [
            "cached",
            "no",
            "single"
        ]
    },
    {
        "q": "Match select patterns:",
        "type": "match",
        "left": [
            "select(memoizedSelector)",
            "select(state => state.x)"
        ],
        "right": [
            "Optimized",
            "Not memoized"
        ]
    },
    {
        "q": "What is async pipe with NgRx?",
        "type": "mcq",
        "o": [
            "Template subscription to store Observable",
            "Component subscription",
            "Manual subscribe",
            "No subscription"
        ]
    },
    {
        "q": "async pipe handles subscription automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why use async pipe?",
        "type": "mcq",
        "c": "{{ users$ | async }}",
        "o": [
            "Auto unsubscribe on destroy",
            "Manual unsubscribe",
            "No benefit",
            "Performance"
        ]
    },
    {
        "q": "async pipe subscribes and _____ automatically.",
        "type": "fill_blank",
        "answers": [
            "unsubscribes"
        ],
        "other_options": [
            "subscribes",
            "transforms",
            "filters"
        ]
    },
    {
        "q": "Match subscription patterns:",
        "type": "match",
        "left": [
            "async pipe",
            "Manual subscribe"
        ],
        "right": [
            "Auto cleanup",
            "Manual cleanup"
        ]
    },
    {
        "q": "What is OnPush strategy with NgRx?",
        "type": "mcq",
        "o": [
            "Change detection only on explicit changes",
            "Always detect",
            "Never detect",
            "Default strategy"
        ]
    },
    {
        "q": "OnPush works well with store Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why OnPush with NgRx?",
        "type": "mcq",
        "o": [
            "Better performance with immutable state",
            "No benefit",
            "Worse performance",
            "Complex setup"
        ]
    },
    {
        "q": "OnPush detects changes from _____ emissions.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "value",
            "variable",
            "manual"
        ]
    },
    {
        "q": "Match change detection:",
        "type": "match",
        "left": [
            "OnPush",
            "Default"
        ],
        "right": [
            "Explicit triggers",
            "Always check"
        ]
    },
    {
        "q": "What is store.pipe()?",
        "type": "mcq",
        "o": [
            "RxJS pipe operators on store",
            "Creates pipe",
            "Deletes pipe",
            "Nothing"
        ]
    },
    {
        "q": "Store is an Observable supporting pipe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can you chain after select?",
        "type": "mcq",
        "c": "store.select(selector).pipe(filter(x => x.length > 0))",
        "o": [
            "RxJS operators like filter",
            "Nothing",
            "Actions",
            "Reducers"
        ]
    },
    {
        "q": "pipe() enables RxJS _____ on selections.",
        "type": "fill_blank",
        "answers": [
            "operators"
        ],
        "other_options": [
            "actions",
            "effects",
            "reducers"
        ]
    },
    {
        "q": "Match store methods:",
        "type": "match",
        "left": [
            "select()",
            "dispatch()",
            "pipe()"
        ],
        "right": [
            "Read state",
            "Send action",
            "Chain operators"
        ]
    }
]