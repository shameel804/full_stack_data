[
    {
        "q": "What are the two main approaches to forms in Angular?",
        "type": "mcq",
        "o": [
            "Template-driven and Reactive forms",
            "Simple and Complex forms",
            "Static and Dynamic forms",
            "Basic and Advanced forms"
        ]
    },
    {
        "q": "Template-driven forms use FormsModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this directive enable?",
        "type": "mcq",
        "c": "<input [(ngModel)]=\"name\">",
        "o": [
            "Two-way data binding for form control",
            "One-way binding",
            "Event binding",
            "Property binding"
        ]
    },
    {
        "q": "The _____ directive enables two-way binding in template-driven forms.",
        "type": "fill_blank",
        "answers": [
            "ngModel"
        ],
        "other_options": [
            "formControl",
            "ngBind",
            "model"
        ]
    },
    {
        "q": "Match form approaches:",
        "type": "match",
        "left": [
            "Template-driven",
            "Reactive"
        ],
        "right": [
            "Directives in template",
            "Code in component class"
        ]
    },
    {
        "q": "What module is required for reactive forms?",
        "type": "mcq",
        "o": [
            "ReactiveFormsModule",
            "FormsModule",
            "FormModule",
            "ReactiveModule"
        ]
    },
    {
        "q": "Reactive forms are more testable than template-driven.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "form = new FormGroup({ name: new FormControl('') });",
        "o": [
            "A reactive form with name control",
            "Template form",
            "Form directive",
            "Form binding"
        ]
    },
    {
        "q": "The _____ class represents a single form input.",
        "type": "fill_blank",
        "answers": [
            "FormControl"
        ],
        "other_options": [
            "FormGroup",
            "FormArray",
            "FormInput"
        ]
    },
    {
        "q": "Match form classes:",
        "type": "match",
        "left": [
            "FormControl",
            "FormGroup",
            "FormArray",
            "FormBuilder"
        ],
        "right": [
            "Single input",
            "Group of controls",
            "Array of controls",
            "Helper to create forms"
        ]
    },
    {
        "q": "What is FormGroup?",
        "type": "mcq",
        "o": [
            "A collection of form controls",
            "Single control",
            "Form array",
            "Form builder"
        ]
    },
    {
        "q": "FormGroup tracks validity of all child controls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this bind?",
        "type": "mcq",
        "c": "<form [formGroup]=\"myForm\">",
        "o": [
            "Reactive form to template",
            "Template form",
            "Form control",
            "Form array"
        ]
    },
    {
        "q": "The _____ directive binds FormGroup to template.",
        "type": "fill_blank",
        "answers": [
            "[formGroup]"
        ],
        "other_options": [
            "[ngForm]",
            "[form]",
            "[reactiveForm]"
        ]
    },
    {
        "q": "Rearrange reactive form setup:",
        "type": "rearrange",
        "words": [
            "Import ReactiveFormsModule",
            "Create FormGroup in component",
            "Bind with [formGroup]",
            "Add formControlName to inputs",
            "Handle submit"
        ]
    },
    {
        "q": "What is FormBuilder?",
        "type": "mcq",
        "o": [
            "Helper service to create forms with less code",
            "Form validator",
            "Form submitter",
            "Form renderer"
        ]
    },
    {
        "q": "FormBuilder reduces boilerplate code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "form = this.fb.group({ name: ['', Validators.required], email: [''] });",
        "o": [
            "FormGroup with name (required) and email controls",
            "Single control",
            "Form array",
            "Template form"
        ]
    },
    {
        "q": "The _____ method creates FormGroup using FormBuilder.",
        "type": "fill_blank",
        "answers": [
            "group"
        ],
        "other_options": [
            "create",
            "build",
            "form"
        ]
    },
    {
        "q": "Match FormBuilder methods:",
        "type": "match",
        "left": [
            "group",
            "control",
            "array",
            "nonNullable"
        ],
        "right": [
            "Creates FormGroup",
            "Creates FormControl",
            "Creates FormArray",
            "Non-nullable builder"
        ]
    },
    {
        "q": "What is formControlName?",
        "type": "mcq",
        "o": [
            "Directive to bind control by name",
            "Control type",
            "Control id",
            "Control label"
        ]
    },
    {
        "q": "formControlName must match the key in FormGroup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this bind?",
        "type": "mcq",
        "c": "<input formControlName=\"email\">",
        "o": [
            "Input to email FormControl in FormGroup",
            "Email value",
            "Email template",
            "Email validator"
        ]
    },
    {
        "q": "The _____ directive binds input to named control.",
        "type": "fill_blank",
        "answers": [
            "formControlName"
        ],
        "other_options": [
            "controlName",
            "ngControl",
            "inputControl"
        ]
    },
    {
        "q": "Rearrange form control binding:",
        "type": "rearrange",
        "words": [
            "Define FormGroup with controls",
            "Add [formGroup] to form",
            "Add formControlName to input",
            "Access value via form.value",
            "Check validity via form.valid"
        ]
    },
    {
        "q": "What is FormArray?",
        "type": "mcq",
        "o": [
            "Array of FormControls or FormGroups",
            "Single control",
            "Form group",
            "Form builder"
        ]
    },
    {
        "q": "FormArray is useful for dynamic lists.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "phones = new FormArray([new FormControl('')]);",
        "o": [
            "Array with one phone control",
            "Single phone",
            "Phone group",
            "Phone validator"
        ]
    },
    {
        "q": "The _____ method adds controls to FormArray.",
        "type": "fill_blank",
        "answers": [
            "push"
        ],
        "other_options": [
            "add",
            "insert",
            "append"
        ]
    },
    {
        "q": "Match FormArray methods:",
        "type": "match",
        "left": [
            "push",
            "removeAt",
            "at",
            "clear"
        ],
        "right": [
            "Add control",
            "Remove by index",
            "Get by index",
            "Remove all"
        ]
    },
    {
        "q": "What is Validators?",
        "type": "mcq",
        "o": [
            "Class providing built-in validation functions",
            "Form helper",
            "Form builder",
            "Control class"
        ]
    },
    {
        "q": "Validators.required makes a field mandatory.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this validate?",
        "type": "mcq",
        "c": "email = new FormControl('', [Validators.required, Validators.email]);",
        "o": [
            "Required field with valid email format",
            "Only required",
            "Only email",
            "No validation"
        ]
    },
    {
        "q": "The _____ validator checks email format.",
        "type": "fill_blank",
        "answers": [
            "Validators.email"
        ],
        "other_options": [
            "Validators.emailFormat",
            "Validators.isEmail",
            "Validators.mail"
        ]
    },
    {
        "q": "Match built-in validators:",
        "type": "match",
        "left": [
            "required",
            "minLength",
            "maxLength",
            "pattern"
        ],
        "right": [
            "Field required",
            "Minimum characters",
            "Maximum characters",
            "Regex match"
        ]
    },
    {
        "q": "What is a custom validator?",
        "type": "mcq",
        "o": [
            "User-defined validation function",
            "Built-in validator",
            "Form control",
            "Form group"
        ]
    },
    {
        "q": "Custom validators return null when valid.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this validator check?",
        "type": "mcq",
        "c": "function noSpaces(control: AbstractControl) { return /\\s/.test(control.value) ? { hasSpaces: true } : null; }",
        "o": [
            "Returns error if value contains spaces",
            "Allows spaces",
            "Requires spaces",
            "Trims spaces"
        ]
    },
    {
        "q": "Custom validators return _____ for valid values.",
        "type": "fill_blank",
        "answers": [
            "null"
        ],
        "other_options": [
            "true",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Match validator returns:",
        "type": "match",
        "left": [
            "null",
            "{ error: true }",
            "Promise",
            "Observable"
        ],
        "right": [
            "Valid",
            "Invalid sync",
            "Async validation",
            "Async validation"
        ]
    },
    {
        "q": "What is async validation?",
        "type": "mcq",
        "o": [
            "Validation that requires server call",
            "Sync validation",
            "Instant validation",
            "Local validation"
        ]
    },
    {
        "q": "Async validators return Observable or Promise.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this async validator do?",
        "type": "mcq",
        "c": "function checkUsername(control: AbstractControl) { return http.get(`/api/check/${control.value}`).pipe(map(exists => exists ? { taken: true } : null)); }",
        "o": [
            "Checks if username is already taken",
            "Creates username",
            "Validates format",
            "Hashes password"
        ]
    },
    {
        "q": "Async validators are passed as the _____ argument.",
        "type": "fill_blank",
        "answers": [
            "third"
        ],
        "other_options": [
            "first",
            "second",
            "fourth"
        ]
    },
    {
        "q": "Rearrange async validation:",
        "type": "rearrange",
        "words": [
            "User types value",
            "Sync validators run",
            "Async validators run",
            "Server request made",
            "Validation result returned"
        ]
    },
    {
        "q": "What is control status?",
        "type": "mcq",
        "o": [
            "State of form control validity",
            "Control type",
            "Control value",
            "Control name"
        ]
    },
    {
        "q": "VALID status means all validators passed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this check?",
        "type": "mcq",
        "c": "form.get('email')?.status",
        "o": [
            "Validation status of email control",
            "Email value",
            "Email type",
            "Email name"
        ]
    },
    {
        "q": "The _____ property returns control validation status.",
        "type": "fill_blank",
        "answers": [
            "status"
        ],
        "other_options": [
            "state",
            "validity",
            "condition"
        ]
    },
    {
        "q": "Match control statuses:",
        "type": "match",
        "left": [
            "VALID",
            "INVALID",
            "PENDING",
            "DISABLED"
        ],
        "right": [
            "All validators pass",
            "Validation failed",
            "Async validation running",
            "Control disabled"
        ]
    },
    {
        "q": "What is touched state?",
        "type": "mcq",
        "o": [
            "User has focused and left the control",
            "User is typing",
            "Control has value",
            "Control is valid"
        ]
    },
    {
        "q": "touched becomes true after blur event.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this show?",
        "type": "mcq",
        "c": "<div *ngIf=\"email.touched && email.invalid\">Error message</div>",
        "o": [
            "Error only after user leaves invalid field",
            "Error immediately",
            "Error always",
            "Error never"
        ]
    },
    {
        "q": "The _____ property is true after user blurs control.",
        "type": "fill_blank",
        "answers": [
            "touched"
        ],
        "other_options": [
            "focused",
            "blurred",
            "interacted"
        ]
    },
    {
        "q": "Match control states:",
        "type": "match",
        "left": [
            "touched",
            "untouched",
            "dirty",
            "pristine"
        ],
        "right": [
            "Has been blurred",
            "Never blurred",
            "Value changed",
            "Value unchanged"
        ]
    },
    {
        "q": "What is dirty state?",
        "type": "mcq",
        "o": [
            "User has modified the control value",
            "Control is touched",
            "Control is valid",
            "Control has error"
        ]
    },
    {
        "q": "dirty becomes true when value changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this check?",
        "type": "mcq",
        "c": "form.dirty",
        "o": [
            "Any control value has been modified",
            "Form is valid",
            "Form is touched",
            "Form has errors"
        ]
    },
    {
        "q": "The opposite of dirty is _____.",
        "type": "fill_blank",
        "answers": [
            "pristine"
        ],
        "other_options": [
            "clean",
            "unchanged",
            "fresh"
        ]
    },
    {
        "q": "Rearrange state changes:",
        "type": "rearrange",
        "words": [
            "Control created (pristine, untouched)",
            "User focuses control",
            "User types (dirty)",
            "User leaves (touched)",
            "Validation runs"
        ]
    },
    {
        "q": "What is setValue?",
        "type": "mcq",
        "o": [
            "Method to set entire form value",
            "Get form value",
            "Reset form",
            "Clear form"
        ]
    },
    {
        "q": "setValue requires all controls to be present.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "form.setValue({ name: 'John', email: 'john@email.com' });",
        "o": [
            "Sets all form control values",
            "Sets partial values",
            "Resets form",
            "Clears form"
        ]
    },
    {
        "q": "The _____ method sets partial form values.",
        "type": "fill_blank",
        "answers": [
            "patchValue"
        ],
        "other_options": [
            "setValue",
            "updateValue",
            "partialValue"
        ]
    },
    {
        "q": "Match value methods:",
        "type": "match",
        "left": [
            "setValue",
            "patchValue",
            "reset",
            "getRawValue"
        ],
        "right": [
            "Set all values",
            "Set some values",
            "Clear values and states",
            "Get including disabled"
        ]
    },
    {
        "q": "What is patchValue?",
        "type": "mcq",
        "o": [
            "Method to update some control values",
            "Set all values",
            "Reset form",
            "Validate form"
        ]
    },
    {
        "q": "patchValue ignores missing keys.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this update?",
        "type": "mcq",
        "c": "form.patchValue({ name: 'Jane' });",
        "o": [
            "Only the name control value",
            "All values",
            "No values",
            "Resets form"
        ]
    },
    {
        "q": "patchValue is useful for _____ form updates.",
        "type": "fill_blank",
        "answers": [
            "partial"
        ],
        "other_options": [
            "complete",
            "full",
            "entire"
        ]
    },
    {
        "q": "Rearrange form population:",
        "type": "rearrange",
        "words": [
            "Fetch data from API",
            "Call patchValue or setValue",
            "Form displays values",
            "User edits",
            "Submit changes"
        ]
    },
    {
        "q": "What is form reset?",
        "type": "mcq",
        "o": [
            "Clearing values and resetting states",
            "Set values",
            "Patch values",
            "Validate form"
        ]
    },
    {
        "q": "reset() can accept initial values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "form.reset({ name: 'Default' });",
        "o": [
            "Resets form with default name value",
            "Clears all values",
            "Sets all values",
            "Patches values"
        ]
    },
    {
        "q": "reset() sets state to _____ and untouched.",
        "type": "fill_blank",
        "answers": [
            "pristine"
        ],
        "other_options": [
            "dirty",
            "touched",
            "valid"
        ]
    },
    {
        "q": "Match reset behaviors:",
        "type": "match",
        "left": [
            "reset()",
            "reset(values)",
            "reset({}, {onlySelf})",
            "control.reset()"
        ],
        "right": [
            "Clear to null",
            "Clear to values",
            "Don't propagate",
            "Reset single control"
        ]
    },
    {
        "q": "What is ngSubmit?",
        "type": "mcq",
        "o": [
            "Event emitted when form is submitted",
            "Form validator",
            "Form control",
            "Form group"
        ]
    },
    {
        "q": "ngSubmit prevents default form submission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this handle?",
        "type": "mcq",
        "c": "<form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">",
        "o": [
            "Form submission with custom handler",
            "Form reset",
            "Form validation",
            "Form binding"
        ]
    },
    {
        "q": "The _____ event handles form submission.",
        "type": "fill_blank",
        "answers": [
            "ngSubmit"
        ],
        "other_options": [
            "submit",
            "onSubmit",
            "formSubmit"
        ]
    },
    {
        "q": "Rearrange form submission:",
        "type": "rearrange",
        "words": [
            "User clicks submit",
            "(ngSubmit) fires",
            "Check form.valid",
            "Process form.value",
            "Send to server"
        ]
    },
    {
        "q": "What is validation error display?",
        "type": "mcq",
        "o": [
            "Showing error messages to users",
            "Logging errors",
            "Throwing errors",
            "Ignoring errors"
        ]
    },
    {
        "q": "hasError() checks for specific validation error.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this display?",
        "type": "mcq",
        "c": "<div *ngIf=\"form.get('email').hasError('required')\">Email is required</div>",
        "o": [
            "Error message if email is empty",
            "Always shows",
            "Never shows",
            "Shows email value"
        ]
    },
    {
        "q": "The _____ method checks for specific error key.",
        "type": "fill_blank",
        "answers": [
            "hasError"
        ],
        "other_options": [
            "getError",
            "checkError",
            "isError"
        ]
    },
    {
        "q": "Match error access:",
        "type": "match",
        "left": [
            "errors",
            "hasError('key')",
            "getError('key')",
            "setErrors()"
        ],
        "right": [
            "All errors object",
            "Check error exists",
            "Get error value",
            "Set errors manually"
        ]
    },
    {
        "q": "What is updateOn?",
        "type": "mcq",
        "o": [
            "Configuration for when validation runs",
            "Update value",
            "Update status",
            "Update state"
        ]
    },
    {
        "q": "Default updateOn is 'change'.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "new FormControl('', { updateOn: 'blur' });",
        "o": [
            "Validation runs only on blur",
            "Validation on every change",
            "Validation on submit",
            "No validation"
        ]
    },
    {
        "q": "updateOn: 'submit' delays validation until _____.",
        "type": "fill_blank",
        "answers": [
            "form submission"
        ],
        "other_options": [
            "blur",
            "change",
            "focus"
        ]
    },
    {
        "q": "Match updateOn values:",
        "type": "match",
        "left": [
            "change",
            "blur",
            "submit"
        ],
        "right": [
            "Every keystroke",
            "On field exit",
            "On form submit"
        ]
    },
    {
        "q": "What is valueChanges?",
        "type": "mcq",
        "o": [
            "Observable that emits on value changes",
            "Value property",
            "Change handler",
            "Event emitter"
        ]
    },
    {
        "q": "valueChanges is an Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this subscribe to?",
        "type": "mcq",
        "c": "form.get('search').valueChanges.pipe(debounceTime(300)).subscribe(val => search(val));",
        "o": [
            "Debounced search input changes",
            "All form changes",
            "Single value",
            "Form submission"
        ]
    },
    {
        "q": "The _____ observable emits when value changes.",
        "type": "fill_blank",
        "answers": [
            "valueChanges"
        ],
        "other_options": [
            "value",
            "changes",
            "valueUpdated"
        ]
    },
    {
        "q": "Match form observables:",
        "type": "match",
        "left": [
            "valueChanges",
            "statusChanges",
            "events"
        ],
        "right": [
            "Value updates",
            "Validity updates",
            "All control events"
        ]
    },
    {
        "q": "What is statusChanges?",
        "type": "mcq",
        "o": [
            "Observable that emits on status changes",
            "Status property",
            "Status handler",
            "Event emitter"
        ]
    },
    {
        "q": "statusChanges emits VALID, INVALID, PENDING, or DISABLED.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this track?",
        "type": "mcq",
        "c": "form.statusChanges.subscribe(status => console.log(status));",
        "o": [
            "Form validation status changes",
            "Value changes",
            "Control creation",
            "Form submission"
        ]
    },
    {
        "q": "statusChanges is useful for tracking _____ validation.",
        "type": "fill_blank",
        "answers": [
            "async"
        ],
        "other_options": [
            "sync",
            "local",
            "instant"
        ]
    },
    {
        "q": "Rearrange async validation tracking:",
        "type": "rearrange",
        "words": [
            "User types value",
            "Status becomes PENDING",
            "Async validator runs",
            "Status becomes VALID or INVALID",
            "statusChanges emits"
        ]
    },
    {
        "q": "What is nested FormGroup?",
        "type": "mcq",
        "o": [
            "FormGroup inside another FormGroup",
            "Single form",
            "Form array",
            "Form control"
        ]
    },
    {
        "q": "Nested FormGroups organize complex forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "form = this.fb.group({ user: this.fb.group({ name: '', email: '' }), address: this.fb.group({ street: '', city: '' }) });",
        "o": [
            "Form with nested user and address groups",
            "Flat form",
            "Single group",
            "Form array"
        ]
    },
    {
        "q": "The _____ directive binds nested FormGroup.",
        "type": "fill_blank",
        "answers": [
            "formGroupName"
        ],
        "other_options": [
            "nestedGroup",
            "childGroup",
            "subGroup"
        ]
    },
    {
        "q": "Match nested form directives:",
        "type": "match",
        "left": [
            "formGroup",
            "formGroupName",
            "formArrayName",
            "formControlName"
        ],
        "right": [
            "Root form binding",
            "Nested group binding",
            "Array binding",
            "Control binding"
        ]
    },
    {
        "q": "What is formGroupName directive?",
        "type": "mcq",
        "o": [
            "Binds nested FormGroup by name",
            "Creates form group",
            "Validates group",
            "Submits group"
        ]
    },
    {
        "q": "formGroupName must be used inside [formGroup].",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this bind?",
        "type": "mcq",
        "c": "<div formGroupName=\"address\"><input formControlName=\"city\"></div>",
        "o": [
            "City input to address.city control",
            "City to root",
            "Address only",
            "All controls"
        ]
    },
    {
        "q": "Nested groups require _____ directive for template binding.",
        "type": "fill_blank",
        "answers": [
            "formGroupName"
        ],
        "other_options": [
            "formGroup",
            "nestedForm",
            "childForm"
        ]
    },
    {
        "q": "Rearrange nested form structure:",
        "type": "rearrange",
        "words": [
            "Define root FormGroup",
            "Add nested FormGroups",
            "Bind root with [formGroup]",
            "Use formGroupName for nested",
            "Add formControlName inside"
        ]
    },
    {
        "q": "What is dynamic FormArray?",
        "type": "mcq",
        "o": [
            "FormArray with add/remove functionality",
            "Static array",
            "Fixed controls",
            "Single control"
        ]
    },
    {
        "q": "FormArray length can change at runtime.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "addPhone() { this.phones.push(new FormControl('')); }",
        "o": [
            "Adds new phone input to form",
            "Removes phone",
            "Clears phones",
            "Validates phones"
        ]
    },
    {
        "q": "The _____ directive binds FormArray to template.",
        "type": "fill_blank",
        "answers": [
            "formArrayName"
        ],
        "other_options": [
            "formArray",
            "arrayName",
            "listName"
        ]
    },
    {
        "q": "Match FormArray operations:",
        "type": "match",
        "left": [
            "push",
            "removeAt",
            "insert",
            "setControl"
        ],
        "right": [
            "Add to end",
            "Remove by index",
            "Add at index",
            "Replace at index"
        ]
    },
    {
        "q": "What is formArrayName?",
        "type": "mcq",
        "o": [
            "Directive to bind FormArray by name",
            "Array validator",
            "Array creator",
            "Control name"
        ]
    },
    {
        "q": "formArrayName requires index for control access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this template render?",
        "type": "mcq",
        "c": "<div formArrayName=\"phones\"><div *ngFor=\"let phone of phones.controls; let i = index\"><input [formControlName]=\"i\"></div></div>",
        "o": [
            "Dynamic list of phone inputs",
            "Single input",
            "Static list",
            "No inputs"
        ]
    },
    {
        "q": "FormArray controls are accessed by _____ as formControlName.",
        "type": "fill_blank",
        "answers": [
            "index"
        ],
        "other_options": [
            "name",
            "key",
            "id"
        ]
    },
    {
        "q": "Rearrange dynamic array rendering:",
        "type": "rearrange",
        "words": [
            "Define FormArray in component",
            "Add formArrayName to container",
            "Use *ngFor with controls",
            "Bind index to formControlName",
            "Add/remove controls as needed"
        ]
    },
    {
        "q": "What is ControlValueAccessor?",
        "type": "mcq",
        "o": [
            "Interface for custom form controls",
            "Form validator",
            "Form builder",
            "Control wrapper"
        ]
    },
    {
        "q": "ControlValueAccessor bridges forms and DOM.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What must this interface implement?",
        "type": "mcq",
        "c": "export class CustomInput implements ControlValueAccessor",
        "o": [
            "writeValue, registerOnChange, registerOnTouched",
            "Only writeValue",
            "Only registerOnChange",
            "validate method"
        ]
    },
    {
        "q": "The _____ method receives value from form control.",
        "type": "fill_blank",
        "answers": [
            "writeValue"
        ],
        "other_options": [
            "setValue",
            "updateValue",
            "getValue"
        ]
    },
    {
        "q": "Match ControlValueAccessor methods:",
        "type": "match",
        "left": [
            "writeValue",
            "registerOnChange",
            "registerOnTouched",
            "setDisabledState"
        ],
        "right": [
            "Receive form value",
            "Report value changes",
            "Report blur events",
            "Handle disabled state"
        ]
    },
    {
        "q": "What is cross-field validation?",
        "type": "mcq",
        "o": [
            "Validation across multiple controls",
            "Single field validation",
            "Async validation",
            "Pattern validation"
        ]
    },
    {
        "q": "Cross-field validators are applied to FormGroup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this validator check?",
        "type": "mcq",
        "c": "function passwordMatch(group: FormGroup) { return group.get('password').value === group.get('confirm').value ? null : { mismatch: true }; }",
        "o": [
            "Password and confirm match",
            "Password strength",
            "Confirm required",
            "Both required"
        ]
    },
    {
        "q": "Cross-field validators receive _____ as parameter.",
        "type": "fill_blank",
        "answers": [
            "FormGroup"
        ],
        "other_options": [
            "FormControl",
            "FormArray",
            "AbstractControl"
        ]
    },
    {
        "q": "Match validator targets:",
        "type": "match",
        "left": [
            "FormControl validator",
            "FormGroup validator",
            "FormArray validator",
            "Async validator"
        ],
        "right": [
            "Single field",
            "Cross-field",
            "Array items",
            "Server check"
        ]
    },
    {
        "q": "What is Validators.compose?",
        "type": "mcq",
        "o": [
            "Combines multiple validators",
            "Creates validator",
            "Clears validators",
            "Sets validators"
        ]
    },
    {
        "q": "compose merges validator functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "Validators.compose([Validators.required, Validators.minLength(3)])",
        "o": [
            "Single validator from two",
            "Two separate validators",
            "No validators",
            "Async validator"
        ]
    },
    {
        "q": "Arrays of validators are _____ automatically.",
        "type": "fill_blank",
        "answers": [
            "composed"
        ],
        "other_options": [
            "separated",
            "merged",
            "combined"
        ]
    },
    {
        "q": "Match validator utilities:",
        "type": "match",
        "left": [
            "compose",
            "composeAsync",
            "nullValidator",
            "requiredTrue"
        ],
        "right": [
            "Merge sync validators",
            "Merge async validators",
            "Always valid",
            "Checkbox must be true"
        ]
    },
    {
        "q": "What is setValidators?",
        "type": "mcq",
        "o": [
            "Replaces all validators on control",
            "Adds validators",
            "Removes validators",
            "Checks validators"
        ]
    },
    {
        "q": "setValidators requires updateValueAndValidity call.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this change?",
        "type": "mcq",
        "c": "control.setValidators([Validators.required]); control.updateValueAndValidity();",
        "o": [
            "Sets required as only validator",
            "Adds required",
            "Removes required",
            "No change"
        ]
    },
    {
        "q": "The _____ method adds validators without replacing.",
        "type": "fill_blank",
        "answers": [
            "addValidators"
        ],
        "other_options": [
            "setValidators",
            "pushValidator",
            "insertValidator"
        ]
    },
    {
        "q": "Match validator management:",
        "type": "match",
        "left": [
            "setValidators",
            "addValidators",
            "removeValidators",
            "clearValidators"
        ],
        "right": [
            "Replace all",
            "Add to existing",
            "Remove specific",
            "Remove all"
        ]
    },
    {
        "q": "What is updateValueAndValidity?",
        "type": "mcq",
        "o": [
            "Triggers validation recalculation",
            "Updates value only",
            "Updates validity only",
            "Clears control"
        ]
    },
    {
        "q": "updateValueAndValidity must be called after changing validators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "control.updateValueAndValidity({ onlySelf: true });",
        "o": [
            "Revalidates without notifying parent",
            "Updates parent too",
            "Clears validation",
            "Sets value"
        ]
    },
    {
        "q": "onlySelf: true prevents _____ propagation.",
        "type": "fill_blank",
        "answers": [
            "parent"
        ],
        "other_options": [
            "child",
            "sibling",
            "root"
        ]
    },
    {
        "q": "Match update options:",
        "type": "match",
        "left": [
            "onlySelf: true",
            "emitEvent: false",
            "no options",
            "both options"
        ],
        "right": [
            "Don't notify parent",
            "Don't emit valueChanges",
            "Full propagation",
            "Silent update"
        ]
    },
    {
        "q": "What is markAsTouched?",
        "type": "mcq",
        "o": [
            "Programmatically sets touched state",
            "Clears touched",
            "Validates control",
            "Updates value"
        ]
    },
    {
        "q": "markAsTouched triggers validation error display.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "form.markAllAsTouched();",
        "o": [
            "Marks all controls as touched for error display",
            "Clears all touched",
            "Validates all",
            "Resets all"
        ]
    },
    {
        "q": "markAllAsTouched is useful before _____ to show all errors.",
        "type": "fill_blank",
        "answers": [
            "submission"
        ],
        "other_options": [
            "reset",
            "clear",
            "validation"
        ]
    },
    {
        "q": "Match mark methods:",
        "type": "match",
        "left": [
            "markAsTouched",
            "markAsUntouched",
            "markAsDirty",
            "markAsPristine"
        ],
        "right": [
            "Set touched",
            "Clear touched",
            "Set modified",
            "Clear modified"
        ]
    },
    {
        "q": "What is disable/enable?",
        "type": "mcq",
        "o": [
            "Methods to toggle control disabled state",
            "Validation methods",
            "Value methods",
            "State methods"
        ]
    },
    {
        "q": "Disabled controls are excluded from form.value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "form.get('email').disable();",
        "o": [
            "Disables email control and removes from value",
            "Enables email",
            "Validates email",
            "Clears email"
        ]
    },
    {
        "q": "The _____ method includes disabled values.",
        "type": "fill_blank",
        "answers": [
            "getRawValue"
        ],
        "other_options": [
            "getValue",
            "getAllValues",
            "getFullValue"
        ]
    },
    {
        "q": "Match control methods:",
        "type": "match",
        "left": [
            "disable()",
            "enable()",
            "getRawValue()",
            "value"
        ],
        "right": [
            "Disable control",
            "Enable control",
            "Get all including disabled",
            "Get enabled only"
        ]
    },
    {
        "q": "What is form control initial value?",
        "type": "mcq",
        "o": [
            "Default value when control is created",
            "Current value",
            "Validated value",
            "Submitted value"
        ]
    },
    {
        "q": "Initial value is passed as first argument to FormControl.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the initial value here?",
        "type": "mcq",
        "c": "new FormControl('default', Validators.required)",
        "o": [
            "The string 'default'",
            "null",
            "undefined",
            "empty string"
        ]
    },
    {
        "q": "FormControl with no arguments has _____ initial value.",
        "type": "fill_blank",
        "answers": [
            "null"
        ],
        "other_options": [
            "undefined",
            "empty string",
            "zero"
        ]
    },
    {
        "q": "Match initial values:",
        "type": "match",
        "left": [
            "FormControl()",
            "FormControl('')",
            "FormControl(null)",
            "FormControl(0)"
        ],
        "right": [
            "null",
            "empty string",
            "null explicit",
            "zero"
        ]
    },
    {
        "q": "What is nonNullable FormBuilder?",
        "type": "mcq",
        "o": [
            "Builder that resets to initial value instead of null",
            "Normal builder",
            "Nullable builder",
            "Strict builder"
        ]
    },
    {
        "q": "nonNullable preserves initial value on reset.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What happens on reset?",
        "type": "mcq",
        "c": "fb.nonNullable.control('initial').reset()",
        "o": [
            "Value becomes 'initial'",
            "Value becomes null",
            "Value becomes undefined",
            "Value stays same"
        ]
    },
    {
        "q": "nonNullable controls reset to _____ value.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "null",
            "undefined",
            "empty"
        ]
    },
    {
        "q": "Match reset behaviors:",
        "type": "match",
        "left": [
            "Regular control reset",
            "nonNullable reset",
            "reset with value",
            "clear()"
        ],
        "right": [
            "Value becomes null",
            "Value becomes initial",
            "Value becomes specified",
            "Remove array items"
        ]
    },
    {
        "q": "What is FormRecord?",
        "type": "mcq",
        "o": [
            "Dictionary-like form with string keys",
            "Form array",
            "Form group",
            "Form control"
        ]
    },
    {
        "q": "FormRecord allows dynamic string keys.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "permissions = new FormRecord<FormControl<boolean>>({});",
        "o": [
            "Dynamic record for boolean permissions",
            "Fixed form group",
            "Form array",
            "Single control"
        ]
    },
    {
        "q": "FormRecord differs from FormGroup by allowing _____ keys.",
        "type": "fill_blank",
        "answers": [
            "dynamic"
        ],
        "other_options": [
            "fixed",
            "typed",
            "static"
        ]
    },
    {
        "q": "Match form types:",
        "type": "match",
        "left": [
            "FormControl",
            "FormGroup",
            "FormArray",
            "FormRecord"
        ],
        "right": [
            "Single value",
            "Fixed key object",
            "Index-based list",
            "Dynamic key object"
        ]
    },
    {
        "q": "What is typed forms?",
        "type": "mcq",
        "o": [
            "Strictly typed reactive forms in Angular 14+",
            "Untyped forms",
            "Template forms",
            "Legacy forms"
        ]
    },
    {
        "q": "Typed forms provide compile-time type checking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What type does this form have?",
        "type": "mcq",
        "c": "form = new FormGroup({ name: new FormControl<string>('') });",
        "o": [
            "FormGroup<{ name: FormControl<string> }>",
            "FormGroup<any>",
            "FormGroup<string>",
            "Untyped FormGroup"
        ]
    },
    {
        "q": "Typed forms infer types from _____ values.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "validated",
            "submitted",
            "current"
        ]
    },
    {
        "q": "Match form typing:",
        "type": "match",
        "left": [
            "FormControl<string>",
            "FormControl<number>",
            "FormControl<boolean>",
            "FormControl<null | string>"
        ],
        "right": [
            "String control",
            "Number control",
            "Boolean control",
            "Nullable string"
        ]
    },
    {
        "q": "What is UntypedFormControl?",
        "type": "mcq",
        "o": [
            "Legacy untyped form control",
            "Typed control",
            "New control",
            "Strict control"
        ]
    },
    {
        "q": "UntypedFormControl is for migration from older Angular.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the difference?",
        "type": "mcq",
        "c": "new FormControl('') vs new UntypedFormControl('')",
        "o": [
            "First is typed, second is any",
            "Both typed",
            "Both untyped",
            "No difference"
        ]
    },
    {
        "q": "UntypedFormControl value property returns _____.",
        "type": "fill_blank",
        "answers": [
            "any"
        ],
        "other_options": [
            "string",
            "unknown",
            "object"
        ]
    },
    {
        "q": "Match form classes:",
        "type": "match",
        "left": [
            "FormControl",
            "UntypedFormControl",
            "FormGroup",
            "UntypedFormGroup"
        ],
        "right": [
            "Typed control",
            "Untyped control",
            "Typed group",
            "Untyped group"
        ]
    },
    {
        "q": "What is ngModelGroup?",
        "type": "mcq",
        "o": [
            "Groups template-driven form controls",
            "Reactive group",
            "Validation group",
            "Submit group"
        ]
    },
    {
        "q": "ngModelGroup creates nested groups in template forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<div ngModelGroup=\"address\"><input ngModel name=\"city\"></div>",
        "o": [
            "Nested address group with city",
            "Flat form",
            "Array",
            "Single control"
        ]
    },
    {
        "q": "ngModelGroup is for _____ forms.",
        "type": "fill_blank",
        "answers": [
            "template-driven"
        ],
        "other_options": [
            "reactive",
            "mixed",
            "hybrid"
        ]
    },
    {
        "q": "Match template form directives:",
        "type": "match",
        "left": [
            "ngForm",
            "ngModel",
            "ngModelGroup",
            "ngModelOptions"
        ],
        "right": [
            "Form container",
            "Input binding",
            "Group controls",
            "Configure behavior"
        ]
    },
    {
        "q": "What is ngModelOptions?",
        "type": "mcq",
        "o": [
            "Configuration for ngModel behavior",
            "Model validation",
            "Model value",
            "Model binding"
        ]
    },
    {
        "q": "ngModelOptions can set updateOn for template forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configure?",
        "type": "mcq",
        "c": "<input ngModel [ngModelOptions]=\"{ updateOn: 'blur' }\">",
        "o": [
            "Updates model only on blur",
            "Updates on change",
            "Updates on submit",
            "No updates"
        ]
    },
    {
        "q": "ngModelOptions standalone: true allows _____ ngModel.",
        "type": "fill_blank",
        "answers": [
            "standalone"
        ],
        "other_options": [
            "grouped",
            "nested",
            "bound"
        ]
    },
    {
        "q": "Match ngModelOptions:",
        "type": "match",
        "left": [
            "updateOn",
            "standalone",
            "name"
        ],
        "right": [
            "When to update",
            "Outside form",
            "Control identifier"
        ]
    },
    {
        "q": "What is form submission prevention?",
        "type": "mcq",
        "o": [
            "Stopping submission if form invalid",
            "Always submit",
            "Skip validation",
            "Force submission"
        ]
    },
    {
        "q": "Checking form.valid before submit is best practice.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this prevent?",
        "type": "mcq",
        "c": "onSubmit() { if (this.form.invalid) { this.form.markAllAsTouched(); return; } }",
        "o": [
            "Submission with invalid data and shows errors",
            "All submissions",
            "Valid submissions",
            "Error display"
        ]
    },
    {
        "q": "markAllAsTouched reveals _____ before submission.",
        "type": "fill_blank",
        "answers": [
            "validation errors"
        ],
        "other_options": [
            "form values",
            "control names",
            "form state"
        ]
    },
    {
        "q": "Rearrange submission flow:",
        "type": "rearrange",
        "words": [
            "User clicks submit",
            "Check form.valid",
            "If invalid, mark touched",
            "If valid, get form.value",
            "Send to server"
        ]
    },
    {
        "q": "What is form error handling?",
        "type": "mcq",
        "o": [
            "Displaying appropriate validation messages",
            "Ignoring errors",
            "Logging errors",
            "Throwing errors"
        ]
    },
    {
        "q": "Good UX shows errors at appropriate times.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the best practice here?",
        "type": "mcq",
        "c": "<mat-error *ngIf=\"control.touched && control.hasError('required')\">Required</mat-error>",
        "o": [
            "Show error only after user interaction",
            "Show immediately",
            "Never show",
            "Show on submit only"
        ]
    },
    {
        "q": "Errors are typically shown after control is _____.",
        "type": "fill_blank",
        "answers": [
            "touched"
        ],
        "other_options": [
            "created",
            "focused",
            "submitted"
        ]
    },
    {
        "q": "Match error display strategies:",
        "type": "match",
        "left": [
            "Show on touched",
            "Show on dirty",
            "Show on submit",
            "Show immediately"
        ],
        "right": [
            "After blur",
            "After value change",
            "All at once",
            "Aggressive"
        ]
    },
    {
        "q": "What is form testing with TestBed?",
        "type": "mcq",
        "o": [
            "Testing forms using Angular testing utilities",
            "Form validation",
            "Form creation",
            "Form submission"
        ]
    },
    {
        "q": "ReactiveFormsModule must be imported for testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test verify?",
        "type": "mcq",
        "c": "it('should be invalid when empty', () => { expect(component.form.valid).toBeFalse(); });",
        "o": [
            "Form is invalid with no values",
            "Form is valid",
            "Form exists",
            "Form has controls"
        ]
    },
    {
        "q": "Form tests should verify _____ states.",
        "type": "fill_blank",
        "answers": [
            "validity"
        ],
        "other_options": [
            "creation",
            "display",
            "rendering"
        ]
    },
    {
        "q": "Match form test scenarios:",
        "type": "match",
        "left": [
            "Initial state",
            "Valid input",
            "Invalid input",
            "Submit handling"
        ],
        "right": [
            "Form starts invalid/pristine",
            "Form becomes valid",
            "Shows errors",
            "Calls submit method"
        ]
    },
    {
        "q": "What is testing validators?",
        "type": "mcq",
        "o": [
            "Unit testing validation functions",
            "Creating validators",
            "Applying validators",
            "Removing validators"
        ]
    },
    {
        "q": "Custom validators can be tested in isolation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test?",
        "type": "mcq",
        "c": "it('should return error for spaces', () => { const control = new FormControl('has space'); expect(noSpaces(control)).toEqual({ hasSpaces: true }); });",
        "o": [
            "Custom validator detects spaces",
            "Validator creates control",
            "Validator clears spaces",
            "Validator allows spaces"
        ]
    },
    {
        "q": "Validators return _____ when valid.",
        "type": "fill_blank",
        "answers": [
            "null"
        ],
        "other_options": [
            "true",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Rearrange validator testing:",
        "type": "rearrange",
        "words": [
            "Create FormControl with test value",
            "Call validator function",
            "Check return value",
            "Assert null for valid",
            "Assert error object for invalid"
        ]
    },
    {
        "q": "What is testing async validators?",
        "type": "mcq",
        "o": [
            "Testing validators that return Observable/Promise",
            "Sync testing",
            "Instant testing",
            "Mock testing"
        ]
    },
    {
        "q": "fakeAsync/tick helps test async validators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test setup handle?",
        "type": "mcq",
        "c": "it('should validate async', fakeAsync(() => { control.setValue('test'); tick(300); expect(control.valid).toBeTrue(); }));",
        "o": [
            "Async validator with debounce",
            "Sync validator",
            "No validator",
            "Multiple validators"
        ]
    },
    {
        "q": "tick() advances _____ time in tests.",
        "type": "fill_blank",
        "answers": [
            "virtual"
        ],
        "other_options": [
            "real",
            "system",
            "actual"
        ]
    },
    {
        "q": "Match async testing utilities:",
        "type": "match",
        "left": [
            "fakeAsync",
            "tick",
            "flush",
            "waitForAsync"
        ],
        "right": [
            "Zone wrapper",
            "Advance time",
            "Clear queue",
            "Real async"
        ]
    },
    {
        "q": "What is Material form fields?",
        "type": "mcq",
        "o": [
            "Angular Material styled form inputs",
            "Plain inputs",
            "Custom inputs",
            "Native inputs"
        ]
    },
    {
        "q": "mat-form-field wraps Material inputs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<mat-form-field><mat-label>Email</mat-label><input matInput formControlName=\"email\"></mat-form-field>",
        "o": [
            "Styled Material input with label",
            "Plain input",
            "Text only",
            "Label only"
        ]
    },
    {
        "q": "The _____ directive applies Material styles to input.",
        "type": "fill_blank",
        "answers": [
            "matInput"
        ],
        "other_options": [
            "matField",
            "matControl",
            "matForm"
        ]
    },
    {
        "q": "Match Material form components:",
        "type": "match",
        "left": [
            "mat-form-field",
            "mat-label",
            "mat-error",
            "mat-hint"
        ],
        "right": [
            "Container",
            "Field label",
            "Validation error",
            "Help text"
        ]
    },
    {
        "q": "What is mat-error?",
        "type": "mcq",
        "o": [
            "Material component for validation errors",
            "Error handler",
            "Error logger",
            "Error service"
        ]
    },
    {
        "q": "mat-error shows only when control is invalid and touched.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this display?",
        "type": "mcq",
        "c": "<mat-error *ngIf=\"email.hasError('email')\">Invalid email format</mat-error>",
        "o": [
            "Error message for invalid email",
            "Always shows",
            "Never shows",
            "Email value"
        ]
    },
    {
        "q": "mat-error requires _____ matcher for custom timing.",
        "type": "fill_blank",
        "answers": [
            "ErrorStateMatcher"
        ],
        "other_options": [
            "ErrorMatcher",
            "StateMatcher",
            "ValidationMatcher"
        ]
    },
    {
        "q": "Match Material error features:",
        "type": "match",
        "left": [
            "mat-error",
            "ErrorStateMatcher",
            "ShowOnDirtyErrorStateMatcher"
        ],
        "right": [
            "Error display",
            "Custom error timing",
            "Show on value change"
        ]
    },
    {
        "q": "What is ErrorStateMatcher?",
        "type": "mcq",
        "o": [
            "Controls when mat-error displays",
            "Error validator",
            "Error handler",
            "Error logger"
        ]
    },
    {
        "q": "Custom ErrorStateMatcher overrides default behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this matcher do?",
        "type": "mcq",
        "c": "class ShowOnSubmit implements ErrorStateMatcher { isErrorState(control, form) { return form?.submitted && control?.invalid; } }",
        "o": [
            "Shows errors only after form submit",
            "Shows immediately",
            "Never shows",
            "Shows on touch"
        ]
    },
    {
        "q": "isErrorState returns _____ to show error.",
        "type": "fill_blank",
        "answers": [
            "true"
        ],
        "other_options": [
            "false",
            "null",
            "error"
        ]
    },
    {
        "q": "Rearrange error matcher usage:",
        "type": "rearrange",
        "words": [
            "Create ErrorStateMatcher class",
            "Implement isErrorState method",
            "Provide in component or globally",
            "mat-error uses matcher",
            "Error shows per logic"
        ]
    },
    {
        "q": "What is mat-select?",
        "type": "mcq",
        "o": [
            "Material dropdown component",
            "Text input",
            "Checkbox",
            "Radio button"
        ]
    },
    {
        "q": "mat-select works with formControlName.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<mat-select formControlName=\"country\"><mat-option *ngFor=\"let c of countries\" [value]=\"c.code\">{{c.name}}</mat-option></mat-select>",
        "o": [
            "Country dropdown with code values",
            "Text input",
            "Checkbox",
            "Radio buttons"
        ]
    },
    {
        "q": "mat-option's _____ property sets the form value.",
        "type": "fill_blank",
        "answers": [
            "[value]"
        ],
        "other_options": [
            "name",
            "text",
            "label"
        ]
    },
    {
        "q": "Match Material select features:",
        "type": "match",
        "left": [
            "mat-select",
            "mat-option",
            "multiple",
            "compareWith"
        ],
        "right": [
            "Dropdown container",
            "Option item",
            "Multi-select",
            "Object comparison"
        ]
    },
    {
        "q": "What is mat-checkbox?",
        "type": "mcq",
        "o": [
            "Material styled checkbox",
            "Radio button",
            "Toggle switch",
            "Text input"
        ]
    },
    {
        "q": "mat-checkbox value is boolean.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this bind?",
        "type": "mcq",
        "c": "<mat-checkbox formControlName=\"agree\">I agree to terms</mat-checkbox>",
        "o": [
            "Boolean agree value in form",
            "String value",
            "Number value",
            "Object value"
        ]
    },
    {
        "q": "Validators.requiredTrue ensures checkbox is _____.",
        "type": "fill_blank",
        "answers": [
            "checked"
        ],
        "other_options": [
            "unchecked",
            "disabled",
            "enabled"
        ]
    },
    {
        "q": "Match checkbox validators:",
        "type": "match",
        "left": [
            "required",
            "requiredTrue",
            "pattern"
        ],
        "right": [
            "Any value",
            "Must be true",
            "Not applicable"
        ]
    },
    {
        "q": "What is mat-radio-group?",
        "type": "mcq",
        "o": [
            "Material radio button group",
            "Single radio",
            "Checkbox group",
            "Select dropdown"
        ]
    },
    {
        "q": "mat-radio-group contains mat-radio-button items.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<mat-radio-group formControlName=\"gender\"><mat-radio-button value=\"m\">Male</mat-radio-button><mat-radio-button value=\"f\">Female</mat-radio-button></mat-radio-group>",
        "o": [
            "Gender selection radio buttons",
            "Checkboxes",
            "Dropdown",
            "Text inputs"
        ]
    },
    {
        "q": "Only one radio button can be _____ in a group.",
        "type": "fill_blank",
        "answers": [
            "selected"
        ],
        "other_options": [
            "visible",
            "enabled",
            "created"
        ]
    },
    {
        "q": "Match radio features:",
        "type": "match",
        "left": [
            "mat-radio-group",
            "mat-radio-button",
            "value",
            "labelPosition"
        ],
        "right": [
            "Container",
            "Option",
            "Form value",
            "Label placement"
        ]
    },
    {
        "q": "What is mat-datepicker?",
        "type": "mcq",
        "o": [
            "Material date picker component",
            "Time picker",
            "Calendar view",
            "Date display"
        ]
    },
    {
        "q": "mat-datepicker requires MatDatepickerModule.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<input matInput [matDatepicker]=\"dp\" formControlName=\"birthDate\"><mat-datepicker-toggle [for]=\"dp\"></mat-datepicker-toggle><mat-datepicker #dp></mat-datepicker>",
        "o": [
            "Date input with date picker popup",
            "Text input",
            "Calendar display",
            "Time picker"
        ]
    },
    {
        "q": "matDatepicker binds input to _____ popup.",
        "type": "fill_blank",
        "answers": [
            "date picker"
        ],
        "other_options": [
            "calendar",
            "time",
            "month"
        ]
    },
    {
        "q": "Match datepicker components:",
        "type": "match",
        "left": [
            "matDatepicker",
            "mat-datepicker",
            "mat-datepicker-toggle",
            "DateAdapter"
        ],
        "right": [
            "Input directive",
            "Popup calendar",
            "Open button",
            "Date handling"
        ]
    },
    {
        "q": "What is form signals integration?",
        "type": "mcq",
        "o": [
            "Using Angular signals with reactive forms",
            "Signal forms",
            "Event signals",
            "Form events"
        ]
    },
    {
        "q": "toSignal can convert valueChanges to signal.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "value = toSignal(this.control.valueChanges, { initialValue: '' });",
        "o": [
            "Signal that tracks control value",
            "Observable",
            "Subject",
            "FormControl"
        ]
    },
    {
        "q": "Signals require _____ to convert observables.",
        "type": "fill_blank",
        "answers": [
            "toSignal"
        ],
        "other_options": [
            "asSignal",
            "signal",
            "createSignal"
        ]
    },
    {
        "q": "Match signal integration:",
        "type": "match",
        "left": [
            "toSignal",
            "computed",
            "effect",
            "signal"
        ],
        "right": [
            "Observable to signal",
            "Derived value",
            "Side effects",
            "Reactive value"
        ]
    },
    {
        "q": "What is form accessibility?",
        "type": "mcq",
        "o": [
            "Making forms usable by all users",
            "Form security",
            "Form styling",
            "Form validation"
        ]
    },
    {
        "q": "Labels are essential for screen readers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this improve?",
        "type": "mcq",
        "c": "<label for=\"email\">Email</label><input id=\"email\" formControlName=\"email\" aria-describedby=\"emailHint\"><span id=\"emailHint\">Enter work email</span>",
        "o": [
            "Screen reader accessibility",
            "Visual styling",
            "Validation",
            "Performance"
        ]
    },
    {
        "q": "aria-describedby links input to _____ text.",
        "type": "fill_blank",
        "answers": [
            "help"
        ],
        "other_options": [
            "error",
            "label",
            "value"
        ]
    },
    {
        "q": "Match accessibility attributes:",
        "type": "match",
        "left": [
            "for/id",
            "aria-describedby",
            "aria-invalid",
            "aria-required"
        ],
        "right": [
            "Label association",
            "Description link",
            "Error state",
            "Required field"
        ]
    },
    {
        "q": "What is aria-invalid?",
        "type": "mcq",
        "o": [
            "Indicates validation error state",
            "Label attribute",
            "Required indicator",
            "Disabled state"
        ]
    },
    {
        "q": "aria-invalid should be true when control is invalid.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "<input [attr.aria-invalid]=\"control.invalid && control.touched\">",
        "o": [
            "Screen reader error announcement",
            "Visual error",
            "Validation",
            "Styling"
        ]
    },
    {
        "q": "Binding aria-invalid requires _____ prefix.",
        "type": "fill_blank",
        "answers": [
            "[attr."
        ],
        "other_options": [
            "[aria.",
            "[prop.",
            "["
        ]
    },
    {
        "q": "Rearrange accessible form:",
        "type": "rearrange",
        "words": [
            "Add label with for attribute",
            "Add id to input",
            "Include aria-describedby",
            "Set aria-invalid on error",
            "Announce error message"
        ]
    },
    {
        "q": "What is form autofill?",
        "type": "mcq",
        "o": [
            "Browser automatic value filling",
            "Manual filling",
            "Default values",
            "Placeholder text"
        ]
    },
    {
        "q": "autocomplete attribute helps browsers fill forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "<input formControlName=\"email\" autocomplete=\"email\">",
        "o": [
            "Browser email autofill",
            "Email validation",
            "Email formatting",
            "Email template"
        ]
    },
    {
        "q": "autocomplete='off' _____ browser autofill.",
        "type": "fill_blank",
        "answers": [
            "disables"
        ],
        "other_options": [
            "enables",
            "ignores",
            "delays"
        ]
    },
    {
        "q": "Match autocomplete values:",
        "type": "match",
        "left": [
            "name",
            "email",
            "tel",
            "address-line1"
        ],
        "right": [
            "Full name",
            "Email address",
            "Phone number",
            "Street address"
        ]
    },
    {
        "q": "What is form field prefixes?",
        "type": "mcq",
        "o": [
            "Icons or text before input",
            "Validators",
            "Labels",
            "Placeholders"
        ]
    },
    {
        "q": "matPrefix adds content before input.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this display?",
        "type": "mcq",
        "c": "<mat-form-field><span matPrefix>$</span><input matInput formControlName=\"price\"></mat-form-field>",
        "o": [
            "Dollar sign before price input",
            "Dollar after",
            "No symbol",
            "Currency selector"
        ]
    },
    {
        "q": "matSuffix adds content _____ the input.",
        "type": "fill_blank",
        "answers": [
            "after"
        ],
        "other_options": [
            "before",
            "below",
            "above"
        ]
    },
    {
        "q": "Match Material affixes:",
        "type": "match",
        "left": [
            "matPrefix",
            "matSuffix",
            "matIconPrefix",
            "matIconSuffix"
        ],
        "right": [
            "Text/content before",
            "Text/content after",
            "Icon before",
            "Icon after"
        ]
    },
    {
        "q": "What is form field appearance?",
        "type": "mcq",
        "o": [
            "Visual style of Material form fields",
            "Validation style",
            "Error style",
            "Label style"
        ]
    },
    {
        "q": "appearance attribute changes form field style.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What style does this use?",
        "type": "mcq",
        "c": "<mat-form-field appearance=\"outline\">",
        "o": [
            "Outlined border style",
            "Filled background",
            "Default underline",
            "No styling"
        ]
    },
    {
        "q": "The _____ appearance uses underline by default.",
        "type": "fill_blank",
        "answers": [
            "fill"
        ],
        "other_options": [
            "outline",
            "standard",
            "legacy"
        ]
    },
    {
        "q": "Match appearance values:",
        "type": "match",
        "left": [
            "fill",
            "outline"
        ],
        "right": [
            "Filled background",
            "Bordered outline"
        ]
    },
    {
        "q": "What is form wizard pattern?",
        "type": "mcq",
        "o": [
            "Multi-step form with navigation",
            "Single form",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "mat-stepper helps create form wizards.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<mat-stepper [linear]=\"true\"><mat-step [stepControl]=\"personalForm\">Personal</mat-step><mat-step [stepControl]=\"addressForm\">Address</mat-step></mat-stepper>",
        "o": [
            "Two-step form wizard",
            "Single form",
            "Tab view",
            "Accordion"
        ]
    },
    {
        "q": "stepControl links step to _____ for validation.",
        "type": "fill_blank",
        "answers": [
            "FormGroup"
        ],
        "other_options": [
            "FormControl",
            "FormArray",
            "Validator"
        ]
    },
    {
        "q": "Match stepper properties:",
        "type": "match",
        "left": [
            "linear",
            "stepControl",
            "optional",
            "editable"
        ],
        "right": [
            "Must complete in order",
            "Form validation",
            "Can skip step",
            "Can return to step"
        ]
    },
    {
        "q": "What is form debouncing?",
        "type": "mcq",
        "o": [
            "Delaying processing of rapid changes",
            "Immediate processing",
            "Validation delay",
            "Submit delay"
        ]
    },
    {
        "q": "debounceTime reduces unnecessary processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this optimize?",
        "type": "mcq",
        "c": "search.valueChanges.pipe(debounceTime(300)).subscribe(val => this.performSearch(val));",
        "o": [
            "Reduces API calls during typing",
            "Increases calls",
            "Immediate search",
            "No optimization"
        ]
    },
    {
        "q": "debounceTime waits for _____ after last change.",
        "type": "fill_blank",
        "answers": [
            "specified milliseconds"
        ],
        "other_options": [
            "immediate",
            "1 second",
            "form submission"
        ]
    },
    {
        "q": "Match optimization operators:",
        "type": "match",
        "left": [
            "debounceTime",
            "throttleTime",
            "distinctUntilChanged",
            "filter"
        ],
        "right": [
            "Wait after last",
            "Limit rate",
            "Ignore same values",
            "Conditional emit"
        ]
    },
    {
        "q": "What is form caching?",
        "type": "mcq",
        "o": [
            "Preserving form values across navigation",
            "Clearing forms",
            "Resetting forms",
            "Validating forms"
        ]
    },
    {
        "q": "Services can cache form data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this pattern enable?",
        "type": "mcq",
        "c": "ngOnDestroy() { this.formCache.save(this.form.value); } ngOnInit() { this.form.patchValue(this.formCache.get()); }",
        "o": [
            "Restores form when returning to page",
            "Clears form",
            "Validates form",
            "Submits form"
        ]
    },
    {
        "q": "Form caching preserves user _____ across navigation.",
        "type": "fill_blank",
        "answers": [
            "input"
        ],
        "other_options": [
            "validation",
            "errors",
            "state"
        ]
    },
    {
        "q": "Match caching strategies:",
        "type": "match",
        "left": [
            "Service cache",
            "localStorage",
            "sessionStorage",
            "Route state"
        ],
        "right": [
            "Memory during session",
            "Persistent storage",
            "Tab-specific",
            "Navigation state"
        ]
    },
    {
        "q": "What is form dirty checking?",
        "type": "mcq",
        "o": [
            "Detecting if form has unsaved changes",
            "Validation check",
            "Error check",
            "Submit check"
        ]
    },
    {
        "q": "canDeactivate guard uses dirty checking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this prevent?",
        "type": "mcq",
        "c": "canDeactivate() { return !this.form.dirty || confirm('Discard changes?'); }",
        "o": [
            "Losing unsaved form data",
            "All navigation",
            "Dirty forms",
            "Clean forms"
        ]
    },
    {
        "q": "form.dirty is true when _____ has changed.",
        "type": "fill_blank",
        "answers": [
            "value"
        ],
        "other_options": [
            "validation",
            "state",
            "error"
        ]
    },
    {
        "q": "Rearrange dirty check flow:",
        "type": "rearrange",
        "words": [
            "User edits form",
            "form.dirty becomes true",
            "User navigates away",
            "Guard checks dirty",
            "Confirm or stay"
        ]
    },
    {
        "q": "What is conditional validation?",
        "type": "mcq",
        "o": [
            "Validation rules that change based on conditions",
            "Static validation",
            "Always required",
            "Never required"
        ]
    },
    {
        "q": "Validators can be added or removed dynamically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "if (hasCompany) { form.get('companyName').addValidators(Validators.required); } else { form.get('companyName').clearValidators(); } form.get('companyName').updateValueAndValidity();",
        "o": [
            "Require company name only when hasCompany is true",
            "Always require company",
            "Never require company",
            "Validate both cases"
        ]
    },
    {
        "q": "updateValueAndValidity is required after _____ validators.",
        "type": "fill_blank",
        "answers": [
            "changing"
        ],
        "other_options": [
            "adding",
            "checking",
            "running"
        ]
    },
    {
        "q": "Match conditional patterns:",
        "type": "match",
        "left": [
            "addValidators",
            "removeValidators",
            "clearValidators",
            "setValidators"
        ],
        "right": [
            "Add to existing",
            "Remove specific",
            "Remove all",
            "Replace all"
        ]
    },
    {
        "q": "What is dependent field validation?",
        "type": "mcq",
        "o": [
            "Field validated based on another field's value",
            "Independent validation",
            "Static validation",
            "No validation"
        ]
    },
    {
        "q": "valueChanges can trigger dependent validation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this setup enable?",
        "type": "mcq",
        "c": "form.get('type').valueChanges.subscribe(type => { if (type === 'business') this.addBusinessValidators(); else this.addPersonalValidators(); });",
        "o": [
            "Different validation based on selected type",
            "Same validation always",
            "No validation",
            "Type validation only"
        ]
    },
    {
        "q": "Dependent validation creates _____ between fields.",
        "type": "fill_blank",
        "answers": [
            "relationships"
        ],
        "other_options": [
            "errors",
            "bindings",
            "links"
        ]
    },
    {
        "q": "Rearrange dependent validation:",
        "type": "rearrange",
        "words": [
            "Subscribe to trigger field",
            "Get trigger value",
            "Update dependent validators",
            "Call updateValueAndValidity",
            "Re-validate dependent field"
        ]
    },
    {
        "q": "What is file input in forms?",
        "type": "mcq",
        "o": [
            "Handling file uploads in forms",
            "Text input",
            "Number input",
            "Select input"
        ]
    },
    {
        "q": "File inputs require custom handling in reactive forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this handle?",
        "type": "mcq",
        "c": "<input type=\"file\" (change)=\"onFileSelected($event)\">",
        "o": [
            "File selection event",
            "Text change",
            "Form submission",
            "Validation"
        ]
    },
    {
        "q": "File data is accessed via event.target._____.",
        "type": "fill_blank",
        "answers": [
            "files"
        ],
        "other_options": [
            "value",
            "data",
            "file"
        ]
    },
    {
        "q": "Match file handling:",
        "type": "match",
        "left": [
            "event.target.files",
            "FileReader",
            "FormData",
            "accept attribute"
        ],
        "right": [
            "Get selected files",
            "Read file content",
            "Upload format",
            "Filter file types"
        ]
    },
    {
        "q": "What is file validation?",
        "type": "mcq",
        "o": [
            "Validating file type, size, and properties",
            "Text validation",
            "Number validation",
            "Email validation"
        ]
    },
    {
        "q": "Files can be validated for size and type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this validator check?",
        "type": "mcq",
        "c": "function maxFileSize(maxBytes) { return (control) => control.value?.size > maxBytes ? { maxSize: true } : null; }",
        "o": [
            "File exceeds maximum size",
            "File type",
            "File name",
            "File count"
        ]
    },
    {
        "q": "File size is measured in _____.",
        "type": "fill_blank",
        "answers": [
            "bytes"
        ],
        "other_options": [
            "kilobytes",
            "megabytes",
            "bits"
        ]
    },
    {
        "q": "Match file validations:",
        "type": "match",
        "left": [
            "size",
            "type",
            "name",
            "lastModified"
        ],
        "right": [
            "File bytes",
            "MIME type",
            "File name",
            "Modification date"
        ]
    },
    {
        "q": "What is form internationalization?",
        "type": "mcq",
        "o": [
            "Supporting multiple languages in forms",
            "Form styling",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "Validation messages can be internationalized.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "<mat-error *ngIf=\"control.hasError('required')\">{{ 'validation.required' | translate }}</mat-error>",
        "o": [
            "Translated error messages",
            "Static messages",
            "No messages",
            "Default messages"
        ]
    },
    {
        "q": "ngx-translate uses _____ pipe for translations.",
        "type": "fill_blank",
        "answers": [
            "translate"
        ],
        "other_options": [
            "i18n",
            "lang",
            "text"
        ]
    },
    {
        "q": "Match i18n approaches:",
        "type": "match",
        "left": [
            "Built-in i18n",
            "ngx-translate",
            "Transloco",
            "None"
        ],
        "right": [
            "Compile-time",
            "Runtime",
            "Runtime modern",
            "Hardcoded"
        ]
    },
    {
        "q": "What is form performance?",
        "type": "mcq",
        "o": [
            "Optimizing form responsiveness",
            "Form styling",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "Large forms can impact performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this optimize?",
        "type": "mcq",
        "c": "{ updateOn: 'blur' }",
        "o": [
            "Reduces validation frequency",
            "Increases validation",
            "Disables validation",
            "No effect"
        ]
    },
    {
        "q": "updateOn: 'blur' validates on _____ instead of change.",
        "type": "fill_blank",
        "answers": [
            "field exit"
        ],
        "other_options": [
            "keystroke",
            "submit",
            "focus"
        ]
    },
    {
        "q": "Match performance optimizations:",
        "type": "match",
        "left": [
            "updateOn: blur",
            "debounceTime",
            "OnPush",
            "trackBy"
        ],
        "right": [
            "Reduce validation",
            "Reduce emissions",
            "Change detection",
            "List rendering"
        ]
    },
    {
        "q": "What is form lazy loading?",
        "type": "mcq",
        "o": [
            "Loading form controls on demand",
            "Lazy routes",
            "Lazy modules",
            "Eager loading"
        ]
    },
    {
        "q": "Complex forms can be split into sections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern does this implement?",
        "type": "mcq",
        "c": "*ngIf=\"showAdvanced\" [formGroup]=\"advancedForm\"",
        "o": [
            "Load advanced form only when shown",
            "Always load",
            "Never load",
            "Load on submit"
        ]
    },
    {
        "q": "Lazy form sections reduce _____ form complexity.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "final",
            "total",
            "submitted"
        ]
    },
    {
        "q": "Rearrange lazy form loading:",
        "type": "rearrange",
        "words": [
            "Show basic form first",
            "User expands section",
            "Create additional FormGroup",
            "Bind to template",
            "Validate on demand"
        ]
    },
    {
        "q": "What is form immutability?",
        "type": "mcq",
        "o": [
            "Creating new form instances instead of mutating",
            "Mutable forms",
            "Static forms",
            "Dynamic forms"
        ]
    },
    {
        "q": "Immutable patterns improve change detection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this pattern promote?",
        "type": "mcq",
        "c": "form = this.fb.group({ ...existingValues, newField: '' });",
        "o": [
            "Creating new form with spread values",
            "Mutating existing form",
            "Deleting form",
            "No change"
        ]
    },
    {
        "q": "Spread operator creates _____ copy.",
        "type": "fill_blank",
        "answers": [
            "shallow"
        ],
        "other_options": [
            "deep",
            "reference",
            "no"
        ]
    },
    {
        "q": "Match immutability patterns:",
        "type": "match",
        "left": [
            "Spread operator",
            "Object.assign",
            "structuredClone",
            "JSON parse/stringify"
        ],
        "right": [
            "Shallow copy",
            "Shallow copy",
            "Deep clone",
            "Deep clone (basic)"
        ]
    },
    {
        "q": "What is form state management?",
        "type": "mcq",
        "o": [
            "Managing form state with external stores",
            "Internal state",
            "No state",
            "Static state"
        ]
    },
    {
        "q": "NgRx can manage form state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What benefit does this provide?",
        "type": "mcq",
        "c": "// Store form values in NgRx state",
        "o": [
            "Centralized state with time travel",
            "Local state only",
            "No benefits",
            "Slower performance"
        ]
    },
    {
        "q": "External state stores enable _____ debugging.",
        "type": "fill_blank",
        "answers": [
            "time travel"
        ],
        "other_options": [
            "instant",
            "slow",
            "no"
        ]
    },
    {
        "q": "Match state approaches:",
        "type": "match",
        "left": [
            "Component state",
            "Service state",
            "NgRx/NGRX",
            "Signal Store"
        ],
        "right": [
            "Local to component",
            "Shared across",
            "Redux pattern",
            "Signal-based"
        ]
    },
    {
        "q": "What is form error aggregation?",
        "type": "mcq",
        "o": [
            "Collecting all errors for display",
            "Single error",
            "No errors",
            "Error logging"
        ]
    },
    {
        "q": "Error summaries improve user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this function do?",
        "type": "mcq",
        "c": "getAllErrors(form) { const errors = []; Object.keys(form.controls).forEach(key => { if (form.get(key).errors) errors.push({ field: key, errors: form.get(key).errors }); }); return errors; }",
        "o": [
            "Collects all form errors into array",
            "Clears errors",
            "Sets errors",
            "Validates form"
        ]
    },
    {
        "q": "Error aggregation is useful for _____ displays.",
        "type": "fill_blank",
        "answers": [
            "summary"
        ],
        "other_options": [
            "inline",
            "tooltip",
            "modal"
        ]
    },
    {
        "q": "Match error display patterns:",
        "type": "match",
        "left": [
            "Inline errors",
            "Summary block",
            "Toast notification",
            "Dialog"
        ],
        "right": [
            "Near field",
            "Top of form",
            "Temporary message",
            "Blocking popup"
        ]
    },
    {
        "q": "What is form field focus management?",
        "type": "mcq",
        "o": [
            "Programmatically controlling input focus",
            "Visual focus",
            "Click handling",
            "Hover effects"
        ]
    },
    {
        "q": "Focus can be set programmatically on errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this improve?",
        "type": "mcq",
        "c": "if (form.invalid) { const firstInvalid = document.querySelector('.ng-invalid'); firstInvalid?.focus(); }",
        "o": [
            "Focus first invalid field on submit",
            "Remove focus",
            "Focus all fields",
            "No focus"
        ]
    },
    {
        "q": "querySelector('.ng-invalid') finds first _____ element.",
        "type": "fill_blank",
        "answers": [
            "invalid"
        ],
        "other_options": [
            "valid",
            "touched",
            "dirty"
        ]
    },
    {
        "q": "Rearrange focus management:",
        "type": "rearrange",
        "words": [
            "Check form validity",
            "Find invalid controls",
            "Get DOM element",
            "Call focus method",
            "Scroll into view"
        ]
    },
    {
        "q": "What is form keyboard shortcuts?",
        "type": "mcq",
        "o": [
            "Keyboard-driven form interactions",
            "Mouse only",
            "Touch only",
            "Voice input"
        ]
    },
    {
        "q": "Enter key can be bound to submit.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "@HostListener('keydown.enter') onEnter() { if (this.form.valid) this.submit(); }",
        "o": [
            "Submit form on Enter key",
            "Clear form",
            "Reset form",
            "Cancel form"
        ]
    },
    {
        "q": "@HostListener listens for _____ on host element.",
        "type": "fill_blank",
        "answers": [
            "events"
        ],
        "other_options": [
            "values",
            "changes",
            "properties"
        ]
    },
    {
        "q": "Match keyboard handling:",
        "type": "match",
        "left": [
            "Enter",
            "Escape",
            "Tab",
            "Ctrl+S"
        ],
        "right": [
            "Submit",
            "Cancel/Close",
            "Next field",
            "Save shortcut"
        ]
    },
    {
        "q": "What is form submission feedback?",
        "type": "mcq",
        "o": [
            "Indicating submission status to users",
            "Silent submission",
            "No feedback",
            "Error only"
        ]
    },
    {
        "q": "Loading states improve user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "<button [disabled]=\"isSubmitting\">{{ isSubmitting ? 'Saving...' : 'Save' }}</button>",
        "o": [
            "Visual feedback during submission",
            "Always disabled",
            "No feedback",
            "Error message"
        ]
    },
    {
        "q": "Disabling submit during processing prevents _____ submissions.",
        "type": "fill_blank",
        "answers": [
            "duplicate"
        ],
        "other_options": [
            "valid",
            "all",
            "first"
        ]
    },
    {
        "q": "Match submission states:",
        "type": "match",
        "left": [
            "Idle",
            "Submitting",
            "Success",
            "Error"
        ],
        "right": [
            "Ready to submit",
            "In progress",
            "Show confirmation",
            "Show retry"
        ]
    },
    {
        "q": "What is form reset confirmation?",
        "type": "mcq",
        "o": [
            "Asking before clearing form data",
            "Immediate reset",
            "No reset",
            "Auto reset"
        ]
    },
    {
        "q": "Confirmation prevents accidental data loss.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this implement?",
        "type": "mcq",
        "c": "onReset() { if (confirm('Clear all data?')) this.form.reset(); }",
        "o": [
            "Confirmation before reset",
            "Immediate reset",
            "No reset",
            "Silent reset"
        ]
    },
    {
        "q": "confirm() returns _____ if user clicks OK.",
        "type": "fill_blank",
        "answers": [
            "true"
        ],
        "other_options": [
            "false",
            "null",
            "undefined"
        ]
    },
    {
        "q": "Match confirmation patterns:",
        "type": "match",
        "left": [
            "Browser confirm",
            "Material dialog",
            "Snackbar",
            "Inline"
        ],
        "right": [
            "Native popup",
            "Styled modal",
            "Temporary message",
            "Same page"
        ]
    },
    {
        "q": "What is form value transformation?",
        "type": "mcq",
        "o": [
            "Converting form values before use",
            "Direct values",
            "No transformation",
            "Validation"
        ]
    },
    {
        "q": "Values can be transformed on read or write.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this transform?",
        "type": "mcq",
        "c": "const values = { ...form.value, date: form.value.date?.toISOString() };",
        "o": [
            "Date object to ISO string",
            "String to date",
            "No transformation",
            "Number to string"
        ]
    },
    {
        "q": "toISOString converts Date to _____ format.",
        "type": "fill_blank",
        "answers": [
            "ISO 8601"
        ],
        "other_options": [
            "Unix timestamp",
            "Local string",
            "JSON"
        ]
    },
    {
        "q": "Match transformations:",
        "type": "match",
        "left": [
            "trim()",
            "toLowerCase()",
            "parseInt()",
            "toISOString()"
        ],
        "right": [
            "Remove whitespace",
            "Lowercase text",
            "String to number",
            "Date to string"
        ]
    },
    {
        "q": "What is form serialization?",
        "type": "mcq",
        "o": [
            "Converting form to format for transmission",
            "Form display",
            "Form validation",
            "Form creation"
        ]
    },
    {
        "q": "JSON.stringify serializes form values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What format does this create?",
        "type": "mcq",
        "c": "const body = JSON.stringify(form.value)",
        "o": [
            "JSON string",
            "FormData",
            "URL encoded",
            "XML"
        ]
    },
    {
        "q": "FormData is used for _____ uploads.",
        "type": "fill_blank",
        "answers": [
            "file"
        ],
        "other_options": [
            "text",
            "JSON",
            "number"
        ]
    },
    {
        "q": "Match serialization formats:",
        "type": "match",
        "left": [
            "JSON",
            "FormData",
            "URLSearchParams",
            "XML"
        ],
        "right": [
            "Object format",
            "Multipart",
            "Query string",
            "Document format"
        ]
    },
    {
        "q": "What is server-side validation response?",
        "type": "mcq",
        "o": [
            "Handling validation errors from server",
            "Client validation",
            "No validation",
            "Browser validation"
        ]
    },
    {
        "q": "Server errors should be displayed to users.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this handle?",
        "type": "mcq",
        "c": "api.submit(data).subscribe({ error: err => this.form.get('email').setErrors({ serverError: err.message }) });",
        "o": [
            "Server validation errors on controls",
            "Client errors",
            "Network errors",
            "No errors"
        ]
    },
    {
        "q": "setErrors allows setting _____ validation errors.",
        "type": "fill_blank",
        "answers": [
            "custom"
        ],
        "other_options": [
            "built-in",
            "default",
            "standard"
        ]
    },
    {
        "q": "Rearrange server error handling:",
        "type": "rearrange",
        "words": [
            "Submit to server",
            "Receive error response",
            "Parse error fields",
            "Call setErrors on controls",
            "Display error messages"
        ]
    },
    {
        "q": "What is form architecture?",
        "type": "mcq",
        "o": [
            "Organizing forms for maintainability",
            "Form styling",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "Feature modules should contain related forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern does this follow?",
        "type": "mcq",
        "c": "// user-forms/user-profile-form.component.ts\n// user-forms/user-settings-form.component.ts",
        "o": [
            "Feature-based form organization",
            "Random organization",
            "Single file",
            "No organization"
        ]
    },
    {
        "q": "Forms should be organized by _____.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "alphabet",
            "size",
            "date"
        ]
    },
    {
        "q": "Match organization patterns:",
        "type": "match",
        "left": [
            "Feature-based",
            "Type-based",
            "Shared",
            "Lazy-loaded"
        ],
        "right": [
            "By domain",
            "By form type",
            "Common forms",
            "On-demand"
        ]
    },
    {
        "q": "What is form reusability?",
        "type": "mcq",
        "o": [
            "Creating forms that work in multiple contexts",
            "Single-use forms",
            "Duplicate forms",
            "Static forms"
        ]
    },
    {
        "q": "Form components can be configured via inputs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "@Input() mode: 'create' | 'edit'; @Input() initialData: User;",
        "o": [
            "Same form for create and edit",
            "Only create",
            "Only edit",
            "No reuse"
        ]
    },
    {
        "q": "Reusable forms reduce code _____.",
        "type": "fill_blank",
        "answers": [
            "duplication"
        ],
        "other_options": [
            "quality",
            "coverage",
            "testing"
        ]
    },
    {
        "q": "Match reusability patterns:",
        "type": "match",
        "left": [
            "Input config",
            "Sub-forms",
            "Form factories",
            "Base classes"
        ],
        "right": [
            "External configuration",
            "Composable parts",
            "Dynamic creation",
            "Inheritance"
        ]
    },
    {
        "q": "What is form composition?",
        "type": "mcq",
        "o": [
            "Building forms from smaller components",
            "Single large form",
            "Form inheritance",
            "Static forms"
        ]
    },
    {
        "q": "ControlContainer enables nested form components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this inject?",
        "type": "mcq",
        "c": "constructor(@Host() @SkipSelf() private controlContainer: ControlContainer) {}",
        "o": [
            "Parent FormGroup from host",
            "New FormGroup",
            "FormControl",
            "FormArray"
        ]
    },
    {
        "q": "ControlContainer allows _____ form components.",
        "type": "fill_blank",
        "answers": [
            "nested"
        ],
        "other_options": [
            "flat",
            "isolated",
            "independent"
        ]
    },
    {
        "q": "Match composition tokens:",
        "type": "match",
        "left": [
            "ControlContainer",
            "FormGroupDirective",
            "NgForm",
            "@Host()"
        ],
        "right": [
            "Parent container",
            "Reactive parent",
            "Template parent",
            "Limit search scope"
        ]
    },
    {
        "q": "What is form factory pattern?",
        "type": "mcq",
        "o": [
            "Service that creates forms dynamically",
            "Static forms",
            "Template forms",
            "Manual forms"
        ]
    },
    {
        "q": "Factory services centralize form creation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this factory do?",
        "type": "mcq",
        "c": "createUserForm(user?: User) { return this.fb.group({ name: [user?.name ?? '', Validators.required], email: [user?.email ?? ''] }); }",
        "o": [
            "Creates user form with optional initial data",
            "Validates user",
            "Submits user",
            "Deletes user"
        ]
    },
    {
        "q": "Factories accept _____ data for population.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "validated",
            "submitted",
            "final"
        ]
    },
    {
        "q": "Rearrange factory usage:",
        "type": "rearrange",
        "words": [
            "Inject factory service",
            "Call factory method",
            "Receive FormGroup",
            "Bind to template",
            "Handle submission"
        ]
    },
    {
        "q": "What is form validation service?",
        "type": "mcq",
        "o": [
            "Service providing reusable validators",
            "Form builder",
            "Form factory",
            "Form control"
        ]
    },
    {
        "q": "Validation services centralize validation logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "class ValidationService { get passwordValidators() { return [Validators.required, Validators.minLength(8), this.hasUppercase]; } }",
        "o": [
            "Reusable password validation rules",
            "Single validator",
            "No validation",
            "Form creation"
        ]
    },
    {
        "q": "Validation services promote _____.",
        "type": "fill_blank",
        "answers": [
            "consistency"
        ],
        "other_options": [
            "duplication",
            "complexity",
            "isolation"
        ]
    },
    {
        "q": "Match validation patterns:",
        "type": "match",
        "left": [
            "Service validators",
            "Inline validators",
            "Directive validators",
            "Pipe validators"
        ],
        "right": [
            "Reusable service",
            "Component-specific",
            "Template attribute",
            "Not applicable"
        ]
    },
    {
        "q": "What is form error message service?",
        "type": "mcq",
        "o": [
            "Service providing centralized error messages",
            "Error handler",
            "Error logger",
            "Error validator"
        ]
    },
    {
        "q": "Error messages should be consistent across forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this service provide?",
        "type": "mcq",
        "c": "getErrorMessage(control: AbstractControl) { if (control.hasError('required')) return 'Field is required'; if (control.hasError('email')) return 'Invalid email'; return ''; }",
        "o": [
            "Consistent error messages for validators",
            "Random messages",
            "No messages",
            "Control names"
        ]
    },
    {
        "q": "Centralized messages improve _____.",
        "type": "fill_blank",
        "answers": [
            "maintainability"
        ],
        "other_options": [
            "complexity",
            "duplication",
            "confusion"
        ]
    },
    {
        "q": "Match error patterns:",
        "type": "match",
        "left": [
            "Service messages",
            "Inline messages",
            "i18n messages",
            "Dynamic messages"
        ],
        "right": [
            "Centralized",
            "Template-specific",
            "Translated",
            "Runtime generated"
        ]
    },
    {
        "q": "What is form integration testing?",
        "type": "mcq",
        "o": [
            "Testing form with template interaction",
            "Unit testing",
            "E2E testing",
            "Manual testing"
        ]
    },
    {
        "q": "Integration tests verify form-template binding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test?",
        "type": "mcq",
        "c": "it('should bind input to control', () => { const input = fixture.debugElement.query(By.css('input')); input.nativeElement.value = 'test'; input.nativeElement.dispatchEvent(new Event('input')); expect(component.form.get('name').value).toBe('test'); });",
        "o": [
            "Input value flows to form control",
            "Control value flows to input",
            "No binding",
            "Validation"
        ]
    },
    {
        "q": "dispatchEvent simulates user _____ in tests.",
        "type": "fill_blank",
        "answers": [
            "interactions"
        ],
        "other_options": [
            "creation",
            "deletion",
            "validation"
        ]
    },
    {
        "q": "Match test types:",
        "type": "match",
        "left": [
            "Unit test",
            "Integration test",
            "E2E test",
            "Snapshot test"
        ],
        "right": [
            "Logic only",
            "With template",
            "Full browser",
            "UI state"
        ]
    },
    {
        "q": "What is form E2E testing?",
        "type": "mcq",
        "o": [
            "Testing forms in real browser",
            "Unit testing",
            "Integration testing",
            "Mock testing"
        ]
    },
    {
        "q": "E2E tests validate complete user flows.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What framework is this?",
        "type": "mcq",
        "c": "await page.fill('[formControlName=\"email\"]', 'test@test.com'); await page.click('button[type=\"submit\"]');",
        "o": [
            "Playwright E2E test",
            "Jest unit test",
            "Jasmine test",
            "Karma test"
        ]
    },
    {
        "q": "E2E tests run in real _____.",
        "type": "fill_blank",
        "answers": [
            "browsers"
        ],
        "other_options": [
            "terminals",
            "editors",
            "consoles"
        ]
    },
    {
        "q": "Match E2E frameworks:",
        "type": "match",
        "left": [
            "Cypress",
            "Playwright",
            "Protractor"
        ],
        "right": [
            "JavaScript-focused",
            "Multi-browser",
            "Deprecated"
        ]
    },
    {
        "q": "What is form mock testing?",
        "type": "mcq",
        "o": [
            "Testing with simulated services",
            "Real API testing",
            "No testing",
            "Manual testing"
        ]
    },
    {
        "q": "Mocks isolate form logic from dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this mock?",
        "type": "mcq",
        "c": "const mockHttp = jasmine.createSpyObj('HttpClient', ['post']); mockHttp.post.and.returnValue(of({ success: true }));",
        "o": [
            "HTTP service for form submission",
            "Form control",
            "Validator",
            "Template"
        ]
    },
    {
        "q": "Mocks return _____ responses.",
        "type": "fill_blank",
        "answers": [
            "predictable"
        ],
        "other_options": [
            "random",
            "real",
            "slow"
        ]
    },
    {
        "q": "Match mock patterns:",
        "type": "match",
        "left": [
            "Spy",
            "Stub",
            "Mock",
            "Fake"
        ],
        "right": [
            "Track calls",
            "Simple return",
            "Verify behavior",
            "Working implementation"
        ]
    },
    {
        "q": "What is form snapshot testing?",
        "type": "mcq",
        "o": [
            "Comparing rendered output to baseline",
            "Unit testing",
            "Integration testing",
            "E2E testing"
        ]
    },
    {
        "q": "Snapshots detect unintended UI changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this verify?",
        "type": "mcq",
        "c": "expect(fixture).toMatchSnapshot();",
        "o": [
            "Component output matches saved snapshot",
            "Form is valid",
            "Form has values",
            "Form submits"
        ]
    },
    {
        "q": "Failed snapshots require review for _____ changes.",
        "type": "fill_blank",
        "answers": [
            "intentional"
        ],
        "other_options": [
            "random",
            "automatic",
            "no"
        ]
    },
    {
        "q": "Match test assertions:",
        "type": "match",
        "left": [
            "toMatchSnapshot",
            "toBe",
            "toEqual",
            "toContain"
        ],
        "right": [
            "UI comparison",
            "Exact match",
            "Deep equality",
            "Array/string check"
        ]
    },
    {
        "q": "What is form accessibility testing?",
        "type": "mcq",
        "o": [
            "Testing forms for accessibility compliance",
            "Unit testing",
            "Performance testing",
            "Security testing"
        ]
    },
    {
        "q": "axe-core can automate accessibility testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test for?",
        "type": "mcq",
        "c": "it('should be accessible', async () => { const results = await axe(fixture.nativeElement); expect(results.violations).toHaveLength(0); });",
        "o": [
            "WCAG accessibility violations",
            "Performance issues",
            "Security issues",
            "Styling issues"
        ]
    },
    {
        "q": "axe-core checks _____ compliance.",
        "type": "fill_blank",
        "answers": [
            "WCAG"
        ],
        "other_options": [
            "performance",
            "security",
            "styling"
        ]
    },
    {
        "q": "Match accessibility tests:",
        "type": "match",
        "left": [
            "Label association",
            "Color contrast",
            "Focus order",
            "Error announcement"
        ],
        "right": [
            "for/id match",
            "Readable colors",
            "Logical navigation",
            "Screen reader"
        ]
    },
    {
        "q": "What is form migration?",
        "type": "mcq",
        "o": [
            "Upgrading forms to newer patterns",
            "Creating forms",
            "Deleting forms",
            "Testing forms"
        ]
    },
    {
        "q": "Template-driven can be migrated to reactive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is this migration?",
        "type": "mcq",
        "c": "// Before: <input [(ngModel)]=\"name\">\n// After: <input [formControl]=\"nameControl\">",
        "o": [
            "Template-driven to reactive forms",
            "Reactive to template",
            "No change",
            "Form deletion"
        ]
    },
    {
        "q": "Reactive forms provide better _____.",
        "type": "fill_blank",
        "answers": [
            "testability"
        ],
        "other_options": [
            "styling",
            "simplicity",
            "templates"
        ]
    },
    {
        "q": "Rearrange migration steps:",
        "type": "rearrange",
        "words": [
            "Import ReactiveFormsModule",
            "Create FormControl/FormGroup",
            "Replace ngModel with formControl",
            "Update validation",
            "Test thoroughly"
        ]
    },
    {
        "q": "What is form security?",
        "type": "mcq",
        "o": [
            "Protecting forms from vulnerabilities",
            "Form styling",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "Form inputs should be sanitized.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What security does this address?",
        "type": "mcq",
        "c": "this.sanitizer.sanitize(SecurityContext.HTML, input)",
        "o": [
            "XSS prevention via HTML sanitization",
            "CSRF protection",
            "SQL injection",
            "No protection"
        ]
    },
    {
        "q": "DomSanitizer helps prevent _____ attacks.",
        "type": "fill_blank",
        "answers": [
            "XSS"
        ],
        "other_options": [
            "CSRF",
            "SQL",
            "DDoS"
        ]
    },
    {
        "q": "Match security measures:",
        "type": "match",
        "left": [
            "Sanitization",
            "CSRF tokens",
            "Input validation",
            "HTTPS"
        ],
        "right": [
            "Remove dangerous content",
            "Request verification",
            "Data format check",
            "Encryption in transit"
        ]
    },
    {
        "q": "What is form CSRF protection?",
        "type": "mcq",
        "o": [
            "Preventing cross-site request forgery",
            "XSS protection",
            "SQL protection",
            "No protection"
        ]
    },
    {
        "q": "CSRF tokens verify request origin.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does HttpClientXsrfModule provide?",
        "type": "mcq",
        "o": [
            "Automatic CSRF token handling",
            "XSS protection",
            "Encryption",
            "Caching"
        ]
    },
    {
        "q": "CSRF tokens are sent via _____ headers.",
        "type": "fill_blank",
        "answers": [
            "HTTP"
        ],
        "other_options": [
            "body",
            "URL",
            "cookie"
        ]
    },
    {
        "q": "Match security configurations:",
        "type": "match",
        "left": [
            "withXsrfConfiguration",
            "withInterceptorsFromDi",
            "withNoXsrfProtection"
        ],
        "right": [
            "Custom CSRF",
            "DI interceptors",
            "Disable CSRF"
        ]
    },
    {
        "q": "What is form rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting submission frequency",
            "Unlimited submissions",
            "Form validation",
            "Form styling"
        ]
    },
    {
        "q": "Rate limiting prevents spam submissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this implement?",
        "type": "mcq",
        "c": "submit() { if (Date.now() - this.lastSubmit < 5000) return; this.lastSubmit = Date.now(); this.sendForm(); }",
        "o": [
            "5-second cooldown between submissions",
            "Immediate submission",
            "No submission",
            "Validation"
        ]
    },
    {
        "q": "Cooldown periods prevent _____ submissions.",
        "type": "fill_blank",
        "answers": [
            "rapid"
        ],
        "other_options": [
            "valid",
            "first",
            "all"
        ]
    },
    {
        "q": "Match protection patterns:",
        "type": "match",
        "left": [
            "Client cooldown",
            "Server rate limit",
            "CAPTCHA",
            "Honeypot"
        ],
        "right": [
            "Frontend delay",
            "Backend limit",
            "Human verification",
            "Bot detection"
        ]
    },
    {
        "q": "What is form analytics?",
        "type": "mcq",
        "o": [
            "Tracking form usage and behavior",
            "Form validation",
            "Form styling",
            "Form security"
        ]
    },
    {
        "q": "Analytics help improve form UX.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can analytics track?",
        "type": "mcq",
        "c": "// Track field focus, time spent, abandonment",
        "o": [
            "User interaction patterns",
            "Form structure",
            "Validation rules",
            "Styling"
        ]
    },
    {
        "q": "Form abandonment rate indicates _____ issues.",
        "type": "fill_blank",
        "answers": [
            "UX"
        ],
        "other_options": [
            "security",
            "validation",
            "styling"
        ]
    },
    {
        "q": "Match analytics metrics:",
        "type": "match",
        "left": [
            "Completion rate",
            "Field time",
            "Error rate",
            "Abandonment"
        ],
        "right": [
            "Successfully submitted",
            "Time per field",
            "Validation failures",
            "Left incomplete"
        ]
    },
    {
        "q": "What is form A/B testing?",
        "type": "mcq",
        "o": [
            "Comparing form variations for effectiveness",
            "Unit testing",
            "E2E testing",
            "Security testing"
        ]
    },
    {
        "q": "A/B testing helps optimize conversions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can be tested?",
        "type": "mcq",
        "c": "// Version A: Single-page form\n// Version B: Multi-step wizard",
        "o": [
            "Form layout and structure",
            "Validation rules",
            "Data types",
            "API endpoints"
        ]
    },
    {
        "q": "A/B tests compare _____ rates.",
        "type": "fill_blank",
        "answers": [
            "conversion"
        ],
        "other_options": [
            "error",
            "validation",
            "loading"
        ]
    },
    {
        "q": "Match A/B test elements:",
        "type": "match",
        "left": [
            "Field order",
            "Button text",
            "Form layout",
            "Validation timing"
        ],
        "right": [
            "Sequence testing",
            "CTA testing",
            "UX testing",
            "Error display"
        ]
    },
    {
        "q": "What is form progressive disclosure?",
        "type": "mcq",
        "o": [
            "Revealing fields based on user actions",
            "Showing all fields",
            "Hiding all fields",
            "Static forms"
        ]
    },
    {
        "q": "Progressive disclosure reduces cognitive load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this implement?",
        "type": "mcq",
        "c": "<div *ngIf=\"showBusinessFields\"><input formControlName=\"companyName\"></div>",
        "o": [
            "Shows business fields only when needed",
            "Always shows",
            "Never shows",
            "Validates always"
        ]
    },
    {
        "q": "Progressive disclosure shows _____ complexity.",
        "type": "fill_blank",
        "answers": [
            "only necessary"
        ],
        "other_options": [
            "all",
            "no",
            "maximum"
        ]
    },
    {
        "q": "Match disclosure patterns:",
        "type": "match",
        "left": [
            "Conditional fields",
            "Expandable sections",
            "Wizard steps",
            "Accordion"
        ],
        "right": [
            "Based on selection",
            "User-triggered",
            "Sequential reveal",
            "Collapsible groups"
        ]
    },
    {
        "q": "What is form microinteractions?",
        "type": "mcq",
        "o": [
            "Small animations for feedback",
            "Large animations",
            "No animations",
            "Form validation"
        ]
    },
    {
        "q": "Microinteractions improve perceived quality.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }",
        "o": [
            "Error feedback animation",
            "Success animation",
            "Loading animation",
            "No animation"
        ]
    },
    {
        "q": "Shake animation indicates _____.",
        "type": "fill_blank",
        "answers": [
            "validation error"
        ],
        "other_options": [
            "success",
            "loading",
            "focus"
        ]
    },
    {
        "q": "Match microinteraction purposes:",
        "type": "match",
        "left": [
            "Shake",
            "Fade",
            "Pulse",
            "Slide"
        ],
        "right": [
            "Error feedback",
            "Show/hide",
            "Attention",
            "Transition"
        ]
    },
    {
        "q": "What is form responsive design?",
        "type": "mcq",
        "o": [
            "Adapting forms to different screen sizes",
            "Fixed layout",
            "Desktop only",
            "Mobile only"
        ]
    },
    {
        "q": "Forms should work on all devices.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "@media (max-width: 600px) { .form-row { flex-direction: column; } }",
        "o": [
            "Stacked layout on mobile",
            "Always horizontal",
            "Always hidden",
            "No change"
        ]
    },
    {
        "q": "Media queries adapt layout to _____.",
        "type": "fill_blank",
        "answers": [
            "screen size"
        ],
        "other_options": [
            "validation",
            "values",
            "errors"
        ]
    },
    {
        "q": "Match responsive patterns:",
        "type": "match",
        "left": [
            "Stack on mobile",
            "Full-width inputs",
            "Touch-friendly",
            "Larger targets"
        ],
        "right": [
            "Column layout",
            "100% width",
            "Bigger elements",
            "Easy tapping"
        ]
    },
    {
        "q": "What is form offline support?",
        "type": "mcq",
        "o": [
            "Working without network connection",
            "Online only",
            "No support",
            "Always connected"
        ]
    },
    {
        "q": "Forms can save data locally when offline.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "submit() { if (!navigator.onLine) { localStorage.setItem('pendingForm', JSON.stringify(this.form.value)); return; } this.sendToServer(); }",
        "o": [
            "Save and sync when online",
            "Fail silently",
            "Require connection",
            "No action"
        ]
    },
    {
        "q": "navigator.onLine checks _____ status.",
        "type": "fill_blank",
        "answers": [
            "connection"
        ],
        "other_options": [
            "validation",
            "form",
            "error"
        ]
    },
    {
        "q": "Match offline patterns:",
        "type": "match",
        "left": [
            "localStorage",
            "IndexedDB",
            "Service Worker",
            "Background Sync"
        ],
        "right": [
            "Simple storage",
            "Database storage",
            "Offline cache",
            "Delayed send"
        ]
    },
    {
        "q": "What are standalone form components?",
        "type": "mcq",
        "o": [
            "Form components without NgModules",
            "Module-based forms",
            "Template forms",
            "Legacy forms"
        ]
    },
    {
        "q": "Standalone components use imports array directly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "@Component({ standalone: true, imports: [ReactiveFormsModule] })",
        "o": [
            "Direct ReactiveFormsModule import",
            "Module declaration",
            "Global import",
            "No effect"
        ]
    },
    {
        "q": "Standalone components simplify _____ management.",
        "type": "fill_blank",
        "answers": [
            "dependency"
        ],
        "other_options": [
            "validation",
            "submission",
            "styling"
        ]
    },
    {
        "q": "Match standalone patterns:",
        "type": "match",
        "left": [
            "imports",
            "providers",
            "hostDirectives",
            "schemas"
        ],
        "right": [
            "Dependencies",
            "Services",
            "Apply directives",
            "Custom elements"
        ]
    },
    {
        "q": "What is signal-based forms?",
        "type": "mcq",
        "o": [
            "Forms using Angular signals for reactivity",
            "Observable forms",
            "Event forms",
            "Static forms"
        ]
    },
    {
        "q": "Signals provide fine-grained reactivity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "formValue = toSignal(this.form.valueChanges);",
        "o": [
            "Signal from form value changes",
            "Observable",
            "Promise",
            "Static value"
        ]
    },
    {
        "q": "toSignal converts Observable to _____.",
        "type": "fill_blank",
        "answers": [
            "Signal"
        ],
        "other_options": [
            "Promise",
            "Array",
            "Object"
        ]
    },
    {
        "q": "Match signal utilities:",
        "type": "match",
        "left": [
            "toSignal",
            "toObservable",
            "computed",
            "effect"
        ],
        "right": [
            "Observable to signal",
            "Signal to observable",
            "Derived signal",
            "Side effect"
        ]
    },
    {
        "q": "What is computed form state?",
        "type": "mcq",
        "o": [
            "Derived state from form values",
            "Static state",
            "Form control",
            "Validator"
        ]
    },
    {
        "q": "computed creates derived values automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this compute?",
        "type": "mcq",
        "c": "fullName = computed(() => `${this.firstNameSignal()} ${this.lastNameSignal()}`);",
        "o": [
            "Combined first and last name",
            "Single name",
            "Validation",
            "Errors"
        ]
    },
    {
        "q": "computed signals update _____ when dependencies change.",
        "type": "fill_blank",
        "answers": [
            "automatically"
        ],
        "other_options": [
            "manually",
            "never",
            "randomly"
        ]
    },
    {
        "q": "Rearrange signal form setup:",
        "type": "rearrange",
        "words": [
            "Create form controls",
            "Convert to signals with toSignal",
            "Create computed values",
            "Use in template",
            "React to changes"
        ]
    },
    {
        "q": "What is advanced ControlValueAccessor?",
        "type": "mcq",
        "o": [
            "Custom form controls with complex behavior",
            "Simple input",
            "Built-in control",
            "Validator"
        ]
    },
    {
        "q": "CVA can wrap third-party components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does NG_VALUE_ACCESSOR provide?",
        "type": "mcq",
        "c": "providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CustomInput), multi: true }]",
        "o": [
            "Registers custom control with Angular forms",
            "Validates control",
            "Creates control",
            "Destroys control"
        ]
    },
    {
        "q": "NG_VALUE_ACCESSOR uses _____ to avoid circular dependency.",
        "type": "fill_blank",
        "answers": [
            "forwardRef"
        ],
        "other_options": [
            "inject",
            "provider",
            "factory"
        ]
    },
    {
        "q": "Match CVA tokens:",
        "type": "match",
        "left": [
            "NG_VALUE_ACCESSOR",
            "NG_VALIDATORS",
            "NG_ASYNC_VALIDATORS",
            "forwardRef"
        ],
        "right": [
            "Value bridge",
            "Sync validation",
            "Async validation",
            "Circular fix"
        ]
    },
    {
        "q": "What is NG_VALIDATORS?",
        "type": "mcq",
        "o": [
            "Token for custom validator directives",
            "Value accessor",
            "Form builder",
            "Control"
        ]
    },
    {
        "q": "Components can implement Validator interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this add?",
        "type": "mcq",
        "c": "providers: [{ provide: NG_VALIDATORS, useExisting: CustomInput, multi: true }]",
        "o": [
            "Custom validation to form control",
            "Value accessor",
            "Styling",
            "Events"
        ]
    },
    {
        "q": "multi: true allows _____ validators.",
        "type": "fill_blank",
        "answers": [
            "multiple"
        ],
        "other_options": [
            "single",
            "no",
            "async"
        ]
    },
    {
        "q": "Match validation tokens:",
        "type": "match",
        "left": [
            "NG_VALIDATORS",
            "NG_ASYNC_VALIDATORS",
            "Validator",
            "AsyncValidator"
        ],
        "right": [
            "Sync DI token",
            "Async DI token",
            "Sync interface",
            "Async interface"
        ]
    },
    {
        "q": "What is form inject pattern?",
        "type": "mcq",
        "o": [
            "Using inject() in form services",
            "Constructor injection",
            "Provider injection",
            "Factory injection"
        ]
    },
    {
        "q": "inject() works in injection context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this access?",
        "type": "mcq",
        "c": "private fb = inject(FormBuilder);",
        "o": [
            "FormBuilder via inject function",
            "Constructor parameter",
            "Global variable",
            "Local variable"
        ]
    },
    {
        "q": "inject() is preferred in _____ applications.",
        "type": "fill_blank",
        "answers": [
            "standalone"
        ],
        "other_options": [
            "module",
            "legacy",
            "old"
        ]
    },
    {
        "q": "Match injection patterns:",
        "type": "match",
        "left": [
            "inject()",
            "constructor",
            "@Inject()",
            "InjectionToken"
        ],
        "right": [
            "Function injection",
            "Parameter injection",
            "Decorator injection",
            "Custom token"
        ]
    },
    {
        "q": "What is form event handling?",
        "type": "mcq",
        "o": [
            "Processing form lifecycle events",
            "Value changes",
            "Status changes",
            "All above"
        ]
    },
    {
        "q": "Form controls emit events observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does events contain?",
        "type": "mcq",
        "c": "control.events.subscribe(event => console.log(event));",
        "o": [
            "All control events including value and status",
            "Only values",
            "Only status",
            "Only touched"
        ]
    },
    {
        "q": "events observable is new in Angular _____.",
        "type": "fill_blank",
        "answers": [
            "18"
        ],
        "other_options": [
            "14",
            "15",
            "16"
        ]
    },
    {
        "q": "Match form events:",
        "type": "match",
        "left": [
            "ValueChangeEvent",
            "StatusChangeEvent",
            "TouchedChangeEvent",
            "PristineChangeEvent"
        ],
        "right": [
            "Value updated",
            "Validity changed",
            "Touched state",
            "Pristine state"
        ]
    },
    {
        "q": "What is form control state signals?",
        "type": "mcq",
        "o": [
            "Signal-based access to form state",
            "Observable state",
            "Static state",
            "No state"
        ]
    },
    {
        "q": "Angular 18 adds signal-based form state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What signal does this access?",
        "type": "mcq",
        "c": "control.valueSignal()",
        "o": [
            "Control value as signal",
            "Control status",
            "Control errors",
            "Control touched"
        ]
    },
    {
        "q": "Form signals reduce _____ subscriptions.",
        "type": "fill_blank",
        "answers": [
            "observable"
        ],
        "other_options": [
            "signal",
            "event",
            "all"
        ]
    },
    {
        "q": "Match form signals:",
        "type": "match",
        "left": [
            "valueSignal",
            "statusSignal",
            "validSignal",
            "touchedSignal"
        ],
        "right": [
            "Current value",
            "Current status",
            "Is valid",
            "Is touched"
        ]
    },
    {
        "q": "What is deferrable views with forms?",
        "type": "mcq",
        "o": [
            "Loading form parts on demand",
            "Eager loading",
            "Static forms",
            "All at once"
        ]
    },
    {
        "q": "@defer can wrap form sections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this defer?",
        "type": "mcq",
        "c": "@defer (on viewport) { <app-address-form formGroupName=\"address\"></app-address-form> }",
        "o": [
            "Loads address form when visible",
            "Always loads",
            "Never loads",
            "Loads on click"
        ]
    },
    {
        "q": "@defer improves initial _____ time.",
        "type": "fill_blank",
        "answers": [
            "load"
        ],
        "other_options": [
            "validation",
            "submission",
            "styling"
        ]
    },
    {
        "q": "Match defer triggers:",
        "type": "match",
        "left": [
            "on viewport",
            "on interaction",
            "on hover",
            "on timer"
        ],
        "right": [
            "Visible in view",
            "User clicks",
            "Mouse over",
            "After delay"
        ]
    },
    {
        "q": "What is form hydration?",
        "type": "mcq",
        "o": [
            "Restoring form state after SSR",
            "Form creation",
            "Form validation",
            "Form submission"
        ]
    },
    {
        "q": "SSR apps must hydrate forms correctly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does withEventReplay help with?",
        "type": "mcq",
        "c": "provideClientHydration(withEventReplay())",
        "o": [
            "Capture events before hydration",
            "Skip events",
            "Cancel events",
            "No effect"
        ]
    },
    {
        "q": "Event replay preserves user _____ during hydration.",
        "type": "fill_blank",
        "answers": [
            "interactions"
        ],
        "other_options": [
            "validation",
            "errors",
            "values"
        ]
    },
    {
        "q": "Match hydration features:",
        "type": "match",
        "left": [
            "withEventReplay",
            "withNoHttpTransferCache",
            "provideClientHydration"
        ],
        "right": [
            "Capture events",
            "Skip cache",
            "Enable hydration"
        ]
    },
    {
        "q": "What is form input transform?",
        "type": "mcq",
        "o": [
            "Transforming input values in components",
            "Value binding",
            "Validation",
            "Event handling"
        ]
    },
    {
        "q": "Input transforms run on assignment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this transform?",
        "type": "mcq",
        "c": "@Input({ transform: booleanAttribute }) required!: boolean;",
        "o": [
            "Converts attribute to boolean",
            "String conversion",
            "Number conversion",
            "No conversion"
        ]
    },
    {
        "q": "booleanAttribute handles _____ to boolean conversion.",
        "type": "fill_blank",
        "answers": [
            "string"
        ],
        "other_options": [
            "number",
            "object",
            "array"
        ]
    },
    {
        "q": "Match input transforms:",
        "type": "match",
        "left": [
            "booleanAttribute",
            "numberAttribute",
            "Custom transform"
        ],
        "right": [
            "String to boolean",
            "String to number",
            "Custom logic"
        ]
    },
    {
        "q": "What is model() input?",
        "type": "mcq",
        "o": [
            "Two-way bindable signal input",
            "One-way input",
            "Output only",
            "Static value"
        ]
    },
    {
        "q": "model() enables two-way binding with signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "value = model<string>('');",
        "o": [
            "Two-way bindable value",
            "One-way input",
            "Output",
            "Signal"
        ]
    },
    {
        "q": "model() is syntactic sugar for input + _____.",
        "type": "fill_blank",
        "answers": [
            "output"
        ],
        "other_options": [
            "signal",
            "computed",
            "effect"
        ]
    },
    {
        "q": "Match signal inputs:",
        "type": "match",
        "left": [
            "input()",
            "input.required()",
            "model()"
        ],
        "right": [
            "Optional signal input",
            "Required signal input",
            "Two-way signal"
        ]
    },
    {
        "q": "What is form output?",
        "type": "mcq",
        "o": [
            "Signal-based event emitter",
            "Input binding",
            "Validator",
            "Control"
        ]
    },
    {
        "q": "output() is the signal-based alternative to @Output.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "formSubmitted = output<FormData>(); // this.formSubmitted.emit(data);",
        "o": [
            "FormData on submission",
            "Validation result",
            "Error message",
            "Control value"
        ]
    },
    {
        "q": "output() creates _____ emitter.",
        "type": "fill_blank",
        "answers": [
            "signal-based"
        ],
        "other_options": [
            "observable",
            "promise",
            "callback"
        ]
    },
    {
        "q": "Match output patterns:",
        "type": "match",
        "left": [
            "@Output()",
            "output()",
            "outputFromObservable()"
        ],
        "right": [
            "EventEmitter",
            "Signal output",
            "Observable to output"
        ]
    },
    {
        "q": "What is form view queries?",
        "type": "mcq",
        "o": [
            "Accessing form elements in template",
            "Value access",
            "Event handling",
            "Validation"
        ]
    },
    {
        "q": "viewChild can reference form elements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this query?",
        "type": "mcq",
        "c": "emailInput = viewChild<ElementRef>('emailInput');",
        "o": [
            "Email input element reference",
            "Form value",
            "Validator",
            "Control"
        ]
    },
    {
        "q": "viewChild returns _____ signal.",
        "type": "fill_blank",
        "answers": [
            "read-only"
        ],
        "other_options": [
            "writable",
            "computed",
            "model"
        ]
    },
    {
        "q": "Match view queries:",
        "type": "match",
        "left": [
            "viewChild",
            "viewChildren",
            "contentChild",
            "contentChildren"
        ],
        "right": [
            "Single child",
            "Multiple children",
            "Projected single",
            "Projected multiple"
        ]
    },
    {
        "q": "What is form content projection?",
        "type": "mcq",
        "o": [
            "Passing content into form components",
            "Value binding",
            "Event handling",
            "Validation"
        ]
    },
    {
        "q": "ng-content enables form slot patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this project?",
        "type": "mcq",
        "c": "<my-form-field><input formControlName=\"email\"><ng-content></ng-content></my-form-field>",
        "o": [
            "Input and additional content into wrapper",
            "Only input",
            "Only wrapper",
            "Nothing"
        ]
    },
    {
        "q": "ng-content uses _____ for multiple slots.",
        "type": "fill_blank",
        "answers": [
            "select"
        ],
        "other_options": [
            "filter",
            "query",
            "name"
        ]
    },
    {
        "q": "Match content projection:",
        "type": "match",
        "left": [
            "ng-content",
            "select",
            "ngProjectAs",
            "@ContentChild"
        ],
        "right": [
            "Projection point",
            "Filter content",
            "Override selector",
            "Access projected"
        ]
    },
    {
        "q": "What is form host binding?",
        "type": "mcq",
        "o": [
            "Binding to host element properties",
            "Value binding",
            "Event binding",
            "Control binding"
        ]
    },
    {
        "q": "host can bind form-related classes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this add?",
        "type": "mcq",
        "c": "host: { '[class.invalid]': 'control.invalid' }",
        "o": [
            "Invalid class when control is invalid",
            "Always invalid",
            "Never invalid",
            "Style only"
        ]
    },
    {
        "q": "host bindings affect _____ element.",
        "type": "fill_blank",
        "answers": [
            "host"
        ],
        "other_options": [
            "child",
            "parent",
            "sibling"
        ]
    },
    {
        "q": "Match host bindings:",
        "type": "match",
        "left": [
            "[class.x]",
            "[style.x]",
            "[attr.x]",
            "(event)"
        ],
        "right": [
            "CSS class",
            "Inline style",
            "HTML attribute",
            "Event listener"
        ]
    },
    {
        "q": "What is form directive composition?",
        "type": "mcq",
        "o": [
            "Combining directives on form elements",
            "Single directive",
            "No directives",
            "Template only"
        ]
    },
    {
        "q": "hostDirectives apply directives to host.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this compose?",
        "type": "mcq",
        "c": "hostDirectives: [{ directive: TooltipDirective, inputs: ['tooltip'] }]",
        "o": [
            "Tooltip functionality on component",
            "Form control",
            "Validation",
            "Styling"
        ]
    },
    {
        "q": "hostDirectives enable directive _____.",
        "type": "fill_blank",
        "answers": [
            "reuse"
        ],
        "other_options": [
            "creation",
            "deletion",
            "validation"
        ]
    },
    {
        "q": "Match directive composition:",
        "type": "match",
        "left": [
            "directive",
            "inputs",
            "outputs"
        ],
        "right": [
            "Directive class",
            "Expose inputs",
            "Expose outputs"
        ]
    },
    {
        "q": "What is form DI scope?",
        "type": "mcq",
        "o": [
            "Controlling service lifetime in forms",
            "Global scope",
            "No scope",
            "Static scope"
        ]
    },
    {
        "q": "Component-level providers scope services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What scope does this create?",
        "type": "mcq",
        "c": "@Component({ providers: [FormStateService] })",
        "o": [
            "Component-scoped form state",
            "Global state",
            "Module state",
            "App state"
        ]
    },
    {
        "q": "Component providers create _____ service instances.",
        "type": "fill_blank",
        "answers": [
            "unique"
        ],
        "other_options": [
            "shared",
            "global",
            "static"
        ]
    },
    {
        "q": "Match DI scopes:",
        "type": "match",
        "left": [
            "root",
            "platform",
            "any",
            "Component"
        ],
        "right": [
            "Singleton",
            "Multi-app",
            "Lazy boundary",
            "Per instance"
        ]
    },
    {
        "q": "What is form error boundary?",
        "type": "mcq",
        "o": [
            "Handling errors in form components",
            "Validation errors",
            "No errors",
            "Global errors"
        ]
    },
    {
        "q": "Error handlers can catch form errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ErrorHandler do?",
        "type": "mcq",
        "c": "class FormErrorHandler implements ErrorHandler { handleError(error) { /* log */ } }",
        "o": [
            "Catches and handles runtime errors",
            "Creates errors",
            "Ignores errors",
            "Validates forms"
        ]
    },
    {
        "q": "Custom ErrorHandler provides _____ error handling.",
        "type": "fill_blank",
        "answers": [
            "centralized"
        ],
        "other_options": [
            "distributed",
            "no",
            "local"
        ]
    },
    {
        "q": "Match error handling:",
        "type": "match",
        "left": [
            "ErrorHandler",
            "try/catch",
            "catchError",
            "setErrors"
        ],
        "right": [
            "Global handler",
            "Sync handler",
            "Observable handler",
            "Form errors"
        ]
    },
    {
        "q": "What is form change detection strategy?",
        "type": "mcq",
        "o": [
            "Controlling when forms check for changes",
            "Always check",
            "Never check",
            "Random check"
        ]
    },
    {
        "q": "OnPush improves form performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does OnPush require?",
        "type": "mcq",
        "c": "changeDetection: ChangeDetectionStrategy.OnPush",
        "o": [
            "Immutable inputs or markForCheck",
            "Mutable state",
            "Always change",
            "No requirements"
        ]
    },
    {
        "q": "OnPush checks only on input _____ or async.",
        "type": "fill_blank",
        "answers": [
            "changes"
        ],
        "other_options": [
            "creation",
            "deletion",
            "validation"
        ]
    },
    {
        "q": "Match change detection:",
        "type": "match",
        "left": [
            "Default",
            "OnPush",
            "markForCheck",
            "detectChanges"
        ],
        "right": [
            "Check always",
            "Check on trigger",
            "Request check",
            "Force check"
        ]
    },
    {
        "q": "What is form zone optimization?",
        "type": "mcq",
        "o": [
            "Running form code outside NgZone",
            "Inside zone",
            "No zone",
            "New zone"
        ]
    },
    {
        "q": "runOutsideAngular avoids unnecessary change detection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What optimization does this provide?",
        "type": "mcq",
        "c": "ngZone.runOutsideAngular(() => this.expensiveFormOperation());",
        "o": [
            "Skip change detection for operation",
            "Force change detection",
            "Cancel operation",
            "No effect"
        ]
    },
    {
        "q": "Zone-less apps use _____ change detection.",
        "type": "fill_blank",
        "answers": [
            "signal-based"
        ],
        "other_options": [
            "zone",
            "manual",
            "automatic"
        ]
    },
    {
        "q": "Match zone patterns:",
        "type": "match",
        "left": [
            "runOutsideAngular",
            "run",
            "provideZoneChangeDetection",
            "zoneless"
        ],
        "right": [
            "Skip zone",
            "In zone",
            "Configure zone",
            "No zone"
        ]
    },
    {
        "q": "What is form deprecation handling?",
        "type": "mcq",
        "o": [
            "Managing outdated APIs in forms",
            "Creating forms",
            "Deleting forms",
            "No handling"
        ]
    },
    {
        "q": "Using deprecated APIs shows console warnings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is deprecated in favor of inject()?",
        "type": "mcq",
        "o": [
            "Constructor injection in some contexts",
            "All injection",
            "No injection",
            "Template injection"
        ]
    },
    {
        "q": "Deprecated APIs should be _____ before removal.",
        "type": "fill_blank",
        "answers": [
            "migrated"
        ],
        "other_options": [
            "ignored",
            "kept",
            "duplicated"
        ]
    },
    {
        "q": "Match deprecation patterns:",
        "type": "match",
        "left": [
            "UntypedFormControl",
            "ReactiveFormsModule.withConfig",
            "ngModel + formControlName"
        ],
        "right": [
            "Typed forms available",
            "Modern config",
            "Not allowed together"
        ]
    },
    {
        "q": "What is form best practice summary?",
        "type": "mcq",
        "o": [
            "Collection of recommended patterns",
            "Single pattern",
            "No patterns",
            "Random patterns"
        ]
    },
    {
        "q": "Prefer reactive over template-driven for complex forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is recommended for new projects?",
        "type": "mcq",
        "o": [
            "Typed reactive forms with signals",
            "Template-driven only",
            "Untyped forms",
            "No forms"
        ]
    },
    {
        "q": "Best practice: keep forms _____ and focused.",
        "type": "fill_blank",
        "answers": [
            "small"
        ],
        "other_options": [
            "large",
            "complex",
            "nested"
        ]
    },
    {
        "q": "Match best practices:",
        "type": "match",
        "left": [
            "Typed forms",
            "Signals",
            "OnPush",
            "updateOn: blur"
        ],
        "right": [
            "Type safety",
            "Fine-grained reactivity",
            "Performance",
            "Reduced validation"
        ]
    },
    {
        "q": "What is form documentation?",
        "type": "mcq",
        "o": [
            "Documenting form structure and usage",
            "No documentation",
            "Code only",
            "Comments only"
        ]
    },
    {
        "q": "JSDoc comments help document forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this document?",
        "type": "mcq",
        "c": "/** User registration form with email validation */\nform = this.fb.group({...});",
        "o": [
            "Form purpose and features",
            "Nothing",
            "Code syntax",
            "Form values"
        ]
    },
    {
        "q": "Documentation helps with form _____.",
        "type": "fill_blank",
        "answers": [
            "maintenance"
        ],
        "other_options": [
            "validation",
            "styling",
            "submission"
        ]
    },
    {
        "q": "Match documentation elements:",
        "type": "match",
        "left": [
            "JSDoc",
            "README",
            "Storybook",
            "TypeDoc"
        ],
        "right": [
            "Code comments",
            "File documentation",
            "Visual docs",
            "API docs"
        ]
    },
    {
        "q": "What is form naming conventions?",
        "type": "mcq",
        "o": [
            "Consistent names for form elements",
            "Random naming",
            "No naming",
            "Number naming"
        ]
    },
    {
        "q": "Descriptive names improve readability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which naming is clearer?",
        "type": "mcq",
        "o": [
            "userRegistrationForm vs form1",
            "form1 vs formX",
            "f1 vs f2",
            "No difference"
        ]
    },
    {
        "q": "Control names should match _____ model properties.",
        "type": "fill_blank",
        "answers": [
            "domain"
        ],
        "other_options": [
            "random",
            "sequential",
            "alphabetical"
        ]
    },
    {
        "q": "Match naming conventions:",
        "type": "match",
        "left": [
            "camelCase",
            "PascalCase",
            "kebab-case",
            "SCREAMING_CASE"
        ],
        "right": [
            "Properties",
            "Classes",
            "Selectors",
            "Constants"
        ]
    },
    {
        "q": "What is form code organization?",
        "type": "mcq",
        "o": [
            "Structuring form-related code logically",
            "Random structure",
            "No structure",
            "Single file"
        ]
    },
    {
        "q": "Separate form logic from presentation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern separates form building?",
        "type": "mcq",
        "o": [
            "Form factory service",
            "All in component",
            "Template only",
            "No separation"
        ]
    },
    {
        "q": "Form logic in services improves _____.",
        "type": "fill_blank",
        "answers": [
            "testability"
        ],
        "other_options": [
            "styling",
            "display",
            "templates"
        ]
    },
    {
        "q": "Rearrange code organization:",
        "type": "rearrange",
        "words": [
            "Define models/interfaces",
            "Create form factory service",
            "Build validation service",
            "Implement form component",
            "Add template bindings"
        ]
    },
    {
        "q": "What is form version control?",
        "type": "mcq",
        "o": [
            "Tracking form schema changes over time",
            "No versioning",
            "Random versioning",
            "Date versioning"
        ]
    },
    {
        "q": "Form migrations help handle schema changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What helps track form changes?",
        "type": "mcq",
        "o": [
            "Git version control and migrations",
            "No tracking",
            "Manual notes",
            "Memory"
        ]
    },
    {
        "q": "Schema versioning helps _____ compatibility.",
        "type": "fill_blank",
        "answers": [
            "backward"
        ],
        "other_options": [
            "forward",
            "no",
            "random"
        ]
    },
    {
        "q": "Match versioning patterns:",
        "type": "match",
        "left": [
            "Git history",
            "Schema version",
            "Migration script",
            "Changelog"
        ],
        "right": [
            "Code changes",
            "Data format",
            "Update data",
            "Document changes"
        ]
    },
    {
        "q": "What is form future-proofing?",
        "type": "mcq",
        "o": [
            "Building forms that adapt to changes",
            "Static forms",
            "No planning",
            "Hardcoded forms"
        ]
    },
    {
        "q": "Flexible form design reduces refactoring.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What enables future flexibility?",
        "type": "mcq",
        "o": [
            "Generic patterns and configuration",
            "Hardcoded values",
            "No abstraction",
            "Inline code"
        ]
    },
    {
        "q": "Configuration-driven forms enable _____ modification.",
        "type": "fill_blank",
        "answers": [
            "runtime"
        ],
        "other_options": [
            "compile-time",
            "no",
            "manual"
        ]
    },
    {
        "q": "Match future-proofing patterns:",
        "type": "match",
        "left": [
            "Config-driven",
            "Factory pattern",
            "Interface abstraction",
            "Modular design"
        ],
        "right": [
            "External config",
            "Dynamic creation",
            "Contract-based",
            "Independent parts"
        ]
    }
]