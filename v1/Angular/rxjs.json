[
    {
        "q": "What is RxJS?",
        "type": "mcq",
        "o": [
            "Reactive Extensions for JavaScript",
            "React JavaScript",
            "Regular Expressions",
            "Runtime JavaScript"
        ]
    },
    {
        "q": "RxJS is used for asynchronous programming.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is an Observable?",
        "type": "mcq",
        "o": [
            "A stream of values over time",
            "A single value",
            "A function",
            "A class"
        ]
    },
    {
        "q": "Observables are _____ by default.",
        "type": "fill_blank",
        "answers": [
            "lazy"
        ],
        "other_options": [
            "eager",
            "active",
            "pending"
        ]
    },
    {
        "q": "Match RxJS concepts:",
        "type": "match",
        "left": [
            "Observable",
            "Observer",
            "Subscription",
            "Operator"
        ],
        "right": [
            "Data source",
            "Data consumer",
            "Connection",
            "Transformation"
        ]
    },
    {
        "q": "What is an Observer?",
        "type": "mcq",
        "o": [
            "Object that receives Observable values",
            "Data source",
            "Operator",
            "Subject"
        ]
    },
    {
        "q": "Observers have next, error, and complete callbacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does subscribe() return?",
        "type": "mcq",
        "o": [
            "Subscription",
            "Observable",
            "Observer",
            "Value"
        ]
    },
    {
        "q": "The _____ method is called when Observable completes.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "done",
            "finish",
            "end"
        ]
    },
    {
        "q": "Rearrange Observable lifecycle:",
        "type": "rearrange",
        "words": [
            "Create Observable",
            "Subscribe to Observable",
            "Receive next values",
            "Handle completion or error",
            "Unsubscribe"
        ]
    },
    {
        "q": "What is a Subscription?",
        "type": "mcq",
        "o": [
            "Represents execution of Observable",
            "Observable itself",
            "Observer",
            "Operator"
        ]
    },
    {
        "q": "Subscriptions should be unsubscribed to prevent memory leaks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does unsubscribe() do?",
        "type": "mcq",
        "o": [
            "Stops receiving values from Observable",
            "Creates new subscription",
            "Emits value",
            "Completes Observable"
        ]
    },
    {
        "q": "Memory leaks occur when subscriptions are not _____.",
        "type": "fill_blank",
        "answers": [
            "unsubscribed"
        ],
        "other_options": [
            "created",
            "started",
            "paused"
        ]
    },
    {
        "q": "Match subscription methods:",
        "type": "match",
        "left": [
            "subscribe",
            "unsubscribe",
            "add",
            "remove"
        ],
        "right": [
            "Start receiving",
            "Stop receiving",
            "Add child subscription",
            "Remove child subscription"
        ]
    },
    {
        "q": "What is the of() operator?",
        "type": "mcq",
        "o": [
            "Creates Observable from values",
            "Filters values",
            "Maps values",
            "Merges Observables"
        ]
    },
    {
        "q": "of(1, 2, 3) emits values synchronously.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "of('a', 'b', 'c')",
        "o": [
            "Observable emitting a, b, c then completing",
            "Array",
            "Promise",
            "String"
        ]
    },
    {
        "q": "of() emits values and then _____.",
        "type": "fill_blank",
        "answers": [
            "completes"
        ],
        "other_options": [
            "errors",
            "waits",
            "repeats"
        ]
    },
    {
        "q": "Match creation operators:",
        "type": "match",
        "left": [
            "of",
            "from",
            "interval",
            "timer"
        ],
        "right": [
            "From values",
            "From iterable/promise",
            "Periodic emissions",
            "Delayed emission"
        ]
    },
    {
        "q": "What is the from() operator?",
        "type": "mcq",
        "o": [
            "Creates Observable from array/iterable/promise",
            "Creates values",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "from() can convert a Promise to Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "from([1, 2, 3])",
        "o": [
            "Observable emitting 1, 2, 3",
            "Array",
            "Promise",
            "Single value"
        ]
    },
    {
        "q": "from() converts iterables to _____.",
        "type": "fill_blank",
        "answers": [
            "Observables"
        ],
        "other_options": [
            "Promises",
            "Arrays",
            "Strings"
        ]
    },
    {
        "q": "Rearrange from() usage with Promise:",
        "type": "rearrange",
        "words": [
            "Create Promise",
            "Pass to from()",
            "Get Observable",
            "Subscribe",
            "Receive resolved value"
        ]
    },
    {
        "q": "What is interval()?",
        "type": "mcq",
        "o": [
            "Emits sequential numbers at intervals",
            "Single emission",
            "Array emission",
            "Immediate completion"
        ]
    },
    {
        "q": "interval(1000) emits every second.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "interval(500)",
        "o": [
            "0, 1, 2, 3... every 500ms",
            "500, 1000, 1500...",
            "Single value",
            "Nothing"
        ]
    },
    {
        "q": "interval() starts emitting at index _____.",
        "type": "fill_blank",
        "answers": [
            "0"
        ],
        "other_options": [
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Match timing operators:",
        "type": "match",
        "left": [
            "interval",
            "timer",
            "delay",
            "debounceTime"
        ],
        "right": [
            "Periodic",
            "Initial delay + optional periodic",
            "Delay emissions",
            "Wait after last value"
        ]
    },
    {
        "q": "What is timer()?",
        "type": "mcq",
        "o": [
            "Emits after delay, optionally periodically",
            "Immediate emission",
            "No delay",
            "Array emission"
        ]
    },
    {
        "q": "timer(3000) emits after 3 seconds.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "timer(1000, 500)",
        "o": [
            "1s delay, then emit every 500ms",
            "1500ms delay",
            "Single emission",
            "No emission"
        ]
    },
    {
        "q": "timer(0) emits _____.",
        "type": "fill_blank",
        "answers": [
            "immediately"
        ],
        "other_options": [
            "never",
            "after 1 second",
            "after completion"
        ]
    },
    {
        "q": "Match timer behaviors:",
        "type": "match",
        "left": [
            "timer(1000)",
            "timer(0)",
            "timer(1000, 500)",
            "timer(0, 1000)"
        ],
        "right": [
            "1s delay, single emit",
            "Immediate single emit",
            "1s delay then periodic",
            "Immediate then periodic"
        ]
    },
    {
        "q": "What is map() operator?",
        "type": "mcq",
        "o": [
            "Transforms each emitted value",
            "Filters values",
            "Combines Observables",
            "Delays values"
        ]
    },
    {
        "q": "map() is similar to Array.map().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this produce?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(map(x => x * 2))",
        "o": [
            "2, 4, 6",
            "1, 2, 3",
            "3, 6, 9",
            "1, 4, 9"
        ]
    },
    {
        "q": "map() applies a _____ to each value.",
        "type": "fill_blank",
        "answers": [
            "function"
        ],
        "other_options": [
            "filter",
            "delay",
            "merge"
        ]
    },
    {
        "q": "Match transformation operators:",
        "type": "match",
        "left": [
            "map",
            "pluck",
            "mapTo",
            "scan"
        ],
        "right": [
            "Transform value",
            "Extract property",
            "Map to constant",
            "Accumulate"
        ]
    },
    {
        "q": "What is filter() operator?",
        "type": "mcq",
        "o": [
            "Emits values that pass a condition",
            "Transforms values",
            "Delays values",
            "Combines Observables"
        ]
    },
    {
        "q": "filter() is similar to Array.filter().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 2, 3, 4).pipe(filter(x => x > 2))",
        "o": [
            "3, 4",
            "1, 2",
            "1, 2, 3, 4",
            "Nothing"
        ]
    },
    {
        "q": "filter() only emits values where predicate returns _____.",
        "type": "fill_blank",
        "answers": [
            "true"
        ],
        "other_options": [
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Match filtering operators:",
        "type": "match",
        "left": [
            "filter",
            "take",
            "skip",
            "distinct"
        ],
        "right": [
            "By condition",
            "First N values",
            "Skip first N",
            "Unique values"
        ]
    },
    {
        "q": "What is tap() operator?",
        "type": "mcq",
        "o": [
            "Performs side effects without changing values",
            "Transforms values",
            "Filters values",
            "Delays values"
        ]
    },
    {
        "q": "tap() is useful for debugging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "of(1, 2).pipe(tap(x => console.log(x)))",
        "o": [
            "Logs values, emits unchanged",
            "Transforms values",
            "Filters values",
            "Stops emission"
        ]
    },
    {
        "q": "tap() was previously called _____.",
        "type": "fill_blank",
        "answers": [
            "do"
        ],
        "other_options": [
            "log",
            "debug",
            "print"
        ]
    },
    {
        "q": "Match utility operators:",
        "type": "match",
        "left": [
            "tap",
            "delay",
            "timeout",
            "finalize"
        ],
        "right": [
            "Side effects",
            "Delay emissions",
            "Error if slow",
            "Cleanup"
        ]
    },
    {
        "q": "What is take() operator?",
        "type": "mcq",
        "o": [
            "Takes first N values then completes",
            "Skips first N values",
            "Takes last N values",
            "Takes all values"
        ]
    },
    {
        "q": "take(1) completes after first emission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "interval(100).pipe(take(3))",
        "o": [
            "0, 1, 2 then completes",
            "0, 1, 2, 3...",
            "100, 200, 300",
            "Nothing"
        ]
    },
    {
        "q": "take() automatically _____ when count reached.",
        "type": "fill_blank",
        "answers": [
            "completes"
        ],
        "other_options": [
            "errors",
            "waits",
            "restarts"
        ]
    },
    {
        "q": "Match taking operators:",
        "type": "match",
        "left": [
            "take",
            "takeLast",
            "takeUntil",
            "takeWhile"
        ],
        "right": [
            "First N",
            "Last N",
            "Until notifier",
            "While condition"
        ]
    },
    {
        "q": "What is takeUntil()?",
        "type": "mcq",
        "o": [
            "Completes when notifier emits",
            "Takes first N values",
            "Takes while condition",
            "Never completes"
        ]
    },
    {
        "q": "takeUntil is useful for unsubscribing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern is this?",
        "type": "mcq",
        "c": "data$.pipe(takeUntil(destroy$))",
        "o": [
            "Unsubscribe on component destroy",
            "Infinite subscription",
            "Manual unsubscribe",
            "No unsubscribe"
        ]
    },
    {
        "q": "takeUntil completes when notifier _____.",
        "type": "fill_blank",
        "answers": [
            "emits"
        ],
        "other_options": [
            "subscribes",
            "completes",
            "errors"
        ]
    },
    {
        "q": "Rearrange takeUntil pattern:",
        "type": "rearrange",
        "words": [
            "Create destroy$ Subject",
            "Use takeUntil(destroy$)",
            "Subscribe to Observable",
            "Call destroy$.next() in ngOnDestroy",
            "Subscription completes"
        ]
    },
    {
        "q": "What is skip() operator?",
        "type": "mcq",
        "o": [
            "Skips first N values",
            "Takes first N values",
            "Skips last N values",
            "Skips all values"
        ]
    },
    {
        "q": "skip(2) ignores first two emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 2, 3, 4).pipe(skip(2))",
        "o": [
            "3, 4",
            "1, 2",
            "1, 2, 3, 4",
            "Nothing"
        ]
    },
    {
        "q": "skip() ignores values until count _____.",
        "type": "fill_blank",
        "answers": [
            "reached"
        ],
        "other_options": [
            "zero",
            "one",
            "negative"
        ]
    },
    {
        "q": "Match skipping operators:",
        "type": "match",
        "left": [
            "skip",
            "skipLast",
            "skipUntil",
            "skipWhile"
        ],
        "right": [
            "First N",
            "Last N",
            "Until notifier",
            "While condition"
        ]
    },
    {
        "q": "What is first() operator?",
        "type": "mcq",
        "o": [
            "Emits first value then completes",
            "Emits all values",
            "Emits last value",
            "Filters values"
        ]
    },
    {
        "q": "first() is equivalent to take(1).",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(5, 10, 15).pipe(first())",
        "o": [
            "5",
            "15",
            "5, 10, 15",
            "30"
        ]
    },
    {
        "q": "first() with predicate emits first value matching _____.",
        "type": "fill_blank",
        "answers": [
            "condition"
        ],
        "other_options": [
            "type",
            "index",
            "order"
        ]
    },
    {
        "q": "Match single value operators:",
        "type": "match",
        "left": [
            "first",
            "last",
            "single",
            "elementAt"
        ],
        "right": [
            "First value",
            "Last value",
            "Only if single",
            "At index"
        ]
    },
    {
        "q": "What is debounceTime()?",
        "type": "mcq",
        "o": [
            "Emits after silence period",
            "Emits immediately",
            "Delays all values",
            "Filters values"
        ]
    },
    {
        "q": "debounceTime is useful for search inputs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this help with?",
        "type": "mcq",
        "c": "searchInput.valueChanges.pipe(debounceTime(300))",
        "o": [
            "Waits 300ms after typing stops",
            "Delays for 300ms",
            "Emits every 300ms",
            "Ignores for 300ms"
        ]
    },
    {
        "q": "debounceTime emits latest value after _____ period.",
        "type": "fill_blank",
        "answers": [
            "silence"
        ],
        "other_options": [
            "active",
            "initial",
            "final"
        ]
    },
    {
        "q": "Match rate limiting operators:",
        "type": "match",
        "left": [
            "debounceTime",
            "throttleTime",
            "auditTime",
            "sampleTime"
        ],
        "right": [
            "After silence",
            "First in window",
            "Last in window",
            "At intervals"
        ]
    },
    {
        "q": "What is distinctUntilChanged()?",
        "type": "mcq",
        "o": [
            "Emits only when value changes",
            "Emits all values",
            "Emits distinct values ever",
            "Filters by condition"
        ]
    },
    {
        "q": "distinctUntilChanged prevents duplicate consecutive emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 1, 2, 2, 3).pipe(distinctUntilChanged())",
        "o": [
            "1, 2, 3",
            "1, 1, 2, 2, 3",
            "1",
            "3"
        ]
    },
    {
        "q": "distinctUntilChanged compares to _____ value.",
        "type": "fill_blank",
        "answers": [
            "previous"
        ],
        "other_options": [
            "first",
            "last",
            "all"
        ]
    },
    {
        "q": "Match distinct operators:",
        "type": "match",
        "left": [
            "distinct",
            "distinctUntilChanged",
            "distinctUntilKeyChanged"
        ],
        "right": [
            "Ever seen",
            "From previous",
            "Property change"
        ]
    },
    {
        "q": "What is switchMap()?",
        "type": "mcq",
        "o": [
            "Switches to new inner Observable, canceling previous",
            "Merges all inner Observables",
            "Concatenates Observables",
            "Filters Observables"
        ]
    },
    {
        "q": "switchMap cancels previous inner subscriptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is switchMap useful for?",
        "type": "mcq",
        "o": [
            "HTTP requests that cancel on new input",
            "Parallel requests",
            "Sequential requests",
            "Caching"
        ]
    },
    {
        "q": "switchMap is best for _____ requests.",
        "type": "fill_blank",
        "answers": [
            "search"
        ],
        "other_options": [
            "save",
            "delete",
            "queue"
        ]
    },
    {
        "q": "Match flattening operators:",
        "type": "match",
        "left": [
            "switchMap",
            "mergeMap",
            "concatMap",
            "exhaustMap"
        ],
        "right": [
            "Cancel previous",
            "Run parallel",
            "Sequential",
            "Ignore while busy"
        ]
    },
    {
        "q": "What is mergeMap()?",
        "type": "mcq",
        "o": [
            "Subscribes to all inner Observables simultaneously",
            "Cancels previous",
            "Queues subscriptions",
            "Ignores new"
        ]
    },
    {
        "q": "mergeMap can cause race conditions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does mergeMap do with inner Observables?",
        "type": "mcq",
        "o": [
            "Runs them in parallel",
            "Runs sequentially",
            "Cancels all but latest",
            "Ignores all but first"
        ]
    },
    {
        "q": "mergeMap runs _____ inner subscriptions.",
        "type": "fill_blank",
        "answers": [
            "concurrent"
        ],
        "other_options": [
            "sequential",
            "single",
            "no"
        ]
    },
    {
        "q": "Rearrange mergeMap execution:",
        "type": "rearrange",
        "words": [
            "Outer Observable emits",
            "Project to inner Observable",
            "Subscribe to inner immediately",
            "Merge all inner emissions",
            "Continue for all outer values"
        ]
    },
    {
        "q": "What is concatMap()?",
        "type": "mcq",
        "o": [
            "Queues inner Observables sequentially",
            "Runs in parallel",
            "Cancels previous",
            "Ignores new"
        ]
    },
    {
        "q": "concatMap preserves order of emissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is concatMap best for?",
        "type": "mcq",
        "o": [
            "Operations that must be sequential",
            "Parallel operations",
            "Canceling operations",
            "Ignoring operations"
        ]
    },
    {
        "q": "concatMap waits for previous inner to _____.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "start",
            "emit",
            "error"
        ]
    },
    {
        "q": "Match use cases:",
        "type": "match",
        "left": [
            "switchMap",
            "mergeMap",
            "concatMap",
            "exhaustMap"
        ],
        "right": [
            "Search autocomplete",
            "Parallel file uploads",
            "Sequential saves",
            "Login button"
        ]
    },
    {
        "q": "What is exhaustMap()?",
        "type": "mcq",
        "o": [
            "Ignores new while previous is active",
            "Cancels previous",
            "Runs parallel",
            "Queues all"
        ]
    },
    {
        "q": "exhaustMap prevents duplicate requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is exhaustMap best for?",
        "type": "mcq",
        "o": [
            "Button clicks that shouldn't queue",
            "Search input",
            "Parallel uploads",
            "Sequential operations"
        ]
    },
    {
        "q": "exhaustMap ignores emissions while _____.",
        "type": "fill_blank",
        "answers": [
            "busy"
        ],
        "other_options": [
            "idle",
            "complete",
            "starting"
        ]
    },
    {
        "q": "Match operator behaviors:",
        "type": "match",
        "left": [
            "Cancels on new",
            "Runs parallel",
            "Queues",
            "Ignores while busy"
        ],
        "right": [
            "switchMap",
            "mergeMap",
            "concatMap",
            "exhaustMap"
        ]
    },
    {
        "q": "What is a Subject?",
        "type": "mcq",
        "o": [
            "Observable and Observer combined",
            "Only Observable",
            "Only Observer",
            "Operator"
        ]
    },
    {
        "q": "Subjects can multicast to multiple subscribers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "const subject = new Subject(); subject.subscribe(console.log); subject.next(1);",
        "o": [
            "Emits 1 to subscriber",
            "Nothing",
            "Error",
            "Creates Observable"
        ]
    },
    {
        "q": "Subject has both subscribe() and _____ methods.",
        "type": "fill_blank",
        "answers": [
            "next"
        ],
        "other_options": [
            "emit",
            "send",
            "push"
        ]
    },
    {
        "q": "Match Subject types:",
        "type": "match",
        "left": [
            "Subject",
            "BehaviorSubject",
            "ReplaySubject",
            "AsyncSubject"
        ],
        "right": [
            "Basic multicast",
            "Last value to new subscribers",
            "N values to new subscribers",
            "Only last on complete"
        ]
    },
    {
        "q": "What is BehaviorSubject?",
        "type": "mcq",
        "o": [
            "Subject with initial/current value",
            "Basic Subject",
            "Replay Subject",
            "Async Subject"
        ]
    },
    {
        "q": "BehaviorSubject requires an initial value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit to new subscriber?",
        "type": "mcq",
        "c": "const bs = new BehaviorSubject(5); bs.next(10); bs.subscribe(console.log);",
        "o": [
            "10 (current value)",
            "5 (initial)",
            "Nothing",
            "5, 10"
        ]
    },
    {
        "q": "BehaviorSubject.getValue() returns _____ value.",
        "type": "fill_blank",
        "answers": [
            "current"
        ],
        "other_options": [
            "initial",
            "first",
            "last"
        ]
    },
    {
        "q": "Rearrange BehaviorSubject usage:",
        "type": "rearrange",
        "words": [
            "Create with initial value",
            "Subscribe to receive current",
            "Call next() to update",
            "New subscribers get latest",
            "Use getValue() for sync access"
        ]
    },
    {
        "q": "What is ReplaySubject?",
        "type": "mcq",
        "o": [
            "Subject that replays past emissions to new subscribers",
            "BehaviorSubject",
            "AsyncSubject",
            "Basic Subject"
        ]
    },
    {
        "q": "ReplaySubject(3) replays last 3 values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does new subscriber receive?",
        "type": "mcq",
        "c": "const rs = new ReplaySubject(2); rs.next(1); rs.next(2); rs.next(3); rs.subscribe(console.log);",
        "o": [
            "2, 3 (last 2 values)",
            "1, 2, 3",
            "3 only",
            "Nothing"
        ]
    },
    {
        "q": "ReplaySubject buffers _____ emissions.",
        "type": "fill_blank",
        "answers": [
            "past"
        ],
        "other_options": [
            "future",
            "current",
            "no"
        ]
    },
    {
        "q": "Match ReplaySubject configs:",
        "type": "match",
        "left": [
            "ReplaySubject()",
            "ReplaySubject(1)",
            "ReplaySubject(3)",
            "ReplaySubject(1, 100)"
        ],
        "right": [
            "Replay all",
            "Like BehaviorSubject",
            "Last 3 values",
            "Last 1 within 100ms"
        ]
    },
    {
        "q": "What is AsyncSubject?",
        "type": "mcq",
        "o": [
            "Emits only last value on complete",
            "Emits all values",
            "Emits first value",
            "Never emits"
        ]
    },
    {
        "q": "AsyncSubject waits for complete().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does subscriber receive?",
        "type": "mcq",
        "c": "const as = new AsyncSubject(); as.next(1); as.next(2); as.complete(); as.subscribe(console.log);",
        "o": [
            "2 (last before complete)",
            "1, 2",
            "1",
            "Nothing"
        ]
    },
    {
        "q": "AsyncSubject emits when _____ is called.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "next",
            "error",
            "subscribe"
        ]
    },
    {
        "q": "Match Subject behaviors:",
        "type": "match",
        "left": [
            "Multicast live values",
            "Current value access",
            "Replay history",
            "Only final value"
        ],
        "right": [
            "Subject",
            "BehaviorSubject",
            "ReplaySubject",
            "AsyncSubject"
        ]
    },
    {
        "q": "What is combineLatest()?",
        "type": "mcq",
        "o": [
            "Combines latest from multiple Observables",
            "Merges all emissions",
            "Concatenates Observables",
            "Races Observables"
        ]
    },
    {
        "q": "combineLatest waits for all sources to emit.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When does combineLatest emit?",
        "type": "mcq",
        "o": [
            "When any source emits (after all have emitted once)",
            "Immediately",
            "Only on complete",
            "Never"
        ]
    },
    {
        "q": "combineLatest emits _____ of latest values.",
        "type": "fill_blank",
        "answers": [
            "array"
        ],
        "other_options": [
            "object",
            "single",
            "first"
        ]
    },
    {
        "q": "Match combination operators:",
        "type": "match",
        "left": [
            "combineLatest",
            "merge",
            "concat",
            "forkJoin"
        ],
        "right": [
            "Latest from each",
            "Interleave emissions",
            "Sequential",
            "Final values"
        ]
    },
    {
        "q": "What is merge()?",
        "type": "mcq",
        "o": [
            "Combines emissions from multiple Observables",
            "Only latest values",
            "Sequential combination",
            "Final values only"
        ]
    },
    {
        "q": "merge preserves emission order.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does merge do?",
        "type": "mcq",
        "c": "merge(of(1), of(2))",
        "o": [
            "Emits 1 and 2 interleaved",
            "Emits [1, 2]",
            "Emits only 2",
            "Waits for both"
        ]
    },
    {
        "q": "merge flattens emissions into _____ stream.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "multiple",
            "nested",
            "array"
        ]
    },
    {
        "q": "Rearrange merge execution:",
        "type": "rearrange",
        "words": [
            "Subscribe to all sources",
            "First source emits",
            "Forward to output",
            "Other sources emit",
            "All interleaved in output"
        ]
    },
    {
        "q": "What is concat()?",
        "type": "mcq",
        "o": [
            "Subscribes to Observables sequentially",
            "Subscribes to all at once",
            "Only latest values",
            "Final values"
        ]
    },
    {
        "q": "concat waits for previous to complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What order does this emit?",
        "type": "mcq",
        "c": "concat(of(1, 2), of(3, 4))",
        "o": [
            "1, 2, 3, 4",
            "1, 3, 2, 4",
            "[1, 2], [3, 4]",
            "4, 3, 2, 1"
        ]
    },
    {
        "q": "concat subscribes to next when previous _____.",
        "type": "fill_blank",
        "answers": [
            "completes"
        ],
        "other_options": [
            "starts",
            "emits",
            "errors"
        ]
    },
    {
        "q": "Match sequential operators:",
        "type": "match",
        "left": [
            "concat",
            "concatMap",
            "concatAll"
        ],
        "right": [
            "Static combination",
            "Project and queue",
            "Flatten sequentially"
        ]
    },
    {
        "q": "What is forkJoin()?",
        "type": "mcq",
        "o": [
            "Emits last values when all complete",
            "Emits first values",
            "Merges all emissions",
            "Emits immediately"
        ]
    },
    {
        "q": "forkJoin is like Promise.all().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does forkJoin return?",
        "type": "mcq",
        "c": "forkJoin([http.get('/a'), http.get('/b')])",
        "o": [
            "Array of final responses",
            "First response",
            "All intermediate values",
            "Nothing until subscribe"
        ]
    },
    {
        "q": "forkJoin waits for all to _____.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "start",
            "emit",
            "subscribe"
        ]
    },
    {
        "q": "Match Promise equivalents:",
        "type": "match",
        "left": [
            "forkJoin",
            "race",
            "from(promise)",
            "toPromise()"
        ],
        "right": [
            "Promise.all()",
            "Promise.race()",
            "Wrap promise",
            "Convert to promise"
        ]
    },
    {
        "q": "What is zip()?",
        "type": "mcq",
        "o": [
            "Pairs values by index from sources",
            "Merges all values",
            "Latest values",
            "Final values"
        ]
    },
    {
        "q": "zip waits for all sources to emit.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "zip(of(1, 2), of('a', 'b'))",
        "o": [
            "[1, 'a'], [2, 'b']",
            "[1, 2, 'a', 'b']",
            "1, 'a', 2, 'b'",
            "[1, 2], ['a', 'b']"
        ]
    },
    {
        "q": "zip pairs values at same _____.",
        "type": "fill_blank",
        "answers": [
            "index"
        ],
        "other_options": [
            "time",
            "type",
            "source"
        ]
    },
    {
        "q": "Match zip behavior:",
        "type": "match",
        "left": [
            "Same index pairing",
            "Waits for pair",
            "Completes early"
        ],
        "right": [
            "First with first",
            "Sync values",
            "Shortest source"
        ]
    },
    {
        "q": "What is race()?",
        "type": "mcq",
        "o": [
            "Uses first Observable to emit",
            "All Observables",
            "Last to emit",
            "Random Observable"
        ]
    },
    {
        "q": "race is like Promise.race().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What happens to losers in race?",
        "type": "mcq",
        "o": [
            "Unsubscribed",
            "Continue emitting",
            "Error",
            "Wait"
        ]
    },
    {
        "q": "race selects the _____ Observable.",
        "type": "fill_blank",
        "answers": [
            "fastest"
        ],
        "other_options": [
            "slowest",
            "first",
            "last"
        ]
    },
    {
        "q": "Match racing patterns:",
        "type": "match",
        "left": [
            "First to emit",
            "Timeout fallback",
            "Fastest API"
        ],
        "right": [
            "race winner",
            "race with timer",
            "race multiple endpoints"
        ]
    },
    {
        "q": "What is withLatestFrom()?",
        "type": "mcq",
        "o": [
            "Combines source with latest from others",
            "Combines latest from all",
            "Merges all",
            "Races sources"
        ]
    },
    {
        "q": "withLatestFrom only emits when source emits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers emission here?",
        "type": "mcq",
        "c": "clicks$.pipe(withLatestFrom(data$))",
        "o": [
            "Click events",
            "Data updates",
            "Either",
            "Neither"
        ]
    },
    {
        "q": "withLatestFrom samples _____ Observables.",
        "type": "fill_blank",
        "answers": [
            "secondary"
        ],
        "other_options": [
            "primary",
            "all",
            "first"
        ]
    },
    {
        "q": "Match with patterns:",
        "type": "match",
        "left": [
            "combineLatest",
            "withLatestFrom",
            "sample"
        ],
        "right": [
            "Any triggers",
            "First triggers",
            "Second triggers"
        ]
    },
    {
        "q": "What is catchError()?",
        "type": "mcq",
        "o": [
            "Handles errors in Observable stream",
            "Throws errors",
            "Ignores errors",
            "Logs errors"
        ]
    },
    {
        "q": "catchError can return replacement Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this handle?",
        "type": "mcq",
        "c": "http.get('/api').pipe(catchError(err => of([])))",
        "o": [
            "Returns empty array on error",
            "Throws error",
            "Retries request",
            "Logs error"
        ]
    },
    {
        "q": "catchError replaces error with _____.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "value",
            "null",
            "Promise"
        ]
    },
    {
        "q": "Match error operators:",
        "type": "match",
        "left": [
            "catchError",
            "retry",
            "retryWhen",
            "throwError"
        ],
        "right": [
            "Handle error",
            "Retry N times",
            "Conditional retry",
            "Create error"
        ]
    },
    {
        "q": "What is retry()?",
        "type": "mcq",
        "o": [
            "Resubscribes on error",
            "Catches error",
            "Ignores error",
            "Throws error"
        ]
    },
    {
        "q": "retry(3) tries up to 3 times.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do on error?",
        "type": "mcq",
        "c": "http.get('/api').pipe(retry(2))",
        "o": [
            "Retries request twice",
            "Tries 2 times total",
            "Catches error",
            "Ignores error"
        ]
    },
    {
        "q": "retry resubscribes to _____ Observable.",
        "type": "fill_blank",
        "answers": [
            "source"
        ],
        "other_options": [
            "new",
            "cached",
            "empty"
        ]
    },
    {
        "q": "Rearrange error handling:",
        "type": "rearrange",
        "words": [
            "Observable errors",
            "retry attempts",
            "Max retries reached",
            "catchError handles",
            "Return fallback"
        ]
    },
    {
        "q": "What is throwError()?",
        "type": "mcq",
        "o": [
            "Creates Observable that errors immediately",
            "Catches errors",
            "Retries on error",
            "Completes"
        ]
    },
    {
        "q": "throwError is useful for testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "throwError(() => new Error('fail'))",
        "o": [
            "Observable that errors with 'fail'",
            "Error object",
            "Empty Observable",
            "Complete Observable"
        ]
    },
    {
        "q": "throwError factory is called _____.",
        "type": "fill_blank",
        "answers": [
            "lazily"
        ],
        "other_options": [
            "eagerly",
            "never",
            "immediately"
        ]
    },
    {
        "q": "Match error creation:",
        "type": "match",
        "left": [
            "throwError",
            "EMPTY",
            "NEVER"
        ],
        "right": [
            "Immediate error",
            "Complete immediately",
            "Never emit"
        ]
    },
    {
        "q": "What is finalize()?",
        "type": "mcq",
        "o": [
            "Runs cleanup on complete or error",
            "On success only",
            "On error only",
            "Never runs"
        ]
    },
    {
        "q": "finalize runs regardless of completion type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is finalize used for?",
        "type": "mcq",
        "c": ".pipe(finalize(() => loading = false))",
        "o": [
            "Cleanup like finally block",
            "Error handling",
            "Value transformation",
            "Filtering"
        ]
    },
    {
        "q": "finalize is like try-finally's _____ block.",
        "type": "fill_blank",
        "answers": [
            "finally"
        ],
        "other_options": [
            "catch",
            "try",
            "throw"
        ]
    },
    {
        "q": "Match cleanup patterns:",
        "type": "match",
        "left": [
            "finalize",
            "tap",
            "catchError"
        ],
        "right": [
            "Always runs",
            "On each value",
            "On error only"
        ]
    },
    {
        "q": "What is share()?",
        "type": "mcq",
        "o": [
            "Shares single subscription among subscribers",
            "Creates new subscription each",
            "Caches values",
            "Completes early"
        ]
    },
    {
        "q": "share prevents duplicate HTTP calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does share help with?",
        "type": "mcq",
        "c": "data$ = http.get('/api').pipe(share())",
        "o": [
            "Multiple subscribers share one request",
            "Caches permanently",
            "Retries on error",
            "Delays request"
        ]
    },
    {
        "q": "share multicasts to _____ subscribers.",
        "type": "fill_blank",
        "answers": [
            "multiple"
        ],
        "other_options": [
            "single",
            "no",
            "cached"
        ]
    },
    {
        "q": "Match sharing operators:",
        "type": "match",
        "left": [
            "share",
            "shareReplay",
            "publish",
            "multicast"
        ],
        "right": [
            "Refcount share",
            "Share with replay",
            "ConnectableObservable",
            "Subject-based"
        ]
    },
    {
        "q": "What is shareReplay()?",
        "type": "mcq",
        "o": [
            "Shares and replays values to late subscribers",
            "Just shares",
            "Just replays",
            "Creates Subject"
        ]
    },
    {
        "q": "shareReplay(1) is common for HTTP caching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does shareReplay(1) do?",
        "type": "mcq",
        "o": [
            "Shares and replays last value",
            "Replays all values",
            "No replay",
            "Caches forever"
        ]
    },
    {
        "q": "shareReplay uses _____ internally.",
        "type": "fill_blank",
        "answers": [
            "ReplaySubject"
        ],
        "other_options": [
            "BehaviorSubject",
            "Subject",
            "AsyncSubject"
        ]
    },
    {
        "q": "Rearrange shareReplay caching:",
        "type": "rearrange",
        "words": [
            "First subscriber triggers request",
            "Response received",
            "Value cached",
            "Late subscriber arrives",
            "Gets cached value"
        ]
    },
    {
        "q": "What is a Scheduler?",
        "type": "mcq",
        "o": [
            "Controls when and how emissions happen",
            "Observable type",
            "Subject type",
            "Operator"
        ]
    },
    {
        "q": "Schedulers control execution timing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does asyncScheduler do?",
        "type": "mcq",
        "o": [
            "Schedules with setTimeout",
            "Runs synchronously",
            "Uses requestAnimationFrame",
            "Runs immediately"
        ]
    },
    {
        "q": "queueScheduler runs tasks _____.",
        "type": "fill_blank",
        "answers": [
            "synchronously"
        ],
        "other_options": [
            "asynchronously",
            "randomly",
            "never"
        ]
    },
    {
        "q": "Match schedulers:",
        "type": "match",
        "left": [
            "asyncScheduler",
            "asapScheduler",
            "queueScheduler",
            "animationFrameScheduler"
        ],
        "right": [
            "setTimeout",
            "Promise microtask",
            "Synchronous queue",
            "requestAnimationFrame"
        ]
    },
    {
        "q": "What is observeOn()?",
        "type": "mcq",
        "o": [
            "Changes scheduler for emissions",
            "Changes scheduler for subscription",
            "Creates Observable",
            "Filters values"
        ]
    },
    {
        "q": "observeOn affects downstream operators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "of(1, 2).pipe(observeOn(asyncScheduler))",
        "o": [
            "Emits values asynchronously",
            "Emits synchronously",
            "Changes source",
            "No effect"
        ]
    },
    {
        "q": "observeOn changes _____ scheduler.",
        "type": "fill_blank",
        "answers": [
            "emission"
        ],
        "other_options": [
            "subscription",
            "creation",
            "all"
        ]
    },
    {
        "q": "Match scheduler operators:",
        "type": "match",
        "left": [
            "observeOn",
            "subscribeOn"
        ],
        "right": [
            "Downstream emissions",
            "Source subscription"
        ]
    },
    {
        "q": "What is subscribeOn()?",
        "type": "mcq",
        "o": [
            "Changes scheduler for subscription",
            "Changes scheduler for emissions",
            "Creates Observable",
            "Unsubscribes"
        ]
    },
    {
        "q": "subscribeOn position doesn't matter in pipe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does subscribeOn affect?",
        "type": "mcq",
        "o": [
            "When source Observable starts",
            "When values are emitted",
            "Nothing",
            "Error handling"
        ]
    },
    {
        "q": "subscribeOn controls _____ timing.",
        "type": "fill_blank",
        "answers": [
            "subscription"
        ],
        "other_options": [
            "emission",
            "completion",
            "error"
        ]
    },
    {
        "q": "Rearrange scheduler effects:",
        "type": "rearrange",
        "words": [
            "subscribeOn sets subscription scheduler",
            "Source subscribes on that scheduler",
            "Emissions start",
            "observeOn changes emission scheduler",
            "Downstream receives on new scheduler"
        ]
    },
    {
        "q": "What is async pipe?",
        "type": "mcq",
        "o": [
            "Subscribes to Observable in template",
            "Creates Observable",
            "Transforms values",
            "Filters values"
        ]
    },
    {
        "q": "async pipe automatically unsubscribes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "{{ data$ | async }}",
        "o": [
            "Subscribes and displays values",
            "Creates Observable",
            "Transforms data",
            "Nothing"
        ]
    },
    {
        "q": "async pipe handles _____ automatically.",
        "type": "fill_blank",
        "answers": [
            "unsubscription"
        ],
        "other_options": [
            "subscription only",
            "errors only",
            "nothing"
        ]
    },
    {
        "q": "Match async pipe features:",
        "type": "match",
        "left": [
            "Auto subscribe",
            "Auto unsubscribe",
            "Change detection",
            "Null handling"
        ],
        "right": [
            "On render",
            "On destroy",
            "Triggers update",
            "Shows nothing"
        ]
    },
    {
        "q": "What is HttpClient Observable?",
        "type": "mcq",
        "o": [
            "Observable that completes after HTTP response",
            "Infinite Observable",
            "Subject",
            "BehaviorSubject"
        ]
    },
    {
        "q": "HttpClient returns cold Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers the HTTP request?",
        "type": "mcq",
        "c": "this.http.get('/api')",
        "o": [
            "Subscription",
            "Method call",
            "Immediately",
            "Never"
        ]
    },
    {
        "q": "HttpClient Observables emit _____ value.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "multiple",
            "no",
            "infinite"
        ]
    },
    {
        "q": "Match HTTP patterns:",
        "type": "match",
        "left": [
            "GET request",
            "POST request",
            "Error handling",
            "Retry logic"
        ],
        "right": [
            "http.get()",
            "http.post()",
            "catchError()",
            "retry()"
        ]
    },
    {
        "q": "What is iif()?",
        "type": "mcq",
        "o": [
            "Conditional Observable selection",
            "Filtering",
            "Transformation",
            "Error handling"
        ]
    },
    {
        "q": "iif evaluates condition at subscription time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this select?",
        "type": "mcq",
        "c": "iif(() => loggedIn, user$, of(null))",
        "o": [
            "user$ if loggedIn, else of(null)",
            "Always user$",
            "Always of(null)",
            "Both"
        ]
    },
    {
        "q": "iif provides _____ Observable selection.",
        "type": "fill_blank",
        "answers": [
            "conditional"
        ],
        "other_options": [
            "random",
            "sequential",
            "parallel"
        ]
    },
    {
        "q": "Match conditional operators:",
        "type": "match",
        "left": [
            "iif",
            "defer"
        ],
        "right": [
            "Choose Observable",
            "Create lazily"
        ]
    },
    {
        "q": "What is defer()?",
        "type": "mcq",
        "o": [
            "Creates Observable lazily at subscription",
            "Creates immediately",
            "Delays emission",
            "Filters values"
        ]
    },
    {
        "q": "defer factory runs on each subscription.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does defer enable?",
        "type": "mcq",
        "c": "defer(() => of(Date.now()))",
        "o": [
            "Fresh value per subscription",
            "Same value",
            "No value",
            "Error"
        ]
    },
    {
        "q": "defer delays Observable _____ until subscribe.",
        "type": "fill_blank",
        "answers": [
            "creation"
        ],
        "other_options": [
            "emission",
            "completion",
            "error"
        ]
    },
    {
        "q": "Match lazy patterns:",
        "type": "match",
        "left": [
            "defer",
            "lazy factory",
            "fresh values"
        ],
        "right": [
            "Create on subscribe",
            "Function wrapper",
            "Per subscription"
        ]
    },
    {
        "q": "What is scan()?",
        "type": "mcq",
        "o": [
            "Accumulates values like reduce but emits each",
            "Final value only",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "scan emits for each source value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this produce?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(scan((acc, val) => acc + val, 0))",
        "o": [
            "1, 3, 6",
            "6",
            "1",
            "1, 2, 3"
        ]
    },
    {
        "q": "scan is like reduce but emits _____.",
        "type": "fill_blank",
        "answers": [
            "incrementally"
        ],
        "other_options": [
            "finally",
            "never",
            "randomly"
        ]
    },
    {
        "q": "Match accumulation operators:",
        "type": "match",
        "left": [
            "scan",
            "reduce",
            "pairwise"
        ],
        "right": [
            "Emit each accumulated",
            "Emit final only",
            "Emit pairs"
        ]
    },
    {
        "q": "What is reduce()?",
        "type": "mcq",
        "o": [
            "Accumulates and emits final value",
            "Emits each accumulation",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "reduce waits for Observable to complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this produce?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(reduce((acc, val) => acc + val, 0))",
        "o": [
            "6",
            "1, 3, 6",
            "1",
            "Nothing"
        ]
    },
    {
        "q": "reduce emits _____ value.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "multiple",
            "no",
            "first"
        ]
    },
    {
        "q": "Match reduce patterns:",
        "type": "match",
        "left": [
            "Sum values",
            "Count values",
            "Max value"
        ],
        "right": [
            "reduce((a,v) => a+v)",
            "reduce((a) => a+1, 0)",
            "reduce((a,v) => Math.max(a,v))"
        ]
    },
    {
        "q": "What is pairwise()?",
        "type": "mcq",
        "o": [
            "Emits pairs of consecutive values",
            "Emits single values",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "pairwise skips first emission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this produce?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(pairwise())",
        "o": [
            "[1,2], [2,3]",
            "[1,2,3]",
            "1, 2, 3",
            "[1], [2], [3]"
        ]
    },
    {
        "q": "pairwise emits previous and _____ values.",
        "type": "fill_blank",
        "answers": [
            "current"
        ],
        "other_options": [
            "next",
            "first",
            "last"
        ]
    },
    {
        "q": "Match pair operators:",
        "type": "match",
        "left": [
            "pairwise",
            "bufferCount(2)"
        ],
        "right": [
            "Sliding window",
            "Non-overlapping"
        ]
    },
    {
        "q": "What is buffer()?",
        "type": "mcq",
        "o": [
            "Collects values until notifier emits",
            "Single values",
            "Pairs of values",
            "Filtered values"
        ]
    },
    {
        "q": "buffer emits arrays of collected values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does buffer emit?",
        "type": "mcq",
        "c": "source$.pipe(buffer(click$))",
        "o": [
            "Array of values since last click",
            "Single value",
            "Click event",
            "Nothing"
        ]
    },
    {
        "q": "buffer collects until _____ emits.",
        "type": "fill_blank",
        "answers": [
            "notifier"
        ],
        "other_options": [
            "source",
            "timer",
            "complete"
        ]
    },
    {
        "q": "Match buffer operators:",
        "type": "match",
        "left": [
            "buffer",
            "bufferCount",
            "bufferTime",
            "bufferWhen"
        ],
        "right": [
            "Until notifier",
            "N values",
            "Time window",
            "Factory"
        ]
    },
    {
        "q": "What is window()?",
        "type": "mcq",
        "o": [
            "Like buffer but emits Observables",
            "Like buffer, emits arrays",
            "Single values",
            "Filtered values"
        ]
    },
    {
        "q": "window creates nested Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does window produce?",
        "type": "mcq",
        "c": "source$.pipe(window(notifier$))",
        "o": [
            "Observable of Observables",
            "Array of values",
            "Single Observable",
            "Nothing"
        ]
    },
    {
        "q": "window emits _____ Observables.",
        "type": "fill_blank",
        "answers": [
            "inner"
        ],
        "other_options": [
            "outer",
            "same",
            "cached"
        ]
    },
    {
        "q": "Match window variants:",
        "type": "match",
        "left": [
            "window",
            "windowCount",
            "windowTime"
        ],
        "right": [
            "Notifier-based",
            "Count-based",
            "Time-based"
        ]
    },
    {
        "q": "What is startWith()?",
        "type": "mcq",
        "o": [
            "Prepends values to Observable",
            "Appends values",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "startWith emits immediately before source.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit first?",
        "type": "mcq",
        "c": "of(2, 3).pipe(startWith(1))",
        "o": [
            "1",
            "2",
            "3",
            "Nothing"
        ]
    },
    {
        "q": "startWith provides _____ value.",
        "type": "fill_blank",
        "answers": [
            "initial"
        ],
        "other_options": [
            "final",
            "filtered",
            "transformed"
        ]
    },
    {
        "q": "Match start/end operators:",
        "type": "match",
        "left": [
            "startWith",
            "endWith",
            "defaultIfEmpty"
        ],
        "right": [
            "Prepend value",
            "Append value",
            "If no emission"
        ]
    },
    {
        "q": "What is endWith()?",
        "type": "mcq",
        "o": [
            "Appends values after source completes",
            "Prepends values",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "endWith emits after source completes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit last?",
        "type": "mcq",
        "c": "of(1, 2).pipe(endWith(3))",
        "o": [
            "3",
            "1",
            "2",
            "Nothing"
        ]
    },
    {
        "q": "endWith provides _____ value.",
        "type": "fill_blank",
        "answers": [
            "final"
        ],
        "other_options": [
            "initial",
            "middle",
            "none"
        ]
    },
    {
        "q": "Rearrange value injection:",
        "type": "rearrange",
        "words": [
            "startWith emits",
            "Source values emit",
            "Source completes",
            "endWith emits",
            "Overall complete"
        ]
    },
    {
        "q": "What is expand()?",
        "type": "mcq",
        "o": [
            "Recursively projects values",
            "Expands array",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "expand can create infinite recursion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is expand used for?",
        "type": "mcq",
        "o": [
            "Recursive API calls",
            "Single request",
            "Filtering",
            "Delaying"
        ]
    },
    {
        "q": "expand emits source and _____ values.",
        "type": "fill_blank",
        "answers": [
            "projected"
        ],
        "other_options": [
            "filtered",
            "first",
            "last"
        ]
    },
    {
        "q": "Match recursive patterns:",
        "type": "match",
        "left": [
            "expand",
            "Pagination",
            "Tree traversal"
        ],
        "right": [
            "Recursive projection",
            "Next page requests",
            "Child node fetching"
        ]
    },
    {
        "q": "What is TestScheduler?",
        "type": "mcq",
        "o": [
            "Testing utility for time-based Observables",
            "Production scheduler",
            "Async scheduler",
            "Queue scheduler"
        ]
    },
    {
        "q": "TestScheduler uses marble testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does TestScheduler enable?",
        "type": "mcq",
        "o": [
            "Synchronous time-based testing",
            "Slower tests",
            "Async tests only",
            "No time control"
        ]
    },
    {
        "q": "Marble testing uses _____ notation.",
        "type": "fill_blank",
        "answers": [
            "string"
        ],
        "other_options": [
            "number",
            "object",
            "array"
        ]
    },
    {
        "q": "Match marble symbols:",
        "type": "match",
        "left": [
            "-",
            "a-z",
            "|",
            "#"
        ],
        "right": [
            "Time frame",
            "Values",
            "Complete",
            "Error"
        ]
    },
    {
        "q": "What is cold Observable in marble testing?",
        "type": "mcq",
        "o": [
            "Starts when subscribed",
            "Already running",
            "Hot Observable",
            "Subject"
        ]
    },
    {
        "q": "cold('-a-b|') emits a, then b, then completes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this marble represent?",
        "type": "mcq",
        "c": "--a--b--|",
        "o": [
            "2 frames, a, 2 frames, b, 2 frames, complete",
            "Immediate a and b",
            "Error after b",
            "Never completes"
        ]
    },
    {
        "q": "cold() creates Observable from _____ diagram.",
        "type": "fill_blank",
        "answers": [
            "marble"
        ],
        "other_options": [
            "code",
            "array",
            "function"
        ]
    },
    {
        "q": "Match marble testing methods:",
        "type": "match",
        "left": [
            "cold",
            "hot",
            "expectObservable",
            "flush"
        ],
        "right": [
            "Cold Observable",
            "Hot Observable",
            "Assert output",
            "Execute"
        ]
    },
    {
        "q": "What is hot Observable in marble testing?",
        "type": "mcq",
        "o": [
            "Already emitting before subscription",
            "Starts on subscribe",
            "Cold Observable",
            "Never emits"
        ]
    },
    {
        "q": "hot('-^-a-b-|') uses ^ for subscription point.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ^ mean in hot marbles?",
        "type": "mcq",
        "o": [
            "Subscription point",
            "Emission",
            "Complete",
            "Error"
        ]
    },
    {
        "q": "hot() simulates _____ Observables.",
        "type": "fill_blank",
        "answers": [
            "shared"
        ],
        "other_options": [
            "cold",
            "cached",
            "delayed"
        ]
    },
    {
        "q": "Match testing concepts:",
        "type": "match",
        "left": [
            "Cold",
            "Hot",
            "^",
            "!"
        ],
        "right": [
            "Subscription starts",
            "Already running",
            "Subscribe point",
            "Unsubscribe point"
        ]
    },
    {
        "q": "What is toArray()?",
        "type": "mcq",
        "o": [
            "Collects all values into array on complete",
            "Emits each as array",
            "Filters to array",
            "Single value"
        ]
    },
    {
        "q": "toArray waits for completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(toArray())",
        "o": [
            "[1, 2, 3]",
            "1, 2, 3",
            "6",
            "Nothing"
        ]
    },
    {
        "q": "toArray collects until source _____.",
        "type": "fill_blank",
        "answers": [
            "completes"
        ],
        "other_options": [
            "starts",
            "errors",
            "subscribes"
        ]
    },
    {
        "q": "Match collection operators:",
        "type": "match",
        "left": [
            "toArray",
            "buffer",
            "reduce"
        ],
        "right": [
            "All to array",
            "Chunks to arrays",
            "Accumulate value"
        ]
    },
    {
        "q": "What is custom operator?",
        "type": "mcq",
        "o": [
            "User-defined reusable pipe function",
            "Built-in operator",
            "Subject",
            "Observable"
        ]
    },
    {
        "q": "Custom operators return functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern is this?",
        "type": "mcq",
        "c": "const myOp = () => pipe(filter(...), map(...))",
        "o": [
            "Custom operator factory",
            "Built-in operator",
            "Subject",
            "Observer"
        ]
    },
    {
        "q": "Custom operators compose _____ operators.",
        "type": "fill_blank",
        "answers": [
            "existing"
        ],
        "other_options": [
            "new",
            "no",
            "all"
        ]
    },
    {
        "q": "Match operator patterns:",
        "type": "match",
        "left": [
            "Simple composition",
            "Configurable",
            "Stateful"
        ],
        "right": [
            "pipe(op1, op2)",
            "Factory function",
            "Closure variables"
        ]
    },
    {
        "q": "What is partition()?",
        "type": "mcq",
        "o": [
            "Splits Observable into two by predicate",
            "Merges two Observables",
            "Filters values",
            "Takes values"
        ]
    },
    {
        "q": "partition returns two Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does partition produce?",
        "type": "mcq",
        "c": "const [even$, odd$] = partition(nums$, x => x % 2 === 0)",
        "o": [
            "Even and odd number streams",
            "Single stream",
            "Error",
            "Array"
        ]
    },
    {
        "q": "partition creates true and _____ streams.",
        "type": "fill_blank",
        "answers": [
            "false"
        ],
        "other_options": [
            "null",
            "undefined",
            "error"
        ]
    },
    {
        "q": "Match splitting operators:",
        "type": "match",
        "left": [
            "partition",
            "groupBy"
        ],
        "right": [
            "Two streams",
            "Multiple group streams"
        ]
    },
    {
        "q": "What is groupBy()?",
        "type": "mcq",
        "o": [
            "Groups values into keyed Observables",
            "Single stream",
            "Two streams",
            "Filters"
        ]
    },
    {
        "q": "groupBy creates Observable of GroupedObservables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does groupBy emit?",
        "type": "mcq",
        "c": "users$.pipe(groupBy(u => u.role))",
        "o": [
            "Observables grouped by role",
            "Single stream",
            "Array",
            "Object"
        ]
    },
    {
        "q": "groupBy creates _____ grouped streams.",
        "type": "fill_blank",
        "answers": [
            "keyed"
        ],
        "other_options": [
            "unkeyed",
            "single",
            "no"
        ]
    },
    {
        "q": "Rearrange groupBy processing:",
        "type": "rearrange",
        "words": [
            "Source emits value",
            "Key extracted",
            "Check existing group",
            "Create or use group Observable",
            "Value emitted to group"
        ]
    },
    {
        "q": "What is using() operator?",
        "type": "mcq",
        "o": [
            "Creates disposable resource with Observable",
            "Creates Observable",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "using() cleans up resource on complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is using() useful for?",
        "type": "mcq",
        "o": [
            "Resource lifecycle management",
            "Value transformation",
            "Filtering",
            "Rate limiting"
        ]
    },
    {
        "q": "using() manages resource _____.",
        "type": "fill_blank",
        "answers": [
            "lifecycle"
        ],
        "other_options": [
            "values",
            "errors",
            "types"
        ]
    },
    {
        "q": "Match resource patterns:",
        "type": "match",
        "left": [
            "using",
            "finalize",
            "takeUntil"
        ],
        "right": [
            "Disposable resource",
            "Cleanup callback",
            "Completion trigger"
        ]
    },
    {
        "q": "What is connect()?",
        "type": "mcq",
        "o": [
            "Shares source with manual control",
            "Creates connection",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "connect() provides more control than share().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does connect enable?",
        "type": "mcq",
        "o": [
            "Multiple subscribers with shared source",
            "Single subscriber",
            "No sharing",
            "Cold Observable"
        ]
    },
    {
        "q": "connect() creates _____ subscription.",
        "type": "fill_blank",
        "answers": [
            "shared"
        ],
        "other_options": [
            "individual",
            "no",
            "cached"
        ]
    },
    {
        "q": "Match connect patterns:",
        "type": "match",
        "left": [
            "connect",
            "share",
            "shareReplay"
        ],
        "right": [
            "Manual multicast",
            "Auto refcount",
            "With replay"
        ]
    },
    {
        "q": "What is connectable()?",
        "type": "mcq",
        "o": [
            "Creates manually connectable Observable",
            "Auto-connecting",
            "Cold Observable",
            "Hot Observable"
        ]
    },
    {
        "q": "connectable requires explicit connect() call.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern does connectable support?",
        "type": "mcq",
        "o": [
            "Wait for all subscribers before starting",
            "Start immediately",
            "Cold per subscriber",
            "No sharing"
        ]
    },
    {
        "q": "connectable delays emissions until _____.",
        "type": "fill_blank",
        "answers": [
            "connected"
        ],
        "other_options": [
            "subscribed",
            "completed",
            "errored"
        ]
    },
    {
        "q": "Match connectable methods:",
        "type": "match",
        "left": [
            "connect()",
            "refCount()"
        ],
        "right": [
            "Manual start",
            "Auto connect/disconnect"
        ]
    },
    {
        "q": "What is memory leak in RxJS?",
        "type": "mcq",
        "o": [
            "Unsubscribed subscriptions holding references",
            "Too many values",
            "Large Observable",
            "Error handling"
        ]
    },
    {
        "q": "Subscriptions should be cleaned up.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What causes this memory leak?",
        "type": "mcq",
        "c": "interval(1000).subscribe(x => this.data = x);",
        "o": [
            "Infinite subscription never unsubscribed",
            "Too fast interval",
            "Assignment",
            "No leak"
        ]
    },
    {
        "q": "Memory leaks occur from _____ subscriptions.",
        "type": "fill_blank",
        "answers": [
            "unclosed"
        ],
        "other_options": [
            "closed",
            "completed",
            "errored"
        ]
    },
    {
        "q": "Match leak prevention:",
        "type": "match",
        "left": [
            "takeUntil",
            "async pipe",
            "take(1)",
            "finalize"
        ],
        "right": [
            "Destroy trigger",
            "Auto cleanup",
            "Complete after one",
            "Cleanup callback"
        ]
    },
    {
        "q": "What is DestroyRef?",
        "type": "mcq",
        "o": [
            "Angular cleanup hook for subscriptions",
            "Observable",
            "Operator",
            "Subject"
        ]
    },
    {
        "q": "DestroyRef simplifies unsubscription.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does takeUntilDestroyed() do?",
        "type": "mcq",
        "c": "data$.pipe(takeUntilDestroyed())",
        "o": [
            "Completes when component destroys",
            "Never completes",
            "Errors",
            "Nothing"
        ]
    },
    {
        "q": "takeUntilDestroyed uses _____ internally.",
        "type": "fill_blank",
        "answers": [
            "DestroyRef"
        ],
        "other_options": [
            "Subject",
            "Observable",
            "Operator"
        ]
    },
    {
        "q": "Rearrange cleanup pattern:",
        "type": "rearrange",
        "words": [
            "Inject DestroyRef",
            "Use takeUntilDestroyed()",
            "Subscribe to Observable",
            "Component destroyed",
            "Subscription cleaned"
        ]
    },
    {
        "q": "What is toSignal()?",
        "type": "mcq",
        "o": [
            "Converts Observable to Signal",
            "Creates Observable",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "toSignal auto-subscribes to Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "const data = toSignal(data$);",
        "o": [
            "Signal from Observable values",
            "Observable",
            "Subject",
            "Array"
        ]
    },
    {
        "q": "toSignal requires _____ context.",
        "type": "fill_blank",
        "answers": [
            "injection"
        ],
        "other_options": [
            "subscription",
            "template",
            "module"
        ]
    },
    {
        "q": "Match signal utilities:",
        "type": "match",
        "left": [
            "toSignal",
            "toObservable",
            "computed",
            "effect"
        ],
        "right": [
            "Observable to signal",
            "Signal to observable",
            "Derived signal",
            "Side effect"
        ]
    },
    {
        "q": "What is toObservable()?",
        "type": "mcq",
        "o": [
            "Converts Signal to Observable",
            "Creates Signal",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "toObservable emits on signal changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "const data$ = toObservable(dataSignal);",
        "o": [
            "Observable from signal changes",
            "Signal",
            "Subject",
            "Array"
        ]
    },
    {
        "q": "toObservable bridges signals to _____.",
        "type": "fill_blank",
        "answers": [
            "RxJS"
        ],
        "other_options": [
            "Angular",
            "Promises",
            "Arrays"
        ]
    },
    {
        "q": "Match interop patterns:",
        "type": "match",
        "left": [
            "toSignal",
            "toObservable",
            "async pipe"
        ],
        "right": [
            "Observable -> Signal",
            "Signal -> Observable",
            "Observable -> template"
        ]
    },
    {
        "q": "What is firstValueFrom()?",
        "type": "mcq",
        "o": [
            "Converts Observable to Promise of first value",
            "Observable of first",
            "Filter first",
            "Take first"
        ]
    },
    {
        "q": "firstValueFrom returns a Promise.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this return?",
        "type": "mcq",
        "c": "await firstValueFrom(data$);",
        "o": [
            "First emitted value",
            "All values",
            "Observable",
            "Subscription"
        ]
    },
    {
        "q": "firstValueFrom rejects if Observable _____ empty.",
        "type": "fill_blank",
        "answers": [
            "completes"
        ],
        "other_options": [
            "starts",
            "subscribes",
            "emits"
        ]
    },
    {
        "q": "Match Promise conversion:",
        "type": "match",
        "left": [
            "firstValueFrom",
            "lastValueFrom",
            "from(promise)"
        ],
        "right": [
            "First to Promise",
            "Last to Promise",
            "Promise to Observable"
        ]
    },
    {
        "q": "What is lastValueFrom()?",
        "type": "mcq",
        "o": [
            "Converts Observable to Promise of last value",
            "Observable of last",
            "Filter last",
            "Take last"
        ]
    },
    {
        "q": "lastValueFrom waits for completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does lastValueFrom return?",
        "type": "mcq",
        "o": [
            "Last emitted value as Promise",
            "First value",
            "All values",
            "Nothing"
        ]
    },
    {
        "q": "lastValueFrom resolves on _____.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "first",
            "error",
            "subscribe"
        ]
    },
    {
        "q": "Match async patterns:",
        "type": "match",
        "left": [
            "async/await",
            "firstValueFrom",
            "Observable"
        ],
        "right": [
            "Promise syntax",
            "Bridge to Promise",
            "Stream"
        ]
    },
    {
        "q": "What is audit()?",
        "type": "mcq",
        "o": [
            "Emits source value when notifier emits",
            "Filters values",
            "Maps values",
            "Takes values"
        ]
    },
    {
        "q": "audit ignores source until notifier emits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does audit sample?",
        "type": "mcq",
        "c": "source$.pipe(audit(() => interval(1000)))",
        "o": [
            "Source value when interval emits",
            "All source values",
            "Interval values",
            "Nothing"
        ]
    },
    {
        "q": "audit emits _____ source value in window.",
        "type": "fill_blank",
        "answers": [
            "last"
        ],
        "other_options": [
            "first",
            "all",
            "no"
        ]
    },
    {
        "q": "Match sampling:",
        "type": "match",
        "left": [
            "audit",
            "sample",
            "throttle"
        ],
        "right": [
            "Notifier-based last",
            "Notifier samples",
            "First in window"
        ]
    },
    {
        "q": "What is sample()?",
        "type": "mcq",
        "o": [
            "Emits latest source when notifier emits",
            "All values",
            "First value",
            "Filtered values"
        ]
    },
    {
        "q": "sample is triggered by notifier.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers emission here?",
        "type": "mcq",
        "c": "data$.pipe(sample(click$))",
        "o": [
            "Click events sample data",
            "Data triggers",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "sample emits _____ value on trigger.",
        "type": "fill_blank",
        "answers": [
            "latest"
        ],
        "other_options": [
            "first",
            "all",
            "none"
        ]
    },
    {
        "q": "Match sample patterns:",
        "type": "match",
        "left": [
            "sample(click$)",
            "sampleTime(1000)"
        ],
        "right": [
            "Sample on click",
            "Sample every 1s"
        ]
    },
    {
        "q": "What is throttle()?",
        "type": "mcq",
        "o": [
            "Emits first value then waits",
            "Emits all values",
            "Emits last value",
            "Filters values"
        ]
    },
    {
        "q": "throttle emits immediately then waits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does throttle control?",
        "type": "mcq",
        "o": [
            "Rate of emissions",
            "Value transformation",
            "Error handling",
            "Completion"
        ]
    },
    {
        "q": "throttle emits _____ in window.",
        "type": "fill_blank",
        "answers": [
            "first"
        ],
        "other_options": [
            "last",
            "all",
            "none"
        ]
    },
    {
        "q": "Match rate limiting:",
        "type": "match",
        "left": [
            "throttle",
            "debounce",
            "audit"
        ],
        "right": [
            "First value",
            "After silence",
            "Last value"
        ]
    },
    {
        "q": "What is materialize()?",
        "type": "mcq",
        "o": [
            "Wraps values, error, complete in Notifications",
            "Unwraps Notifications",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "materialize converts events to data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does materialize produce?",
        "type": "mcq",
        "o": [
            "Notification objects with kind, value, error",
            "Plain values",
            "Errors only",
            "Nothing"
        ]
    },
    {
        "q": "materialize never _____ itself.",
        "type": "fill_blank",
        "answers": [
            "errors"
        ],
        "other_options": [
            "emits",
            "completes",
            "subscribes"
        ]
    },
    {
        "q": "Match meta operators:",
        "type": "match",
        "left": [
            "materialize",
            "dematerialize"
        ],
        "right": [
            "Events to data",
            "Data to events"
        ]
    },
    {
        "q": "What is dematerialize()?",
        "type": "mcq",
        "o": [
            "Unwraps Notifications to values/error/complete",
            "Wraps in Notifications",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "dematerialize reverses materialize.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does dematerialize restore?",
        "type": "mcq",
        "o": [
            "Original Observable behavior",
            "Notifications",
            "Arrays",
            "Objects"
        ]
    },
    {
        "q": "dematerialize converts Notifications to _____.",
        "type": "fill_blank",
        "answers": [
            "events"
        ],
        "other_options": [
            "data",
            "objects",
            "arrays"
        ]
    },
    {
        "q": "Rearrange materialize round-trip:",
        "type": "rearrange",
        "words": [
            "Source emits/errors/completes",
            "materialize wraps in Notifications",
            "Process Notifications as data",
            "dematerialize unwraps",
            "Original behavior restored"
        ]
    },
    {
        "q": "What is repeat()?",
        "type": "mcq",
        "o": [
            "Resubscribes when source completes",
            "Repeats values",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "repeat(3) resubscribes 3 times.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "of(1, 2).pipe(repeat(2))",
        "o": [
            "Emits 1, 2, 1, 2",
            "Emits 1, 2",
            "Emits 1, 1, 2, 2",
            "Nothing"
        ]
    },
    {
        "q": "repeat resubscribes on _____.",
        "type": "fill_blank",
        "answers": [
            "complete"
        ],
        "other_options": [
            "error",
            "subscribe",
            "emit"
        ]
    },
    {
        "q": "Match repeat patterns:",
        "type": "match",
        "left": [
            "repeat()",
            "repeat(3)",
            "repeatWhen"
        ],
        "right": [
            "Infinite repeat",
            "3 times",
            "Conditional"
        ]
    },
    {
        "q": "What is delay()?",
        "type": "mcq",
        "o": [
            "Delays each emission by time",
            "Delays subscription",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "delay affects all emissions equally.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this do?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(delay(1000))",
        "o": [
            "Delays all values by 1s",
            "Waits 1s between values",
            "No delay",
            "Errors"
        ]
    },
    {
        "q": "delay shifts emissions by _____ amount.",
        "type": "fill_blank",
        "answers": [
            "fixed"
        ],
        "other_options": [
            "variable",
            "random",
            "no"
        ]
    },
    {
        "q": "Match delay operators:",
        "type": "match",
        "left": [
            "delay",
            "delayWhen"
        ],
        "right": [
            "Fixed delay",
            "Per-value delay"
        ]
    },
    {
        "q": "What is delayWhen()?",
        "type": "mcq",
        "o": [
            "Delays each value by notifier Observable",
            "Fixed delay",
            "No delay",
            "Filters values"
        ]
    },
    {
        "q": "delayWhen provides per-value delays.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What controls delay here?",
        "type": "mcq",
        "c": "source$.pipe(delayWhen(val => timer(val * 100)))",
        "o": [
            "Value-based timer",
            "Fixed time",
            "Random",
            "Nothing"
        ]
    },
    {
        "q": "delayWhen waits for notifier to _____.",
        "type": "fill_blank",
        "answers": [
            "emit"
        ],
        "other_options": [
            "complete",
            "error",
            "subscribe"
        ]
    },
    {
        "q": "Match delay patterns:",
        "type": "match",
        "left": [
            "delay(1000)",
            "delayWhen(x => timer(x))"
        ],
        "right": [
            "All 1s delay",
            "Variable delay"
        ]
    },
    {
        "q": "What is timeout()?",
        "type": "mcq",
        "o": [
            "Errors if no emission within time",
            "Delays emission",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "timeout can provide fallback Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What happens if timeout triggers?",
        "type": "mcq",
        "c": "http.get('/api').pipe(timeout(5000))",
        "o": [
            "TimeoutError if >5s",
            "Retry",
            "Nothing",
            "Complete"
        ]
    },
    {
        "q": "timeout throws _____ on expiry.",
        "type": "fill_blank",
        "answers": [
            "TimeoutError"
        ],
        "other_options": [
            "Error",
            "Nothing",
            "Complete"
        ]
    },
    {
        "q": "Match timeout config:",
        "type": "match",
        "left": [
            "first",
            "each",
            "with"
        ],
        "right": [
            "Initial timeout",
            "Between emissions",
            "Fallback Observable"
        ]
    },
    {
        "q": "What is defaultIfEmpty()?",
        "type": "mcq",
        "o": [
            "Emits default if source completes empty",
            "Always emits default",
            "Filters values",
            "Maps values"
        ]
    },
    {
        "q": "defaultIfEmpty only acts on empty completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "EMPTY.pipe(defaultIfEmpty('none'))",
        "o": [
            "'none'",
            "Nothing",
            "undefined",
            "null"
        ]
    },
    {
        "q": "defaultIfEmpty provides _____ value.",
        "type": "fill_blank",
        "answers": [
            "fallback"
        ],
        "other_options": [
            "first",
            "last",
            "all"
        ]
    },
    {
        "q": "Match empty handling:",
        "type": "match",
        "left": [
            "defaultIfEmpty",
            "throwIfEmpty"
        ],
        "right": [
            "Emit default",
            "Error if empty"
        ]
    },
    {
        "q": "What is isEmpty()?",
        "type": "mcq",
        "o": [
            "Emits boolean if source was empty",
            "Filters empty",
            "Maps values",
            "Takes values"
        ]
    },
    {
        "q": "isEmpty emits true only if source completes without emission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1).pipe(isEmpty())",
        "o": [
            "false",
            "true",
            "1",
            "Nothing"
        ]
    },
    {
        "q": "isEmpty emits _____ on first source value.",
        "type": "fill_blank",
        "answers": [
            "false"
        ],
        "other_options": [
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Match empty checks:",
        "type": "match",
        "left": [
            "isEmpty",
            "count"
        ],
        "right": [
            "Boolean result",
            "Number of emissions"
        ]
    },
    {
        "q": "What is count()?",
        "type": "mcq",
        "o": [
            "Counts emissions and emits count on complete",
            "Emits each count",
            "Filters by count",
            "Takes by count"
        ]
    },
    {
        "q": "count emits single number on complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(count())",
        "o": [
            "3",
            "6",
            "1, 2, 3",
            "Nothing"
        ]
    },
    {
        "q": "count with predicate counts _____ matches.",
        "type": "fill_blank",
        "answers": [
            "only"
        ],
        "other_options": [
            "all",
            "no",
            "first"
        ]
    },
    {
        "q": "Match counting patterns:",
        "type": "match",
        "left": [
            "count()",
            "count(x => x > 5)"
        ],
        "right": [
            "All values",
            "Matching only"
        ]
    },
    {
        "q": "What is min()?",
        "type": "mcq",
        "o": [
            "Emits minimum value on complete",
            "Filters minimum",
            "All values",
            "First value"
        ]
    },
    {
        "q": "min waits for completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(5, 2, 8).pipe(min())",
        "o": [
            "2",
            "5",
            "8",
            "15"
        ]
    },
    {
        "q": "min with comparer supports _____ types.",
        "type": "fill_blank",
        "answers": [
            "custom"
        ],
        "other_options": [
            "number",
            "string",
            "date"
        ]
    },
    {
        "q": "Match aggregate operators:",
        "type": "match",
        "left": [
            "min",
            "max",
            "count",
            "reduce"
        ],
        "right": [
            "Minimum value",
            "Maximum value",
            "Total count",
            "Custom accumulator"
        ]
    },
    {
        "q": "What is max()?",
        "type": "mcq",
        "o": [
            "Emits maximum value on complete",
            "Filters maximum",
            "All values",
            "Last value"
        ]
    },
    {
        "q": "max compares values to find largest.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(5, 2, 8).pipe(max())",
        "o": [
            "8",
            "5",
            "2",
            "15"
        ]
    },
    {
        "q": "max emits _____ value on complete.",
        "type": "fill_blank",
        "answers": [
            "largest"
        ],
        "other_options": [
            "smallest",
            "first",
            "last"
        ]
    },
    {
        "q": "Rearrange aggregate flow:",
        "type": "rearrange",
        "words": [
            "Source starts emitting",
            "Track aggregate value",
            "Each emission updates track",
            "Source completes",
            "Emit final aggregate"
        ]
    },
    {
        "q": "What is every()?",
        "type": "mcq",
        "o": [
            "Checks if all values pass predicate",
            "Filters values",
            "Maps values",
            "Takes values"
        ]
    },
    {
        "q": "every emits false immediately on failure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(2, 4, 6).pipe(every(x => x % 2 === 0))",
        "o": [
            "true",
            "false",
            "2, 4, 6",
            "Nothing"
        ]
    },
    {
        "q": "every returns true only if _____ match.",
        "type": "fill_blank",
        "answers": [
            "all"
        ],
        "other_options": [
            "some",
            "none",
            "first"
        ]
    },
    {
        "q": "Match boolean operators:",
        "type": "match",
        "left": [
            "every",
            "find",
            "findIndex"
        ],
        "right": [
            "All match",
            "First match value",
            "First match index"
        ]
    },
    {
        "q": "What is find()?",
        "type": "mcq",
        "o": [
            "Emits first value matching predicate",
            "All matching",
            "Index of match",
            "Boolean"
        ]
    },
    {
        "q": "find completes after first match.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(find(x => x > 1))",
        "o": [
            "2",
            "3",
            "2, 3",
            "true"
        ]
    },
    {
        "q": "find is like filter but takes _____.",
        "type": "fill_blank",
        "answers": [
            "one"
        ],
        "other_options": [
            "all",
            "none",
            "last"
        ]
    },
    {
        "q": "Match find operators:",
        "type": "match",
        "left": [
            "find",
            "findIndex",
            "first with predicate"
        ],
        "right": [
            "Match value",
            "Match position",
            "First matching"
        ]
    },
    {
        "q": "What is findIndex()?",
        "type": "mcq",
        "o": [
            "Emits index of first matching value",
            "Value itself",
            "All indices",
            "Boolean"
        ]
    },
    {
        "q": "findIndex emits -1 if no match.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "of('a', 'b', 'c').pipe(findIndex(x => x === 'b'))",
        "o": [
            "1",
            "0",
            "'b'",
            "true"
        ]
    },
    {
        "q": "findIndex returns _____ of first match.",
        "type": "fill_blank",
        "answers": [
            "position"
        ],
        "other_options": [
            "value",
            "boolean",
            "count"
        ]
    },
    {
        "q": "Match index patterns:",
        "type": "match",
        "left": [
            "findIndex",
            "elementAt"
        ],
        "right": [
            "Find position",
            "Get at position"
        ]
    },
    {
        "q": "What is RxJS best practice for subscriptions?",
        "type": "mcq",
        "o": [
            "Always unsubscribe when done",
            "Never unsubscribe",
            "Let garbage collect",
            "Ignore subscriptions"
        ]
    },
    {
        "q": "Prefer async pipe over manual subscribe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should you avoid?",
        "type": "mcq",
        "o": [
            "Nested subscriptions",
            "Using operators",
            "Using pipe()",
            "Using async pipe"
        ]
    },
    {
        "q": "Use _____ operators instead of nested subscribes.",
        "type": "fill_blank",
        "answers": [
            "flattening"
        ],
        "other_options": [
            "filtering",
            "transformation",
            "creation"
        ]
    },
    {
        "q": "Match best practices:",
        "type": "match",
        "left": [
            "async pipe",
            "takeUntil",
            "shareReplay",
            "distinctUntilChanged"
        ],
        "right": [
            "Auto unsubscribe",
            "Destroy cleanup",
            "Caching",
            "Prevent duplicates"
        ]
    },
    {
        "q": "What is Observable naming convention?",
        "type": "mcq",
        "o": [
            "Suffix with $",
            "Prefix with obs_",
            "No convention",
            "Suffix with _observable"
        ]
    },
    {
        "q": "data$ clearly indicates Observable type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does $ suffix indicate?",
        "type": "mcq",
        "c": "const users$ = this.http.get('/users');",
        "o": [
            "Observable stream",
            "Array",
            "Promise",
            "Subject"
        ]
    },
    {
        "q": "$ convention improves code _____.",
        "type": "fill_blank",
        "answers": [
            "readability"
        ],
        "other_options": [
            "performance",
            "security",
            "speed"
        ]
    },
    {
        "q": "Match naming:",
        "type": "match",
        "left": [
            "data$",
            "data",
            "getData()"
        ],
        "right": [
            "Observable",
            "Plain value",
            "Method"
        ]
    },
    {
        "q": "What is pure function in RxJS?",
        "type": "mcq",
        "o": [
            "Function with no side effects",
            "Impure function",
            "Side effect handler",
            "Mutation"
        ]
    },
    {
        "q": "Operators should use pure functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What makes this impure?",
        "type": "mcq",
        "c": "map(x => { this.count++; return x * 2; })",
        "o": [
            "Modifies external state",
            "Returns value",
            "Pure transformation",
            "Nothing"
        ]
    },
    {
        "q": "Pure functions make code _____.",
        "type": "fill_blank",
        "answers": [
            "predictable"
        ],
        "other_options": [
            "slower",
            "complex",
            "impure"
        ]
    },
    {
        "q": "Match purity patterns:",
        "type": "match",
        "left": [
            "Pure map",
            "Side effect",
            "State mutation"
        ],
        "right": [
            "Transform only",
            "Use tap()",
            "Avoid"
        ]
    },
    {
        "q": "What is Observable typing?",
        "type": "mcq",
        "o": [
            "TypeScript generics for Observable values",
            "No typing",
            "Any typing",
            "String typing"
        ]
    },
    {
        "q": "Observable<User[]> specifies User array type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this type?",
        "type": "mcq",
        "c": "Observable<{ id: number; name: string }>",
        "o": [
            "Object with id and name",
            "Any object",
            "Array",
            "String"
        ]
    },
    {
        "q": "Generics provide _____ safety.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "runtime",
            "memory",
            "performance"
        ]
    },
    {
        "q": "Match typed patterns:",
        "type": "match",
        "left": [
            "Observable<T>",
            "Subject<T>",
            "BehaviorSubject<T>"
        ],
        "right": [
            "Typed stream",
            "Typed multicast",
            "Typed with initial"
        ]
    },
    {
        "q": "What is error handling strategy?",
        "type": "mcq",
        "o": [
            "Handling errors at appropriate level",
            "Ignore errors",
            "Let errors propagate",
            "Log only"
        ]
    },
    {
        "q": "catchError should return fallback Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the pattern here?",
        "type": "mcq",
        "c": ".pipe(retry(3), catchError(err => of([])))",
        "o": [
            "Retry then fallback",
            "Fail immediately",
            "Infinite retry",
            "Ignore error"
        ]
    },
    {
        "q": "Errors should be handled at _____ level.",
        "type": "fill_blank",
        "answers": [
            "appropriate"
        ],
        "other_options": [
            "top",
            "bottom",
            "any"
        ]
    },
    {
        "q": "Match error strategies:",
        "type": "match",
        "left": [
            "retry",
            "catchError",
            "throwError"
        ],
        "right": [
            "Retry attempts",
            "Handle gracefully",
            "Propagate error"
        ]
    },
    {
        "q": "What is cold vs hot Observable?",
        "type": "mcq",
        "o": [
            "Cold: per-subscriber, Hot: shared",
            "Cold: shared, Hot: per-subscriber",
            "No difference",
            "Cold: error, Hot: success"
        ]
    },
    {
        "q": "HttpClient returns cold Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is typically hot?",
        "type": "mcq",
        "o": [
            "FromEvent clicks",
            "of() values",
            "HTTP request",
            "interval()"
        ]
    },
    {
        "q": "Cold Observables execute _____ subscribe.",
        "type": "fill_blank",
        "answers": [
            "per"
        ],
        "other_options": [
            "once",
            "never",
            "before"
        ]
    },
    {
        "q": "Match hot/cold:",
        "type": "match",
        "left": [
            "of()",
            "fromEvent()",
            "http.get()",
            "Subject"
        ],
        "right": [
            "Cold",
            "Hot",
            "Cold",
            "Hot"
        ]
    },
    {
        "q": "What is backpressure?",
        "type": "mcq",
        "o": [
            "When consumer is slower than producer",
            "Fast consumer",
            "No data",
            "Error handling"
        ]
    },
    {
        "q": "Buffering can help with backpressure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What handles backpressure?",
        "type": "mcq",
        "o": [
            "buffer, throttle, debounce",
            "map, filter",
            "switchMap only",
            "Nothing"
        ]
    },
    {
        "q": "Backpressure occurs when emissions are too _____.",
        "type": "fill_blank",
        "answers": [
            "fast"
        ],
        "other_options": [
            "slow",
            "few",
            "large"
        ]
    },
    {
        "q": "Match backpressure strategies:",
        "type": "match",
        "left": [
            "buffer",
            "throttle",
            "sample",
            "debounce"
        ],
        "right": [
            "Collect",
            "Limit rate",
            "Latest on trigger",
            "After pause"
        ]
    },
    {
        "q": "What is fromEvent()?",
        "type": "mcq",
        "o": [
            "Creates Observable from DOM events",
            "Creates DOM element",
            "Filters events",
            "Maps events"
        ]
    },
    {
        "q": "fromEvent creates hot Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this observe?",
        "type": "mcq",
        "c": "fromEvent(document, 'click')",
        "o": [
            "All document clicks",
            "Single click",
            "Click elements",
            "Nothing"
        ]
    },
    {
        "q": "fromEvent automatically manages event _____.",
        "type": "fill_blank",
        "answers": [
            "listeners"
        ],
        "other_options": [
            "handlers",
            "callbacks",
            "targets"
        ]
    },
    {
        "q": "Match fromEvent patterns:",
        "type": "match",
        "left": [
            "fromEvent(el, 'click')",
            "fromEvent(doc, 'keydown')",
            "fromEvent(input, 'input')"
        ],
        "right": [
            "Click events",
            "Key events",
            "Input changes"
        ]
    },
    {
        "q": "What is fromEventPattern()?",
        "type": "mcq",
        "o": [
            "Creates Observable from custom add/remove handlers",
            "Standard event handler",
            "DOM events only",
            "No handlers"
        ]
    },
    {
        "q": "fromEventPattern works with any event system.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does fromEventPattern enable?",
        "type": "mcq",
        "o": [
            "Custom event source integration",
            "DOM events only",
            "No integration",
            "Array events"
        ]
    },
    {
        "q": "fromEventPattern needs add and _____ handlers.",
        "type": "fill_blank",
        "answers": [
            "remove"
        ],
        "other_options": [
            "delete",
            "clear",
            "reset"
        ]
    },
    {
        "q": "Match event patterns:",
        "type": "match",
        "left": [
            "fromEvent",
            "fromEventPattern"
        ],
        "right": [
            "Standard events",
            "Custom events"
        ]
    },
    {
        "q": "What is webSocket()?",
        "type": "mcq",
        "o": [
            "Creates Observable WebSocket connection",
            "HTTP request",
            "File download",
            "DOM events"
        ]
    },
    {
        "q": "webSocket subject can send and receive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does webSocket return?",
        "type": "mcq",
        "c": "webSocket('wss://api.example.com')",
        "o": [
            "WebSocketSubject for bidirectional communication",
            "Observable only",
            "Promise",
            "HTTP response"
        ]
    },
    {
        "q": "webSocket creates _____ connection.",
        "type": "fill_blank",
        "answers": [
            "bidirectional"
        ],
        "other_options": [
            "unidirectional",
            "HTTP",
            "offline"
        ]
    },
    {
        "q": "Match webSocket methods:",
        "type": "match",
        "left": [
            "subscribe",
            "next",
            "multiplex"
        ],
        "right": [
            "Receive messages",
            "Send messages",
            "Filter channels"
        ]
    },
    {
        "q": "What is ajax()?",
        "type": "mcq",
        "o": [
            "Creates Observable from XMLHttpRequest",
            "WebSocket",
            "DOM events",
            "File read"
        ]
    },
    {
        "q": "ajax is alternative to fetch/HttpClient.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ajax.getJSON() do?",
        "type": "mcq",
        "o": [
            "GET request parsing JSON response",
            "POST request",
            "File upload",
            "WebSocket"
        ]
    },
    {
        "q": "ajax provides _____ control than fetch.",
        "type": "fill_blank",
        "answers": [
            "more"
        ],
        "other_options": [
            "less",
            "same",
            "no"
        ]
    },
    {
        "q": "Match ajax methods:",
        "type": "match",
        "left": [
            "ajax",
            "ajax.getJSON",
            "ajax.post"
        ],
        "right": [
            "Full request config",
            "JSON GET shorthand",
            "POST shorthand"
        ]
    },
    {
        "q": "What is animationFrameScheduler?",
        "type": "mcq",
        "o": [
            "Schedules work with requestAnimationFrame",
            "Immediate scheduling",
            "Async scheduling",
            "Queue scheduling"
        ]
    },
    {
        "q": "animationFrameScheduler is best for animations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers animationFrameScheduler execution?",
        "type": "mcq",
        "o": [
            "Browser paint cycle",
            "Immediately",
            "After delay",
            "On complete"
        ]
    },
    {
        "q": "animationFrameScheduler synchronizes with browser _____.",
        "type": "fill_blank",
        "answers": [
            "repaint"
        ],
        "other_options": [
            "load",
            "unload",
            "resize"
        ]
    },
    {
        "q": "Match animation patterns:",
        "type": "match",
        "left": [
            "animationFrameScheduler",
            "interval with animation"
        ],
        "right": [
            "60fps sync",
            "Smooth animation"
        ]
    },
    {
        "q": "What is retryWhen()?",
        "type": "mcq",
        "o": [
            "Conditional retry with custom logic",
            "Simple retry",
            "No retry",
            "Error only"
        ]
    },
    {
        "q": "retryWhen allows delay between retries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern is this?",
        "type": "mcq",
        "c": "retryWhen(errors => errors.pipe(delay(1000)))",
        "o": [
            "Retry after 1 second delay",
            "Immediate retry",
            "No retry",
            "Error handling"
        ]
    },
    {
        "q": "retryWhen receives _____ Observable.",
        "type": "fill_blank",
        "answers": [
            "errors"
        ],
        "other_options": [
            "values",
            "complete",
            "subscription"
        ]
    },
    {
        "q": "Match retry strategies:",
        "type": "match",
        "left": [
            "retry(3)",
            "retryWhen with delay",
            "retryWhen with take"
        ],
        "right": [
            "Immediate 3 times",
            "Delayed retry",
            "Limited retries"
        ]
    },
    {
        "q": "What is exponential backoff?",
        "type": "mcq",
        "o": [
            "Increasing delay between retries",
            "Constant delay",
            "No delay",
            "Decreasing delay"
        ]
    },
    {
        "q": "Exponential backoff prevents server overload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this implement?",
        "type": "mcq",
        "c": "retryWhen(e => e.pipe(scan((acc) => acc + 1, 0), delayWhen(i => timer(i * 1000))))",
        "o": [
            "Exponential backoff retry",
            "Constant retry",
            "Immediate retry",
            "No retry"
        ]
    },
    {
        "q": "Backoff delay typically _____ each retry.",
        "type": "fill_blank",
        "answers": [
            "increases"
        ],
        "other_options": [
            "decreases",
            "stays same",
            "random"
        ]
    },
    {
        "q": "Match backoff patterns:",
        "type": "match",
        "left": [
            "delay(1000)",
            "delay(i * 1000)",
            "delay(Math.pow(2, i) * 1000)"
        ],
        "right": [
            "Constant",
            "Linear",
            "Exponential"
        ]
    },
    {
        "q": "What is onErrorResumeNext()?",
        "type": "mcq",
        "o": [
            "Continues with next Observable on error",
            "Stops on error",
            "Retries",
            "Ignores errors"
        ]
    },
    {
        "q": "onErrorResumeNext ignores errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What happens on error here?",
        "type": "mcq",
        "c": "onErrorResumeNext(obs1$, obs2$)",
        "o": [
            "Continues with obs2$",
            "Stops",
            "Retries obs1$",
            "Errors"
        ]
    },
    {
        "q": "onErrorResumeNext chains Observables on _____ or complete.",
        "type": "fill_blank",
        "answers": [
            "error"
        ],
        "other_options": [
            "success",
            "start",
            "subscribe"
        ]
    },
    {
        "q": "Match error continuation:",
        "type": "match",
        "left": [
            "onErrorResumeNext",
            "catchError",
            "concat"
        ],
        "right": [
            "Ignore and continue",
            "Handle and recover",
            "Sequential only"
        ]
    },
    {
        "q": "What is throwIfEmpty()?",
        "type": "mcq",
        "o": [
            "Throws error if Observable completes without emitting",
            "Emits default",
            "Ignores empty",
            "Filters empty"
        ]
    },
    {
        "q": "throwIfEmpty validates non-empty stream.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this throw?",
        "type": "mcq",
        "c": "EMPTY.pipe(throwIfEmpty(() => new Error('Empty!')))",
        "o": [
            "Custom error on empty completion",
            "Default error",
            "Nothing",
            "Value"
        ]
    },
    {
        "q": "throwIfEmpty errors when source is _____.",
        "type": "fill_blank",
        "answers": [
            "empty"
        ],
        "other_options": [
            "full",
            "slow",
            "fast"
        ]
    },
    {
        "q": "Match empty validation:",
        "type": "match",
        "left": [
            "throwIfEmpty",
            "defaultIfEmpty"
        ],
        "right": [
            "Error if empty",
            "Default if empty"
        ]
    },
    {
        "q": "What is ignoreElements()?",
        "type": "mcq",
        "o": [
            "Ignores all values, only passes complete/error",
            "Ignores errors",
            "Ignores complete",
            "Ignores nothing"
        ]
    },
    {
        "q": "ignoreElements passes through errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ignoreElements output?",
        "type": "mcq",
        "c": "of(1, 2, 3).pipe(ignoreElements())",
        "o": [
            "No values, just complete",
            "1, 2, 3",
            "Error",
            "Nothing"
        ]
    },
    {
        "q": "ignoreElements is useful for _____ effects only.",
        "type": "fill_blank",
        "answers": [
            "side"
        ],
        "other_options": [
            "main",
            "value",
            "no"
        ]
    },
    {
        "q": "Match ignore patterns:",
        "type": "match",
        "left": [
            "ignoreElements",
            "tap with ignoreElements"
        ],
        "right": [
            "No output values",
            "Side effects only"
        ]
    },
    {
        "q": "What is pluck()?",
        "type": "mcq",
        "o": [
            "Extracts property from emitted objects",
            "Entire object",
            "Filters objects",
            "Maps objects"
        ]
    },
    {
        "q": "pluck is deprecated in favor of map.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this extract?",
        "type": "mcq",
        "c": "of({name: 'John', age: 30}).pipe(pluck('name'))",
        "o": [
            "'John'",
            "{name: 'John'}",
            "30",
            "Object"
        ]
    },
    {
        "q": "pluck replaced by map with _____ access.",
        "type": "fill_blank",
        "answers": [
            "property"
        ],
        "other_options": [
            "array",
            "method",
            "function"
        ]
    },
    {
        "q": "Match property extraction:",
        "type": "match",
        "left": [
            "pluck('name')",
            "map(x => x.name)"
        ],
        "right": [
            "Deprecated way",
            "Modern way"
        ]
    },
    {
        "q": "What is timestamp()?",
        "type": "mcq",
        "o": [
            "Adds timestamp to each emission",
            "Filters by time",
            "Delays by time",
            "Counts time"
        ]
    },
    {
        "q": "timestamp wraps value with time information.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does timestamp emit?",
        "type": "mcq",
        "c": "of(1).pipe(timestamp())",
        "o": [
            "{value: 1, timestamp: <Date.now()>}",
            "1",
            "Date object",
            "Number"
        ]
    },
    {
        "q": "timestamp provides _____ of emission.",
        "type": "fill_blank",
        "answers": [
            "timing"
        ],
        "other_options": [
            "value",
            "index",
            "source"
        ]
    },
    {
        "q": "Match time operators:",
        "type": "match",
        "left": [
            "timestamp",
            "timeInterval"
        ],
        "right": [
            "Emission time",
            "Time between emissions"
        ]
    },
    {
        "q": "What is timeInterval()?",
        "type": "mcq",
        "o": [
            "Measures time between emissions",
            "Absolute time",
            "Delays emissions",
            "Filters by time"
        ]
    },
    {
        "q": "timeInterval shows interval between values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does timeInterval emit?",
        "type": "mcq",
        "o": [
            "{value, interval} objects",
            "Just values",
            "Just intervals",
            "Nothing"
        ]
    },
    {
        "q": "timeInterval measures _____ between emissions.",
        "type": "fill_blank",
        "answers": [
            "duration"
        ],
        "other_options": [
            "count",
            "value",
            "type"
        ]
    },
    {
        "q": "Match timing analysis:",
        "type": "match",
        "left": [
            "timestamp",
            "timeInterval"
        ],
        "right": [
            "When emitted",
            "How long since last"
        ]
    },
    {
        "q": "What is RxJS 7 new features?",
        "type": "mcq",
        "o": [
            "Smaller bundle, better types, new operators",
            "No changes",
            "Larger bundle",
            "Removed operators"
        ]
    },
    {
        "q": "RxJS 7 improved TypeScript support.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What changed in RxJS 7?",
        "type": "mcq",
        "o": [
            "toPromise deprecated for firstValueFrom/lastValueFrom",
            "All same",
            "More operators",
            "Larger size"
        ]
    },
    {
        "q": "RxJS 7 has _____ bundle size.",
        "type": "fill_blank",
        "answers": [
            "smaller"
        ],
        "other_options": [
            "larger",
            "same",
            "no"
        ]
    },
    {
        "q": "Match RxJS versions:",
        "type": "match",
        "left": [
            "toPromise",
            "firstValueFrom",
            "lastValueFrom"
        ],
        "right": [
            "Deprecated",
            "First value Promise",
            "Last value Promise"
        ]
    },
    {
        "q": "What is tree-shaking in RxJS?",
        "type": "mcq",
        "o": [
            "Removing unused code from bundle",
            "Adding all code",
            "Manual removal",
            "No optimization"
        ]
    },
    {
        "q": "Tree-shaking reduces bundle size.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What enables better tree-shaking?",
        "type": "mcq",
        "o": [
            "Direct imports from 'rxjs' and 'rxjs/operators'",
            "Import everything",
            "No imports",
            "Global imports"
        ]
    },
    {
        "q": "Tree-shaking eliminates _____ code.",
        "type": "fill_blank",
        "answers": [
            "unused"
        ],
        "other_options": [
            "all",
            "used",
            "new"
        ]
    },
    {
        "q": "Match import patterns:",
        "type": "match",
        "left": [
            "import {map} from 'rxjs'",
            "import * as rxjs"
        ],
        "right": [
            "Tree-shakeable",
            "Not tree-shakeable"
        ]
    },
    {
        "q": "What is debugging RxJS?",
        "type": "mcq",
        "o": [
            "Using tap to log values and state",
            "Console only",
            "No debugging",
            "Breakpoints only"
        ]
    },
    {
        "q": "tap() is primary debugging tool.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What helps debug here?",
        "type": "mcq",
        "c": ".pipe(tap(x => console.log('value:', x)))",
        "o": [
            "Logs each emitted value",
            "Stops execution",
            "Changes values",
            "Errors"
        ]
    },
    {
        "q": "Debug with tap to see _____ flow.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "error",
            "complete",
            "subscribe"
        ]
    },
    {
        "q": "Match debugging techniques:",
        "type": "match",
        "left": [
            "tap(console.log)",
            "tap({next, error, complete})"
        ],
        "right": [
            "Log values",
            "Log all events"
        ]
    },
    {
        "q": "What is RxJS DevTools?",
        "type": "mcq",
        "o": [
            "Browser extension for Observable debugging",
            "Code library",
            "IDE plugin only",
            "No tools"
        ]
    },
    {
        "q": "DevTools visualize Observable streams.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can DevTools show?",
        "type": "mcq",
        "o": [
            "Marble diagrams of live streams",
            "Source code",
            "Database",
            "Network only"
        ]
    },
    {
        "q": "DevTools help understand _____ flow.",
        "type": "fill_blank",
        "answers": [
            "Observable"
        ],
        "other_options": [
            "Promise",
            "Array",
            "Object"
        ]
    },
    {
        "q": "Match debugging tools:",
        "type": "match",
        "left": [
            "tap",
            "DevTools",
            "TestScheduler"
        ],
        "right": [
            "Code logging",
            "Visual debugging",
            "Testing"
        ]
    },
    {
        "q": "What is mergeAll()?",
        "type": "mcq",
        "o": [
            "Flattens higher-order Observable",
            "Merges arrays",
            "Merges values",
            "Single Observable"
        ]
    },
    {
        "q": "mergeAll subscribes to all inner Observables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does mergeAll flatten?",
        "type": "mcq",
        "c": "of(of(1), of(2)).pipe(mergeAll())",
        "o": [
            "Inner Observables to single stream",
            "Nothing",
            "Errors",
            "Arrays"
        ]
    },
    {
        "q": "mergeAll is like mergeMap with _____ function.",
        "type": "fill_blank",
        "answers": [
            "identity"
        ],
        "other_options": [
            "transform",
            "filter",
            "map"
        ]
    },
    {
        "q": "Match flattening operators:",
        "type": "match",
        "left": [
            "mergeAll",
            "concatAll",
            "switchAll"
        ],
        "right": [
            "Concurrent",
            "Sequential",
            "Switch to latest"
        ]
    },
    {
        "q": "What is concatAll()?",
        "type": "mcq",
        "o": [
            "Flattens sequentially",
            "Flattens concurrently",
            "Switches",
            "Ignores"
        ]
    },
    {
        "q": "concatAll waits for each inner to complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What order does concatAll use?",
        "type": "mcq",
        "o": [
            "Sequential, preserving order",
            "Concurrent",
            "Random",
            "Reverse"
        ]
    },
    {
        "q": "concatAll is like concatMap with _____ function.",
        "type": "fill_blank",
        "answers": [
            "identity"
        ],
        "other_options": [
            "transform",
            "filter",
            "map"
        ]
    },
    {
        "q": "Rearrange concatAll execution:",
        "type": "rearrange",
        "words": [
            "Outer emits inner Observable",
            "Subscribe to first inner",
            "First inner completes",
            "Subscribe to next inner",
            "Continue until all complete"
        ]
    },
    {
        "q": "What is switchAll()?",
        "type": "mcq",
        "o": [
            "Switches to latest inner Observable",
            "Merges all",
            "Concatenates all",
            "Ignores all"
        ]
    },
    {
        "q": "switchAll cancels previous inner.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does switchAll prioritize?",
        "type": "mcq",
        "o": [
            "Latest inner Observable",
            "First inner",
            "All inners",
            "None"
        ]
    },
    {
        "q": "switchAll is like switchMap with _____ function.",
        "type": "fill_blank",
        "answers": [
            "identity"
        ],
        "other_options": [
            "transform",
            "filter",
            "map"
        ]
    },
    {
        "q": "Match All operators:",
        "type": "match",
        "left": [
            "mergeAll",
            "concatAll",
            "switchAll",
            "exhaustAll"
        ],
        "right": [
            "All concurrent",
            "All sequential",
            "Latest only",
            "Ignore while busy"
        ]
    },
    {
        "q": "What is exhaustAll()?",
        "type": "mcq",
        "o": [
            "Ignores new inner while current is active",
            "Merges all",
            "Concatenates all",
            "Switches"
        ]
    },
    {
        "q": "exhaustAll prevents overlapping subscriptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does exhaustAll do with new emissions?",
        "type": "mcq",
        "o": [
            "Ignores while busy",
            "Queues",
            "Cancels current",
            "Merges"
        ]
    },
    {
        "q": "exhaustAll is like exhaustMap with _____ function.",
        "type": "fill_blank",
        "answers": [
            "identity"
        ],
        "other_options": [
            "transform",
            "filter",
            "map"
        ]
    },
    {
        "q": "Match exhaustAll behavior:",
        "type": "match",
        "left": [
            "Current active",
            "New emission arrives",
            "Current completes"
        ],
        "right": [
            "Processing",
            "Ignored",
            "Accept next"
        ]
    },
    {
        "q": "What is combineLatestAll()?",
        "type": "mcq",
        "o": [
            "Combines latest from all inner Observables",
            "Merges all",
            "Concatenates all",
            "Switches"
        ]
    },
    {
        "q": "combineLatestAll waits for all inners to emit.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does combineLatestAll produce?",
        "type": "mcq",
        "o": [
            "Arrays of latest values from all inners",
            "Single value",
            "First value",
            "Last value"
        ]
    },
    {
        "q": "combineLatestAll is higher-order _____.",
        "type": "fill_blank",
        "answers": [
            "combineLatest"
        ],
        "other_options": [
            "merge",
            "concat",
            "switch"
        ]
    },
    {
        "q": "Match higher-order operators:",
        "type": "match",
        "left": [
            "combineLatestAll",
            "zipAll",
            "mergeAll"
        ],
        "right": [
            "Latest from all",
            "Paired by index",
            "All concurrent"
        ]
    },
    {
        "q": "What is zipAll()?",
        "type": "mcq",
        "o": [
            "Zips all inner Observables by index",
            "Merges all",
            "Concatenates all",
            "Combines latest"
        ]
    },
    {
        "q": "zipAll pairs values at same position.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does zipAll synchronize?",
        "type": "mcq",
        "o": [
            "Emissions by index across inners",
            "By time",
            "Random",
            "Nothing"
        ]
    },
    {
        "q": "zipAll is higher-order _____.",
        "type": "fill_blank",
        "answers": [
            "zip"
        ],
        "other_options": [
            "merge",
            "concat",
            "switch"
        ]
    },
    {
        "q": "Match zip patterns:",
        "type": "match",
        "left": [
            "zip",
            "zipAll",
            "zipWith"
        ],
        "right": [
            "Static operator",
            "Higher-order",
            "Pipeable"
        ]
    },
    {
        "q": "What is scheduled()?",
        "type": "mcq",
        "o": [
            "Creates Observable with specific scheduler",
            "No scheduler",
            "Default scheduler",
            "Immediate"
        ]
    },
    {
        "q": "scheduled provides scheduler at creation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does scheduled configure?",
        "type": "mcq",
        "c": "scheduled([1, 2, 3], asyncScheduler)",
        "o": [
            "Observable emitting async",
            "Immediate emission",
            "No emission",
            "Error"
        ]
    },
    {
        "q": "scheduled replaces deprecated _____ argument.",
        "type": "fill_blank",
        "answers": [
            "scheduler"
        ],
        "other_options": [
            "value",
            "operator",
            "observer"
        ]
    },
    {
        "q": "Match scheduling:",
        "type": "match",
        "left": [
            "scheduled",
            "observeOn",
            "subscribeOn"
        ],
        "right": [
            "At creation",
            "For emissions",
            "For subscription"
        ]
    },
    {
        "q": "What is generate()?",
        "type": "mcq",
        "o": [
            "Creates Observable with iterative logic",
            "Simple array",
            "Single value",
            "Error"
        ]
    },
    {
        "q": "generate is like a for loop as Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does generate do?",
        "type": "mcq",
        "c": "generate(0, x => x < 5, x => x + 1)",
        "o": [
            "Emits 0, 1, 2, 3, 4",
            "Single value",
            "Nothing",
            "Error"
        ]
    },
    {
        "q": "generate has initial, condition, and _____ functions.",
        "type": "fill_blank",
        "answers": [
            "iterate"
        ],
        "other_options": [
            "filter",
            "map",
            "complete"
        ]
    },
    {
        "q": "Match generation patterns:",
        "type": "match",
        "left": [
            "generate",
            "range",
            "interval"
        ],
        "right": [
            "Custom iteration",
            "Number sequence",
            "Periodic"
        ]
    },
    {
        "q": "What is range()?",
        "type": "mcq",
        "o": [
            "Emits sequence of numbers",
            "Single number",
            "Random numbers",
            "Infinite"
        ]
    },
    {
        "q": "range(1, 5) emits 1 through 5.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this emit?",
        "type": "mcq",
        "c": "range(10, 3)",
        "o": [
            "10, 11, 12",
            "1, 2, 3",
            "10, 20, 30",
            "3, 4, 5"
        ]
    },
    {
        "q": "range(start, count) emits _____ numbers.",
        "type": "fill_blank",
        "answers": [
            "count"
        ],
        "other_options": [
            "start",
            "end",
            "random"
        ]
    },
    {
        "q": "Match number generators:",
        "type": "match",
        "left": [
            "range(1, 5)",
            "of(1, 2, 3)",
            "from([1, 2, 3])"
        ],
        "right": [
            "Generate sequence",
            "From arguments",
            "From array"
        ]
    },
    {
        "q": "What is subscription.add()?",
        "type": "mcq",
        "o": [
            "Groups subscriptions for bulk unsubscribe",
            "Adds values",
            "Adds operators",
            "Nothing"
        ]
    },
    {
        "q": "subscription.add() enables parent-child cleanup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "const parent = obs1$.subscribe(); parent.add(obs2$.subscribe());",
        "o": [
            "Single unsubscribe cleans both",
            "Separate unsubscribes",
            "Nothing",
            "Error"
        ]
    },
    {
        "q": "subscription.add() creates _____ subscription.",
        "type": "fill_blank",
        "answers": [
            "composite"
        ],
        "other_options": [
            "single",
            "no",
            "empty"
        ]
    },
    {
        "q": "Match subscription patterns:",
        "type": "match",
        "left": [
            "subscription.add",
            "subscription.unsubscribe",
            "subscription.closed"
        ],
        "right": [
            "Add child",
            "Cleanup",
            "Check status"
        ]
    },
    {
        "q": "What is Observable.create() deprecated for?",
        "type": "mcq",
        "o": [
            "new Observable() constructor",
            "of()",
            "from()",
            "Nothing"
        ]
    },
    {
        "q": "new Observable() is the modern approach.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does new Observable take?",
        "type": "mcq",
        "o": [
            "Subscriber function",
            "Value",
            "Array",
            "Promise"
        ]
    },
    {
        "q": "Observable constructor receives _____ callback.",
        "type": "fill_blank",
        "answers": [
            "subscriber"
        ],
        "other_options": [
            "value",
            "array",
            "promise"
        ]
    },
    {
        "q": "Match Observable creation:",
        "type": "match",
        "left": [
            "new Observable",
            "of",
            "from"
        ],
        "right": [
            "Custom logic",
            "From values",
            "From iterable"
        ]
    },
    {
        "q": "What is mapTo() deprecated for?",
        "type": "mcq",
        "o": [
            "map(() => value)",
            "filter",
            "tap",
            "Nothing"
        ]
    },
    {
        "q": "mapTo is replaced by map with constant.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What replaces mapTo(true)?",
        "type": "mcq",
        "o": [
            "map(() => true)",
            "filter",
            "tap(true)",
            "of(true)"
        ]
    },
    {
        "q": "mapTo deprecated in favor of _____.",
        "type": "fill_blank",
        "answers": [
            "map"
        ],
        "other_options": [
            "filter",
            "tap",
            "of"
        ]
    },
    {
        "q": "Match deprecated operators:",
        "type": "match",
        "left": [
            "mapTo",
            "pluck",
            "toPromise"
        ],
        "right": [
            "map(() => value)",
            "map(x => x.prop)",
            "firstValueFrom"
        ]
    },
    {
        "q": "What is Subscription pattern in services?",
        "type": "mcq",
        "o": [
            "Share Observable and cache with shareReplay",
            "New request per call",
            "No sharing",
            "Manual caching"
        ]
    },
    {
        "q": "Services should cache shared data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern is this?",
        "type": "mcq",
        "c": "data$ = this.http.get('/api').pipe(shareReplay(1));",
        "o": [
            "Service-level caching",
            "No caching",
            "Component caching",
            "Manual cache"
        ]
    },
    {
        "q": "shareReplay in services prevents duplicate _____.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "values",
            "errors",
            "complete"
        ]
    },
    {
        "q": "Match service patterns:",
        "type": "match",
        "left": [
            "shareReplay(1)",
            "BehaviorSubject",
            "ReplaySubject"
        ],
        "right": [
            "HTTP caching",
            "State management",
            "Event replay"
        ]
    },
    {
        "q": "What is NgRx observable pattern?",
        "type": "mcq",
        "o": [
            "select() returns Observable slices of state",
            "Direct state access",
            "No Observables",
            "Promises"
        ]
    },
    {
        "q": "NgRx uses RxJS extensively.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does store.select() return?",
        "type": "mcq",
        "o": [
            "Observable of selected state",
            "Plain value",
            "Promise",
            "Action"
        ]
    },
    {
        "q": "NgRx selectors return _____.",
        "type": "fill_blank",
        "answers": [
            "Observables"
        ],
        "other_options": [
            "values",
            "promises",
            "actions"
        ]
    },
    {
        "q": "Match NgRx RxJS usage:",
        "type": "match",
        "left": [
            "select",
            "ofType",
            "switchMap"
        ],
        "right": [
            "State slice",
            "Filter actions",
            "Effect handling"
        ]
    },
    {
        "q": "What is Router events Observable?",
        "type": "mcq",
        "o": [
            "Observable of navigation events",
            "Static property",
            "Promise",
            "Array"
        ]
    },
    {
        "q": "Router.events is Observable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can you filter from router.events?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationEnd))",
        "o": [
            "Navigation completion events",
            "All events",
            "Start only",
            "Nothing"
        ]
    },
    {
        "q": "Router events stream is _____.",
        "type": "fill_blank",
        "answers": [
            "hot"
        ],
        "other_options": [
            "cold",
            "cached",
            "delayed"
        ]
    },
    {
        "q": "Match Angular Observables:",
        "type": "match",
        "left": [
            "Router.events",
            "ActivatedRoute.params",
            "FormControl.valueChanges"
        ],
        "right": [
            "Navigation events",
            "Route parameters",
            "Form value changes"
        ]
    },
    {
        "q": "What is ActivatedRoute.params?",
        "type": "mcq",
        "o": [
            "Observable of route parameters",
            "Static params",
            "Promise",
            "Array"
        ]
    },
    {
        "q": "Route params change triggers Observable emission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this subscribe to?",
        "type": "mcq",
        "c": "route.params.pipe(map(p => p.id))",
        "o": [
            "Route parameter 'id' changes",
            "All params",
            "Static id",
            "Nothing"
        ]
    },
    {
        "q": "ActivatedRoute.paramMap is preferred over _____.",
        "type": "fill_blank",
        "answers": [
            "params"
        ],
        "other_options": [
            "queryParams",
            "data",
            "url"
        ]
    },
    {
        "q": "Match route Observables:",
        "type": "match",
        "left": [
            "params",
            "queryParams",
            "data",
            "url"
        ],
        "right": [
            "Path parameters",
            "Query string",
            "Resolver data",
            "URL segments"
        ]
    },
    {
        "q": "What is BreakpointObserver?",
        "type": "mcq",
        "o": [
            "Observable for responsive breakpoints",
            "Element sizing",
            "Window events",
            "Nothing"
        ]
    },
    {
        "q": "BreakpointObserver is from CDK.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does BreakpointObserver observe?",
        "type": "mcq",
        "o": [
            "Media query matches",
            "Element size",
            "Window resize",
            "Scroll position"
        ]
    },
    {
        "q": "BreakpointObserver uses media _____ internally.",
        "type": "fill_blank",
        "answers": [
            "queries"
        ],
        "other_options": [
            "elements",
            "events",
            "listeners"
        ]
    },
    {
        "q": "Match CDK Observables:",
        "type": "match",
        "left": [
            "BreakpointObserver",
            "ViewportRuler"
        ],
        "right": [
            "Responsive design",
            "Viewport changes"
        ]
    }
]