[
    {
        "q": "What is Angular Router?",
        "type": "mcq",
        "o": [
            "Module for navigation between views in Angular apps",
            "Route builder",
            "Page loader",
            "URL parser"
        ]
    },
    {
        "q": "Angular Router enables single-page application navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a route in Angular?",
        "type": "mcq",
        "o": [
            "Configuration mapping URL path to a component",
            "URL path",
            "Page link",
            "Navigation point"
        ]
    },
    {
        "q": "The _____ array defines application routes.",
        "type": "fill_blank",
        "answers": [
            "Routes"
        ],
        "other_options": [
            "Paths",
            "Links",
            "Pages"
        ]
    },
    {
        "q": "What is router-outlet?",
        "type": "mcq",
        "o": [
            "Directive that marks where routed components render",
            "Route output",
            "Component slot",
            "View container"
        ]
    },
    {
        "q": "<router-outlet> is where routed content displays.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this route configuration do?",
        "type": "mcq",
        "c": "{ path: 'home', component: HomeComponent }",
        "o": [
            "Maps /home URL to HomeComponent",
            "Creates home",
            "Loads home",
            "Links home"
        ]
    },
    {
        "q": "Match routing concepts:",
        "type": "match",
        "left": [
            "Route",
            "Router",
            "RouterOutlet",
            "RouterLink"
        ],
        "right": [
            "Path config",
            "Navigation service",
            "View placeholder",
            "Navigation directive"
        ]
    },
    {
        "q": "What is RouterLink directive?",
        "type": "mcq",
        "o": [
            "Directive for navigation without page reload",
            "Link directive",
            "Route link",
            "Nav directive"
        ]
    },
    {
        "q": "The _____ directive replaces href for Angular navigation.",
        "type": "fill_blank",
        "answers": [
            "routerLink"
        ],
        "other_options": [
            "link",
            "href",
            "navigate"
        ]
    },
    {
        "q": "What does this routerLink do?",
        "type": "mcq",
        "c": "<a routerLink=\"/products\">Products</a>",
        "o": [
            "Navigates to /products route",
            "Links products",
            "Opens products",
            "Loads products"
        ]
    },
    {
        "q": "routerLink uses Angular Router for navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is routerLinkActive?",
        "type": "mcq",
        "o": [
            "Directive adding CSS class when link's route is active",
            "Active link",
            "Link style",
            "Route style"
        ]
    },
    {
        "q": "Match router directives:",
        "type": "match",
        "left": [
            "routerLink",
            "routerLinkActive",
            "routerOutlet",
            "routerLinkActiveOptions"
        ],
        "right": [
            "Navigate",
            "Active class",
            "Render target",
            "Match options"
        ]
    },
    {
        "q": "What does this routerLinkActive do?",
        "type": "mcq",
        "c": "<a routerLink=\"/home\" routerLinkActive=\"active\">Home</a>",
        "o": [
            "Adds 'active' class when /home route is active",
            "Makes active",
            "Styles link",
            "Activates route"
        ]
    },
    {
        "q": "The _____ directive applies CSS class to active links.",
        "type": "fill_blank",
        "answers": [
            "routerLinkActive"
        ],
        "other_options": [
            "activeLink",
            "linkActive",
            "routeActive"
        ]
    },
    {
        "q": "What is provideRouter()?",
        "type": "mcq",
        "o": [
            "Standalone function to configure routing",
            "Router provider",
            "Route creator",
            "Nav provider"
        ]
    },
    {
        "q": "provideRouter replaces RouterModule.forRoot().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provideRouter do?",
        "type": "mcq",
        "c": "provideRouter(routes, withComponentInputBinding())",
        "o": [
            "Configures router with route param input binding",
            "Creates router",
            "Provides routes",
            "Binds components"
        ]
    },
    {
        "q": "The _____ function enables route param binding to inputs.",
        "type": "fill_blank",
        "answers": [
            "withComponentInputBinding"
        ],
        "other_options": [
            "withInputBinding",
            "bindInputs",
            "withParamBinding"
        ]
    },
    {
        "q": "What is lazy loading in routing?",
        "type": "mcq",
        "o": [
            "Loading modules only when their route is accessed",
            "Slow loading",
            "Deferred loading",
            "Late loading"
        ]
    },
    {
        "q": "Lazy loading improves initial load time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this lazy route do?",
        "type": "mcq",
        "c": "{ path: 'admin', loadComponent: () => import('./admin.component').then(m => m.AdminComponent) }",
        "o": [
            "Lazy loads AdminComponent when /admin is accessed",
            "Loads admin",
            "Creates admin",
            "Imports admin"
        ]
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "Eager",
            "Lazy",
            "Preload",
            "On-demand"
        ],
        "right": [
            "Load at start",
            "Load on route",
            "Load in background",
            "Load on action"
        ]
    },
    {
        "q": "What is loadChildren for lazy loading?",
        "type": "mcq",
        "o": [
            "Lazy loads child routes from a module or routes file",
            "Load children",
            "Child loader",
            "Nested routes"
        ]
    },
    {
        "q": "The _____ property lazy loads route modules.",
        "type": "fill_blank",
        "answers": [
            "loadChildren"
        ],
        "other_options": [
            "loadModule",
            "lazyLoad",
            "children"
        ]
    },
    {
        "q": "What is route parameter?",
        "type": "mcq",
        "o": [
            "Dynamic segment in route path that captures values",
            "Route value",
            "Path variable",
            "URL param"
        ]
    },
    {
        "q": "Route parameters use colon prefix like :id.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this route parameter do?",
        "type": "mcq",
        "c": "{ path: 'users/:id', component: UserComponent }",
        "o": [
            "Captures user ID from URL like /users/123",
            "Creates user",
            "IDs users",
            "Routes user"
        ]
    },
    {
        "q": "Match route data sources:",
        "type": "match",
        "left": [
            "paramMap",
            "queryParamMap",
            "data",
            "fragment"
        ],
        "right": [
            "Path params",
            "Query string",
            "Static data",
            "URL hash"
        ]
    },
    {
        "q": "What is ActivatedRoute?",
        "type": "mcq",
        "o": [
            "Service providing access to route information",
            "Active route",
            "Current route",
            "Route info"
        ]
    },
    {
        "q": "The _____ service provides route parameters.",
        "type": "fill_blank",
        "answers": [
            "ActivatedRoute"
        ],
        "other_options": [
            "Router",
            "RouteInfo",
            "CurrentRoute"
        ]
    },
    {
        "q": "What does this ActivatedRoute code do?",
        "type": "mcq",
        "c": "this.route.paramMap.subscribe(params => {\n  this.userId = params.get('id');\n});",
        "o": [
            "Gets 'id' parameter from current route",
            "Subscribes route",
            "Creates param",
            "Logs ID"
        ]
    },
    {
        "q": "paramMap is Observable of route parameters.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is snapshot in ActivatedRoute?",
        "type": "mcq",
        "o": [
            "One-time snapshot of route info without subscribing",
            "Route picture",
            "Static route",
            "Route copy"
        ]
    },
    {
        "q": "Match ActivatedRoute properties:",
        "type": "match",
        "left": [
            "snapshot",
            "paramMap",
            "queryParamMap",
            "data"
        ],
        "right": [
            "One-time",
            "Observable params",
            "Observable query",
            "Observable data"
        ]
    },
    {
        "q": "What does this snapshot do?",
        "type": "mcq",
        "c": "const id = this.route.snapshot.paramMap.get('id');",
        "o": [
            "Gets 'id' parameter synchronously",
            "Takes snapshot",
            "Creates ID",
            "Logs param"
        ]
    },
    {
        "q": "Snapshot is good when params don't change within component.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What are query parameters?",
        "type": "mcq",
        "o": [
            "Optional key-value pairs after ? in URL",
            "Query string",
            "URL params",
            "Search params"
        ]
    },
    {
        "q": "The _____ contains query string parameters.",
        "type": "fill_blank",
        "answers": [
            "queryParamMap"
        ],
        "other_options": [
            "queryParams",
            "searchParams",
            "urlParams"
        ]
    },
    {
        "q": "What does this queryParams do?",
        "type": "mcq",
        "c": "<a [routerLink]=\"['/search']\" [queryParams]=\"{q: 'angular'}\">Search</a>",
        "o": [
            "Navigates to /search?q=angular",
            "Queries search",
            "Adds params",
            "Links search"
        ]
    },
    {
        "q": "Match URL parts:",
        "type": "match",
        "left": [
            "Path",
            "Query",
            "Fragment",
            "Matrix"
        ],
        "right": [
            "/path/to",
            "?key=value",
            "#section",
            ";param=value"
        ]
    },
    {
        "q": "What is Router.navigate()?",
        "type": "mcq",
        "o": [
            "Method for programmatic navigation",
            "Navigate method",
            "Route method",
            "Go method"
        ]
    },
    {
        "q": "Router.navigate uses route commands array.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this navigate do?",
        "type": "mcq",
        "c": "this.router.navigate(['/users', userId]);",
        "o": [
            "Navigates to /users/:userId programmatically",
            "Creates route",
            "Logs navigation",
            "Returns route"
        ]
    },
    {
        "q": "The _____ method navigates programmatically.",
        "type": "fill_blank",
        "answers": [
            "navigate"
        ],
        "other_options": [
            "go",
            "route",
            "navigateTo"
        ]
    },
    {
        "q": "What is Router.navigateByUrl()?",
        "type": "mcq",
        "o": [
            "Navigates using full URL string",
            "URL navigate",
            "String navigate",
            "Path navigate"
        ]
    },
    {
        "q": "Match Router methods:",
        "type": "match",
        "left": [
            "navigate",
            "navigateByUrl",
            "createUrlTree",
            "isActive"
        ],
        "right": [
            "Commands array",
            "URL string",
            "Build URL",
            "Check active"
        ]
    },
    {
        "q": "What is child routing?",
        "type": "mcq",
        "o": [
            "Nested routes within parent routes",
            "Child routes",
            "Nested paths",
            "Sub routes"
        ]
    },
    {
        "q": "Child routes use the 'children' property.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this child route do?",
        "type": "mcq",
        "c": "{\n  path: 'admin',\n  component: AdminComponent,\n  children: [\n    { path: 'users', component: UsersComponent }\n  ]\n}",
        "o": [
            "Creates /admin/users nested route",
            "Creates admin",
            "Nests users",
            "Links admin"
        ]
    },
    {
        "q": "The _____ property defines nested routes.",
        "type": "fill_blank",
        "answers": [
            "children"
        ],
        "other_options": [
            "nested",
            "child",
            "subroutes"
        ]
    },
    {
        "q": "Child routes need router-outlet in parent component.",
        "type": "mcq",
        "o": [
            "True - parent must have outlet for children",
            "False - automatic",
            "Only sometimes",
            "Never needed"
        ]
    },
    {
        "q": "Match nesting concepts:",
        "type": "match",
        "left": [
            "Parent route",
            "Child route",
            "Nested outlet",
            "Relative path"
        ],
        "right": [
            "Container",
            "Nested view",
            "Child render",
            "From parent"
        ]
    },
    {
        "q": "What is route guard?",
        "type": "mcq",
        "o": [
            "Function controlling route access",
            "Route protector",
            "Path guard",
            "Access control"
        ]
    },
    {
        "q": "Guards can prevent navigation to/from routes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is CanActivate guard?",
        "type": "mcq",
        "o": [
            "Guard controlling if route can be activated",
            "Activate guard",
            "Access guard",
            "Entry guard"
        ]
    },
    {
        "q": "The _____ guard runs before entering a route.",
        "type": "fill_blank",
        "answers": [
            "CanActivate"
        ],
        "other_options": [
            "CanEnter",
            "CanAccess",
            "CanLoad"
        ]
    },
    {
        "q": "What is CanActivateFn?",
        "type": "mcq",
        "o": [
            "Function type for functional guards",
            "Guard function",
            "Activate function",
            "Access function"
        ]
    },
    {
        "q": "Match guard types:",
        "type": "match",
        "left": [
            "CanActivate",
            "CanDeactivate",
            "CanMatch",
            "Resolve"
        ],
        "right": [
            "Enter route",
            "Leave route",
            "Match route",
            "Pre-fetch data"
        ]
    },
    {
        "q": "What does this guard do?",
        "type": "mcq",
        "c": "export const authGuard: CanActivateFn = () => {\n  return inject(AuthService).isLoggedIn();\n};",
        "o": [
            "Allows access only if user is logged in",
            "Guards auth",
            "Checks login",
            "Returns auth"
        ]
    },
    {
        "q": "Functional guards use inject() for dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is CanDeactivate guard?",
        "type": "mcq",
        "o": [
            "Guard controlling if user can leave a route",
            "Exit guard",
            "Leave guard",
            "Deactivate guard"
        ]
    },
    {
        "q": "The _____ guard confirms navigation away.",
        "type": "fill_blank",
        "answers": [
            "CanDeactivate"
        ],
        "other_options": [
            "CanLeave",
            "CanExit",
            "CanNavigate"
        ]
    },
    {
        "q": "What does this CanDeactivate do?",
        "type": "mcq",
        "c": "export const unsavedGuard: CanDeactivateFn<HasUnsavedChanges> = (component) => {\n  return component.canLeave();\n};",
        "o": [
            "Asks component if user can leave with unsaved changes",
            "Deactivates route",
            "Saves changes",
            "Exits component"
        ]
    },
    {
        "q": "CanDeactivate can show confirmation dialogs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is CanMatch guard?",
        "type": "mcq",
        "o": [
            "Guard controlling if route config can match",
            "Match guard",
            "Route match",
            "Config guard"
        ]
    },
    {
        "q": "Match guard return values:",
        "type": "match",
        "left": [
            "true",
            "false",
            "UrlTree",
            "Observable"
        ],
        "right": [
            "Allow",
            "Block",
            "Redirect",
            "Async decision"
        ]
    },
    {
        "q": "What is route resolver?",
        "type": "mcq",
        "o": [
            "Pre-fetches data before route activates",
            "Data resolver",
            "Route resolver",
            "Fetch resolver"
        ]
    },
    {
        "q": "The _____ ensures data is ready before component loads.",
        "type": "fill_blank",
        "answers": [
            "resolver"
        ],
        "other_options": [
            "guard",
            "loader",
            "fetcher"
        ]
    },
    {
        "q": "What does this resolver do?",
        "type": "mcq",
        "c": "export const userResolver: ResolveFn<User> = (route) => {\n  return inject(UserService).getUser(route.params['id']);\n};",
        "o": [
            "Fetches user data before route loads",
            "Resolves user",
            "Creates user",
            "Logs user"
        ]
    },
    {
        "q": "Resolvers block navigation until data is ready.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is RedirectTo?",
        "type": "mcq",
        "o": [
            "Route property that redirects to another path",
            "Redirect route",
            "Path redirect",
            "Navigation redirect"
        ]
    },
    {
        "q": "Match route properties:",
        "type": "match",
        "left": [
            "path",
            "component",
            "redirectTo",
            "pathMatch"
        ],
        "right": [
            "URL segment",
            "View",
            "Redirect",
            "Match strategy"
        ]
    },
    {
        "q": "What does this redirect do?",
        "type": "mcq",
        "c": "{ path: '', redirectTo: '/home', pathMatch: 'full' }",
        "o": [
            "Redirects empty path to /home",
            "Creates redirect",
            "Links home",
            "Empties path"
        ]
    },
    {
        "q": "The _____ property specifies redirect destination.",
        "type": "fill_blank",
        "answers": [
            "redirectTo"
        ],
        "other_options": [
            "redirect",
            "to",
            "target"
        ]
    },
    {
        "q": "What is pathMatch: 'full'?",
        "type": "mcq",
        "o": [
            "Route matches only if entire URL matches path",
            "Full match",
            "Complete match",
            "Exact match"
        ]
    },
    {
        "q": "pathMatch: 'prefix' is the default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is wildcard route?",
        "type": "mcq",
        "o": [
            "Route using ** that matches any URL",
            "Catch all",
            "Default route",
            "Any route"
        ]
    },
    {
        "q": "Match pathMatch values:",
        "type": "match",
        "left": [
            "full",
            "prefix"
        ],
        "right": [
            "Exact match",
            "Starts with"
        ]
    },
    {
        "q": "What does this wildcard do?",
        "type": "mcq",
        "c": "{ path: '**', component: NotFoundComponent }",
        "o": [
            "Shows NotFoundComponent for unknown URLs",
            "Catches all",
            "Creates wildcard",
            "Matches any"
        ]
    },
    {
        "q": "Wildcard routes should be last in Routes array.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is named outlet?",
        "type": "mcq",
        "o": [
            "Secondary router-outlet with a name for auxiliary routes",
            "Named view",
            "Outlet name",
            "Second outlet"
        ]
    },
    {
        "q": "The _____ property names a router outlet.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "id",
            "outlet",
            "named"
        ]
    },
    {
        "q": "What does this named outlet do?",
        "type": "mcq",
        "c": "<router-outlet name=\"sidebar\"></router-outlet>",
        "o": [
            "Creates secondary outlet for sidebar content",
            "Names outlet",
            "Creates sidebar",
            "Outlets sidebar"
        ]
    },
    {
        "q": "Match outlet concepts:",
        "type": "match",
        "left": [
            "Primary",
            "Named",
            "Auxiliary",
            "outlet property"
        ],
        "right": [
            "Default outlet",
            "Secondary outlet",
            "Side content",
            "Target outlet"
        ]
    },
    {
        "q": "What is auxiliary route?",
        "type": "mcq",
        "o": [
            "Route that renders in named outlet alongside primary",
            "Side route",
            "Extra route",
            "Secondary route"
        ]
    },
    {
        "q": "Auxiliary routes use outlet property.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is preloading strategy?",
        "type": "mcq",
        "o": [
            "Strategy for loading lazy modules in background",
            "Preload strategy",
            "Load strategy",
            "Background load"
        ]
    },
    {
        "q": "The _____ strategy preloads all lazy modules.",
        "type": "fill_blank",
        "answers": [
            "PreloadAllModules"
        ],
        "other_options": [
            "PreloadAll",
            "LoadAll",
            "EagerLoad"
        ]
    },
    {
        "q": "What does this preloading do?",
        "type": "mcq",
        "c": "provideRouter(routes, withPreloading(PreloadAllModules))",
        "o": [
            "Preloads all lazy modules after app starts",
            "Preloads routes",
            "Loads modules",
            "Configures preload"
        ]
    },
    {
        "q": "Match preloading strategies:",
        "type": "match",
        "left": [
            "NoPreloading",
            "PreloadAllModules",
            "Custom"
        ],
        "right": [
            "No preload",
            "Preload all",
            "Selective preload"
        ]
    },
    {
        "q": "What is custom PreloadingStrategy?",
        "type": "mcq",
        "o": [
            "Strategy that selectively preloads based on logic",
            "Custom preload",
            "Selective load",
            "Logic load"
        ]
    },
    {
        "q": "Custom strategies implement PreloadingStrategy interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is route data property?",
        "type": "mcq",
        "o": [
            "Static data attached to route configuration",
            "Route info",
            "Path data",
            "Config data"
        ]
    },
    {
        "q": "The _____ property provides static route data.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "static",
            "info",
            "meta"
        ]
    },
    {
        "q": "Rearrange navigation flow:",
        "type": "rearrange",
        "words": [
            "User clicks",
            "Router recognizes URL",
            "Guards run",
            "Resolvers run",
            "Component loads"
        ]
    },
    {
        "q": "Rearrange route matching:",
        "type": "rearrange",
        "words": [
            "Parse URL",
            "Match routes",
            "Create route state",
            "Apply guards",
            "Activate route"
        ]
    },
    {
        "q": "What is router event?",
        "type": "mcq",
        "o": [
            "Observable events during navigation lifecycle",
            "Route event",
            "Navigation event",
            "Router signal"
        ]
    },
    {
        "q": "Router.events is an Observable of navigation events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is NavigationStart event?",
        "type": "mcq",
        "o": [
            "Fired when navigation begins",
            "Start event",
            "Begin event",
            "First event"
        ]
    },
    {
        "q": "The _____ event fires when navigation starts.",
        "type": "fill_blank",
        "answers": [
            "NavigationStart"
        ],
        "other_options": [
            "NavigationBegin",
            "RouteStart",
            "StartNavigation"
        ]
    },
    {
        "q": "What is NavigationEnd event?",
        "type": "mcq",
        "o": [
            "Fired when navigation completes successfully",
            "End event",
            "Complete event",
            "Finish event"
        ]
    },
    {
        "q": "Match router events:",
        "type": "match",
        "left": [
            "NavigationStart",
            "NavigationEnd",
            "NavigationCancel",
            "NavigationError"
        ],
        "right": [
            "Begin",
            "Success",
            "Cancelled",
            "Failed"
        ]
    },
    {
        "q": "What is NavigationCancel event?",
        "type": "mcq",
        "o": [
            "Fired when navigation is cancelled by guard or redirect",
            "Cancel event",
            "Stop event",
            "Abort event"
        ]
    },
    {
        "q": "Guards returning false trigger NavigationCancel.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is NavigationError event?",
        "type": "mcq",
        "o": [
            "Fired when navigation fails due to error",
            "Error event",
            "Fail event",
            "Exception event"
        ]
    },
    {
        "q": "The _____ event contains the error that occurred.",
        "type": "fill_blank",
        "answers": [
            "NavigationError"
        ],
        "other_options": [
            "RouteError",
            "NavigationFail",
            "ErrorEvent"
        ]
    },
    {
        "q": "What is RouteConfigLoadStart event?",
        "type": "mcq",
        "o": [
            "Fired before lazy loading a route config",
            "Load start",
            "Config load",
            "Lazy start"
        ]
    },
    {
        "q": "Match lazy loading events:",
        "type": "match",
        "left": [
            "RouteConfigLoadStart",
            "RouteConfigLoadEnd",
            "ChildActivationStart",
            "ChildActivationEnd"
        ],
        "right": [
            "Before load",
            "After load",
            "Child starting",
            "Child done"
        ]
    },
    {
        "q": "What does this router event code do?",
        "type": "mcq",
        "c": "this.router.events.pipe(\n  filter(e => e instanceof NavigationEnd)\n).subscribe(e => console.log('Navigated to', e.url));",
        "o": [
            "Logs URL after each successful navigation",
            "Filters events",
            "Creates navigation",
            "Ends navigation"
        ]
    },
    {
        "q": "Router events can show loading indicators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is TitleStrategy?",
        "type": "mcq",
        "o": [
            "Service controlling how page titles are set",
            "Title service",
            "Page title",
            "Title method"
        ]
    },
    {
        "q": "The _____ configures dynamic page titles.",
        "type": "fill_blank",
        "answers": [
            "TitleStrategy"
        ],
        "other_options": [
            "TitleService",
            "PageTitle",
            "DocumentTitle"
        ]
    },
    {
        "q": "What is route title property?",
        "type": "mcq",
        "o": [
            "Static or resolved title for the route",
            "Page title",
            "Route name",
            "Title text"
        ]
    },
    {
        "q": "Match title configuration:",
        "type": "match",
        "left": [
            "title string",
            "title resolver",
            "TitleStrategy",
            "Title service"
        ],
        "right": [
            "Static",
            "Dynamic",
            "Custom logic",
            "Set title"
        ]
    },
    {
        "q": "What does this title config do?",
        "type": "mcq",
        "c": "{ path: 'products', component: ProductsComponent, title: 'Our Products' }",
        "o": [
            "Sets page title to 'Our Products' on this route",
            "Names route",
            "Creates title",
            "Labels page"
        ]
    },
    {
        "q": "Title resolvers can fetch dynamic titles.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is scroll position restoration?",
        "type": "mcq",
        "o": [
            "Restoring scroll position on navigation",
            "Scroll restore",
            "Position save",
            "Scroll memory"
        ]
    },
    {
        "q": "The _____ feature restores scroll on back navigation.",
        "type": "fill_blank",
        "answers": [
            "withInMemoryScrolling"
        ],
        "other_options": [
            "withScrollRestore",
            "scrollPositionRestoration",
            "enableScroll"
        ]
    },
    {
        "q": "What does this scroll config do?",
        "type": "mcq",
        "c": "provideRouter(routes, withInMemoryScrolling({\n  scrollPositionRestoration: 'enabled'\n}))",
        "o": [
            "Enables scroll position restoration on navigation",
            "Enables scrolling",
            "Configures memory",
            "Adds scroll"
        ]
    },
    {
        "q": "Match scroll restoration options:",
        "type": "match",
        "left": [
            "disabled",
            "enabled",
            "top"
        ],
        "right": [
            "No restore",
            "Restore position",
            "Scroll to top"
        ]
    },
    {
        "q": "What is anchorScrolling?",
        "type": "mcq",
        "o": [
            "Scrolling to element by fragment/anchor in URL",
            "Anchor scroll",
            "Hash scroll",
            "Fragment scroll"
        ]
    },
    {
        "q": "Anchor scrolling uses URL fragment like #section.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is RouterState?",
        "type": "mcq",
        "o": [
            "Tree of activated routes representing current URL",
            "Route state",
            "Router data",
            "Navigation state"
        ]
    },
    {
        "q": "The _____ represents the current route tree.",
        "type": "fill_blank",
        "answers": [
            "RouterState"
        ],
        "other_options": [
            "RouteTree",
            "NavigationState",
            "RouteState"
        ]
    },
    {
        "q": "What is ActivatedRouteSnapshot?",
        "type": "mcq",
        "o": [
            "Immutable snapshot of route at a moment in time",
            "Route snapshot",
            "Frozen route",
            "Route copy"
        ]
    },
    {
        "q": "Match route state types:",
        "type": "match",
        "left": [
            "RouterState",
            "ActivatedRoute",
            "RouterStateSnapshot",
            "ActivatedRouteSnapshot"
        ],
        "right": [
            "Route tree",
            "Observable route",
            "Tree snapshot",
            "Route snapshot"
        ]
    },
    {
        "q": "What is RouterStateSnapshot?",
        "type": "mcq",
        "o": [
            "Immutable snapshot of entire router state",
            "State snapshot",
            "Router copy",
            "Frozen state"
        ]
    },
    {
        "q": "Guards receive RouterStateSnapshot as parameter.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is UrlTree?",
        "type": "mcq",
        "o": [
            "Parsed representation of a URL",
            "URL object",
            "Path tree",
            "Route tree"
        ]
    },
    {
        "q": "The _____ represents parsed URL structure.",
        "type": "fill_blank",
        "answers": [
            "UrlTree"
        ],
        "other_options": [
            "ParsedUrl",
            "UrlStructure",
            "RoutePath"
        ]
    },
    {
        "q": "What is createUrlTree()?",
        "type": "mcq",
        "o": [
            "Creates UrlTree from route commands",
            "Create URL",
            "Build tree",
            "Parse URL"
        ]
    },
    {
        "q": "Match URL utilities:",
        "type": "match",
        "left": [
            "createUrlTree",
            "serializeUrl",
            "parseUrl",
            "isActive"
        ],
        "right": [
            "Build tree",
            "Tree to string",
            "String to tree",
            "Check active"
        ]
    },
    {
        "q": "What does this createUrlTree do?",
        "type": "mcq",
        "c": "const tree = this.router.createUrlTree(['/users', 123], {\n  queryParams: { tab: 'details' }\n});",
        "o": [
            "Creates URL tree for /users/123?tab=details",
            "Creates tree",
            "Builds URL",
            "Parses path"
        ]
    },
    {
        "q": "Guards can return UrlTree to redirect.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is relative navigation?",
        "type": "mcq",
        "o": [
            "Navigating relative to current route",
            "Relative path",
            "Local navigation",
            "Context nav"
        ]
    },
    {
        "q": "The _____ option enables relative navigation.",
        "type": "fill_blank",
        "answers": [
            "relativeTo"
        ],
        "other_options": [
            "relative",
            "from",
            "basePath"
        ]
    },
    {
        "q": "What does this relative navigation do?",
        "type": "mcq",
        "c": "this.router.navigate(['details'], { relativeTo: this.route });",
        "o": [
            "Navigates to details relative to current route",
            "Navigates details",
            "Goes relative",
            "Adds details"
        ]
    },
    {
        "q": "Match navigation options:",
        "type": "match",
        "left": [
            "relativeTo",
            "queryParams",
            "fragment",
            "replaceUrl"
        ],
        "right": [
            "Base route",
            "Query string",
            "URL hash",
            "Replace history"
        ]
    },
    {
        "q": "What is queryParamsHandling?",
        "type": "mcq",
        "o": [
            "How to handle query params during navigation",
            "Query handling",
            "Param option",
            "Query rule"
        ]
    },
    {
        "q": "queryParamsHandling: 'preserve' keeps existing params.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does queryParamsHandling: 'merge' do?",
        "type": "mcq",
        "o": [
            "Merges new query params with existing ones",
            "Merge params",
            "Combine params",
            "Mix params"
        ]
    },
    {
        "q": "Match queryParamsHandling values:",
        "type": "match",
        "left": [
            "preserve",
            "merge"
        ],
        "right": [
            "Keep all existing",
            "Combine with new"
        ]
    },
    {
        "q": "What is skipLocationChange?",
        "type": "mcq",
        "o": [
            "Navigates without changing browser URL",
            "Skip URL",
            "Hidden navigation",
            "Silent nav"
        ]
    },
    {
        "q": "The _____ option hides navigation from URL bar.",
        "type": "fill_blank",
        "answers": [
            "skipLocationChange"
        ],
        "other_options": [
            "hideUrl",
            "silentNav",
            "noUrlChange"
        ]
    },
    {
        "q": "What is replaceUrl?",
        "type": "mcq",
        "o": [
            "Replaces current URL in history instead of adding",
            "Replace URL",
            "Swap URL",
            "Override URL"
        ]
    },
    {
        "q": "Match navigation extras:",
        "type": "match",
        "left": [
            "skipLocationChange",
            "replaceUrl",
            "state",
            "queryParamsHandling"
        ],
        "right": [
            "Don't update URL",
            "Replace in history",
            "Navigation state",
            "Handle query"
        ]
    },
    {
        "q": "What is navigation state?",
        "type": "mcq",
        "o": [
            "Custom state object passed with navigation",
            "Nav state",
            "Route state",
            "Page state"
        ]
    },
    {
        "q": "Navigation state is available via window.history.state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this state navigation do?",
        "type": "mcq",
        "c": "this.router.navigate(['/checkout'], {\n  state: { fromCart: true, items: this.cartItems }\n});",
        "o": [
            "Navigates with cart info in navigation state",
            "Sets state",
            "Navigates checkout",
            "Creates state"
        ]
    },
    {
        "q": "The _____ property passes extra data to navigation.",
        "type": "fill_blank",
        "answers": [
            "state"
        ],
        "other_options": [
            "data",
            "extra",
            "info"
        ]
    },
    {
        "q": "What is CanActivateChild guard?",
        "type": "mcq",
        "o": [
            "Guard run for child routes of a parent",
            "Child guard",
            "Nested guard",
            "Children guard"
        ]
    },
    {
        "q": "Match guard scopes:",
        "type": "match",
        "left": [
            "CanActivate",
            "CanActivateChild",
            "CanDeactivate",
            "CanMatch"
        ],
        "right": [
            "Route entry",
            "Child routes",
            "Route exit",
            "Route matching"
        ]
    },
    {
        "q": "What is CanLoad guard?",
        "type": "mcq",
        "o": [
            "Guard preventing lazy loading of module",
            "Load guard",
            "Module guard",
            "Lazy guard"
        ]
    },
    {
        "q": "CanLoad is deprecated in favor of CanMatch.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is input binding from route params?",
        "type": "mcq",
        "o": [
            "Automatically binding route params to component inputs",
            "Param binding",
            "Input route",
            "Bind param"
        ]
    },
    {
        "q": "The _____ feature binds route params to @Input.",
        "type": "fill_blank",
        "answers": [
            "withComponentInputBinding"
        ],
        "other_options": [
            "withParamBinding",
            "bindInputs",
            "routeToInput"
        ]
    },
    {
        "q": "What does this input binding do?",
        "type": "mcq",
        "c": "@Input() id!: string;  // Automatically set from :id param",
        "o": [
            "Gets 'id' route parameter automatically as input",
            "Sets ID",
            "Inputs param",
            "Binds ID"
        ]
    },
    {
        "q": "Input binding works with route params, query params, and data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is route reuse strategy?",
        "type": "mcq",
        "o": [
            "Strategy controlling when to reuse route components",
            "Reuse strategy",
            "Component reuse",
            "Route cache"
        ]
    },
    {
        "q": "Match reuse concepts:",
        "type": "match",
        "left": [
            "RouteReuseStrategy",
            "shouldDetach",
            "shouldAttach",
            "retrieve"
        ],
        "right": [
            "Reuse interface",
            "Store component",
            "Restore component",
            "Get stored"
        ]
    },
    {
        "q": "What is custom RouteReuseStrategy?",
        "type": "mcq",
        "o": [
            "Custom logic for caching and reusing route components",
            "Custom reuse",
            "Cache strategy",
            "Reuse logic"
        ]
    },
    {
        "q": "Custom strategies can cache components for faster switching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is withDebugTracing()?",
        "type": "mcq",
        "o": [
            "Enables router event logging for debugging",
            "Debug tracing",
            "Route logging",
            "Event debug"
        ]
    },
    {
        "q": "The _____ feature logs router events to console.",
        "type": "fill_blank",
        "answers": [
            "withDebugTracing"
        ],
        "other_options": [
            "withLogging",
            "enableDebug",
            "withTrace"
        ]
    },
    {
        "q": "What is withRouterConfig()?",
        "type": "mcq",
        "o": [
            "Configures additional router options",
            "Router config",
            "Route options",
            "Config helper"
        ]
    },
    {
        "q": "Match router features:",
        "type": "match",
        "left": [
            "withDebugTracing",
            "withPreloading",
            "withComponentInputBinding",
            "withRouterConfig"
        ],
        "right": [
            "Debug logging",
            "Preload strategy",
            "Input binding",
            "Extra config"
        ]
    },
    {
        "q": "What is paramsInheritanceStrategy?",
        "type": "mcq",
        "o": [
            "How child routes inherit parent params",
            "Param inheritance",
            "Child params",
            "Inherit strategy"
        ]
    },
    {
        "q": "paramsInheritanceStrategy: 'always' inherits all parent params.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is onSameUrlNavigation?",
        "type": "mcq",
        "o": [
            "Behavior when navigating to same URL",
            "Same URL",
            "Reload behavior",
            "URL match"
        ]
    },
    {
        "q": "Match same URL options:",
        "type": "match",
        "left": [
            "ignore",
            "reload"
        ],
        "right": [
            "Do nothing",
            "Re-trigger navigation"
        ]
    },
    {
        "q": "What is urlUpdateStrategy?",
        "type": "mcq",
        "o": [
            "When to update browser URL during navigation",
            "URL update",
            "Update strategy",
            "URL timing"
        ]
    },
    {
        "q": "The _____ controls when browser URL changes.",
        "type": "fill_blank",
        "answers": [
            "urlUpdateStrategy"
        ],
        "other_options": [
            "urlTiming",
            "urlChange",
            "updateUrl"
        ]
    },
    {
        "q": "What is matrix parameters?",
        "type": "mcq",
        "o": [
            "Route parameters using semicolon syntax",
            "Matrix params",
            "Semi params",
            "Segment params"
        ]
    },
    {
        "q": "Match parameter types:",
        "type": "match",
        "left": [
            "Path params",
            "Query params",
            "Matrix params",
            "Fragment"
        ],
        "right": [
            ":id",
            "?key=val",
            ";key=val",
            "#section"
        ]
    },
    {
        "q": "What does this matrix params do?",
        "type": "mcq",
        "c": "<a [routerLink]=\"['/products', {page: 1, sort: 'name'}]\">Products</a>",
        "o": [
            "Navigates to /products;page=1;sort=name",
            "Sets matrix",
            "Links products",
            "Adds params"
        ]
    },
    {
        "q": "Matrix parameters are part of the path, not query string.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is standalone routing?",
        "type": "mcq",
        "o": [
            "Routing without NgModules using provideRouter",
            "Standalone routes",
            "Module-free routing",
            "Direct routing"
        ]
    },
    {
        "q": "The _____ function configures standalone routing.",
        "type": "fill_blank",
        "answers": [
            "provideRouter"
        ],
        "other_options": [
            "configureRouter",
            "setupRouter",
            "createRouter"
        ]
    },
    {
        "q": "What does this standalone routing do?",
        "type": "mcq",
        "c": "bootstrapApplication(AppComponent, {\n  providers: [provideRouter(routes)]\n});",
        "o": [
            "Configures routing for standalone app",
            "Bootstraps routes",
            "Creates router",
            "Provides app"
        ]
    },
    {
        "q": "Match module vs standalone routing:",
        "type": "match",
        "left": [
            "RouterModule.forRoot",
            "RouterModule.forChild",
            "provideRouter",
            "loadChildren"
        ],
        "right": [
            "NgModule root",
            "NgModule child",
            "Standalone root",
            "Lazy load"
        ]
    },
    {
        "q": "Rearrange guard execution order:",
        "type": "rearrange",
        "words": [
            "CanMatch",
            "CanLoad",
            "CanActivate",
            "CanActivateChild",
            "Resolve"
        ]
    },
    {
        "q": "Rearrange lazy loading steps:",
        "type": "rearrange",
        "words": [
            "Route matched",
            "Check CanMatch",
            "Download chunk",
            "Register routes",
            "Activate component"
        ]
    },
    {
        "q": "What is route path matching?",
        "type": "mcq",
        "o": [
            "How router matches URL segments to route paths",
            "Path match",
            "Route match",
            "URL match"
        ]
    },
    {
        "q": "Routes are matched in order they are defined.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is primary outlet?",
        "type": "mcq",
        "o": [
            "Default unnamed router-outlet",
            "Main outlet",
            "First outlet",
            "Default outlet"
        ]
    },
    {
        "q": "The _____ outlet renders the main route.",
        "type": "fill_blank",
        "answers": [
            "primary"
        ],
        "other_options": [
            "main",
            "default",
            "root"
        ]
    },
    {
        "q": "What is outlet context?",
        "type": "mcq",
        "o": [
            "Information about activated outlet and component",
            "Outlet info",
            "Context data",
            "Outlet data"
        ]
    },
    {
        "q": "Match outlet properties:",
        "type": "match",
        "left": [
            "name",
            "activatedRoute",
            "component",
            "activateEvents"
        ],
        "right": [
            "Outlet name",
            "Current route",
            "Current component",
            "Activation events"
        ]
    },
    {
        "q": "What is router outlet events?",
        "type": "mcq",
        "o": [
            "Events emitted when components activate/deactivate",
            "Outlet events",
            "Route events",
            "Component events"
        ]
    },
    {
        "q": "activate event fires when component is activated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this outlet event do?",
        "type": "mcq",
        "c": "<router-outlet (activate)=\"onActivate($event)\" (deactivate)=\"onDeactivate($event)\"></router-outlet>",
        "o": [
            "Handles component activation and deactivation",
            "Activates outlet",
            "Creates events",
            "Logs changes"
        ]
    },
    {
        "q": "The _____ event fires when route component is removed.",
        "type": "fill_blank",
        "answers": [
            "deactivate"
        ],
        "other_options": [
            "remove",
            "destroy",
            "unload"
        ]
    },
    {
        "q": "Rearrange route configuration best practices:",
        "type": "rearrange",
        "words": [
            "Specific routes first",
            "Dynamic routes",
            "Lazy loaded routes",
            "Wildcard route last"
        ]
    },
    {
        "q": "Rearrange title resolution:",
        "type": "rearrange",
        "words": [
            "Route matched",
            "Check title property",
            "Run title resolver",
            "TitleStrategy formats",
            "Document.title set"
        ]
    },
    {
        "q": "What is a functional guard in Angular?",
        "type": "mcq",
        "o": [
            "A guard defined as a function instead of a class",
            "A class guard",
            "A service guard",
            "A component guard"
        ]
    },
    {
        "q": "Functional guards are simpler than class guards.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this functional guard do?",
        "type": "mcq",
        "c": "export const authGuard: CanActivateFn = () => inject(AuthService).isLoggedIn();",
        "o": [
            "Checks authentication using inject()",
            "Creates auth service",
            "Logs user in",
            "Redirects user"
        ]
    },
    {
        "q": "The _____ function is used to inject services in functional guards.",
        "type": "fill_blank",
        "answers": [
            "inject"
        ],
        "other_options": [
            "provide",
            "get",
            "service"
        ]
    },
    {
        "q": "Match functional guard types:",
        "type": "match",
        "left": [
            "CanActivateFn",
            "CanDeactivateFn",
            "CanMatchFn",
            "ResolveFn"
        ],
        "right": [
            "Route activation guard",
            "Route leave guard",
            "Route matching guard",
            "Data resolver"
        ]
    },
    {
        "q": "What is CanMatchFn used for?",
        "type": "mcq",
        "o": [
            "Determining if a route configuration should match",
            "Matching components",
            "Matching data",
            "Matching parameters"
        ]
    },
    {
        "q": "CanMatch guards run before lazy loading module.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard return?",
        "type": "mcq",
        "c": "const adminGuard: CanMatchFn = () => inject(AuthService).hasRole('admin') ? true : inject(Router).createUrlTree(['/unauthorized']);",
        "o": [
            "Boolean or UrlTree for redirect",
            "Always true",
            "Always redirects",
            "Role name"
        ]
    },
    {
        "q": "The _____ type is the function signature for route resolvers.",
        "type": "fill_blank",
        "answers": [
            "ResolveFn"
        ],
        "other_options": [
            "ResolverFn",
            "DataFn",
            "FetchFn"
        ]
    },
    {
        "q": "Rearrange functional guard execution:",
        "type": "rearrange",
        "words": [
            "Navigation starts",
            "CanMatch guards run",
            "CanActivate guards run",
            "Resolvers execute",
            "Component renders"
        ]
    },
    {
        "q": "What is RedirectCommand in modern Angular?",
        "type": "mcq",
        "o": [
            "A class that represents a redirect in guards",
            "A redirect service",
            "A route command",
            "A navigation mode"
        ]
    },
    {
        "q": "RedirectCommand can be returned from guards instead of UrlTree.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard return?",
        "type": "mcq",
        "c": "return new RedirectCommand(router.parseUrl('/login'), { skipLocationChange: true });",
        "o": [
            "A redirect with navigation extras",
            "A simple redirect",
            "A UrlTree",
            "A boolean"
        ]
    },
    {
        "q": "The _____ class allows specifying navigation extras when redirecting from guards.",
        "type": "fill_blank",
        "answers": [
            "RedirectCommand"
        ],
        "other_options": [
            "UrlTree",
            "NavigationExtras",
            "RedirectExtras"
        ]
    },
    {
        "q": "Match guard return types:",
        "type": "match",
        "left": [
            "true",
            "false",
            "UrlTree",
            "RedirectCommand"
        ],
        "right": [
            "Allow navigation",
            "Block navigation",
            "Redirect navigation",
            "Redirect with extras"
        ]
    },
    {
        "q": "What is router testing in Angular?",
        "type": "mcq",
        "o": [
            "Testing navigation and routing behavior",
            "Testing components",
            "Testing services",
            "Testing templates"
        ]
    },
    {
        "q": "RouterTestingModule is used to test routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test setup do?",
        "type": "mcq",
        "c": "TestBed.configureTestingModule({ imports: [RouterTestingModule.withRoutes(routes)] });",
        "o": [
            "Configures test router with routes",
            "Creates routes",
            "Tests routes",
            "Validates routes"
        ]
    },
    {
        "q": "The _____ module provides test utilities for routing.",
        "type": "fill_blank",
        "answers": [
            "RouterTestingModule"
        ],
        "other_options": [
            "RouterModule",
            "TestingModule",
            "RouteTestModule"
        ]
    },
    {
        "q": "Match router testing utilities:",
        "type": "match",
        "left": [
            "RouterTestingModule",
            "SpyLocation",
            "RouterTestingHarness",
            "fakeAsync"
        ],
        "right": [
            "Router test module",
            "Location spy",
            "Router harness",
            "Async test wrapper"
        ]
    },
    {
        "q": "What is RouterTestingHarness?",
        "type": "mcq",
        "o": [
            "A modern testing utility for router",
            "A route configuration",
            "A testing module",
            "A spy object"
        ]
    },
    {
        "q": "RouterTestingHarness provides navigateByUrl method.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test do?",
        "type": "mcq",
        "c": "const harness = await RouterTestingHarness.create(); const component = await harness.navigateByUrl('/home', HomeComponent);",
        "o": [
            "Navigates and gets component instance",
            "Creates component",
            "Tests navigation",
            "Renders component"
        ]
    },
    {
        "q": "The _____ method navigates in RouterTestingHarness.",
        "type": "fill_blank",
        "answers": [
            "navigateByUrl"
        ],
        "other_options": [
            "navigate",
            "goTo",
            "route"
        ]
    },
    {
        "q": "Rearrange router test setup:",
        "type": "rearrange",
        "words": [
            "Import RouterTestingModule",
            "Configure routes",
            "Create harness",
            "Navigate to route",
            "Assert component state"
        ]
    },
    {
        "q": "What is provideRouter used for in tests?",
        "type": "mcq",
        "o": [
            "Providing router configuration in standalone tests",
            "Creating router",
            "Testing router",
            "Mocking router"
        ]
    },
    {
        "q": "provideRouter can be used with standalone test configuration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test setup do?",
        "type": "mcq",
        "c": "TestBed.configureTestingModule({ providers: [provideRouter(routes), provideLocationMocks()] });",
        "o": [
            "Configures standalone router with mocked location",
            "Creates routes",
            "Provides location",
            "Mocks router"
        ]
    },
    {
        "q": "The _____ function provides mock location for testing.",
        "type": "fill_blank",
        "answers": [
            "provideLocationMocks"
        ],
        "other_options": [
            "mockLocation",
            "locationMock",
            "provideMocks"
        ]
    },
    {
        "q": "Match testing providers:",
        "type": "match",
        "left": [
            "provideRouter",
            "provideLocationMocks",
            "provideNoopAnimations",
            "provideHttpClientTesting"
        ],
        "right": [
            "Router configuration",
            "Location mocks",
            "Animation mocks",
            "HTTP mocks"
        ]
    },
    {
        "q": "What is route environment configuration?",
        "type": "mcq",
        "o": [
            "Different routing based on environment",
            "Environment variables",
            "Route settings",
            "Configuration files"
        ]
    },
    {
        "q": "Routes can be configured differently per environment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "const routes = environment.production ? prodRoutes : devRoutes;",
        "o": [
            "Selects routes based on environment",
            "Creates routes",
            "Validates routes",
            "Merges routes"
        ]
    },
    {
        "q": "The _____ property determines production mode.",
        "type": "fill_blank",
        "answers": [
            "environment.production"
        ],
        "other_options": [
            "isProduction",
            "prodMode",
            "env.prod"
        ]
    },
    {
        "q": "Match environment routing patterns:",
        "type": "match",
        "left": [
            "Debug routes",
            "Feature flags",
            "Mock routes",
            "Production routes"
        ],
        "right": [
            "Development only",
            "Conditional features",
            "Testing data",
            "Live application"
        ]
    },
    {
        "q": "What is dynamic route registration?",
        "type": "mcq",
        "o": [
            "Adding routes at runtime",
            "Static routes",
            "Lazy routes",
            "Preloaded routes"
        ]
    },
    {
        "q": "Routes can be added dynamically after application starts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code do?",
        "type": "mcq",
        "c": "router.resetConfig([...router.config, newRoute]);",
        "o": [
            "Adds a new route to existing configuration",
            "Resets routes",
            "Removes routes",
            "Updates routes"
        ]
    },
    {
        "q": "The _____ method replaces the entire route configuration.",
        "type": "fill_blank",
        "answers": [
            "resetConfig"
        ],
        "other_options": [
            "setConfig",
            "updateConfig",
            "replaceConfig"
        ]
    },
    {
        "q": "Rearrange dynamic route addition:",
        "type": "rearrange",
        "words": [
            "Get current config",
            "Create new route",
            "Merge configurations",
            "Call resetConfig",
            "Navigate to new route"
        ]
    },
    {
        "q": "What is route data inheritance?",
        "type": "mcq",
        "o": [
            "Child routes accessing parent route data",
            "Data sharing",
            "Data binding",
            "Data transfer"
        ]
    },
    {
        "q": "By default route data is inherited from parent.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "withRouterConfig({ paramsInheritanceStrategy: 'always' });",
        "o": [
            "Child routes inherit all parent parameters",
            "Parameter sharing",
            "Parameter binding",
            "Parameter merging"
        ]
    },
    {
        "q": "The _____ strategy controls parameter inheritance.",
        "type": "fill_blank",
        "answers": [
            "paramsInheritanceStrategy"
        ],
        "other_options": [
            "paramStrategy",
            "inheritParams",
            "dataInheritance"
        ]
    },
    {
        "q": "Match inheritance strategies:",
        "type": "match",
        "left": [
            "emptyOnly",
            "always"
        ],
        "right": [
            "Inherit from empty path parents",
            "Inherit from all parents"
        ]
    },
    {
        "q": "What is component communication via routes?",
        "type": "mcq",
        "o": [
            "Passing data between components using route state",
            "Service communication",
            "Event communication",
            "Direct communication"
        ]
    },
    {
        "q": "Navigation state can pass complex objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this navigation do?",
        "type": "mcq",
        "c": "router.navigate(['/details'], { state: { user: userObject, action: 'edit' } });",
        "o": [
            "Passes user object and action in state",
            "Creates user",
            "Edits action",
            "Navigates only"
        ]
    },
    {
        "q": "The _____ property stores navigation state.",
        "type": "fill_blank",
        "answers": [
            "state"
        ],
        "other_options": [
            "data",
            "params",
            "extras"
        ]
    },
    {
        "q": "Match data passing methods:",
        "type": "match",
        "left": [
            "Route parameters",
            "Query parameters",
            "Route data",
            "Navigation state"
        ],
        "right": [
            "URL segment values",
            "Optional URL params",
            "Static configuration",
            "Hidden complex data"
        ]
    },
    {
        "q": "What is getCurrentNavigation?",
        "type": "mcq",
        "o": [
            "Gets the current navigation in progress",
            "Gets current route",
            "Gets navigation history",
            "Gets active component"
        ]
    },
    {
        "q": "getCurrentNavigation returns null after navigation completes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code retrieve?",
        "type": "mcq",
        "c": "const state = this.router.getCurrentNavigation()?.extras?.state;",
        "o": [
            "Navigation state from current navigation",
            "Current route",
            "Navigation extras",
            "Route parameters"
        ]
    },
    {
        "q": "The _____ method gets navigation state during navigation.",
        "type": "fill_blank",
        "answers": [
            "getCurrentNavigation"
        ],
        "other_options": [
            "getNavigation",
            "currentNav",
            "getState"
        ]
    },
    {
        "q": "Rearrange state retrieval timing:",
        "type": "rearrange",
        "words": [
            "Navigation starts",
            "getCurrentNavigation available",
            "Component constructor runs",
            "ngOnInit runs",
            "Navigation completes"
        ]
    },
    {
        "q": "What is router.lastSuccessfulNavigation?",
        "type": "mcq",
        "o": [
            "The most recent successful navigation",
            "Last route",
            "Previous navigation",
            "Navigation history"
        ]
    },
    {
        "q": "lastSuccessfulNavigation persists after navigation completes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code access?",
        "type": "mcq",
        "c": "const previousState = this.router.lastSuccessfulNavigation?.extras?.state;",
        "o": [
            "State from last successful navigation",
            "Current state",
            "Navigation extras",
            "Route data"
        ]
    },
    {
        "q": "The _____ property stores the last successful navigation.",
        "type": "fill_blank",
        "answers": [
            "lastSuccessfulNavigation"
        ],
        "other_options": [
            "lastNavigation",
            "previousNavigation",
            "navigationHistory"
        ]
    },
    {
        "q": "Match navigation properties:",
        "type": "match",
        "left": [
            "getCurrentNavigation",
            "lastSuccessfulNavigation",
            "routerState",
            "url"
        ],
        "right": [
            "Active navigation",
            "Previous navigation",
            "Route tree",
            "Current URL"
        ]
    },
    {
        "q": "What is route fragment?",
        "type": "mcq",
        "o": [
            "The hash portion of URL for anchor links",
            "Route segment",
            "Route part",
            "URL section"
        ]
    },
    {
        "q": "Fragments appear after # in URL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this navigation do?",
        "type": "mcq",
        "c": "router.navigate(['/page'], { fragment: 'section1' });",
        "o": [
            "Navigates to /page#section1",
            "Creates fragment",
            "Adds parameter",
            "Sets anchor"
        ]
    },
    {
        "q": "The _____ property sets URL hash in NavigationExtras.",
        "type": "fill_blank",
        "answers": [
            "fragment"
        ],
        "other_options": [
            "hash",
            "anchor",
            "section"
        ]
    },
    {
        "q": "Match URL parts:",
        "type": "match",
        "left": [
            "/path",
            ";matrix=val",
            "?query=val",
            "#fragment"
        ],
        "right": [
            "Route path",
            "Matrix parameter",
            "Query parameter",
            "Fragment identifier"
        ]
    },
    {
        "q": "What is anchorScrolling?",
        "type": "mcq",
        "o": [
            "Scrolling to fragment element",
            "Anchor creation",
            "Scroll position",
            "Element scrolling"
        ]
    },
    {
        "q": "anchorScrolling is enabled by default.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "withInMemoryScrolling({ anchorScrolling: 'enabled', scrollPositionRestoration: 'top' });",
        "o": [
            "Fragment scrolling and scroll to top on navigation",
            "Scroll restoration",
            "Memory scrolling",
            "Position tracking"
        ]
    },
    {
        "q": "The _____ option enables scrolling to fragment elements.",
        "type": "fill_blank",
        "answers": [
            "anchorScrolling"
        ],
        "other_options": [
            "fragmentScrolling",
            "hashScrolling",
            "elementScrolling"
        ]
    },
    {
        "q": "Rearrange anchor scrolling flow:",
        "type": "rearrange",
        "words": [
            "Navigate with fragment",
            "Route activates",
            "Find element by id",
            "Scroll to element",
            "View updates"
        ]
    },
    {
        "q": "What is scrollOffset?",
        "type": "mcq",
        "o": [
            "Offset applied when scrolling to anchors",
            "Scroll position",
            "Element offset",
            "View offset"
        ]
    },
    {
        "q": "scrollOffset compensates for fixed headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "withInMemoryScrolling({ scrollOffset: [0, 64] });",
        "o": [
            "Adds 64px vertical offset when scrolling",
            "Sets scroll position",
            "Creates offset",
            "Adjusts view"
        ]
    },
    {
        "q": "The _____ option is an array of [x, y] offset values.",
        "type": "fill_blank",
        "answers": [
            "scrollOffset"
        ],
        "other_options": [
            "offset",
            "scrollPosition",
            "viewOffset"
        ]
    },
    {
        "q": "Match scroll options:",
        "type": "match",
        "left": [
            "scrollPositionRestoration",
            "anchorScrolling",
            "scrollOffset",
            "scrollBehavior"
        ],
        "right": [
            "Restore on navigation",
            "Scroll to fragment",
            "Fixed header offset",
            "Smooth scrolling"
        ]
    },
    {
        "q": "What is NavigationBehaviorOptions?",
        "type": "mcq",
        "o": [
            "Options that control navigation behavior",
            "Behavior settings",
            "Navigation mode",
            "Routing options"
        ]
    },
    {
        "q": "NavigationBehaviorOptions includes onSameUrlNavigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "const extras: NavigationBehaviorOptions = { onSameUrlNavigation: 'reload', replaceUrl: true };",
        "o": [
            "Forces reload and replaces history entry",
            "Creates options",
            "Sets behavior",
            "Updates navigation"
        ]
    },
    {
        "q": "The _____ interface defines navigation behavior options.",
        "type": "fill_blank",
        "answers": [
            "NavigationBehaviorOptions"
        ],
        "other_options": [
            "NavigationOptions",
            "RouterOptions",
            "RouteOptions"
        ]
    },
    {
        "q": "Rearrange navigation with behavior options:",
        "type": "rearrange",
        "words": [
            "Create NavigationBehaviorOptions",
            "Set behavior properties",
            "Call navigate with options",
            "Router processes options",
            "Navigation completes"
        ]
    },
    {
        "q": "What is UrlHandlingStrategy?",
        "type": "mcq",
        "o": [
            "Strategy to handle URL parsing",
            "URL creation",
            "URL validation",
            "URL encoding"
        ]
    },
    {
        "q": "UrlHandlingStrategy determines which URLs the router handles.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this strategy implement?",
        "type": "mcq",
        "c": "class CustomUrlHandling implements UrlHandlingStrategy { shouldProcessUrl(url: UrlTree) { return url.root.children['primary']?.segments[0]?.path.startsWith('app'); } }",
        "o": [
            "Only processes URLs starting with /app",
            "Processes all URLs",
            "Validates URLs",
            "Creates URLs"
        ]
    },
    {
        "q": "The _____ method determines if URL should be processed.",
        "type": "fill_blank",
        "answers": [
            "shouldProcessUrl"
        ],
        "other_options": [
            "handleUrl",
            "processUrl",
            "parseUrl"
        ]
    },
    {
        "q": "Match UrlHandlingStrategy methods:",
        "type": "match",
        "left": [
            "shouldProcessUrl",
            "extract",
            "merge"
        ],
        "right": [
            "Check if router handles URL",
            "Get router portion of URL",
            "Combine processed and unprocessed"
        ]
    },
    {
        "q": "What is MergeStrategy in UrlHandlingStrategy?",
        "type": "mcq",
        "o": [
            "Combining processed URL with remaining parts",
            "Merging routes",
            "Combining parameters",
            "Joining paths"
        ]
    },
    {
        "q": "UrlHandlingStrategy is useful for hybrid applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the merge method do?",
        "type": "mcq",
        "c": "merge(newUrlPart: UrlTree, rawUrl: UrlTree) { return newUrlPart; }",
        "o": [
            "Returns only the router-processed portion",
            "Merges all parts",
            "Creates new URL",
            "Updates raw URL"
        ]
    },
    {
        "q": "The _____ method combines router URL with original URL.",
        "type": "fill_blank",
        "answers": [
            "merge"
        ],
        "other_options": [
            "combine",
            "join",
            "concat"
        ]
    },
    {
        "q": "Rearrange URL handling process:",
        "type": "rearrange",
        "words": [
            "URL change detected",
            "shouldProcessUrl called",
            "extract gets router portion",
            "Router processes URL",
            "merge combines result"
        ]
    },
    {
        "q": "What is router outlet animation?",
        "type": "mcq",
        "o": [
            "Animating route transitions",
            "Component animations",
            "View animations",
            "Navigation effects"
        ]
    },
    {
        "q": "Route animations use Angular animations module.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this trigger do?",
        "type": "mcq",
        "c": "trigger('routeAnimations', [transition('* <=> *', [query(':enter', [style({ opacity: 0 })]), group([query(':leave', [animate('200ms', style({ opacity: 0 }))]), query(':enter', [animate('200ms', style({ opacity: 1 }))])])])])",
        "o": [
            "Fades out leaving component and fades in entering",
            "Creates animation",
            "Animates component",
            "Transitions routes"
        ]
    },
    {
        "q": "The _____ selector matches entering component.",
        "type": "fill_blank",
        "answers": [
            ":enter"
        ],
        "other_options": [
            ":incoming",
            ":activate",
            ":new"
        ]
    },
    {
        "q": "Match animation selectors:",
        "type": "match",
        "left": [
            ":enter",
            ":leave",
            ":increment",
            ":decrement"
        ],
        "right": [
            "Entering element",
            "Leaving element",
            "State increase",
            "State decrease"
        ]
    },
    {
        "q": "What is prepareRoute in animations?",
        "type": "mcq",
        "o": [
            "Gets animation data for current route",
            "Prepares route",
            "Creates animation",
            "Sets route"
        ]
    },
    {
        "q": "Route data can specify animation state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "prepareRoute(outlet: RouterOutlet) { return outlet?.activatedRouteData?.['animation']; }",
        "o": [
            "Returns animation state from route data",
            "Prepares outlet",
            "Creates animation",
            "Gets route"
        ]
    },
    {
        "q": "The _____ property stores animation state in route config.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "animation",
            "state",
            "config"
        ]
    },
    {
        "q": "Rearrange route animation setup:",
        "type": "rearrange",
        "words": [
            "Import animations module",
            "Define animation trigger",
            "Add animation data to routes",
            "Bind trigger to outlet",
            "Provide prepareRoute method"
        ]
    },
    {
        "q": "What is ChildrenOutletContexts?",
        "type": "mcq",
        "o": [
            "Service managing child outlet contexts",
            "Child routes",
            "Outlet children",
            "Context manager"
        ]
    },
    {
        "q": "ChildrenOutletContexts tracks activated components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this service provide?",
        "type": "mcq",
        "c": "inject(ChildrenOutletContexts).getContext('primary')?.outlet;",
        "o": [
            "Gets the primary outlet instance",
            "Creates context",
            "Gets children",
            "Manages outlets"
        ]
    },
    {
        "q": "The _____ method retrieves outlet context by name.",
        "type": "fill_blank",
        "answers": [
            "getContext"
        ],
        "other_options": [
            "get",
            "getOutlet",
            "find"
        ]
    },
    {
        "q": "Match outlet context properties:",
        "type": "match",
        "left": [
            "outlet",
            "route",
            "children",
            "resolver"
        ],
        "right": [
            "RouterOutlet instance",
            "Activated route",
            "Child contexts",
            "Component factory resolver"
        ]
    },
    {
        "q": "What is deferrable view routing?",
        "type": "mcq",
        "o": [
            "Route components that load on demand with @defer",
            "Lazy loading",
            "Preloading",
            "Dynamic importing"
        ]
    },
    {
        "q": "@defer blocks can be used in routed components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this template do?",
        "type": "mcq",
        "c": "@defer (on viewport) { <heavy-component /> } @placeholder { <loading-skeleton /> }",
        "o": [
            "Loads heavy component when visible in viewport",
            "Defers loading always",
            "Shows skeleton first",
            "Loads component immediately"
        ]
    },
    {
        "q": "The _____ trigger loads deferred content when visible.",
        "type": "fill_blank",
        "answers": [
            "on viewport"
        ],
        "other_options": [
            "on visible",
            "on scroll",
            "on view"
        ]
    },
    {
        "q": "Match defer triggers:",
        "type": "match",
        "left": [
            "on idle",
            "on viewport",
            "on interaction",
            "on timer"
        ],
        "right": [
            "Browser idle time",
            "In viewport",
            "User interaction",
            "Time delay"
        ]
    },
    {
        "q": "What is @placeholder in defer blocks?",
        "type": "mcq",
        "o": [
            "Content shown before deferred content loads",
            "Error handler",
            "Loading indicator",
            "Fallback content"
        ]
    },
    {
        "q": "@loading shows content while deferred block loads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this defer block provide?",
        "type": "mcq",
        "c": "@defer { <main-content /> } @loading { <spinner /> } @error { <error-msg /> }",
        "o": [
            "Loading spinner and error handling for deferred content",
            "Just loading",
            "Just error",
            "Content only"
        ]
    },
    {
        "q": "The _____ block shows when deferred content fails to load.",
        "type": "fill_blank",
        "answers": [
            "@error"
        ],
        "other_options": [
            "@catch",
            "@fallback",
            "@fail"
        ]
    },
    {
        "q": "Rearrange defer loading sequence:",
        "type": "rearrange",
        "words": [
            "Show @placeholder",
            "Trigger condition met",
            "Show @loading",
            "Load deferred content",
            "Show actual content"
        ]
    },
    {
        "q": "What is prefetch in defer blocks?",
        "type": "mcq",
        "o": [
            "Loading deferred content before trigger",
            "Pre-rendering",
            "Caching",
            "Precompiling"
        ]
    },
    {
        "q": "Prefetch improves perceived performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "@defer (on interaction; prefetch on idle) { <content /> }",
        "o": [
            "Prefetches on idle, shows on interaction",
            "Loads on idle",
            "Shows immediately",
            "Prefetches always"
        ]
    },
    {
        "q": "The _____ keyword enables early loading of deferred content.",
        "type": "fill_blank",
        "answers": [
            "prefetch"
        ],
        "other_options": [
            "preload",
            "cache",
            "eager"
        ]
    },
    {
        "q": "Match defer block sections:",
        "type": "match",
        "left": [
            "@defer",
            "@placeholder",
            "@loading",
            "@error"
        ],
        "right": [
            "Main deferred content",
            "Initial placeholder",
            "Loading state",
            "Error fallback"
        ]
    },
    {
        "q": "What is micro-frontend routing?",
        "type": "mcq",
        "o": [
            "Routing across independently deployed applications",
            "Small routes",
            "Component routing",
            "Local routing"
        ]
    },
    {
        "q": "Module Federation enables micro-frontend routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this route configuration enable?",
        "type": "mcq",
        "c": "{ path: 'remote', loadChildren: () => loadRemoteModule({ remotEntry: 'http://remote/remoteEntry.js', remoteName: 'mfe', exposedModule: './Module' }).then(m => m.RemoteModule) }",
        "o": [
            "Loading remote module from separate deployment",
            "Local module",
            "Lazy module",
            "Dynamic module"
        ]
    },
    {
        "q": "The _____ function loads federated modules.",
        "type": "fill_blank",
        "answers": [
            "loadRemoteModule"
        ],
        "other_options": [
            "loadModule",
            "importModule",
            "fetchModule"
        ]
    },
    {
        "q": "Match micro-frontend terms:",
        "type": "match",
        "left": [
            "Shell",
            "Remote",
            "Exposed module",
            "Shared dependencies"
        ],
        "right": [
            "Host application",
            "External micro-frontend",
            "Module available for loading",
            "Common libraries"
        ]
    },
    {
        "q": "What is shell application in micro-frontends?",
        "type": "mcq",
        "o": [
            "The host that loads remote applications",
            "A small app",
            "Empty container",
            "Base template"
        ]
    },
    {
        "q": "Shell manages top-level routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this shell configuration do?",
        "type": "mcq",
        "c": "const routes = [{ path: 'app1', loadChildren: loadApp1 }, { path: 'app2', loadChildren: loadApp2 }];",
        "o": [
            "Routes to different micro-frontends",
            "Loads apps concurrently",
            "Creates apps",
            "Shares apps"
        ]
    },
    {
        "q": "The _____ application orchestrates micro-frontend loading.",
        "type": "fill_blank",
        "answers": [
            "shell"
        ],
        "other_options": [
            "host",
            "main",
            "parent"
        ]
    },
    {
        "q": "Rearrange micro-frontend navigation:",
        "type": "rearrange",
        "words": [
            "User navigates in shell",
            "Shell routes to MFE path",
            "Load remote entry",
            "Initialize remote module",
            "Remote component renders"
        ]
    },
    {
        "q": "What is SSR routing?",
        "type": "mcq",
        "o": [
            "Server-side rendering with Angular Router",
            "Secure routing",
            "Static routing",
            "Simple routing"
        ]
    },
    {
        "q": "Angular Universal supports full router features.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this SSR configuration provide?",
        "type": "mcq",
        "c": "provideServerRendering(), provideRouter(routes, withInitialNavigation('enabledBlocking'));",
        "o": [
            "SSR with blocking initial navigation",
            "Client routing",
            "Static rendering",
            "Dynamic routing"
        ]
    },
    {
        "q": "The _____ initial navigation mode blocks rendering until route resolves.",
        "type": "fill_blank",
        "answers": [
            "enabledBlocking"
        ],
        "other_options": [
            "blocking",
            "wait",
            "sync"
        ]
    },
    {
        "q": "Match SSR routing options:",
        "type": "match",
        "left": [
            "enabledBlocking",
            "enabledNonBlocking",
            "disabled",
            "TransferState"
        ],
        "right": [
            "Wait for resolution",
            "Parallel resolution",
            "No initial navigation",
            "State transfer"
        ]
    },
    {
        "q": "What is TransferState in SSR routing?",
        "type": "mcq",
        "o": [
            "Transferring server state to client",
            "State management",
            "Route transfer",
            "Data transfer"
        ]
    },
    {
        "q": "TransferState prevents duplicate API calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this resolver do?",
        "type": "mcq",
        "c": "const dataResolver: ResolveFn<Data> = () => { const state = inject(TransferState); const cached = state.get(KEY, null); return cached || inject(DataService).load(); };",
        "o": [
            "Uses cached data from server or fetches fresh",
            "Always fetches",
            "Always caches",
            "Transfers data"
        ]
    },
    {
        "q": "The _____ service shares data between server and client.",
        "type": "fill_blank",
        "answers": [
            "TransferState"
        ],
        "other_options": [
            "StateTransfer",
            "SharedState",
            "ServerState"
        ]
    },
    {
        "q": "Rearrange SSR hydration flow:",
        "type": "rearrange",
        "words": [
            "Server renders route",
            "HTML sent to client",
            "Angular hydrates",
            "TransferState restored",
            "Client continues"
        ]
    },
    {
        "q": "What is route-based code splitting?",
        "type": "mcq",
        "o": [
            "Creating separate bundles per route",
            "Splitting components",
            "Route separation",
            "Code organization"
        ]
    },
    {
        "q": "Lazy loading enables route-based code splitting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What bundle does this create?",
        "type": "mcq",
        "c": "{ path: 'admin', loadChildren: () => import('./admin/admin.routes') }",
        "o": [
            "Separate admin bundle loaded on demand",
            "Main bundle",
            "Vendor bundle",
            "Common bundle"
        ]
    },
    {
        "q": "The _____ function enables code splitting.",
        "type": "fill_blank",
        "answers": [
            "import"
        ],
        "other_options": [
            "require",
            "load",
            "fetch"
        ]
    },
    {
        "q": "Match bundle types:",
        "type": "match",
        "left": [
            "Main bundle",
            "Lazy bundle",
            "Common bundle",
            "Vendor bundle"
        ],
        "right": [
            "Initial application code",
            "Route-specific code",
            "Shared module code",
            "Third-party libraries"
        ]
    },
    {
        "q": "What is route-level error handling?",
        "type": "mcq",
        "o": [
            "Handling errors specific to routes",
            "Global errors",
            "Component errors",
            "Service errors"
        ]
    },
    {
        "q": "NavigationError event indicates route loading failure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this error handler do?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationError)).subscribe(e => logger.error('Route failed', e));",
        "o": [
            "Logs navigation errors",
            "Handles all errors",
            "Prevents errors",
            "Retries navigation"
        ]
    },
    {
        "q": "The _____ event fires when navigation fails.",
        "type": "fill_blank",
        "answers": [
            "NavigationError"
        ],
        "other_options": [
            "RouteError",
            "NavigationFailed",
            "RouteFailed"
        ]
    },
    {
        "q": "Match error scenarios:",
        "type": "match",
        "left": [
            "Guard rejection",
            "Resolver error",
            "Lazy load failure",
            "Invalid route"
        ],
        "right": [
            "NavigationCancel",
            "NavigationError",
            "ChunkLoadError",
            "Wildcard route"
        ]
    },
    {
        "q": "What is chunk loading error recovery?",
        "type": "mcq",
        "o": [
            "Handling failed lazy module loads",
            "Chunk recovery",
            "Bundle recovery",
            "Error prevention"
        ]
    },
    {
        "q": "Chunk errors occur when network fails during lazy loading.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this error handler enable?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationError && e.error?.name === 'ChunkLoadError')).subscribe(() => window.location.reload());",
        "o": [
            "Reloads page on chunk load failure",
            "Retries loading",
            "Shows error",
            "Logs error"
        ]
    },
    {
        "q": "The _____ error indicates lazy bundle failed to load.",
        "type": "fill_blank",
        "answers": [
            "ChunkLoadError"
        ],
        "other_options": [
            "BundleError",
            "LoadError",
            "ModuleError"
        ]
    },
    {
        "q": "Rearrange chunk error handling:",
        "type": "rearrange",
        "words": [
            "User navigates to lazy route",
            "Chunk request fails",
            "NavigationError fired",
            "Check error type",
            "Retry or reload"
        ]
    },
    {
        "q": "What is route caching?",
        "type": "mcq",
        "o": [
            "Preserving route component state",
            "URL caching",
            "Data caching",
            "Request caching"
        ]
    },
    {
        "q": "Angular destroys components by default on navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does custom RouteReuseStrategy enable?",
        "type": "mcq",
        "c": "implements RouteReuseStrategy { shouldReuseRoute(future, curr) { return future.routeConfig === curr.routeConfig; } }",
        "o": [
            "Reuses component when route config matches",
            "Always reuses",
            "Never reuses",
            "Caches all"
        ]
    },
    {
        "q": "The _____ method determines if route should be reused.",
        "type": "fill_blank",
        "answers": [
            "shouldReuseRoute"
        ],
        "other_options": [
            "reuseRoute",
            "canReuse",
            "shouldCache"
        ]
    },
    {
        "q": "Match RouteReuseStrategy methods:",
        "type": "match",
        "left": [
            "shouldReuseRoute",
            "shouldAttach",
            "shouldDetach",
            "store"
        ],
        "right": [
            "Check route reuse",
            "Check restore from cache",
            "Check save to cache",
            "Save route snapshot"
        ]
    },
    {
        "q": "What is shouldDetach used for?",
        "type": "mcq",
        "o": [
            "Determining if route should be cached",
            "Detaching component",
            "Removing route",
            "Disconnecting outlet"
        ]
    },
    {
        "q": "shouldDetach returning true caches the component.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this implementation do?",
        "type": "mcq",
        "c": "shouldDetach(route) { return route.data['cache'] === true; }",
        "o": [
            "Caches routes with cache: true in data",
            "Detaches all",
            "Caches nothing",
            "Checks config"
        ]
    },
    {
        "q": "The _____ method stores detached route for later reuse.",
        "type": "fill_blank",
        "answers": [
            "store"
        ],
        "other_options": [
            "cache",
            "save",
            "detach"
        ]
    },
    {
        "q": "Rearrange route caching flow:",
        "type": "rearrange",
        "words": [
            "Navigate away from route",
            "shouldDetach returns true",
            "store saves snapshot",
            "Navigate back",
            "shouldAttach restores"
        ]
    },
    {
        "q": "What is retrieve in RouteReuseStrategy?",
        "type": "mcq",
        "o": [
            "Getting cached route snapshot",
            "Retrieving data",
            "Getting route",
            "Loading cache"
        ]
    },
    {
        "q": "retrieve returns DetachedRouteHandle for cached routes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this method do?",
        "type": "mcq",
        "c": "retrieve(route) { return this.cache.get(route.routeConfig?.path); }",
        "o": [
            "Returns cached handle for route path",
            "Gets route data",
            "Loads component",
            "Retrieves config"
        ]
    },
    {
        "q": "The _____ type represents cached route state.",
        "type": "fill_blank",
        "answers": [
            "DetachedRouteHandle"
        ],
        "other_options": [
            "RouteHandle",
            "CachedRoute",
            "RouteState"
        ]
    },
    {
        "q": "Match caching methods:",
        "type": "match",
        "left": [
            "shouldDetach",
            "store",
            "shouldAttach",
            "retrieve"
        ],
        "right": [
            "Check if cache route",
            "Save route state",
            "Check if restore route",
            "Get cached state"
        ]
    },
    {
        "q": "What is route permission management?",
        "type": "mcq",
        "o": [
            "Controlling access based on user permissions",
            "Route security",
            "Authentication",
            "Authorization"
        ]
    },
    {
        "q": "Guards can check multiple permissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard check?",
        "type": "mcq",
        "c": "const permissionGuard: CanActivateFn = (route) => { const perms = route.data['permissions']; return inject(AuthService).hasAnyPermission(perms); };",
        "o": [
            "User has any of required permissions",
            "User has all permissions",
            "Route has permissions",
            "Permissions exist"
        ]
    },
    {
        "q": "The _____ property stores required permissions in route config.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "permissions",
            "roles",
            "access"
        ]
    },
    {
        "q": "Match permission patterns:",
        "type": "match",
        "left": [
            "Role-based",
            "Permission-based",
            "Claim-based",
            "Policy-based"
        ],
        "right": [
            "User roles",
            "Specific actions",
            "JWT claims",
            "Business rules"
        ]
    },
    {
        "q": "What is hierarchical route authorization?",
        "type": "mcq",
        "o": [
            "Parent permissions applying to children",
            "Nested permissions",
            "Role hierarchy",
            "Permission inheritance"
        ]
    },
    {
        "q": "CanActivateChild enforces parent-level checks on children.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration enforce?",
        "type": "mcq",
        "c": "{ path: 'admin', canActivate: [adminGuard], canActivateChild: [adminGuard], children: [...] }",
        "o": [
            "Admin guard on parent and all children",
            "Only parent guard",
            "Only child guard",
            "No guards"
        ]
    },
    {
        "q": "The _____ guard runs before each child route.",
        "type": "fill_blank",
        "answers": [
            "canActivateChild"
        ],
        "other_options": [
            "childGuard",
            "childActivate",
            "activateChild"
        ]
    },
    {
        "q": "Rearrange authorization check order:",
        "type": "rearrange",
        "words": [
            "CanMatch guards",
            "CanActivate on parent",
            "CanActivateChild",
            "CanActivate on child",
            "Resolvers"
        ]
    },
    {
        "q": "What is route-based feature flags?",
        "type": "mcq",
        "o": [
            "Enabling routes based on feature toggles",
            "Route flags",
            "Feature routing",
            "Toggle routes"
        ]
    },
    {
        "q": "Feature flags can control route availability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard enable?",
        "type": "mcq",
        "c": "const featureGuard: CanMatchFn = (route) => inject(FeatureService).isEnabled(route.data['feature']);",
        "o": [
            "Routes only available when feature enabled",
            "All routes enabled",
            "Feature detection",
            "Route configuration"
        ]
    },
    {
        "q": "The _____ service typically manages feature toggles.",
        "type": "fill_blank",
        "answers": [
            "FeatureService"
        ],
        "other_options": [
            "ToggleService",
            "FlagService",
            "ConfigService"
        ]
    },
    {
        "q": "Match feature flag patterns:",
        "type": "match",
        "left": [
            "Boolean flag",
            "Percentage rollout",
            "User segment",
            "Environment flag"
        ],
        "right": [
            "On/off toggle",
            "Gradual release",
            "Targeted users",
            "Dev/prod differences"
        ]
    },
    {
        "q": "What is A/B testing with routes?",
        "type": "mcq",
        "o": [
            "Showing different routes to different users",
            "Testing routes",
            "Route comparison",
            "Performance testing"
        ]
    },
    {
        "q": "Multiple route configurations can exist for same path.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "{ path: 'checkout', canMatch: [variantAGuard], component: CheckoutV1 }, { path: 'checkout', component: CheckoutV2 }",
        "o": [
            "Shows V1 to selected users, V2 to others",
            "Shows both",
            "Shows V1 always",
            "Shows V2 always"
        ]
    },
    {
        "q": "The _____ guard determines which variant to show.",
        "type": "fill_blank",
        "answers": [
            "canMatch"
        ],
        "other_options": [
            "canActivate",
            "variant",
            "abTest"
        ]
    },
    {
        "q": "Rearrange A/B route selection:",
        "type": "rearrange",
        "words": [
            "User navigates to path",
            "Check first route canMatch",
            "If passes, use first",
            "If fails, check next",
            "Use matching route"
        ]
    },
    {
        "q": "What is route analytics?",
        "type": "mcq",
        "o": [
            "Tracking navigation events for analytics",
            "Route performance",
            "Navigation statistics",
            "User tracking"
        ]
    },
    {
        "q": "NavigationEnd is commonly used for page view tracking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this subscription track?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationEnd)).subscribe(e => analytics.trackPageView(e.urlAfterRedirects));",
        "o": [
            "Page views with final URL",
            "All events",
            "Navigation starts",
            "Route changes"
        ]
    },
    {
        "q": "The _____ property gives the URL after all redirects.",
        "type": "fill_blank",
        "answers": [
            "urlAfterRedirects"
        ],
        "other_options": [
            "finalUrl",
            "redirectedUrl",
            "actualUrl"
        ]
    },
    {
        "q": "Match analytics events:",
        "type": "match",
        "left": [
            "NavigationStart",
            "NavigationEnd",
            "NavigationCancel",
            "NavigationError"
        ],
        "right": [
            "Navigation initiated",
            "Page view",
            "Abandoned navigation",
            "Failed navigation"
        ]
    },
    {
        "q": "What is route performance monitoring?",
        "type": "mcq",
        "o": [
            "Tracking navigation timing and performance",
            "Route optimization",
            "Performance testing",
            "Route benchmarking"
        ]
    },
    {
        "q": "Navigation timing can be measured using router events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code measure?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(() => startTime = performance.now()); router.events.pipe(filter(e => e instanceof NavigationEnd)).subscribe(() => console.log(performance.now() - startTime));",
        "o": [
            "Navigation duration in milliseconds",
            "Page load time",
            "Component render time",
            "Route resolution time"
        ]
    },
    {
        "q": "The _____ API provides precise timing measurements.",
        "type": "fill_blank",
        "answers": [
            "performance"
        ],
        "other_options": [
            "timing",
            "measure",
            "clock"
        ]
    },
    {
        "q": "Match performance metrics:",
        "type": "match",
        "left": [
            "Navigation time",
            "Guard time",
            "Resolver time",
            "Render time"
        ],
        "right": [
            "Total navigation duration",
            "Guard execution",
            "Data fetching",
            "Component display"
        ]
    },
    {
        "q": "What is breadcrumb navigation?",
        "type": "mcq",
        "o": [
            "Showing hierarchical path to current route",
            "Navigation history",
            "Route trail",
            "Path display"
        ]
    },
    {
        "q": "Breadcrumbs can be built from activated route hierarchy.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code build?",
        "type": "mcq",
        "c": "let route = this.route.root; while (route.firstChild) { route = route.firstChild; breadcrumbs.push({ label: route.snapshot.data['title'], url: route.snapshot.url }); }",
        "o": [
            "Breadcrumb trail from route hierarchy",
            "Route history",
            "Navigation path",
            "URL list"
        ]
    },
    {
        "q": "The _____ property gets first child route.",
        "type": "fill_blank",
        "answers": [
            "firstChild"
        ],
        "other_options": [
            "child",
            "children",
            "next"
        ]
    },
    {
        "q": "Match breadcrumb properties:",
        "type": "match",
        "left": [
            "label",
            "url",
            "icon",
            "active"
        ],
        "right": [
            "Display text",
            "Navigation path",
            "Visual indicator",
            "Current page flag"
        ]
    },
    {
        "q": "What is deep linking?",
        "type": "mcq",
        "o": [
            "Linking directly to specific application state",
            "Nested routes",
            "External links",
            "Internal navigation"
        ]
    },
    {
        "q": "Angular routes support deep linking by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this route enable?",
        "type": "mcq",
        "c": "{ path: 'products/:category/:id', component: ProductDetailComponent }",
        "o": [
            "Direct linking to specific product in category",
            "Product listing",
            "Category view",
            "Product search"
        ]
    },
    {
        "q": "The _____ parameters enable deep linking to specific content.",
        "type": "fill_blank",
        "answers": [
            "route"
        ],
        "other_options": [
            "query",
            "state",
            "link"
        ]
    },
    {
        "q": "Rearrange deep linking flow:",
        "type": "rearrange",
        "words": [
            "User shares URL",
            "Recipient opens link",
            "Router parses URL",
            "Parameters extracted",
            "Content displayed"
        ]
    },
    {
        "q": "What is route logging?",
        "type": "mcq",
        "o": [
            "Recording navigation events for debugging",
            "Console output",
            "Event tracking",
            "Route tracing"
        ]
    },
    {
        "q": "withDebugTracing enables route logging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "provideRouter(routes, withDebugTracing());",
        "o": [
            "Logs all router events to console",
            "Creates logs",
            "Enables debugging",
            "Traces routes"
        ]
    },
    {
        "q": "The _____ feature enables router event logging.",
        "type": "fill_blank",
        "answers": [
            "withDebugTracing"
        ],
        "other_options": [
            "enableLogging",
            "debugMode",
            "traceRoutes"
        ]
    },
    {
        "q": "Match logging features:",
        "type": "match",
        "left": [
            "withDebugTracing",
            "Custom logger",
            "Router events",
            "Performance marks"
        ],
        "right": [
            "Built-in logging",
            "Application logging",
            "Event subscription",
            "Browser DevTools"
        ]
    },
    {
        "q": "What is navigation timing?",
        "type": "mcq",
        "o": [
            "Measuring time between navigation events",
            "Route scheduling",
            "Event timing",
            "Component timing"
        ]
    },
    {
        "q": "RouteConfigLoadStart marks lazy module load beginning.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this track?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof RouteConfigLoadStart || e instanceof RouteConfigLoadEnd)).subscribe(e => console.log(e));",
        "o": [
            "Lazy module loading timing",
            "Route configuration",
            "Module creation",
            "Config changes"
        ]
    },
    {
        "q": "The _____ event fires when lazy module finishes loading.",
        "type": "fill_blank",
        "answers": [
            "RouteConfigLoadEnd"
        ],
        "other_options": [
            "ModuleLoaded",
            "LazyLoadEnd",
            "ConfigLoaded"
        ]
    },
    {
        "q": "Match timing events:",
        "type": "match",
        "left": [
            "NavigationStart",
            "GuardsCheckStart",
            "ResolveStart",
            "ActivationEnd"
        ],
        "right": [
            "Navigation begins",
            "Guards executing",
            "Resolvers running",
            "Component activated"
        ]
    },
    {
        "q": "What is route documentation?",
        "type": "mcq",
        "o": [
            "Documenting route configuration and behavior",
            "API docs",
            "Code comments",
            "User guides"
        ]
    },
    {
        "q": "Route documentation helps team understanding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this pattern document?",
        "type": "mcq",
        "c": "{ path: 'users/:id', component: UserComponent, data: { title: 'User Details', description: 'Shows user profile and settings', permissions: ['view_users'] } }",
        "o": [
            "Route purpose, title and required permissions",
            "Just title",
            "Just permissions",
            "Just description"
        ]
    },
    {
        "q": "The _____ property stores route metadata for documentation.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "meta",
            "info",
            "doc"
        ]
    },
    {
        "q": "Rearrange documentation approach:",
        "type": "rearrange",
        "words": [
            "Define route configuration",
            "Add data properties",
            "Include description",
            "Specify permissions",
            "Generate documentation"
        ]
    },
    {
        "q": "What is route versioning?",
        "type": "mcq",
        "o": [
            "Managing different API versions via routes",
            "Route updates",
            "Version control",
            "Route history"
        ]
    },
    {
        "q": "Route versioning allows backward compatibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration provide?",
        "type": "mcq",
        "c": "{ path: 'api/v1/users', component: UsersV1Component }, { path: 'api/v2/users', component: UsersV2Component }",
        "o": [
            "Multiple API versions via different routes",
            "Single version",
            "Latest version only",
            "Version redirect"
        ]
    },
    {
        "q": "The _____ approach uses path prefixes for versioning.",
        "type": "fill_blank",
        "answers": [
            "URL-based"
        ],
        "other_options": [
            "header-based",
            "query-based",
            "media-type"
        ]
    },
    {
        "q": "Match versioning strategies:",
        "type": "match",
        "left": [
            "URL path",
            "Query parameter",
            "Header",
            "Content negotiation"
        ],
        "right": [
            "/v1/resource",
            "?version=1",
            "X-API-Version: 1",
            "Accept: application/vnd.api+json"
        ]
    },
    {
        "q": "What is fallback routing?",
        "type": "mcq",
        "o": [
            "Default route when no match found",
            "Error routing",
            "Backup routes",
            "Alternative paths"
        ]
    },
    {
        "q": "Wildcard route provides fallback routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this route provide?",
        "type": "mcq",
        "c": "{ path: '**', component: NotFoundComponent }",
        "o": [
            "Catches all unmatched routes",
            "Matches root",
            "Matches empty",
            "Matches specific path"
        ]
    },
    {
        "q": "The _____ path matches any URL segment.",
        "type": "fill_blank",
        "answers": [
            "**"
        ],
        "other_options": [
            "*",
            "any",
            "all"
        ]
    },
    {
        "q": "Rearrange route matching order:",
        "type": "rearrange",
        "words": [
            "Specific routes checked",
            "Parameterized routes",
            "Empty path routes",
            "Wildcard route last"
        ]
    },
    {
        "q": "What is redirect guard pattern?",
        "type": "mcq",
        "o": [
            "Guard that redirects based on conditions",
            "Guard rejection",
            "Route blocking",
            "Access denial"
        ]
    },
    {
        "q": "Guards can return UrlTree to redirect.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard do?",
        "type": "mcq",
        "c": "const redirectGuard: CanActivateFn = () => inject(AuthService).isLoggedIn() ? true : inject(Router).createUrlTree(['/login']);",
        "o": [
            "Allows if logged in, redirects to login otherwise",
            "Always redirects",
            "Always allows",
            "Blocks access"
        ]
    },
    {
        "q": "The _____ method creates a UrlTree for redirection.",
        "type": "fill_blank",
        "answers": [
            "createUrlTree"
        ],
        "other_options": [
            "navigate",
            "redirect",
            "routeTo"
        ]
    },
    {
        "q": "Match guard responses:",
        "type": "match",
        "left": [
            "true",
            "false",
            "UrlTree",
            "Observable<boolean>"
        ],
        "right": [
            "Allow navigation",
            "Cancel navigation",
            "Redirect",
            "Async decision"
        ]
    },
    {
        "q": "What is conditional child loading?",
        "type": "mcq",
        "o": [
            "Loading children based on conditions",
            "Lazy children",
            "Dynamic children",
            "Nested loading"
        ]
    },
    {
        "q": "CanMatch can conditionally skip children.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "{ path: 'premium', canMatch: [premiumGuard], loadChildren: () => import('./premium/premium.routes') }",
        "o": [
            "Premium routes only for premium users",
            "Always loads premium",
            "Never loads premium",
            "Checks after load"
        ]
    },
    {
        "q": "The _____ guard runs before loading children.",
        "type": "fill_blank",
        "answers": [
            "canMatch"
        ],
        "other_options": [
            "canLoad",
            "canActivate",
            "canChildren"
        ]
    },
    {
        "q": "Rearrange conditional loading:",
        "type": "rearrange",
        "words": [
            "Route matched",
            "CanMatch executed",
            "Check passes",
            "Children loaded",
            "CanActivate runs"
        ]
    },
    {
        "q": "What is route-based theming?",
        "type": "mcq",
        "o": [
            "Different themes for different routes",
            "CSS themes",
            "Style switching",
            "Color schemes"
        ]
    },
    {
        "q": "Route data can specify theme information.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "{ path: 'admin', component: AdminComponent, data: { theme: 'dark' } }",
        "o": [
            "Dark theme for admin routes",
            "Light theme",
            "Default theme",
            "No theme"
        ]
    },
    {
        "q": "The _____ property stores theme configuration.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "theme",
            "style",
            "config"
        ]
    },
    {
        "q": "Match theming approaches:",
        "type": "match",
        "left": [
            "Route data",
            "CSS class",
            "Service",
            "Local storage"
        ],
        "right": [
            "Per-route theme",
            "Theme application",
            "Global state",
            "User preference"
        ]
    },
    {
        "q": "What is navigation debouncing?",
        "type": "mcq",
        "o": [
            "Preventing rapid repeated navigations",
            "Slow navigation",
            "Delayed routing",
            "Throttled events"
        ]
    },
    {
        "q": "Multiple rapid navigations can cause issues.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this prevent?",
        "type": "mcq",
        "c": "if (this.isNavigating) return; this.isNavigating = true; this.router.navigate(['/target']).finally(() => this.isNavigating = false);",
        "o": [
            "Double navigation before first completes",
            "Single navigation",
            "Slow navigation",
            "Navigation error"
        ]
    },
    {
        "q": "The _____ pattern prevents navigation spam.",
        "type": "fill_blank",
        "answers": [
            "debounce"
        ],
        "other_options": [
            "throttle",
            "lock",
            "guard"
        ]
    },
    {
        "q": "Match navigation patterns:",
        "type": "match",
        "left": [
            "Debounce",
            "Throttle",
            "Lock",
            "Queue"
        ],
        "right": [
            "Wait for completion",
            "Rate limit",
            "Prevent concurrent",
            "Sequential processing"
        ]
    },
    {
        "q": "What is route-based SEO?",
        "type": "mcq",
        "o": [
            "Setting meta tags based on routes",
            "Search optimization",
            "URL structure",
            "Site indexing"
        ]
    },
    {
        "q": "Angular provides Title and Meta services for SEO.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this resolver do?",
        "type": "mcq",
        "c": "const seoResolver: ResolveFn<void> = (route) => { inject(Title).setTitle(route.data['title']); inject(Meta).updateTag({ name: 'description', content: route.data['description'] }); };",
        "o": [
            "Sets title and meta description from route data",
            "Gets SEO data",
            "Creates tags",
            "Updates route"
        ]
    },
    {
        "q": "The _____ service sets the document title.",
        "type": "fill_blank",
        "answers": [
            "Title"
        ],
        "other_options": [
            "Meta",
            "Document",
            "Head"
        ]
    },
    {
        "q": "Match SEO services:",
        "type": "match",
        "left": [
            "Title",
            "Meta",
            "TitleStrategy",
            "SSR"
        ],
        "right": [
            "Document title",
            "Meta tags",
            "Title formatting",
            "Pre-rendering"
        ]
    },
    {
        "q": "What is route-based layout switching?",
        "type": "mcq",
        "o": [
            "Different layouts for different routes",
            "Responsive design",
            "View switching",
            "Template changing"
        ]
    },
    {
        "q": "Parent routes can define layouts for children.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "{ path: '', component: MainLayoutComponent, children: [...] }, { path: 'admin', component: AdminLayoutComponent, children: [...] }",
        "o": [
            "Different layouts for main and admin sections",
            "Same layout",
            "No layout",
            "Single component"
        ]
    },
    {
        "q": "The _____ routes define layouts containing router-outlet.",
        "type": "fill_blank",
        "answers": [
            "parent"
        ],
        "other_options": [
            "layout",
            "wrapper",
            "container"
        ]
    },
    {
        "q": "Rearrange layout navigation:",
        "type": "rearrange",
        "words": [
            "Navigate to child route",
            "Match parent route",
            "Render layout component",
            "Render child in outlet"
        ]
    },
    {
        "q": "What is route guards composition?",
        "type": "mcq",
        "o": [
            "Combining multiple guards for complex checks",
            "Guard grouping",
            "Guard merging",
            "Guard stacking"
        ]
    },
    {
        "q": "Multiple guards are evaluated in order.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "{ path: 'admin', canActivate: [authGuard, roleGuard, featureGuard] }",
        "o": [
            "Runs all three guards in sequence",
            "Runs one guard",
            "Runs guards in parallel",
            "Skips guards"
        ]
    },
    {
        "q": "The _____ guard stops execution and navigation is cancelled.",
        "type": "fill_blank",
        "answers": [
            "first failing"
        ],
        "other_options": [
            "last",
            "any",
            "all"
        ]
    },
    {
        "q": "Match guard behaviors:",
        "type": "match",
        "left": [
            "All pass",
            "One fails",
            "Returns UrlTree",
            "Returns Observable"
        ],
        "right": [
            "Navigation proceeds",
            "Navigation cancelled",
            "Redirect occurs",
            "Async evaluation"
        ]
    },
    {
        "q": "What is input binding from routes?",
        "type": "mcq",
        "o": [
            "Binding route params directly to component inputs",
            "Data binding",
            "Property binding",
            "Event binding"
        ]
    },
    {
        "q": "withComponentInputBinding enables automatic binding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "@Input() id!: string; // Route param bound automatically",
        "o": [
            "Route parameter bound to input without explicit subscription",
            "Manual binding",
            "Service injection",
            "Event binding"
        ]
    },
    {
        "q": "The _____ feature binds route data to component inputs.",
        "type": "fill_blank",
        "answers": [
            "withComponentInputBinding"
        ],
        "other_options": [
            "bindRouteInputs",
            "autoBindParams",
            "inputBinding"
        ]
    },
    {
        "q": "Match input binding sources:",
        "type": "match",
        "left": [
            "Route params",
            "Query params",
            "Route data",
            "Resolve data"
        ],
        "right": [
            "Path parameters",
            "URL query string",
            "Static configuration",
            "Dynamic data"
        ]
    },
    {
        "q": "What is router outlet directive references?",
        "type": "mcq",
        "o": [
            "Accessing outlet instance via template reference",
            "Directive outlet",
            "Reference variable",
            "Template binding"
        ]
    },
    {
        "q": "Template reference allows access to outlet methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can this access?",
        "type": "mcq",
        "c": "<router-outlet #outlet=\"outlet\"></router-outlet> {{ outlet.isActivated }}",
        "o": [
            "Whether outlet has activated component",
            "Outlet name",
            "Route data",
            "Component instance"
        ]
    },
    {
        "q": "The _____ property indicates if outlet has component.",
        "type": "fill_blank",
        "answers": [
            "isActivated"
        ],
        "other_options": [
            "active",
            "hasComponent",
            "loaded"
        ]
    },
    {
        "q": "Match outlet reference properties:",
        "type": "match",
        "left": [
            "isActivated",
            "activatedRoute",
            "component",
            "activateEvents"
        ],
        "right": [
            "Has component",
            "Current route",
            "Component instance",
            "Activation emitter"
        ]
    },
    {
        "q": "What is route path normalization?",
        "type": "mcq",
        "o": [
            "Standardizing URL paths",
            "Path cleaning",
            "URL formatting",
            "Path validation"
        ]
    },
    {
        "q": "Router normalizes trailing slashes by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration affect?",
        "type": "mcq",
        "c": "{ path: 'users/', redirectTo: 'users', pathMatch: 'full' }",
        "o": [
            "Redirects trailing slash to clean URL",
            "Adds slash",
            "Removes all slashes",
            "Validates path"
        ]
    },
    {
        "q": "The _____ property ensures exact path match for redirects.",
        "type": "fill_blank",
        "answers": [
            "pathMatch"
        ],
        "other_options": [
            "exact",
            "strict",
            "full"
        ]
    },
    {
        "q": "Match path matching:",
        "type": "match",
        "left": [
            "prefix",
            "full"
        ],
        "right": [
            "Matches beginning",
            "Matches entire path"
        ]
    },
    {
        "q": "What is router outlet naming convention?",
        "type": "mcq",
        "o": [
            "Standard names for auxiliary outlets",
            "Outlet IDs",
            "Naming rules",
            "Identifier pattern"
        ]
    },
    {
        "q": "Named outlets enable multiple content areas.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this create?",
        "type": "mcq",
        "c": "<router-outlet></router-outlet> <router-outlet name=\"sidebar\"></router-outlet> <router-outlet name=\"modal\"></router-outlet>",
        "o": [
            "Primary and two named outlets",
            "Three primary outlets",
            "One outlet",
            "Nested outlets"
        ]
    },
    {
        "q": "The _____ outlet is used when no name specified.",
        "type": "fill_blank",
        "answers": [
            "primary"
        ],
        "other_options": [
            "default",
            "main",
            "root"
        ]
    },
    {
        "q": "Match outlet types:",
        "type": "match",
        "left": [
            "Primary",
            "Named",
            "Nested",
            "Modal"
        ],
        "right": [
            "Main content",
            "Auxiliary content",
            "Child routes",
            "Overlay content"
        ]
    },
    {
        "q": "What is route security?",
        "type": "mcq",
        "o": [
            "Protecting routes from unauthorized access",
            "URL encryption",
            "Data security",
            "Network security"
        ]
    },
    {
        "q": "Guards are the primary mechanism for route security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this pattern implement?",
        "type": "mcq",
        "c": "canActivate: [() => inject(AuthService).isAuthenticated() && inject(AuthService).hasPermission('admin')]",
        "o": [
            "Authentication AND authorization check",
            "Only authentication",
            "Only authorization",
            "No security"
        ]
    },
    {
        "q": "The _____ pattern combines multiple security checks.",
        "type": "fill_blank",
        "answers": [
            "composition"
        ],
        "other_options": [
            "chaining",
            "nesting",
            "stacking"
        ]
    },
    {
        "q": "Match security concepts:",
        "type": "match",
        "left": [
            "Authentication",
            "Authorization",
            "Role-based",
            "Permission-based"
        ],
        "right": [
            "Identity verification",
            "Access control",
            "User roles",
            "Specific actions"
        ]
    },
    {
        "q": "What is route testing with spies?",
        "type": "mcq",
        "o": [
            "Using spy objects to mock router behavior",
            "Spy testing",
            "Route inspection",
            "Navigation tracking"
        ]
    },
    {
        "q": "Router can be mocked with jasmine spies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test mock do?",
        "type": "mcq",
        "c": "const routerSpy = jasmine.createSpyObj('Router', ['navigate']); routerSpy.navigate.and.returnValue(Promise.resolve(true));",
        "o": [
            "Creates mock router that successfully navigates",
            "Creates real router",
            "Tracks navigation",
            "Validates routes"
        ]
    },
    {
        "q": "The _____ function creates spy objects.",
        "type": "fill_blank",
        "answers": [
            "createSpyObj"
        ],
        "other_options": [
            "spy",
            "mock",
            "stub"
        ]
    },
    {
        "q": "Match testing patterns:",
        "type": "match",
        "left": [
            "Spy",
            "Stub",
            "Mock",
            "Fake"
        ],
        "right": [
            "Track calls",
            "Return values",
            "Verify behavior",
            "Simple implementation"
        ]
    },
    {
        "q": "What is route accessibility?",
        "type": "mcq",
        "o": [
            "Making navigation accessible to all users",
            "Route availability",
            "Access control",
            "Route visibility"
        ]
    },
    {
        "q": "Focus management is important for accessibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this improve?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationEnd)).subscribe(() => document.querySelector('main')?.focus());",
        "o": [
            "Sets focus to main content after navigation",
            "Focuses router",
            "Tracks events",
            "Updates DOM"
        ]
    },
    {
        "q": "The _____ method moves keyboard focus to element.",
        "type": "fill_blank",
        "answers": [
            "focus"
        ],
        "other_options": [
            "select",
            "activate",
            "highlight"
        ]
    },
    {
        "q": "Match accessibility features:",
        "type": "match",
        "left": [
            "Focus management",
            "Skip links",
            "Announcements",
            "Keyboard navigation"
        ],
        "right": [
            "After route change",
            "Jump to content",
            "Screen reader updates",
            "Tab navigation"
        ]
    },
    {
        "q": "What is live region announcements?",
        "type": "mcq",
        "o": [
            "Announcing route changes to screen readers",
            "Live updates",
            "Real-time data",
            "Dynamic content"
        ]
    },
    {
        "q": "ARIA live regions announce dynamic content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this announce?",
        "type": "mcq",
        "c": "router.events.pipe(filter(e => e instanceof NavigationEnd)).subscribe(() => liveAnnouncer.announce('Page loaded: ' + router.url));",
        "o": [
            "Page navigation to screen readers",
            "All events",
            "Errors only",
            "Route data"
        ]
    },
    {
        "q": "The _____ service announces content to screen readers.",
        "type": "fill_blank",
        "answers": [
            "LiveAnnouncer"
        ],
        "other_options": [
            "Announcer",
            "AriaService",
            "ScreenReader"
        ]
    },
    {
        "q": "Rearrange accessible navigation:",
        "type": "rearrange",
        "words": [
            "Navigation triggered",
            "Route changes",
            "Announce page load",
            "Move focus to content",
            "User continues"
        ]
    },
    {
        "q": "What is routing best practice for error handling?",
        "type": "mcq",
        "o": [
            "Graceful fallbacks and error routes",
            "Ignore errors",
            "Log only",
            "Alert user"
        ]
    },
    {
        "q": "Every application should have an error route.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What pattern does this implement?",
        "type": "mcq",
        "c": "{ path: 'error', component: ErrorComponent }, { path: '**', redirectTo: '/error' }",
        "o": [
            "Error page for all unmatched routes",
            "Only specific errors",
            "No error handling",
            "Error logging"
        ]
    },
    {
        "q": "The _____ route catches unmatched URLs.",
        "type": "fill_blank",
        "answers": [
            "wildcard"
        ],
        "other_options": [
            "error",
            "default",
            "fallback"
        ]
    },
    {
        "q": "Match error handling patterns:",
        "type": "match",
        "left": [
            "Wildcard route",
            "Error component",
            "Error service",
            "Error boundary"
        ],
        "right": [
            "Catch unmatched",
            "Display error",
            "Handle and log",
            "Contain failures"
        ]
    },
    {
        "q": "What is lazy loading best practice?",
        "type": "mcq",
        "o": [
            "Load feature modules on demand",
            "Load everything eagerly",
            "Preload all modules",
            "Avoid lazy loading"
        ]
    },
    {
        "q": "Lazy loading improves initial load time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is recommended for large features?",
        "type": "mcq",
        "c": "{ path: 'admin', loadChildren: () => import('./admin/admin.routes').then(m => m.routes) }",
        "o": [
            "Lazy load to reduce initial bundle",
            "Eager load",
            "Preload always",
            "No lazy loading"
        ]
    },
    {
        "q": "The _____ strategy improves perceived performance.",
        "type": "fill_blank",
        "answers": [
            "preloading"
        ],
        "other_options": [
            "eager",
            "lazy",
            "defer"
        ]
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "Eager",
            "Lazy",
            "Preload all",
            "Custom preload"
        ],
        "right": [
            "Load immediately",
            "Load on demand",
            "Load in background",
            "Selective background load"
        ]
    },
    {
        "q": "What is route organization best practice?",
        "type": "mcq",
        "o": [
            "Group related routes in feature files",
            "All routes in app",
            "Random organization",
            "No organization"
        ]
    },
    {
        "q": "Feature-based route organization improves maintainability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What structure does this follow?",
        "type": "mcq",
        "c": "// users/users.routes.ts export const usersRoutes: Routes = [{ path: '', component: UsersComponent, children: [...] }];",
        "o": [
            "Feature-based route file organization",
            "Single file",
            "No organization",
            "Random structure"
        ]
    },
    {
        "q": "The _____ pattern groups routes by feature.",
        "type": "fill_blank",
        "answers": [
            "feature module"
        ],
        "other_options": [
            "core module",
            "shared module",
            "app module"
        ]
    },
    {
        "q": "Rearrange route file structure:",
        "type": "rearrange",
        "words": [
            "App routes",
            "Feature routes",
            "Shared routes",
            "Lazy loaded routes"
        ]
    },
    {
        "q": "What is guard reusability best practice?",
        "type": "mcq",
        "o": [
            "Create generic configurable guards",
            "Duplicate guards",
            "One guard per route",
            "No guards"
        ]
    },
    {
        "q": "Parameterized guards improve reusability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this factory function enable?",
        "type": "mcq",
        "c": "export const roleGuard = (requiredRole: string): CanActivateFn => () => inject(AuthService).hasRole(requiredRole);",
        "o": [
            "Reusable guard with different role requirements",
            "Single role guard",
            "No reusability",
            "Static guard"
        ]
    },
    {
        "q": "The _____ pattern creates configurable guards.",
        "type": "fill_blank",
        "answers": [
            "factory"
        ],
        "other_options": [
            "builder",
            "singleton",
            "provider"
        ]
    },
    {
        "q": "Match guard patterns:",
        "type": "match",
        "left": [
            "Factory guard",
            "Composite guard",
            "Async guard",
            "Redirect guard"
        ],
        "right": [
            "Configurable creation",
            "Multiple checks",
            "Observable/Promise",
            "UrlTree return"
        ]
    },
    {
        "q": "What is resolver best practice?",
        "type": "mcq",
        "o": [
            "Keep resolvers focused and fast",
            "Load all data",
            "Complex operations",
            "No resolvers"
        ]
    },
    {
        "q": "Resolvers should complete quickly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the issue with this resolver?",
        "type": "mcq",
        "c": "resolve() { return forkJoin([api.getUsers(), api.getProducts(), api.getOrders(), api.getStats()]); }",
        "o": [
            "Too many parallel requests delay navigation",
            "Perfect resolver",
            "Fast resolver",
            "No issues"
        ]
    },
    {
        "q": "The _____ approach loads data after component renders.",
        "type": "fill_blank",
        "answers": [
            "component-based"
        ],
        "other_options": [
            "resolver-based",
            "guard-based",
            "service-based"
        ]
    },
    {
        "q": "Match data loading patterns:",
        "type": "match",
        "left": [
            "Resolver",
            "Component ngOnInit",
            "Service injection",
            "Signal effect"
        ],
        "right": [
            "Before render",
            "After render",
            "On demand",
            "Reactive"
        ]
    },
    {
        "q": "What is navigation timing best practice?",
        "type": "mcq",
        "o": [
            "Measure and optimize slow navigations",
            "Ignore timing",
            "Always fast",
            "No measurement"
        ]
    },
    {
        "q": "Navigation should feel instant to users.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should trigger investigation?",
        "type": "mcq",
        "c": "if (navigationTime > 300) console.warn('Slow navigation detected');",
        "o": [
            "Navigations taking more than 300ms",
            "All navigations",
            "No navigations",
            "Only errors"
        ]
    },
    {
        "q": "The _____ threshold is typically acceptable for navigation.",
        "type": "fill_blank",
        "answers": [
            "100-300ms"
        ],
        "other_options": [
            "1-10ms",
            "1-5s",
            "10-30s"
        ]
    },
    {
        "q": "Match performance targets:",
        "type": "match",
        "left": [
            "Instant",
            "Fast",
            "Acceptable",
            "Slow"
        ],
        "right": [
            "< 100ms",
            "100-300ms",
            "300-1000ms",
            "> 1000ms"
        ]
    },
    {
        "q": "What is URL structure best practice?",
        "type": "mcq",
        "o": [
            "Clean, readable, RESTful URLs",
            "Random URLs",
            "Encoded URLs",
            "No structure"
        ]
    },
    {
        "q": "RESTful URL patterns improve usability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which URL structure is preferred?",
        "type": "mcq",
        "c": "Option A: /users/123/orders/456 vs Option B: /page?userId=123&orderId=456",
        "o": [
            "Option A - path-based parameters",
            "Option B - query parameters",
            "Both equal",
            "Neither"
        ]
    },
    {
        "q": "The _____ pattern uses nouns for resources.",
        "type": "fill_blank",
        "answers": [
            "RESTful"
        ],
        "other_options": [
            "RPC",
            "GraphQL",
            "SOAP"
        ]
    },
    {
        "q": "Match URL patterns:",
        "type": "match",
        "left": [
            "/users/:id",
            "/users/:id/edit",
            "/search?q=term",
            "/dashboard#section"
        ],
        "right": [
            "Resource path",
            "Action path",
            "Query parameter",
            "Fragment"
        ]
    },
    {
        "q": "What is state management with routing?",
        "type": "mcq",
        "o": [
            "Syncing application state with route",
            "Global state",
            "Local state",
            "Session state"
        ]
    },
    {
        "q": "Route parameters can represent application state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What state does this URL represent?",
        "type": "mcq",
        "c": "/products?category=electronics&sort=price&page=2",
        "o": [
            "Filter, sort, and pagination state",
            "Product details",
            "User preferences",
            "Session data"
        ]
    },
    {
        "q": "The _____ parameters store shareable state.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "route",
            "state",
            "session"
        ]
    },
    {
        "q": "Match state locations:",
        "type": "match",
        "left": [
            "Route params",
            "Query params",
            "Navigation state",
            "Service state"
        ],
        "right": [
            "Resource identity",
            "Shareable filters",
            "Hidden complex data",
            "Application state"
        ]
    },
    {
        "q": "What is route configuration validation?",
        "type": "mcq",
        "o": [
            "Verifying route config correctness",
            "Route testing",
            "URL validation",
            "Path checking"
        ]
    },
    {
        "q": "Invalid routes cause runtime errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this validate?",
        "type": "mcq",
        "c": "routes.forEach(r => { if (r.loadChildren && r.component) throw new Error('Cannot use both'); });",
        "o": [
            "Route config consistency",
            "URL format",
            "Component existence",
            "Guard validity"
        ]
    },
    {
        "q": "The _____ pattern validates routes at startup.",
        "type": "fill_blank",
        "answers": [
            "APP_INITIALIZER"
        ],
        "other_options": [
            "ngOnInit",
            "constructor",
            "ngAfterViewInit"
        ]
    },
    {
        "q": "Match validation targets:",
        "type": "match",
        "left": [
            "Path format",
            "Guard presence",
            "Component existence",
            "Lazy import"
        ],
        "right": [
            "No leading slash",
            "Security check",
            "Valid reference",
            "Module exists"
        ]
    },
    {
        "q": "What is route module organization?",
        "type": "mcq",
        "o": [
            "Separating routing into dedicated modules",
            "Single module",
            "No modules",
            "Random organization"
        ]
    },
    {
        "q": "Routing modules improve code organization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of this file?",
        "type": "mcq",
        "c": "// app.routes.ts export const appRoutes: Routes = [...];",
        "o": [
            "Dedicated route configuration file",
            "Component file",
            "Service file",
            "Model file"
        ]
    },
    {
        "q": "The _____ pattern separates routes from components.",
        "type": "fill_blank",
        "answers": [
            "route file"
        ],
        "other_options": [
            "inline",
            "embedded",
            "coupled"
        ]
    },
    {
        "q": "Match file organization:",
        "type": "match",
        "left": [
            "app.routes.ts",
            "feature.routes.ts",
            "app.config.ts",
            "main.ts"
        ],
        "right": [
            "Root routes",
            "Feature routes",
            "Provider config",
            "Bootstrap"
        ]
    },
    {
        "q": "What is route testing coverage?",
        "type": "mcq",
        "o": [
            "Testing all route scenarios",
            "Code coverage",
            "Unit testing",
            "Integration testing"
        ]
    },
    {
        "q": "Route tests should cover guards and resolvers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What scenarios should be tested?",
        "type": "mcq",
        "c": "// Test: authorized access, unauthorized redirect, lazy loading, error handling",
        "o": [
            "All listed scenarios",
            "Only authorized",
            "Only errors",
            "Only lazy loading"
        ]
    },
    {
        "q": "The _____ testing approach verifies full navigation.",
        "type": "fill_blank",
        "answers": [
            "e2e"
        ],
        "other_options": [
            "unit",
            "integration",
            "snapshot"
        ]
    },
    {
        "q": "Match testing types:",
        "type": "match",
        "left": [
            "Unit test",
            "Integration test",
            "E2E test",
            "Smoke test"
        ],
        "right": [
            "Guard logic",
            "Router + guards",
            "Full navigation",
            "Basic routes work"
        ]
    },
    {
        "q": "What is route debugging technique?",
        "type": "mcq",
        "o": [
            "Tracing route matching and guard execution",
            "Console logging",
            "Breakpoints",
            "Network inspection"
        ]
    },
    {
        "q": "Router events help debug navigation issues.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What helps debug this issue?",
        "type": "mcq",
        "c": "// Navigation starts but never completes",
        "o": [
            "Check for blocking guard or resolver",
            "Check URL",
            "Check component",
            "Check template"
        ]
    },
    {
        "q": "The _____ event indicates navigation cancellation reason.",
        "type": "fill_blank",
        "answers": [
            "NavigationCancel"
        ],
        "other_options": [
            "NavigationError",
            "NavigationEnd",
            "NavigationSkipped"
        ]
    },
    {
        "q": "Match debugging tools:",
        "type": "match",
        "left": [
            "withDebugTracing",
            "Router events",
            "Augury",
            "DevTools"
        ],
        "right": [
            "Console logging",
            "Event subscription",
            "Visual debugging",
            "Network/DOM"
        ]
    },
    {
        "q": "What is migration to standalone routing?",
        "type": "mcq",
        "o": [
            "Moving from NgModule to standalone routing",
            "Route updates",
            "Version upgrade",
            "Code refactoring"
        ]
    },
    {
        "q": "Standalone routing uses provideRouter.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the standalone equivalent?",
        "type": "mcq",
        "c": "// Before: RouterModule.forRoot(routes)",
        "o": [
            "provideRouter(routes)",
            "RouterModule.forRoot(routes)",
            "importRoutes(routes)",
            "routerProvider(routes)"
        ]
    },
    {
        "q": "The _____ function replaces RouterModule.forRoot.",
        "type": "fill_blank",
        "answers": [
            "provideRouter"
        ],
        "other_options": [
            "routerModule",
            "createRouter",
            "setupRouter"
        ]
    },
    {
        "q": "Rearrange migration steps:",
        "type": "rearrange",
        "words": [
            "Remove RouterModule imports",
            "Add provideRouter to config",
            "Update route definitions",
            "Update lazy loading syntax",
            "Test navigation"
        ]
    },
    {
        "q": "What is signals integration with routing?",
        "type": "mcq",
        "o": [
            "Using Angular signals with route data",
            "Signal service",
            "Route signals",
            "Event signals"
        ]
    },
    {
        "q": "ActivatedRoute provides signal-based APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code use?",
        "type": "mcq",
        "c": "const id = toSignal(this.route.paramMap.pipe(map(p => p.get('id'))));",
        "o": [
            "Converts route params to signal",
            "Creates route",
            "Gets params",
            "Maps data"
        ]
    },
    {
        "q": "The _____ function converts observables to signals.",
        "type": "fill_blank",
        "answers": [
            "toSignal"
        ],
        "other_options": [
            "asSignal",
            "signal",
            "createSignal"
        ]
    },
    {
        "q": "Match signal concepts:",
        "type": "match",
        "left": [
            "signal",
            "computed",
            "effect",
            "toSignal"
        ],
        "right": [
            "Reactive value",
            "Derived value",
            "Side effect",
            "Observable to signal"
        ]
    },
    {
        "q": "What is view transitions API with routing?",
        "type": "mcq",
        "o": [
            "Native browser animations for route changes",
            "Component transitions",
            "View updates",
            "Animation API"
        ]
    },
    {
        "q": "View Transitions API provides smooth page transitions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this enable?",
        "type": "mcq",
        "c": "withViewTransitions()",
        "o": [
            "Native browser view transitions",
            "Component animations",
            "Route animations",
            "CSS transitions"
        ]
    },
    {
        "q": "The _____ feature enables native browser transitions.",
        "type": "fill_blank",
        "answers": [
            "withViewTransitions"
        ],
        "other_options": [
            "viewTransitions",
            "enableTransitions",
            "pageTransitions"
        ]
    },
    {
        "q": "Rearrange view transition flow:",
        "type": "rearrange",
        "words": [
            "Navigation triggered",
            "Capture old view",
            "Update DOM",
            "Capture new view",
            "Animate between"
        ]
    },
    {
        "q": "What is router outlet data binding?",
        "type": "mcq",
        "o": [
            "Passing data directly to outlet components",
            "Outlet binding",
            "Data transfer",
            "Component binding"
        ]
    },
    {
        "q": "Router outlet can pass component inputs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration enable?",
        "type": "mcq",
        "c": "withComponentInputBinding()",
        "o": [
            "Route data bound to component inputs",
            "Event binding",
            "Property binding",
            "Template binding"
        ]
    },
    {
        "q": "The _____ feature auto-binds route params to inputs.",
        "type": "fill_blank",
        "answers": [
            "withComponentInputBinding"
        ],
        "other_options": [
            "bindInputs",
            "autoBindRoute",
            "inputBinding"
        ]
    },
    {
        "q": "Match binding sources:",
        "type": "match",
        "left": [
            "Path params",
            "Query params",
            "Data",
            "Resolved data"
        ],
        "right": [
            ":id in path",
            "?key=value",
            "Static route data",
            "Resolver output"
        ]
    },
    {
        "q": "What is hash location strategy?",
        "type": "mcq",
        "o": [
            "Using # in URLs for routing",
            "Hash function",
            "URL hashing",
            "Path encoding"
        ]
    },
    {
        "q": "HashLocationStrategy uses # before path.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What URLs does this create?",
        "type": "mcq",
        "c": "provideRouter(routes, withHashLocation())",
        "o": [
            "http://app.com/#/users pattern",
            "http://app.com/users pattern",
            "http://app.com?users pattern",
            "http://app.com/#!/users pattern"
        ]
    },
    {
        "q": "The _____ strategy is useful for servers without rewrite.",
        "type": "fill_blank",
        "answers": [
            "hash"
        ],
        "other_options": [
            "path",
            "query",
            "fragment"
        ]
    },
    {
        "q": "Match location strategies:",
        "type": "match",
        "left": [
            "PathLocationStrategy",
            "HashLocationStrategy"
        ],
        "right": [
            "Clean URLs, needs server config",
            "Hash URLs, works everywhere"
        ]
    },
    {
        "q": "What is router navigation extras?",
        "type": "mcq",
        "o": [
            "Additional options for navigation",
            "Extra routes",
            "Additional paths",
            "Navigation data"
        ]
    },
    {
        "q": "NavigationExtras controls navigation behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this configuration do?",
        "type": "mcq",
        "c": "router.navigate(['/home'], { queryParams: { ref: 'header' }, fragment: 'top', replaceUrl: true })",
        "o": [
            "Navigates with query, fragment, replacing history",
            "Simple navigation",
            "Redirect only",
            "Query only"
        ]
    },
    {
        "q": "The _____ option replaces current history entry.",
        "type": "fill_blank",
        "answers": [
            "replaceUrl"
        ],
        "other_options": [
            "replace",
            "noHistory",
            "skipHistory"
        ]
    },
    {
        "q": "Match navigation extras:",
        "type": "match",
        "left": [
            "queryParams",
            "fragment",
            "state",
            "skipLocationChange"
        ],
        "right": [
            "URL query string",
            "URL hash",
            "Hidden data",
            "No URL update"
        ]
    },
    {
        "q": "What is router info property?",
        "type": "mcq",
        "o": [
            "Information passed with navigation",
            "Router data",
            "Route info",
            "Navigation details"
        ]
    },
    {
        "q": "info property transfers data without URL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the difference from state?",
        "type": "mcq",
        "c": "router.navigate(['/page'], { info: { source: 'button' } })",
        "o": [
            "info is not persisted in history, state is",
            "Same behavior",
            "info is persisted, state is not",
            "No difference"
        ]
    },
    {
        "q": "The _____ property passes ephemeral navigation data.",
        "type": "fill_blank",
        "answers": [
            "info"
        ],
        "other_options": [
            "data",
            "meta",
            "context"
        ]
    },
    {
        "q": "Match data transfer options:",
        "type": "match",
        "left": [
            "queryParams",
            "state",
            "info",
            "data"
        ],
        "right": [
            "In URL, visible",
            "In history, hidden",
            "Ephemeral, not persisted",
            "Static config"
        ]
    },
    {
        "q": "What is router outlet attach/detach?",
        "type": "mcq",
        "o": [
            "Lifecycle hooks for outlet components",
            "Component loading",
            "Outlet events",
            "Route changes"
        ]
    },
    {
        "q": "attach and detach events are emitted by router outlet.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What do these events track?",
        "type": "mcq",
        "c": "<router-outlet (attach)=\"onAttach($event)\" (detach)=\"onDetach($event)\"></router-outlet>",
        "o": [
            "Component reattachment from cache",
            "Initial loading",
            "Component destruction",
            "Route changes"
        ]
    },
    {
        "q": "The _____ event fires when cached component reattaches.",
        "type": "fill_blank",
        "answers": [
            "attach"
        ],
        "other_options": [
            "reattach",
            "restore",
            "activate"
        ]
    },
    {
        "q": "Match outlet events:",
        "type": "match",
        "left": [
            "activate",
            "deactivate",
            "attach",
            "detach"
        ],
        "right": [
            "New component created",
            "Component destroyed",
            "Cached component restored",
            "Component cached"
        ]
    },
    {
        "q": "What is CanDeactivate use case?",
        "type": "mcq",
        "o": [
            "Preventing navigation when changes unsaved",
            "Route blocking",
            "Access control",
            "Navigation logging"
        ]
    },
    {
        "q": "CanDeactivate can show confirmation dialog.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this guard do?",
        "type": "mcq",
        "c": "const unsavedGuard: CanDeactivateFn<FormComponent> = (component) => component.hasUnsavedChanges() ? confirm('Discard changes?') : true;",
        "o": [
            "Asks confirmation if form has changes",
            "Always blocks",
            "Always allows",
            "Logs changes"
        ]
    },
    {
        "q": "The _____ guard protects against accidental data loss.",
        "type": "fill_blank",
        "answers": [
            "CanDeactivate"
        ],
        "other_options": [
            "LeaveGuard",
            "ExitGuard",
            "SaveGuard"
        ]
    },
    {
        "q": "Match guard scenarios:",
        "type": "match",
        "left": [
            "CanActivate",
            "CanDeactivate",
            "CanMatch",
            "Resolve"
        ],
        "right": [
            "Check before enter",
            "Check before leave",
            "Check before match",
            "Load before enter"
        ]
    },
    {
        "q": "What is multiple route configuration?",
        "type": "mcq",
        "o": [
            "Different routes for same path with guards",
            "Route duplication",
            "Path aliases",
            "Route variants"
        ]
    },
    {
        "q": "First matching route wins when multiple exist.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What enables this pattern?",
        "type": "mcq",
        "c": "{ path: 'dashboard', canMatch: [adminGuard], component: AdminDashboard }, { path: 'dashboard', component: UserDashboard }",
        "o": [
            "Different components for different users",
            "Same component always",
            "Route error",
            "First route always"
        ]
    },
    {
        "q": "The _____ guard enables route variants.",
        "type": "fill_blank",
        "answers": [
            "canMatch"
        ],
        "other_options": [
            "canActivate",
            "variant",
            "switch"
        ]
    },
    {
        "q": "Rearrange route selection:",
        "type": "rearrange",
        "words": [
            "URL matched to path",
            "First route canMatch checked",
            "If true, use first",
            "If false, check next",
            "Repeat until match"
        ]
    },
    {
        "q": "What is route testing harness?",
        "type": "mcq",
        "o": [
            "Testing utility for modern router tests",
            "Test fixture",
            "Route spy",
            "Navigation mock"
        ]
    },
    {
        "q": "RouterTestingHarness simplifies route testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test achieve?",
        "type": "mcq",
        "c": "const harness = await RouterTestingHarness.create(); const comp = await harness.navigateByUrl('/users/1', UserComponent); expect(comp.userId).toBe('1');",
        "o": [
            "Navigates and verifies component state",
            "Creates component",
            "Mocks navigation",
            "Tests route config"
        ]
    },
    {
        "q": "The _____ class is the modern approach to route testing.",
        "type": "fill_blank",
        "answers": [
            "RouterTestingHarness"
        ],
        "other_options": [
            "RouterTestingModule",
            "TestRouter",
            "RouteTestBed"
        ]
    },
    {
        "q": "Match testing approaches:",
        "type": "match",
        "left": [
            "RouterTestingHarness",
            "RouterTestingModule",
            "Spy router",
            "Real router"
        ],
        "right": [
            "Modern standalone",
            "NgModule based",
            "Mock navigation",
            "E2E testing"
        ]
    },
    {
        "q": "What is URL serializer?",
        "type": "mcq",
        "o": [
            "Converts UrlTree to/from URL string",
            "URL validator",
            "URL formatter",
            "URL parser"
        ]
    },
    {
        "q": "Custom UrlSerializer enables custom URL formats.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What can this customize?",
        "type": "mcq",
        "c": "class CustomSerializer extends DefaultUrlSerializer { parse(url) { return super.parse(url.replace('+', '%2B')); } }",
        "o": [
            "URL parsing and encoding",
            "URL validation",
            "Route matching",
            "Path format"
        ]
    },
    {
        "q": "The _____ class provides default URL handling.",
        "type": "fill_blank",
        "answers": [
            "DefaultUrlSerializer"
        ],
        "other_options": [
            "UrlSerializer",
            "UrlParser",
            "UrlHandler"
        ]
    },
    {
        "q": "Match serializer methods:",
        "type": "match",
        "left": [
            "parse",
            "serialize"
        ],
        "right": [
            "String to UrlTree",
            "UrlTree to string"
        ]
    },
    {
        "q": "What is the complete routing configuration?",
        "type": "mcq",
        "o": [
            "All routing features combined in provideRouter",
            "Basic routes",
            "Single feature",
            "Default config"
        ]
    },
    {
        "q": "Multiple with* functions can be combined.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this provide?",
        "type": "mcq",
        "c": "provideRouter(routes, withPreloading(PreloadAllModules), withComponentInputBinding(), withInMemoryScrolling({scrollPositionRestoration: 'enabled'}), withViewTransitions())",
        "o": [
            "Full-featured router configuration",
            "Basic routing",
            "Single feature",
            "Default settings"
        ]
    },
    {
        "q": "The _____ pattern combines multiple router features.",
        "type": "fill_blank",
        "answers": [
            "feature composition"
        ],
        "other_options": [
            "configuration",
            "setup",
            "initialization"
        ]
    },
    {
        "q": "Match router features:",
        "type": "match",
        "left": [
            "withPreloading",
            "withComponentInputBinding",
            "withInMemoryScrolling",
            "withViewTransitions"
        ],
        "right": [
            "Background loading",
            "Auto input binding",
            "Scroll management",
            "Smooth transitions"
        ]
    }
]