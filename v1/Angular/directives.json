[
    {
        "q": "What is a directive in Angular?",
        "type": "mcq",
        "o": [
            "A class that adds behavior to DOM elements",
            "A component type",
            "A service",
            "A module"
        ]
    },
    {
        "q": "Directives are used to manipulate the DOM.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What are the three types of directives in Angular?",
        "type": "mcq",
        "o": [
            "Component, Structural, and Attribute directives",
            "Simple, Complex, and Advanced directives",
            "Input, Output, and Both directives",
            "Static, Dynamic, and Hybrid directives"
        ]
    },
    {
        "q": "The _____ decorator creates a directive.",
        "type": "fill_blank",
        "answers": [
            "@Directive"
        ],
        "other_options": [
            "@Component",
            "@Injectable",
            "@Pipe"
        ]
    },
    {
        "q": "Components are directives with a template.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a structural directive?",
        "type": "mcq",
        "o": [
            "A directive that changes the DOM structure by adding/removing elements",
            "A directive that builds structures",
            "A directive that organizes code",
            "A directive that creates classes"
        ]
    },
    {
        "q": "Structural directives are prefixed with an asterisk (*).",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is *ngIf used for?",
        "type": "mcq",
        "o": [
            "Conditionally adding or removing elements from the DOM",
            "Creating loops",
            "Switching styles",
            "Binding events"
        ]
    },
    {
        "q": "Match the structural directives:",
        "type": "match",
        "left": [
            "*ngIf",
            "*ngFor",
            "*ngSwitch",
            "ng-template"
        ],
        "right": [
            "Conditional",
            "Loop",
            "Multiple conditions",
            "Template holder"
        ]
    },
    {
        "q": "What does *ngFor do?",
        "type": "mcq",
        "o": [
            "Repeats a template for each item in a collection",
            "Creates conditions",
            "Switches values",
            "Binds properties"
        ]
    },
    {
        "q": "*ngFor creates multiple elements based on an array.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code do?",
        "type": "mcq",
        "c": "<li *ngFor=\"let item of items\">{{ item }}</li>",
        "o": [
            "Creates an li element for each item in the items array",
            "Creates one li element",
            "Shows items conditionally",
            "Binds to items property"
        ]
    },
    {
        "q": "The _____ directive loops through arrays.",
        "type": "fill_blank",
        "answers": [
            "*ngFor"
        ],
        "other_options": [
            "*ngIf",
            "*ngSwitch",
            "ngFor"
        ]
    },
    {
        "q": "What is the let keyword in *ngFor?",
        "type": "mcq",
        "o": [
            "Declares a template input variable for each iteration",
            "Creates a constant",
            "Defines a function",
            "Makes a variable global"
        ]
    },
    {
        "q": "*ngFor provides the index variable automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you access the index in *ngFor?",
        "type": "mcq",
        "c": "*ngFor=\"let item of items; let i = index\"",
        "o": [
            "Using let i = index",
            "Using index directly",
            "Using item.index",
            "Using getIndex()"
        ]
    },
    {
        "q": "Match the *ngFor local variables:",
        "type": "match",
        "left": [
            "index",
            "first",
            "last",
            "even"
        ],
        "right": [
            "Position number",
            "Is first item",
            "Is last item",
            "Is even index"
        ]
    },
    {
        "q": "What does the odd variable in *ngFor indicate?",
        "type": "mcq",
        "o": [
            "Whether the current index is odd",
            "Odd items",
            "Remaining items",
            "Item count"
        ]
    },
    {
        "q": "The count variable returns the total number of items in *ngFor.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is trackBy in *ngFor?",
        "type": "mcq",
        "o": [
            "A function that helps Angular track changes efficiently",
            "A tracking library",
            "A debugging tool",
            "An index tracker"
        ]
    },
    {
        "q": "trackBy improves performance by reducing DOM manipulation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should trackBy return?",
        "type": "mcq",
        "o": [
            "A unique identifier for each item",
            "The item itself",
            "The index only",
            "True or false"
        ]
    },
    {
        "q": "The _____ function optimizes *ngFor performance.",
        "type": "fill_blank",
        "answers": [
            "trackBy"
        ],
        "other_options": [
            "track",
            "optimize",
            "identify"
        ]
    },
    {
        "q": "What is *ngIf; else syntax?",
        "type": "mcq",
        "c": "<div *ngIf=\"condition; else elseBlock\">Content</div>",
        "o": [
            "Shows alternate content when condition is false",
            "Creates two conditions",
            "Shows content twice",
            "Validates conditions"
        ]
    },
    {
        "q": "*ngIf completely removes elements from the DOM when false.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the then clause in *ngIf?",
        "type": "mcq",
        "o": [
            "Specifies a template to show when condition is true",
            "A callback function",
            "A promise handler",
            "An error handler"
        ]
    },
    {
        "q": "Match the *ngIf features:",
        "type": "match",
        "left": [
            "*ngIf",
            "else",
            "then",
            "as"
        ],
        "right": [
            "Condition check",
            "False template",
            "True template",
            "Store value"
        ]
    },
    {
        "q": "What does *ngIf with as clause do?",
        "type": "mcq",
        "c": "<div *ngIf=\"user$ | async as user\">{{ user.name }}</div>",
        "o": [
            "Stores the result in a local variable",
            "Creates an alias",
            "Adds a class",
            "Logs the value"
        ]
    },
    {
        "q": "What is [ngSwitch]?",
        "type": "mcq",
        "o": [
            "A directive that switches between templates based on expression",
            "A JavaScript switch",
            "A toggle switch",
            "A router switch"
        ]
    },
    {
        "q": "ngSwitchCase defines individual cases in ngSwitch.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is *ngSwitchDefault?",
        "type": "mcq",
        "o": [
            "The template shown when no case matches",
            "The first case",
            "The main case",
            "An error handler"
        ]
    },
    {
        "q": "Match the ngSwitch directives:",
        "type": "match",
        "left": [
            "[ngSwitch]",
            "*ngSwitchCase",
            "*ngSwitchDefault"
        ],
        "right": [
            "Container",
            "Match case",
            "No match case"
        ]
    },
    {
        "q": "What is an attribute directive?",
        "type": "mcq",
        "o": [
            "A directive that changes the appearance or behavior of an element",
            "A directive that adds attributes",
            "A directive that creates elements",
            "A directive that removes elements"
        ]
    },
    {
        "q": "Attribute directives do not change the DOM structure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngClass used for?",
        "type": "mcq",
        "o": [
            "Dynamically adding or removing CSS classes",
            "Creating classes",
            "Defining components",
            "Styling elements"
        ]
    },
    {
        "q": "The _____ directive adds/removes CSS classes dynamically.",
        "type": "fill_blank",
        "answers": [
            "ngClass"
        ],
        "other_options": [
            "ngStyle",
            "class",
            "addClass"
        ]
    },
    {
        "q": "What formats does ngClass accept?",
        "type": "mcq",
        "o": [
            "String, array, or object",
            "Only strings",
            "Only arrays",
            "Only objects"
        ]
    },
    {
        "q": "ngClass with object syntax uses boolean values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ngClass do?",
        "type": "mcq",
        "c": "[ngClass]=\"{'active': isActive, 'disabled': isDisabled}\"",
        "o": [
            "Adds 'active' class if isActive is true, 'disabled' if isDisabled is true",
            "Always adds both classes",
            "Removes both classes",
            "Toggles classes"
        ]
    },
    {
        "q": "Match the ngClass formats:",
        "type": "match",
        "left": [
            "String",
            "Array",
            "Object"
        ],
        "right": [
            "'class1 class2'",
            "['class1', 'class2']",
            "{class1: bool}"
        ]
    },
    {
        "q": "What is ngStyle used for?",
        "type": "mcq",
        "o": [
            "Dynamically setting inline styles on elements",
            "Creating stylesheets",
            "Importing CSS",
            "Defining animations"
        ]
    },
    {
        "q": "ngStyle takes an object with style properties.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ngStyle do?",
        "type": "mcq",
        "c": "[ngStyle]=\"{'color': textColor, 'font-size': fontSize + 'px'}\"",
        "o": [
            "Sets color and font-size based on component properties",
            "Creates CSS rules",
            "Removes styles",
            "Validates styles"
        ]
    },
    {
        "q": "The _____ directive sets inline styles dynamically.",
        "type": "fill_blank",
        "answers": [
            "ngStyle"
        ],
        "other_options": [
            "ngClass",
            "style",
            "setStyle"
        ]
    },
    {
        "q": "What is ng-template?",
        "type": "mcq",
        "o": [
            "A container for Angular templates that isn't rendered by default",
            "An HTML template tag",
            "A component template",
            "A style template"
        ]
    },
    {
        "q": "ng-template content is not rendered until explicitly used.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ng-container?",
        "type": "mcq",
        "o": [
            "A grouping element that doesn't render any DOM element",
            "A div container",
            "A component container",
            "A data container"
        ]
    },
    {
        "q": "Match the template elements:",
        "type": "match",
        "left": [
            "ng-template",
            "ng-container",
            "ng-content"
        ],
        "right": [
            "Not rendered by default",
            "No DOM element",
            "Content projection"
        ]
    },
    {
        "q": "Why use ng-container?",
        "type": "mcq",
        "o": [
            "To group elements without adding extra DOM nodes",
            "To improve security",
            "To style elements",
            "To create components"
        ]
    },
    {
        "q": "ng-container is useful when you can't apply structural directives directly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the selector in a directive?",
        "type": "mcq",
        "o": [
            "A CSS selector that identifies where to apply the directive",
            "A function name",
            "A component name",
            "A module name"
        ]
    },
    {
        "q": "Directive selectors are often attribute selectors like [myDirective].",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you create a custom attribute directive?",
        "type": "mcq",
        "c": "@Directive({\n  selector: '[appHighlight]'\n})",
        "o": [
            "Using @Directive decorator with an attribute selector",
            "Using @Component decorator",
            "Using @Pipe decorator",
            "Using @Custom decorator"
        ]
    },
    {
        "q": "The _____ decorator creates a custom directive.",
        "type": "fill_blank",
        "answers": [
            "@Directive"
        ],
        "other_options": [
            "@Custom",
            "@Attribute",
            "@Element"
        ]
    },
    {
        "q": "What is ElementRef in directives?",
        "type": "mcq",
        "o": [
            "A wrapper around the native DOM element",
            "An element creator",
            "A reference counter",
            "An element validator"
        ]
    },
    {
        "q": "ElementRef.nativeElement gives direct DOM access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Why should ElementRef be used carefully?",
        "type": "mcq",
        "o": [
            "Direct DOM access may break server-side rendering",
            "It's slow",
            "It uses too much memory",
            "It's deprecated"
        ]
    },
    {
        "q": "Match the directive tools:",
        "type": "match",
        "left": [
            "ElementRef",
            "Renderer2",
            "@HostBinding",
            "@HostListener"
        ],
        "right": [
            "DOM reference",
            "Safe DOM manipulation",
            "Property binding",
            "Event handling"
        ]
    },
    {
        "q": "What is Renderer2?",
        "type": "mcq",
        "o": [
            "A service for safe, platform-independent DOM manipulation",
            "A rendering engine",
            "A graphics renderer",
            "A template renderer"
        ]
    },
    {
        "q": "Renderer2 is preferred over direct DOM manipulation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What method adds a class with Renderer2?",
        "type": "mcq",
        "o": [
            "renderer.addClass(element, 'className')",
            "renderer.addClassName()",
            "renderer.setClass()",
            "renderer.class()"
        ]
    },
    {
        "q": "The _____ method sets an element's style with Renderer2.",
        "type": "fill_blank",
        "answers": [
            "setStyle"
        ],
        "other_options": [
            "addStyle",
            "applyStyle",
            "style"
        ]
    },
    {
        "q": "What does Renderer2.removeClass() do?",
        "type": "mcq",
        "o": [
            "Removes a CSS class from an element",
            "Removes the element",
            "Removes all classes",
            "Clears styles"
        ]
    },
    {
        "q": "Match the Renderer2 methods:",
        "type": "match",
        "left": [
            "addClass",
            "removeClass",
            "setStyle",
            "setAttribute"
        ],
        "right": [
            "Add CSS class",
            "Remove CSS class",
            "Set inline style",
            "Set HTML attribute"
        ]
    },
    {
        "q": "What is @HostBinding?",
        "type": "mcq",
        "o": [
            "Binds a directive property to a host element property",
            "Creates a binding",
            "Hosts an element",
            "Binds services"
        ]
    },
    {
        "q": "@HostBinding can bind to class, style, and attribute properties.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @HostBinding do?",
        "type": "mcq",
        "c": "@HostBinding('class.active') isActive = false;",
        "o": [
            "Adds 'active' class when isActive is true",
            "Creates a class",
            "Removes active class",
            "Always adds active"
        ]
    },
    {
        "q": "The _____ decorator binds properties to the host element.",
        "type": "fill_blank",
        "answers": [
            "@HostBinding"
        ],
        "other_options": [
            "@HostListener",
            "@Bind",
            "@Host"
        ]
    },
    {
        "q": "What is @HostListener?",
        "type": "mcq",
        "o": [
            "Listens to events on the host element",
            "Creates listeners",
            "Hosts events",
            "Logs events"
        ]
    },
    {
        "q": "@HostListener can pass $event to the handler.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @HostListener do?",
        "type": "mcq",
        "c": "@HostListener('mouseenter')\nonMouseEnter() {\n  this.highlight('yellow');\n}",
        "o": [
            "Calls highlight when mouse enters the host element",
            "Creates a mouse event",
            "Removes mouse listeners",
            "Logs mouse position"
        ]
    },
    {
        "q": "Match the host decorators:",
        "type": "match",
        "left": [
            "@HostBinding",
            "@HostListener"
        ],
        "right": [
            "Bind property",
            "Listen to event"
        ]
    },
    {
        "q": "What is @Input in a directive?",
        "type": "mcq",
        "o": [
            "Receives data from the parent element using the directive",
            "Creates inputs",
            "Handles user input",
            "Validates input"
        ]
    },
    {
        "q": "Directives can have multiple @Input properties.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you pass data to a directive?",
        "type": "mcq",
        "c": "<p appHighlight [color]=\"'yellow'\">Text</p>",
        "o": [
            "By binding to the @Input property on the directive",
            "Using innerHTML",
            "Through services",
            "Using global variables"
        ]
    },
    {
        "q": "The _____ decorator receives values in a directive.",
        "type": "fill_blank",
        "answers": [
            "@Input"
        ],
        "other_options": [
            "@Output",
            "@Bind",
            "@Value"
        ]
    },
    {
        "q": "What is @Output in a directive?",
        "type": "mcq",
        "o": [
            "Emits events from the directive to the parent",
            "Creates output",
            "Displays data",
            "Logs values"
        ]
    },
    {
        "q": "@Output uses EventEmitter to emit events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngOnInit in a directive?",
        "type": "mcq",
        "o": [
            "A lifecycle hook called after the directive is initialized",
            "An initialization function",
            "A setup method",
            "A startup event"
        ]
    },
    {
        "q": "Match the directive lifecycle hooks:",
        "type": "match",
        "left": [
            "ngOnInit",
            "ngOnChanges",
            "ngOnDestroy",
            "ngAfterViewInit"
        ],
        "right": [
            "After initialization",
            "Input changes",
            "Before destruction",
            "After view ready"
        ]
    },
    {
        "q": "What is ngOnChanges in a directive?",
        "type": "mcq",
        "o": [
            "Called when any @Input property value changes",
            "Detects DOM changes",
            "Handles events",
            "Updates styles"
        ]
    },
    {
        "q": "ngOnChanges receives a SimpleChanges object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngOnDestroy in a directive?",
        "type": "mcq",
        "o": [
            "Called just before Angular destroys the directive",
            "Destroys elements",
            "Removes bindings",
            "Clears memory"
        ]
    },
    {
        "q": "The _____ hook is used for cleanup in directives.",
        "type": "fill_blank",
        "answers": [
            "ngOnDestroy"
        ],
        "other_options": [
            "ngOnInit",
            "ngCleanup",
            "ngDispose"
        ]
    },
    {
        "q": "What is a host property in @Directive metadata?",
        "type": "mcq",
        "o": [
            "An alternative to @HostBinding and @HostListener in decorator",
            "The host element",
            "A hosting server",
            "A parent component"
        ]
    },
    {
        "q": "The host property can define both bindings and listeners.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is exportAs in a directive?",
        "type": "mcq",
        "o": [
            "Exports the directive instance with a name for template reference",
            "Exports to a file",
            "Exports data",
            "Shares the directive"
        ]
    },
    {
        "q": "Match the @Directive properties:",
        "type": "match",
        "left": [
            "selector",
            "host",
            "exportAs",
            "providers"
        ],
        "right": [
            "CSS selector",
            "Bindings/listeners",
            "Template reference",
            "Dependencies"
        ]
    },
    {
        "q": "How do you reference a directive in a template?",
        "type": "mcq",
        "c": "<input type=\"text\" #myInput=\"appValidator\" appValidator>",
        "o": [
            "Using #reference with exportAs name",
            "Using id attribute",
            "Using class name",
            "Using index"
        ]
    },
    {
        "q": "exportAs allows templates to interact with directive methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is standalone: true for directives?",
        "type": "mcq",
        "o": [
            "Makes the directive usable without declaring in NgModule",
            "Runs independently",
            "Creates isolation",
            "Removes dependencies"
        ]
    },
    {
        "q": "Standalone directives can be imported directly in components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you use a standalone directive?",
        "type": "mcq",
        "c": "@Component({\n  imports: [HighlightDirective]\n})",
        "o": [
            "Import it in the component's imports array",
            "Declare in module",
            "Use globally",
            "No import needed"
        ]
    },
    {
        "q": "The _____ property makes directives standalone.",
        "type": "fill_blank",
        "answers": [
            "standalone"
        ],
        "other_options": [
            "independent",
            "isolated",
            "solo"
        ]
    },
    {
        "q": "What is ngTemplateOutlet?",
        "type": "mcq",
        "o": [
            "A directive that inserts ng-template content dynamically",
            "A template output",
            "An outlet router",
            "A content stream"
        ]
    },
    {
        "q": "ngTemplateOutlet can pass context to templates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange the directive creation steps:",
        "type": "rearrange",
        "words": [
            "Create class",
            "Add @Directive",
            "Define selector",
            "Inject ElementRef",
            "Add logic"
        ]
    },
    {
        "q": "What is ngTemplateOutletContext?",
        "type": "mcq",
        "o": [
            "Object that defines context variables for the template",
            "Template settings",
            "Context API",
            "Outlet configuration"
        ]
    },
    {
        "q": "Context variables in templates use $implicit for default binding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ngTemplateOutlet do?",
        "type": "mcq",
        "c": "<ng-container *ngTemplateOutlet=\"myTemplate; context: {$implicit: data}\"></ng-container>",
        "o": [
            "Renders myTemplate with data as the default context variable",
            "Creates a new template",
            "Removes the template",
            "Logs the data"
        ]
    },
    {
        "q": "Match the template outlet features:",
        "type": "match",
        "left": [
            "ngTemplateOutlet",
            "ngTemplateOutletContext",
            "$implicit",
            "let-var"
        ],
        "right": [
            "Template reference",
            "Context object",
            "Default value",
            "Named variable"
        ]
    },
    {
        "q": "What is TemplateRef?",
        "type": "mcq",
        "o": [
            "A reference to an ng-template in the component",
            "A template creator",
            "A reference counter",
            "A template validator"
        ]
    },
    {
        "q": "TemplateRef allows programmatic template manipulation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ViewContainerRef?",
        "type": "mcq",
        "o": [
            "A container for inserting views dynamically",
            "A view creator",
            "A container element",
            "A reference holder"
        ]
    },
    {
        "q": "The _____ method creates an embedded view from a template.",
        "type": "fill_blank",
        "answers": [
            "createEmbeddedView"
        ],
        "other_options": [
            "create",
            "insertView",
            "addView"
        ]
    },
    {
        "q": "What does ViewContainerRef.createEmbeddedView() do?",
        "type": "mcq",
        "o": [
            "Instantiates a template and inserts it into the view container",
            "Creates a component",
            "Embeds a video",
            "Creates a container"
        ]
    },
    {
        "q": "Match the template APIs:",
        "type": "match",
        "left": [
            "TemplateRef",
            "ViewContainerRef",
            "EmbeddedViewRef",
            "createEmbeddedView"
        ],
        "right": [
            "Template reference",
            "Insertion point",
            "View instance",
            "Create method"
        ]
    },
    {
        "q": "How do you create a custom structural directive?",
        "type": "mcq",
        "o": [
            "Inject TemplateRef and ViewContainerRef, then manipulate views",
            "Use @Structural decorator",
            "Extend NgIf",
            "Use asterisk in selector"
        ]
    },
    {
        "q": "Structural directives need TemplateRef and ViewContainerRef.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this structural directive do?",
        "type": "mcq",
        "c": "if (condition) {\n  this.vcRef.createEmbeddedView(this.templateRef);\n} else {\n  this.vcRef.clear();\n}",
        "o": [
            "Shows template when condition is true, removes when false",
            "Creates two views",
            "Clears all templates",
            "Validates condition"
        ]
    },
    {
        "q": "The _____ method removes all views from a container.",
        "type": "fill_blank",
        "answers": [
            "clear"
        ],
        "other_options": [
            "remove",
            "destroy",
            "delete"
        ]
    },
    {
        "q": "What is the microsyntax in structural directives?",
        "type": "mcq",
        "o": [
            "The shorthand syntax that Angular expands to ng-template",
            "Small syntax",
            "Micro functions",
            "Short expressions"
        ]
    },
    {
        "q": "*ngFor is microsyntax that expands to ng-template with [ngFor].",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the asterisk (*) do in structural directives?",
        "type": "mcq",
        "o": [
            "Triggers Angular to wrap the element in an ng-template",
            "Multiplies elements",
            "Makes it optional",
            "Adds priority"
        ]
    },
    {
        "q": "Match the microsyntax conversions:",
        "type": "match",
        "left": [
            "*ngIf=\"condition\"",
            "*ngFor=\"let item of items\""
        ],
        "right": [
            "[ngIf]='condition'",
            "[ngForOf]='items'"
        ]
    },
    {
        "q": "What is ngNonBindable directive?",
        "type": "mcq",
        "o": [
            "Prevents Angular from processing bindings in the element",
            "Removes bindings",
            "Creates bindings",
            "Validates bindings"
        ]
    },
    {
        "q": "ngNonBindable is useful for displaying Angular syntax as text.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngPlural directive?",
        "type": "mcq",
        "o": [
            "Displays different strings based on numeric value using ICU format",
            "Creates plural forms",
            "Multiplies values",
            "Plural validation"
        ]
    },
    {
        "q": "The _____ directive handles pluralization in templates.",
        "type": "fill_blank",
        "answers": [
            "ngPlural"
        ],
        "other_options": [
            "ngSwitch",
            "ngIf",
            "ngNumber"
        ]
    },
    {
        "q": "What is ngPluralCase?",
        "type": "mcq",
        "o": [
            "Defines individual cases for ngPlural like =0, =1, other",
            "Plural container",
            "Case converter",
            "Number formatter"
        ]
    },
    {
        "q": "Match the special directives:",
        "type": "match",
        "left": [
            "ngNonBindable",
            "ngPlural",
            "ngPluralCase",
            "ngComponentOutlet"
        ],
        "right": [
            "Skip processing",
            "Pluralization",
            "Plural case",
            "Dynamic component"
        ]
    },
    {
        "q": "What is ngComponentOutlet?",
        "type": "mcq",
        "o": [
            "Dynamically instantiates a component in the template",
            "Component output",
            "Router outlet",
            "Template outlet"
        ]
    },
    {
        "q": "ngComponentOutlet can render different components dynamically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ngComponentOutlet do?",
        "type": "mcq",
        "c": "<ng-container *ngComponentOutlet=\"currentComponent\"></ng-container>",
        "o": [
            "Renders the component type stored in currentComponent",
            "Creates a container",
            "Outputs component data",
            "Logs component"
        ]
    },
    {
        "q": "The _____ directive dynamically renders components.",
        "type": "fill_blank",
        "answers": [
            "ngComponentOutlet"
        ],
        "other_options": [
            "ngTemplateOutlet",
            "ngContainer",
            "ngDynamic"
        ]
    },
    {
        "q": "What is the difference between ngIf and [hidden]?",
        "type": "mcq",
        "o": [
            "ngIf removes from DOM; hidden uses CSS display:none",
            "They are the same",
            "hidden is faster",
            "ngIf is for styling"
        ]
    },
    {
        "q": "[hidden] keeps the element in the DOM but hides it.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "When should you use [hidden] over *ngIf?",
        "type": "mcq",
        "o": [
            "When frequently toggling visibility and element is simple",
            "Always",
            "Never",
            "For complex elements"
        ]
    },
    {
        "q": "Match the visibility approaches:",
        "type": "match",
        "left": [
            "*ngIf",
            "[hidden]",
            "ngClass",
            "[style.display]"
        ],
        "right": [
            "DOM manipulation",
            "CSS hidden",
            "Class toggle",
            "Inline style"
        ]
    },
    {
        "q": "What is the purpose of directive composition?",
        "type": "mcq",
        "o": [
            "Combining multiple directive behaviors on a single element",
            "Creating composites",
            "Merging directives",
            "Directive inheritance"
        ]
    },
    {
        "q": "Multiple directives can be applied to the same element.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is hostDirectives in Angular?",
        "type": "mcq",
        "o": [
            "A feature to compose directives into a component or directive",
            "Host element directives",
            "Main directives",
            "Parent directives"
        ]
    },
    {
        "q": "The _____ property enables directive composition.",
        "type": "fill_blank",
        "answers": [
            "hostDirectives"
        ],
        "other_options": [
            "directives",
            "compose",
            "includes"
        ]
    },
    {
        "q": "What does this hostDirectives do?",
        "type": "mcq",
        "c": "@Component({\n  hostDirectives: [TooltipDirective, FocusDirective]\n})",
        "o": [
            "Applies tooltip and focus behaviors to the component",
            "Creates nested directives",
            "Imports directives",
            "Removes behaviors"
        ]
    },
    {
        "q": "hostDirectives can expose inputs and outputs from composed directives.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you expose inputs from hostDirectives?",
        "type": "mcq",
        "c": "hostDirectives: [{\n  directive: TooltipDirective,\n  inputs: ['text']\n}]",
        "o": [
            "Using the inputs array to specify which inputs to expose",
            "All inputs are exposed automatically",
            "Using @Input decorator",
            "Through configuration"
        ]
    },
    {
        "q": "Match the hostDirectives options:",
        "type": "match",
        "left": [
            "directive",
            "inputs",
            "outputs"
        ],
        "right": [
            "Directive class",
            "Exposed inputs",
            "Exposed outputs"
        ]
    },
    {
        "q": "What is the new @if block in Angular?",
        "type": "mcq",
        "o": [
            "A new control flow syntax replacing *ngIf",
            "An if function",
            "A conditional pipe",
            "A template tag"
        ]
    },
    {
        "q": "@if is more performant than *ngIf.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @if block do?",
        "type": "mcq",
        "c": "@if (user) {\n  <p>Welcome, {{ user.name }}</p>\n} @else {\n  <p>Please login</p>\n}",
        "o": [
            "Shows welcome message if user exists, otherwise login prompt",
            "Creates two elements",
            "Logs user",
            "Validates user"
        ]
    },
    {
        "q": "The _____ syntax is the new control flow for conditionals.",
        "type": "fill_blank",
        "answers": [
            "@if"
        ],
        "other_options": [
            "*ngIf",
            "if:",
            "#if"
        ]
    },
    {
        "q": "What is @for in Angular?",
        "type": "mcq",
        "o": [
            "New control flow syntax replacing *ngFor",
            "A for loop function",
            "A template loop",
            "An iteration pipe"
        ]
    },
    {
        "q": "@for requires a track expression.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @for block do?",
        "type": "mcq",
        "c": "@for (item of items; track item.id) {\n  <li>{{ item.name }}</li>\n}",
        "o": [
            "Loops through items using item.id for efficient tracking",
            "Creates one item",
            "Tracks items",
            "Validates items"
        ]
    },
    {
        "q": "Match the new control flow:",
        "type": "match",
        "left": [
            "@if",
            "@for",
            "@switch",
            "@empty"
        ],
        "right": [
            "Conditional",
            "Iteration",
            "Multiple cases",
            "Empty array"
        ]
    },
    {
        "q": "What is @empty in @for?",
        "type": "mcq",
        "o": [
            "Block shown when the collection is empty",
            "Empty block",
            "Reset block",
            "Clear block"
        ]
    },
    {
        "q": "@empty provides a fallback when @for has no items.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is @switch in Angular?",
        "type": "mcq",
        "o": [
            "New control flow syntax replacing ngSwitch",
            "A switch function",
            "A toggle",
            "A router switch"
        ]
    },
    {
        "q": "The _____ block defines individual cases in @switch.",
        "type": "fill_blank",
        "answers": [
            "@case"
        ],
        "other_options": [
            "@when",
            "@match",
            "@option"
        ]
    },
    {
        "q": "What is @default in @switch?",
        "type": "mcq",
        "o": [
            "The fallback block when no @case matches",
            "Default value",
            "Default setting",
            "Default style"
        ]
    },
    {
        "q": "Match the @switch syntax:",
        "type": "match",
        "left": [
            "@switch",
            "@case",
            "@default"
        ],
        "right": [
            "Container",
            "Match value",
            "No match"
        ]
    },
    {
        "q": "What is @let in Angular templates?",
        "type": "mcq",
        "o": [
            "Declares a template variable with an expression",
            "Let statement",
            "Variable declaration",
            "Constant creation"
        ]
    },
    {
        "q": "@let allows storing computed values in templates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @let do?",
        "type": "mcq",
        "c": "@let total = price * quantity;\n<p>Total: {{ total }}</p>",
        "o": [
            "Calculates and stores the total for use in the template",
            "Creates a constant",
            "Logs the value",
            "Validates price"
        ]
    },
    {
        "q": "The _____ syntax declares template-scoped variables.",
        "type": "fill_blank",
        "answers": [
            "@let"
        ],
        "other_options": [
            "let",
            "var",
            "#"
        ]
    },
    {
        "q": "What is the purpose of input transform in Angular?",
        "type": "mcq",
        "o": [
            "Transforming input values as they are received",
            "Input validation",
            "Input formatting",
            "Input logging"
        ]
    },
    {
        "q": "Input transforms can convert strings to numbers automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this input transform do?",
        "type": "mcq",
        "c": "@Input({transform: booleanAttribute}) disabled = false;",
        "o": [
            "Converts string 'true' or '' to boolean true",
            "Validates boolean",
            "Creates toggle",
            "Logs disabled state"
        ]
    },
    {
        "q": "Match the input transforms:",
        "type": "match",
        "left": [
            "booleanAttribute",
            "numberAttribute",
            "custom function"
        ],
        "right": [
            "String to boolean",
            "String to number",
            "Custom conversion"
        ]
    },
    {
        "q": "What is signal-based input()?",
        "type": "mcq",
        "o": [
            "A function that creates reactive input properties",
            "Input signal",
            "Signal creation",
            "Input validation"
        ]
    },
    {
        "q": "input() provides signal-based reactivity for inputs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this input code do?",
        "type": "mcq",
        "c": "name = input<string>('default');\nrequiredId = input.required<number>();",
        "o": [
            "Creates optional and required signal inputs",
            "Creates HTML inputs",
            "Validates inputs",
            "Logs inputs"
        ]
    },
    {
        "q": "The _____ function creates signal-based inputs.",
        "type": "fill_blank",
        "answers": [
            "input"
        ],
        "other_options": [
            "@Input",
            "signal",
            "reactive"
        ]
    },
    {
        "q": "What is output() function?",
        "type": "mcq",
        "o": [
            "Creates a signal-based output emitter",
            "Output display",
            "Console output",
            "File output"
        ]
    },
    {
        "q": "output() replaces @Output with EventEmitter.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this output code do?",
        "type": "mcq",
        "c": "clicked = output<MouseEvent>();\nthis.clicked.emit(event);",
        "o": [
            "Creates an output that emits MouseEvent objects",
            "Logs clicks",
            "Creates button",
            "Validates events"
        ]
    },
    {
        "q": "Match the signal-based APIs:",
        "type": "match",
        "left": [
            "input()",
            "output()",
            "model()",
            "viewChild()"
        ],
        "right": [
            "Input property",
            "Event emitter",
            "Two-way binding",
            "View query"
        ]
    },
    {
        "q": "What is model() function?",
        "type": "mcq",
        "o": [
            "Creates a two-way bindable signal input",
            "Data model",
            "Model class",
            "Model validation"
        ]
    },
    {
        "q": "model() enables two-way binding with signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this model code do?",
        "type": "mcq",
        "c": "value = model<string>('');",
        "o": [
            "Creates a two-way bindable signal with empty string default",
            "Creates a model class",
            "Validates values",
            "Logs changes"
        ]
    },
    {
        "q": "The _____ function creates two-way signal bindings.",
        "type": "fill_blank",
        "answers": [
            "model"
        ],
        "other_options": [
            "input",
            "output",
            "signal"
        ]
    },
    {
        "q": "What is viewChild() function?",
        "type": "mcq",
        "o": [
            "Signal-based query for child elements",
            "View creator",
            "Child component",
            "View validator"
        ]
    },
    {
        "q": "viewChild() returns a signal containing the query result.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this viewChild code do?",
        "type": "mcq",
        "c": "inputEl = viewChild<ElementRef>('input');",
        "o": [
            "Creates a signal query for element with #input reference",
            "Creates input",
            "Logs element",
            "Validates input"
        ]
    },
    {
        "q": "Match the query functions:",
        "type": "match",
        "left": [
            "viewChild()",
            "viewChildren()",
            "contentChild()",
            "contentChildren()"
        ],
        "right": [
            "Single view element",
            "Multiple view elements",
            "Single projected",
            "Multiple projected"
        ]
    },
    {
        "q": "What is viewChildren() function?",
        "type": "mcq",
        "o": [
            "Signal-based query for multiple child elements",
            "View creator",
            "Children creator",
            "Array generator"
        ]
    },
    {
        "q": "viewChildren() returns a signal containing an array-like result.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is contentChild() function?",
        "type": "mcq",
        "o": [
            "Signal-based query for projected content elements",
            "Content creator",
            "Child selector",
            "Content validator"
        ]
    },
    {
        "q": "The _____ function queries projected content with signals.",
        "type": "fill_blank",
        "answers": [
            "contentChild"
        ],
        "other_options": [
            "viewChild",
            "content",
            "ngContent"
        ]
    },
    {
        "q": "What is the difference between view and content queries?",
        "type": "mcq",
        "o": [
            "View queries the template; content queries ng-content projection",
            "They are the same",
            "Content is faster",
            "View is for styles"
        ]
    },
    {
        "q": "Content queries access elements projected via ng-content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the required option in signal queries?",
        "type": "mcq",
        "c": "inputEl = viewChild.required<ElementRef>('input');",
        "o": [
            "Makes the query required, never undefined",
            "Required validation",
            "Required element",
            "Mandatory setting"
        ]
    },
    {
        "q": "Match the query options:",
        "type": "match",
        "left": [
            "required",
            "read",
            "descendants"
        ],
        "right": [
            "Never undefined",
            "Token type",
            "Include nested"
        ]
    },
    {
        "q": "What is the read option in queries?",
        "type": "mcq",
        "o": [
            "Specifies what token to read from the queried element",
            "Read mode",
            "Read-only",
            "Read speed"
        ]
    },
    {
        "q": "read: ElementRef returns the native element wrapper.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is afterRender() for in directives?",
        "type": "mcq",
        "o": [
            "Callback that runs after DOM rendering is complete",
            "After animation",
            "Post-processing",
            "Cleanup"
        ]
    },
    {
        "q": "The _____ function runs after Angular renders the component.",
        "type": "fill_blank",
        "answers": [
            "afterRender"
        ],
        "other_options": [
            "afterInit",
            "onRender",
            "postRender"
        ]
    },
    {
        "q": "What is afterNextRender()?",
        "type": "mcq",
        "o": [
            "Callback that runs once after the next render cycle",
            "After every render",
            "Before render",
            "During render"
        ]
    },
    {
        "q": "afterNextRender is useful for one-time initialization after render.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What render phases can afterRender target?",
        "type": "mcq",
        "o": [
            "earlyRead, read, mixedReadWrite, write",
            "before, during, after",
            "init, update, destroy",
            "start, middle, end"
        ]
    },
    {
        "q": "Match the render phases:",
        "type": "match",
        "left": [
            "earlyRead",
            "read",
            "mixedReadWrite",
            "write"
        ],
        "right": [
            "Before layout",
            "After layout reads",
            "Combined",
            "DOM writes"
        ]
    },
    {
        "q": "What is DestroyRef in Angular?",
        "type": "mcq",
        "o": [
            "An injection token for destroy lifecycle access",
            "Destructor",
            "Cleanup service",
            "Memory manager"
        ]
    },
    {
        "q": "DestroyRef.onDestroy() registers cleanup callbacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this DestroyRef code do?",
        "type": "mcq",
        "c": "destroyRef.onDestroy(() => {\n  subscription.unsubscribe();\n});",
        "o": [
            "Unsubscribes when the context is destroyed",
            "Destroys immediately",
            "Logs destruction",
            "Prevents destruction"
        ]
    },
    {
        "q": "The _____ token enables functional cleanup patterns.",
        "type": "fill_blank",
        "answers": [
            "DestroyRef"
        ],
        "other_options": [
            "OnDestroy",
            "CleanupRef",
            "DisposeRef"
        ]
    },
    {
        "q": "What is takeUntilDestroyed()?",
        "type": "mcq",
        "o": [
            "RxJS operator that unsubscribes when component is destroyed",
            "Takes values",
            "Destroys subscription",
            "Removes operator"
        ]
    },
    {
        "q": "takeUntilDestroyed simplifies subscription cleanup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this code do?",
        "type": "mcq",
        "c": "interval(1000).pipe(\n  takeUntilDestroyed()\n).subscribe(console.log);",
        "o": [
            "Logs every second until component is destroyed",
            "Creates infinite log",
            "Stops immediately",
            "Logs once"
        ]
    },
    {
        "q": "Match the cleanup patterns:",
        "type": "match",
        "left": [
            "ngOnDestroy",
            "DestroyRef",
            "takeUntilDestroyed",
            "async pipe"
        ],
        "right": [
            "Lifecycle hook",
            "Injection token",
            "RxJS operator",
            "Template cleanup"
        ]
    },
    {
        "q": "What is inject() function?",
        "type": "mcq",
        "o": [
            "Dependency injection in functional/constructor context",
            "Injection token",
            "Service creator",
            "Inject validation"
        ]
    },
    {
        "q": "inject() can be used in directive constructors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this inject code do?",
        "type": "mcq",
        "c": "private el = inject(ElementRef);\nprivate renderer = inject(Renderer2);",
        "o": [
            "Injects ElementRef and Renderer2 using functional pattern",
            "Creates elements",
            "Renders content",
            "Validates dependencies"
        ]
    },
    {
        "q": "The _____ function enables functional dependency injection.",
        "type": "fill_blank",
        "answers": [
            "inject"
        ],
        "other_options": [
            "get",
            "provide",
            "resolve"
        ]
    },
    {
        "q": "What is effect() in directives?",
        "type": "mcq",
        "o": [
            "Creates a reactive side effect that tracks signal dependencies",
            "Visual effect",
            "Animation effect",
            "DOM effect"
        ]
    },
    {
        "q": "effect() automatically re-runs when tracked signals change.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this effect do?",
        "type": "mcq",
        "c": "effect(() => {\n  this.renderer.setStyle(this.el.nativeElement, 'color', this.color());\n});",
        "o": [
            "Updates element color whenever color signal changes",
            "Logs color",
            "Validates color",
            "Creates animation"
        ]
    },
    {
        "q": "Match the reactive patterns:",
        "type": "match",
        "left": [
            "signal()",
            "computed()",
            "effect()",
            "toSignal()"
        ],
        "right": [
            "Writable state",
            "Derived value",
            "Side effect",
            "Observable conversion"
        ]
    },
    {
        "q": "What is computed() for in directives?",
        "type": "mcq",
        "o": [
            "Creates a derived signal from other signals",
            "Computes math",
            "Calculates values",
            "Validates data"
        ]
    },
    {
        "q": "computed() only recalculates when dependencies change.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this computed code do?",
        "type": "mcq",
        "c": "isHighlighted = computed(() => this.active() && !this.disabled());",
        "o": [
            "Derives highlight state from active and disabled signals",
            "Highlights always",
            "Logs state",
            "Creates toggle"
        ]
    },
    {
        "q": "The _____ function creates derived read-only signals.",
        "type": "fill_blank",
        "answers": [
            "computed"
        ],
        "other_options": [
            "derive",
            "calculate",
            "signal"
        ]
    },
    {
        "q": "What is testing directives with TestBed?",
        "type": "mcq",
        "o": [
            "Creating a test module to test directive behavior",
            "Testing directly",
            "Unit testing",
            "Manual testing"
        ]
    },
    {
        "q": "Directives can be tested by creating host components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a host component in directive testing?",
        "type": "mcq",
        "o": [
            "A component that uses the directive for testing purposes",
            "Main component",
            "Parent component",
            "Test component"
        ]
    },
    {
        "q": "Match the testing concepts:",
        "type": "match",
        "left": [
            "TestBed",
            "ComponentFixture",
            "DebugElement",
            "By.directive"
        ],
        "right": [
            "Test module",
            "Component wrapper",
            "Element wrapper",
            "Query predicate"
        ]
    },
    {
        "q": "What does By.directive() do in testing?",
        "type": "mcq",
        "o": [
            "Creates a predicate to query elements by directive type",
            "Creates directives",
            "Validates directives",
            "Logs directives"
        ]
    },
    {
        "q": "fixture.debugElement.query(By.directive(MyDirective)) finds elements with the directive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "How do you get the directive instance in tests?",
        "type": "mcq",
        "c": "const directive = debugElement.injector.get(MyDirective);",
        "o": [
            "Using the element's injector to get the directive",
            "Using fixture.directive",
            "Using TestBed.get()",
            "Directly accessing"
        ]
    },
    {
        "q": "The _____ method retrieves directive instances from elements.",
        "type": "fill_blank",
        "answers": [
            "injector.get"
        ],
        "other_options": [
            "getDirective",
            "query",
            "find"
        ]
    },
    {
        "q": "What is ng-mocks for directive testing?",
        "type": "mcq",
        "o": [
            "A library for mocking Angular dependencies in tests",
            "Mock directives",
            "Test mocks",
            "Fake data"
        ]
    },
    {
        "q": "ng-mocks can automatically mock directives for isolation testing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Spectator for testing?",
        "type": "mcq",
        "o": [
            "A testing library that simplifies Angular testing",
            "Test viewer",
            "Test monitor",
            "Debugging tool"
        ]
    },
    {
        "q": "Match the testing libraries:",
        "type": "match",
        "left": [
            "Spectator",
            "ng-mocks",
            "Jest",
            "Karma"
        ],
        "right": [
            "Testing helper",
            "Mocking library",
            "Test runner",
            "Test runner"
        ]
    },
    {
        "q": "What is the purpose of directive performance optimization?",
        "type": "mcq",
        "o": [
            "Minimizing DOM operations and change detection cycles",
            "Faster code",
            "Better UX",
            "Smaller files"
        ]
    },
    {
        "q": "Using OnPush change detection can improve directive performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is runOutsideAngular for directives?",
        "type": "mcq",
        "o": [
            "Runs code outside Angular's change detection zone",
            "External execution",
            "Zone bypass",
            "Async execution"
        ]
    },
    {
        "q": "The _____ method runs code without triggering change detection.",
        "type": "fill_blank",
        "answers": [
            "runOutsideAngular"
        ],
        "other_options": [
            "runAsync",
            "runExternal",
            "execute"
        ]
    },
    {
        "q": "When should you use runOutsideAngular in directives?",
        "type": "mcq",
        "o": [
            "For frequent DOM operations like scroll or mouse move handlers",
            "Always",
            "Never",
            "Only for HTTP"
        ]
    },
    {
        "q": "Match the performance techniques:",
        "type": "match",
        "left": [
            "runOutsideAngular",
            "trackBy",
            "OnPush",
            "detach"
        ],
        "right": [
            "Skip zone",
            "Optimize lists",
            "Reduce checks",
            "Manual CD"
        ]
    },
    {
        "q": "What is ChangeDetectorRef.detach()?",
        "type": "mcq",
        "o": [
            "Detaches the component from automatic change detection",
            "Removes component",
            "Detaches view",
            "Clears changes"
        ]
    },
    {
        "q": "detach() allows manual change detection control.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ChangeDetectorRef.reattach()?",
        "type": "mcq",
        "o": [
            "Re-enables automatic change detection after detach",
            "Reattaches element",
            "Reconnects service",
            "Restores state"
        ]
    },
    {
        "q": "The _____ method re-enables automatic change detection.",
        "type": "fill_blank",
        "answers": [
            "reattach"
        ],
        "other_options": [
            "attach",
            "enable",
            "connect"
        ]
    },
    {
        "q": "What is ChangeDetectorRef.markForCheck()?",
        "type": "mcq",
        "o": [
            "Marks OnPush component for check in next cycle",
            "Checks immediately",
            "Marks changed",
            "Logs check"
        ]
    },
    {
        "q": "markForCheck is used with OnPush when async data changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ChangeDetectorRef.detectChanges()?",
        "type": "mcq",
        "o": [
            "Immediately runs change detection for the component",
            "Detects changes",
            "Logs changes",
            "Queues changes"
        ]
    },
    {
        "q": "Match the ChangeDetectorRef methods:",
        "type": "match",
        "left": [
            "detectChanges",
            "markForCheck",
            "detach",
            "reattach"
        ],
        "right": [
            "Immediate check",
            "Queue check",
            "Disable auto",
            "Enable auto"
        ]
    },
    {
        "q": "Rearrange the directive development workflow:",
        "type": "rearrange",
        "words": [
            "Create directive class",
            "Define selector",
            "Add logic",
            "Write tests",
            "Export from module"
        ]
    },
    {
        "q": "What is a multi-slot content projection?",
        "type": "mcq",
        "o": [
            "Projecting content into multiple named ng-content slots",
            "Multiple projections",
            "Content split",
            "Multi-layer projection"
        ]
    },
    {
        "q": "ng-content accepts select attribute for multi-slot projection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this ng-content do?",
        "type": "mcq",
        "c": "<ng-content select=\"header\"></ng-content>\n<ng-content select=\".body\"></ng-content>",
        "o": [
            "Projects header elements and elements with class 'body' to respective slots",
            "Creates headers",
            "Selects one slot",
            "Logs content"
        ]
    },
    {
        "q": "The _____ attribute in ng-content targets specific projected content.",
        "type": "fill_blank",
        "answers": [
            "select"
        ],
        "other_options": [
            "filter",
            "target",
            "slot"
        ]
    },
    {
        "q": "What is ngProjectAs?",
        "type": "mcq",
        "o": [
            "Changes how an element is matched for content projection",
            "Project alias",
            "Content converter",
            "Slot renamer"
        ]
    },
    {
        "q": "ngProjectAs allows ng-container to be projected to a specific slot.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What are CSS attribute selectors for directives?",
        "type": "mcq",
        "o": [
            "Selectors using square brackets like [appDirective]",
            "CSS classes",
            "ID selectors",
            "Pseudo selectors"
        ]
    },
    {
        "q": "Match the selector types:",
        "type": "match",
        "left": [
            "[attr]",
            ".class",
            "element",
            "[attr=value]"
        ],
        "right": [
            "Attribute",
            "CSS class",
            "Element name",
            "Attribute with value"
        ]
    },
    {
        "q": "What is a selector combining multiple attributes?",
        "type": "mcq",
        "c": "selector: '[appTooltip][position]'",
        "o": [
            "Matches elements with both appTooltip and position attributes",
            "Either attribute",
            "One attribute",
            "Class selector"
        ]
    },
    {
        "q": "Directive selectors can use :not() pseudo-selector.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive with multiple selectors?",
        "type": "mcq",
        "c": "selector: '[appClick], [appTap]'",
        "o": [
            "Directive that applies to elements with either selector",
            "Multiple directives",
            "Combined directive",
            "Merged selectors"
        ]
    },
    {
        "q": "The _____ character separates multiple selectors in a directive.",
        "type": "fill_blank",
        "answers": [
            ","
        ],
        "other_options": [
            "|",
            ";",
            "&"
        ]
    },
    {
        "q": "What is a class-based directive selector?",
        "type": "mcq",
        "c": "selector: '.highlight'",
        "o": [
            "Matches elements with the highlight CSS class",
            "Creates classes",
            "Style selector",
            "Template class"
        ]
    },
    {
        "q": "Element selectors match by tag name like 'my-element'.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is directive inheritance?",
        "type": "mcq",
        "o": [
            "Extending a base directive class to reuse functionality",
            "Copying directives",
            "Cloning behavior",
            "Code sharing"
        ]
    },
    {
        "q": "Match the inheritance concepts:",
        "type": "match",
        "left": [
            "extends",
            "super()",
            "override",
            "abstract"
        ],
        "right": [
            "Inherit class",
            "Call parent",
            "Replace method",
            "Must implement"
        ]
    },
    {
        "q": "What is an abstract directive?",
        "type": "mcq",
        "o": [
            "A base class without @Directive that can't be used directly",
            "Hidden directive",
            "Invisible directive",
            "Virtual directive"
        ]
    },
    {
        "q": "Abstract directives provide shared functionality for derived directives.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is forwardRef in directives?",
        "type": "mcq",
        "o": [
            "Allows referencing a class before it's defined",
            "Forward motion",
            "Reference forwarding",
            "Link creator"
        ]
    },
    {
        "q": "The _____ function handles circular dependencies.",
        "type": "fill_blank",
        "answers": [
            "forwardRef"
        ],
        "other_options": [
            "resolveRef",
            "lazyRef",
            "deferRef"
        ]
    },
    {
        "q": "What is NG_VALUE_ACCESSOR?",
        "type": "mcq",
        "o": [
            "A token for registering custom form control directives",
            "Value getter",
            "Access token",
            "Form accessor"
        ]
    },
    {
        "q": "NG_VALUE_ACCESSOR enables custom form controls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What interface must custom form controls implement?",
        "type": "mcq",
        "o": [
            "ControlValueAccessor",
            "FormControl",
            "ValueAccessor",
            "CustomControl"
        ]
    },
    {
        "q": "Match the ControlValueAccessor methods:",
        "type": "match",
        "left": [
            "writeValue",
            "registerOnChange",
            "registerOnTouched",
            "setDisabledState"
        ],
        "right": [
            "Set value",
            "Change callback",
            "Touch callback",
            "Disable control"
        ]
    },
    {
        "q": "What is a validator directive?",
        "type": "mcq",
        "o": [
            "A directive that adds custom validation to form controls",
            "Value checker",
            "Form validator",
            "Input validator"
        ]
    },
    {
        "q": "Validator directives implement Validator interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What token registers a validator directive?",
        "type": "mcq",
        "o": [
            "NG_VALIDATORS or NG_ASYNC_VALIDATORS",
            "VALIDATORS",
            "FORM_VALIDATORS",
            "VALIDATION_TOKEN"
        ]
    },
    {
        "q": "The _____ token registers synchronous validators.",
        "type": "fill_blank",
        "answers": [
            "NG_VALIDATORS"
        ],
        "other_options": [
            "VALIDATORS",
            "NG_SYNC",
            "FORM_VALIDATORS"
        ]
    },
    {
        "q": "What is an async validator directive?",
        "type": "mcq",
        "o": [
            "A validator that returns Observable or Promise for validation",
            "Fast validator",
            "Delayed validator",
            "Remote validator"
        ]
    },
    {
        "q": "Async validators use NG_ASYNC_VALIDATORS token.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is NG_VALUE_ACCESSOR multi provider?",
        "type": "mcq",
        "c": "providers: [{\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MyDirective),\n  multi: true\n}]",
        "o": [
            "Allows multiple value accessors to be registered",
            "Single provider",
            "Unique accessor",
            "One-time registration"
        ]
    },
    {
        "q": "Match the form directive tokens:",
        "type": "match",
        "left": [
            "NG_VALUE_ACCESSOR",
            "NG_VALIDATORS",
            "NG_ASYNC_VALIDATORS"
        ],
        "right": [
            "Form control binding",
            "Sync validation",
            "Async validation"
        ]
    },
    {
        "q": "What is a structural directive microsyntax parser?",
        "type": "mcq",
        "o": [
            "Angular's syntax parser for * shorthand",
            "Code parser",
            "Template parser",
            "Syntax checker"
        ]
    },
    {
        "q": "Microsyntax can have multiple bindings like let-context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this microsyntax mean?",
        "type": "mcq",
        "c": "*myDirective=\"let item of items; let i=index; trackBy: trackFn\"",
        "o": [
            "Creates bindings for item, index, and trackBy function",
            "Single binding",
            "Loops through",
            "Creates template"
        ]
    },
    {
        "q": "The _____ keyword in microsyntax creates template variables.",
        "type": "fill_blank",
        "answers": [
            "let"
        ],
        "other_options": [
            "var",
            "const",
            "def"
        ]
    },
    {
        "q": "What is the implicit context in structural directives?",
        "type": "mcq",
        "o": [
            "The default value accessible without naming",
            "Hidden context",
            "Main context",
            "First value"
        ]
    },
    {
        "q": "Match microsyntax components:",
        "type": "match",
        "left": [
            "*directive",
            "let-var",
            "property:",
            "as alias"
        ],
        "right": [
            "Template wrapper",
            "Local variable",
            "Input binding",
            "Value alias"
        ]
    },
    {
        "q": "What is @defer block for lazy loading?",
        "type": "mcq",
        "o": [
            "Deferred rendering that lazy loads content on trigger",
            "Delayed block",
            "Async block",
            "Later block"
        ]
    },
    {
        "q": "@defer improves initial load performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What triggers can @defer use?",
        "type": "mcq",
        "o": [
            "on viewport, on interaction, on hover, on timer, when condition",
            "Only click",
            "Only scroll",
            "Only load"
        ]
    },
    {
        "q": "The _____ block shows content while @defer is loading.",
        "type": "fill_blank",
        "answers": [
            "@placeholder"
        ],
        "other_options": [
            "@loading",
            "@pending",
            "@waiting"
        ]
    },
    {
        "q": "What is @loading in @defer?",
        "type": "mcq",
        "o": [
            "Shows loading indicator while resources are being fetched",
            "Load handler",
            "Loading event",
            "Resource loader"
        ]
    },
    {
        "q": "@error shows content when @defer fails to load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this @defer do?",
        "type": "mcq",
        "c": "@defer (on viewport; prefetch on idle) {\n  <heavy-component />\n} @placeholder {\n  <skeleton />\n}",
        "o": [
            "Loads component when in viewport, prefetches when idle",
            "Always loads",
            "Never loads",
            "Loads on click"
        ]
    },
    {
        "q": "Match the @defer triggers:",
        "type": "match",
        "left": [
            "on viewport",
            "on interaction",
            "on hover",
            "on timer"
        ],
        "right": [
            "In view",
            "Click/keydown",
            "Mouse over",
            "Time delay"
        ]
    },
    {
        "q": "What is prefetch in @defer?",
        "type": "mcq",
        "o": [
            "Pre-downloads resources before the trigger condition",
            "Pre-rendering",
            "Early loading",
            "Cache fill"
        ]
    },
    {
        "q": "prefetch can have different triggers than the main @defer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is when condition in @defer?",
        "type": "mcq",
        "c": "@defer (when isReady) { <component /> }",
        "o": [
            "Triggers load when the expression becomes truthy",
            "Conditional content",
            "Always true",
            "Never loads"
        ]
    },
    {
        "q": "The _____ trigger loads @defer content after time delay.",
        "type": "fill_blank",
        "answers": [
            "on timer"
        ],
        "other_options": [
            "on delay",
            "on timeout",
            "on wait"
        ]
    },
    {
        "q": "What is minimum in @placeholder?",
        "type": "mcq",
        "c": "@placeholder (minimum 500ms) { <skeleton /> }",
        "o": [
            "Shows placeholder for at least 500ms even if content loads faster",
            "Maximum time",
            "Load time",
            "Wait time"
        ]
    },
    {
        "q": "Match the @defer blocks:",
        "type": "match",
        "left": [
            "@defer",
            "@placeholder",
            "@loading",
            "@error"
        ],
        "right": [
            "Main content",
            "Before trigger",
            "During load",
            "Load failed"
        ]
    },
    {
        "q": "What is a directive that works with SSR?",
        "type": "mcq",
        "o": [
            "A directive that avoids direct DOM access and uses platform-safe APIs",
            "Server directive",
            "Render directive",
            "SSR-only directive"
        ]
    },
    {
        "q": "Direct DOM access via nativeElement breaks SSR.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What makes a directive SSR-compatible?",
        "type": "mcq",
        "o": [
            "Using Renderer2, isPlatformBrowser check, and avoiding window/document",
            "Using ElementRef",
            "Using nativeElement",
            "Nothing special"
        ]
    },
    {
        "q": "The _____ function checks if running in browser.",
        "type": "fill_blank",
        "answers": [
            "isPlatformBrowser"
        ],
        "other_options": [
            "isBrowser",
            "checkPlatform",
            "getBrowser"
        ]
    },
    {
        "q": "Why is isPlatformBrowser needed for some directives?",
        "type": "mcq",
        "o": [
            "Some APIs like window/document don't exist on server",
            "Performance",
            "Security",
            "Style isolation"
        ]
    },
    {
        "q": "afterNextRender runs only on client, safe for browser APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is PLATFORM_ID injection token?",
        "type": "mcq",
        "o": [
            "Token that provides the current platform identifier",
            "Platform name",
            "ID generator",
            "Platform config"
        ]
    },
    {
        "q": "Match the SSR concepts:",
        "type": "match",
        "left": [
            "isPlatformBrowser",
            "isPlatformServer",
            "PLATFORM_ID",
            "TransferState"
        ],
        "right": [
            "Check browser",
            "Check server",
            "Platform token",
            "State hydration"
        ]
    },
    {
        "q": "What is hydration in Angular?",
        "type": "mcq",
        "o": [
            "Attaching event listeners to server-rendered HTML",
            "Adding water",
            "Loading data",
            "Caching"
        ]
    },
    {
        "q": "Hydration makes SSR content interactive on client.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngSkipHydration?",
        "type": "mcq",
        "o": [
            "Skips hydration for specific components/elements",
            "Skip directive",
            "Bypass hydration",
            "Remove events"
        ]
    },
    {
        "q": "The _____ attribute skips hydration for an element.",
        "type": "fill_blank",
        "answers": [
            "ngSkipHydration"
        ],
        "other_options": [
            "skipHydration",
            "noHydrate",
            "disableHydration"
        ]
    },
    {
        "q": "What is partial hydration?",
        "type": "mcq",
        "o": [
            "Only hydrating parts of the page that need interactivity",
            "Half hydration",
            "Incomplete loading",
            "Lazy hydration"
        ]
    },
    {
        "q": "Partial hydration can be combined with @defer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is event replay in hydration?",
        "type": "mcq",
        "o": [
            "Capturing and replaying user events that occurred before hydration",
            "Recording events",
            "Logging clicks",
            "Event history"
        ]
    },
    {
        "q": "Match the hydration features:",
        "type": "match",
        "left": [
            "Full hydration",
            "Partial hydration",
            "Event replay",
            "ngSkipHydration"
        ],
        "right": [
            "All interactive",
            "Selective",
            "Queue events",
            "Skip element"
        ]
    },
    {
        "q": "What is an accessibility directive?",
        "type": "mcq",
        "o": [
            "A directive that enhances accessibility for screen readers and keyboard",
            "Access control",
            "Permission directive",
            "Auth directive"
        ]
    },
    {
        "q": "Accessibility directives often set ARIA attributes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What accessibility attribute indicates element state?",
        "type": "mcq",
        "c": "@HostBinding('attr.aria-expanded') isExpanded = false;",
        "o": [
            "aria-expanded attribute for expandable elements",
            "expanded class",
            "state attribute",
            "toggle attribute"
        ]
    },
    {
        "q": "The _____ attribute announces content changes to screen readers.",
        "type": "fill_blank",
        "answers": [
            "aria-live"
        ],
        "other_options": [
            "aria-announce",
            "aria-say",
            "aria-speak"
        ]
    },
    {
        "q": "What is role attribute in accessibility?",
        "type": "mcq",
        "o": [
            "Defines the type of UI element for assistive technologies",
            "User role",
            "Permission",
            "Access level"
        ]
    },
    {
        "q": "Match the ARIA attributes:",
        "type": "match",
        "left": [
            "aria-label",
            "aria-describedby",
            "aria-hidden",
            "aria-disabled"
        ],
        "right": [
            "Text label",
            "Description reference",
            "Hide from AT",
            "Disabled state"
        ]
    },
    {
        "q": "What is focus management in directives?",
        "type": "mcq",
        "o": [
            "Programmatically controlling keyboard focus for accessibility",
            "Focus styling",
            "Focus events",
            "Focus capture"
        ]
    },
    {
        "q": "cdkFocusTrap keeps focus within a container like dialogs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What CDK directive traps focus?",
        "type": "mcq",
        "o": [
            "cdkTrapFocus",
            "focusTrap",
            "trapFocus",
            "cdkFocus"
        ]
    },
    {
        "q": "The _____ directive from CDK highlights focused elements.",
        "type": "fill_blank",
        "answers": [
            "cdkFocusInitial"
        ],
        "other_options": [
            "cdkFocusHighlight",
            "cdkFocusRing",
            "cdkFocusShow"
        ]
    },
    {
        "q": "What is live announcer service?",
        "type": "mcq",
        "o": [
            "Announces messages to screen readers using aria-live",
            "Audio player",
            "Speech synthesizer",
            "Notification service"
        ]
    },
    {
        "q": "LiveAnnouncer is from @angular/cdk/a11y.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the CDK directives library?",
        "type": "mcq",
        "o": [
            "Component Dev Kit providing behavior primitives",
            "Custom directives",
            "Core directives",
            "Common directives"
        ]
    },
    {
        "q": "Match the CDK modules:",
        "type": "match",
        "left": [
            "a11y",
            "drag-drop",
            "overlay",
            "scrolling"
        ],
        "right": [
            "Accessibility",
            "Drag and drop",
            "Popups/dialogs",
            "Virtual scroll"
        ]
    },
    {
        "q": "What is cdkDrag directive?",
        "type": "mcq",
        "o": [
            "Makes elements draggable with mouse or touch",
            "Drag event",
            "Move handler",
            "Position changer"
        ]
    },
    {
        "q": "cdkDropList creates a drop zone for cdkDrag items.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this CDK code do?",
        "type": "mcq",
        "c": "<div cdkDrag cdkDragBoundary=\".container\">Drag me</div>",
        "o": [
            "Creates draggable element constrained to container",
            "Creates container",
            "Logs drag",
            "Deletes element"
        ]
    },
    {
        "q": "The _____ directive constrains drag boundaries.",
        "type": "fill_blank",
        "answers": [
            "cdkDragBoundary"
        ],
        "other_options": [
            "cdkDragLimit",
            "cdkDragArea",
            "cdkDragZone"
        ]
    },
    {
        "q": "What is cdkScrollable?",
        "type": "mcq",
        "o": [
            "Makes an element a scroll container for virtual scrolling",
            "Scroll handler",
            "Scroll event",
            "Scroll listener"
        ]
    },
    {
        "q": "cdkVirtualScrollViewport enables virtual scrolling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is virtual scrolling?",
        "type": "mcq",
        "o": [
            "Rendering only visible items in long lists",
            "Smooth scrolling",
            "Fast scrolling",
            "Auto scrolling"
        ]
    },
    {
        "q": "Match the CDK scroll directives:",
        "type": "match",
        "left": [
            "cdkVirtualScrollViewport",
            "cdkVirtualFor",
            "cdkScrollable"
        ],
        "right": [
            "Viewport container",
            "Item template",
            "Scroll container"
        ]
    },
    {
        "q": "What is cdkOverlay?",
        "type": "mcq",
        "o": [
            "Creates floating panels like tooltips and menus",
            "Background overlay",
            "Cover element",
            "Layer creator"
        ]
    },
    {
        "q": "cdkConnectedOverlay attaches overlays to trigger elements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is cdkPortal?",
        "type": "mcq",
        "o": [
            "Attaches content to a portal outlet elsewhere in DOM",
            "Entry point",
            "Link creator",
            "Navigation"
        ]
    },
    {
        "q": "The _____ directive defines where portal content appears.",
        "type": "fill_blank",
        "answers": [
            "cdkPortalOutlet"
        ],
        "other_options": [
            "cdkPortalHost",
            "cdkPortalTarget",
            "cdkPortalContainer"
        ]
    },
    {
        "q": "What is directive testing with fakeAsync?",
        "type": "mcq",
        "o": [
            "Testing async code synchronously using fake timers",
            "Fast testing",
            "Async mocking",
            "Time simulation"
        ]
    },
    {
        "q": "fakeAsync zone controls time with tick().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does tick() do in fakeAsync?",
        "type": "mcq",
        "o": [
            "Simulates passage of time and executes async callbacks",
            "Creates timer",
            "Logs time",
            "Resets time"
        ]
    },
    {
        "q": "Match the async testing utilities:",
        "type": "match",
        "left": [
            "fakeAsync",
            "tick",
            "flush",
            "flushMicrotasks"
        ],
        "right": [
            "Fake zone",
            "Advance time",
            "Drain macrotasks",
            "Drain microtasks"
        ]
    },
    {
        "q": "What is flush() in fakeAsync?",
        "type": "mcq",
        "o": [
            "Executes all pending timers",
            "Clears queue",
            "Resets state",
            "Removes tasks"
        ]
    },
    {
        "q": "flushMicrotasks drains Promise callbacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is discardPeriodicTasks()?",
        "type": "mcq",
        "o": [
            "Cleans up setInterval tasks in fakeAsync",
            "Removes tasks",
            "Stops timers",
            "Clears queue"
        ]
    },
    {
        "q": "The _____ utility advances time and drains async queue.",
        "type": "fill_blank",
        "answers": [
            "tick"
        ],
        "other_options": [
            "advance",
            "wait",
            "proceed"
        ]
    },
    {
        "q": "What is directive testing with waitForAsync?",
        "type": "mcq",
        "o": [
            "Runs test in special zone that tracks async operations",
            "Async test",
            "Wait function",
            "Delay test"
        ]
    },
    {
        "q": "waitForAsync waits for all async operations to complete.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is fixture.whenStable()?",
        "type": "mcq",
        "o": [
            "Waits for all async operations in the fixture to complete",
            "Stability check",
            "Ready handler",
            "Completion event"
        ]
    },
    {
        "q": "Match the test async patterns:",
        "type": "match",
        "left": [
            "fakeAsync",
            "waitForAsync",
            "done callback",
            "async/await"
        ],
        "right": [
            "Fake time",
            "Zone tracking",
            "Manual completion",
            "Native async"
        ]
    },
    {
        "q": "What is triggerEventHandler in testing?",
        "type": "mcq",
        "o": [
            "Triggers events on DebugElement for testing",
            "Event creator",
            "Handler runner",
            "Event logger"
        ]
    },
    {
        "q": "triggerEventHandler simulates DOM events for directives.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this test code do?",
        "type": "mcq",
        "c": "debugElement.triggerEventHandler('click', { button: 0 });",
        "o": [
            "Simulates a left click event on the element",
            "Creates click",
            "Logs click",
            "Prevents click"
        ]
    },
    {
        "q": "The _____ method triggers events on DebugElement.",
        "type": "fill_blank",
        "answers": [
            "triggerEventHandler"
        ],
        "other_options": [
            "trigger",
            "emit",
            "dispatch"
        ]
    },
    {
        "q": "What is directive mocking in tests?",
        "type": "mcq",
        "o": [
            "Creating fake directive implementations for testing",
            "Mock data",
            "Fake values",
            "Test doubles"
        ]
    },
    {
        "q": "MockNgModuleResolver helps mock directives in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is MockDirective from ng-mocks?",
        "type": "mcq",
        "o": [
            "Creates a mock version of a directive automatically",
            "Directive creator",
            "Test directive",
            "Fake directive"
        ]
    },
    {
        "q": "Match the mocking strategies:",
        "type": "match",
        "left": [
            "MockDirective",
            "MockComponent",
            "MockPipe",
            "provideMock"
        ],
        "right": [
            "Mock directive",
            "Mock component",
            "Mock pipe",
            "Mock service"
        ]
    },
    {
        "q": "What is overrideDirective in TestBed?",
        "type": "mcq",
        "o": [
            "Replaces a directive's metadata for testing",
            "Override method",
            "Replace directive",
            "Swap directive"
        ]
    },
    {
        "q": "overrideDirective can replace providers in directive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is animation directive in Angular?",
        "type": "mcq",
        "o": [
            "Directive that triggers or controls Angular animations",
            "Visual effect",
            "Motion handler",
            "Transition director"
        ]
    },
    {
        "q": "The _____ decorator defines animation triggers.",
        "type": "fill_blank",
        "answers": [
            "trigger"
        ],
        "other_options": [
            "animation",
            "animate",
            "motion"
        ]
    },
    {
        "q": "What is @trigger in animations?",
        "type": "mcq",
        "o": [
            "Defines an animation that can be attached to elements",
            "Event trigger",
            "Start animation",
            "Animation name"
        ]
    },
    {
        "q": "Animation triggers use [@triggerName] binding syntax.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What are animation states?",
        "type": "mcq",
        "o": [
            "Named positions with specific styles that define animation endpoints",
            "State machine",
            "Animation steps",
            "Style states"
        ]
    },
    {
        "q": "Match the animation functions:",
        "type": "match",
        "left": [
            "trigger",
            "state",
            "transition",
            "animate"
        ],
        "right": [
            "Define trigger",
            "Define state",
            "Define change",
            "Define timing"
        ]
    },
    {
        "q": "What is transition() in animations?",
        "type": "mcq",
        "o": [
            "Defines how to animate between states",
            "State change",
            "Movement",
            "Transformation"
        ]
    },
    {
        "q": "transition(':enter') is alias for void => *.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is :leave alias in transitions?",
        "type": "mcq",
        "o": [
            "Alias for * => void, element being removed",
            "Exit point",
            "End state",
            "Final state"
        ]
    },
    {
        "q": "The _____ state represents element not in DOM.",
        "type": "fill_blank",
        "answers": [
            "void"
        ],
        "other_options": [
            "null",
            "none",
            "empty"
        ]
    },
    {
        "q": "What is query() in animations?",
        "type": "mcq",
        "o": [
            "Selects child elements to animate",
            "Find element",
            "Search DOM",
            "Get children"
        ]
    },
    {
        "q": "stagger() creates delay between child animations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this animation do?",
        "type": "mcq",
        "c": "query(':enter', stagger(100, animate('300ms ease-out')))",
        "o": [
            "Animates each entering child with 100ms delay between them",
            "Single animation",
            "Removes elements",
            "Stops animation"
        ]
    },
    {
        "q": "Match the animation query selectors:",
        "type": "match",
        "left": [
            ":enter",
            ":leave",
            ":self",
            "@*"
        ],
        "right": [
            "Entering elements",
            "Leaving elements",
            "Host element",
            "All triggers"
        ]
    },
    {
        "q": "What is group() in animations?",
        "type": "mcq",
        "o": [
            "Runs multiple animations in parallel",
            "Create group",
            "Combine elements",
            "Merge states"
        ]
    },
    {
        "q": "sequence() runs animations one after another.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is keyframes() in animations?",
        "type": "mcq",
        "o": [
            "Defines intermediate styles during animation",
            "Video frames",
            "Time markers",
            "Style array"
        ]
    },
    {
        "q": "The _____ function defines animation steps with timing.",
        "type": "fill_blank",
        "answers": [
            "keyframes"
        ],
        "other_options": [
            "steps",
            "frames",
            "phases"
        ]
    },
    {
        "q": "What is animation callback?",
        "type": "mcq",
        "c": "(@myTrigger.start)=\"onAnimStart($event)\"",
        "o": [
            "Event fired when animation starts or completes",
            "Callback function",
            "Animation handler",
            "Event logger"
        ]
    },
    {
        "q": ".done callback fires when animation completes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is AnimationBuilder service?",
        "type": "mcq",
        "o": [
            "Programmatically creates and runs animations",
            "Animation factory",
            "Builder pattern",
            "Animation creator"
        ]
    },
    {
        "q": "Match the animation services:",
        "type": "match",
        "left": [
            "AnimationBuilder",
            "AnimationPlayer",
            "AnimationFactory"
        ],
        "right": [
            "Create animations",
            "Control playback",
            "Animation template"
        ]
    },
    {
        "q": "What is useAnimation() function?",
        "type": "mcq",
        "o": [
            "Reuses a predefined animation",
            "Apply animation",
            "Start animation",
            "Import animation"
        ]
    },
    {
        "q": "animation() creates reusable animation definitions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is directive with zoneless Angular?",
        "type": "mcq",
        "o": [
            "Directive working without Zone.js using signal-based change detection",
            "No zone directive",
            "External directive",
            "Isolated directive"
        ]
    },
    {
        "q": "The _____ API enables zoneless change detection.",
        "type": "fill_blank",
        "answers": [
            "Signals"
        ],
        "other_options": [
            "Zone",
            "ChangeDetector",
            "Scheduler"
        ]
    },
    {
        "q": "What is provideExperimentalZonelessChangeDetection?",
        "type": "mcq",
        "o": [
            "Enables zoneless mode for entire application",
            "Zone config",
            "Detection provider",
            "Experimental mode"
        ]
    },
    {
        "q": "Zoneless mode improves performance by removing Zone.js overhead.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ChangeDetectionScheduler in zoneless mode?",
        "type": "mcq",
        "o": [
            "Schedules change detection updates based on signal changes",
            "Time scheduler",
            "Task scheduler",
            "Event scheduler"
        ]
    },
    {
        "q": "Match the zoneless concepts:",
        "type": "match",
        "left": [
            "Signals",
            "Zoneless",
            "Local change detection",
            "markForCheck"
        ],
        "right": [
            "Reactive values",
            "No Zone.js",
            "Check only affected",
            "Queue check"
        ]
    },
    {
        "q": "What is linkedSignal()?",
        "type": "mcq",
        "o": [
            "Creates a writable signal derived from another signal",
            "Signal link",
            "Connection",
            "Signal chain"
        ]
    },
    {
        "q": "linkedSignal combines features of computed and writable signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this linkedSignal do?",
        "type": "mcq",
        "c": "options = signal(['a', 'b', 'c']);\nselected = linkedSignal(() => this.options()[0]);",
        "o": [
            "Creates writable signal linked to first option",
            "Links arrays",
            "Copies signal",
            "Creates computed"
        ]
    },
    {
        "q": "The _____ function creates a resettable derived signal.",
        "type": "fill_blank",
        "answers": [
            "linkedSignal"
        ],
        "other_options": [
            "derivedSignal",
            "chainedSignal",
            "boundSignal"
        ]
    },
    {
        "q": "What is resource() API?",
        "type": "mcq",
        "o": [
            "Signal-based async data fetching with loading states",
            "Resource loader",
            "Data fetcher",
            "API client"
        ]
    },
    {
        "q": "resource() provides value, loading, and error signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this resource do?",
        "type": "mcq",
        "c": "user = resource({\n  request: () => this.userId(),\n  loader: ({request}) => fetch(`/api/users/${request}`)\n});",
        "o": [
            "Fetches user data reactively when userId changes",
            "Creates resource",
            "Logs user",
            "Caches data"
        ]
    },
    {
        "q": "Match the resource properties:",
        "type": "match",
        "left": [
            "value",
            "isLoading",
            "error",
            "reload"
        ],
        "right": [
            "Data signal",
            "Loading state",
            "Error state",
            "Refresh function"
        ]
    },
    {
        "q": "What is toSignal()?",
        "type": "mcq",
        "o": [
            "Converts an Observable to a Signal",
            "Signal creator",
            "Observable wrapper",
            "Conversion function"
        ]
    },
    {
        "q": "toSignal requires initial value or requireSync option.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this toSignal do?",
        "type": "mcq",
        "c": "currentTime = toSignal(interval(1000), { initialValue: 0 });",
        "o": [
            "Converts interval Observable to Signal with initial value 0",
            "Creates timer",
            "Logs time",
            "Stops interval"
        ]
    },
    {
        "q": "The _____ function converts Signal to Observable.",
        "type": "fill_blank",
        "answers": [
            "toObservable"
        ],
        "other_options": [
            "asObservable",
            "toRx",
            "observableFrom"
        ]
    },
    {
        "q": "What is toObservable()?",
        "type": "mcq",
        "o": [
            "Converts a Signal to an Observable stream",
            "Observable creator",
            "Signal wrapper",
            "Stream converter"
        ]
    },
    {
        "q": "toObservable emits whenever the signal value changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is outputFromObservable()?",
        "type": "mcq",
        "o": [
            "Creates an output from Observable emissions",
            "Observable output",
            "Stream output",
            "Emit handler"
        ]
    },
    {
        "q": "Match the RxJS interop functions:",
        "type": "match",
        "left": [
            "toSignal",
            "toObservable",
            "outputFromObservable",
            "outputToObservable"
        ],
        "right": [
            "Obs to Signal",
            "Signal to Obs",
            "Obs to Output",
            "Output to Obs"
        ]
    },
    {
        "q": "What is directive security best practice?",
        "type": "mcq",
        "o": [
            "Sanitizing user input to prevent XSS attacks",
            "Access control",
            "Encryption",
            "Authentication"
        ]
    },
    {
        "q": "DomSanitizer prevents XSS in dynamic content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is DomSanitizer?",
        "type": "mcq",
        "o": [
            "Service that sanitizes values for safe DOM use",
            "DOM cleaner",
            "HTML validator",
            "Security checker"
        ]
    },
    {
        "q": "The _____ method bypasses security for trusted HTML.",
        "type": "fill_blank",
        "answers": [
            "bypassSecurityTrustHtml"
        ],
        "other_options": [
            "trustHtml",
            "allowHtml",
            "safeHtml"
        ]
    },
    {
        "q": "What security contexts does Angular sanitize?",
        "type": "mcq",
        "o": [
            "HTML, Style, Script, URL, and Resource URL",
            "Only HTML",
            "Only scripts",
            "All content"
        ]
    },
    {
        "q": "Match the sanitization contexts:",
        "type": "match",
        "left": [
            "SecurityContext.HTML",
            "SecurityContext.STYLE",
            "SecurityContext.URL",
            "SecurityContext.SCRIPT"
        ],
        "right": [
            "HTML content",
            "CSS styles",
            "Links",
            "Code execution"
        ]
    },
    {
        "q": "What is bypassSecurityTrustScript()?",
        "type": "mcq",
        "o": [
            "Marks a script as trusted for execution",
            "Script bypass",
            "Security skip",
            "Trust script"
        ]
    },
    {
        "q": "Bypass methods should be used carefully with trusted content only.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a debounce directive pattern?",
        "type": "mcq",
        "o": [
            "Directive that delays action until input stops for specified time",
            "Delay handler",
            "Timeout directive",
            "Wait pattern"
        ]
    },
    {
        "q": "The _____ operator delays emissions in RxJS.",
        "type": "fill_blank",
        "answers": [
            "debounceTime"
        ],
        "other_options": [
            "delay",
            "timeout",
            "wait"
        ]
    },
    {
        "q": "What is a throttle directive pattern?",
        "type": "mcq",
        "o": [
            "Directive that limits action frequency over time",
            "Speed limiter",
            "Rate controller",
            "Action pacer"
        ]
    },
    {
        "q": "throttleTime limits emissions to one per time window.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a click-outside directive?",
        "type": "mcq",
        "o": [
            "Directive that detects clicks outside an element",
            "External click",
            "Outside handler",
            "Click detector"
        ]
    },
    {
        "q": "Match the common directive patterns:",
        "type": "match",
        "left": [
            "Debounce",
            "Throttle",
            "Click-outside",
            "Lazy-load"
        ],
        "right": [
            "Wait after input",
            "Limit frequency",
            "Detect external",
            "Load on demand"
        ]
    },
    {
        "q": "What is a lazy load image directive?",
        "type": "mcq",
        "o": [
            "Directive that loads images when they enter viewport",
            "Slow loader",
            "Image delay",
            "Async image"
        ]
    },
    {
        "q": "IntersectionObserver enables efficient viewport detection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a resize directive?",
        "type": "mcq",
        "o": [
            "Directive that reacts to element size changes",
            "Size handler",
            "Dimension tracker",
            "Scale controller"
        ]
    },
    {
        "q": "The _____ API observes element size changes.",
        "type": "fill_blank",
        "answers": [
            "ResizeObserver"
        ],
        "other_options": [
            "SizeObserver",
            "DimensionObserver",
            "ElementObserver"
        ]
    },
    {
        "q": "What is an infinite scroll directive?",
        "type": "mcq",
        "o": [
            "Directive that loads more content when scrolling near bottom",
            "Endless list",
            "Scroll handler",
            "Load trigger"
        ]
    },
    {
        "q": "Match the browser APIs for directives:",
        "type": "match",
        "left": [
            "IntersectionObserver",
            "ResizeObserver",
            "MutationObserver",
            "PerformanceObserver"
        ],
        "right": [
            "Viewport detection",
            "Size changes",
            "DOM mutations",
            "Performance metrics"
        ]
    },
    {
        "q": "What is a permission directive?",
        "type": "mcq",
        "o": [
            "Directive that shows/hides elements based on user permissions",
            "Access control",
            "Auth directive",
            "Role directive"
        ]
    },
    {
        "q": "Permission directives often use structural directive pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this permission code do?",
        "type": "mcq",
        "c": "<button *appHasRole=\"'admin'\">Delete</button>",
        "o": [
            "Shows button only for users with admin role",
            "Creates admin",
            "Logs role",
            "Validates user"
        ]
    },
    {
        "q": "The _____ pattern controls element visibility by permission.",
        "type": "fill_blank",
        "answers": [
            "structural directive"
        ],
        "other_options": [
            "attribute directive",
            "component",
            "pipe"
        ]
    },
    {
        "q": "What is a feature flag directive?",
        "type": "mcq",
        "o": [
            "Directive showing content based on feature toggles",
            "Flag handler",
            "Toggle controller",
            "Feature switch"
        ]
    },
    {
        "q": "Feature flags enable gradual feature rollouts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange the directive testing workflow:",
        "type": "rearrange",
        "words": [
            "Create host component",
            "Configure TestBed",
            "Create fixture",
            "Query element",
            "Assert behavior"
        ]
    },
    {
        "q": "Rearrange the custom structural directive creation:",
        "type": "rearrange",
        "words": [
            "Create class",
            "Inject TemplateRef",
            "Inject ViewContainerRef",
            "Add input property",
            "Create/clear view"
        ]
    },
    {
        "q": "What is micro-frontend integration with directives?",
        "type": "mcq",
        "o": [
            "Using directives to integrate independently deployed Angular apps",
            "Small directives",
            "Frontend merge",
            "App integration"
        ]
    },
    {
        "q": "Module federation enables sharing directives between micro-frontends.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange the signal-based directive evolution:",
        "type": "rearrange",
        "words": [
            "@Input decorator",
            "input() function",
            "computed()",
            "effect()",
            "Signal queries"
        ]
    },
    {
        "q": "What is Angular Material component library?",
        "type": "mcq",
        "o": [
            "Official Material Design UI component library for Angular",
            "Custom components",
            "Third-party library",
            "CSS framework"
        ]
    },
    {
        "q": "Angular Material provides directives alongside its components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is mat-prefix directive?",
        "type": "mcq",
        "o": [
            "Adds prefix content to form fields",
            "CSS prefix",
            "Class prefix",
            "Name prefix"
        ]
    },
    {
        "q": "The _____ directive adds suffix content to Angular Material form fields.",
        "type": "fill_blank",
        "answers": [
            "mat-suffix"
        ],
        "other_options": [
            "matSuffix",
            "mat-after",
            "matEnd"
        ]
    },
    {
        "q": "What is matInput directive?",
        "type": "mcq",
        "o": [
            "Applies Material styling to native input elements",
            "Creates input",
            "Input validator",
            "Form control"
        ]
    },
    {
        "q": "matInput works with mat-form-field wrapper component.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is matRipple directive?",
        "type": "mcq",
        "o": [
            "Adds Material ripple effect on click",
            "Wave animation",
            "Water effect",
            "Click handler"
        ]
    },
    {
        "q": "Match the Angular Material directives:",
        "type": "match",
        "left": [
            "matInput",
            "matRipple",
            "matTooltip",
            "matBadge"
        ],
        "right": [
            "Form input",
            "Click effect",
            "Hover info",
            "Notification badge"
        ]
    },
    {
        "q": "What is matTooltip directive?",
        "type": "mcq",
        "o": [
            "Shows a tooltip on hover",
            "Tool menu",
            "Tip text",
            "Help popup"
        ]
    },
    {
        "q": "matBadge directive adds notification badges to elements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is i18n attribute directive?",
        "type": "mcq",
        "o": [
            "Marks text for internationalization extraction",
            "Language setting",
            "Translation",
            "Locale config"
        ]
    },
    {
        "q": "The _____ attribute marks elements for Angular i18n translation.",
        "type": "fill_blank",
        "answers": [
            "i18n"
        ],
        "other_options": [
            "translate",
            "lang",
            "locale"
        ]
    },
    {
        "q": "What does i18n-attribute syntax do?",
        "type": "mcq",
        "c": "i18n-placeholder",
        "o": [
            "Marks attributes for translation like placeholder",
            "Attribute naming",
            "Placeholder i18n",
            "Attribute prefix"
        ]
    },
    {
        "q": "i18n supports description and meaning metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is $localize template tag?",
        "type": "mcq",
        "o": [
            "Runtime localization in TypeScript code",
            "Locale getter",
            "Language tag",
            "Translation function"
        ]
    },
    {
        "q": "Match the i18n concepts:",
        "type": "match",
        "left": [
            "i18n attribute",
            "$localize",
            "XLIFF",
            "ICU expressions"
        ],
        "right": [
            "Template marking",
            "Code localization",
            "Translation format",
            "Pluralization"
        ]
    },
    {
        "q": "What are ICU expressions in Angular i18n?",
        "type": "mcq",
        "o": [
            "Internationalization format for pluralization and selection",
            "CU format",
            "International code",
            "Unicode expressions"
        ]
    },
    {
        "q": "ICU expressions handle plural forms like zero, one, few, many.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a memory leak prevention in directives?",
        "type": "mcq",
        "o": [
            "Properly cleaning up subscriptions and event listeners on destroy",
            "Memory clearing",
            "Garbage collection",
            "Cache clearing"
        ]
    },
    {
        "q": "The _____ hook is essential for cleanup in directives.",
        "type": "fill_blank",
        "answers": [
            "ngOnDestroy"
        ],
        "other_options": [
            "ngOnInit",
            "ngCleanup",
            "ngDispose"
        ]
    },
    {
        "q": "What causes memory leaks in directives?",
        "type": "mcq",
        "o": [
            "Unsubscribed Observables and unremoved event listeners",
            "Too much data",
            "Large templates",
            "Heavy computations"
        ]
    },
    {
        "q": "Match the leak prevention patterns:",
        "type": "match",
        "left": [
            "takeUntilDestroyed",
            "async pipe",
            "ngOnDestroy",
            "DestroyRef"
        ],
        "right": [
            "Auto unsubscribe operator",
            "Template subscription",
            "Lifecycle cleanup",
            "Inject cleanup"
        ]
    },
    {
        "q": "What is Subject-based unsubscription pattern?",
        "type": "mcq",
        "c": "destroy$ = new Subject<void>();\nngOnDestroy() { this.destroy$.next(); }",
        "o": [
            "Using Subject to complete subscriptions on destroy",
            "Subject cleanup",
            "Event pattern",
            "Observer pattern"
        ]
    },
    {
        "q": "takeUntil(this.destroy$) completes observables on directive destroy.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is lazy initialization in directives?",
        "type": "mcq",
        "o": [
            "Delaying expensive operations until needed",
            "Slow loading",
            "Late binding",
            "Delayed rendering"
        ]
    },
    {
        "q": "The _____ pattern delays initialization until first use.",
        "type": "fill_blank",
        "answers": [
            "lazy"
        ],
        "other_options": [
            "deferred",
            "delayed",
            "late"
        ]
    },
    {
        "q": "What is memoization in directive patterns?",
        "type": "mcq",
        "o": [
            "Caching computed values to avoid recalculation",
            "Memory allocation",
            "Value storage",
            "State saving"
        ]
    },
    {
        "q": "Memoization improves performance for expensive computations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a pure pipe vs directive for data transformation?",
        "type": "mcq",
        "o": [
            "Pipes transform data; directives manipulate DOM behaviors",
            "They are the same",
            "Pipes are faster",
            "Directives transform data"
        ]
    },
    {
        "q": "Match the transformation approaches:",
        "type": "match",
        "left": [
            "Pure pipe",
            "Impure pipe",
            "Directive",
            "Computed signal"
        ],
        "right": [
            "Cached transform",
            "Every check",
            "DOM behavior",
            "Reactive value"
        ]
    },
    {
        "q": "What is RxJS fromEvent with directives?",
        "type": "mcq",
        "o": [
            "Creates Observable from DOM events on host element",
            "Event creator",
            "Event handler",
            "Observable event"
        ]
    },
    {
        "q": "fromEvent enables reactive event handling in directives.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this fromEvent code do?",
        "type": "mcq",
        "c": "fromEvent(this.el.nativeElement, 'scroll').pipe(\n  throttleTime(100)\n).subscribe()",
        "o": [
            "Creates throttled scroll event Observable",
            "Scrolls element",
            "Logs scroll",
            "Stops scrolling"
        ]
    },
    {
        "q": "The _____ operator samples events at regular intervals.",
        "type": "fill_blank",
        "answers": [
            "throttleTime"
        ],
        "other_options": [
            "debounceTime",
            "sampleTime",
            "interval"
        ]
    },
    {
        "q": "What is combineLatest with directive observables?",
        "type": "mcq",
        "o": [
            "Combines multiple observables emitting when any changes",
            "Combine arrays",
            "Latest value",
            "Observable merge"
        ]
    },
    {
        "q": "combineLatest waits for all sources to emit before first emission.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is merge for directive event streams?",
        "type": "mcq",
        "o": [
            "Combines multiple event streams into single output",
            "Merge arrays",
            "Join data",
            "Combine values"
        ]
    },
    {
        "q": "Match the RxJS combination operators:",
        "type": "match",
        "left": [
            "merge",
            "combineLatest",
            "forkJoin",
            "withLatestFrom"
        ],
        "right": [
            "Interleave",
            "Latest each",
            "Complete all",
            "Sample with"
        ]
    },
    {
        "q": "What is switchMap in directive async operations?",
        "type": "mcq",
        "o": [
            "Cancels previous inner observable and switches to new one",
            "Switch values",
            "Map change",
            "Observable switch"
        ]
    },
    {
        "q": "switchMap is useful for search-as-you-type patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is exhaustMap for directive events?",
        "type": "mcq",
        "o": [
            "Ignores new source values until inner observable completes",
            "Exhaust resources",
            "Complete all",
            "Map fully"
        ]
    },
    {
        "q": "The _____ operator ignores emissions during active subscription.",
        "type": "fill_blank",
        "answers": [
            "exhaustMap"
        ],
        "other_options": [
            "switchMap",
            "mergeMap",
            "concatMap"
        ]
    },
    {
        "q": "What is distinctUntilChanged in directives?",
        "type": "mcq",
        "o": [
            "Filters consecutive duplicate emissions",
            "Unique values",
            "Distinct filter",
            "Change detector"
        ]
    },
    {
        "q": "distinctUntilChanged prevents redundant processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is shareReplay for directive observables?",
        "type": "mcq",
        "o": [
            "Shares observable and replays last emissions to new subscribers",
            "Share data",
            "Replay events",
            "Cache observable"
        ]
    },
    {
        "q": "Match the RxJS multicasting operators:",
        "type": "match",
        "left": [
            "share",
            "shareReplay",
            "publish",
            "multicast"
        ],
        "right": [
            "Hot observable",
            "Replay cached",
            "Manual connect",
            "Subject multicast"
        ]
    },
    {
        "q": "What is startWith for directive initial values?",
        "type": "mcq",
        "o": [
            "Emits specified value before other emissions",
            "Start observable",
            "First value",
            "Init value"
        ]
    },
    {
        "q": "startWith provides initial values for templates using async pipe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is scan operator for directive state?",
        "type": "mcq",
        "o": [
            "Accumulates values over time like reduce",
            "Scan data",
            "Search values",
            "Find items"
        ]
    },
    {
        "q": "The _____ operator accumulates values emitting each intermediate result.",
        "type": "fill_blank",
        "answers": [
            "scan"
        ],
        "other_options": [
            "reduce",
            "accumulate",
            "collect"
        ]
    },
    {
        "q": "What is pairwise for directive comparisons?",
        "type": "mcq",
        "o": [
            "Emits previous and current values as pair",
            "Pair data",
            "Two values",
            "Compare values"
        ]
    },
    {
        "q": "pairwise is useful for comparing before/after values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is catchError in directive error handling?",
        "type": "mcq",
        "o": [
            "Catches errors and returns alternative observable",
            "Error catch",
            "Handle error",
            "Error handler"
        ]
    },
    {
        "q": "Match the RxJS error operators:",
        "type": "match",
        "left": [
            "catchError",
            "retry",
            "retryWhen",
            "throwError"
        ],
        "right": [
            "Handle error",
            "Auto retry",
            "Conditional retry",
            "Emit error"
        ]
    },
    {
        "q": "What is retry operator for directive resilience?",
        "type": "mcq",
        "o": [
            "Resubscribes to source on error up to specified times",
            "Retry logic",
            "Repeat action",
            "Try again"
        ]
    },
    {
        "q": "retry(3) attempts operation up to 3 times on failure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is finalize operator for directive cleanup?",
        "type": "mcq",
        "o": [
            "Executes callback on complete or error",
            "Final value",
            "End callback",
            "Completion handler"
        ]
    },
    {
        "q": "The _____ operator runs cleanup regardless of success or error.",
        "type": "fill_blank",
        "answers": [
            "finalize"
        ],
        "other_options": [
            "complete",
            "finally",
            "end"
        ]
    },
    {
        "q": "What is a template variable with directive exportAs?",
        "type": "mcq",
        "o": [
            "Accessing directive instance methods from template",
            "Variable export",
            "Template binding",
            "Instance reference"
        ]
    },
    {
        "q": "exportAs enables template interaction with directive methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does this exportAs code do?",
        "type": "mcq",
        "c": "<input appValidator #validator=\"appValidator\">\n<span>{{ validator.errors }}</span>",
        "o": [
            "Exposes validator directive to display errors",
            "Creates validator",
            "Exports input",
            "Logs errors"
        ]
    },
    {
        "q": "Match the template reference patterns:",
        "type": "match",
        "left": [
            "#ref",
            "#ref='directive'",
            "ViewChild",
            "@ViewChild"
        ],
        "right": [
            "Element reference",
            "Directive instance",
            "Query element",
            "Decorator query"
        ]
    },
    {
        "q": "What is a directive factory pattern?",
        "type": "mcq",
        "o": [
            "Dynamically creating directives with configuration",
            "Factory method",
            "Directive builder",
            "Create pattern"
        ]
    },
    {
        "q": "Directive factories allow runtime configuration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive with optional dependencies?",
        "type": "mcq",
        "c": "@Optional() @Inject(CONFIG) config: Config | null",
        "o": [
            "Directive that works with or without the dependency",
            "Required dependency",
            "Optional feature",
            "Nullable config"
        ]
    },
    {
        "q": "The _____ decorator makes dependencies optional.",
        "type": "fill_blank",
        "answers": [
            "@Optional"
        ],
        "other_options": [
            "@Nullable",
            "@Maybe",
            "@Default"
        ]
    },
    {
        "q": "What is @Self in directive injection?",
        "type": "mcq",
        "o": [
            "Only looks for dependency on the element itself",
            "Self reference",
            "Current element",
            "This instance"
        ]
    },
    {
        "q": "@SkipSelf skips the current element when looking for dependency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is @Host in directive injection?",
        "type": "mcq",
        "o": [
            "Limits dependency search to host element and above",
            "Host element",
            "Parent host",
            "Element host"
        ]
    },
    {
        "q": "Match the injection modifiers:",
        "type": "match",
        "left": [
            "@Self",
            "@SkipSelf",
            "@Host",
            "@Optional"
        ],
        "right": [
            "This element only",
            "Skip this element",
            "Up to host",
            "May not exist"
        ]
    },
    {
        "q": "What is a multi-provider pattern in directives?",
        "type": "mcq",
        "c": "{ provide: VALIDATORS, useExisting: MyDirective, multi: true }",
        "o": [
            "Registering multiple values for same token",
            "Multiple providers",
            "Multi registration",
            "Many services"
        ]
    },
    {
        "q": "multi: true allows collecting multiple directive contributions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is useExisting in directive providers?",
        "type": "mcq",
        "o": [
            "Uses an existing instance from the injector",
            "Create existing",
            "Existing value",
            "Current instance"
        ]
    },
    {
        "q": "The _____ provider option creates an alias to existing service.",
        "type": "fill_blank",
        "answers": [
            "useExisting"
        ],
        "other_options": [
            "useClass",
            "useValue",
            "useFactory"
        ]
    },
    {
        "q": "What is useFactory for directive providers?",
        "type": "mcq",
        "o": [
            "Creates dependency using a factory function",
            "Factory pattern",
            "Create function",
            "Build service"
        ]
    },
    {
        "q": "useFactory can inject dependencies for factory creation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is InjectionToken for directive configuration?",
        "type": "mcq",
        "o": [
            "Type-safe token for non-class dependencies",
            "Inject token",
            "Type token",
            "DI token"
        ]
    },
    {
        "q": "Match the provider options:",
        "type": "match",
        "left": [
            "useClass",
            "useValue",
            "useFactory",
            "useExisting"
        ],
        "right": [
            "New instance",
            "Static value",
            "Factory function",
            "Alias token"
        ]
    },
    {
        "q": "What is directive scope in Angular?",
        "type": "mcq",
        "o": [
            "Where the directive instance and its dependencies are available",
            "Variable scope",
            "Template scope",
            "CSS scope"
        ]
    },
    {
        "q": "Directives can have their own providers for scoped services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a scoped directive instance?",
        "type": "mcq",
        "c": "@Directive({ providers: [CounterService] })",
        "o": [
            "Each directive instance gets its own service instance",
            "Shared service",
            "Global service",
            "Single instance"
        ]
    },
    {
        "q": "The _____ metadata creates scoped service instances.",
        "type": "fill_blank",
        "answers": [
            "providers"
        ],
        "other_options": [
            "services",
            "inject",
            "uses"
        ]
    },
    {
        "q": "What is a directive with viewProviders?",
        "type": "mcq",
        "o": [
            "Provides dependencies only for view children, not content",
            "View services",
            "Child providers",
            "Local services"
        ]
    },
    {
        "q": "viewProviders hides dependencies from projected content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the difference between providers and viewProviders?",
        "type": "mcq",
        "o": [
            "providers includes content children; viewProviders excludes them",
            "They are the same",
            "viewProviders is faster",
            "providers is deprecated"
        ]
    },
    {
        "q": "Match the provider scopes:",
        "type": "match",
        "left": [
            "root",
            "component",
            "directive",
            "module"
        ],
        "right": [
            "App singleton",
            "Component tree",
            "Directive instance",
            "Module scope"
        ]
    },
    {
        "q": "What is a directive with inputs alias?",
        "type": "mcq",
        "c": "@Input('highlight-color') color: string;",
        "o": [
            "External name differs from internal property name",
            "Input rename",
            "Property alias",
            "Binding name"
        ]
    },
    {
        "q": "Input alias allows public API to differ from internal names.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive with required input?",
        "type": "mcq",
        "c": "@Input({ required: true }) id!: string;",
        "o": [
            "Input that must be provided by parent",
            "Mandatory value",
            "Required field",
            "Necessary input"
        ]
    },
    {
        "q": "The _____ option makes @Input mandatory.",
        "type": "fill_blank",
        "answers": [
            "required"
        ],
        "other_options": [
            "mandatory",
            "needed",
            "mustHave"
        ]
    },
    {
        "q": "What is a directive output alias?",
        "type": "mcq",
        "c": "@Output('changeColor') colorChange = new EventEmitter();",
        "o": [
            "External event name differs from internal property",
            "Output rename",
            "Event alias",
            "Emission name"
        ]
    },
    {
        "q": "Output alias enables public event names different from property names.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is two-way binding syntax for directives?",
        "type": "mcq",
        "c": "[(value)]=\"myValue\"",
        "o": [
            "Combines property binding and event binding",
            "Double binding",
            "Value sync",
            "Auto update"
        ]
    },
    {
        "q": "Match the binding patterns:",
        "type": "match",
        "left": [
            "[input]",
            "(output)",
            "[(twoway)]",
            "#ref"
        ],
        "right": [
            "Property binding",
            "Event binding",
            "Banana in box",
            "Template reference"
        ]
    },
    {
        "q": "What is the convention for two-way binding pairs?",
        "type": "mcq",
        "o": [
            "Property 'value' with event 'valueChange'",
            "value and onChange",
            "value and updated",
            "value and changed"
        ]
    },
    {
        "q": "model() signal API simplifies two-way binding implementation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a typed EventEmitter in directives?",
        "type": "mcq",
        "c": "@Output() clicked = new EventEmitter<MouseEvent>();",
        "o": [
            "Event emitter with specific event type",
            "Event type",
            "Typed event",
            "Generic emitter"
        ]
    },
    {
        "q": "The generic parameter in EventEmitter<T> defines payload type.",
        "type": "fill_blank",
        "answers": [
            "EventEmitter<T>"
        ],
        "other_options": [
            "EventEmitter()",
            "Emitter<T>",
            "Output<T>"
        ]
    },
    {
        "q": "What is a directive with async input handling?",
        "type": "mcq",
        "c": "@Input() set data(value: Observable<Data>) {\n  this.data$.next(value);\n}",
        "o": [
            "Handling observable inputs with internal subject",
            "Async input",
            "Stream input",
            "Observable binding"
        ]
    },
    {
        "q": "Async inputs can be handled with BehaviorSubject or switchMap.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngOnChanges for multiple input tracking?",
        "type": "mcq",
        "o": [
            "Called when any @Input changes with details of all changes",
            "Single change",
            "First change",
            "Last change"
        ]
    },
    {
        "q": "Match the SimpleChanges properties:",
        "type": "match",
        "left": [
            "currentValue",
            "previousValue",
            "firstChange",
            "isFirstChange()"
        ],
        "right": [
            "New value",
            "Old value",
            "Boolean flag",
            "Method check"
        ]
    },
    {
        "q": "What is directive host metadata alternative?",
        "type": "mcq",
        "c": "@Directive({ host: { '[class.active]': 'isActive' } })",
        "o": [
            "Defining host bindings in decorator metadata",
            "Host element",
            "Element host",
            "Host config"
        ]
    },
    {
        "q": "host property is an alternative to @HostBinding and @HostListener.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive ngDoCheck hook?",
        "type": "mcq",
        "o": [
            "Custom change detection logic for directive",
            "Do checking",
            "Check trigger",
            "Manual check"
        ]
    },
    {
        "q": "The _____ hook runs on every change detection cycle.",
        "type": "fill_blank",
        "answers": [
            "ngDoCheck"
        ],
        "other_options": [
            "ngOnChanges",
            "ngAfterCheck",
            "ngCheck"
        ]
    },
    {
        "q": "What is the order of directive lifecycle hooks?",
        "type": "mcq",
        "o": [
            "Constructor, ngOnChanges, ngOnInit, ngDoCheck, ngAfterContentInit...",
            "ngOnInit first",
            "Constructor last",
            "Random order"
        ]
    },
    {
        "q": "ngOnInit runs after first ngOnChanges.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngAfterContentInit for?",
        "type": "mcq",
        "o": [
            "Called after projected content is initialized",
            "After init",
            "Content ready",
            "Projection complete"
        ]
    },
    {
        "q": "Match the content vs view hooks:",
        "type": "match",
        "left": [
            "ngAfterContentInit",
            "ngAfterContentChecked",
            "ngAfterViewInit",
            "ngAfterViewChecked"
        ],
        "right": [
            "Content ready",
            "Content checked",
            "View ready",
            "View checked"
        ]
    },
    {
        "q": "What is directive with static query?",
        "type": "mcq",
        "c": "@ViewChild('elem', { static: true }) elem: ElementRef;",
        "o": [
            "Query resolved before ngOnInit instead of ngAfterViewInit",
            "Static element",
            "Fixed query",
            "Constant reference"
        ]
    },
    {
        "q": "static: true queries are available in ngOnInit.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the difference between static true and false?",
        "type": "mcq",
        "o": [
            "static: true resolves before ngOnInit; false waits for view",
            "They are the same",
            "true is faster",
            "false is accurate"
        ]
    },
    {
        "q": "The _____ option determines when query is resolved.",
        "type": "fill_blank",
        "answers": [
            "static"
        ],
        "other_options": [
            "timing",
            "resolve",
            "init"
        ]
    },
    {
        "q": "What is a directive query predicate?",
        "type": "mcq",
        "c": "@ViewChildren(ChildComponent) children: QueryList<ChildComponent>;",
        "o": [
            "Selector that determines what elements to query",
            "Query filter",
            "Element selector",
            "Search term"
        ]
    },
    {
        "q": "Query predicates can be component types, directive types, or template references.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is QueryList in directives?",
        "type": "mcq",
        "o": [
            "Live collection of query results that updates automatically",
            "Static list",
            "Query array",
            "Element list"
        ]
    },
    {
        "q": "Match the QueryList features:",
        "type": "match",
        "left": [
            "changes",
            "forEach",
            "first",
            "toArray"
        ],
        "right": [
            "Observable updates",
            "Iterate items",
            "First result",
            "Convert to array"
        ]
    },
    {
        "q": "What is QueryList.changes observable?",
        "type": "mcq",
        "o": [
            "Emits when query results change",
            "Change handler",
            "Update event",
            "Modification stream"
        ]
    },
    {
        "q": "QueryList.changes enables reacting to dynamic query changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a read option in queries?",
        "type": "mcq",
        "c": "@ViewChild('elem', { read: ElementRef }) elem: ElementRef;",
        "o": [
            "Specifies what token to read from the queried element",
            "Read mode",
            "Element type",
            "Token type"
        ]
    },
    {
        "q": "The _____ query option determines the injector token to retrieve.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "get",
            "type",
            "token"
        ]
    },
    {
        "q": "What tokens can read option retrieve?",
        "type": "mcq",
        "o": [
            "ElementRef, TemplateRef, ViewContainerRef, directive/component type",
            "Only ElementRef",
            "Only components",
            "Only templates"
        ]
    },
    {
        "q": "Match the read token types:",
        "type": "match",
        "left": [
            "ElementRef",
            "TemplateRef",
            "ViewContainerRef",
            "Component"
        ],
        "right": [
            "DOM element",
            "Template reference",
            "View container",
            "Component instance"
        ]
    },
    {
        "q": "What is descendants option in queries?",
        "type": "mcq",
        "c": "@ContentChildren(Child, { descendants: true }) children;",
        "o": [
            "Include nested children in query results",
            "Descendant filter",
            "Deep query",
            "Nested search"
        ]
    },
    {
        "q": "descendants: true includes nested elements in ContentChildren.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is structural directive desugaring?",
        "type": "mcq",
        "o": [
            "How Angular expands * syntax to ng-template",
            "Remove sugar",
            "Syntax expand",
            "Template convert"
        ]
    },
    {
        "q": "The _____ syntax is shorthand for ng-template with directive.",
        "type": "fill_blank",
        "answers": [
            "*"
        ],
        "other_options": [
            "#",
            "@",
            "&"
        ]
    },
    {
        "q": "What does *ngIf desugar to?",
        "type": "mcq",
        "c": "<ng-template [ngIf]=\"condition\"><element></element></ng-template>",
        "o": [
            "ng-template with [ngIf] binding containing the element",
            "div with ngIf",
            "span with condition",
            "container with if"
        ]
    },
    {
        "q": "Match the structural sugar expansion:",
        "type": "match",
        "left": [
            "*ngIf",
            "*ngFor",
            "*ngSwitch"
        ],
        "right": [
            "[ngIf]",
            "[ngForOf]",
            "[ngSwitch]"
        ]
    },
    {
        "q": "What is a custom structural directive input?",
        "type": "mcq",
        "c": "@Input() set appUnless(condition: boolean) {\n  if (!condition) this.vcRef.createEmbeddedView(this.templateRef);\n}",
        "o": [
            "Input setter that controls view creation",
            "Custom input",
            "Unless logic",
            "Condition handler"
        ]
    },
    {
        "q": "Structural directive inputs react to condition changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a structural directive with context?",
        "type": "mcq",
        "c": "this.vcRef.createEmbeddedView(this.templateRef, { $implicit: value });",
        "o": [
            "Passing data to template via context object",
            "Context creation",
            "Value passing",
            "Data binding"
        ]
    },
    {
        "q": "The _____ property provides default value in template context.",
        "type": "fill_blank",
        "answers": [
            "$implicit"
        ],
        "other_options": [
            "$default",
            "$value",
            "$data"
        ]
    },
    {
        "q": "What is let-variable in templates?",
        "type": "mcq",
        "c": "<ng-template let-item let-i=\"index\">",
        "o": [
            "Declares template input variable from context",
            "Variable declaration",
            "Local variable",
            "Template constant"
        ]
    },
    {
        "q": "let-item without assignment gets the $implicit context value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive with conditional rendering?",
        "type": "mcq",
        "o": [
            "Directive that shows/hides content based on conditions",
            "Condition check",
            "If logic",
            "Show/hide"
        ]
    },
    {
        "q": "Match the conditional patterns:",
        "type": "match",
        "left": [
            "*ngIf",
            "[hidden]",
            "ngClass",
            "@if"
        ],
        "right": [
            "DOM manipulation",
            "CSS hide",
            "Class toggle",
            "New control flow"
        ]
    },
    {
        "q": "What is directive coercion for inputs?",
        "type": "mcq",
        "o": [
            "Automatically converting input values to expected types",
            "Type forcing",
            "Value conversion",
            "Input transform"
        ]
    },
    {
        "q": "booleanAttribute coerces empty string '' to true.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is custom input transform function?",
        "type": "mcq",
        "c": "@Input({ transform: (v: string) => v.toUpperCase() }) name: string;",
        "o": [
            "Custom function to transform input values",
            "Transform pipe",
            "Value converter",
            "Input modifier"
        ]
    },
    {
        "q": "The _____ input option applies custom transformation.",
        "type": "fill_blank",
        "answers": [
            "transform"
        ],
        "other_options": [
            "convert",
            "map",
            "modify"
        ]
    },
    {
        "q": "Rearrange the structural directive implementation:",
        "type": "rearrange",
        "words": [
            "Inject TemplateRef",
            "Inject ViewContainerRef",
            "Create @Input setter",
            "Check condition",
            "createEmbeddedView or clear"
        ]
    },
    {
        "q": "Rearrange the form control directive steps:",
        "type": "rearrange",
        "words": [
            "Implement ControlValueAccessor",
            "Add NG_VALUE_ACCESSOR provider",
            "Implement writeValue",
            "Implement registerOnChange",
            "Implement registerOnTouched"
        ]
    },
    {
        "q": "Rearrange the directive lifecycle order:",
        "type": "rearrange",
        "words": [
            "constructor",
            "ngOnChanges",
            "ngOnInit",
            "ngDoCheck",
            "ngOnDestroy"
        ]
    },
    {
        "q": "What is directive testing best practice?",
        "type": "mcq",
        "o": [
            "Create minimal host component and test directive behavior",
            "Test in isolation",
            "Mock everything",
            "E2E only"
        ]
    },
    {
        "q": "Directive tests should focus on behavior, not implementation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is directive selector validation?",
        "type": "mcq",
        "o": [
            "Angular checks that selectors are valid CSS selectors",
            "Selector check",
            "Name validation",
            "Format test"
        ]
    },
    {
        "q": "Angular warns about selectors that don't follow conventions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive with emitDecoratorMetadata?",
        "type": "mcq",
        "o": [
            "TypeScript compiler option enabling runtime type metadata",
            "Decorator output",
            "Meta emitter",
            "Type info"
        ]
    },
    {
        "q": "The _____ compiler option enables reflection metadata.",
        "type": "fill_blank",
        "answers": [
            "emitDecoratorMetadata"
        ],
        "other_options": [
            "experimentalDecorators",
            "reflectMetadata",
            "decoratorInfo"
        ]
    },
    {
        "q": "What is directive tree shaking?",
        "type": "mcq",
        "o": [
            "Removing unused directive code from production bundles",
            "Tree optimization",
            "Code removal",
            "Bundle cleanup"
        ]
    },
    {
        "q": "Standalone directives enable better tree shaking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is providedIn for directive services?",
        "type": "mcq",
        "c": "@Injectable({ providedIn: 'root' })",
        "o": [
            "Configures where the service is provided",
            "Provider config",
            "Service location",
            "Injection point"
        ]
    },
    {
        "q": "Match the providedIn options:",
        "type": "match",
        "left": [
            "root",
            "any",
            "platform",
            "component"
        ],
        "right": [
            "App singleton",
            "Per injector",
            "Platform scope",
            "Component scope"
        ]
    },
    {
        "q": "What is directive source maps?",
        "type": "mcq",
        "o": [
            "Mapping compiled code to original TypeScript for debugging",
            "Source code",
            "Map files",
            "Debug info"
        ]
    },
    {
        "q": "Source maps help debug directives in browser DevTools.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ngDevMode flag in directives?",
        "type": "mcq",
        "o": [
            "Global flag that enables development-only code",
            "Dev toggle",
            "Test mode",
            "Debug flag"
        ]
    },
    {
        "q": "The _____ flag is automatically set in development builds.",
        "type": "fill_blank",
        "answers": [
            "ngDevMode"
        ],
        "other_options": [
            "devMode",
            "debugMode",
            "testMode"
        ]
    },
    {
        "q": "What is directive error handling best practice?",
        "type": "mcq",
        "o": [
            "Use ErrorHandler service and meaningful error messages",
            "Catch all",
            "Silent fail",
            "Log everything"
        ]
    },
    {
        "q": "Match the debugging tools:",
        "type": "match",
        "left": [
            "Angular DevTools",
            "Augury",
            "Source maps",
            "Console.log"
        ],
        "right": [
            "Official extension",
            "Third-party",
            "Debug mapping",
            "Basic logging"
        ]
    },
    {
        "q": "What is directive documentation with JSDoc?",
        "type": "mcq",
        "o": [
            "Adding comments for IDE auto-completion and documentation",
            "JS comments",
            "Doc strings",
            "API docs"
        ]
    },
    {
        "q": "JSDoc comments on @Input provide documentation in templates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is strict mode in Angular projects?",
        "type": "mcq",
        "o": [
            "Stricter type checking and template validation",
            "Strict rules",
            "Hard mode",
            "Validation mode"
        ]
    },
    {
        "q": "The _____ template option enables strict null checks in templates.",
        "type": "fill_blank",
        "answers": [
            "strictNullChecks"
        ],
        "other_options": [
            "strictTemplates",
            "strictMode",
            "nullChecks"
        ]
    },
    {
        "q": "What is strictTemplates in Angular config?",
        "type": "mcq",
        "o": [
            "Enables advanced template type checking",
            "Template rules",
            "Strict HTML",
            "Type templates"
        ]
    },
    {
        "q": "strictTemplates catches type errors in directive bindings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is fullTemplateTypeCheck?",
        "type": "mcq",
        "o": [
            "Legacy option for template type checking",
            "Full check",
            "Complete validation",
            "Template test"
        ]
    },
    {
        "q": "Match the strict options:",
        "type": "match",
        "left": [
            "strictTemplates",
            "strictNullChecks",
            "strictPropertyInitialization",
            "noImplicitAny"
        ],
        "right": [
            "Template types",
            "Null safety",
            "Init required",
            "Type required"
        ]
    },
    {
        "q": "What is ngPackagr for directive libraries?",
        "type": "mcq",
        "o": [
            "Tool to compile and package Angular libraries",
            "Package manager",
            "Library builder",
            "Bundle tool"
        ]
    },
    {
        "q": "ng-packagr creates APF-compliant library packages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Angular Package Format (APF)?",
        "type": "mcq",
        "o": [
            "Standard format for Angular library distribution",
            "Package format",
            "Angular format",
            "Library spec"
        ]
    },
    {
        "q": "The _____ format ensures library compatibility.",
        "type": "fill_blank",
        "answers": [
            "APF"
        ],
        "other_options": [
            "NPM",
            "UMD",
            "ESM"
        ]
    },
    {
        "q": "What is public-api.ts in directive libraries?",
        "type": "mcq",
        "o": [
            "File that exports public API of the library",
            "Public exports",
            "API file",
            "Export list"
        ]
    },
    {
        "q": "Match library concepts:",
        "type": "match",
        "left": [
            "public-api.ts",
            "ng-package.json",
            "package.json",
            "CHANGELOG.md"
        ],
        "right": [
            "Public exports",
            "Library config",
            "NPM manifest",
            "Version history"
        ]
    },
    {
        "q": "What is secondary entry point in libraries?",
        "type": "mcq",
        "o": [
            "Sub-package allowing import of specific modules",
            "Second entry",
            "Alt import",
            "Sub-module"
        ]
    },
    {
        "q": "Secondary entry points enable tree-shakable imports.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is peerDependencies for directive libraries?",
        "type": "mcq",
        "o": [
            "Declares required dependencies without bundling them",
            "Peer packages",
            "Friend deps",
            "External deps"
        ]
    },
    {
        "q": "The _____ field declares Angular as peer dependency.",
        "type": "fill_blank",
        "answers": [
            "peerDependencies"
        ],
        "other_options": [
            "dependencies",
            "devDependencies",
            "optionalDependencies"
        ]
    },
    {
        "q": "What is schematics in directive libraries?",
        "type": "mcq",
        "o": [
            "Adding ng generate support for custom directives",
            "Schema files",
            "Type schemas",
            "Config templates"
        ]
    },
    {
        "q": "Schematics enable ng add and ng generate for libraries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is directive migration with ng update?",
        "type": "mcq",
        "o": [
            "Automated code updates when upgrading Angular versions",
            "Manual update",
            "Version change",
            "Upgrade tool"
        ]
    },
    {
        "q": "Match the Angular CLI commands:",
        "type": "match",
        "left": [
            "ng generate",
            "ng add",
            "ng update",
            "ng build"
        ],
        "right": [
            "Create files",
            "Add library",
            "Update project",
            "Build app"
        ]
    },
    {
        "q": "What is directive deprecation pattern?",
        "type": "mcq",
        "o": [
            "Warning about deprecated features before removal",
            "Remove pattern",
            "Old pattern",
            "Legacy code"
        ]
    },
    {
        "q": "@deprecated JSDoc tag marks directives as deprecated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is breaking change communication?",
        "type": "mcq",
        "o": [
            "Documenting changes that require user code updates",
            "Break info",
            "Change log",
            "Update notes"
        ]
    },
    {
        "q": "The _____ file documents version changes.",
        "type": "fill_blank",
        "answers": [
            "CHANGELOG"
        ],
        "other_options": [
            "README",
            "BREAKING",
            "UPDATES"
        ]
    },
    {
        "q": "What is semantic versioning for directive libraries?",
        "type": "mcq",
        "o": [
            "Version format major.minor.patch indicating change type",
            "Version numbers",
            "Semantic numbers",
            "Change version"
        ]
    },
    {
        "q": "Match semantic version changes:",
        "type": "match",
        "left": [
            "Major",
            "Minor",
            "Patch"
        ],
        "right": [
            "Breaking changes",
            "New features",
            "Bug fixes"
        ]
    },
    {
        "q": "Rearrange library publication steps:",
        "type": "rearrange",
        "words": [
            "Build library",
            "Test package",
            "Update version",
            "Update changelog",
            "Publish to npm"
        ]
    },
    {
        "q": "Rearrange directive debugging steps:",
        "type": "rearrange",
        "words": [
            "Identify issue",
            "Check bindings",
            "Use DevTools",
            "Add logging",
            "Fix and verify"
        ]
    },
    {
        "q": "What is directive unit testing coverage?",
        "type": "mcq",
        "o": [
            "Measuring what percentage of directive code is tested",
            "Test count",
            "Code coverage",
            "Test ratio"
        ]
    },
    {
        "q": "Code coverage tools measure tested directive code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange Angular directive best practices priority:",
        "type": "rearrange",
        "words": [
            "Single responsibility",
            "Proper cleanup",
            "Type safety",
            "Documentation",
            "Testing"
        ]
    }
]