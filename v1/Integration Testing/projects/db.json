[
    {
        "title": "Test Database ğŸ—„ï¸",
        "ques": "Should integration tests run against the production database?",
        "answer": {
            "type": "text",
            "content": "**Never**"
        },
        "explanation": "Always use a dedicated test database (or an in-memory one) to avoid corrupting real user data."
    },
    {
        "title": "Transactions ğŸ’¸",
        "ques": "How can you ensure that a test modifying the database does not affect subsequent tests?",
        "answer": {
            "type": "text",
            "content": "**Rollback Transactions**"
        },
        "explanation": "Wrap the test in a transaction and roll it back at the end, resetting the state."
    },
    {
        "title": "Seeds ğŸŒ¾",
        "ques": "What is the process of populating the database with initial data required for tests to run?",
        "answer": {
            "type": "text",
            "content": "**Seeding**"
        },
        "explanation": "Seeding ensures a known starting state."
    },
    {
        "title": "Constraints ğŸ”—",
        "ques": "What database feature prevents you from inserting a record with a foreign key that doesn't exist?",
        "answer": {
            "type": "text",
            "content": "**Foreign Key Constraint**"
        },
        "explanation": "Referential integrity is a key part of database integration testing."
    },
    {
        "title": "Migration Testing ğŸšš",
        "ques": "What ensures that your database schema changes (migrations) can be applied and rolled back successfully?",
        "answer": {
            "type": "text",
            "content": "**Migration Tests**"
        },
        "explanation": "Verifying that `up` and `down` migration scripts work prevents deployment failures."
    }
]