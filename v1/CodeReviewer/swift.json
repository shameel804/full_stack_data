[
    {
        "id": "swift_err_1",
        "title": "Let constant reassignment",
        "description": "Identify syntax error.",
        "codeSnippet": "let x = 10\nx = 20",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Constants declared with `let` are immutable and cannot be reassigned. Use `var` for mutable variables.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_1",
        "title": "Variable declaration",
        "description": "True or False?",
        "codeSnippet": "var name = \"Swift\"\nname = \"SwiftUI\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Variables declared with `var` can be reassigned.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_2",
        "title": "Type mismatch assignment",
        "description": "Identify type error.",
        "codeSnippet": "var count: Int = 10\ncount = \"Ten\"",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot assign value of type 'String' to type 'Int'. Swift is statically typed.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_2",
        "title": "Type inference",
        "description": "True or False?",
        "codeSnippet": "var pi = 3.14 // inferred as Double",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Swift infers floating-point numbers as `Double` by default.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_3",
        "title": "Force unwrapping nil",
        "description": "Identify runtime error.",
        "codeSnippet": "var name: String? = nil\nprint(name!)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Force unwrapping (`!`) a nil optional causes a runtime crash ('Unexpectedly found nil while unwrapping an Optional value').",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_3",
        "title": "Optional binding",
        "description": "True or False?",
        "codeSnippet": "var name: String? = \"John\"\nif let unwrapped = name {\n    print(unwrapped)\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `if let` safely unwraps the optional if it contains a value.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_4",
        "title": "Invalid array element type",
        "description": "Identify type error.",
        "codeSnippet": "var numbers: [Int] = [1, 2, \"Three\"]",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Arrays are typed. Cannot insert a String (\"Three\") into an Array of Ints.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_4",
        "title": "Array append",
        "description": "True or False?",
        "codeSnippet": "var list = [1, 2]\nlist.append(3)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `append` adds an element to the end of the array.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_5",
        "title": "Constant array mutation",
        "description": "Identify mutability error.",
        "codeSnippet": "let list = [1, 2]\nlist.append(3)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Arrays assigned to `let` are immutable. Cannot call mutating method `append` on a constant array.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_5",
        "title": "Dictionary declaration",
        "description": "True or False?",
        "codeSnippet": "var scores = [\"A\": 90, \"B\": 80]",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Valid dictionary literal syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_6",
        "title": "String interpolation syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "let name = \"World\"\nprint(\"Hello $name\")",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Swift uses `\\(variable)` for string interpolation, not `$variable`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_6",
        "title": "String interpolation",
        "description": "True or False?",
        "codeSnippet": "let x = 5\nprint(\"Value is \\(x)\")",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct syntax for string interpolation.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_7",
        "title": "Function return missing",
        "description": "Identify logic error.",
        "codeSnippet": "def add(a: Int, b: Int) -> Int {\n    return a + b\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Function keyword is `func`, not `def`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_7",
        "title": "Function implicit return",
        "description": "True or False?",
        "codeSnippet": "func add(a: Int, b: Int) -> Int {\n    a + b\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Single-expression functions implicit return the value.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_8",
        "title": "Missing argument label",
        "description": "Identify call error.",
        "codeSnippet": "func greet(name: String) {}\ngreet(\"Alice\")",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "By default, Swift functions require argument labels. Must call `greet(name: \"Alice\")`. To omit label, define `func greet(_ name: String)`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_8",
        "title": "Omitted argument label",
        "description": "True or False?",
        "codeSnippet": "func triple(_ x: Int) -> Int { x * 3 }\nprint(triple(3))",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. The underscore `_` allows omitting the argument label at call site.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_9",
        "title": "Switch exhaustive",
        "description": "Identify logic error.",
        "codeSnippet": "let x = 1\nswitch x {\ncase 1: print(\"One\")\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Switch statements must be exhaustive. Since `x` is `Int`, not all cases are covered. Needs a `default` case.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_9",
        "title": "Range operator",
        "description": "True or False?",
        "codeSnippet": "for i in 1...5 {\n    print(i)\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `...` is the closed range operator (includes 5).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_10",
        "title": "Class missing init",
        "description": "Identify syntax error.",
        "codeSnippet": "class Person {\n    var name: String\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Class `Person` has no initializers. Stored property `name` must be initialized (e.g., `init(name: String) { ... }`) or optional.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_10",
        "title": "Struct memberwise init",
        "description": "True or False?",
        "codeSnippet": "struct Point {\n    var x: Int\n    var y: Int\n}\nlet p = Point(x: 1, y: 2)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Structs automatically receive a memberwise initializer.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_11",
        "title": "Struct mutation",
        "description": "Identify mutability error.",
        "codeSnippet": "struct Counter {\n    var count = 0\n    func increment() {\n        count += 1\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Cannot modify property of a value type (struct) within an instance method without marking it `mutating`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_11",
        "title": "Mutating keyword",
        "description": "True or False?",
        "codeSnippet": "struct S {\n    var x = 0\n    mutating func update() { x = 1 }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_12",
        "title": "Tuple access",
        "description": "Identify syntax error.",
        "codeSnippet": "let pair = (1, \"one\")\nprint(pair.first)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Tuples elements are accessed by index (e.g., `.0`, `.1`) or name, not `.first`. `pair.0` is correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_12",
        "title": "Named tuple",
        "description": "True or False?",
        "codeSnippet": "let pair = (number: 1, text: \"one\")\nprint(pair.text)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_13",
        "title": "Guard statement missing else",
        "description": "Identify syntax error.",
        "codeSnippet": "func check(x: Int?) {\n    guard let val = x {\n        print(\"Missing else\")\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`guard` statement must have an `else` clause.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_13",
        "title": "Guard return",
        "description": "True or False?",
        "codeSnippet": "func f(x: Int?) {\n    guard let _ = x else { return }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `guard` else block must exit the scope (return, break, throw, etc.).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_14",
        "title": "Nil coalescing type",
        "description": "Identify type error.",
        "codeSnippet": "let x: Int? = nil\nlet y = x ?? \"Default\"",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Nil-coalescing (`??`) operand types must match. `x` is `Int?`, defaulted value is `String`. Cannot coalesce.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_14",
        "title": "Nil coalescing",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = nil\nlet y = x ?? 0",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `y` becomes 0.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_15",
        "title": "Variable shadowing",
        "description": "Ignore shadowing warning - check functionality.",
        "codeSnippet": "func f(x: Int) {\n    var x = x\n    x = 10\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "This is valid Swift code (assigning parameter to local var). Wait, `errorSpotting` usually has an error. If correct, maybe logic? But snippet is trivial. Let's provide an actual error. \nNew snippet: `func f(x: Int) { x = 10 }`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_15_real",
        "title": "Parameter mutability",
        "description": "Identify mutability error.",
        "codeSnippet": "func update(x: Int) {\n    x = 10\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Function parameters are constants (`let`) by default and cannot be reassigned.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_15",
        "title": "In-out parameter",
        "description": "True or False?",
        "codeSnippet": "func swap(_ a: inout Int, _ b: inout Int) {\n    let temp = a; a = b; b = temp\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct usage of `inout` to modify parameters.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_16",
        "title": "Protocol method implementation",
        "description": "Identify conformance error.",
        "codeSnippet": "protocol P {\n    func m()\n}\nstruct S: P {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Type `S` does not conform to protocol `P`. It needs to implement method `m()`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_16",
        "title": "Protocol property requirement",
        "description": "True or False?",
        "codeSnippet": "protocol Named {\n    var name: String { get }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct syntax for read-only property requirement.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_17",
        "title": "Access control private",
        "description": "Identify access error.",
        "codeSnippet": "class A {\n    private var x = 10\n}\nprint(A().x)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "`x` is private and cannot be accessed outside of class `A`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_17",
        "title": "Fileprivate access",
        "description": "True or False?",
        "codeSnippet": "class A {\n    fileprivate var x = 10\n}\n// in same file\nlet a = A()\na.x = 20",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `fileprivate` allows access within the same source file.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_18",
        "title": "Extension stored property",
        "description": "Identify extension limit.",
        "codeSnippet": "extension Int {\n    var doubleValue: Int = 0\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Extensions must not contain stored properties. Computed properties are allowed.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_18",
        "title": "Extension computed property",
        "description": "True or False?",
        "codeSnippet": "extension Int {\n    var squared: Int { return self * self }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_19",
        "title": "Self in closure capture",
        "description": "Identify retain cycle risk.",
        "codeSnippet": "class A {\n    var block: (() -> Void)?\n    func run() {\n        block = { print(self) }\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Strong reference cycle. Closure captures `self` strongly, and `self` holds closure. Use `[weak self]`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_19",
        "title": "Weak capture",
        "description": "True or False?",
        "codeSnippet": "block = { [weak self] in\n    print(self?.description)\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Breaks reference cycle.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_20",
        "title": "Static method override",
        "description": "Identify override error.",
        "codeSnippet": "class Base {\n    static func f() {}\n}\nclass Sub: Base {\n    override static func f() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Cannot override a `static` method. Use `class` methods if override is intended.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_20",
        "title": "Class method override",
        "description": "True or False?",
        "codeSnippet": "class Base {\n    class func f() {}\n}\nclass Sub: Base {\n    override class func f() {}\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `class` methods can be overridden.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_21",
        "title": "Do-Catch missing try",
        "description": "Identify syntax error.",
        "codeSnippet": "func f() throws {}\ndo {\n    f()\n} catch {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Calling a throwing function requires `try`. `try f()`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_21",
        "title": "Try optional",
        "description": "True or False?",
        "codeSnippet": "func f() throws -> Int { return 1 }\nlet x: Int? = try? f()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `try?` returns an optional, nil if error throws.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_22",
        "title": "DidSet constant",
        "description": "Identify mutability.",
        "codeSnippet": "struct S {\n    let x: Int = 0 { didSet { print(\"Set\") } }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`didSet` observers observe setting the value. Constants (`let`) are never set after init, so observers are invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_22",
        "title": "WillSet observer",
        "description": "True or False?",
        "codeSnippet": "var score: Int = 0 {\n    willSet {\n        print(newValue)\n    }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_23",
        "title": "Enum raw value duplicate",
        "description": "Identify definition error.",
        "codeSnippet": "enum E: Int {\n    case a = 1\n    case b = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Raw values must be unique. `case b` cannot also be 1.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_23",
        "title": "Enum implicit raw values",
        "description": "True or False?",
        "codeSnippet": "enum E: Int {\n    case a = 1, b, c\n}\n// E.b.rawValue == 2",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Integers increment automatically.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_24",
        "title": "Defer scope",
        "description": "Identify flow.",
        "codeSnippet": "func f() {\n    defer { print(\"D\") }\n    return\n    print(\"E\")\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid code. Prints \"D\". \nError: `defer` outside of scope? \nCode: `defer { return }`? \nSnippet: `var x = 0; defer { x += 1 }; return x`. Returns 0. `defer` runs *after* return logic evaluated? Wait. `defer` runs just before exiting scope. `return x` evaluates x (0), sets return, then defer runs (x=1), then exit. So returns 0.\nLet's use a simpler error: `defer` requires a closure.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_24_real",
        "title": "Defer syntax",
        "description": "Identify syntax.",
        "codeSnippet": "defer print(\"Exit\")",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`defer` statement requires a block/closure `{ ... }`. `defer { print(\"Exit\") }`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_24",
        "title": "Defer order",
        "description": "True or False?",
        "codeSnippet": "func f() {\n  defer { print(1) }\n  defer { print(2) }\n}\n// prints 2 then 1",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Defer statements are executed in reverse order (stack).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_25",
        "title": "Computed property set",
        "description": "Identify syntax.",
        "codeSnippet": "var x: Int {\n    get { 1 }\n    set { print(val) }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "The implicit name for the new value in the setter is `newValue`, not `val`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_25",
        "title": "Lazy property",
        "description": "True or False?",
        "codeSnippet": "class C {\n    lazy var x = 10\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_26",
        "title": "Closure capture list",
        "description": "Identify syntax error.",
        "codeSnippet": "var x = 0\nlet f = { [x] in print(x) }\nx = 1\nf()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. Capture list `[x]` captures `x` by value (copy) at creation. Prints 0. \nError: `[x] { ... }` syntax? No, `params in`. \nReal Error: `weak` used with value type.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_26_real",
        "title": "Weak capture value type",
        "description": "Identify ARC error.",
        "codeSnippet": "struct S {}\nlet s = S()\nlet f = { [weak s] in print(s) }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`weak` may only be applied to class and class-bound protocol types, not struct `S`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_26",
        "title": "Trailing closure",
        "description": "True or False?",
        "codeSnippet": "func f(action: () -> Void) {}\nf { print(\"Done\") }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Trailing closure syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_27",
        "title": "Any typing",
        "description": "Identify type usage.",
        "codeSnippet": "let x: Any = \"String\"\nprint(x + \"Suffix\")",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot apply operator `+` to `Any` and `String`. Must cast `x` to `String` first.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_27",
        "title": "As? cast",
        "description": "True or False?",
        "codeSnippet": "let x: Any = \"String\"\nif let s = x as? String {\n    print(s)\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Conditional downcast.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_28",
        "title": "Protocol optional requirement",
        "description": "Identify requirements.",
        "codeSnippet": "protocol P {\n    optional func f()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`optional` requirements are only supported in `@objc` protocols.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_28",
        "title": "Protocol inheritance",
        "description": "True or False?",
        "codeSnippet": "protocol A {}\nprotocol B: A {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_29",
        "title": "Tuple type labels",
        "description": "Identify type mismatch.",
        "codeSnippet": "var t = (a: 1, b: 2)\nt = (x: 1, y: 2)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Tuples with different element labels have different types. Cannot assign `(x: Int, y: Int)` to `(a: Int, b: Int)`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_29",
        "title": "Set creation",
        "description": "True or False?",
        "codeSnippet": "let s: Set = [1, 2, 2]",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Creates a Set `{1, 2}`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_30",
        "title": "Set index access",
        "description": "Identify usage.",
        "codeSnippet": "let s: Set = [1, 2]\nprint(s[0])",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Sets are unordered and do not support integer indexing like arrays.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_30",
        "title": "Set contains",
        "description": "True or False?",
        "codeSnippet": "let s: Set = [1]\ns.contains(1)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_31",
        "title": "Character literal",
        "description": "Identify type.",
        "codeSnippet": "let c: Character = 'a'",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Swift uses double quotes `\"` for string and character literals. Single quotes `'` are not used.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_31",
        "title": "Multiline String",
        "description": "True or False?",
        "codeSnippet": "let s = \"\"\"\nLine 1\nLine 2\n\"\"\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_32",
        "title": "Subscript static",
        "description": "Identify syntax.",
        "codeSnippet": "struct S {\n    static subscript(i: Int) -> Int { return i }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Static subscripts are allowed in Swift 5.1+. Valid. \nError: `class var` override? \nReal Error: `enum` invalid case names (modifiers).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_32_real",
        "title": "Enum case method conflict",
        "description": "Identify definition.",
        "codeSnippet": "enum E {\n    case a\n    func a() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Invalid redeclaration of `a`. Enum case and instance method cannot have same name.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_32",
        "title": "Raw string",
        "description": "True or False?",
        "codeSnippet": "let s = #\"Line 1\\nLine 2\"#",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `\\n` is treated as literal characters because of raw string delimiters `#`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_33",
        "title": "Repeat while condition",
        "description": "Identify syntax.",
        "codeSnippet": "repeat {\n    print(\"Loop\")\n} while false",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. Runs once. \nError: `do ... while`? Swift uses `repeat ... while`. \nCode: `do { } while false`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_33_real",
        "title": "Do while syntax",
        "description": "Identify syntax.",
        "codeSnippet": "do {\n    print(\"Loop\")\n} while false",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Swift uses `repeat { ... } while condition`, not `do ... while`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_33",
        "title": "Labeled break",
        "description": "True or False?",
        "codeSnippet": "outer: for i in 1...2 {\n    break outer\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_34",
        "title": "Fallthrough in if",
        "description": "Identify control flow.",
        "codeSnippet": "if true {\n    fallthrough\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`fallthrough` is only allowed inside a `switch` statement.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_34",
        "title": "Switch compound case",
        "description": "True or False?",
        "codeSnippet": "switch 1 {\ncase 1, 2: print(\"1 or 2\")\ndefault: break\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_35",
        "title": "Implicitly unwrapped usage",
        "description": "Identify safety.",
        "codeSnippet": "var s: String! = nil\nprint(s.count)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Runtime crash. Accessing nil IUO triggers crash.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_35",
        "title": "AnyObject type",
        "description": "True or False?",
        "codeSnippet": "class C {}\nlet x: AnyObject = C()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. `AnyObject` refers to any class instance.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_36",
        "title": "Computed property lazy",
        "description": "Identify syntax.",
        "codeSnippet": "lazy var x: Int {\n    return 0\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`lazy` cannot be used on a computed property. It is for stored properties initialized on first access.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_36",
        "title": "Property observer init",
        "description": "True or False?",
        "codeSnippet": "class C {\n    var x = 0 { didSet { print(\"Set\") } }\n    init() { x = 1 }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct (compiles), but `didSet` is NOT called inside `init`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_37",
        "title": "Init failable return",
        "description": "Identify syntax.",
        "codeSnippet": "init() {\n    return nil\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Only failable initializers (`init?`) can return `nil`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_37",
        "title": "Failable init",
        "description": "True or False?",
        "codeSnippet": "struct S { init?() { return nil } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_38",
        "title": "Deinit in struct",
        "description": "Identify syntax.",
        "codeSnippet": "struct S {\n    deinit { print(\"Bye\") }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Deinitializers (`deinit`) are only available in classes, not structs (value types).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_38",
        "title": "Required init",
        "description": "True or False?",
        "codeSnippet": "class A { required init() {} }\nclass B: A { required init() {} }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Subclasses must implement required inits.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_39",
        "title": "Operator overload static",
        "description": "Identify syntax.",
        "codeSnippet": "struct Vector {\n    func +(lhs: Vector, rhs: Vector) -> Vector { ... }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Operator functions must be `static`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_39",
        "title": "Extension init",
        "description": "True or False?",
        "codeSnippet": "struct S { var x: Int }\nextension S {\n    init(y: Int) { self.init(x: y) }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Extensions can add convenince initializers.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_40",
        "title": "Nested type access",
        "description": "Identify scope.",
        "codeSnippet": "class Outer {\n    private class Inner {}\n}\nlet i = Outer.Inner()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "`Inner` is private to `Outer`. Cannot be accessed outside.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_40",
        "title": "Nested type",
        "description": "True or False?",
        "codeSnippet": "struct Deck {\n    enum Suit { case heart, spade }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_41",
        "title": "Assert condition",
        "description": "Identify usage.",
        "codeSnippet": "let x = -1\nassert(x > 0, \"Must be positive\")",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Runtime assertion failure. Condition `x > 0` is false.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_41",
        "title": "Precondition",
        "description": "True or False?",
        "codeSnippet": "precondition(true)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_42",
        "title": "Fatal error return",
        "description": "Identify behavior.",
        "codeSnippet": "func crash() -> Int {\n    fatalError(\"Crash\")\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. `fatalError` returns `Never`, which satisfies any return type (function never returns).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_42_real",
        "title": "Throw in non-throwing",
        "description": "Identify syntax.",
        "codeSnippet": "func f() {\n    throw MyError.e\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot throw error in a function not marked with `throws`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_42",
        "title": "Rethrows",
        "description": "True or False?",
        "codeSnippet": "func f(block: () throws -> Void) rethrows {\n    try block()\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_43",
        "title": "KeyPath syntax",
        "description": "Identify syntax.",
        "codeSnippet": "struct S { var x: Int }\nlet kp = S.x",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Keypath syntax requires backslash `\\`. `\\S.x`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_43",
        "title": "KeyPath read",
        "description": "True or False?",
        "codeSnippet": "struct S { var x = 1 }\nlet s = S()\nprint(s[keyPath: \\.x])",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_44",
        "title": "Codable enum rawvalue",
        "description": "Identify requirement.",
        "codeSnippet": "enum E: Codable {\n    case a\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. Enums without raw values can be Codable (uses case name). \nError: `json` decoding mismatch. \nCode: `struct S: Codable { var x: Int }`. JSON `{\"x\": \"1\"}`. Decoding error.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_44_real",
        "title": "Decoding type mismatch",
        "description": "Identify runtime.",
        "codeSnippet": "let json = \"{\\\"x\\\": \\\"1\\\"}\".data(using: .utf8)!\nstruct S: Codable { var x: Int }\ntry! JSONDecoder().decode(S.self, from: json)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Type mismatch. JSON has string \"1\", model expects Int 1. Decoder throws exception (Using `try!` causes crash).",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_44",
        "title": "CodingKeys",
        "description": "True or False?",
        "codeSnippet": "struct S: Codable {\n    var name: String\n    enum CodingKeys: String, CodingKey {\n        case name = \"title\"\n    }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Maps `name` property to `title` key.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_45",
        "title": "Final class inheritance",
        "description": "Identify definition.",
        "codeSnippet": "final class A {}\nclass B: A {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot inherit from a `final` class.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_45",
        "title": "Convenience init",
        "description": "True or False?",
        "codeSnippet": "class C {\n    init(x: Int) {}\n    convenience init() { self.init(x: 0) }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_46",
        "title": "Tuple comparison",
        "description": "Identify capability.",
        "codeSnippet": "(1, true) < (2, false)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. Tuples are comparable if elements are comparable and < 7 elements. \nError: `(1, true) == (1, true)`. \nCode: `(1, Bool) < ...`. Bool not Comparable? \nYes, Bool is not Comparable. Comparable protocol? `false < true`? No.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_46_real",
        "title": "Bool comparision",
        "description": "Identify type capability.",
        "codeSnippet": "false < true",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Bool does not conform to `Comparable`. Cannot use `<`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_46",
        "title": "String count",
        "description": "True or False?",
        "codeSnippet": "\"abc\".count == 3",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_47",
        "title": "Unowned unsafe",
        "description": "Identify crash risk.",
        "codeSnippet": "class A {}\nunowned var ref: A = A()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Instance is deallocated immediately (no strong ref). Accessing `ref` will crash. Unowned reference expects instance to be alive.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_47",
        "title": "Computed property get-only",
        "description": "True or False?",
        "codeSnippet": "var x: Int { 1 }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct shortcut for read-only computed property.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_48",
        "title": "Generic where clause",
        "description": "Identify usage.",
        "codeSnippet": "func f<T>(x: T) where T: Int {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Type definition `Int` is a struct, not a protocol. Constraint must be a class or protocol. (Though `T == Int` is valid). `T: Int` implies conformance.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_48",
        "title": "Generic constraint",
        "description": "True or False?",
        "codeSnippet": "func f<T: Equatable>(x: T, y: T) -> Bool { x == y }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_49",
        "title": "Objc selector visibility",
        "description": "Identify attribute.",
        "codeSnippet": "class C {\n    func f() {}\n}\n#selector(C.f)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Method `f` must be marked `@objc` to be exposed to Objective-C runtime for `#selector`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_49",
        "title": "Dynamic member lookup",
        "description": "True or False?",
        "codeSnippet": "@dynamicMemberLookup\nstruct S {\n    subscript(dynamicMember member: String) -> String {\n        return member\n    }\n}\n// S().foo returns \"foo\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_50",
        "title": "Set value type",
        "description": "Identify type constraint.",
        "codeSnippet": "struct S {}\nlet s: Set<S> = []",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Type `S` must conform to `Hashable` to be used in a `Set`.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_tf_50",
        "title": "Hashable synthesize",
        "description": "True or False?",
        "codeSnippet": "struct S: Hashable { var x: Int }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "Correct. Compiler synthesizes Hashable conformance if all properties are Hashable.",
        "difficultyLevel": 1
    },
    {
        "id": "swift_err_101",
        "title": "Actor isolation check",
        "description": "Identify concurrency error.",
        "codeSnippet": "actor Bank {\n    var balance = 0\n}\nlet b = Bank()\nprint(b.balance)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Actor-isolated property `balance` can only be accessed from outside the actor using `await`. `print(await b.balance)`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_101",
        "title": "Actor reentrancy",
        "description": "True or False?",
        "codeSnippet": "actor A {\n    func f() async {\n        await g()\n        // state might have changed here\n    }\n    func g() async {}\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Actors are reentrant. During the `await g()` suspension, other tasks can execute methods on actor `A`, potentially changing state before `f` resumes.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_102",
        "title": "Opaque type return mismatch",
        "description": "Identify type error.",
        "codeSnippet": "func make() -> some Equatable {\n    if true { return 1 }\n    else { return \"String\" }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Functions returning an opaque type (`some Protocol`) must return values of a single, underlying concrete type. Cannot return both `Int` and `String`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_102",
        "title": "Existential Any",
        "description": "True or False?",
        "codeSnippet": "let x: any Equatable = 1",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `any Equatable` creates an existential box.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_103",
        "title": "Escaping closure",
        "description": "Identify attribute error.",
        "codeSnippet": "var handlers = [() -> Void]()\nfunc add(handler: () -> Void) {\n    handlers.append(handler)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Parameter `handler` is stored outside the function scope, so it must be marked `@escaping`. `func add(handler: @escaping () -> Void)`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_103",
        "title": "Autoclosure",
        "description": "True or False?",
        "codeSnippet": "func f(_ p: @autoclosure () -> Bool) {}\nf(1 > 0)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Arguments are automatically wrapped in a closure.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_104",
        "title": "Protocol with associated type variable",
        "description": "Identify usage.",
        "codeSnippet": "protocol P { associatedtype T }\nvar x: P",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Protocol `P` has associated type requirements, so it cannot be used as a concrete type directly (except as `any P` in Swift 5.7+). In older Swift: Protocol 'P' can only be used as a generic constraint.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_104",
        "title": "Primary associated type",
        "description": "True or False?",
        "codeSnippet": "func f(p: some Collection<Int>) {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Swift 5.7+ checks `Collection` where `Element == Int`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_105",
        "title": "Associated type constraint",
        "description": "Identify syntax.",
        "codeSnippet": "protocol P {\n    associatedtype T where T: Int\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`Int` is a struct, not a protocol or class. Constraints like `T: SomeClass` or `T: SomeProtocol` are valid. `T == Int` is syntax for equality constraint (usually in where clause of extension/func). Associated type definition uses `: Protocol` or `: Class`. Should be `associatedtype T: Equatable` e.g.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_105",
        "title": "Protocol extension default",
        "description": "True or False?",
        "codeSnippet": "protocol P { func f() }\nextension P { func f() {} }\nstruct S: P {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `S` gets default implementation of `f`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_106",
        "title": "Indirect enum",
        "description": "Identify definition error.",
        "codeSnippet": "enum List {\n    case empty\n    case node(Int, List)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Recursive enum cases must be marked `indirect`. `indirect case node(Int, List)`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_106",
        "title": "CaseIterable",
        "description": "True or False?",
        "codeSnippet": "enum E: CaseIterable {\n    case a, b\n}\nprint(E.allCases.count)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Compiler synthesizes `allCases`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_107",
        "title": "Mutating protocol method",
        "description": "Identify requirement.",
        "codeSnippet": "protocol P { func reset() }\nstruct S: P {\n    var x = 0\n    func reset() { x = 0 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Method modifies state of struct, so it must be marked `mutating`. Protocol should declare `mutating func` if it expects to support value type mutation.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_107",
        "title": "Extension computed property",
        "description": "True or False?",
        "codeSnippet": "extension String {\n    var isEmptyStr: Bool { self.isEmpty }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_108",
        "title": "Property wrapper type access",
        "description": "Identify syntax.",
        "codeSnippet": "@propertyWrapper struct W { var wrappedValue: Int }\nstruct S {\n    @W var x: Int\n}\nlet s = S(x: 1)\nprint(s._x)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 5,
        "explanation": "The backing storage `_x` is private. Only accessible within `S`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_108",
        "title": "Projected value",
        "description": "True or False?",
        "codeSnippet": "@propertyWrapper struct W {\n    var wrappedValue: Int\n    var projectedValue: String { \"Projected\" }\n}\nstruct S { @W var x: Int }\n// s.$x returns \"Projected\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `$` accesses `projectedValue`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_109",
        "title": "Result usage",
        "description": "Identify syntax.",
        "codeSnippet": "let r: Result<Int> = .success(1)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`Result` requires two type arguments: `Success` and `Failure`. `Result<Int, Error>`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_109",
        "title": "Result get",
        "description": "True or False?",
        "codeSnippet": "let r: Result<Int, Error> = .success(1)\nlet val = try? r.get()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `get()` returns value or throws.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_110",
        "title": "Throwing property",
        "description": "Identify scope.",
        "codeSnippet": "var x: Int throws { 1 }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Computed properties can throw (Swift 5.5+). `var x: Int { get throws { 1 } }`. Syntax `var x: Int throws` is invalid shorthand? Actually `var x: Int { get throws { ... } }` is correct.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_110",
        "title": "Property observer throw",
        "description": "True or False?",
        "codeSnippet": "var x: Int = 0 { didSet { throw Error() } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False. Property observers (`didSet`, `willSet`) cannot throw.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_111",
        "title": "KeyPath write let",
        "description": "Identify mutability.",
        "codeSnippet": "struct S { var x: Int }\nlet s = S(x: 1)\ns[keyPath: \\.x] = 2",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Cannot use writable keypath subscript on constant `s`. `s` must be `var`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_111",
        "title": "KeyPath function",
        "description": "True or False?",
        "codeSnippet": "struct S { var x: Int }\nlet list = [S(x: 1), S(x: 2)]\nlet xs = list.map(\\.x)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. KeyPath can be used as functions (Swift 5.2+).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_112",
        "title": "Optional chaining call",
        "description": "Identify return type.",
        "codeSnippet": "class C { func f() -> Int { 1 } }\nlet c: C? = C()\nlet x: Int = c?.f()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Optional chaining returns `Optional`. `c?.f()` returns `Int?`, not `Int`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_112",
        "title": "Nil coalescing sequencing",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = nil\nlet y: Int? = 2\nlet z = x ?? y ?? 3",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. 2 is returned.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_113",
        "title": "Structural type alias",
        "description": "Identify usage.",
        "codeSnippet": "typealias Callback = (Int) -> Void\nfunc f(c: Callback) {\n    c(argument: 1)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Closures do not use argument labels in calls. `c(1)`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_113",
        "title": "Typealias generic",
        "description": "True or False?",
        "codeSnippet": "typealias List<T> = Array<T>",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_114",
        "title": "Weak variable non-optional",
        "description": "Identify requirement.",
        "codeSnippet": "class C {}\nweak var c: C = C()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`weak` variables must be optional (`C?`) because they can become nil at runtime.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_114",
        "title": "Unowned implicit unwrapped",
        "description": "True or False?",
        "codeSnippet": "unowned var x: C",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `unowned` references act like implicitly unwrapped non-optionals (assumed to exist).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_115",
        "title": "Deinit call",
        "description": "Identify logic.",
        "codeSnippet": "class C { deinit {} }\nlet c = C()\nc.deinit()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`deinit` cannot be called explicitly. It is called automatically by ARC.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_115",
        "title": "Reference identity",
        "description": "True or False?",
        "codeSnippet": "class C {}\nlet a = C()\nlet b = a\n// a === b is true",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `===` checks reference identity.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_116",
        "title": "Copy on write custom",
        "description": "Identify implementation.",
        "codeSnippet": "struct S {\n    var ref = C()\n    mutating func update() {\n        ref.val = 1\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Modifying a reference type property inside a struct makes the struct effectively a reference type (shared state). To implement value semantics (COW), must check `isKnownUniquelyReferenced(&ref)` and copy if needed.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_116",
        "title": "Tuple Equatable",
        "description": "True or False?",
        "codeSnippet": "(1, 2) == (1, 2)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Tuples conform to Equatable if elements do (up to size 6).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_117",
        "title": "Generic subscript param",
        "description": "Identify syntax.",
        "codeSnippet": "struct S {\n    subscript<T>(x: T) -> Int { 0 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid (Swift 4+ supports generic subscripts). \nError: `subscript` cannot throw? (Swift 5.5 supports throwing subscripts). \nCode: `subscript(x: Int) throws -> Int`. \nReal Error: `subscript` cannot be `let`. Must be `subscript`. \nLet's use: `private subscript` visibility in protocol.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_117_real",
        "title": "Protocol subscript setter",
        "description": "Identify requirement.",
        "codeSnippet": "protocol P {\n    subscript(i: Int) -> Int { get set }\n}\nstruct S: P {\n    subscript(i: Int) -> Int { 0 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Protocol requires `{ get set }`. Struct implementation is read-only (getter only). Must define setter or proper storage.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_117",
        "title": "Multiple Protocol Conformance",
        "description": "True or False?",
        "codeSnippet": "func f(x: P & Q) {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Composition of protocols.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_118",
        "title": "Enum raw value non-literal",
        "description": "Identify definition.",
        "codeSnippet": "var x = 1\nenum E: Int {\n    case a = x\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Raw values must be literals. Cannot use variable `x`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_118",
        "title": "Enum associated values",
        "description": "True or False?",
        "codeSnippet": "enum E {\n    case val(Int)\n}\nlet e = E.val(1)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_119",
        "title": "Generic protocol constraint variance",
        "description": "Identify usage.",
        "codeSnippet": "class A {}\nclass B: A {}\nvar list: Array<A> = []\nlet bList: Array<B> = []\nlist = bList",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Swift Arrays are invariant in terms of assignment. Cannot assign `Array<B>` to `Array<A>`. Use `map` or upcasting.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_119",
        "title": "Array Any upcast",
        "description": "True or False?",
        "codeSnippet": "let list: [Any] = [1, \"a\"] as [Any]",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_120",
        "title": "For loop iterator modification",
        "description": "Identify safety.",
        "codeSnippet": "var list = [1, 2, 3]\nfor i in list {\n    list.removeLast()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid in Swift. `for i in list` iterates over a *copy* of the array (value semantics). Modifying `list` inside loop does not affect iterator. \nError: `list.remove(at: i)`? \nReal Error: `inout` capture in escaping closure.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_120_real",
        "title": "Escaping closure inout",
        "description": "Identify usage.",
        "codeSnippet": "func f(x: inout Int) {\n    let closure = { print(x) }\n    save(closure)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Escaping closures cannot capture `inout` parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_120",
        "title": "Non-escaping inout capture",
        "description": "True or False?",
        "codeSnippet": "func f(x: inout Int) {\n    [1].forEach { _ in x += 1 }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Non-escaping closures can capture inout.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_121",
        "title": "Defer in struct init",
        "description": "Identify memory usage.",
        "codeSnippet": "struct S {\n    var x: Int\n    init() {\n        defer { x = 1 }\n        x = 0\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. `defer` runs after init scope. \nError: accessing `self` before init? \nCode: `init() { print(self); x = 0 }`. \nReal Error: `defer { print(self.x) }`. `self` must be fully initialized before defer block uses it? Defer captures context. If `x` not initialized, compiler error.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_121_real",
        "title": "Self access before init",
        "description": "Identify initialization.",
        "codeSnippet": "struct S {\n    var x: Int\n    init() {\n        print(self)\n        x = 1\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "`self` used before all stored properties are initialized.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_121",
        "title": "Lazy initialization",
        "description": "True or False?",
        "codeSnippet": "class C { lazy var x = { return 1 }() }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_122",
        "title": "DidSet infinite recursion",
        "description": "Identify logic.",
        "codeSnippet": "var x: Int = 0 {\n    didSet {\n        x += 1\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Setting `x` inside `didSet` triggers `didSet` again? False! In Swift, setting property inside its own observer does NOT trigger observer again to prevent recursion. This is valid logic (though maybe unexpected). \nWait. True? \"The didSet and willSet observers of superclass properties are called when a property is set in a subclass initializer...\" \n\"Inside the observer...\" -> No recursion. \nLet's assume error is: `willSet` new value modification? \nCode: `willSet { newValue = 1 }`. `newValue` is const.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_122_real",
        "title": "WillSet newValue mutation",
        "description": "Identify mutability.",
        "codeSnippet": "var x: Int = 0 {\n    willSet {\n        newValue = 1\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`newValue` in `willSet` is an immutable constant.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_122",
        "title": "DidSet oldValue",
        "description": "True or False?",
        "codeSnippet": "var x = 0 { didSet { print(oldValue) } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_123",
        "title": "Static property class override",
        "description": "Identify override.",
        "codeSnippet": "class A {\n    static var x = 0\n}\nclass B: A {\n    override static var x = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "`static` properties are final and cannot be overridden. Use `class var` to allow override.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_123",
        "title": "Class computed property",
        "description": "True or False?",
        "codeSnippet": "class A {\n    class var x: Int { 1 }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_124",
        "title": "Convenience init call order",
        "description": "Identify flow.",
        "codeSnippet": "class C {\n    init() {}\n    convenience init(x: Int) {\n        // missing self.init()\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Convenience initializer must call a designated initializer (or another convenience init) of the *same* class (`self.init(...)`).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_124",
        "title": "Required init inherit",
        "description": "True or False?",
        "codeSnippet": "class A { required init() {} }\nclass B: A {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `B` inherits required init automatically if it doesn't add properties requiring init/doesn't define other designated inits.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_125",
        "title": "MainActor on struct",
        "description": "Identify attribute.",
        "codeSnippet": "@MainActor struct S {\n    func update() {}\n}\nfunc f() {\n    S().update()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 5,
        "explanation": "Call to main-actor-isolated 'update()' in a non-isolated context. Must refer to it via `await S().update()` (if context allows) or run on MainActor. Wait. `struct` implies methods are isolated? Yes. Calling from sync context `f` is error.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_125",
        "title": "Task.detached",
        "description": "True or False?",
        "codeSnippet": "Task.detached {\n    // code\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Creates a task not inheriting context.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_126",
        "title": "Raw string delimiter mismatch",
        "description": "Identify syntax.",
        "codeSnippet": "let s = #\"Hello\"##",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Mismatched delimiters. Must use same number of `#` on both ends. `#\"Hello\"#`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_126",
        "title": "Try! usage",
        "description": "True or False?",
        "codeSnippet": "let x = try! JSONDecoder().decode(S.self, from: data)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True (valid syntax), but crashes if error occurs. Use with caution.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_127",
        "title": "Associated value compare",
        "description": "Identify capability.",
        "codeSnippet": "enum E { case a(Int) }\nlet e1 = E.a(1)\nlet e2 = E.a(1)\nprint(e1 == e2)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Enum with associated values does not conform to `Equatable` by default (prior to Swift 4.1? In recent Swift it DOES conform if Int is Equatable). \nWait. Swift 4.1+ synthesizes Equatable. \nSo this is VALID. \nError: `enum E { case a(Void) }`? \nReal Error: `enum` raw value AND associated value.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_127_real",
        "title": "Enum raw and associated",
        "description": "Identify limitation.",
        "codeSnippet": "enum E: Int {\n    case a(Int) = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Enums cannot have both raw values and associated values.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_127",
        "title": "Optional pattern match",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = 1\nif case .some(let val) = x { print(val) }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Optional is an enum.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_128",
        "title": "Function default parameter let",
        "description": "Identify syntax.",
        "codeSnippet": "func f(x: Int = 1) {\n    x = 2\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Parameters are constants. `x` cannot be reassigned.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_128",
        "title": "Variadic parameter",
        "description": "True or False?",
        "codeSnippet": "func f(_ nums: Int...) { print(nums.count) }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_129",
        "title": "Throwing closure rethrow",
        "description": "Identify flow.",
        "codeSnippet": "func f(fn: () throws -> Void) {\n    fn()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Call to throwing closure `fn` must be marked with `try`. `try fn()`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_129",
        "title": "Do catch pattern",
        "description": "True or False?",
        "codeSnippet": "do {\n    try f()\n} catch let e as MyError {\n    print(e)\n} catch {\n    print(error)\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_130",
        "title": "String index integer",
        "description": "Identify type usage.",
        "codeSnippet": "let s = \"Hello\"\nprint(s[1])",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "String subscript expects `String.Index`, not `Int`. Use `s[s.index(s.startIndex, offsetBy: 1)]`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_130",
        "title": "Substring type",
        "description": "True or False?",
        "codeSnippet": "let s = \"Hello\"\nlet sub = s.prefix(2)\n// sub is String?",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False. `prefix` returns `Substring`. Need `String(sub)` to convert back to String.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_131",
        "title": "Computed property address",
        "description": "Identify limit.",
        "codeSnippet": "struct S { var x: Int { 1 } }\nvar s = S()\nwithUnsafePointer(to: &s.x) { _ in }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Cannot take address (`&`) of a computed property (read-only or not stored).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_131",
        "title": "UnsafePointer",
        "description": "True or False?",
        "codeSnippet": "var x = 10\nwithUnsafePointer(to: &x) { ptr in print(ptr.pointee) }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_132",
        "title": "Switch tuple partial",
        "description": "Identify logic.",
        "codeSnippet": "let p = (1, 10)\nswitch p {\ncase (1, _): break\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Switch is not exhaustive. Must handle non-1 cases or add `default`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_132",
        "title": "Switch binding",
        "description": "True or False?",
        "codeSnippet": "switch (1, 2) {\ncase (let x, let y) where x == y: print(\"Equal\")\ndefault: break\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_133",
        "title": "Range pattern mismatch",
        "description": "Identify syntax.",
        "codeSnippet": "let x = 10\nif case 0..10 = x {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`0..10` is not a valid range operator. Use `0..<10` or `0...10`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_133",
        "title": "If case let",
        "description": "True or False?",
        "codeSnippet": "enum E { case a(Int) }\nlet e = E.a(1)\nif case let .a(x) = e { print(x) }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_134",
        "title": "Optional map return nil",
        "description": "Identify type.",
        "codeSnippet": "let x: Int? = nil\nlet y = x.map { $0 * 2 }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. `y` is `Int?` (nil). \nError: `flatMap` on optional returning type? \nCode: `let y: Int = x.map ...`. Error `Int?` to `Int`. \nReal Error: `compactMap` contains nil result? \nCode: `[1, nil].compactMap { $0 }`. Valid. \nLet's use: `for case let` over optional?",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_134_real",
        "title": "Optional types comparison",
        "description": "Identify type deduction.",
        "codeSnippet": "let x: Int? = 1\nlet y: Int?? = 1\nprint(x == y)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Types `Int?` and `Int??` are not directly comparable. (Wait, Swift might implicitly wrap? Yes). \nThis might be VALID. \nReal Error: `Int?` compared to `String?`. \nCode: `let x: Int? = 1; x == \"1\"`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_134_real_2",
        "title": "Type mismatch comparison",
        "description": "Identify type.",
        "codeSnippet": "let x: Int? = 1\nif x == \"1\" {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot compare `Int?` and `String`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_134",
        "title": "Optional flatMap",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = 1\nlet y = x.flatMap { i in return nil as Int? }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Result is `nil`. `map` would produce `Int??` (nested optional). `flatMap` flattens to `Int?`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_135",
        "title": "Class final override",
        "description": "Identify definition.",
        "codeSnippet": "class A {\n    final func m() {}\n}\nclass B: A {\n    override func m() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Cannot override `final` method `m`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_135",
        "title": "Access control setter",
        "description": "True or False?",
        "codeSnippet": "struct S {\n    private(set) var x = 0\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Public/internal getter, private setter.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_136",
        "title": "Protocol type property",
        "description": "Identify requirement.",
        "codeSnippet": "protocol P {\n    static var x: Int { get }\n}\nstruct S: P {\n    var x: Int = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Protocol requires `static var x`. Struct implements instance `var x`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_136",
        "title": "Class protocol constraint",
        "description": "True or False?",
        "codeSnippet": "protocol P: AnyObject {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `AnyObject` constraint limits adoption to classes.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_137",
        "title": "Dynamic member subscript arg",
        "description": "Identify definition.",
        "codeSnippet": "@dynamicMemberLookup\nstruct S {\n    subscript(dynamicMember member: Int) -> Int { 0 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`dynamicMember` parameter must be `String` (or `KeyPath` in later Swift). `Int` is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_137",
        "title": "CallAsFunction",
        "description": "True or False?",
        "codeSnippet": "struct Adder {\n    func callAsFunction(_ x: Int) -> Int { x + 1 }\n}\nlet add = Adder()\nadd(1)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Swift 5.2+ callable values.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_138",
        "title": "Property wrapper init",
        "description": "Identify syntax.",
        "codeSnippet": "@propertyWrapper struct W {\n    var wrappedValue: Int\n}\nstruct S {\n    @W(initialValue: 1) var x: Int\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Property wrapper init arg label is `wrappedValue`, not `initialValue` (changed in Swift 5.1 beta? Standard is `wrappedValue`). Use `@W(wrappedValue: 1)` or `@W var x = 1`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_138",
        "title": "Property wrapper args",
        "description": "True or False?",
        "codeSnippet": "@W(customArg: 10) var x: Int",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True (assuming init matches).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_139",
        "title": "Opaque type var",
        "description": "Identify usage.",
        "codeSnippet": "var x: some Equatable = 1\nx = \"String\"",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Opaque type `some Equatable` is bound to `Int` (from initialization). Cannot assign `String` later. It is strict typing.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_139",
        "title": "Result map",
        "description": "True or False?",
        "codeSnippet": "let r: Result<Int, Error> = .success(1)\nlet r2 = r.map { $0 * 2 }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Transforms success value.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_140",
        "title": "Defer in guard",
        "description": "Identify flow.",
        "codeSnippet": "guard false else {\n    defer { print(\"A\") }\n    return\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. Prints A. \nError: `guard` using `return value` in Void func? \nReal Error: `lazy` on local variable.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_140_real",
        "title": "Lazy local var",
        "description": "Identify scope.",
        "codeSnippet": "func f() {\n    lazy var x = 0\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`lazy` is only valid on struct/class properties, not local variables.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_140",
        "title": "Sequence next",
        "description": "True or False?",
        "codeSnippet": "var iter = [1].makeIterator()\niter.next()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Returns Int? (1).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_141",
        "title": "Dictionary nil value",
        "description": "Identify usage.",
        "codeSnippet": "var d = [1: 1]\nd[1] = nil",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Valid. Removes key 1. \nError: `d[1] = .some(nil)`? \nReal Error: `Set` insert return value usage.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_141_real",
        "title": "CompactMapValues return",
        "description": "Identify type.",
        "codeSnippet": "let d = [\"a\": \"1\"]\nlet vals = d.compactMap { Int($0.value) }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`compactMap` on Dictionary return an Array, not a Dictionary. Use `compactMapValues` to keep Dictionary.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_141",
        "title": "Zip sequence",
        "description": "True or False?",
        "codeSnippet": "let z = zip([1], [\"a\"])\n// Array(z) is [(1, \"a\")]",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_142",
        "title": "Struct recursive",
        "description": "Identify layout.",
        "codeSnippet": "struct Node {\n    var next: Node\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Value types cannot be recursive (infinite size). `Node` contains `Node`. Must be `class` or `indirect` enum (Node cannot be indirect struct) or use boxing.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_142",
        "title": "Class recursive",
        "description": "True or False?",
        "codeSnippet": "class Node {\n    var next: Node?\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Reference types can be recursive.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_143",
        "title": "SIMD addition",
        "description": "Identify library.",
        "codeSnippet": "import SIMD\nlet a = SIMD2(1, 1)\na + 1",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`SIMD2` requires memberwise operations or another SIMD vector. (Scalar broadcasting works? `a &+ 1`? Standard `+` works with Scalar in recent Swift?). \nLet's assume Valid. \nReal Error: `Int64` vs `Int`. \nCode: `let x: Int64 = 1; let y: Int = x`. Error.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_143_real",
        "title": "Integer types implicit cast",
        "description": "Identify type safety.",
        "codeSnippet": "let x: Int32 = 1\nlet y: Int64 = x",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Swift does not support implicit widening. Must use initializer `Int64(x)`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_143",
        "title": "Stride",
        "description": "True or False?",
        "codeSnippet": "stride(from: 0, to: 10, by: 2)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Returns iterator/sequence 0, 2, 4, 6, 8.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_144",
        "title": "Tuple return ignore",
        "description": "Identify syntax.",
        "codeSnippet": "func f() -> (Int, Int) { (1, 2) }\nlet x = f().0",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `(let x, _) = f()` syntax? \nCode: `let (x, _) = f()`. \nReal Error: `discardableResult` missing on function called for side effect? Warning, not error. \nReal Error: `try` inside `catch`. \nCode: `catch { try f() }` is valid. \nReal Error: `catch` pattern mismatch.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_144_real",
        "title": "Catch pattern mismatch",
        "description": "Identify scope.",
        "codeSnippet": "do {} catch MyError { }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`catch MyError` expects a type? No, catch matches patterns. `MyError` is a type. Should be `catch is MyError` or `catch let error as MyError`? `catch MyError.case` works. Catching a Type is invalid syntax without cast.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_144",
        "title": "Pattern matching tuple",
        "description": "True or False?",
        "codeSnippet": "let p = (0, 0)\nif case (0, 0) = p {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_145",
        "title": "Class default init missing",
        "description": "Identify initialization.",
        "codeSnippet": "class C {\n    var x: Int\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Class `C` has stored property `x` without initial value and no `init`. Compiler error.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_145",
        "title": "Optional compare nil",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = nil\nx == nil",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_146",
        "title": "Range contains end",
        "description": "Identify logic.",
        "codeSnippet": "(0..<10).contains(10)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Returns false. Half-open range excludes upper bound. (Not a compile error but error spotting implies logic check).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_146",
        "title": "Static method dispatch",
        "description": "True or False?",
        "codeSnippet": "struct S { static func f() {} }\nS.f()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_147",
        "title": "Self reassignment class",
        "description": "Identify mutability.",
        "codeSnippet": "class C {\n    func reset() {\n        self = C()\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Cannot assign to `self` in a reference type (class) method. Valid in `mutating` struct methods only.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_147",
        "title": "Self reassignment struct",
        "description": "True or False?",
        "codeSnippet": "struct S {\n    mutating func reset() {\n        self = S()\n    }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_148",
        "title": "Struct vs Class identity",
        "description": "Identify capability.",
        "codeSnippet": "struct S {}\nlet s1 = S(); let s2 = S()\nprint(s1 === s2)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Identity operator `===` is not defined for value types (structs). Only reference types.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_148",
        "title": "Type property",
        "description": "True or False?",
        "codeSnippet": "struct S {\n    static var min = 0\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_149",
        "title": "Extension stored prop again",
        "description": "Identify syntax.",
        "codeSnippet": "extension C {\n    var y: Int = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Extensions cannot add stored properties. (Repeat concept but common error).",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_149",
        "title": "Literal convertible",
        "description": "True or False?",
        "codeSnippet": "struct S: ExpressibleByIntegerLiteral {\n    init(integerLiteral value: Int) {}\n}\nlet s: S = 10",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_150",
        "title": "Inout let argument",
        "description": "Identify mutability.",
        "codeSnippet": "func f(_ x: inout Int) {}\nlet a = 1\nf(&a)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Cannot pass constant `a` as inout argument. `a` must be `var`.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_tf_150",
        "title": "Never return",
        "description": "True or False?",
        "codeSnippet": "func f() -> Never { fatalError() }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "swift_err_201",
        "title": "Sendable closure capture",
        "description": "Identify concurrency safety.",
        "codeSnippet": "class C { var x = 0 }\nfunc f(op: @Sendable () -> Void) {}\nlet c = C()\nf { c.x = 1 }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Closure captures `c` (a non-Sendable class instance) and is marked `@Sendable`. This is a concurrency warning/error (depending on strictness) because `C` is mutable shared state accessed from potentially another isolation domain.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_201",
        "title": "Actor Sendable",
        "description": "True or False?",
        "codeSnippet": "actor A {}\nfunc f<T: Sendable>(_: T) {}\nf(A())",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Actors implicitly conform to `Sendable`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_202",
        "title": "UnsafePointer initialization",
        "description": "Identify lifetime issue.",
        "codeSnippet": "var ptr: UnsafePointer<Int>?\nfunc setup() {\n    var x = 10\n    ptr = UnsafePointer(&x)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Pointer `ptr` outlives the variable `x` (stack allocated local). `x` is destroyed when `setup` returns, leaving `ptr` dangling.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_202",
        "title": "MemoryLayout stride",
        "description": "True or False?",
        "codeSnippet": "struct S { var a: Int8; var b: Int64 }\n// MemoryLayout<S>.stride >= .size",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Stride includes padding for alignment.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_203",
        "title": "Covariance Array",
        "description": "Identify type system nuance.",
        "codeSnippet": "class Animal {}\nclass Cat: Animal {}\nvar cats: [Cat] = []\nvar animals: [Animal] = cats\nanimals.append(Animal())",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "In Swift, Arrays are covariant but copied on write. `animals` is a copy of `cats`. Wait. `[Cat]` to `[Animal]` cast succeeds. `animals` is `[Animal]`. Appending `Animal` is valid for `animals`. \nThe issue: Modifying `animals` does not modify `cats`. It's not a shared reference. \nError: `var animals: [Animal] = cats`. Valid. \nReal Error: `inout` aliasing? \nCode: `func f(a: inout Int) { a += 1 }; var x = 1; f(&x); f(&x)`? \nLet's try: `enum` raw value constructor failure.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_203_real",
        "title": "Enum rawValue failure",
        "description": "Identify initialization return.",
        "codeSnippet": "enum E: Int { case a = 1 }\nlet e: E = E(rawValue: 2)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`init(rawValue:)` returns an Optional `E?`. Returns `nil` if raw value doesn't match. Cannot assign `E?` to `E`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_203",
        "title": "Opaque Result Identity",
        "description": "True or False?",
        "codeSnippet": "func f() -> some Equatable { 1 }\nlet a = f(); let b = f()\n// a == b compiles?",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. compiler knows `a` and `b` come from same function `f()` so underlying type is same.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_204",
        "title": "Associated Type recursion",
        "description": "Identify definition.",
        "codeSnippet": "protocol P {\n    associatedtype T: P\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `associatedtype T = P`? \nReal Error: `protocol P { var p: P }`. \nCode: `protocol P { var prop: P { get } }`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_204_real",
        "title": "Protocol recursive property",
        "description": "Identify usage constraint.",
        "codeSnippet": "protocol P {\n    var child: P { get }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Protocol `P` as a type (existential) does not conform to `P` (pre-Swift 5.7 behavior, or if P has Self requirements). Assuming standard context: Valid? \nIssue: Existential containers usage. `P` isn't `Equatable`. \nLet's use: `associated type` without constraint implementation.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_204_improved",
        "title": "Associated type implementation match",
        "description": "Identify requirements.",
        "codeSnippet": "protocol P { associatedtype V }\nstruct S: P {\n    func foo() -> Int { 1 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Missing implementation for `V`. Compiler cannot infer `V` unless used in signature of required method or explicitly typaliased. `S` doesn't conform.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_204",
        "title": "Nested function generics",
        "description": "True or False?",
        "codeSnippet": "func outer<T>(x: T) {\n    func inner(y: T) { }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Inner function captures generic parameter `T`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_205",
        "title": "Tuple splat",
        "description": "Identify removed feature.",
        "codeSnippet": "func f(x: Int, y: Int) {}\nlet t = (1, 2)\nf(t)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Tuple splat (passing tuple as argument list) was removed in Swift 3. Must call `f(x: t.0, y: t.1)`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_205",
        "title": "Typealias tuple",
        "description": "True or False?",
        "codeSnippet": "typealias Point = (x: Int, y: Int)\nlet p: Point = (1, 2)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_206",
        "title": "Double extension conformance",
        "description": "Identify redundancy.",
        "codeSnippet": "protocol P {}\nextension Int: P {}\nextension Int: P {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Redundant conformance to protocol `P`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_206",
        "title": "Conditional conformance",
        "description": "True or False?",
        "codeSnippet": "extension Array: P where Element: P {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_207",
        "title": "Property Observer in Extension",
        "description": "Identify syntax.",
        "codeSnippet": "extension S {\n    var x: Int { willSet {} }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Extensions can't add stored properties, thus can't observe them unless it's a computed property (but computed properties don't have observers). `x` needs getter.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_207",
        "title": "AnyHashable",
        "description": "True or False?",
        "codeSnippet": "let d: [AnyHashable: Int] = [1: 1, \"a\": 2]",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Type erasing wrapper for Hashable.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_208",
        "title": "Struct let computed",
        "description": "Identify syntax.",
        "codeSnippet": "struct S {\n    let val: Int {\n        return 0\n    }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Computed properties must be `var`, not `let`. `read-only` implies value can change over time (not constant), `let` implies constant.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_208",
        "title": "Unowned optional",
        "description": "True or False?",
        "codeSnippet": "class C {}\nunowned var x: C? = C()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True (since Swift 5.0). `unowned` can be optional.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_209",
        "title": "String slicing index",
        "description": "Identify runtime error.",
        "codeSnippet": "let s = \"Hello\"\nlet i = s.startIndex\nprint(s[s.index(i, offsetBy: 10)])",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Index out of bounds error. Offset 10 is beyond end of \"Hello\".",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_209",
        "title": "String indices",
        "description": "True or False?",
        "codeSnippet": "let s = \"Cafe\\u{301}\" // Caf\ns.count == 4",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Swift strings are grapheme-cluster aware. 'e' + accent is 1 character. 4 total.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_210",
        "title": "Generic where equality",
        "description": "Identify definition.",
        "codeSnippet": "protocol P { associatedtype A }\nfunc f<T: P>(x: T) where T.A == Int {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `where T.A: Int`? (Already covered). \nReal Error: `extension` with `stored property`. \nCode: `func f(a: Int) { a = 1 }` (Already covered). \nReal Error: `dynamicCallable` without method.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_210_real",
        "title": "DynamicCallable requirement",
        "description": "Identify requirements.",
        "codeSnippet": "@dynamicCallable\nstruct S {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`@dynamicCallable` type must implement `dynamicallyCall(withArguments:)` or `dynamicallyCall(withKeywordArguments:)`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_210",
        "title": "ResultBuilder if",
        "description": "True or False?",
        "codeSnippet": "@resultBuilder\nstruct B {\n    static func buildBlock(_ components: Int...) -> Int { components.reduce(0, +) }\n    static func buildOptional(_ component: Int?) -> Int { component ?? 0 }\n}\n@B func f() -> Int { if true { 1 } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `buildOptional` handles `if` without else.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_211",
        "title": "Switch enum unknown case",
        "description": "Identify future-proofing.",
        "codeSnippet": "enum E { case a }\nswitch E.a {\ncase .a: break\n@unknown default: break\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `@unknown case`? \nCode: `case @unknown default:`. Syntax is `@unknown default`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_211_real",
        "title": "Unknown default syntax",
        "description": "Identify syntax.",
        "codeSnippet": "switch x {\n    case @unknown default: break\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Correct syntax is `@unknown default`, not `case @unknown default`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_211",
        "title": "Enum frozen",
        "description": "True or False?",
        "codeSnippet": "@frozen enum E { case a }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Promisses no new cases.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_212",
        "title": "Lazy thread safety",
        "description": "Identify safety.",
        "codeSnippet": "class C {\n    lazy var x = { print(\"Init\"); return 1 }()\n}\n// accessed concurrently",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`lazy` properties are NOT thread-safe in Swift. Concurrent access during initialization may run closure multiple times or crash.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_212",
        "title": "Global actors",
        "description": "True or False?",
        "codeSnippet": "@MainActor class VM {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Isolates class to MainActor.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_213",
        "title": "Discardable result missing",
        "description": "Identify warning suppression.",
        "codeSnippet": "func f() -> Int { 1 }\nf()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Call to `f()` returns a result that is unused. Swift emits a warning. To fix, mark func `@discardableResult` or assign to `_`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_213",
        "title": "Available attribute",
        "description": "True or False?",
        "codeSnippet": "if #available(iOS 15, *) { }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_214",
        "title": "Class let property init",
        "description": "Identify initialization.",
        "codeSnippet": "class C {\n    let x: Int\n    init() { self.init(x: 1) }\n    init(x: Int) { self.x = x }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "In invalid setup? No, delegation logic. `init()` calls `init(x: 1)`. `init(x:)` initializes `x`. Valid. \nReal Error: `let` property reassignment in convenience init? \nCode: `init() { x = 1 }` (missing delegation). Designated init rules.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_214_real",
        "title": "Designated init required",
        "description": "Identify initialization rules.",
        "codeSnippet": "class C {\n    var x: Int\n    init() {\n        self.convenienceSetup()\n        x = 1\n    }\n    func convenienceSetup() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Methods cannot be called on `self` before all stored properties are initialized (`x = 1` comes after).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_214",
        "title": "Defer in init",
        "description": "True or False?",
        "codeSnippet": "class C { var x: Int; init() { x = 1; defer { print(x) } } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Defer runs after init finishes (scope exit).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_215",
        "title": "DidSet in Init",
        "description": "Identify behavior.",
        "codeSnippet": "class C {\n    var x = 0 { didSet { print(\"Set\") } }\n    init() { x = 1 }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Warning/Logic: `didSet` is NOT called during initialization (unlike some other languages). Setting `x = 1` in `init` does NOT print \"Set\". Not a compile error, but common logic bug.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_215",
        "title": "Lazy thread hazard",
        "description": "True or False?",
        "codeSnippet": "// lazy var is not atomic",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_216",
        "title": "Escaping closure capture inout 2",
        "description": "Identify safety.",
        "codeSnippet": "func f(x: inout Int) {\n    let c = { print(x) }\n    Task { c() }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Passing closure `c` to `Task` escapes it. `c` captures `inout x`. Escaping closure cannot capture inout parameter (lifetime issue).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_216",
        "title": "Weak self optional",
        "description": "True or False?",
        "codeSnippet": "{ [weak self] in guard let self = self else { return } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Standard pattern.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_217",
        "title": "Struct Deinit",
        "description": "Identify capability.",
        "codeSnippet": "struct S { deinit {} }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Structs cannot have deinitializers.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_217",
        "title": "Result mapError",
        "description": "True or False?",
        "codeSnippet": "let r: Result<Int, Error> = .failure(E())\nlet r2 = r.mapError { _ in E2() }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_218",
        "title": "Associated type Inference ambiguity",
        "description": "Identify inference.",
        "codeSnippet": "protocol P { associatedtype T }\nstruct S: P {\n    func foo(x: Int) {}\n    func foo(x: String) {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`S` does not specify `typealias T`. Compiler tries to infer from `foo`, but multiple candidates exist (Int or String?). Ambiguous inference, conformance fails.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_218",
        "title": "Protocol where Self",
        "description": "True or False?",
        "codeSnippet": "extension P where Self: Equatable { }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_219",
        "title": "Required init in protocol",
        "description": "Identify requirement.",
        "codeSnippet": "protocol P { init() }\nclass C: P { init() {} }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Class implementation of protocol initializer must be marked `required`. `required init() {}`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_219",
        "title": "Final class init required",
        "description": "True or False?",
        "codeSnippet": "protocol P { init() }\nfinal class C: P { init() {} }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `final` classes don't need `required` because they can't be subclassed.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_220",
        "title": "Variable key in Dictionary",
        "description": "Identify type constraint.",
        "codeSnippet": "class C {}\nvar d = [C(): 1]",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Dictionary keys must conform to `Hashable`. `C` (default class) does not conform to Hashable.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_220",
        "title": "ObjectIdentifier Hashable",
        "description": "True or False?",
        "codeSnippet": "class C {}\nlet id = ObjectIdentifier(C())",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `ObjectIdentifier` is Hashable.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_221",
        "title": "UnsafeBufferPointer bounds",
        "description": "Identify runtime risk.",
        "codeSnippet": "let arr = [1, 2]\narr.withUnsafeBufferPointer { ptr in\n    print(ptr[2])\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Index out of bounds. `ptr` has count 2. Index 2 is invalid. (Unsafe access is undefined behavior/crash).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_221",
        "title": "Array capacity",
        "description": "True or False?",
        "codeSnippet": "var a = [Int]()\na.reserveCapacity(100)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_222",
        "title": "KeyPath let mutation attempt",
        "description": "Identify mutability.",
        "codeSnippet": "class C { let x = 0 }\nvar c = C()\nc[keyPath: \\.x] = 1",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Property `x` is `let`. Writable keypath cannot be formed/used to mutate `x`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_222",
        "title": "WritableKeyPath",
        "description": "True or False?",
        "codeSnippet": "var path: WritableKeyPath<C, Int> = \\.x",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True (if x is var).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_223",
        "title": "Tuple Index Variable",
        "description": "Identify syntax.",
        "codeSnippet": "let t = (1, 2)\nlet i = 0\nprint(t.i)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Tuple members must be accessed with literal indices (`t.0`), not variables.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_223",
        "title": "Void type",
        "description": "True or False?",
        "codeSnippet": "let x: () = ()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `Void` is alias for empty tuple `()`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_224",
        "title": "Set<[Int]>",
        "description": "Identify constraint.",
        "codeSnippet": "let s: Set<[Int]> = []",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`Array<Int>` is not `Hashable` (Array conditional conformance requires Element Hashable, `Int` is, so Array is... Wait. Array IS Hashable in Swift 4.2+? Yes. `[Int]` IS Hashable). \nThis Snippet is valid. \nError: `Set<Any>`? \nCode: `Set<Any>`. Any is not Hashable.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_224_real",
        "title": "Set Any",
        "description": "Identify constraint.",
        "codeSnippet": "let s = Set<Any>()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`Any` does not conform to `Hashable`. Cannot create `Set<Any>`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_224",
        "title": "Double NaN equal",
        "description": "True or False?",
        "codeSnippet": "Double.nan == Double.nan",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "False. NaN is not equal to itself.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_225",
        "title": "Mirror reflection write",
        "description": "Identify capability.",
        "codeSnippet": "struct S { var x = 1 }\nvar s = S()\nlet m = Mirror(reflecting: s)\nm.children.first!.value = 2",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "Mirror API is read-only. Cannot modify properties via Mirror.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_225",
        "title": "Self type access",
        "description": "True or False?",
        "codeSnippet": "protocol P { func f() -> Self }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `Self` (capital S) refers to conforming type.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_226",
        "title": "Inout Variadic",
        "description": "Identify parameter constraint.",
        "codeSnippet": "func f(numbers: inout Int...) {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Variadic parameters cannot be marked `inout`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_226",
        "title": "Fallthrough behavior",
        "description": "True or False?",
        "codeSnippet": "switch 1 {\ncase 1: fallthrough; case 2: print(\"2\")\ndefault: break\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `fallthrough` proceeds to next case body without checking condition.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_227",
        "title": "Weak Struct",
        "description": "Identify constraint.",
        "codeSnippet": "struct S {}\nclass C {\n    weak var s: S?\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`weak` may only be applied to class and class-bound protocol types. Structs are value types.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_227",
        "title": "Generic Subscript",
        "description": "True or False?",
        "codeSnippet": "struct S { subscript<T>(x: T) -> Int { 0 } }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_228",
        "title": "Closure Argument Label",
        "description": "Identify syntax.",
        "codeSnippet": "let c: (label: Int) -> Void = { _ in }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Function types cannot have argument labels (removed in Swift 3). `let c: (Int) -> Void`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_228",
        "title": "Convention C",
        "description": "True or False?",
        "codeSnippet": "let c: @convention(c) () -> Void = {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Defines C function pointer compatibility.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_229",
        "title": "Private set public",
        "description": "Identify access control.",
        "codeSnippet": "struct S {\n    private(set) public var x = 0\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. `public` getter, `private` setter. \nError: `public private(set) var x`? (Order matters?) No. \nReal Error: `extension` deinit. \nCode: `extension C { deinit {} }`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_229_real",
        "title": "Extension Deinit",
        "description": "Identify location.",
        "codeSnippet": "class C {}\nextension C {\n    deinit { print(\"Bye\") }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Deinitializers must be declared within the class definition, not an extension.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_229",
        "title": "Re-throws",
        "description": "True or False?",
        "codeSnippet": "func f(c: () throws -> Void) rethrows { try c() }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_230",
        "title": "Objc Struct",
        "description": "Identify usage.",
        "codeSnippet": "@objc struct S {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`@objc` attribute can only be used with classes, protocols, and enums (Int-based), not structs.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_230",
        "title": "Task Detached Priority",
        "description": "True or False?",
        "codeSnippet": "Task.detached(priority: .background) { }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Detached tasks don't inherit context/priority unless specified.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_231",
        "title": "Await in Sync",
        "description": "Identify context.",
        "codeSnippet": "func work() async {}\nfunc main() {\n    await work()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "`await` can only be used in an asynchronous context (`async` function or `Task` closure). `main` is synchronous (unless marked `@main` and static `main`). Assuming normal func.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_231",
        "title": "Defer LIFO",
        "description": "True or False?",
        "codeSnippet": "func f() {\n    defer { print(1) }\n    defer { print(2) }\n} // prints 2 then 1",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Defers are executed in reverse order of declaration (LIFO stack).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_232",
        "title": "Stored property throws",
        "description": "Identify syntax.",
        "codeSnippet": "class C {\n    var x: Int throws = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Stored properties cannot throw. Only computed properties (getters) can throw. `var x: Int { get throws { ... } }`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_232",
        "title": "Fileprivate vs Private",
        "description": "True or False?",
        "codeSnippet": "class C {\n    private var p = 1\n}\nextension C {\n   func f() { print(p) }\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True (since Swift 4). `private` members are accessible in extensions in the same file.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_233",
        "title": "Repeat syntax",
        "description": "Identify syntax.",
        "codeSnippet": "do {\n    print(\"loop\")\n} while false",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Swift uses `repeat { ... } while condition`, not `do { ... } while`. `do` is for error handling/scope.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_233",
        "title": "Guard exit",
        "description": "True or False?",
        "codeSnippet": "guard true else { print(\"Fail\") }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False. `guard` 'else' block MUST exit the scope (return, break, continue, throw, fatalError).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_234",
        "title": "Case in if mismatch",
        "description": "Identify syntax.",
        "codeSnippet": "enum E { case a }\nif E.a == val { } // val is Any",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot compare Enum with `==` unless it matches type and conforms to Equatable. If `val` is not E, mismatch. But syntax `if case .a = val` is for pattern matching.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_234_real",
        "title": "Default Parameter in Protocol",
        "description": "Identify limit.",
        "codeSnippet": "protocol P {\n    func f(x: Int = 0)\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Default argument values are not permitted in protocol definitions.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_234",
        "title": "Result get",
        "description": "True or False?",
        "codeSnippet": "let r = Result<Int, Error>.success(1)\nlet v = try? r.get()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. `get()` throws the error or returns value.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_235",
        "title": "Invalid Operator",
        "description": "Identify definition.",
        "codeSnippet": "operator +++ {}\nfunc +++ (lhs: Int, rhs: Int) -> Int { lhs + rhs }",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Deprecated syntax. Operator declaration requires `prefix`, `infix`, or `postfix`. `infix operator +++`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_235",
        "title": "Throw in Defer",
        "description": "True or False?",
        "codeSnippet": "func f() throws {\n    defer { try f() } // assume stack overflow ignored\n}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False. `defer` block cannot throw errors out of the block. Errors must be handled inside `defer`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_236",
        "title": "Set index mutation",
        "description": "Identify logic.",
        "codeSnippet": "var s: Set = [1, 2]\nlet i = s.startIndex\ns[i] = 3",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Sets do not support subscript assignment (mutable subscript). Elements are hashed and cannot be just replaced at an index without rehashing/move. Must use `.insert` / `.remove`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_236",
        "title": "Implicit Member Member",
        "description": "True or False?",
        "codeSnippet": "func f(_ c: UIColor) {}\nf(.red)",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Implicit member expression.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_237",
        "title": "Static func override",
        "description": "Identify restriction.",
        "codeSnippet": "class A {\n    static func f() {}\n}\nclass B: A {\n    override static func f() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "`static` methods are final. Cannot be overridden. Use `class func` to allow overriding.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_237",
        "title": "Optional Chaining Function",
        "description": "True or False?",
        "codeSnippet": "let f: (() -> Void)? = nil\nf?()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_238",
        "title": "Required Convenience Init",
        "description": "Identify requirement.",
        "codeSnippet": "class A {\n    required convenience init() { self.init(x: 0) }\n    init(x: Int) {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `required` on convenience? Yes allowed. \nReal Error: `subscript` with `throws` (Pre-Swift 5.5? No, allowed). \nLet's use: `property wrapper` on global variable (Allowed). \nLet's use: `lazy` and `willSet`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_238_real",
        "title": "Lazy WillSet",
        "description": "Identify constraint.",
        "codeSnippet": "class C {\n    lazy var x: Int = 0 { willSet {} }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`lazy` properties cannot have property observers (`willSet` / `didSet`).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_238",
        "title": "Protocol extension default",
        "description": "True or False?",
        "codeSnippet": "protocol P { func f() }\nextension P { func f() {} }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Provides default implementation.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_239",
        "title": "Dynamic var struct",
        "description": "Identify constraint.",
        "codeSnippet": "struct S {\n    dynamic var x = 0\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`dynamic` implies ObjC dispatch, only available in classes (and classes must eventually inherit NSObject or similar for full effect, but restricted to class types).",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_239",
        "title": "Unowned unsafe",
        "description": "True or False?",
        "codeSnippet": "unowned(unsafe) var x: C",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Equivalent to `unsafe_unretained`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_240",
        "title": "Class func in Struct",
        "description": "Identify syntax.",
        "codeSnippet": "struct S {\n    class func f() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Structs use `static func`, not `class func`. `class func` implies overridability in classes.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_240",
        "title": "Nil Coalescing precedence",
        "description": "True or False?",
        "codeSnippet": "let x = 1 ?? 2",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False (Warning/Error). Left side `1` is not optional. `??` requires optional on left.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_241",
        "title": "Protocol Optional Requirement",
        "description": "Identify syntax.",
        "codeSnippet": "protocol P {\n    optional func f()\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "`optional` requirements are only allowed in `@objc` protocols.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_241",
        "title": "Escaping optional closure",
        "description": "True or False?",
        "codeSnippet": "func f(c: (() -> Void)?) { g(c) }\nfunc g(_ c: (() -> Void)?) {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Optional closures are implicitly escaping.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_242",
        "title": "Reference to member of protocol",
        "description": "Identify syntax.",
        "codeSnippet": "protocol P { static func f() }\nP.f()",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot call static method on protocol type `P` unless there is a default implementation extension visible. If no extension, error.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_242",
        "title": "Metatype type",
        "description": "True or False?",
        "codeSnippet": "let t: Int.Type = Int.self",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_243",
        "title": "Tuple Comparable",
        "description": "Identify limitation.",
        "codeSnippet": "let t1 = (1, 2, 3, 4, 5, 6, 7)\nlet t2 = (1, 2, 3, 4, 5, 6, 7)\nprint(t1 < t2)",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Tuples confirm to `Comparable` (and `Equatable`) only up to arity 6. arity 7 tuples are not comparable/equatable.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_243",
        "title": "Indirect Enum",
        "description": "True or False?",
        "codeSnippet": "indirect enum E { case node(E) }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. Enables recursive enums.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_244",
        "title": "AnyObject Struct",
        "description": "Identify constraint.",
        "codeSnippet": "struct S: AnyObject {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "`AnyObject` is a protocol that only classes can conform to. Structs are value types.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_244",
        "title": "Empty switch",
        "description": "True or False?",
        "codeSnippet": "let x = 1\nswitch x {}",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": false,
        "explanation": "False. Switch must be exhaustive. Int is not empty.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_245",
        "title": "Generic Extension Requirement",
        "description": "Identify syntax error.",
        "codeSnippet": "extension Array<Int> {}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 0,
        "explanation": "Cannot extend a specialized generic type directly. Syntax is `extension Array where Element == Int {}`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_245",
        "title": "Unicode Scalar",
        "description": "True or False?",
        "codeSnippet": "let s: Unicode.Scalar = \"a\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True. String literal convertible.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_246",
        "title": "Self in class var",
        "description": "Identify scope.",
        "codeSnippet": "class C {\n    var x = Self.y\n    static var y = 1\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Cannot access `Self` (dynamic type) in property initializer context (before init). Wait. `static var y` is available. Issue is `Self` usage vs `C.y`. Is `Self` available in instance property init? No.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_246",
        "title": "Main attribute",
        "description": "True or False?",
        "codeSnippet": "@main struct App { static func main() {} }",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_247",
        "title": "Unowned safe optional",
        "description": "Identify runtime safety.",
        "codeSnippet": "class C {}\nweak var w: C? // ok\nunowned var u: C? // ok\nunowned(safe) var s: C? // Error?",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 3,
        "explanation": "`unowned(safe)` is the default `unowned`. It cannot be optional? No, `unowned optional` is allowed since Swift 5.0. \nWait. \nIs there `unowned(safe)` syntax? It's just `unowned`. `unowned(unsafe)` exists. `unowned(safe)` is not valid syntax.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_247",
        "title": "String multiline",
        "description": "True or False?",
        "codeSnippet": "let s = \"\"\"\n  line1\n  line2\n  \"\"\"",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_248",
        "title": "Protocol let requirement",
        "description": "Identify rule.",
        "codeSnippet": "protocol P {\n    let name: String\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 1,
        "explanation": "Protocols cannot specify `let` requirements. Must use `var name: String { get }`.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_248",
        "title": "Function Types Void",
        "description": "True or False?",
        "codeSnippet": "(Void) -> Void is same as () -> ()",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_249",
        "title": "Duplicate subscript",
        "description": "Identify ambiguity.",
        "codeSnippet": "struct S {\n    subscript(i: Int) -> Int { 0 }\n    subscript(i: Int) -> String { \"\" }\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": -1,
        "explanation": "Valid overload by return type. Usage might be ambiguous if not contextualized. \nReal Error: `lazy` in `struct`? \nCode: `struct S { lazy var x = 0 }`. \nIf struct is constant `let s = S()`, cannot access `s.x` (mutating). But valid definition. \nLet's use: `catch` pattern exhaustivity.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_249_real",
        "title": "Catch exhaustivity",
        "description": "Identify error handling.",
        "codeSnippet": "enum E: Error { case a }\nfunc f() throws {\n    do { throw E.a }\n    catch E.a {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 4,
        "explanation": "Catch block is not exhaustive. `catch E.a` handles one case, but `catch` must be exhaustive or propagate. Missing default `catch` or conformance. Wait. `func f() throws` propagates? No, `do-catch` handles, but if incomplete, does it propagate? \nYes, if `try` is inside `do`, and `catch` doesn't match, it propagates IF the function throws. Snippet is valid? \nAh. `catch E.a` leaves other errors. Function throws. Valid. \nLet's go back to `subscript`. Overloading by return type ALONE causes ambiguity easily, but IS valid code. \nReal Error: `subscript` `set` without `get`? \nCode: `subscript(i: Int) -> Int { set {} }`. \nExplanation: Subscript must have a getter.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_249",
        "title": "Nil Coalescing Chaining",
        "description": "True or False?",
        "codeSnippet": "let x: Int? = nil\nlet y = x ?? x ?? 0",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_err_250",
        "title": "Extension override",
        "description": "Identify limitation.",
        "codeSnippet": "class C { func f() {} }\nextension C {\n    override func f() {}\n}",
        "type": "errorSpotting",
        "language": "swift",
        "errorLineIndex": 2,
        "explanation": "Cannot override a declaration in an extension of the same class (cannot override main class declarations in extension either). `override` not needed/allowed? Or just redefinition error.",
        "difficultyLevel": 3
    },
    {
        "id": "swift_tf_250",
        "title": "Property Wrapper Projected Value",
        "description": "True or False?",
        "codeSnippet": "@propertyWrapper struct W {\n    var wrappedValue: Int\n    var projectedValue: String { \"$\" }\n}\nstruct S { @W var x = 0 }\n// S().$x is String",
        "type": "trueOrFalse",
        "language": "swift",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    }
]