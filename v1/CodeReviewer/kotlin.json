[
    {
        "id": "kotlin_err_1",
        "title": "Val Reassignment",
        "description": "Identify variable mutability issue.",
        "codeSnippet": "fun main() {\n    val x = 10\n    x = 20\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Variables declared with `val` are read-only (immutable reference). Cannot be reassigned. Use `var` for mutable variables.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_1",
        "title": "Nullable Type",
        "description": "True or False?",
        "codeSnippet": "var name: String? = null",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `String?` allows null values.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_2",
        "title": "Null Safety",
        "description": "Identify null safety violation.",
        "codeSnippet": "var a: String = \"Hello\"\na = null",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Variables declared as non-nullable type `String` cannot hold `null`. Must use `String?`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_2",
        "title": "String Interpolation",
        "description": "True or False?",
        "codeSnippet": "val x = 10\nprintln(\"Value: $x\")",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Kotlin supports string templates with `$`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_3",
        "title": "Type Mismatch",
        "description": "Identify type error.",
        "codeSnippet": "var x: Int = 10\nx = \"Hello\"",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Cannot assign `String` to strict `Int` variable. Kotlin is statically typed.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_3",
        "title": "Expression Body",
        "description": "True or False?",
        "codeSnippet": "fun sum(a: Int, b: Int) = a + b",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Single-expression functions can omit braces and return type inference.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_4",
        "title": "List Mutation",
        "description": "Identify collection mutability error.",
        "codeSnippet": "val list = listOf(1, 2, 3)\nlist.add(4)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`listOf` returns a read-only `List`. It does not have an `add` method. Use `mutableListOf` for mutable lists.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_4",
        "title": "When Expression",
        "description": "True or False?",
        "codeSnippet": "val x = 1\nval s = when (x) {\n    1 -> \"One\"\n    else -> \"Other\"\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `when` can be used as an expression returning a value.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_5",
        "title": "Return Type Missing",
        "description": "Identify function syntax error.",
        "codeSnippet": "fun getNumber() {\n    return 42\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Function defined to return `Unit` (default) but returns an integer. Must specify return type `: Int`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_5",
        "title": "Range Check",
        "description": "True or False?",
        "codeSnippet": "if (5 in 1..10) {\n    print(\"Yes\")\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `in 1..10` checks if value is within range.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_6",
        "title": "Lateinit Primitive",
        "description": "Identify property modifier usage.",
        "codeSnippet": "lateinit var x: Int",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`lateinit` modifier is not allowed on primitive types like `Int`. Use object types (Integer/boxed) or default value.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_6",
        "title": "Data Class",
        "description": "True or False?",
        "codeSnippet": "data class User(val name: String, val age: Int)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Data class automatically generates `equals`, `hashCode`, `toString`, `copy`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_7",
        "title": "Const Val Local",
        "description": "Identify const usage.",
        "codeSnippet": "fun main() {\n    const val PI = 3.14\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`const val` is only allowed at the top level or inside an `object` (or companion object). Cannot be a local variable.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_7",
        "title": "Safe Call Operator",
        "description": "True or False?",
        "codeSnippet": "val s: String? = null\nval len = s?.length",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `?.` safely accesses property, returning null if receiver is null.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_8",
        "title": "Interface Constructor",
        "description": "Identify interface restriction.",
        "codeSnippet": "interface I(val x: Int) {\n    fun f()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Interfaces cannot have constructors. Properties in interfaces cannot have backing fields/constructors.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_8",
        "title": "Elvis Operator",
        "description": "True or False?",
        "codeSnippet": "val name: String? = null\nval s = name ?: \"Guest\"",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `?:` returns the left operand if not null, otherwise the right operand.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_9",
        "title": "Abstract Class Instantiation",
        "description": "Identify instantiation error.",
        "codeSnippet": "abstract class Shape\nfun main() {\n    val s = Shape()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Abstract classes cannot be instantiated directly.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_9",
        "title": "Multiline String",
        "description": "True or False?",
        "codeSnippet": "val text = \"\"\"\n    Line 1\n    Line 2\n\"\"\"",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Triple quotes create raw strings spanning multiple lines.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_10",
        "title": "Private Access",
        "description": "Identify access visibility.",
        "codeSnippet": "class A {\n    private val x = 10\n}\nfun main() {\n    val a = A()\n    print(a.x)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 5,
        "explanation": "`x` is private to class `A`. Cannot be accessed from outside.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_10",
        "title": "Extension Function",
        "description": "True or False?",
        "codeSnippet": "fun String.addExclamation() = this + \"!\"",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Adds a method to `String` class via extension.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_11",
        "title": "Break in If",
        "description": "Identify loop control usage.",
        "codeSnippet": "fun f() {\n    if (true) {\n        break\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`break` and `continue` are only allowed inside loops, not simple `if` blocks (unless inside a loop).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_11",
        "title": "Infix Function",
        "description": "True or False?",
        "codeSnippet": "infix fun Int.plus(x: Int) = this + x\nval y = 1 plus 2",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Infix notation allows omitting dot and parentheses.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_12",
        "title": "Val property reassignment in class",
        "description": "Identify property mutability.",
        "codeSnippet": "class User(val name: String)\nfun main() {\n    val u = User(\"Bob\")\n    u.name = \"Alice\"\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`name` is declared as `val` in the primary constructor. It is read-only.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_12",
        "title": "Default Arguments",
        "description": "True or False?",
        "codeSnippet": "fun greet(name: String = \"World\") {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Default parameter values are supported.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_13",
        "title": "Function Overload Ambiguity",
        "description": "Identify call ambiguity (conceptual error spotting, or compilation error).",
        "codeSnippet": "fun f(x: Int) {}\nfun f(x: Any) {}\nf(1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Actually this is Valid. `f(Int)` is more specific than `f(Any)`. \nLet's try: `vararg` vs array. \nSnippet: `fun f(vararg x: Int) {}` \nUsage: `val a = intArrayOf(1); f(a)` \nError: Must use spread operator `f(*a)`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_13_real",
        "title": "Spread Operator Missing",
        "description": "Identify vararg usage.",
        "codeSnippet": "fun printNums(vararg nums: Int) {}\nval list = intArrayOf(1, 2)\nprintNums(list)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Cannot pass an array directly to a `vararg` parameter. Must use the spread operator: `printNums(*list)`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_13",
        "title": "Smart Cast",
        "description": "True or False?",
        "codeSnippet": "fun f(x: Any) {\n    if (x is String) {\n        print(x.length)\n    }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Compiler smart casts `x` to `String` inside the if block.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_14",
        "title": "Companion Object Access",
        "description": "Identify static access syntax.",
        "codeSnippet": "class C {\n    companion object {\n        fun foo() {}\n    }\n}\nval x = C().foo()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 5,
        "explanation": "Companion object members are accessed via the class name, not an instance. `C.foo()`, not `C().foo()`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_14",
        "title": "Object Declaration",
        "description": "True or False?",
        "codeSnippet": "object Singleton {\n    val x = 1\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Defines a singleton object.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_15",
        "title": "When no else",
        "description": "Identify exhaustiveness.",
        "codeSnippet": "val x = 1\nval s = when(x) {\n    1 -> \"One\"\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "'when' expression must be exhaustive. Since `x` is Int, `else` branch is required.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_15",
        "title": "Try Expression",
        "description": "True or False?",
        "codeSnippet": "val x = try { \"1\".toInt() } catch (e: Exception) { 0 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `try` is an expression in Kotlin.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_16",
        "title": "Override without modifier",
        "description": "Identify inheritance syntax.",
        "codeSnippet": "open class Base {\n    open fun f() {}\n}\nclass Derived : Base() {\n    fun f() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "Must use `override` modifier when overriding a function. `override fun f() {}`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_16",
        "title": "Init Block",
        "description": "True or False?",
        "codeSnippet": "class C {\n    init { print(\"Created\") }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `init` blocks are executed during instance initialization.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_17",
        "title": "Inheritance final class",
        "description": "Identify class inheritance restriction.",
        "codeSnippet": "class Base\nclass Derived : Base()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Classes are `final` by default in Kotlin. `Base` must be marked `open` to be inherited from.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_17",
        "title": "Is Check",
        "description": "True or False?",
        "codeSnippet": "val x: Any = \"Hi\"\nval isString = x is String",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `is` checks the runtime type.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_18",
        "title": "Character literal double quotes",
        "description": "Identify literal syntax.",
        "codeSnippet": "val c: Char = \"A\"",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Characters must use single quotes `'A'`. Double quotes are for Strings.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_18",
        "title": "Function Type",
        "description": "True or False?",
        "codeSnippet": "val sum: (Int, Int) -> Int = { a, b -> a + b }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Variable can hold a function type.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_19",
        "title": "Array Index Out of Bounds",
        "description": "Identify runtime error.",
        "codeSnippet": "val arr = arrayOf(1, 2)\nprint(arr[2])",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Index 2 is out of bounds for array of size 2 (indices 0, 1).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_19",
        "title": "Unit Return",
        "description": "True or False?",
        "codeSnippet": "fun f(): Unit {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `Unit` is equivalent to void.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_20",
        "title": "String comparison ===",
        "description": "Identify equality usage.",
        "codeSnippet": "val s1 = String(\"Hello\".toCharArray())\nval s2 = String(\"Hello\".toCharArray())\n// s1 === s2",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`===` checks reference equality. `s1` and `s2` are different objects, so false. Use `==` for structural equality (content check). \nWait, this is `errorSpotting`. Is false statement an error? The code snippet is just the check, maybe inside print? \nIf `if (s1 === s2)` behaves unexpectedly. \nLet's provide a syntax error. \nCode: `if (s1 = s2)`",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_20_real",
        "title": "If Assignment",
        "description": "Identify syntax error.",
        "codeSnippet": "var x = 1\nif (x = 2) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Single `=` is assignment. `if` requires boolean condition (e.g., `x == 2`). Kotlin does not allow assignment in expression context like C.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_20",
        "title": "While Loop",
        "description": "True or False?",
        "codeSnippet": "while (true) { break }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_21",
        "title": "Variable Redefinition",
        "description": "Identify scope error.",
        "codeSnippet": "fun main() {\n    val x = 1\n    val x = 2\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Variable `x` is already defined in the scope. Cannot redeclare.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_21",
        "title": "Protected in Interface",
        "description": "True or False?",
        "codeSnippet": "interface I {\n    protected fun f()\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False. Interface members are public by default. `protected` is not allowed in interfaces.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_22",
        "title": "Data Class No Params",
        "description": "Identify data class rules.",
        "codeSnippet": "data class Empty()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Data classes must have at least one primary constructor parameter.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_22",
        "title": "Reified Inline",
        "description": "True or False?",
        "codeSnippet": "inline fun <reified T> isType(a: Any) = a is T",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `reified` allows checking generic type at runtime in inline functions.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_23",
        "title": "Sealed Class Direct Instantiation",
        "description": "Identify sealed class usage.",
        "codeSnippet": "sealed class Result\nfun main() { val r = Result() }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Sealed classes are abstract and cannot be instantiated directly.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_23",
        "title": "Destructuring",
        "description": "True or False?",
        "codeSnippet": "val (a, b) = Pair(1, 2)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Destructuring declarations work on data classes/pairs.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_24",
        "title": "Nothing Return",
        "description": "Identify syntax/usage.",
        "codeSnippet": "fun f(): Nothing {\n    print(\"Hi\")\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Function returning `Nothing` must never return (must throw exception or loop forever). This function returns Unit normally.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_24",
        "title": "Operator Overloading",
        "description": "True or False?",
        "codeSnippet": "operator fun Int.times(str: String) = str.repeat(this)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `times` overloads the `*` operator.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_25",
        "title": "Secondary Constructor Call",
        "description": "Identify constructor delegation.",
        "codeSnippet": "class C(val x: Int) {\n    constructor() : super() {\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "If class has a primary constructor, secondary constructor must delegate to it (directly or indirectly) via `this(...)`, not `super()`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_25",
        "title": "Tailrec",
        "description": "True or False?",
        "codeSnippet": "tailrec fun f(x: Int): Int = if (x==0) 0 else f(x-1)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Tail recursive optimization.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_26",
        "title": "Unsafe Assertion",
        "description": "Identify null safety limitation.",
        "codeSnippet": "val s: String? = null\nval l = s!!.length",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`!!` operator throws NullPointerException if the operand is null. This will crash at runtime.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_26",
        "title": "C-Style For Loop",
        "description": "True or False?",
        "codeSnippet": "for (var i = 0; i < 10; i++) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False. Kotlin does not support C-style for loops. Use ranges: `for (i in 0 until 10)`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_27",
        "title": "Map Nullable Return",
        "description": "Identify handling of map access.",
        "codeSnippet": "val map = mapOf(1 to \"One\")\nval s: String = map[2]",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Map access `map[key]` returns a nullable value (`String?`) because key might be missing. Cannot assign to non-nullable `String`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_27",
        "title": "Float Literal",
        "description": "True or False?",
        "codeSnippet": "val f: Float = 3.14F",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `F` suffix denotes Float.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_28",
        "title": "Val without initialization",
        "description": "Identify initialization requirement.",
        "codeSnippet": "fun main() {\n    val x: Int\n    print(x)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Local variable `x` must be initialized before use.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_28",
        "title": "Named Arguments",
        "description": "True or False?",
        "codeSnippet": "fun f(a: Int, b: Int) {}\nf(b = 2, a = 1)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Arguments can be reordered using names.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_29",
        "title": "If Expression Else Missing",
        "description": "Identify expression syntax.",
        "codeSnippet": "val x = 10\nval y = if (x > 5) 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`if` used as an expression must have an `else` branch.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_29",
        "title": "Internal Visibility",
        "description": "True or False?",
        "codeSnippet": "internal class C {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `internal` means visible within the same module.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_30",
        "title": "Interface State",
        "description": "Identify interface capability.",
        "codeSnippet": "interface I {\n    val x: Int = 10\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Property initializers are not allowed in interfaces (no backing field). Can define abstract property or property with custom accessor.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_30",
        "title": "Comparison Operator",
        "description": "True or False?",
        "codeSnippet": "val a = \"Hello\"\nval b = \"Hello\"\nval eq = a == b",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `==` in Kotlin uses unnecessary `equals()`, so it checks content structural equality.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_31",
        "title": "Package declaration location",
        "description": "Identify file structure.",
        "codeSnippet": "import java.util.*\npackage com.example",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`package` declaration must be at the top of the file, before imports.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_31",
        "title": "DownTo Range",
        "description": "True or False?",
        "codeSnippet": "for (i in 10 downTo 1) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Creates a descending progression.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_32",
        "title": "Val Function Parameter reassignment",
        "description": "Identify parameter mutability.",
        "codeSnippet": "fun f(x: Int) {\n    x = x + 1\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Function parameters are `val` (immutable). Cannot reassign `x`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_32",
        "title": "Vararg Parameter",
        "description": "True or False?",
        "codeSnippet": "fun f(vararg strings: String) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_33",
        "title": "Type Inference Ambiguity",
        "description": "Identify declaration.",
        "codeSnippet": "val x\nx = 10",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Must specify type explicitly or initialize variable when declaring `val x`. Compiler cannot infer type without initialization.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_33",
        "title": "As Cast",
        "description": "True or False?",
        "codeSnippet": "val x: Any = \"Hi\"\nval s = x as String",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Unsafe cast. Throws if failed (but here succeeds).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_34",
        "title": "Private Class Access",
        "description": "Identify visibility scope.",
        "codeSnippet": "private class C\npublic fun f(): C = C()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Public function `f` exposes private type `C` as return type. Visibility mismatch.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_34",
        "title": "Safe Cast",
        "description": "True or False?",
        "codeSnippet": "val x: Any = 1\nval s: String? = x as? String",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `as?` returns null if cast fails.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_35",
        "title": "Abstract function body",
        "description": "Identify abstract syntax.",
        "codeSnippet": "abstract class C {\n    abstract fun f() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Abstract functions cannot have a body.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_35",
        "title": "Labeled Return",
        "description": "True or False?",
        "codeSnippet": "fun f() {\n    listOf(1).forEach lit@ {\n        if (it == 0) return@lit\n        print(it)\n    }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Returns from lambda, not enclosing function.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_36",
        "title": "Null check smart cast fail",
        "description": "Identify smart cast limitation.",
        "codeSnippet": "class C {\n    var x: String? = \"Hi\"\n    fun f() {\n        if (x != null) {\n            print(x.length)\n        }\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "Smart cast to non-nullable failed because `x` is a mutable property (`var`) of a class, which could be modified by another thread/method between check and usage.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_36",
        "title": "Underscore in Number",
        "description": "True or False?",
        "codeSnippet": "val mill = 1_000_000",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Underscores improve readability.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_37",
        "title": "Const Int Type",
        "description": "Identify invalid type.",
        "codeSnippet": "const val x = \"Hi\"",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. String is allowed for const. \nRefine: `const val x = Date()`? \nError: `const` only allows primitives and String. \nCode: `const val D = java.util.Date()`",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_37_real",
        "title": "Const Type Restriction",
        "description": "Identify const requirement.",
        "codeSnippet": "class C {}\nconst val x = C()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Const properties are limited to String and primitives. Cannot be object instance of custom class.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_37",
        "title": "Function default return",
        "description": "True or False?",
        "codeSnippet": "fun f() = print(\"Hi\")",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Returns Unit type inferred.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_38",
        "title": "Enum Inheritance",
        "description": "Identify class hierarchy.",
        "codeSnippet": "open enum class E { A, B }\nclass C : E()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Enum classes cannot be `open` and cannot be subclassed.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_38",
        "title": "Nested Class",
        "description": "True or False?",
        "codeSnippet": "class Outer {\n    class Inner\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `Inner` is nested (static-like), not inner (member).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_39",
        "title": "Inner class access",
        "description": "Identify nested usage.",
        "codeSnippet": "class Outer {\n    val x = 1\n    class Nested {\n        fun f() = x\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "Nested class defaults to static-like behavior and cannot access outer instance members (`x`). Use `inner class`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_39",
        "title": "Inner Keyword",
        "description": "True or False?",
        "codeSnippet": "class Outer {\n    inner class Inner\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `Inner` holds reference to `Outer`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_40",
        "title": "Super keyword confusion",
        "description": "Identify call.",
        "codeSnippet": "class C : Any() {\n    fun f() {\n        super.f()\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`Any` does not have a method `f`. `super` usage must refer to existing member in parent.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_40",
        "title": "Getter Syntax",
        "description": "True or False?",
        "codeSnippet": "val isEmpty: Boolean\n    get() = true",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Custom getter syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_41",
        "title": "Setter on Val",
        "description": "Identify property mutability.",
        "codeSnippet": "val x: Int = 0\n    set(value) { field = value }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`val` properties are read-only and cannot have a `set` accessor.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_41",
        "title": "Let Scope Function",
        "description": "True or False?",
        "codeSnippet": "val str: String? = \"Hi\"\nstr?.let { print(it) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Executes block if not null.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_42",
        "title": "Field identifier usage",
        "description": "Identify context.",
        "codeSnippet": "fun f() {\n    val field = 10\n    print(field)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. `field` is only a keyword inside accessors. Can be used as variable name. \nError: `class` vs `object` usage? \nCode: `class C { object P {} }`. Valid. \nReal Error: `sealed class` constructors are private/protected. \nCode: `sealed class S public constructor()`. \nError: Sealed class constructors are private by default and cannot be public.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_42_real",
        "title": "Sealed Class Constructor Visibility",
        "description": "Identify rule.",
        "codeSnippet": "sealed class S public constructor()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Sealed class constructors are constrained to `private` (or `protected` in later versions). Cannot be `public`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_42",
        "title": "Repeat Loop",
        "description": "True or False?",
        "codeSnippet": "repeat(3) { print(\"Hi\") }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Standard library function for repetition.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_43",
        "title": "Destructuring declaration missing component",
        "description": "Identify requirement.",
        "codeSnippet": "class C(val x: Int)\nval (a) = C(1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Normal classes do not support destructuring unless `componentN()` operators are defined. `data class` provides them automatically.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_43",
        "title": "Apply Scope Function",
        "description": "True or False?",
        "codeSnippet": "val l = mutableListOf(1).apply { add(2) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `apply` returns the object itself (`l` is list [1, 2]).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_44",
        "title": "Assignment is not expression",
        "description": "Identify syntax difference.",
        "codeSnippet": "var a = 1\nvar b = 2\nval c = (a = b)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Assignment is not an expression in Kotlin and returns Unit (deprecated in earlier versions, now Unit). Assigning `Unit` to `c` is likely unintended if expecting value, but technically allowed (c becomes Unit). Is it syntax error? In many contexts yes or warns. \nWait. `val c = (a = b)`. `a = b` returns `Unit`. `c` is Unit. Valid code. \nReal Error: `return` in logic? \nCode: `val x = return 1`. Valid (x is Nothing). \nLet's try: `char` literal length.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_44_real",
        "title": "Char Literal Length",
        "description": "Identify literal syntax.",
        "codeSnippet": "val c = 'AB'",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Character literal must contain exactly one character.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_44",
        "title": "Type Alias",
        "description": "True or False?",
        "codeSnippet": "typealias Name = String",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Creates alias for existing type.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_45",
        "title": "Try Catch Scope",
        "description": "Identify scope.",
        "codeSnippet": "try {\n    val x = 1\n} catch (e: Exception) {}\nprint(x)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`x` is defined inside `try` block. Not visible outside.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_45",
        "title": "Also Scope Function",
        "description": "True or False?",
        "codeSnippet": "val x = 1.also { print(it) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Returns object, performs side effect.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_46",
        "title": "Function declaration inside function",
        "description": "Identify scope.",
        "codeSnippet": "fun outer() {\n    fun inner() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Local functions are supported. \nError: `abstract` property in non-abstract class. \nCode: `class C { abstract val x: Int }`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_46_real",
        "title": "Abstract Property",
        "description": "Identify abstract rules.",
        "codeSnippet": "class C {\n    abstract val x: Int\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Class `C` is not abstract, so it cannot contain abstract members.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_46",
        "title": "Comment Syntax",
        "description": "True or False?",
        "codeSnippet": "/* Multi \n line */",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_47",
        "title": "Import Wildcard conflict",
        "description": "Identify resolution.",
        "codeSnippet": "import java.sql.Date\nimport java.util.Date\nval d = Date()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Ambiguous reference `Date` matches both imports. Must use fully qualified name or alias.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_47",
        "title": "Import Alias",
        "description": "True or False?",
        "codeSnippet": "import java.util.Date as UtilDate",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Resolves conflicts.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_48",
        "title": "This in static context",
        "description": "Identify scope usage.",
        "codeSnippet": "class C {\n    companion object {\n        fun f() { print(this) }\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`this` in companion object refers to the Companion Object instance, not an instance of `C`. Is this an error? No. Warning maybe? \nLet's try: `super` in companion object. \nCode: `super.toString()`. Valid if companion inherits. \nReal Error: `const val` with function call (covered). \nReal Error: `operator` modifier on non-operator function name? \nCode: `operator fun f() {}`. \nExplanation: `f` is not a valid operator name (invoke, get, plus, etc).",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_48_real",
        "title": "Invalid Operator Name",
        "description": "Identify naming rule.",
        "codeSnippet": "operator fun foo() {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`foo` is not a valid operator convention name. `operator` modifier is inapplicable.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_48",
        "title": "CheckNotNull",
        "description": "True or False?",
        "codeSnippet": "val x = checkNotNull(null)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False (Runtime). Throws IllegalStateException.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_49",
        "title": "Break Label undefined",
        "description": "Identify syntax error.",
        "codeSnippet": "fun f() {\n    break@loop\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Label `@loop` is not defined or reachable.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_49",
        "title": "If Else assignment",
        "description": "True or False?",
        "codeSnippet": "val max = if (a > b) a else b",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_50",
        "title": "When else branch missing enum",
        "description": "Identify exhaustiveness.",
        "codeSnippet": "enum class Color { Red, Green }\nfun f(c: Color) {\n    when(c) {\n        Color.Red -> {}\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`when` must be exhaustive. Missing `Green` branch.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_tf_50",
        "title": "TODO function",
        "description": "True or False?",
        "codeSnippet": "fun f(): Int = TODO()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `TODO()` throws exception (`NotImplementedError`) and returns `Nothing`.",
        "difficultyLevel": 1
    },
    {
        "id": "kotlin_err_101",
        "title": "Val Unsafe Override",
        "description": "Identify inheritance restriction.",
        "codeSnippet": "open class Base {\n    open var x: Int = 1\n}\nclass Derived : Base() {\n    override val x: Int = 2\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "Cannot override a `var` (mutable) property with `val` (read-only). This restricts access allowed by the base class. Overriding `val` with `var` IS allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_101",
        "title": "JvmOverloads",
        "description": "True or False?",
        "codeSnippet": "class C @JvmOverloads constructor(x: Int, y: Int = 0)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Generates overloaded constructors for Java interoperability.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_102",
        "title": "Tailrec non-tail call",
        "description": "Identify optimization failure.",
        "codeSnippet": "tailrec fun factorial(n: Int): Int {\n    if (n == 1) return 1\n    return n * factorial(n - 1)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "The recursive call is not the last operation (multiplication happens after return). `tailrec` modifier will trigger a warning/error that the function is not tail recursive.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_102",
        "title": "Infix parameter count",
        "description": "True or False?",
        "codeSnippet": "infix fun Int.add(a: Int, b: Int) = this + a + b",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False. Infix functions must have exactly one value parameter.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_103",
        "title": "Noinline Parameter",
        "description": "Identify inline rules.",
        "codeSnippet": "inline fun f(noinline block: () -> Unit) {\n    block()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. `noinline` prevents inlining of the lambda. \nError: `crossinline` with non-local return? \nCode: `inline fun f(crossinline b: () -> Unit) { b() }`. Usage: `f { return }`. \nError: `return` is not allowed in crossinline lambda.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_103_real",
        "title": "Crossinline Return",
        "description": "Identify lambda return.",
        "codeSnippet": "inline fun runOp(crossinline op: () -> Unit) {\n    op()\n}\nfun main() {\n    runOp { return }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "`crossinline` parameter lambdas cannot contain non-local returns (`return`). Can only use `return@runOp`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_103",
        "title": "Value Class",
        "description": "True or False?",
        "codeSnippet": "@JvmInline value class Password(val s: String)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Wraps type without allocation overhead (where possible).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_104",
        "title": "Suspend function call",
        "description": "Identify coroutine context.",
        "codeSnippet": "suspend fun work() {}\nfun main() {\n    work()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Suspend function `work` must be called from a coroutine or another suspend function.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_104",
        "title": "Sealed Interface",
        "description": "True or False?",
        "codeSnippet": "sealed interface Expr {\n    class Num(val v: Int): Expr\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Sealed interfaces allow implementations in restricted hierarchy (same package/module).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_105",
        "title": "Delegated Property var val mismatch",
        "description": "Identify delegate requirement.",
        "codeSnippet": "class Delegate {\n    operator fun getValue(thisRef: Any?, property: Any?): String = \"\"\n}\nvar p: String by Delegate()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "Property `p` is `var` (mutable), but delegate only provides `getValue`. Delegate must also provide `setValue`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_105",
        "title": "Lazy Delegate Thread Safety",
        "description": "True or False?",
        "codeSnippet": "val x by lazy(LazyThreadSafetyMode.NONE) { 1 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Disables synchronization for performance if single-threaded.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_106",
        "title": "Operator Inc return type",
        "description": "Identify operator contract.",
        "codeSnippet": "class Counter(val x: Int) {\n    operator fun inc(): Unit {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`inc` operator must return the incremented type (e.g. `Counter`), not `Unit`. Usage `c++` reassigns `c = c.inc()`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_106",
        "title": "Destructuring Lambda",
        "description": "True or False?",
        "codeSnippet": "val map = mapOf(1 to 1)\nmap.forEach { (k, v) -> print(k + v) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Destructuring declaration in lambda parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_107",
        "title": "SAM Conversion Class",
        "description": "Identify SAM rule.",
        "codeSnippet": "abstract class Runnable {\n    abstract fun run()\n}\nfun start(r: Runnable) {}\nfun main() { start { print(\"Go\") } }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "SAM (Single Abstract Method) conversion only works for Java interfaces or Kotlin `fun interface`. It does NOT work for abstract classes.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_107",
        "title": "Fun Interface",
        "description": "True or False?",
        "codeSnippet": "fun interface Action { fun execute() }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Enables SAM conversion for Kotlin interface.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_108",
        "title": "JvmField in Interface",
        "description": "Identify backing field rule.",
        "codeSnippet": "interface I {\n    @JvmField val x = 1\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Property in interface cannot have backing field, so `@JvmField` is not allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_108",
        "title": "Strictfp",
        "description": "True or False?",
        "codeSnippet": "@Strictfp fun f() {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Floating point strictness annotation.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_109",
        "title": "Volatile on Val",
        "description": "Identify concurrency rule.",
        "codeSnippet": "@Volatile val x = 0",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`@Volatile` is only applicable to `var` properties (mutable). `val` is final in Java bytecode, visibility guarantees are inherent or not applicable.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_109",
        "title": "Synchronized Block",
        "description": "True or False?",
        "codeSnippet": "val lock = Any()\nfun f() { synchronized(lock) { } }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_110",
        "title": "Constructor Property Vararg",
        "description": "Identify syntax limit.",
        "codeSnippet": "class C(val vararg x: Int)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`vararg` is allowed in constructor parameters. But `val vararg`? \nYes, allowed. `x` becomes `IntArray`. \nWait. Maybe error is elsewhere? \nLet's use: `inner` class object. \nCode: `class Outer { inner class Inner { object Obj } }`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_110_real",
        "title": "Object in Inner Class",
        "description": "Identify nesting rule.",
        "codeSnippet": "class Outer {\n    inner class Inner {\n        object Singleton\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Inner classes (which hold reference to outer) cannot contain `object` declarations (which are static singletons). Singleton shouldn't depend on outer instance.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_110",
        "title": "Backing Field",
        "description": "True or False?",
        "codeSnippet": "var x = 0\n    set(value) { field = value + 1 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `field` refers to backing field.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_111",
        "title": "Extension Property Initializer",
        "description": "Identify extension capability.",
        "codeSnippet": "val String.lastChar: Char = this.get(length - 1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Extension properties cannot have initializers. Must define a getter: `val String.lastChar get() = ...`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_111",
        "title": "Any Extension",
        "description": "True or False?",
        "codeSnippet": "fun Any?.safeToString() = this?.toString() ?: \"NULL\"",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Can extend nullable types.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_112",
        "title": "Local Class Access",
        "description": "Identify scope.",
        "codeSnippet": "fun f() {\n    class Local\n}\nval l = Local()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`Local` class is defined inside `f` and is not visible outside.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_112",
        "title": "Covariant Return Type",
        "description": "True or False?",
        "codeSnippet": "open class A { open fun f(): Any = 1 }\nclass B : A() { override fun f(): Int = 2 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Covariant return types are supported.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_113",
        "title": "Generic Type Erasure Is Check",
        "description": "Identify erasure.",
        "codeSnippet": "fun <T> check(list: List<T>) {\n    if (list is List<String>) {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Cannot check for instance of erased type: `is List<String>`. At runtime it's just `List<*>`. Use `List<*>` or reified inline.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_113",
        "title": "Star Projection",
        "description": "True or False?",
        "codeSnippet": "val list: List<*> = listOf(1, \"a\")",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Safe way to refer to generic type when argument doesn't matter.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_114",
        "title": "Where clause syntax",
        "description": "Identify syntax position.",
        "codeSnippet": "fun <T> f(x: T) where T: CharSequence, T: Comparable<T> {\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Syntax is `fun <T> f(x: T) where ...` is correct. \nIssue: Valid syntax. \nReal Error: `const` inside `class`. \nAlready covered: `const val`. \nLet's try: `enum` entries with body semicolon. \nCode: `enum class E { A fun f() {} }`. \nError: Must separate entries from members with semicolon if members exist.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_114_real",
        "title": "Enum Semicolon",
        "description": "Identify syntax requirement.",
        "codeSnippet": "enum class E {\n    A, B\n    fun f() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "If an enum class defines members, the list of enum constants must be terminated by a semicolon `;`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_114",
        "title": "Nothing subtype",
        "description": "True or False?",
        "codeSnippet": "val x: String = throw Exception()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `Nothing` is a subtype of every type.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_115",
        "title": "Return at label",
        "description": "Identify label validity.",
        "codeSnippet": "fun f() {\n    return@f\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`return@f` labels are usually for lambdas or inner functions. Returning from `f` itself uses simple `return` or implicit Unit. `return@f` implies returning from a scope named `f`? Actually, explicit label return to function name IS allowed in some contexts (like inside lambda), but as direct expression in function? It works if `f` is valid label. Function name acts as label. \nLet's try: `continue` in `forEach`. \nCode: `listOf(1).forEach { continue }`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_115_real",
        "title": "Continue in forEach",
        "description": "Identify lambda limitation.",
        "codeSnippet": "listOf(1).forEach {\n    if (it == 1) continue\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`continue` and `break` are not allowed in `forEach` lambda (it's a function call, not a loop). Use `return@forEach` for continue behavior.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_115",
        "title": "Suspend Lambda",
        "description": "True or False?",
        "codeSnippet": "val s: suspend () -> Unit = { delay(100) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_116",
        "title": "Non-local return from noinline",
        "description": "Identify return scope.",
        "codeSnippet": "inline fun f(noinline b: () -> Unit) { b() }\nfun main() {\n    f { return }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Since `b` is `noinline`, the lambda passed to `f` cannot contain a non-local `return`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_116",
        "title": "Sealed class constructor",
        "description": "True or False?",
        "codeSnippet": "sealed class S(val x: Int)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Sealed classes can have constructors.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_117",
        "title": "Operator Invoke",
        "description": "Identify modifier.",
        "codeSnippet": "class C {\n    fun invoke() {}\n}\nval c = C(); c()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Must use `operator` modifier to make `invoke` callable as `c()`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_117",
        "title": "Function Reference",
        "description": "True or False?",
        "codeSnippet": "fun f() {}\nval r = ::f",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `::` creates member reference.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_118",
        "title": "Array Invariant",
        "description": "Identify generics variance.",
        "codeSnippet": "val a: Array<Any> = arrayOf(\"s\")",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Kotlin Arrays are invariant. `Array<String>` is not `Array<Any>`. (Use `Array<out Any>` or cast/copy).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_118",
        "title": "List Covariant",
        "description": "True or False?",
        "codeSnippet": "val l: List<Any> = listOf(\"s\")",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `List` (immutable) is covariant (`out E`).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_119",
        "title": "Private Typealias Public",
        "description": "Identify visibility.",
        "codeSnippet": "private class C\ntypealias PublicC = C",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Public typealias `PublicC` cannot expose private type `C`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_119",
        "title": "Getter visibility",
        "description": "True or False?",
        "codeSnippet": "var x: Int = 1\n    private set",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Setter can be private while getter is public.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_120",
        "title": "Lateinit Nullable",
        "description": "Identify modifier usage.",
        "codeSnippet": "lateinit var x: String?",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`lateinit` properties must not be nullable types.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_120",
        "title": "Unit Object",
        "description": "True or False?",
        "codeSnippet": "val u = Unit",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Unit is an object.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_121",
        "title": "Data Class Inheritance",
        "description": "Identify class rule.",
        "codeSnippet": "open data class D(val x: Int)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Data classes cannot be `open`, `abstract`, `sealed`, or `inner`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_121",
        "title": "Coroutines Delay",
        "description": "True or False?",
        "codeSnippet": "suspend fun f() { delay(100) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_122",
        "title": "Anonymous object explicit return",
        "description": "Identify scope.",
        "codeSnippet": "fun f() = object { val x = 1 }\nfun main() { print(f().x) }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "When an anonymous object is returned from a function (without declared supertype), it is treated as `Any` (if public function). Member `x` is not accessible unless function is private.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_122",
        "title": "Sequence Yield",
        "description": "True or False?",
        "codeSnippet": "val seq = sequence { yield(1) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Builds usage sequence.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_123",
        "title": "Inner class companion",
        "description": "Identify nesting rule.",
        "codeSnippet": "class Outer {\n    inner class Inner {\n        companion object {}\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Inner classes cannot have companion objects (similar to `object` restriction).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_123",
        "title": "Inline Property",
        "description": "True or False?",
        "codeSnippet": "val x: Int inline get() = 1",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Accessors can be inlined.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_124",
        "title": "Multiple This ambiguity",
        "description": "Identify scope qualifier.",
        "codeSnippet": "class A { fun f() { print(\"A\") } }\nclass B { \n    fun A.ext() {\n        f() // calls A.f\n        this.toString() // A or B?\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid, but ambiguous logic if not careful. `this` refers to receiver `A`. `this@B` refers to B. \nReal Error: `const val` in inner object? \nCode: `class C { companion object { const val x = 1 } }`. Valid. \nLet's try: `inline` class multiple properties.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_124_real",
        "title": "Value Class Properties",
        "description": "Identify formatting.",
        "codeSnippet": "@JvmInline value class C(val x: Int, val y: Int)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Value classes (inline classes) must have exactly one primary constructor parameter.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_124",
        "title": "Require function",
        "description": "True or False?",
        "codeSnippet": "fun setAge(a: Int) { require(a > 0) }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Throws IllegalArgumentException.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_125",
        "title": "Protected constructor in sealed",
        "description": "Identify visibility.",
        "codeSnippet": "sealed class S protected constructor()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid (redundant but valid). \nError: `sealed` class in different file. \nCode (File A): `sealed class S`. Code (File B): `class C : S()`. \nError: Direct subclasses of sealed classes must be in the same file (or same package/module in 1.5+). Same package is requirement now (1.5). Actually strict same package and module. If File B is same package, valid. If different package, error.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_125_strict",
        "title": "Sealed Inheritance Package",
        "description": "Identify hierarchy rule.",
        "codeSnippet": "package a\nsealed class S\npackage b\nclass C : a.S()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "Sealed class subclasses must be declared in the same package as the sealed class.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_125",
        "title": "String toIntOrNull",
        "description": "True or False?",
        "codeSnippet": "val i = \"abc\".toIntOrNull()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Safe parsing.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_126",
        "title": "Operator Set Return",
        "description": "Identify operator syntax.",
        "codeSnippet": "class C {\n    operator fun set(i: Int, value: Int): Int = value\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`set` operator must return `Unit`. The result of assignment expression is implicit Unit.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_126",
        "title": "Infix Precedence",
        "description": "True or False?",
        "codeSnippet": "val x = 1 shl 2 + 3",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Infix calls have lower precedence than arithmetic operators. Parsed as `1 shl (2 + 3)`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_127",
        "title": "Inline Class Interface",
        "description": "Identify capability.",
        "codeSnippet": "@JvmInline value class C(val x: Int) : Runnable {\n    override fun run() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Value classes can implement interfaces. \nError: `value class` with `init` block (pre-1.9 restriction, but allowed now). \nLet's try: `inner` value class. \nCode: `class Outer { @JvmInline value class Inner(val x: Int) }`. \nError: Value classes cannot be inner.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_127_real",
        "title": "Value Class Inner",
        "description": "Identify nesting rule.",
        "codeSnippet": "class Outer {\n    @JvmInline value class Inner(val x: Int)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Value classes cannot be `inner`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_127",
        "title": "Value class wrapping nullable",
        "description": "True or False?",
        "codeSnippet": "@JvmInline value class Wrapper(val s: String?)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Can wrap nullable types.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_128",
        "title": "Suspend Overload",
        "description": "Identify ambiguity.",
        "codeSnippet": "fun f() {}\nsuspend fun f() {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Overloading based only on `suspend` modifier is often ambiguous or invalid platform signature. But Kotlin allows it if callers are distinct? Actually it creates signature conflict on JVM. `PlatformDeclarationClash`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_128",
        "title": "Flow Collect",
        "description": "True or False?",
        "codeSnippet": "suspend fun main() {\n    flowOf(1).collect { print(it) }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `collect` is a suspend function.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_129",
        "title": "Generic Multiple Upper Bounds Syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "fun <T : CharSequence, Comparable<T>> f(x: T) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Multiple upper bounds must be specified using `where` clause. `T : A, B` is not valid inline syntax.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_129",
        "title": "StateFlow value",
        "description": "True or False?",
        "codeSnippet": "val s = MutableStateFlow(0)\ns.value = 1",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. StateFlow has a `value` property.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_130",
        "title": "Reified without inline",
        "description": "Identify modifier requirement.",
        "codeSnippet": "fun <reified T> isType(a: Any) = a is T",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`reified` type parameters are only allowed in `inline` functions.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_130",
        "title": "Annotation Class Parameter",
        "description": "True or False?",
        "codeSnippet": "annotation class Ann(val s: String)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Annotations can have parameters (const/class types).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_131",
        "title": "Expect class body",
        "description": "Identify multiplatform rule.",
        "codeSnippet": "expect class C {\n    fun f() { print(\"Hi\") }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`expect` classes cannot have function bodies. Implementation is provided by `actual` class.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_131",
        "title": "External Modifier",
        "description": "True or False?",
        "codeSnippet": "external fun f(): Int",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Function implementation is in native code or JNI.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_132",
        "title": "UnaryPlus Operator args",
        "description": "Identify operator signature.",
        "codeSnippet": "operator fun unaryPlus(x: Int) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`unaryPlus` is a unary operator, it takes no arguments (receiver is the operand).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_132",
        "title": "Iterator Operator",
        "description": "True or False?",
        "codeSnippet": "operator fun iterator() = listOf(1).iterator()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Allows usage in `for` loop.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_133",
        "title": "RangeTo return type",
        "description": "Identify operator usage.",
        "codeSnippet": "operator fun rangeTo(other: Int): String = \"\"",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. `rangeTo` can return any type. `1..2` would be a String. \nError: `component1` with args. \nCode: `operator fun component1(x: Int): Int`. \nError: `componentN` functions must take no arguments.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_133_real",
        "title": "Component Function Args",
        "description": "Identify operator signature.",
        "codeSnippet": "class Pair(val x: Int, val y: Int) {\n    operator fun component1(i: Int) = x\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`componentN` functions must take no value parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_133",
        "title": "Contains Operator",
        "description": "True or False?",
        "codeSnippet": "operator fun contains(x: Int): Boolean = true",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Enables `in` operator.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_134",
        "title": "CompareTo Return Type",
        "description": "Identify operator contract.",
        "codeSnippet": "operator fun compareTo(other: Int): Boolean = true",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`compareTo` must return `Int` (negative, zero, positive).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_134",
        "title": "Provide Delegate",
        "description": "True or False?",
        "codeSnippet": "operator fun provideDelegate(thisRef: Any?, prop: KProperty<*>) = MyDelegate()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Allows delegate creation logic.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_135",
        "title": "ReadOnlyProperty setValue",
        "description": "Identify interface contract.",
        "codeSnippet": "class D : ReadOnlyProperty<Any?, Int> {\n    override fun getValue(thisRef: Any?, property: KProperty<*>) = 1\n    fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {}\n}\nvar x: Int by D()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 4,
        "explanation": "`x` is `var`, so delegate must implement `setValue`. `ReadOnlyProperty` only ensures `getValue`. The `setValue` method defined is not an override of `ReadWriteProperty`, but it matches convention. \nWait. If it matches convention `setValue` operator, then it IS valid even if it only implements `ReadOnlyProperty` interface explicitly? \nNo, to be a valid delegate for `var`, it needs `setValue` operator. If `setValue` is present and marked `operator` (or overrides interface), it works. \nSnippet lacks `operator` modifier on `setValue`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_135",
        "title": "ReadWriteProperty",
        "description": "True or False?",
        "codeSnippet": "class D : ReadWriteProperty<Any?, Int> { ... }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Standard interface for var delegates.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_136",
        "title": "Observable Property Initializer",
        "description": "Identify usage.",
        "codeSnippet": "var x: Int by Delegates.observable { prop, old, new -> }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`observable` requires an initial value argument.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_136",
        "title": "Vetoable Delegate",
        "description": "True or False?",
        "codeSnippet": "var x: Int by Delegates.vetoable(0) { _, _, new -> new > 0 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Rejects updates if lambda returns false.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_137",
        "title": "Map Delegate Missing Key",
        "description": "Identify runtime behavior (ErrorSpotting usually static?).",
        "codeSnippet": "val map = mapOf<String, Any>()\nval x: Int by map",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Start-up or runtime error? `map` is empty key `x` missing. `getValue` throws `NoSuchElementException`. \nIs this `ErrorSpotting` material? Maybe static check: `val x: Int`. Map is `<String, Any>`. Casting to Int? \nMap delegate casts value. If value missing or wrong type, exception. \nLet's try: `var` by Map. Map is read-only.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_137_real",
        "title": "Var by Map",
        "description": "Identify delegate type.",
        "codeSnippet": "val map = mapOf(\"x\" to 1)\nvar x: Int by map",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`mapOf` returns read-only `Map`. Cannot be used as delegate for `var` property (needs `setValue` or `MutableMap`).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_137",
        "title": "Invoke on Object",
        "description": "True or False?",
        "codeSnippet": "object Obj { operator fun invoke() {} }\nfun main() { Obj() }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Calls the invoke operator on the singleton instance.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_138",
        "title": "Destructuring custom missing operator",
        "description": "Identify modifier.",
        "codeSnippet": "class C(val x: Int)\nfun component1(c: C) = c.x\nval (a) = C(1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Extension function `component1` must be marked with `operator` modifier to be used in destructuring.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_138",
        "title": "Return Type bounds",
        "description": "True or False?",
        "codeSnippet": "fun <T : AutoCloseable> use(x: T) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Upper bound constraint.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_139",
        "title": "Local Delegate inference",
        "description": "Identify type inference capability.",
        "codeSnippet": "fun f() {\n    var x by Delegates.notNull()\n    print(x)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`Delegates.notNull()` cannot infer type `T` from Usage. Must specify type explicitly: `notNull<Int>()` or `var x: Int`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_139",
        "title": "Function Reference Constructor",
        "description": "True or False?",
        "codeSnippet": "class C\nval factory = ::C",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Reference to constructor.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_140",
        "title": "Annotation Target",
        "description": "Identify meta-annotation.",
        "codeSnippet": "@Target(AnnotationTarget.CLASS)\nannotation class A\n@A fun f() {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Annotation `A` is restricted to `CLASS` target. Cannot be applied to function `f`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_140",
        "title": "Repeatable Annotation",
        "description": "True or False?",
        "codeSnippet": "@Repeatable annotation class Tag(val s: String)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Allows applying annotation multiple times.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_141",
        "title": "MustBeDocumented target",
        "description": "Identify meta-annotation usage.",
        "codeSnippet": "annotation class A\n@MustBeDocumented class C",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`@MustBeDocumented` is a meta-annotation for annotation classes themselves, not for regular classes.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_141",
        "title": "DslMarker",
        "description": "True or False?",
        "codeSnippet": "@DslMarker annotation class HtmlDsl",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Controls implicit receiver scoping in DSLs.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_142",
        "title": "Protected in file",
        "description": "Identify visibility.",
        "codeSnippet": "protected val x = 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Top-level declarations cannot be `protected`. Only `private`, `internal`, or `public`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_142",
        "title": "Private to file",
        "description": "True or False?",
        "codeSnippet": "private val x = 1 // Top level",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Visible only inside this file.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_143",
        "title": "Interface property backing field",
        "description": "Identify syntax.",
        "codeSnippet": "interface I {\n    val x: Int\n    get() = field\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Interfaces cannot have backing fields (`field` identifier is illegal here).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_143",
        "title": "Contract",
        "description": "True or False?",
        "codeSnippet": "fun f(s: String?) {\n    contract { returns() implies (s != null) }\n    if (s == null) throw Exception()\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Experimental contracts feature allow smart casts.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_144",
        "title": "JvmName collision",
        "description": "Identify interoperability.",
        "codeSnippet": "fun f() {}\n@JvmName(\"f\") fun g() {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Platform declaration clash: `g` compiles to `f`, colliding with existing `f`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_144",
        "title": "JvmStatic",
        "description": "True or False?",
        "codeSnippet": "object O { @JvmStatic fun f() {} }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Generates static method in bytecode.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_145",
        "title": "JvmStatic on non-object",
        "description": "Identify requirement.",
        "codeSnippet": "class C {\n    @JvmStatic fun f() {}\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`@JvmStatic` is only allowed in `object` or `companion object` (or interfaces with companion-like logic in recent versions? No, just objects/companions).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_145",
        "title": "Throws annotation",
        "description": "True or False?",
        "codeSnippet": "@Throws(IOException::class) fun f() {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Declares checked exceptions for Java.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_146",
        "title": "Yield from non-sequence",
        "description": "Identify context.",
        "codeSnippet": "fun f() {\n    yield(1)\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`yield` is only available inside `sequence { ... }` or iterator builder blocks.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_146",
        "title": "Destructuring parameter",
        "description": "True or False?",
        "codeSnippet": "data class P(val x: Int, val y: Int)\nfun f(p: P) {\n    val (x, y) = p\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_147",
        "title": "Suspend main args",
        "description": "Identify entry point.",
        "codeSnippet": "suspend fun main(args: Array<String>) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Valid! suspend main is supported since Kotlin 1.3. \nError: `Result` return type? \nCode: `fun f(): Result<Int>`. \nExplanation: `Result` cannot be used as a direct return type in Kotlin < 1.5? It was restricted, now allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_147_strict",
        "title": "Private abstract",
        "description": "Identify modifier conflict.",
        "codeSnippet": "abstract class C {\n    private abstract fun f()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Abstract function cannot be private (must be overridable).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_147",
        "title": "Context Receivers",
        "description": "True or False?",
        "codeSnippet": "context(String) fun f() = length",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. (Experimental feature).",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_148",
        "title": "Label shadowed",
        "description": "Identify complexity.",
        "codeSnippet": "fun f() {\n    loop@ for(i in 0..1) {\n        loop@ for(j in 0..1) {}\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Label `loop` is shadowed by inner loop. Ambiguous reference.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_148",
        "title": "Inner class this",
        "description": "True or False?",
        "codeSnippet": "class Outer { inner class Inner { fun f() = this@Outer } }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Qualified this.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_149",
        "title": "Fun Interface abstract members",
        "description": "Identify limitation.",
        "codeSnippet": "fun interface I {\n    fun f()\n    fun g()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "fun interfaces (SAM interfaces) must have exactly one abstract member.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_149",
        "title": "Interface Default Implementation",
        "description": "True or False?",
        "codeSnippet": "interface I {\n    fun f() { print(\"Def\") }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_150",
        "title": "Supertype initialization in interface",
        "description": "Identify syntax.",
        "codeSnippet": "interface A\ninterface B : A()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Interfaces cannot store state, so passing constructor call `A()` is invalid. Should be `interface B : A`.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_tf_150",
        "title": "Object Expression",
        "description": "True or False?",
        "codeSnippet": "val o = object : Runnable { override fun run() {} }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Anonymous class.",
        "difficultyLevel": 2
    },
    {
        "id": "kotlin_err_201",
        "title": "Contract Implies",
        "description": "Identify contract logic.",
        "codeSnippet": "import kotlin.contracts.*\nfun requireString(x: Any?) {\n    contract {\n        returns() implies (x is String)\n    }\n    if (x !is String) throw Exception()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Smart casts `x` to `String` after return. \nError: `inline` property with backing field. \nCode: `var x: Int inline get() = field`. \nError: Inline accessors cannot access backing field.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_201_real",
        "title": "Inline Accessor Field",
        "description": "Identify inline limitation.",
        "codeSnippet": "var x: Int = 0\n    inline get() = field",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Inline accessors cannot access the backing field. They must compute value or access other properties.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_201",
        "title": "Inline Class Identity",
        "description": "True or False?",
        "codeSnippet": "@JvmInline value class ID(val x: Int)\nval a = ID(1)\nval b = ID(1)\nval eq = a === b",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False. `===` is forbidden or deprecated for value classes because they can be boxed/unboxed unpredictably. Actually it returns false (boxed instances different) or specific behavior, but logical check is typically discouraged.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_202",
        "title": "Suspend Tailrec",
        "description": "Identify modifier usage.",
        "codeSnippet": "tailrec suspend fun f() {\n    f()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`tailrec` modifier is not applicable to `suspend` functions (tail call optimization logic is incompatible with state machine generation).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_202",
        "title": "Crossinline Receiver",
        "description": "True or False?",
        "codeSnippet": "inline fun f(crossinline block: String.() -> Unit) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Crossinline lambdas can have receivers.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_203",
        "title": "Reified Private Access",
        "description": "Identify inlining scope.",
        "codeSnippet": "private class Secret\ninline fun <reified T> access() { print(T::class) }\nfun main() { access<Secret>() }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`inline` function with `reified` type parameter exposes `Secret` via `T::class`. If `access` is public, it cannot expose private type `Secret`? \nActually, `access` is public. Calling it with `Secret` (private) from same file (`main`) works? \nYes, if `access` is in same file/module. \nBut if `access` is public API, usage is restricted. \nReal Error: `const` inside function. \nAlready done. \nLet's try: `enum` ordinal usage in `when` (not constant). \nCode: `when(x) { Color.RED.ordinal -> {} }`. \nError: `when` branch expression must be constant expression (for optimization) or arbitrary? Arbitrary is allowed in kotlin. \nReal Error: `inner` class inside `interface`. \nCode: `interface I { inner class C }`. \nError: Interfaces cannot contain inner classes (stateful).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_203_real",
        "title": "Inner Class in Interface",
        "description": "Identify nesting rule.",
        "codeSnippet": "interface I {\n    inner class C\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Interfaces cannot contain `inner` classes (which require outer instance state). Can contain nested classes (static).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_203",
        "title": "FlowOn Context",
        "description": "True or False?",
        "codeSnippet": "flow { emit(1) }\n    .flowOn(Dispatchers.IO)\n    .map { it }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `flowOn` changes context of upstream operators.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_204",
        "title": "Mutex Reentrancy",
        "description": "Identify concurrency behavior (logical error).",
        "codeSnippet": "val mutex = Mutex()\nsuspend fun f() {\n    mutex.withLock {\n        mutex.withLock { }\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "Kotlin `Mutex` is non-reentrant. Attempting to acquire lock again while holding it will deadlock.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_204",
        "title": "SupervisorJob",
        "description": "True or False?",
        "codeSnippet": "val scope = CoroutineScope(SupervisorJob())\n// Launch failing child doesn't cancel scope",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Children failure doesn't cancel parent.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_205",
        "title": "Sequence reuse",
        "description": "Identify usage capability.",
        "codeSnippet": "val seq = sequence { \n    println(\"Start\")\n    yield(1) \n}\nval i1 = seq.iterator()\nval i2 = seq.iterator()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `yield` in `forEach`? \nCode: `sequence { listOf(1).forEach { yield(it) } }`. \nWait. Suspensions are allowed in inline lambdas. `forEach` is inline. Valid. \nReal Error: `RestrictedSuspendLambda` constraint? \nCode: `sequence { run { yield(1) } }`. \nExplanation: `run` is inline, valid. \nLet's try: `yield` in non-inline lambda. \nCode: `sequence { thread { yield(1) } }`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_205_real",
        "title": "Suspend Call in Non-Suspend Lambda",
        "description": "Identify context.",
        "codeSnippet": "sequence {\n    val t = Thread {\n        yield(1)\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`yield` is a suspend function. Cannot be called from `Thread` lambda (which is not suspend/inline).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_205",
        "title": "Channel Rendezmo",
        "description": "True or False?",
        "codeSnippet": "val c = Channel<Int>(Channel.RENDEZVOUS)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Buffer size 0 (sender suspends until receiver ready).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_206",
        "title": "Delegate Accessing Annotation",
        "description": "Identify Reflection support.",
        "codeSnippet": "class D { operator fun getValue(t: Any?, p: KProperty<*>) { p.findAnnotation<Ann>() } }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid, provided dependencies. \nError: `data object` (new feature)? \nLet's try: `enum` with no instances? Valid. \nCorrect Error: `sealed` class extending `open` class (valid). \nError: `data` class extending `data` class? \nCode: `data class A(val x: Int); data class B(val y: Int) : A(1)`. \nError: Data classes are final. Cannot extend A.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_206_real",
        "title": "Data Class Inheritance",
        "description": "Identify class hierarchy.",
        "codeSnippet": "data class A(val x: Int)\ndata class B(val y: Int) : A(1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Data classes are final by default and cannot be inherited from.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_206",
        "title": "Select Expression",
        "description": "True or False?",
        "codeSnippet": "select<Unit> { onReceive(c) {} }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Selects first available clause.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_207",
        "title": "PublishedApi internal",
        "description": "Identify visibility.",
        "codeSnippet": "@PublishedApi private fun f() {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`@PublishedApi` allows using internal members in public inline functions. It relies on the member being effectively `internal` (module visible), but if marked `private`, it's not even visible to internal. Use `internal` with `@PublishedApi`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_207",
        "title": "RequiresOptIn",
        "description": "True or False?",
        "codeSnippet": "@RequiresOptIn annotation class Experimental",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Defines opt-in requirement marker.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_208",
        "title": "Result Return Type",
        "description": "Identify restriction (legacy/current).",
        "codeSnippet": "fun f(): Result<Int> = Result.success(1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Previously this was error. Since 1.5 it is allowed. \nError: `suspend` property backing field. \nCode: `suspend val x = 1`. \nError: Properties cannot be `suspend`. Must use suspend getter (not allowed) or suspend function.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_208_real",
        "title": "Suspend Property",
        "description": "Identify modifier usage.",
        "codeSnippet": "suspend val x: Int = 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Modifier `suspend` is not applicable to local variables or properties (only functions/lambdas).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_208",
        "title": "Recursive Generic",
        "description": "True or False?",
        "codeSnippet": "class Node<T : Node<T>>",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. F-bounded polymorphism.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_209",
        "title": "Projection Out Assignment",
        "description": "Identify variance safety.",
        "codeSnippet": "class Box<T>(var item: T)\nfun f(b: Box<out String>) {\n    b.item = \"Hi\"\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`Box<out String>` produces Strings but cannot consume them (setter taking T is disabled/unsafe). Cannot assign to `item`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_209",
        "title": "Star Projection Set",
        "description": "True or False?",
        "codeSnippet": "fun f(l: MutableList<*>) {\n    l.add(null)\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": false,
        "explanation": "False. `MutableList<*>` behaves like `MutableList<out Any?>`. `add` expects `Nothing` (cannot add anything safely except maybe null if allowed? actually usually Nothing).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_210",
        "title": "Callable Ref Bound Receiver",
        "description": "Identify syntax/logic.",
        "codeSnippet": "class C { fun f() {} }\nval c = C()\nval ref = c::f\nfun main() { ref(c) }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`ref` is a bound reference `() -> Unit`. It already has receiver `c`. Calling `ref(c)` provides too many arguments. Should be `ref()`. (Depending on type inference, `c::f` matches `() -> Unit` or `(C) -> Unit`? Bound matches `() -> Unit`).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_210",
        "title": "Tailrec Private",
        "description": "True or False?",
        "codeSnippet": "private tailrec fun f() { f() }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Access modifier doesn't affect tailrec logic (unless it prevents overriding).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_211",
        "title": "Nothing instance",
        "description": "Identify type nature.",
        "codeSnippet": "val n = Nothing()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`Nothing` has no instances. It has a private constructor.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_211",
        "title": "Unit Void Interop",
        "description": "True or False?",
        "codeSnippet": "// Java: void f() {}\n// Kotlin: val x: Unit = f()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Java void maps to Kotlin Unit.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_212",
        "title": "Local classes inside object",
        "description": "Identify scope.",
        "codeSnippet": "object O {\n    class Inner\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Classes inside `object` are static nested by default? Actually `inner` keyword isn't allowed. Nested `class Inner` is allowed (static). \nReal Error: `const` val with getter. \nCode: `const val x get() = 1`. \nError: Const properties cannot have custom getters.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_212_real",
        "title": "Const Custom Getter",
        "description": "Identify const limitation.",
        "codeSnippet": "const val x: Int\n    get() = 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Const properties cannot have custom getters.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_212",
        "title": "Lateinit var private",
        "description": "True or False?",
        "codeSnippet": "lateinit var x: String",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Can be private.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_213",
        "title": "Operator componentX type",
        "description": "Identify syntax capability.",
        "codeSnippet": "class C { operator fun component1() = 1 }\nval (a, b) = C()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Destructuring `(a, b)` requires `component1()` and `component2()`. `component2` is missing.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_213",
        "title": "Function Reference to Extension",
        "description": "True or False?",
        "codeSnippet": "fun String.ext() {}\nval r = String::ext",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Reference type `(String) -> Unit`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_214",
        "title": "Nested Inner Class Access",
        "description": "Identify state access.",
        "codeSnippet": "class Outer {\n    val x = 1\n    class Nested {\n        inner class Deep { fun f() = x }\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "`Deep` is inner to `Nested`. `Nested` is static nested in `Outer`. So `Deep` doesn't have reference to `Outer` instance. Cannot access `x`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_214",
        "title": "Type Alias Generics",
        "description": "True or False?",
        "codeSnippet": "typealias Predicate<T> = (T) -> Boolean",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_215",
        "title": "Annotation Parameter Type",
        "description": "Identify type limit.",
        "codeSnippet": "annotation class A(val f: Float)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Annotation parameters support primitives, String, Class, Enum, Annotation, Array. `Float` is allowed. \nWait. Float IS allowed. Double too. \nError: `Date`? \nCode: `annotation class A(val d: Date)`. \nError: `Date` is not a valid annotation parameter type (must be compile-time constant compatible).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_215_real",
        "title": "Annotation Invalid Param",
        "description": "Identify constant restriction.",
        "codeSnippet": "import java.util.Date\nannotation class A(val d: Date)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Annotation parameters can only be primitives, String, Class, Enum, Annotation, or Arrays thereof. `Date` is not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_215",
        "title": "Constructor reference",
        "description": "True or False?",
        "codeSnippet": "class C\nval f: () -> C = ::C",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_216",
        "title": "Override final",
        "description": "Identify inheritance restriction.",
        "codeSnippet": "open class A { final fun f() {} }\nclass B : A() { override fun f() {} }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Cannot override `final` function.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_216",
        "title": "Open class default final",
        "description": "True or False?",
        "codeSnippet": "open class A { fun f() {} } // f is final",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Members are final by default even in open class.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_217",
        "title": "Vararg last param",
        "description": "Identify argument rule.",
        "codeSnippet": "fun f(vararg x: Int, y: Int) {}\nfun main() { f(1, 2, 3) }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "If `vararg` is not the last parameter, subsequent parameters (`y`) must be passed using named arguments. `f(1, 2, y=3)`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_217",
        "title": "Extension shadowing member",
        "description": "True or False?",
        "codeSnippet": "class C { fun f() { print(\"Mem\") } }\nfun C.f() { print(\"Ext\") }\n// C().f() prints \"Mem\"",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Member functions always win over extension functions with same signature.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_218",
        "title": "Sealed class when statement",
        "description": "Identify feature nuance.",
        "codeSnippet": "sealed class S\nobject A : S()\nfun f(s: S) {\n    when(s) { A -> {} }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. `when` used as statement doesn't need to be exhaustive? Actually, since Kotlin 1.7(?), exhaustive warning might be error. But snippet is valid syntax. \nReal Error: `enum` class with abstract method? \nCode: `enum class E { A { override fun f() {} }; abstract fun f() }`. Valid. \nLet's try: `interface` inheriting `class`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_218_real",
        "title": "Interface Inheritance",
        "description": "Identify hierarchy rule.",
        "codeSnippet": "open class C\ninterface I : C",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Interfaces cannot inherit from classes.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_218",
        "title": "Delegation to Interface",
        "description": "True or False?",
        "codeSnippet": "interface I { fun f() }\nclass Base(val i: I) : I by i",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Class delegation pattern.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_219",
        "title": "Backing field in extension",
        "description": "Identify extension limit.",
        "codeSnippet": "var String.tag: String = \"\"\n    get() = field",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Extension properties do not have backing fields. `field` identifier is not available.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_219",
        "title": "Inline reified class literal",
        "description": "True or False?",
        "codeSnippet": "inline fun <reified T> typeName() = T::class.simpleName",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_220",
        "title": "Abstract in object",
        "description": "Identify modifier usage.",
        "codeSnippet": "object O {\n    abstract fun f()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Objects are final/concrete. Cannot have abstract members.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_220",
        "title": "Protected static",
        "description": "True or False?",
        "codeSnippet": "open class C {\n    protected companion object {}\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Companion object can be protected (visible to subclasses).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_221",
        "title": "Dynamic type",
        "description": "Identify generic restriction.",
        "codeSnippet": "val x: dynamic = 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`dynamic` type is only available in Kotlin/JS, not Kotlin/JVM.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_221",
        "title": "External Class",
        "description": "True or False?",
        "codeSnippet": "external class C",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. (Mostly JS/Native).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_222",
        "title": "Operator overload equals",
        "description": "Identify operator strictness.",
        "codeSnippet": "class C {\n    operator fun equals(other: C): Boolean = true\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`equals` overrides `Any.equals(other: Any?)`. Defining it with `C` parameter overloads it but doesn't override the equality operator `==` which uses `Any?`. To work with `==`, must override `equals(Any?)` and `override` keyword.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_222",
        "title": "Infix receiver",
        "description": "True or False?",
        "codeSnippet": "class C {\n    infix fun op(x: Int) {}\n}\nfun main() { C() op 1 }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Member function used as infix.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_223",
        "title": "Constructor return",
        "description": "Identify syntax error.",
        "codeSnippet": "class C {\n    constructor() {\n        return C()\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Constructors implicitly return the instance. Explicit `return` with value is not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_223",
        "title": "Secondary constructor this",
        "description": "True or False?",
        "codeSnippet": "class C(val x: Int) {\n    constructor() : this(0)\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Delegates to primary.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_224",
        "title": "Interface property state",
        "description": "Identify state.",
        "codeSnippet": "interface I {\n    val x: Int\n}\nclass C : I",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 3,
        "explanation": "Class `C` must implement abstract property `x`. Or be abstract.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_224",
        "title": "Data Class Array property equals",
        "description": "True or False?",
        "codeSnippet": "data class D(val arr: IntArray)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True, but caveat: `equals` uses referential equality for arrays. Recommended to override `equals`/`hashCode`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_225",
        "title": "Multiple Inheritance State",
        "description": "Identify diamond problem nuance.",
        "codeSnippet": "open class A(val x: Int)\nopen class B(val x: Int)\nclass C : A(1), B(2)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "Kotlin supports single class inheritance. Cannot extend both `A` and `B`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_225",
        "title": "Context Receiver Multiple",
        "description": "True or False?",
        "codeSnippet": "context(A, B) fun f() {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Requires both A and B in scope.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_226",
        "title": "Inline Property Backing Field",
        "description": "Identify syntax restriction.",
        "codeSnippet": "var x: Int = 0\n    inline get() = field\n    inline set(v) { field = v }",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Inline accessors cannot access backing fields. They must be property without backing field or use other storage.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_226",
        "title": "Effectively Final Smart Cast",
        "description": "True or False?",
        "codeSnippet": "fun f() {\n    var x: Any = \"s\"\n    x = \"s2\"\n    if (x is String) print(x.length)\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Local `var` that is effectively final (or flow analysis proves type) can be smart cast.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_227",
        "title": "Sealed Interface State",
        "description": "Identify limitation.",
        "codeSnippet": "sealed interface I {\n    val x: Int = 1\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Interfaces cannot have state (backing fields). Property with initializer implies backing field (unless it's a const or custom getter, but syntax `val x: Int = 1` creates backing field which is invalid).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_227",
        "title": "Constructor Keyword",
        "description": "True or False?",
        "codeSnippet": "class C private constructor(x: Int)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Keyword `constructor` is required when modifiers are present.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_228",
        "title": "Init Block Access Ahead",
        "description": "Identify initialization safety.",
        "codeSnippet": "class C {\n    init { print(x) }\n    val x = 1\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Cannot access property `x` before it is declared/initialized in `init` block (illegal forward reference).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_228",
        "title": "Delegated Property Provide",
        "description": "True or False?",
        "codeSnippet": "class D { operator fun provideDelegate(t: Any?, p: KProperty<*>) = this }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_229",
        "title": "Fun Interface Multiple Members",
        "description": "Identify constraint.",
        "codeSnippet": "fun interface Action {\n    fun run()\n    fun stop()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "fun interfaces must have exactly one abstract member.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_229",
        "title": "Type Alias Function",
        "description": "True or False?",
        "codeSnippet": "typealias Handler = (Int) -> Unit\nfun f(h: Handler) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_230",
        "title": "Expect Function Default Arg",
        "description": "Identify multiplatform rule.",
        "codeSnippet": "expect fun f(x: Int = 1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid? Actually `expect` functions cannot have default arguments? \nWait, Kotlin docs say: \"Default values are not allowed in expect function parameters.\" \nSo Error is at line 0.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_230_real",
        "title": "Expect Default Argument",
        "description": "Identify multiplatform restriction.",
        "codeSnippet": "expect fun f(x: Int = 1)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Expect functions cannot have default argument values.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_230",
        "title": "Volatile on JVM",
        "description": "True or False?",
        "codeSnippet": "@Volatile var x: Int = 0",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Marks JVM volatile field.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_231",
        "title": "Synchronized on property",
        "description": "Identify annotation usage.",
        "codeSnippet": "@Synchronized val x = 1",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`@Synchronized` is applicable to functions (getters/setters), not properties directly? Actually it targets the getter/setter methods. But syntax `@Synchronized` on property usually fails or targets field (which is wrong). Must apply to accessor: `get() @Synchronized = ...`. \nWait, valid use: `@get:Synchronized`. \nSnippet uses `@Synchronized` on property. \nError: `@Synchronized` is valid on functions only.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_231",
        "title": "Strictfp",
        "description": "True or False?",
        "codeSnippet": "@Strictfp fun f() {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. (Though effect is default in recent JVMs).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_232",
        "title": "Transient on local",
        "description": "Identify scope.",
        "codeSnippet": "fun f() {\n    @Transient val x = 1\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`@Transient` is for class fields (serialization). Not applicable to local variables.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_232",
        "title": "SerialVersionUID",
        "description": "True or False?",
        "codeSnippet": "object O { private const val serialVersionUID: Long = 1L }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Standard JVM serialization hook.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_233",
        "title": "Reflection Java Class",
        "description": "Identify syntax.",
        "codeSnippet": "val c = String::class.java",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `lateinit` on primitive. \nCode: `lateinit var x: Int`. \nError: `lateinit` modifiers not allowed on properties of primitive types.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_233_real",
        "title": "Lateinit Primitive",
        "description": "Identify modifier constraint.",
        "codeSnippet": "lateinit var count: Int",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`lateinit` properties cannot be of primitive types (Int, Double, etc.).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_233",
        "title": "Enum Entries",
        "description": "True or False?",
        "codeSnippet": "enum class E { A, B }\nval list = E.entries",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. New in Kotlin 1.9 (replacing `values()`).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_234",
        "title": "Unsigned negative literal",
        "description": "Identify syntax.",
        "codeSnippet": "val u: UInt = -1u",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Unsigned literals cannot be negative. `-1u` is unary minus applied to `1u`. `1u` is `UInt`. `unaryMinus` is not defined for `UInt`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_234",
        "title": "SubclassOptInRequired",
        "description": "True or False?",
        "codeSnippet": "@SubclassOptInRequired(Experimental::class) open class C",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Requires subclasses to opt-in.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_235",
        "title": "JvmRecord on non-data class",
        "description": "Identify requirement.",
        "codeSnippet": "@JvmRecord class C(val x: Int)",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`@JvmRecord` allowed only on `data` classes (compiled to Java 16+ records).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_235",
        "title": "JsExport",
        "description": "True or False?",
        "codeSnippet": "@JsExport class C",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Exports to JS.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_236",
        "title": "Context Receiver Syntax",
        "description": "Identify syntax error (new feature).",
        "codeSnippet": "func f() context(String) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "`context` receiver must be placed before `fun`. `context(String) fun f() {}`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_236",
        "title": "Inline Value Class Generic",
        "description": "True or False?",
        "codeSnippet": "@JvmInline value class V(val x: Int)\nfun <T> f(v: T) {}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Value class is boxed when used as Generic.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_237",
        "title": "Nested Annotation",
        "description": "Identify nesting rule.",
        "codeSnippet": "class C {\n    annotation class A\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Annotation classes can be nested. \nError: `inner` annotation. \nCode: `class C { inner annotation class A }`. \nError: Annotation classes cannot be inner.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_237_real",
        "title": "Inner Annotation Class",
        "description": "Identify nesting restriction.",
        "codeSnippet": "class C {\n    inner annotation class A\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Annotation classes cannot be `inner`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_237",
        "title": "Anonymous object explicit return",
        "description": "True or False?",
        "codeSnippet": "fun f() = object : Runnable { override fun run() {} }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Returns the anonymous object type (if private) or Runnable (if public).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_238",
        "title": "Local sealed class",
        "description": "Identify scope limitation.",
        "codeSnippet": "fun f() {\n    sealed class S\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Sealed classes cannot be local. Must be top-level or nested.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_238",
        "title": "Enum implements interface",
        "description": "True or False?",
        "codeSnippet": "interface I\nenum class E : I { A }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_239",
        "title": "Interface delegated property missing",
        "description": "Identify requirement.",
        "codeSnippet": "interface I {\n    val x: Int by lazy { 1 }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Interfaces can have delegated properties (they don't have backing fields). `lazy` usually stores value. \nWait. `lazy` creates a property delegate that STORES value? Yes. \nDoes `I` need state? Delegation object is stored in... where? \nIn Class implementing I? No. \nCompiled to `getValue`. \nWait. Does `by lazy` work in interface? \nError: Delegated property in interface cannot have state? \n`lazy` delegate HOLDS content. Interfaces cannot hold state. \nSo `val x by lazy { 1 }` in interface IS error? \nActually, Kotlin compiler allows it? No. \n\"Delegated properties are allowed in interfaces.\" \nRef: Kotlin specs. \nBut `lazy` requires backing field? No, the delegate INSTANCE is the issue. \nWhere is the delegate instance stored? \nIn interface? \nInterfaces cannot have fields. \nSo a property in an interface cannot use a delegate that requires a backing field for the delegate itself? \nThe Delegate is an object instance. \nReference: \"You cannot use delegates that require a backing field in interfaces.\" \n`lazy` implementation uses a field to store the value. \nIs `val x by lazy` correct? \nError: Property in an interface cannot have a backing field.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_239_real",
        "title": "Lazy Delegate in Interface",
        "description": "Identify interface state limit.",
        "codeSnippet": "interface I {\n    val x: Int by lazy { 1 }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Delegated properties in interfaces cannot store state. `by lazy` creates a delegate instance that stores the value, which requires a backing field, not allowed in interfaces.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_239",
        "title": "Destructuring declaration types",
        "description": "True or False?",
        "codeSnippet": "val (a: String, b: Int) = MyPair(\"s\", 1)",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Explicit types allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_240",
        "title": "Data Class No Args",
        "description": "Identify requirement.",
        "codeSnippet": "data class D()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 0,
        "explanation": "Data classes must have at least one primary constructor parameter.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_240",
        "title": "Operator Rem",
        "description": "True or False?",
        "codeSnippet": "operator fun rem(x: Int) = 0",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. `rem` operator (modulo). (Replaces `mod`).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_241",
        "title": "Suspend init",
        "description": "Identify context.",
        "codeSnippet": "class C {\n    init {\n        delay(100)\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`init` blocks cannot contain suspend function calls (they are regular code blocks, not suspendable).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_241",
        "title": "Private Constructor",
        "description": "True or False?",
        "codeSnippet": "class C private constructor()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_242",
        "title": "Return in lambda from inline",
        "description": "Identify control flow.",
        "codeSnippet": "inline fun f(flow: () -> Unit) { flow() }\nfun main() {\n    f { return \n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Non-local return supported for inline functions. \nError: Return in `noinline` lambda. \nCode: `fun f(block: () -> Unit) {}; fun main() { f { return } }`. \nError: `return` is not allowed here (can only return from function or anonymous function, not lambda unless inline).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_242_real",
        "title": "Return in Non-Inline Lambda",
        "description": "Identify control flow limitation.",
        "codeSnippet": "fun runAction(action: () -> Unit) { action() }\nfun main() {\n    runAction { return }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`return` is not allowed in non-inline lambdas (cannot do non-local return). Use `return@runAction`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_242",
        "title": "Labelled This",
        "description": "True or False?",
        "codeSnippet": "class A { inner class B { fun f() = this@A } }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_243",
        "title": "Where clause placement",
        "description": "Identify syntax error.",
        "codeSnippet": "fun <T> f(x: T) where T : CharSequence = x",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. \nError: `where` with multiple classes? \nCode: `fun <T> f() where T: Base1, T: Base2`. \nError: Only one class bound allowed (others must be interfaces). Assuming Base1/Base2 are classes. \nDifficulty: hard to show in snippet properly. \nLet's try: `vararg` before default arg without named arg in call (already done). \nError: `abstract` fun in non-abstract class. \nCode: `class C { abstract fun f() }`. \nError: abstract members only in abstract classes/interfaces.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_243_real",
        "title": "Abstract in Concrete Class",
        "description": "Identify modifier mismatch.",
        "codeSnippet": "class C {\n    abstract fun f()\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Abstract functions can only be defined in abstract classes or interfaces.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_243",
        "title": "Protected Constructor",
        "description": "True or False?",
        "codeSnippet": "open class C protected constructor()",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_244",
        "title": "Suspend operator",
        "description": "Identify valid operators.",
        "codeSnippet": "class C {\n    suspend operator fun get(i: Int) = i\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid? Yes, `get` can be suspend (e.g. network call). \nError: `equals` cannot be suspend. \nCode: `override suspend fun equals(other: Any?): Boolean`. \nError: `equals` is defined in Any and is NOT suspend. Cannot override with suspend.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_244_real",
        "title": "Suspend Equals",
        "description": "Identify override mismatch.",
        "codeSnippet": "class C {\n    override suspend fun equals(other: Any?): Boolean = true\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`equals` is defined in `Any` as a non-suspend function. Cannot override it as `suspend`.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_244",
        "title": "Suspend Invoke",
        "description": "True or False?",
        "codeSnippet": "class C { suspend operator fun invoke() {} }",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_245",
        "title": "Sealed class private",
        "description": "Identify constructor visibility.",
        "codeSnippet": "sealed class S\nclass Sub : S()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": -1,
        "explanation": "Valid. Sealed constructors are protected by default (visible to subclass). \nError: Local class extending sealed? \nAlready covered. \nError: Subclass outside module. \nContext: `sealed class` implies module restriction. \nMaybe `const` in class. \nCode: `class C { const val x = 1 }`. \nError: `const` only allowed in top-level or object (companion).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_245_real",
        "title": "Const in Class",
        "description": "Identify const limit.",
        "codeSnippet": "class C {\n    const val MAX = 100\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`const` properties are only allowed at top-level or inside `object`/`companion object`. Not in regular class bodies.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_245",
        "title": "Interface companion",
        "description": "True or False?",
        "codeSnippet": "interface I {\n    companion object { fun f() {} }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_246",
        "title": "Conflicting Overloads varargs",
        "description": "Identify overload resolution.",
        "codeSnippet": "fun f(vararg x: Int) {}\nfun f(x: IntArray) {}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Platform declaration clash. Both compile to `f(int[])` on JVM.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_246",
        "title": "Getter visibility",
        "description": "True or False?",
        "codeSnippet": "var x: Int = 1\n    private set",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Setter is private, getter is default (public).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_247",
        "title": "Getter visibility wider",
        "description": "Identify property consistency.",
        "codeSnippet": "private var x: Int = 1\n    public get() = field",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Getter visibility must be the same as property visibility (cannot be wider).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_247",
        "title": "Setter visibility",
        "description": "True or False?",
        "codeSnippet": "public var x: Int = 1\n    private set",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Setter can be more restrictive than property.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_248",
        "title": "Inner class companion",
        "description": "Identify nesting rule.",
        "codeSnippet": "class Outer {\n    inner class Inner {\n        companion object { }\n    }\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 2,
        "explanation": "`inner` classes cannot have `companion object` (static members not allowed in inner classes).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_248",
        "title": "Nested class companion",
        "description": "True or False?",
        "codeSnippet": "class Outer {\n    class Nested {\n        companion object {}\n    }\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Nested classes are static.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_249",
        "title": "Object inner",
        "description": "Identify modifier usage.",
        "codeSnippet": "class C {\n    inner object O\n}",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "`object` declaration cannot be `inner` (inherently static singleton).",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_249",
        "title": "Local function",
        "description": "True or False?",
        "codeSnippet": "fun f() {\n    fun local() {}\n    local()\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_err_250",
        "title": "Enum inheritance",
        "description": "Identify enum class rule.",
        "codeSnippet": "enum class E\nclass C : E()",
        "type": "errorSpotting",
        "language": "kotlin",
        "errorLineIndex": 1,
        "explanation": "Enum classes are final and cannot be inherited from.",
        "difficultyLevel": 3
    },
    {
        "id": "kotlin_tf_250",
        "title": "Enum Abstract override",
        "description": "True or False?",
        "codeSnippet": "enum class E {\n    A { override fun f() {} };\n    abstract fun f()\n}",
        "type": "trueOrFalse",
        "language": "kotlin",
        "isCodeCorrect": true,
        "explanation": "True. Constant-specific class body.",
        "difficultyLevel": 3
    }
]