[
    {
        "id": "go_err_1",
        "title": "Unused variable",
        "description": "Identify syntax error.",
        "codeSnippet": "func main() {\n    x := 10\n    fmt.Println(\"Hello\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Go compiler treats unused local variables as errors. `x` is declared but not used.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_1",
        "title": "Public function",
        "description": "Is function public?",
        "codeSnippet": "func Public() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, functions starting with an uppercase letter are exported (public).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_2",
        "title": "Opening brace newline",
        "description": "Identify syntax error.",
        "codeSnippet": "func main()\n{\n    fmt.Println(\"Hi\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Go requires the opening brace `{` to be on the same line as the function declaration statement. Syntax error.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_2",
        "title": "Short declaration",
        "description": "Is := valid?",
        "codeSnippet": "x := 5",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, short variable declaration inside functions.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_3",
        "title": "Semicolon manual",
        "description": "Identify style/syntax.",
        "codeSnippet": "x := 5;\ny := 10;",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Semicolons are not idiomatic in Go source code (though syntactically valid separators, `gofmt` removes them). Strictly speaking valid code, but Code Reviewer flags it as error/noise. Actually, is it an error? No, but strongly discouraged. Let's create a *real* error.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_3_real",
        "title": "If condition parenthesis",
        "description": "Identify syntax.",
        "codeSnippet": "if (x > 5) {\n    fmt.Println(\"Big\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go `if` conditions do not need parentheses. While typically valid in C-like languages, Go idioms prefer `if x > 5`. `gofmt` removes them. Is it an error? No, code compiles. \nLet's try real error: `if x > 5 fmt.Println(\"Big\")` -> Missing braces. Braces are mandatory.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_3_real_2",
        "title": "Missing braces if",
        "description": "Identify syntax.",
        "codeSnippet": "if x > 5\n    fmt.Println(\"Big\")",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Go requires curly braces `{}` for all control structures bodies (`if`, `for`). Single line without braces is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_3",
        "title": "Multiple return",
        "description": "Can return multiple values?",
        "codeSnippet": "func f() (int, int) { return 1, 2 }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, Go supports multiple return values.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_4",
        "title": "Short decl package level",
        "description": "Identify scope error.",
        "codeSnippet": "package main\nvar x = 1\ny := 2\nfunc main() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Short declaration `:=` is strictly for local variables (inside functions). At package level, must use `var`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_4",
        "title": "Zero value int",
        "description": "Is zero value 0?",
        "codeSnippet": "var i int // i is 0",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, default zero value for int is 0.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_5",
        "title": "Switch break",
        "description": "Identify unnecessary code.",
        "codeSnippet": "switch x {\ncase 1:\n    fmt.Println(\"One\")\n    break\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 3,
        "explanation": "Go switch cases break automatically. `break` is redundant (though not an error, just noise, unlike C). \nLet's find error. \n`case 1: fmt.Println(\"One\"); fallthrough;` -> ok. \nDuplicate case? \n`switch x { case 1: ... case 1: ... }` -> Error.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_5_real",
        "title": "Duplicate case switch",
        "description": "Identify logic.",
        "codeSnippet": "switch x {\ncase 1: fmt.Print(\"A\")\ncase 1: fmt.Print(\"B\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Duplicate case `1` in switch statement.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_5",
        "title": "Const declaration",
        "description": "Is const valid?",
        "codeSnippet": "const Pi = 3.14",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, valid constant declaration.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_6",
        "title": "Increment expression",
        "description": "Identify syntax error.",
        "codeSnippet": "x := 1\ny := x++",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "In Go, `++` is a statement, not an expression. Cannot assign `y := x++`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_6",
        "title": "Implicit bool conversion",
        "description": "Is if 1 valid?",
        "codeSnippet": "if 1 { }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Go does not implicitly convert numbers to bool. Must use `if true` or condition.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_7",
        "title": "Unused import",
        "description": "Identify compiler error.",
        "codeSnippet": "import \"fmt\"\nfunc main() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Unused imports are compiler errors in Go.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_7",
        "title": "Blank identifier variables",
        "description": "Can ignore value?",
        "codeSnippet": "_, err := f()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `_` ignores the value.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_8",
        "title": "Map initialization nil",
        "description": "Identify runtime panic.",
        "codeSnippet": "var m map[string]int\nm[\"key\"] = 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Variable `m` is `nil`. Writing to a nil map causes a runtime panic. Must use `make(map[string]int)`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_8",
        "title": "Defer execution",
        "description": "Is defer valid?",
        "codeSnippet": "defer fmt.Println(\"End\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, executes at end of function.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_9",
        "title": "Array size variable",
        "description": "Identify array mismatch.",
        "codeSnippet": "n := 5\nvar a [n]int",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Array length `[n]` must be a constant expression. `n` is a variable. Use slice `[]int` or const `n`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_9",
        "title": "Slice literal",
        "description": "Is slice valid?",
        "codeSnippet": "s := []int{1, 2, 3}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, slice literal/composite literal.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_10",
        "title": "String immutability",
        "description": "Identify string assignment.",
        "codeSnippet": "s := \"hello\"\ns[0] = 'H'",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Strings in Go are immutable. Cannot assign to index `s[0]`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_10",
        "title": "For range loop",
        "description": "Is range valid?",
        "codeSnippet": "for i, v := range s {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, iterates index and value.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_11",
        "title": "Method receiver pointer vs value",
        "description": "Identify mutation fail.",
        "codeSnippet": "type S struct { x int }\nfunc (s S) Set(v int) { s.x = v }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Receiver `(s S)` is by value. `Set` modifies the copy `s`, not the original caller. Changes are lost. Should be `(s *S)`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_11",
        "title": "Struct fields export",
        "description": "Is field exported?",
        "codeSnippet": "struct { Name string }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `Name` is exported (uppercase).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_12",
        "title": "Nil slice append",
        "description": "Identify slice behavior.",
        "codeSnippet": "var s []int\ns[0] = 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`s` is nil slice (len 0). Assignment `s[0] = 1` panics (index out of range). Must use `append` or `make`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_12",
        "title": "Append return",
        "description": "Does append return slice?",
        "codeSnippet": "s = append(s, 1)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `append` returns updated slice.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_13",
        "title": "Capitalization import",
        "description": "Identify visibility.",
        "codeSnippet": "package mypkg\nfunc myPrivate() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Not an error, just private. \nLet's assume user tries to access it from another package. \nSnippet: `mypkg.myPrivate()` in another file. \nSince this snippet is definition, it is valid. \nLet's try syntax error. \n`func (s S) method` where `S` is defined in another package? Can only define methods on types in same package. \nCode: `func (int) MyMethod() {}` -> Invalid receiver type (basic type).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_13_real",
        "title": "Method on basic type",
        "description": "Identify receiver.",
        "codeSnippet": "func (i int) Double() int { return i * 2 }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Cannot define new methods on non-local type `int`. Must define `type MyInt int` first.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_13",
        "title": "Type alias",
        "description": "Is type alias valid?",
        "codeSnippet": "type MyInt = int",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, type alias (since Go 1.9).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_14",
        "title": "Fallthrough syntax",
        "description": "Identify keyword.",
        "codeSnippet": "if x > 0 {\n    fallthrough\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`fallthrough` is only allowed in `switch` statements, not `if`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_14",
        "title": "Iota constant",
        "description": "Is iota valid?",
        "codeSnippet": "const ( A = iota; B )",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, enum generator.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_15",
        "title": "Var redeclaration",
        "description": "Identify scope.",
        "codeSnippet": "var x int\nvar x int",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot redeclare `x` in the same block.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_15",
        "title": "Rune literal",
        "description": "Is 'a' a rune?",
        "codeSnippet": "r := 'a'",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, single quotes are runes (int32).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_16",
        "title": "Map key slice",
        "description": "Identify key type.",
        "codeSnippet": "m := make(map[[]int]int)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Slices are not comparable, so they cannot be used as map keys. Use array or struct.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_16",
        "title": "Make slice",
        "description": "Is make slice valid?",
        "codeSnippet": "make([]int, 5, 10)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, length 5, capacity 10.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_17",
        "title": "Interface method mismatch",
        "description": "Identify implementation.",
        "codeSnippet": "type I interface { M() }\ntype S struct{}\nfunc (s *S) M() {}\nvar i I = S{}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 3,
        "explanation": "`S` does not implement `I` (`M` requires pointer receiver `*S`). `S{}` is a value. Must use `&S{}` or `new(S)`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_17",
        "title": "Empty interface",
        "description": "Is interface{} valid?",
        "codeSnippet": "var i interface{}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, holds any value (Any).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_18",
        "title": "Goroutine call",
        "description": "Identify syntax.",
        "codeSnippet": "go func() { ... }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Missing call parentheses `()` at end of anonymous function definition? `go func() {}` simply defines it but doesn't run? \nWait. Syntax: `go expression`. `func() {}` is function literal. expression must be a function call. `go func() { ... }` is invalid syntax. Must be `go func() { ... }()`. \nCorrect.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_18",
        "title": "Channel receive",
        "description": "Is <-ch valid?",
        "codeSnippet": "v := <-ch",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, receive from channel.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_19",
        "title": "Const slice",
        "description": "Identify const limit.",
        "codeSnippet": "const s = []int{1, 2}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Slices cannot be constants. Arrays cannot be constants (unless in recent Go versions? No, arrays/slices/maps/structs cannot be `const`. Only bool, string, numeric).",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_19",
        "title": "Defer stack",
        "description": "Is defer LIFO?",
        "codeSnippet": "defer f1(); defer f2();",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, LIFO execution order (f2 then f1).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_20",
        "title": "Function default arguments",
        "description": "Identify capability.",
        "codeSnippet": "func f(x int = 0) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go does not support default parameter values.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_20",
        "title": "Package init",
        "description": "Is init() auto called?",
        "codeSnippet": "func init() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `init` is automatically called on package load.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_21",
        "title": "Loop variable scope capture",
        "description": "Identify closure issue.",
        "codeSnippet": "for i := 0; i < 3; i++ {\n    defer func() { println(i) }()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Closure captures `i` by reference. `defer` runs at end of loop. `i` will be 3 for all calls. (Wait, Go 1.22 fixes this? Yes. But generally known as typical Go error. Let's assume standard Go <1.22 logic or just describe it as logic error/bug). Explanation: Prints '3 3 3'.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_21",
        "title": "Select default",
        "description": "Is default in select valid?",
        "codeSnippet": "select { default: }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, non-blocking select.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_22",
        "title": "Casting syntax",
        "description": "Identify syntax.",
        "codeSnippet": "i := 10\nf := (float64)i",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "C-style casting `(type)value` is invalid. Go uses function call syntax `type(value)`. `float64(i)`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_22",
        "title": "Type switch",
        "description": "Is type switch valid?",
        "codeSnippet": "switch v.(type) { case int: }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, type switch.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_23",
        "title": "Unexported struct assignment",
        "description": "Identify visibility.",
        "codeSnippet": "otherpkg.S { x: 1 }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "If `x` is unexported in `S`, cannot initialize it with struct literal from another package.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_23",
        "title": "Raw string literal",
        "description": "Is backtick string valid?",
        "codeSnippet": "`raw string \\n`",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, backticks invoke raw strings (no escape sequences).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_24",
        "title": "Label break error",
        "description": "Identify flow.",
        "codeSnippet": "Loop: for {\n    break Loop\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "This is valid. \nError: `break label` where label is not enclosing for/switch/select. \nCode: `func f() { Label: ... break Label }` -> Error if not in loop.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_24_real",
        "title": "Goto usage",
        "description": "Identify jump over var.",
        "codeSnippet": "goto L\nvar x = 1\nL:",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`goto L` jumps over variable declaration `x`. Forbidden in Go because `x` would be in scope but uninitialized.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_24",
        "title": "Panic recover",
        "description": "Is recover valid?",
        "codeSnippet": "recover()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, used in defer to handle panics.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_25",
        "title": "Method receiver name",
        "description": "Identify naming.",
        "codeSnippet": "func (self *S) M() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Using `self` or `this` is not idiomatic in Go (though valid syntax). ErrorSpotting might flag it as 'Non-idiomatic'. Let's pick real error. \n`func (me *S) M() {}` ok. \n`func (*S) M() {}` ok (unused receiver). \nWhat about `func (x int) M()` earlier? \nHow about duplicate method name? \n`func (s *S) A() {}; func (s *S) A() {}` -> Redeclaration.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_25_real",
        "title": "Duplicate method",
        "description": "Identify conflict.",
        "codeSnippet": "func (s S) M() {}\nfunc (s *S) M() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Method `M` redeclared on type `S`. Pointer and value receivers share the same method set namespace for definition.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_25",
        "title": "Ellipsis variadic",
        "description": "Is ...int valid?",
        "codeSnippet": "func sum(nums ...int)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, variadic function.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_26",
        "title": "String comparison",
        "description": "Identify syntax.",
        "codeSnippet": "s1 := \"a\"\ns2 := \"b\"\nif s1.equals(s2) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Go strings support direct comparison with `==`. `.equals` is not a method on string.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_26",
        "title": "Struct embedding",
        "description": "Is embedding valid?",
        "codeSnippet": "type S1 struct { S2 }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, struct embedding (anonymous field).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_27",
        "title": "Variable shadow switch",
        "description": "Identify scope.",
        "codeSnippet": "switch x := f(); x {\ncase 1: fmt.Println(x)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid scope. `x` is local to switch. \nError: `switch x := f(); x { case 1: x := 2; }`? Valid shadow. \nError: `var x int; func f() { x := 1 }` valid shadow. \nLet's pick: `var nil = 1`. Allowed but bad.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_27_real",
        "title": "Assign to nil",
        "description": "Identify reserved identifier.",
        "codeSnippet": "nil := 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Cannot use `:=` to declare `nil`. `nil` is a predeclared identifier, but `:=` requires new variable on LHS. However `nil` is not a keyword. You can write `var nil = 1` (bad practice but valid). But `nil := 1` might be valid if `nil` is not declared in current block? Yes. Wait. `nil` is universe block. `nil := 1` shadows it. Syntactically valid. \nLet's try: `func init() {} func init() {}` -> Valid (multiple inits). \nError: `func main() {} func main() {}` -> Redeclaration of main.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_27",
        "title": "Map delete",
        "description": "Is delete valid?",
        "codeSnippet": "delete(m, \"key\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, removes key from map.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_28",
        "title": "Nil pointer dereference",
        "description": "Identify runtime error.",
        "codeSnippet": "var p *int\n*p = 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`p` is nil. Dereferencing `*p` causes a runtime panic.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_28",
        "title": "String length",
        "description": "Is len(s) valid?",
        "codeSnippet": "len(\"hello\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, returns number of bytes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_29",
        "title": "Wrong comment syntax",
        "description": "Identify syntax.",
        "codeSnippet": "# This is a comment",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go uses `//` for single line comments, not `#`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_29",
        "title": "Multi-line string",
        "description": "Is backtick multiline?",
        "codeSnippet": "`line1\nline2`",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, raw strings can span multiple lines.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_30",
        "title": "Invalid map key",
        "description": "Identify constraint.",
        "codeSnippet": "m := map[func()]int{}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Functions are not comparable/hashable, so they cannot be map keys.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_30",
        "title": "New allocation",
        "description": "Is new(T) valid?",
        "codeSnippet": "p := new(int)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, allocates zeroed storage and returns pointer `*int`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_31",
        "title": "Unreachable code after return",
        "description": "Identify flow.",
        "codeSnippet": "return\nfmt.Println(\"Unreachable\")",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Code after `return` is unreachable (compiler error: missing return or unreachable code?). Go compiler flags 'unreachable code'.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_31",
        "title": "Interface nil check",
        "description": "Is i == nil valid?",
        "codeSnippet": "var i interface{}\nif i == nil {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_32",
        "title": "Const function call",
        "description": "Identify const.",
        "codeSnippet": "const x = math.Sqrt(4)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Function calls (like `math.Sqrt`) cannot be used in constant declarations (unless built-in functions like `len`, `cap`, `complex`). `Sqrt` is runtime.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_32",
        "title": "Comparison operator",
        "description": "Is != valid?",
        "codeSnippet": "if x != y {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_33",
        "title": "Import cycle",
        "description": "Identify dependency.",
        "codeSnippet": "// pkg A imports B\n// pkg B imports A",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Circular imports are forbidden in Go.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_33",
        "title": "Complex numbers",
        "description": "Is complex64 valid?",
        "codeSnippet": "var c complex64",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, built-in complex type.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_34",
        "title": "Slice out of bounds",
        "description": "Identify panic.",
        "codeSnippet": "s := []int{1}\n_ = s[1]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Index `1` is out of bounds for slice of length 1 (indices 0 to len-1). Panic.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_34",
        "title": "Bitwise OR",
        "description": "Is | valid?",
        "codeSnippet": "x := 1 | 2",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, bitwise OR.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_35",
        "title": "Function brace placement",
        "description": "Identify syntax.",
        "codeSnippet": "func f()\n{\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Opening brace `{` must be on same line as function header.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_35",
        "title": "Pointer to pointer",
        "description": "Is **int valid?",
        "codeSnippet": "var pp **int",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_36",
        "title": "Reserved keyword var usage",
        "description": "Identify identifier.",
        "codeSnippet": "var func = 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`func` is a keyword. Cannot be used as variable name.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_36",
        "title": "Empty struct",
        "description": "Is struct{} valid?",
        "codeSnippet": "s := struct{}{}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, explicit empty struct literal.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_37",
        "title": "Double quotes for char",
        "description": "Identify literal syntax.",
        "codeSnippet": "var c rune = \"a\"",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Double quotes `\"a\"` denote a string. Single quotes `'a'` denote a rune/char.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_37",
        "title": "Label declaration",
        "description": "Is Label: valid?",
        "codeSnippet": "Label:\n    fmt.Println()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, statement label.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_38",
        "title": "Continue in switch",
        "description": "Identify flow.",
        "codeSnippet": "switch x {\ncase 1:\n    continue\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`continue` is only allowed inside loops (`for`). Not in `switch` (unless switch is inside a loop, in which case it affects the loop). But standalone switch? Invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_38",
        "title": "Hex literal",
        "description": "Is 0x10 valid?",
        "codeSnippet": "x := 0x10",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_39",
        "title": "Invalid package name",
        "description": "Identify syntax.",
        "codeSnippet": "package default",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`default` is a keyword. Cannot be package name.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_39",
        "title": "Print format",
        "description": "Is %d for integer?",
        "codeSnippet": "fmt.Printf(\"%d\", 10)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_40",
        "title": "Assign to const",
        "description": "Identify mutability.",
        "codeSnippet": "const pi = 3.14\npi = 3.1415",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot assign to a constant.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_40",
        "title": "Copy slice",
        "description": "Is copy() valid?",
        "codeSnippet": "copy(dst, src)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, built-in function.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_41",
        "title": "Wrong variable declaration",
        "description": "Identify syntax.",
        "codeSnippet": "int x = 5",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go syntax is `var x int = 5` or `var x = 5` or `x := 5`. Type comes after variable name, `var` keyword needed (or short decl).",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_41",
        "title": "Named return values",
        "description": "Are named returns valid?",
        "codeSnippet": "func f() (x int) { x = 1; return }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, named return parameters.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_42",
        "title": "Access unexported field",
        "description": "Identify visibility.",
        "codeSnippet": "otherpkg.s.x",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Field `x` is unexported (lowercase) in `s` (which might also be unexported).",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_42",
        "title": "Byte type",
        "description": "Is byte same as uint8?",
        "codeSnippet": "var b byte = 255",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `byte` is alias for `uint8`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_43",
        "title": "Func call as statement missing parens",
        "description": "Identify command.",
        "codeSnippet": "fmt.Println \"Hello\"",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Function calls require parentheses: `fmt.Println(\"Hello\")`. No parenthesless calls like Ruby/Perl.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_43",
        "title": "Blank import",
        "description": "Is _ import valid?",
        "codeSnippet": "import _ \"net/http/pprof\"",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, for side effects (init functions).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_44",
        "title": "If assignment scope",
        "description": "Identify scope.",
        "codeSnippet": "if x := 1; x > 0 {}\nfmt.Println(x)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`x` defined in `if` statement init clause is only available within `if` block (and else). Not outside.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_44",
        "title": "Underscore numeric",
        "description": "Is 1_000 valid?",
        "codeSnippet": "x := 1_000",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, numeric separators (since Go 1.13).",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_45",
        "title": "Uninitialized pointer",
        "description": "Identify logic.",
        "codeSnippet": "var p *int\nfmt.Println(*p)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Panic: runtime error: invalid memory address or nil pointer dereference.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_45",
        "title": "String concatenation",
        "description": "Is + valid for strings?",
        "codeSnippet": "s := \"a\" + \"b\"",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_46",
        "title": "Main takes args",
        "description": "Identify entry point.",
        "codeSnippet": "func main(args []string) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`main` function does not take arguments or return values. Use `os.Args`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_46",
        "title": "True constant",
        "description": "Is true predeclared?",
        "codeSnippet": "var b bool = true",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_47",
        "title": "Struct comma missing",
        "description": "Identify literal syntax.",
        "codeSnippet": "S{\n    x: 1\n    y: 2\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Fields in struct literal must be separated by commas. `x: 1,`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_47",
        "title": "Range on map",
        "description": "Does range work on map?",
        "codeSnippet": "for k, v := range m {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_48",
        "title": "Array compare size",
        "description": "Identify type mismatch.",
        "codeSnippet": "var a [2]int\nvar b [3]int\nif a == b {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`[2]int` and `[3]int` are different types. Cannot compare.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_48",
        "title": "Float32 type",
        "description": "Is float32 valid?",
        "codeSnippet": "var f float32",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_49",
        "title": "Go routine return capture",
        "description": "Identify syntax/logic.",
        "codeSnippet": "x := go f()",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`go` statement does not return a value. Cannot assign result of `go f()`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_49",
        "title": "Cap function",
        "description": "Is cap valid?",
        "codeSnippet": "cap(s)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, returns capacity.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_50",
        "title": "Interface method implementation",
        "description": "Identify method set.",
        "codeSnippet": "type I interface { M() }\ntype T int\nfunc (t T) M() {}\nvar i I = &t",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid? `T` implements `M`. `&t` (*T) also implements `M` (method set of *T includes T). Valid. \nLet's assume `func (t *T) M() {}` and `var i I = t`. -> Error. `t` (value) doesn't have `M` if `M` requires pointer. \nSnippet: `var i I = t` where `M` on `*T`. -> Error. \nCorrect.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_50_real",
        "title": "Pointer receiver interface",
        "description": "Identify method set.",
        "codeSnippet": "type I interface { M() }\ntype T int\nfunc (t *T) M() {}\nvar t T\nvar i I = t",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 4,
        "explanation": "`T` does not implement `I` because `M` acts on `*T`. Value `t` does not implement `I`. Must use `&t`.",
        "difficultyLevel": 1
    },
    {
        "id": "go_tf_50",
        "title": "Os Exit",
        "description": "Does Exit terminate?",
        "codeSnippet": "os.Exit(0)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, terminates program immediately.",
        "difficultyLevel": 1
    },
    {
        "id": "go_err_51",
        "title": "Slice append assignment",
        "description": "Identify logic error.",
        "codeSnippet": "s := make([]int, 0)\nappend(s, 1)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`append` returns a new slice (which might check capacity and reallocate). The result is discarded here. `s` remains empty. Must assign result: `s = append(s, 1)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_51",
        "title": "String to byte slice",
        "description": "Is conversion valid?",
        "codeSnippet": "b := []byte(\"hello\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, standard conversion.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_52",
        "title": "Method on pointer to pointer",
        "description": "Identify receiver.",
        "codeSnippet": "type S struct{}\nfunc (s **S) M() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Receiver type cannot be a pointer to a pointer. Only `T` or `*T` allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_52",
        "title": "Map value address",
        "description": "Is &m[k] valid?",
        "codeSnippet": "p := &m[\"key\"]",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Cannot take the address of a map element. Map elements are not addressable (can move in memory).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_53",
        "title": "Interface equality",
        "description": "Identify panic possibility.",
        "codeSnippet": "var x interface{} = []int{1}\nvar y interface{} = []int{1}\nif x == y {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Comparing interfaces containing non-comparable types (like slices) causes a runtime panic. `reflect.DeepEqual` needed.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_53",
        "title": "Defer arguments",
        "description": "When are args evaluated?",
        "codeSnippet": "i := 0\ndefer fmt.Println(i)\ni++",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Arguments are evaluated immediately when defer is scheduled. Prints 0.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_54",
        "title": "For range pointers",
        "description": "Identify loop variable re-use.",
        "codeSnippet": "var out []*int\nfor i := 0; i < 3; i++ {\n    out = append(out, &i)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`i` is re-used in each iteration. `&i` takes address of loop variable. All pointers in `out` will point to same address (final value 3). (Fixed in loop var semantics change in 1.22? Yes. But generally testing for classic Go trap. Assuming Go < 1.22 context or valid but logical bug. Let's mark as errorSpotting logical bug).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_54",
        "title": "Switch type assertion",
        "description": "Is .(type) valid outside switch?",
        "codeSnippet": "t := x.(type)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "`(type)` syntax is only valid in `type switch` statement (`switch x.(type)`). Outside, use type assertion `x.(T)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_55",
        "title": "JSON unmarshal private field",
        "description": "Identify struct tag logic.",
        "codeSnippet": "type S struct {\n    name string `json:\"name\"`\n}\njson.Unmarshal(data, &S{})",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Field `name` is unexported (lowercase). `encoding/json` cannot access it even with struct tag.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_55",
        "title": "Recover outside defer",
        "description": "Does recover work directly?",
        "codeSnippet": "func f() { recover() }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Syntactically valid, but `recover()` returns nil unless called directly inside a `defer` function during a panic. As logic code, it does nothing.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_56",
        "title": "Unaddressable slice literal",
        "description": "Identify referencing.",
        "codeSnippet": "p := &[]int{1, 2, 3}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Slice literals are addressable. References to slice literals work. `&[]int{...}` creates pointer to slice. This is Valid. \nLet's find Error. \n`&map[string]int{}` ok. \n`&1` Error (cannot take address of numeric literal).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_56_real",
        "title": "Address of literal constant",
        "description": "Identify addressability.",
        "codeSnippet": "p := &10",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Cannot take address of numeric constant/literal. Must assume it to variable first.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_56",
        "title": "Goroutine closure capture",
        "description": "Does loop capture apply?",
        "codeSnippet": "for i:=0; i<3; i++ { go func(val int){}(i) }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, passing `i` as argument copies it, fixing the loop variable capture issue.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_57",
        "title": "Struct recursive",
        "description": "Identify size.",
        "codeSnippet": "type S struct {\n    s S\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Recursive struct must use pointer for recursive field. `s *S`. Otherwise infinite size.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_57",
        "title": "Channel buffer",
        "description": "Is buffered channel valid?",
        "codeSnippet": "ch := make(chan int, 10)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_58",
        "title": "Nil channel send",
        "description": "Identify deadlock.",
        "codeSnippet": "var ch chan int\nch <- 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Send to `nil` channel blocks forever (deadlock if main thread).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_58",
        "title": "Close closed channel",
        "description": "Does close panic?",
        "codeSnippet": "close(ch); close(ch)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Panic: close of closed channel.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_59",
        "title": "Type assertion check",
        "description": "Identify logic.",
        "codeSnippet": "v := i.(string)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "If `i` does not hold `string`, this causes runtime panic. Safer to use comma-ok idiom: `v, ok := i.(string)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_59",
        "title": "Receiver name mismatch",
        "description": "Can receiver name vary?",
        "codeSnippet": "func (s S) M1() {}\nfunc (x S) M2() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, but idiomatic to use consistent name.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_60",
        "title": "Ternary operator",
        "description": "Identify syntax.",
        "codeSnippet": "x := cond ? 1 : 2",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go does not have a ternary operator `? :`. Must use `if else`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_60",
        "title": "Break outer",
        "description": "Does break label work?",
        "codeSnippet": "J: for { break J }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, breaks labeled outer loop.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_61",
        "title": "Waitgroup usage",
        "description": "Identify race/copy.",
        "codeSnippet": "var wg sync.WaitGroup\ngo func(wg sync.WaitGroup) {\n    wg.Done()\n}(wg)\nwg.Wait()",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "WaitGroups must not be copied (passed by value). Must pass pointer `&wg` or invoke `defer wg.Done()` captured by closure.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_61",
        "title": "Init multiple",
        "description": "Multiple init valid?",
        "codeSnippet": "func init() {}\nfunc init() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, multiple init functions per package allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_62",
        "title": "Const slice indexing",
        "description": "Identify constraint.",
        "codeSnippet": "var s = []int{1}\nconst c = s[0]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`s[0]` is not a constant expression (slice indexing is runtime).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_62",
        "title": "String builder",
        "description": "Is strings.Builder valid?",
        "codeSnippet": "var b strings.Builder",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, efficient string concatenation.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_63",
        "title": "Map concurrency",
        "description": "Identify race.",
        "codeSnippet": "m := make(map[int]int)\ngo func() { m[1] = 1 }()\ngo func() { _ = m[1] }()",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Maps are not thread-safe. Concurrent read/write triggers race detector panic (fatal error: concurrent map writes).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_63",
        "title": "Slice capacity grow",
        "description": "Does append grow cap?",
        "codeSnippet": "append(x, 1)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, doubles capacity initially if needed.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_64",
        "title": "Shadowing import",
        "description": "Identify conflict.",
        "codeSnippet": "import \"fmt\"\nfunc main() {\n    fmt := \"s\"\n    fmt.Println(fmt)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 3,
        "explanation": "`fmt` variable shadows `fmt` package name. `fmt.Println` fails (method on string?).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_64",
        "title": "Channel close nil",
        "description": "Does close(nil) panic?",
        "codeSnippet": "var ch chan int\nclose(ch)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Panic: close of nil channel.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_65",
        "title": "Method receiver base type",
        "description": "Identify receiver.",
        "codeSnippet": "type T []int\nfunc (t []int) M() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Receiver must be a defined type `T` or pointer `*T`. `[]int` is a type literal. Should be `func (t T) M() {}`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_65",
        "title": "Unsafe pointer cast",
        "description": "Is unsafe.Pointer valid?",
        "codeSnippet": "unsafe.Pointer(&x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, allows bypassing Go type safety.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_66",
        "title": "Invalid array size",
        "description": "Identify type.",
        "codeSnippet": "size := 10\nvar arr [size]int",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Variable `size` cannot be used as array length. Must be constant.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_66",
        "title": "Complex literal",
        "description": "Is 1i valid?",
        "codeSnippet": "c := 1 + 2i",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_67",
        "title": "Naked return missing assignment",
        "description": "Identify logic.",
        "codeSnippet": "func f() (x int) {\n    return\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Naked return returns `x` (which is 0). Code Reviewer complains 'naked return '? No, it's valid code. But often confusing. Is it an error? No. \nLet's find error. \n`func f() (int) { return }` -> Error (not enough arguments).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_67_real",
        "title": "Return arg count",
        "description": "Identify syntax.",
        "codeSnippet": "func f() int {\n    return\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Function expects `int` return value. Naked `return` only allowed if return values are named.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_67",
        "title": "Select non-blocking",
        "description": "Is select with default non-blocking?",
        "codeSnippet": "select { case <-ch: default: }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_68",
        "title": "Panic nil",
        "description": "Identify flow.",
        "codeSnippet": "panic(nil)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`panic(nil)` is valid but confusing (recover returns nil, distinguishing from no-panic difficult in some contexts? No, `recover()` returns nil normally). It was problematic in Go pre-1.21? No, it's allowed. runtime panic. \nLet's assume error is `unrecoverable`. \nLet's switch to simpler error: `new(int) = 1`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_68_real",
        "title": "Assign to call result",
        "description": "Identify lhs.",
        "codeSnippet": "new(int) = 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`new(int)` returns expression (value). Cannot assign to it directly. Must dereference: `*new(int) = 1`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_68",
        "title": "Go generate comment",
        "description": "Is go:generate valid?",
        "codeSnippet": "//go:generate command",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, directive for `go generate`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_69",
        "title": "Main return",
        "description": "Identify main sig.",
        "codeSnippet": "func main() int { return 0 }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`main` cannot return values.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_69",
        "title": "Slice re-slice",
        "description": "Is s[:1] valid?",
        "codeSnippet": "s := []int{1,2}; s[:1]",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, re-slicing.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_70",
        "title": "Interface assertion panic",
        "description": "Identify safety.",
        "codeSnippet": "var i interface{} = \"s\"\nn := i.(int)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Type assertion `i.(int)` panics if type mismatches. Use 2-value assignment: `v, ok := i.(int)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_70",
        "title": "Context background",
        "description": "Is context.Background() valid?",
        "codeSnippet": "ctx := context.Background()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, root context.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_71",
        "title": "Unexported method interface",
        "description": "Identify impl.",
        "codeSnippet": "type I interface { m() }\ntype S struct {}\nfunc (S) m() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid, S implements I. The method `m` is unexported. Only types in same package can implement `I`. \nError: `type I interface { m() }` exported? No `I` is exported if uppercase? `m` is private. \nIs it error? No. \nLet's choose `Struct field tag validation`. `json:name` (missing quotes).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_71_real",
        "title": "Struct tag quotes",
        "description": "Identify syntax.",
        "codeSnippet": "type S struct {\n    F int `json:name`\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Struct tags values must be quoted. `json:\"name\"`. `go vet` flags this.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_71",
        "title": "Errors New",
        "description": "Is errors.New valid?",
        "codeSnippet": "err := errors.New(\"fail\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_72",
        "title": "Compare function equality",
        "description": "Identify constraint.",
        "codeSnippet": "if f1 == f2 {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Functions are not comparable using `==` (except to `nil`).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_72",
        "title": "Atomic Load",
        "description": "Is atomic.LoadInt32 valid?",
        "codeSnippet": "atomic.LoadInt32(&i)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_73",
        "title": "Short decl redeclare different",
        "description": "Identify type mismatch.",
        "codeSnippet": "x := 1\nx := \"s\"",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Short declaration `:=` can redeclare `x` only if: same block, at least one new variable, type is consistent? No, if redeclared, it assigns. But type must match original? `x` is int. Assigning string? Error mismatch.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_73",
        "title": "Sync Mutex",
        "description": "Is Mutex valid?",
        "codeSnippet": "var mu sync.Mutex",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_74",
        "title": "Slice three index",
        "description": "Identify syntax.",
        "codeSnippet": "s := arr[0:1:2]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid? Yes, 3-index slice (low:high:max). \nError target: `s := arr[0:1:0]` -> Max < High.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_74_real",
        "title": "Slice capacity invalid",
        "description": "Identify bounds.",
        "codeSnippet": "s := arr[0:5:4]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Capacity `4` cannot be less than length `5-0=5`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_74",
        "title": "Defer recover",
        "description": "Does defer recover work?",
        "codeSnippet": "defer func() { recover() }()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, standard panic handling.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_75",
        "title": "Range on nil map",
        "description": "Identify behavior.",
        "codeSnippet": "var m map[int]int\nfor k, v := range m {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Range on nil map is safe (does nothing, 0 iterations). Valid code. \nError: `struct` defined inside `switch`? Valid. \nLet's choose `invalid receiver type` -> pointer to interface.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_75_real",
        "title": "Pointer to interface receiver",
        "description": "Identify logic.",
        "codeSnippet": "type I interface{}\nfunc (i *I) M() {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Defining method on pointer to interface `*I` is allowed but almost always clear mistake (interfaces are reference types). 'Ineffective/confusing usage'. But Is it invalid? `func (p *error) Error() string`? Strictly allowed. \nBetter error: `type T I` (alias interface) `func (T) M()`. \nActually: Cannot define methods on interface type. `type I interface{}`. `func (I) M() {}` -> Invalid receiver `I` (interface).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_75",
        "title": "Reflect TypeOf",
        "description": "Is reflect.TypeOf valid?",
        "codeSnippet": "reflect.TypeOf(x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_76",
        "title": "String index assignment",
        "description": "Identify mutability.",
        "codeSnippet": "s := \"hello\"\ns[1] = 'a'",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Strings are immutable. Cannot assign to index.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_76",
        "title": "Make map capacity",
        "description": "Is capacity hint valid?",
        "codeSnippet": "make(map[int]int, 100)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, preallocates space for 100 elements.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_77",
        "title": "Fallthrough in if",
        "description": "Identify syntax.",
        "codeSnippet": "if true {\n    fallthrough\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`fallthrough` is only allowed in `switch` cases.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_77",
        "title": "Pointer arithmetic",
        "description": "Is p++ valid?",
        "codeSnippet": "p++",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Go does not support pointer arithmetic like C. Must use `unsafe`. `p++` on pointer is invalid syntax (assuming p is *int). If p is int, valid.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_78",
        "title": "Duplicate map key",
        "description": "Identify literal error.",
        "codeSnippet": "m := map[int]int{1: 1, 1: 2}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Duplicate key `1` in map literal. Compiler error.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_78",
        "title": "Anonymous struct",
        "description": "Is var s struct{} valid?",
        "codeSnippet": "var s struct { x int }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, inline struct definition.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_79",
        "title": "Invalid switch case expression",
        "description": "Identify type mismatch.",
        "codeSnippet": "switch x := 1; x {\ncase \"s\":\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Case expression `\"s\"` (string) must match switch expression `x` (int).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_79",
        "title": "Go routine arguments",
        "description": "Are args evaluated at call?",
        "codeSnippet": "go f(x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, arguments are evaluated in current goroutine, then f executes in new one.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_80",
        "title": "Wrong receiver for Stringer",
        "description": "Identify interface match.",
        "codeSnippet": "type S struct{}\nfunc (s *S) String() string { return \"s\" }\nvar x S\nfmt.Println(x)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 3,
        "explanation": "`fmt.Println` calls `String()` method. `x` is value `S`. `String` requires `*S`. Since `x` is addressable, `fmt` might handle it? Actually `fmt` checks if value implements `Stringer`. `S` does not. `*S` does. Does `fmt` take address? No, `fmt.Println` takes `interface{}`. `S` inside interface does not have `String`. So it prints default struct format `{}`. Is it an error? No. \nLet's find hard error. \n`func (s S) Write(p []byte) (n int, err error) {}`. Implement `io.Writer`. \nError: `const c = new(int)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_80_real",
        "title": "New in constant",
        "description": "Identify const expr.",
        "codeSnippet": "const c = new(int)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`new` is a runtime allocation. Cannot be used in constant declaration.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_80",
        "title": "Defer panic order",
        "description": "Does defer run on panic?",
        "codeSnippet": "defer fmt.Println()\npanic(1)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, deferred functions run when panic unwinds stack.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_81",
        "title": "Variable shadowing shorthand",
        "description": "Identify syntax.",
        "codeSnippet": "var x int\nx := 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "If `x` is declared in same block, `:=` cannot redeclare it unless there is at least one new variable on LHS. `x := 1` has no new variables.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_81",
        "title": "Raw string backticks",
        "description": "Are backticks multiline?",
        "codeSnippet": "`a\nb`",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_82",
        "title": "Unused label",
        "description": "Identify lint/error.",
        "codeSnippet": "func f() {\nL:\n    fmt.Println()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Unused labels are compiler errors in Go.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_82",
        "title": "Map key struct",
        "description": "Is struct valid map key?",
        "codeSnippet": "map[struct{x int}]int",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, if fields are comparable.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_83",
        "title": "Invalid variadic usage",
        "description": "Identify signature mismatch.",
        "codeSnippet": "func f(args ...int, s string) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Variadic parameter `...int` must be the last parameter.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_83",
        "title": "Interface embedding",
        "description": "Can interface embed interface?",
        "codeSnippet": "type I interface {\n    io.Reader\n}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_84",
        "title": "Method on non-local type",
        "description": "Identify rule.",
        "codeSnippet": "func (i int) IsPos() bool {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Cannot define method on basic type `int` (must be defined type in same package).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_84",
        "title": "Panic recover return",
        "description": "Can recover return value?",
        "codeSnippet": "v := recover()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, returns the value passed to panic.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_85",
        "title": "Loop variable address map",
        "description": "Identify reference.",
        "codeSnippet": "m := make(map[string]*int)\nfor i, v := range []int{1, 2} {\n    m[string(i)] = &v\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`v` is the loop value variable, reused each iteration. `&v` is constant address. Map will contain pointers to same value (last element). Logical error.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_85",
        "title": "Recursive function",
        "description": "Is recursion supported?",
        "codeSnippet": "func f(n int) { f(n-1) }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_86",
        "title": "Double close channel",
        "description": "Identify panic.",
        "codeSnippet": "c := make(chan int)\nclose(c)\nclose(c)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Closing an already closed channel panics.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_86",
        "title": "Select break label",
        "description": "Can break out of select?",
        "codeSnippet": "L: select { default: break L }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_87",
        "title": "Append to array",
        "description": "Identify type.",
        "codeSnippet": "var a [2]int\nappend(a, 1)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`append` expects a slice as first argument, not an array.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_87",
        "title": "Alias type method",
        "description": "Method inheritance?",
        "codeSnippet": "type T1 struct{}\nfunc (T1) M() {}\ntype T2 = T1\n// T2 has M?",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, T2 is alias for T1, so it has M.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_88",
        "title": "Invalid complex build",
        "description": "Identify syntax.",
        "codeSnippet": "c := 1 + 2 * i",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`i` is not predeclared constant for imaginary unit. Must use `2i` or `complex(1, 2)`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_88",
        "title": "Struct tag space",
        "description": "Is space allowed?",
        "codeSnippet": "`json: \"name\"`",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Struct tags are space separated key:value pairs. `json: \"name\"` is invalid syntax (often ignored or parsed as key `json:` value `\"name\"`? No, key cannot contain colon. `json:\"name\"` (no space) is conventional. With space `json: \"name\"` -> key `json:`, value empty? key `\"name\"`? Actually `go vet` complains about this. Conventionally incorrect.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_89",
        "title": "Duplicate argument name",
        "description": "Identify syntax.",
        "codeSnippet": "func f(a, a int) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Duplicate argument name `a`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_89",
        "title": "Make chan buffer optional",
        "description": "Is make(chan int) valid?",
        "codeSnippet": "make(chan int)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, unbuffered channel.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_90",
        "title": "Bitwise NOT operator",
        "description": "Identify operator.",
        "codeSnippet": "x := ~1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go uses `^` (caret) for bitwise NOT (complement), not `~`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_90",
        "title": "Switch initialization",
        "description": "Is switch x := 1; x valid?",
        "codeSnippet": "switch x := 1; x {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_91",
        "title": "Invalid numeric literal",
        "description": "Identify leading zero.",
        "codeSnippet": "x := 010",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Legacy octal `010` (Go 1.13+ prefers `0o10`). Keep? Actually `010` IS valid octal in Go (8). Is it error? No. \nError: `0xG`. \nOr: `1_000__000` (double underscore numeric separator).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_91_real",
        "title": "Double underscore numeric",
        "description": "Identify syntax.",
        "codeSnippet": "x := 1__000",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Only one underscore allowed as separator.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_91",
        "title": "Type definition",
        "description": "Is type T []int valid?",
        "codeSnippet": "type T []int",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, defines usage type.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_92",
        "title": "Mod on float",
        "description": "Identify type.",
        "codeSnippet": "x := 5.0 % 2.0",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Modulus `%` is only defined for integers. Use `math.Mod`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_92",
        "title": "Defer nil func",
        "description": "Does defer(nil) panic?",
        "codeSnippet": "defer nil",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Panic: defer requires function invocation.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_93",
        "title": "Append to nil slice pointer",
        "description": "Identify type match.",
        "codeSnippet": "var s *[]int\n*s = append(*s, 1)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`s` is nil pointer. Dereferencing `*s` panics.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_93",
        "title": "Map literal trailing comma",
        "description": "Is trailing comma required?",
        "codeSnippet": "m := map[int]int{\n    1: 1,\n}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes (and required if multi-line).",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_94",
        "title": "Self assignment",
        "description": "Identify useless code.",
        "codeSnippet": "x := 1\nx = x",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Self-assignment. Not an error, but 'useless'. Logic error? \nLet's try `x := x` (if x is outer). Valid. \nLet's find syntax error. `var x = 1, y = 2`. Go syntax: `var x, y = 1, 2`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_94_real",
        "title": "Var decl syntax",
        "description": "Identify syntax.",
        "codeSnippet": "var x = 1, y = 2",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Invalid syntax. Should be `var x, y = 1, 2`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_94",
        "title": "Interface type switch",
        "description": "Switch on non-interface?",
        "codeSnippet": "var i int\nswitch i.(type) {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Type switch only applicable to interfaces, not concrete types.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_95",
        "title": "Const address",
        "description": "Address of const",
        "codeSnippet": "const C = 1\np := &C",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot take address of constant.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_95",
        "title": "Nested function",
        "description": "Func inside func?",
        "codeSnippet": "func f() {\n    func g() {}\n}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Go does not support named nested functions. Use anonymous function assigned to variable: `g := func() {}`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_96",
        "title": "Fallthrough logic",
        "description": "Identify flow.",
        "codeSnippet": "switch x {\ncase 1:\n    fallthrough\n    fmt.Println(\"A\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`fallthrough` must be the last statement in the case block. Code after it is unreachable (or syntax error).",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_96",
        "title": "Ellipsis array length",
        "description": "Is [...]int valid?",
        "codeSnippet": "a := [...]int{1, 2}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler counts array length.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_97",
        "title": "Channel direction violation",
        "description": "Identify type constraint.",
        "codeSnippet": "var ch <-chan int\nch <- 1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot send to receive-only channel `<-chan`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_97",
        "title": "Loop label valid",
        "description": "Label before for?",
        "codeSnippet": "L:\nfor {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_98",
        "title": "Short decl nil",
        "description": "Identify type inference.",
        "codeSnippet": "x := nil",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`nil` does not have a default type. Compiler cannot infer type of `x`. Must use `var x *int = nil`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_98",
        "title": "Struct compare",
        "description": "Are structs comparable?",
        "codeSnippet": "s1 == s2",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, if all fields are comparable.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_99",
        "title": "Wrong range for string",
        "description": "Identify types.",
        "codeSnippet": "for i, v := range \"abc\" {\n    // v is byte?\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Not error. `v` is `rune` (int32). \nError logic: Assuming `v` is byte index? Valid code though. \nLet's choose `invalid indirect of`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_99_real",
        "title": "Indirection of non-pointer",
        "description": "Identify operator usage.",
        "codeSnippet": "x := 1\ny := *x",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot indirect `*` a non-pointer `x`.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_99",
        "title": "Import dot",
        "description": "Is . import valid?",
        "codeSnippet": "import . \"fmt\"",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, imports symbols into local namespace.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_100",
        "title": "Continue with label not loop",
        "description": "Identify flow.",
        "codeSnippet": "L: switch x {\ncase 1:\n    continue L\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`continue` only applies to loops. Even with label `L` pointing to switch, `continue` is invalid. `break` is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "go_tf_100",
        "title": "Goto usage",
        "description": "Is goto valid?",
        "codeSnippet": "goto Label",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, jumps to label.",
        "difficultyLevel": 2
    },
    {
        "id": "go_err_101",
        "title": "Unsafe slice header modification",
        "description": "Identify unsafe pointer misuse.",
        "codeSnippet": "s := []int{1}\nsh := (*reflect.SliceHeader)(unsafe.Pointer(&s))\nsh.Data = 0 // Invalid pointer",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Modifying `SliceHeader` directly is deprecated/dangerous. `Data` field is `uintptr`, not a pointer. Garbage collector doesn't track it. If underlying array moves (unlikely) or collected, crash. (Specifically, holding a uintptr to an object doesn't prevent collection).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_101",
        "title": "CGO import",
        "description": "Is import \"C\" valid?",
        "codeSnippet": "import \"C\"",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, pseudo-package for Cgo.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_102",
        "title": "Finalizer usage",
        "description": "Identify SetFinalizer race.",
        "codeSnippet": "obj := &Object{}\nruntime.SetFinalizer(obj, func(o *Object) {})\n// obj used later?",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "If `obj` is not kept alive, finalizer might run while code is still using `obj`? Or if finalizer creates reference? Complex logic. \nLet's choose `recover` in goroutine created inside defer.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_102_real",
        "title": "Recover logic",
        "description": "Identify recover scope.",
        "codeSnippet": "func f() {\n    defer func() {\n        go func() { recover() }()\n    }()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`recover` must be called directly by a deferred function. Calling it inside a nested goroutine (even inside defer) does not stop the panic checking of the original goroutine.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_102",
        "title": "Linkname directive",
        "description": "Is go:linkname valid?",
        "codeSnippet": "//go:linkname localname importpath.name",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler directive (requires unsafe import usually).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_103",
        "title": "Generic type constraint",
        "description": "Identify syntax.",
        "codeSnippet": "func F[T any](x T) {\n    if x == nil {}\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot compare generic type `T` to `nil` directly if `T` can be non-pointer/non-interface type (e.g. int). Must use comparable constraint or check reflection.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_103",
        "title": "Build tag",
        "description": "Is //go:build valid?",
        "codeSnippet": "//go:build linux || darwin",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, new build constraints syntax.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_104",
        "title": "Sync map type safety",
        "description": "Identify type usage.",
        "codeSnippet": "var m sync.Map\nm.Store(\"key\", 1)\nv, _ := m.Load(\"key\")\ni := v.(string)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 3,
        "explanation": "Stored value is `int` (1). Asserting to `string` causes panic.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_104",
        "title": "Embedded field promotion",
        "description": "Are methods promoted?",
        "codeSnippet": "type Inner struct{}; func (Inner) M() {}\ntype Outer struct{ Inner }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `Outer` has method `M`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_105",
        "title": "Defer loop resource leak",
        "description": "Identify resource usage.",
        "codeSnippet": "for _, f := range files {\n    f, _ := os.Open(f)\n    defer f.Close()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "`defer` executes when function returns, not loop iteration. Keeps all files open until function exit. Potential file descriptor exhaustion.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_105",
        "title": "Method expression",
        "description": "Is T.M valid?",
        "codeSnippet": "f := (*S).M",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, method expression (returns function with receiver as first argument).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_106",
        "title": "Race condition closure",
        "description": "Identify data race.",
        "codeSnippet": "count := 0\nfor i := 0; i < 1000; i++ {\n    go func() { count++ }()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Data race on `count`. `count++` is not atomic. Multiple goroutines write to it.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_106",
        "title": "Plugin open",
        "description": "Is plugin.Open valid?",
        "codeSnippet": "p, _ := plugin.Open(\"mod.so\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, but Linux/macOS only.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_107",
        "title": "Interface nil implementation",
        "description": "Identify nil behavior.",
        "codeSnippet": "type I interface{ M() }\ntype S struct{}\nfunc (s *S) M() {}\nvar s *S = nil\nvar i I = s\nif i == nil {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 5,
        "explanation": "`i` is an interface containing a typed nil pointer (`*S`, nil). An interface is nil only if type AND value are nil. Here type is `*S`. `i == nil` is false.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_107",
        "title": "Select priority",
        "description": "Is select random?",
        "codeSnippet": "select { case <-c1: case <-c2: }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, if multiple ready, chooses pseudo-randomly.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_108",
        "title": "Unaddressable array element",
        "description": "Identify limitation.",
        "codeSnippet": "m := map[int][2]int{1: {1, 2}}\nm[1][0] = 3",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot assign to field/index of map value directly. Map value is not addressable. Must replace whole value.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_108",
        "title": "Generic struct",
        "description": "Is struct[T] valid?",
        "codeSnippet": "type List[T any] struct {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, generic structs.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_109",
        "title": "Invalid type approximation",
        "description": "Identify syntax.",
        "codeSnippet": "func f[T ~int | string](x T) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Approximation `~` allowed for `~int`, but not `~string` if undefined? Actually syntax `~int | string` is valid constraint. Error might be `string` not underlying type? No. \nLet's try: `func f[T int](x T)` -> `int` is not an interface, but Go 1.18 allows basic types as constraints. \nError: `type A = ~int`. `~` only valid in interface/constraint definition.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_109_real",
        "title": "Tilde outside constraint",
        "description": "Identify syntax.",
        "codeSnippet": "type MyInt ~int",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Approximation types `~T` can only be used in type constraints (interfaces), not in regular type definitions.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_109",
        "title": "Context Cancel",
        "description": "Does cancel propagate?",
        "codeSnippet": "ctx, cancel := context.WithCancel(parent)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_110",
        "title": "Recursive call stack overflow",
        "description": "Identify infinite recursion.",
        "codeSnippet": "func (s S) String() string {\n    return fmt.Sprintf(\"%v\", s)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`fmt.Sprintf(\"%v\", s)` calls `s.String()` if implemented, causing infinite recursion. Use `(S)(s)` or printed fields.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_110",
        "title": "Runtime Caller",
        "description": "Is runtime.Caller valid?",
        "codeSnippet": "pc, file, line, ok := runtime.Caller(0)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, gets stack info.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_111",
        "title": "Copy overlapping",
        "description": "Identify logic.",
        "codeSnippet": "s := []int{1, 2, 3}\ncopy(s[1:], s[0:])",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`copy` handles overlapping slices correctly. Not an error. \nWait, is there an error? `s[0:]` len 3, `s[1:]` len 2. Copy 2 elements. `s` becomes `{1, 1, 2}`. Correct. \nError: `copy` arguments order. `copy(dst, src)`. Is this dst, src? Yes. \nLet's choose `invalid slice index` with negative constant.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_111_real",
        "title": "Negative index",
        "description": "Identify syntax.",
        "codeSnippet": "s[-1]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Go does not support negative indices (unlike Python). Panic/Compiler error.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_111",
        "title": "Reflect Value Set",
        "description": "Can Set() work?",
        "codeSnippet": "reflect.ValueOf(&x).Elem().SetInt(2)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, if addressable.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_112",
        "title": "Map key NaN",
        "description": "Identify special key.",
        "codeSnippet": "m := map[float64]int{}\nm[math.NaN()] = 1\nm[math.NaN()] = 2\n// len(m) == ?",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "NaN != NaN. Keys are distinct. `len(m)` is 2. Cannot retrieve values (unless iterating). Not an error, but tricky behavior. \nError: `const a = map[int]int{}` map constant.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_112_real",
        "title": "Const map",
        "description": "Identify const limit.",
        "codeSnippet": "const m = map[int]int{1: 1}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Maps cannot be constants.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_112",
        "title": "Unsafe Sizeof",
        "description": "Is Sizeof valid?",
        "codeSnippet": "unsafe.Sizeof(x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_113",
        "title": "Time Equal operator",
        "description": "Identify comparison.",
        "codeSnippet": "t1 := time.Now(); t2 := t1\nif t1 == t2 {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`time.Time` contains pointer (monotonic block)? Can use `==`? Struct equality works, but Time equality is complex (monotonic vs wall clock). Documentation recommends `t1.Equal(t2)`. `==` might behave unexpectedly across timezones/monotonicity. 'Code Reviewer' might flag use `Equal()`. (Go `time.Time` struct fields are private, `==` compares them).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_113",
        "title": "Go MaxProcs",
        "description": "Is GOMAXPROCS tunable?",
        "codeSnippet": "runtime.GOMAXPROCS(4)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_114",
        "title": "Shift count negative",
        "description": "Identify bitwise.",
        "codeSnippet": "x := 1 << -1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Shift count must be unsigned (or non-negative if constant). Compiler error.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_114",
        "title": "Syscall package",
        "description": "Is syscall frozen?",
        "codeSnippet": "syscall.Read(0, buf)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, but `golang.org/x/sys` is preferred.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_115",
        "title": "Interface conversion check missing",
        "description": "Identify assertion risk.",
        "codeSnippet": "func f(i interface{}) {\n    s := i.(string)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Unchecked type assertion panic if `i` is not `string`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_115",
        "title": "Rune slice to string",
        "description": "Is string(runes) valid?",
        "codeSnippet": "string([]rune{'\u65e5', '\u672c'})",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_116",
        "title": "Http Response Check",
        "description": "Identify logic.",
        "codeSnippet": "resp, _ := http.Get(url)\ndefer resp.Body.Close()",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "If `http.Get` returns error (e.g. connection refused), `resp` is nil. `resp.Body` panic. Must check error first.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_116",
        "title": "Method value",
        "description": "Is s.M valid func?",
        "codeSnippet": "f := s.M",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, method value (binds receiver).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_117",
        "title": "String null termination",
        "description": "Identify string structure.",
        "codeSnippet": "s := \"hello\\0\"",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid, string contains null byte. Not C-string. \nError: Accessing `&s[0]`? Valid in 1.22? \nError: `cap(string)`? strings don't have capacity? `len` yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_117_real",
        "title": "Cap of string",
        "description": "Identify builtin support.",
        "codeSnippet": "c := cap(\"s\")",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`cap` is not defined for strings.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_117",
        "title": "Generic type alias",
        "description": "Is type V[T] = T valid?",
        "codeSnippet": "type Vector[T any] = []T",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, generic type alias.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_118",
        "title": "Invalid generic constraint usage",
        "description": "Identify usage.",
        "codeSnippet": "type I interface{\n    int | string\n    M()\n}\nfunc f(i I) {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 4,
        "explanation": "Interface `I` contains type constraints (`int | string`). Can only be used as a type constraint, not as a variable type/argument `i I`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_118",
        "title": "Embed pointer to interface",
        "description": "Valid embedding?",
        "codeSnippet": "type S struct { *io.Reader }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes (but usually redundant/confusing, value `io.Reader` is already reference/pair).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_119",
        "title": "Cycle in type definition",
        "description": "Identify recursion.",
        "codeSnippet": "type T T",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Invalid recursive type `T`. Must use pointer/slice/map to break cycle. `type T *T` is valid?",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_119",
        "title": "TestMain entry",
        "description": "Is TestMain valid?",
        "codeSnippet": "func TestMain(m *testing.M)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, for global test setup/teardown.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_120",
        "title": "Compare slice constant",
        "description": "Identify logic.",
        "codeSnippet": "if s == []int{1} {}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Slice literal is not comparable.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_120",
        "title": "Sync Cond",
        "description": "Is sync.Cond valid?",
        "codeSnippet": "c := sync.NewCond(&mu)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_121",
        "title": "Json field unexported",
        "description": "Identify access.",
        "codeSnippet": "type S struct { id int }",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "JSON encoder ignores unexported `id`. If intention to serialize, must be exported.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_121",
        "title": "Struct tag reflection",
        "description": "Can read tag?",
        "codeSnippet": "field.Tag.Get(\"json\")",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_122",
        "title": "Defer arguments evaluation",
        "description": "Identify timing.",
        "codeSnippet": "start := time.Now()\ndefer fmt.Println(time.Since(start))",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`time.Since(start)` is evaluated at defer call time (immedately), not return time. Prints ~0. Use closure `defer func() { ... }()`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_122",
        "title": "Make slice capacity check",
        "description": "Check capacity?",
        "codeSnippet": "if cap(s) < n { s = make(...) }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_123",
        "title": "Unsafe OffsetOf",
        "description": "Identify struct field.",
        "codeSnippet": "unsafe.Offsetof(s.f)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `unsafe.Offsetof(x)` where `x` is variable not struct field selection? `Offsetof(v)` -> invalid. Must be `s.f`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_123_real",
        "title": "OffsetOf variable",
        "description": "Identify syntax.",
        "codeSnippet": "unsafe.Offsetof(x)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Argument to `Offsetof` must be a selector expression `s.f`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_123",
        "title": "Array pointer index",
        "description": "Index ptr to array?",
        "codeSnippet": "p := &[3]int{}; x := p[1]",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, automatic dereference.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_124",
        "title": "Map read nil",
        "description": "Identify behavior.",
        "codeSnippet": "var m map[int]int // nil\nv := m[1]",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Read from nil map is valid (returns zero value). Not error. \nAssignment is panic. \nError: `cap(map)`? \nMaps don't have capacity query (only make hint).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_124_real",
        "title": "Cap of map",
        "description": "Identify builtin.",
        "codeSnippet": "c := cap(m)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`cap` is not defined for maps (only slices, arrays, channels).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_124",
        "title": "Struct alignment",
        "description": "Is unsafe.Alignof valid?",
        "codeSnippet": "unsafe.Alignof(x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_125",
        "title": "Type switch variable scope",
        "description": "Identify scope.",
        "codeSnippet": "switch v := i.(type) {\ncase int:\n    // v is int\n}\n// v accessed here",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 4,
        "explanation": "`v` is scoped to switch statement.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_125",
        "title": "Close receive-only chan",
        "description": "Can close <-chan?",
        "codeSnippet": "func f(c <-chan int) { close(c) }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": false,
        "explanation": "Cannot close receive-only channel.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_126",
        "title": "Select case nil channel",
        "description": "Identify blocking.",
        "codeSnippet": "var c chan int\nselect {\ncase <-c:\n    fmt.Println(\"Recv\")\ndefault:\n    fmt.Println(\"Def\")\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid. Nil channel case blocks forever, but `default` executes immediately. \nError: `select` with empty body blocks forever? Valid. \nLet's choose `invalid type switch` on type alias of interface?",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_126_real",
        "title": "Type switch duplicate case",
        "description": "Identify redundancy.",
        "codeSnippet": "switch v.(type) {\ncase int:\ncase int:\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Duplicate case `int` in type switch.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_126",
        "title": "Stack trace print",
        "description": "Is debug.Stack() valid?",
        "codeSnippet": "debug.Stack()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_127",
        "title": "Unsafe pointer conversion logic",
        "description": "Identify GC risk.",
        "codeSnippet": "u := uintptr(unsafe.Pointer(p))\n// GC happens here\np2 := unsafe.Pointer(u)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Converting pointer to `uintptr` and back is unsafe if GC runs in between (GC doesn't track uintptr, might move/collect object). Must be single expression.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_127",
        "title": "Runtime KeepAlive",
        "description": "Is KeepAlive valid?",
        "codeSnippet": "runtime.KeepAlive(x)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, ensures x is reachable until this point.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_128",
        "title": "Invalid map iteration modification",
        "description": "Identify logic.",
        "codeSnippet": "for k := range m {\n    delete(m, k)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Safe to delete keys during iteration in Go (unlike Java/C++). Valid. \nError: `concurrent map read and map write`. \nCode: `go func() { m[1]=1 }(); m[1]` without lock. \nLet's assume Code Reviewer spots strictness. \nLet's stick to `ambiguous selector`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_128_real",
        "title": "Ambiguous selector",
        "description": "Identify ambiguity.",
        "codeSnippet": "type A struct{ x int }\ntype B struct{ x int }\ntype C struct{ A; B }\nvar c C\n_ = c.x",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 4,
        "explanation": "Ambiguous selector `c.x`. `x` exists in both embedded `A` and `B`. Must identify `c.A.x` or `c.B.x`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_128",
        "title": "Testing Benchmark",
        "description": "Is Benchmark valid?",
        "codeSnippet": "func BenchmarkX(b *testing.B)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_129",
        "title": "Generic type recursive constraint",
        "description": "Identify cycle.",
        "codeSnippet": "type T[P T[P]] struct{}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Constraint `T[P]` referring to type `T` being defined. Go generics allow recursive types but constraint usage is tricky. Is this valid? `type Node[T any] struct { next *Node[T] }` is valid. \n`type T[P T[P]]`? `P` must satisfy `T[P]`. `T` is struct. Struct is not interface. Invalid constraint (constraint must be interface).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_129",
        "title": "Embed interface in struct",
        "description": "Is valid?",
        "codeSnippet": "type S struct { error }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, embeds interface.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_130",
        "title": "Defer in loop variable snapshot",
        "description": "Identify resource limit.",
        "codeSnippet": "for i := 0; i < 10000; i++ {\n    defer fmt.Println(i)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Defers pile up on stack until function returns. Stack overflow risk if loop is large.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_130",
        "title": "Method set pointer",
        "description": "Does *T have T methods?",
        "codeSnippet": "type T int; func (T) M() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `*T` method set includes methods of `T`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_131",
        "title": "Json marshal channel",
        "description": "Identify support.",
        "codeSnippet": "json.Marshal(make(chan int))",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`json.Marshal` returns error `json: unsupported type: chan int`. Channels cannot be marshaled.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_131",
        "title": "Unsafe Add",
        "description": "Is unsafe.Add valid?",
        "codeSnippet": "unsafe.Add(ptr, len)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes (Go 1.17+).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_132",
        "title": "Recover return value type",
        "description": "Identify return.",
        "codeSnippet": "x := recover().(error)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`recover()` returns `interface{}` (nil if no panic). Unchecked assertion `.(error)` panics if recover returns nil or non-error (e.g. panic(string)).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_132",
        "title": "Testing Short",
        "description": "Is testing.Short valid?",
        "codeSnippet": "if testing.Short() {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_133",
        "title": "Goto jump over decl",
        "description": "Identify scope violation.",
        "codeSnippet": "goto L\nvar x int\nL:",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Jumping over variable declaration `x` is forbidden.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_133",
        "title": "Fuzz testing",
        "description": "Is FuzzX valid?",
        "codeSnippet": "func FuzzX(f *testing.F)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes (Go 1.18+).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_134",
        "title": "Invalid complex constants",
        "description": "Identify syntax.",
        "codeSnippet": "const c = complex(1, 2)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid, `complex` built-in allowed in constant expression. \nError: `const c = make(chan int)`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_134_real",
        "title": "Make in constant",
        "description": "Identify runtime expr.",
        "codeSnippet": "const m = make([]int, 0)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "`make` is runtime call, not constant.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_134",
        "title": "Struct tag convention",
        "description": "Is snake_case preferred?",
        "codeSnippet": "`json:\"user_id\"`",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, common convention for JSON.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_135",
        "title": "Map modify unaddressable",
        "description": "Identify limitation.",
        "codeSnippet": "type S struct { x int }\nm := map[int]S{1: {1}}\nm[1].x = 2",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Cannot assign to field `x` of map element (struct value). `m[1]` is not addressable. Must reassign whole struct.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_135",
        "title": "Embed pointer to struct",
        "description": "Is *Struct valid embed?",
        "codeSnippet": "type S struct { *T }",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_136",
        "title": "Receiver pointer safety",
        "description": "Identify logic.",
        "codeSnippet": "func (s *S) M() {\n    if s == nil { return }\n    _ = s.x\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "Valid, checking nil receiver. \nError: `func (s S) M()` nil check? \nValue receiver `s` cannot be nil (it's copy). \nSo `if s == nil` is type mismatch? No, struct cannot be nil. \nLet's choose `invalid receiver type` -> array.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_136_real",
        "title": "Nil check on value receiver",
        "description": "Identify unnecessary check.",
        "codeSnippet": "func (s S) M() {\n    if s == nil {}\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Value receiver `s` (struct) can never be nil. Comparison `s == nil` is mismatched types (struct vs nil).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_136",
        "title": "Go directive",
        "description": "Is //go:noinline valid?",
        "codeSnippet": "//go:noinline",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler directive.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_137",
        "title": "Channel buffer negative",
        "description": "Identify bounds.",
        "codeSnippet": "make(chan int, -1)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Channel buffer size cannot be negative. Panic.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_137",
        "title": "Reflect DeepEqual",
        "description": "Is deep equal valid?",
        "codeSnippet": "reflect.DeepEqual(a, b)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_138",
        "title": "Invalid map key slice",
        "description": "Identify key constraint.",
        "codeSnippet": "var m map[[]byte]int",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Slice `[]byte` is not comparable. Cannot be map key.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_138",
        "title": "Binary package",
        "description": "Is binary.BigEndian valid?",
        "codeSnippet": "binary.BigEndian.Uint64(b)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_139",
        "title": "Type alias recursive",
        "description": "Identify cycle.",
        "codeSnippet": "type T = T",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Recursive type alias `T = T` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_139",
        "title": "Runtime NumCPU",
        "description": "Is NumCPU valid?",
        "codeSnippet": "runtime.NumCPU()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_140",
        "title": "Waitgroup negative counter",
        "description": "Identify logic.",
        "codeSnippet": "wg.Add(-1)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "If counter goes negative, WaitGroup panics. If current count is 0, `Add(-1)` panics.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_140",
        "title": "IOTA expression",
        "description": "Is 1 << iota valid?",
        "codeSnippet": "const ( A = 1 << iota )",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_141",
        "title": "Close receive chan",
        "description": "Identify usage.",
        "codeSnippet": "func f(ch <-chan int) {\n    close(ch)\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot close receive-only channel.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_141",
        "title": "Testing T Parallel",
        "description": "Is t.Parallel() valid?",
        "codeSnippet": "t.Parallel()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, marks test as parallel.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_142",
        "title": "Slice array pointer assignment",
        "description": "Identify type mismatch.",
        "codeSnippet": "var s []int\nvar a *[10]int = s",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Cannot assign slice `[]int` to array pointer `*[10]int` directly (Go 1.17 allows conversion `(*[10]int)(s)`, but assignment requires conversion syntax).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_142",
        "title": "Context WithTimeout",
        "description": "Is WithTimeout valid?",
        "codeSnippet": "ctx, cancel := context.WithTimeout(ctx, 1*time.Second)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_143",
        "title": "Range over func",
        "description": "Identify range type.",
        "codeSnippet": "for x := range func() int { return 1 } {\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Cannot range over function. Go 1.22 introduced range over integer `range n`. Go 1.23 might add range over func/iterators? Assuming standard Go < 1.23, range only supports array, slice, string, map, channel.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_143",
        "title": "Sync Pool",
        "description": "Is usage valid?",
        "codeSnippet": "pool.Get()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_144",
        "title": "Method call on nil interface",
        "description": "Identify panic.",
        "codeSnippet": "var err error // nil\ns := err.Error()",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Method call on nil interface `err` panics. `err` does not hold a value with `Error()` method.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_144",
        "title": "Errors Is",
        "description": "Is errors.Is valid?",
        "codeSnippet": "errors.Is(err, target)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_145",
        "title": "Concurrent map write",
        "description": "Identify race.",
        "codeSnippet": "m := make(map[int]int)\ngo func() { m[1] = 1 }()\nm[1] = 2",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Concurrent modification of map. Race condition. Panic.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_145",
        "title": "Generic Comparable",
        "description": "Is comparable constraint valid?",
        "codeSnippet": "func f[T comparable](x T) {}",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_146",
        "title": "Invalid type assertion non-interface",
        "description": "Identify syntax.",
        "codeSnippet": "var s string\nx := s.(int)",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "Type assertion `s.(int)` is only valid if `s` is an interface. `s` is concrete string.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_146",
        "title": "Errors As",
        "description": "Is errors.As valid?",
        "codeSnippet": "errors.As(err, &target)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_147",
        "title": "Select timeout usage",
        "description": "Identify resource leak.",
        "codeSnippet": "select {\ncase <-time.After(time.Second):\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`time.After` leaks timer if select breaks early (in tight loop). Use `time.NewTimer` + `Stop()` if needed efficiently. Not fatal error but 'leak'? Code Reviewer flags logical efficiency. Error: `select` syntax valid.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_147_real",
        "title": "Duplicate select case",
        "description": "Identify redundancy.",
        "codeSnippet": "select {\ncase <-c:\ncase <-c:\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 2,
        "explanation": "Duplicate case logic (runtime behavior unspecified choice). But duplicates are generally useless. Pure error: `case 1:` in select (not chan op).",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_147",
        "title": "Atomic Add",
        "description": "Is atomic.AddInt64 valid?",
        "codeSnippet": "atomic.AddInt64(&x, 1)",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_148",
        "title": "Invalid chan receive",
        "description": "Identify syntax logic.",
        "codeSnippet": "var c chan int\nvar x = <-c <- c",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 1,
        "explanation": "`<-c <- c` parses as `<- (c <- c)`. `c<-c` is send `c` into `c`. `<-` results in receive from result of send? Send statement returns nothing. Syntax error.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_148",
        "title": "Build tag constraints",
        "description": "Is convention valid?",
        "codeSnippet": "// +build linux",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, older syntax (still respected).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_149",
        "title": "Sync WaitGroup Copy",
        "description": "Identify race.",
        "codeSnippet": "func f(wg sync.WaitGroup) {\n    wg.Done()\n}",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Passes WaitGroup by value. `wg.Done()` affects copy, not original. Deadlock in caller.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_149",
        "title": "Generics any constraint",
        "description": "Is any valid?",
        "codeSnippet": "func f[T any]()",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes, `any` is alias for `interface{}`.",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_150",
        "title": "Invalid rune constant",
        "description": "Identify bounds.",
        "codeSnippet": "const r rune = -1",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": -1,
        "explanation": "`rune` is `int32`. -1 is valid int32. Valid. \nError: `const r rune = 'ab'` (multi-char).",
        "difficultyLevel": 3
    },
    {
        "id": "go_err_150_real",
        "title": "Multi char rune",
        "description": "Identify syntax.",
        "codeSnippet": "c := 'ab'",
        "type": "errorSpotting",
        "language": "go",
        "errorLineIndex": 0,
        "explanation": "Rune literal must be single character (or escaped sequence). 'ab' is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "go_tf_150",
        "title": "Sync Once",
        "description": "Is Do valid?",
        "codeSnippet": "once.Do(func() {})",
        "type": "trueOrFalse",
        "language": "go",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    }
]