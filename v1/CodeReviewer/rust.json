[
    {
        "id": "rust_err_1",
        "title": "Uninitialized Variable",
        "description": "Identify compiler error.",
        "codeSnippet": "fn main() {\n    let x: i32;\n    println!(\"{}\", x);\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Rust compiler prevents using uninitialized variables. `x` must be initialized before use.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_1",
        "title": "Variable Immutability",
        "description": "Are variables immutable by default?",
        "codeSnippet": "let x = 5;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, variables in Rust are immutable by default. Need `mut` keyword to make them mutable.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_2",
        "title": "Mutable Assignment",
        "description": "Identify mutability error.",
        "codeSnippet": "fn main() {\n    let x = 5;\n    x = 6;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`x` is immutable by default. Cannot assign twice. Use `let mut x = 5;`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_2",
        "title": "Statement Semicolon",
        "description": "Is return optional at block end?",
        "codeSnippet": "fn add(a: i32, b: i32) -> i32 {\n    a + b\n}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, omitting semicolon at the end of a block returns the expression's value.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_3",
        "title": "Type Mismatch",
        "description": "Identify type error.",
        "codeSnippet": "let x: i32 = \"Hello\";",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Trying to assign a string literal `&str` to an integer variable `i32`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_3",
        "title": "Function Snake Case",
        "description": "Is snake_case naming standard?",
        "codeSnippet": "fn MyFunction() {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "It assumes valid code. But Rust convention is `snake_case`. Compiler warns about `CamelCase` functions (non-standard style), but code is syntactically correct/runnable (with warning). But commonly considered 'False' if question asks about strict style? Or 'Is this idiomatic?'. If 'Is code correct?' -> True (compiles). But conventionally wrong. Let's assume idiomatism is not syntax error.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_4",
        "title": "Ownership Move",
        "description": "Identify ownership error.",
        "codeSnippet": "let s1 = String::from(\"hello\");\nlet s2 = s1;\nprintln!(\"{}\", s1);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`s1` moved to `s2`. `s1` is no longer valid. Using `s1` causes compile error (borrow of moved value).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_4",
        "title": "Copy Trait Integers",
        "description": "Do integers implement Copy?",
        "codeSnippet": "let x = 5;\nlet y = x;\nprintln!(\"{}\", x);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, primitive integers implement `Copy` trait, so `x` is copied, not moved. `x` remains valid.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_5",
        "title": "Borrow Checker Mutable",
        "description": "Identify borrowing rule.",
        "codeSnippet": "let mut s = String::from(\"hello\");\nlet r1 = &mut s;\nlet r2 = &mut s;\nprintln!(\"{}, {}\", r1, r2);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Cannot borrow `s` as mutable more than once at a time (`r1` and `r2` overlap).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_5",
        "title": "If Let Syntax",
        "description": "Is if let valid?",
        "codeSnippet": "if let Some(x) = opt { }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `if let` is idiomatic Rust for matching a single pattern.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_6",
        "title": "Const Variable Type",
        "description": "Identify missing type.",
        "codeSnippet": "const MAX_POINTS = 100000;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Constants must explicitly annotate type. `const MAX_POINTS: u32 = 100000;`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_6",
        "title": "Tuple Indexing",
        "description": "Is tuple.0 valid?",
        "codeSnippet": "let t = (1, 2);\nlet x = t.0;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, tuple elements are accessed via dot notation and index.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_7",
        "title": "Array Index Out of Bounds",
        "description": "Identify runtime panic/check.",
        "codeSnippet": "let a = [1, 2, 3];\nlet x = a[10];",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Index `10` is out of bounds for array of length 3. Rust panics at runtime (or compile time if index is constant).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_7",
        "title": "Loop Keyword",
        "description": "Is loop infinite?",
        "codeSnippet": "loop { break; }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `loop` creates an infinite loop, exited with `break`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_8",
        "title": "Wait for return type",
        "description": "Identify signature.",
        "codeSnippet": "fn five() -> i32 {\n    \"5\"\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Function expects `i32` return, but returns a string literal `&str`. Type mismatch.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_8",
        "title": "Vec literal macro",
        "description": "Is vec! valid?",
        "codeSnippet": "let v = vec![1, 2, 3];",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `vec!` macro creates a `Vec<T>`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_9",
        "title": "Match Exhaustive",
        "description": "Identify match error.",
        "codeSnippet": "let x = 1;\nmatch x {\n    1 => println!(\"one\"),\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`match` arms must cover all possible values. `i32` can be other than 1. Missing `_ => ...` catch-all.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_9",
        "title": "String concatenation",
        "description": "Is + operator valid?",
        "codeSnippet": "let s = String::from(\"a\") + \"b\";",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `+` operator calls `add`, taking ownership of left side and borrowing right (`&str`).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_10",
        "title": "Shadowing Mutability",
        "description": "Identify logic/syntax.",
        "codeSnippet": "let x = 5;\nx = 6;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Variable `x` is immutable. Cannot assign to it. Shadowing (`let x = 6;`) would be valid, but assignment `x=6` is error.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_10",
        "title": "Struct Syntax",
        "description": "Is struct definition valid?",
        "codeSnippet": "struct User { username: String, active: bool }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, standard struct definition.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_11",
        "title": "Print macro args",
        "description": "Identify placeholder mismatch.",
        "codeSnippet": "let x = 5;\nprintln!(\"x is {}\");",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Missing argument for placeholder `{}`. Should be `println!(\"x is {}\", x);`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_11",
        "title": "Range syntax",
        "description": "Is 1..5 valid?",
        "codeSnippet": "for i in 1..5 {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `1..5` is a range (1 to 4).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_12",
        "title": "Return in void function",
        "description": "Identify return type.",
        "codeSnippet": "fn f() {\n    return 5;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Function `f` implicitly returns unit `()`. Explicit return `5` (integer) mismatches return type.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_12",
        "title": "Unit Type",
        "description": "Is () a value?",
        "codeSnippet": "let x: () = ();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `()` is both the unit type and the unit value.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_13",
        "title": "Char vs String",
        "description": "Identify literal.",
        "codeSnippet": "let c: char = \"a\";",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Double quotes `\"a\"` create a string slice `&str`. Single quotes `'a'` create a `char`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_13",
        "title": "Pub Keyword",
        "description": "Does pub make it public?",
        "codeSnippet": "pub fn my_func() {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `pub` makes the item visible outside the module.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_14",
        "title": "Reference to freed memory",
        "description": "Identify lifetime/scope.",
        "codeSnippet": "fn dangling() -> &String {\n    let s = String::from(\"hello\");\n    &s\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`s` is dropped at end of function. Returning a reference `&s` to it is invalid (dangling pointer).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_14",
        "title": "Enum Option",
        "description": "Is Option::None valid?",
        "codeSnippet": "let x: Option<i32> = None;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Option` enum is standard prelude (Some/None).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_15",
        "title": "Unwrap None",
        "description": "Identify panic.",
        "codeSnippet": "let x: Option<i32> = None;\nlet y = x.unwrap();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Calling `unwrap()` on `None` causes a runtime panic.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_15",
        "title": "While Loop",
        "description": "Is while valid loop?",
        "codeSnippet": "while true {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes. (Compiler might suggest `loop` instead, but syntactically correct).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_16",
        "title": "Parse unwrap",
        "description": "Identify result handling.",
        "codeSnippet": "let n: i32 = \"abc\".parse().unwrap();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`\"abc\"` cannot be parsed as `i32`. `parse` returns `Err`. `unwrap` panics.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_16",
        "title": "Reference syntax",
        "description": "Is &x a borrow?",
        "codeSnippet": "let x = 5; let r = &x;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `&` creates a reference.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_17",
        "title": "Binary literal prefix",
        "description": "Identify literal syntax.",
        "codeSnippet": "let b = 0b12;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Binary literals start with `0b` followed by 0s and 1s. `2` is invalid digit in binary.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_17",
        "title": "Modulus operator",
        "description": "Is % standard?",
        "codeSnippet": "let r = 10 % 3;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `%` is the remainder operator.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_18",
        "title": "Main args",
        "description": "Identify main signature.",
        "codeSnippet": "fn main(args: Vec<String>) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Standard `main` in Rust takes no arguments. Command line args are accessed via `std::env::args()`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_18",
        "title": "Impl block",
        "description": "Is impl Struct valid?",
        "codeSnippet": "struct S; impl S {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, method implementation block.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_19",
        "title": "Comparison Chaining",
        "description": "Identify syntax limit.",
        "codeSnippet": "if 1 < 2 < 3 {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Rust does not support chained comparisons like Python. Expressions evaluate left to right: `(1<2)` is bool. `bool < 3` is type error.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_19",
        "title": "Underscore placeholder",
        "description": "Is _ valid pattern?",
        "codeSnippet": "match x { _ => () }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `_` matches anything (wildcard).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_20",
        "title": "Empty match",
        "description": "Identify match block.",
        "codeSnippet": "let x = 1;\nmatch x {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Match block cannot be empty. Must handle possible values of `x`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_20",
        "title": "Use keyword",
        "description": "Does use import?",
        "codeSnippet": "use std::io;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, imports module into scope.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_21",
        "title": "Private field access",
        "description": "Identify visibility.",
        "codeSnippet": "mod m { struct S { x: i32 } }\nfn f() { let s = m::S { x: 1 }; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Field `x` in `m::S` is private by default. Cannot construct struct with private fields from outside module.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_21",
        "title": "Static lifetime",
        "description": "Is 'static valid?",
        "codeSnippet": "let s: &'static str = \"hello\";",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, string literals have `'static` lifetime.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_22",
        "title": "Self naming",
        "description": "Identify method syntax.",
        "codeSnippet": "impl S {\n    fn new(Self) -> S { S }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`Self` in arguments must be `self`, `&self`, or `&mut self`. `Self` is a type. `new` is usually a static method (no self). Here `(Self)` assumes parameter name `Self`? No, type `Self`. Missing param name. e.g., `fn new(s: Self)` or standard constructor `fn new()`. Error is bad syntax for arg.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_22",
        "title": "Assert macro",
        "description": "Is assert! standard?",
        "codeSnippet": "assert!(true);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_23",
        "title": "Continue outside loop",
        "description": "Identify scope.",
        "codeSnippet": "fn f() {\n    continue;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`continue` usage restricted to loops.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_23",
        "title": "Comments",
        "description": "Is // valid comment?",
        "codeSnippet": "// Comment",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_24",
        "title": "Function overloading",
        "description": "Identify feature missing.",
        "codeSnippet": "fn f(x: i32) {}\nfn f(x: f64) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Rust does not support function overloading (defining multiple functions with same name but different signature).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_24",
        "title": "Format string debug",
        "description": "Is {:?} debug?",
        "codeSnippet": "println!(\"{:?}\", x);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `{:?}` uses the `Debug` trait.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_25",
        "title": "Box dereference move",
        "description": "Identify move semantics.",
        "codeSnippet": "let b = Box::new(String::from(\"Hi\"));\nlet s = *b;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Moving content out of box via dereference `*b`. Valid? Yes. But if `b` is used later? Snippet looks valid. \nWait. `Box<String>` deref is `String`. `let s = *b` moves the String out of the Box. `b` is now invalid (partially moved?). Actually `b` is consumed. \nLet's assume the error is trying to use `b` after? Or maybe `let s = *b` is valid move. \nMaybe `let s = *b` is error if `b` is shared ref? \nLet's pick an easier one: `let x = *&5;` valid. \nWhat about `&mut immutable`?\nCode: `let x = 5; let y = &mut x;` -> Error: `x` not mutable.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_25_real",
        "title": "Borrow Immutable as Mutable",
        "description": "Identify mutability.",
        "codeSnippet": "let x = 5;\nlet y = &mut x;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`x` is immutable. Cannot take mutable reference `&mut x`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_25",
        "title": "Raw String Literal",
        "description": "Is r#\"...\"# valid?",
        "codeSnippet": "let s = r#\"raw string\"#;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, raw string literals ignore escapes.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_26",
        "title": "Use of uninitialized binding",
        "description": "Identify flow.",
        "codeSnippet": "let x: i32;\nif true { x = 1; }\nprintln!(\"{}\", x);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Rust must guarantee `x` is initialized in all paths. If condition is not met (compiler might not know `true` is const here?), `x` might be uninitialized. For simple `if true`, some versions might allow, but generally conditional init requires coverage or `let x = if ...`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_26",
        "title": "Char byte size",
        "description": "Is char 4 bytes?",
        "codeSnippet": "std::mem::size_of::<char>()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `char` in Rust represents a Unicode Scalar Value and is always 4 bytes.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_27",
        "title": "Match arms incompatible types",
        "description": "Identify return type.",
        "codeSnippet": "let x = match true {\n    true => 1,\n    false => \"no\",\n};",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Match arms must return the same type. `1` is integer, `\"no\"` is `&str`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_27",
        "title": "Static mut unsafe",
        "description": "Is accessing static mut unsafe?",
        "codeSnippet": "static mut N: i32 = 0;\nunsafe { N += 1; }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, modifying or accessing `static mut` is `unsafe`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_28",
        "title": "Reference to reference syntax",
        "description": "Identify deref.",
        "codeSnippet": "let x = 5;\nlet r = &&x;\nprintln!(\"{}\", **r);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid code (double deref). \nError: `let r = &x; println!(\"{}\", **r);` -> Double deref on single ref?",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_28_real",
        "title": "Unwrap err",
        "description": "Panic identification.",
        "codeSnippet": "let r: Result<i32, &str> = Err(\"fail\");\nr.expect(\"Error message\");",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Calling `expect` on an `Err` variant causes a panic with the message.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_28",
        "title": "As conversion",
        "description": "Is as keyword safe?",
        "codeSnippet": "let x = 100u32 as u8;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `as` performs conversions (numeric casts). Truncation may occur but it is safe.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_29",
        "title": "Modulus float",
        "description": "Identify type constraint.",
        "codeSnippet": "let x = 5.5 % 2.0;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid in Rust (`Rem` implemented for float). \nError: `let x = 5.5 % 2;` -> Type mismatch (float vs int).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_29_real",
        "title": "Mixed numeric types",
        "description": "Identify type mismatch.",
        "codeSnippet": "let a: i32 = 5;\nlet b: f64 = 2.0;\nlet c = a + b;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Rust does not support implicit casting between numeric types. `i32` + `f64` is error. Must cast `a as f64`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_29",
        "title": "Break value",
        "description": "Can break return value?",
        "codeSnippet": "let x = loop { break 5; };",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `break` can return a value from a loop expression.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_30",
        "title": "Field missing",
        "description": "Identify struct init.",
        "codeSnippet": "struct S { x: i32, y: i32 }\nlet s = S { x: 1 };",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Struct `S` has `y`, but `y` is missing in initializer.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_30",
        "title": "Derive Debug",
        "description": "Is derive valid?",
        "codeSnippet": "#[derive(Debug)]\nstruct S;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, standard derive macro.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_31",
        "title": "Private module",
        "description": "Identify visibility.",
        "codeSnippet": "mod a { fn f() {} }\nfn main() { a::f(); }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Function `f` is private in module `a`. Need `pub fn f`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_31",
        "title": "Let masking",
        "description": "Is let allowed in if?",
        "codeSnippet": "if let x = 5 { }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "`if let` expects a pattern match `if let Pat = Expr`. `if let x = 5` (irrefutable pattern `x`) is technically allowed but experimental/warned? Use `let x = 5;` or `if x == 5`. Wait. `if let x = 5` is valid irrefutable pattern in standard Rust? It warns. Question: Is it error? No, just warning. But usually `if let` implies check. `if true` is better. BUT code snippet `if let x = 5` is syntactically CORRECT. Explanation: 'Yes, but warns irrefutable'.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_32",
        "title": "Const func non-const",
        "description": "Identify const constraints.",
        "codeSnippet": "fn f() -> i32 { 1 }\nconst X: i32 = f();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot call non-const function `f` inside a const context. `f` needs to be `const fn`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_32",
        "title": "Return type inference",
        "description": "Does Rust infer return?",
        "codeSnippet": "fn f() { 1 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Block evaluates to `1` (integer) but function implies `-> ()` return (void). Mismatch. Error.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_33",
        "title": "Unsafe block required",
        "description": "Identify unsafe op.",
        "codeSnippet": "let p: *const i32 = std::ptr::null();\nlet x = *p;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Dereferencing raw pointer `p` requires `unsafe` block.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_33",
        "title": "String push_str",
        "description": "Does push_str take &str?",
        "codeSnippet": "s.push_str(\"hello\");",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, appends string slice.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_34",
        "title": "Immutable reference modify",
        "description": "Identify mutability.",
        "codeSnippet": "let mut x = 5;\nlet y = &x;\n*y = 6;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`y` is an immutable reference `&i32`. Cannot assign to `*y`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_34",
        "title": "Fn pointer type",
        "description": "Is fn() a type?",
        "codeSnippet": "let f: fn() = main;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, function pointer type.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_35",
        "title": "While let syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "while let opt = Some(1) { }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Syntax is `while let PATTERN = EXPRESSION`. `opt` is pattern (variable binding). But irrefutable pattern in while let? Wait. Syntax is `while let Some(x) = opt` usually. `while let opt = Some(1)` binds `opt` to `Some(1)`? This is irrefutable. Rust forbids irrefutable patterns in `while let`. \"irrefutable while-let pattern\".",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_35",
        "title": "String new",
        "description": "Is String::new() valid?",
        "codeSnippet": "let s = String::new();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, creates empty string.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_36",
        "title": "Move during borrow",
        "description": "Identify borrow rule.",
        "codeSnippet": "let s = String::from(\"Hi\");\nlet r = &s;\nlet s2 = s;\nprintln!(\"{}\", r);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Cannot move `s` (to `s2`) while it is borrowed (`r`).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_36",
        "title": "Vec macro trailing comma",
        "description": "Is vec![1,] valid?",
        "codeSnippet": "vec![1,]",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, trailing comma allowed.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_37",
        "title": "Self in static method",
        "description": "Identify self usage.",
        "codeSnippet": "impl S {\n    fn new() { self.x = 1; }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`new` does not take `self` parameter, so `self` is not available.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_37",
        "title": "Where clause",
        "description": "Is where valid?",
        "codeSnippet": "fn f<T>(x: T) where T: Display {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `where` clause specifies bounds.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_38",
        "title": "Trait impl missing method",
        "description": "Identify contract.",
        "codeSnippet": "trait T { fn f(&self); }\nimpl T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Implementation of trait `T` for `S` is missing function `f`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_38",
        "title": "Wildcard import",
        "description": "Is use * valid?",
        "codeSnippet": "use std::io::*;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, imports all items (glob import).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_39",
        "title": "Function arg shadowing",
        "description": "Identify arg check.",
        "codeSnippet": "fn f(x: i32, x: i32) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Duplicate argument name `x`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_39",
        "title": "Let binding tuple",
        "description": "Is let (x,y) valid?",
        "codeSnippet": "let (x, y) = (1, 2);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, destructing tuple assignment.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_40",
        "title": "Index string",
        "description": "Identify string access.",
        "codeSnippet": "let s = \"hello\";\nlet c = s[0];",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Rust strings cannot be indexed by integer constant directly (because of UTF-8). Use slice `&s[0..1]` or chars iterator.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_40",
        "title": "Bool cast to int",
        "description": "Is true as i32?",
        "codeSnippet": "true as i32",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `true` casts to `1`, `false` to `0`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_41",
        "title": "Main return type",
        "description": "Identify valid return.",
        "codeSnippet": "fn main() -> String {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`main` can return `()` or `Result<(), E>`. Returning `String` is not supported (normally).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_41",
        "title": "Char literal",
        "description": "Is 'ab' valid?",
        "codeSnippet": "let c = 'ab';",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Character literal must contain exactly one character.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_42",
        "title": "Lifetime missing",
        "description": "Identify constraints.",
        "codeSnippet": "struct S { r: &i32 }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Struct with reference field must have named lifetime parameter. `struct S<'a> { r: &'a i32 }`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_42",
        "title": "Mod block",
        "description": "Is mod valid?",
        "codeSnippet": "mod my_mod { }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, defines inline module.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_43",
        "title": "Break outer",
        "description": "Identify labeled break.",
        "codeSnippet": "'outer: loop { break outer; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Label must be used with `'` prefix in break. `break 'outer;`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_43",
        "title": "For loop range inclusive",
        "description": "Is 1..=5 valid?",
        "codeSnippet": "for i in 1..=5 {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `..=` creates inclusive range (1 to 5).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_44",
        "title": "Unreachable code",
        "description": "Identify warning/error.",
        "codeSnippet": "return;\nprintln!(\"Hi\");",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Code after `return` is unreachable. (Warning usually, not strict error logic wise, but good for spotting).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_44",
        "title": "If expression value",
        "description": "Does if return value?",
        "codeSnippet": "let x = if true { 5 } else { 6 };",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `if` is an expression in Rust.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_45",
        "title": "Tuple struct access",
        "description": "Identify field name.",
        "codeSnippet": "struct Color(i32, i32, i32);\nlet c = Color(0,0,0);\nlet r = c.x;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Tuple struct fields are accessed by index `0`, `1`, etc., not names (unless defined, but here just tuple). `c.0`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_45",
        "title": "Ref keyword pattern",
        "description": "Is ref used in match?",
        "codeSnippet": "match x { Some(ref r) => {} }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `ref` borrows value in pattern match.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_46",
        "title": "Static mut threading",
        "description": "Identify limitation.",
        "codeSnippet": "static mut X: i32 = 0;\n// usage without unsafe",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Accessing `static mut` requires `unsafe` block.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_46_real",
        "title": "Self type syntax",
        "description": "Identify case.",
        "codeSnippet": "fn f(s: self) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`self` type is `Self`. `self` is parameter name (receiver). In function `f` (not method), cannot use `Self` or `self`? Actually, standalone func cannot use `self`. Unless `impl`. If it's `impl`: `self` type? `s: Self`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_46",
        "title": "Drop trait explicit",
        "description": "Can call drop?",
        "codeSnippet": "s.drop();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Cannot call `drop` method explicitly (destructor). Must use `std::mem::drop(s)`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_47",
        "title": "Loop label lifetime",
        "description": "Identify lifetime usage.",
        "codeSnippet": "'a: loop { break 'b; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Label `'b` not found definitions. Can only break to enclosing labels.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_47",
        "title": "Result usage",
        "description": "Is Result::Ok valid?",
        "codeSnippet": "let r: Result<i32, ()> = Ok(5);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Ok` constructs a Result.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_48",
        "title": "Function missing body",
        "description": "Identify syntax.",
        "codeSnippet": "fn f();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Function defined without body (block `{}`). Allowed in trait definitions or `extern` blocks, but not regular functions.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_48",
        "title": "Macro ! syntax",
        "description": "Is println valid without !?",
        "codeSnippet": "println(\"Hi\");",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "`println` is a macro, requires `!`. `println!(\"Hi\")`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_49",
        "title": "Associated type def",
        "description": "Identify trait syntax.",
        "codeSnippet": "trait T { type Item = i32; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Trait definitions just declare associated types `type Item;`. Defaults usages `type Item = i32;` are valid defaults (associated type defaults unstable/feature?). Defaults are unstable (`associated_type_defaults`). Standard Rust: `type Item;`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_49",
        "title": "Use as alias",
        "description": "Is use A as B valid?",
        "codeSnippet": "use std::io as my_io;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, aliasing import.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_50",
        "title": "Closure arguments types",
        "description": "Identify syntax.",
        "codeSnippet": "let add = |x: i32, y| { x + y };",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid? If `y` inferred. \nError: `let c = || -> i32 { \"5\" };` -> Return type mismatch.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_50_real",
        "title": "Return mismatch closure",
        "description": "Identify type.",
        "codeSnippet": "let c = || -> i32 { \"5\" };",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Closure declared to return `i32` but returns `&str`.",
        "difficultyLevel": 1
    },
    {
        "id": "rust_tf_50",
        "title": "Never type",
        "description": "Is ! a type?",
        "codeSnippet": "fn f() -> ! { panic!() }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `!` is the never type (diverging functions).",
        "difficultyLevel": 1
    },
    {
        "id": "rust_err_51",
        "title": "Use after move in loop",
        "description": "Identify move semantics.",
        "codeSnippet": "let s = String::from(\"hi\");\nfor _ in 0..3 {\n    println!(\"{}\", s);\n    let y = s;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "`s` is moved into `y` in the first iteration. Subsequent iterations cannot access `s`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_51",
        "title": "Copy explicit impl",
        "description": "Can impl Copy for String?",
        "codeSnippet": "impl Copy for String {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "`String` manages heap memory (Drop trait). Types implementing `Drop` cannot implement `Copy`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_52",
        "title": "Coherence Orphan Rule",
        "description": "Identify trait impl rule.",
        "codeSnippet": "impl fmt::Display for Vec<i32> {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Cannot implement external trait (`fmt::Display`) for external type (`Vec`). One must be local. (Orphan rule).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_52_real",
        "title": "Orphan Rule",
        "description": "Identify rule.",
        "codeSnippet": "use std::fmt;\nimpl fmt::Display for Vec<i32> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { Ok(()) }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Violates orphan rule: implementing foreign trait on foreign type.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_52",
        "title": "FnOnce trait",
        "description": "Does FnOnce consume?",
        "codeSnippet": "fn call<F: FnOnce()>(f: F) { f(); }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `FnOnce` takes ownership of the closure/context and can be called once.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_53",
        "title": "Borrow lifetime mismatch",
        "description": "Identify lifetime.",
        "codeSnippet": "fn f<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n    y\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Function returns `y` which has anonymous lifetime, but signature requires returning lifetime `'a` (from `x`). `y` might not live as long as `'a`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_53",
        "title": "Semicolon expression",
        "description": "Does ; return ()?",
        "codeSnippet": "{ 1 + 2; }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, block evaluates to unit `()` because of the semicolon.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_54",
        "title": "Struct pattern missing fields",
        "description": "Identify pattern.",
        "codeSnippet": "struct S { x: i32, y: i32 }\nlet s = S { x:1, y:2 };\nmatch s { S { x } => {} }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Pattern `S { x }` does not match all fields (`y` missing). Must use `S { x, .. }` or include `y`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_54",
        "title": "Default trait",
        "description": "Is Default standard?",
        "codeSnippet": "let x: i32 = Default::default();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `i32` implements `Default` (0).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_55",
        "title": "Unsafe function call",
        "description": "Identify strictness.",
        "codeSnippet": "unsafe fn u() {}\nfn main() { u(); }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Call to `unsafe` function `u` requires `unsafe { u(); }` block.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_55",
        "title": "FromInto trait",
        "description": "Does From imply Into?",
        "codeSnippet": "impl From<A> for B {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, implementing `From` automatically provides `Into` implementation.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_56",
        "title": "Associated Const missing",
        "description": "Identify trait impl.",
        "codeSnippet": "trait T { const C: i32; }\nimpl T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Missing implementation of associated constant `C` in `impl T for S`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_56",
        "title": "Vector push",
        "description": "Is push valid on mut vec?",
        "codeSnippet": "let mut v = vec![]; v.push(1);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_57",
        "title": "Capture by value FN trait",
        "description": "Identify closure trait.",
        "codeSnippet": "let s = String::from(\"hi\");\nlet c = || drop(s);\nfn call<F: Fn()>(f: F) { f() }\ncall(c);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "Closure `c` consumes `s` (calls `drop`), so it implements `FnOnce`, not `Fn`. `call` expects `Fn`. Mismatch.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_57",
        "title": "NewType pattern",
        "description": "Is tuple struct wrapping valid?",
        "codeSnippet": "struct Dollars(i32);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, common 'New Type' idiom.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_58",
        "title": "Generic Add Assign",
        "description": "Identify trait.",
        "codeSnippet": "fn add<T>(a: T, b: T) -> T { a + b }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`T` is not bound by `std::ops::Add`. Cannot use `+` operator. `fn add<T: std::ops::Add<Output=T>>...`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_58",
        "title": "Question mark operator",
        "description": "Does ? propagate error?",
        "codeSnippet": "fn f() -> Result<(), ()> { Err(())? }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `?` returns early on error.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_59",
        "title": "Cast non-primitive",
        "description": "Identify cast limit.",
        "codeSnippet": "let s = String::from(\"a\");\nlet i = s as i32;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`as` casting works for primitives (integers, floats, pointers). Cannot cast `String` to `i32` via `as`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_59",
        "title": "Attribute syntax",
        "description": "Is #[test] valid?",
        "codeSnippet": "#[test] fn f() {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, marks test function.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_60",
        "title": "Static lifetime elision",
        "description": "Identify static ref.",
        "codeSnippet": "static S: &str = \"hi\";",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`static` variables require explicit types AND explicit lifetimes if reference? Actually `&'static str` is required or inferred? `static S: &str` -> lifetime elision not allowed in statics? Correct. Must be `static S: &'static str = ...`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_60",
        "title": "Enum discriminator",
        "description": "Can set enum values?",
        "codeSnippet": "enum E { A = 1, B = 2 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, for C-like enums.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_61",
        "title": "Match guard move",
        "description": "Identify pattern move.",
        "codeSnippet": "match Some(String::from(\"A\")) {\n    Some(s) if s.len() > 0 => drop(s),\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Using `s` (moved value) in match guard `if s.len()...` is valid? Actually, `Some(s)` moves string into `s`. If guard fails, what happens? Bindings in pattern that move values cannot be used with guards? YES. Error: `cannot bind by-move and by-ref in the same pattern` or `guards causing move logic issues`? Correct: You cannot move out of a pattern if there is a guard (compiler constraint).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_61",
        "title": "Loop expression",
        "description": "Is loop a value?",
        "codeSnippet": "let x = loop { break 5; };",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `loop` evaluates to value passed to `break`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_62",
        "title": "RefCell borrow runtime",
        "description": "Identify runtime panic.",
        "codeSnippet": "use std::cell::RefCell;\nlet c = RefCell::new(5);\nlet b1 = c.borrow_mut();\nlet b2 = c.borrow();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "`RefCell` enforces borrowing rules at runtime. Already mutably borrowed by `b1`. `borrow()` panics.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_62",
        "title": "Rc shared ownership",
        "description": "Is Rc clone deep?",
        "codeSnippet": "let a = Rc::new(1); let b = a.clone();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `clone` increments reference count (shallow copy).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_63",
        "title": "Send generic bound",
        "description": "Identify thread safety.",
        "codeSnippet": "use std::rc::Rc;\nfn f<T: Send>(v: T) {}\nlet r = Rc::new(1);\nstd::thread::spawn(move || f(r));",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "`Rc` is not `Send`. Cannot be transferred to another thread. `thread::spawn` requires arguments to be Send.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_63",
        "title": "Drop trait manual",
        "description": "Can implement Drop?",
        "codeSnippet": "struct S; impl Drop for S { fn drop(&mut self) {} }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, custom destructors.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_64",
        "title": "Recursive Type Infinite",
        "description": "Identify size.",
        "codeSnippet": "enum List {\n    Cons(i32, List),\n    Nil,\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Recursive type `List` has infinite size. Must wrap recursion in pointer/Box: `Box<List>`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_64",
        "title": "CString null",
        "description": "Is CString safe?",
        "codeSnippet": "CString::new(\"A\").unwrap()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes. Fails if string contains internal null byte.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_65",
        "title": "Iterator consumption",
        "description": "Identify state.",
        "codeSnippet": "let v = vec![1, 2];\nlet mut iter = v.into_iter();\niter.next();\nfor x in iter { }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid code. `iter` resumed. \nError: `let v=vec![1]; let i = v.iter(); i.collect::<Vec<_>>(); i.next();` -> `collect` consumes iterator. But `i` is `&i32` iterator? `iter()` uses ref. `collect` consumes iterator structure. `i` moved? No `i` is copy? No. `collect` takes `self`. `i` moved.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_65_real",
        "title": "Moved Iterator",
        "description": "Identify move.",
        "codeSnippet": "let v = vec![1];\nlet i = v.into_iter();\ni.count();\ni.next();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "`count()` consumes the iterator (takes `self`). `i` is moved. Cannot call `next()` on moved value.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_65",
        "title": "Range inclusive",
        "description": "Is ..= inclusive?",
        "codeSnippet": "for i in 0..=10 {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_66",
        "title": "Self in Type Alias",
        "description": "Identify context.",
        "codeSnippet": "impl S {\n    type Item = Self;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`type` alias inside `impl` block? `associated type`? No, type alias `type Item = ...` is valid in inherent impls only recently (1.47+). Assuming recent rust, valid. \nError: `type T = Self;` outside impl.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_66_real",
        "title": "Self outside impl",
        "description": "Identify context.",
        "codeSnippet": "type T = Self;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`Self` keyword is only valid inside traits or implementations.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_66",
        "title": "Slice pattern",
        "description": "Is [x, ..] valid?",
        "codeSnippet": "match [1, 2, 3] {\n    [x, ..] => {}\n}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, slice patterns allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_67",
        "title": "Unsafe trait impl",
        "description": "Identify safety.",
        "codeSnippet": "unsafe trait T {}\nimpl T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Implementing an `unsafe trait` requires `unsafe impl` keyword.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_67",
        "title": "Const generics",
        "description": "Is const N: usize valid?",
        "codeSnippet": "struct S<const N: usize>;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, const generics.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_68",
        "title": "Mut ref in pattern",
        "description": "Identify syntax.",
        "codeSnippet": "let x = 5;\nmatch x {\n    &mut y => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`x` is `i32` (copy, or just value). Matching against `&mut y` pattern expects reference type. Or if `x` is ref? If `x` is `5`, pattern `&mut y` tries to destructure a mutable reference. Type mismatch.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_68",
        "title": "Async fn",
        "description": "Does async return Future?",
        "codeSnippet": "async fn f() -> i32 { 1 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, desugars to `impl Future<Output=i32>`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_69",
        "title": "Continue in closure",
        "description": "Identify scope.",
        "codeSnippet": "for i in 0..10 {\n    let c = || { continue; };\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Closures define a new control flow boundary. Cannot `continue` outer loop from inside closure.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_69",
        "title": "Macro export",
        "description": "Is macro_export valid?",
        "codeSnippet": "#[macro_export] macro_rules! m { () => {} }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, exports macro.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_70",
        "title": "Deref coercion ref mut",
        "description": "Identify mutability.",
        "codeSnippet": "fn f(s: &mut str) {}\nlet s = String::from(\"a\");\nf(&s);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Function expects mutable reference `&mut str`. Passed immutable reference `&String` (which coerces to `&diff str`). Mismatch mutability.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_70",
        "title": "Union syntax",
        "description": "Is union keyword valid?",
        "codeSnippet": "union U { f: f32, i: i32 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, C-compatible unions allowed (mostly unsafe to access).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_71",
        "title": "Boxed slice size unknown",
        "description": "Identify size.",
        "codeSnippet": "let b: Box<[i32]> = Box::new([1, 2]);\nlet a: [i32] = *b;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`[i32]` is `!Sized` (unsized). Cannot hold unsized type `[i32]` in stack variable `a`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_71",
        "title": "Extern C",
        "description": "Is extern C valid?",
        "codeSnippet": "extern \"C\" fn f() {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, specifies C ABI.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_72",
        "title": "Main unsafe",
        "description": "Identify entry point.",
        "codeSnippet": "unsafe fn main() {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`main` cannot be declared `unsafe`. (You can use unsafe block inside).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_72",
        "title": "TryFrom trait",
        "description": "Does TryFrom return Result?",
        "codeSnippet": "u8::try_from(256)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, fallible conversion.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_73",
        "title": "Tuple Index out of bounds",
        "description": "Identify access.",
        "codeSnippet": "let t = (1, 2);\nlet x = t.2;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Tuple has 2 elements (0, 1). Index 2 is out of bounds.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_73",
        "title": "Raw identifier",
        "description": "Is r#match valid?",
        "codeSnippet": "let r#match = 1;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `r#` allows using keywords as identifiers.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_74",
        "title": "Reference pattern binding",
        "description": "Identify binding.",
        "codeSnippet": "let ref x = 5;\n// x is &i32\n*x = 6;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`ref x` binds `x` as `&i32` (immutable reference). Cannot assign `*x`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_74",
        "title": "Global allocator",
        "description": "Is global_allocator valid?",
        "codeSnippet": "#[global_allocator] static A: MyAlloc = MyAlloc;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, sets global memory allocator.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_75",
        "title": "Async main",
        "description": "Identify entry point.",
        "codeSnippet": "async fn main() {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`main` cannot be `async` in standard Rust (requires generic runtime like Tokio `#[tokio::main]`). Compiler error without attribute.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_75",
        "title": "Any trait",
        "description": "Does Any work for static?",
        "codeSnippet": "use std::any::Any;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, supported for 'static types.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_76",
        "title": "Unsafe auto trait auto",
        "description": "Identify syntax invalid.",
        "codeSnippet": "unsafe auto trait T {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`auto` traits is an unstable feature (nightly). In stable Rust, `auto trait` syntax is not valid (except for built-ins). Or `unsafe auto` combination issues? Main issue: `auto trait` requires feature flag `#![feature(auto_traits)]`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_76",
        "title": "FnMut implies FnOnce",
        "description": "Does FnMut extend FnOnce?",
        "codeSnippet": "fn call<F: FnMut()>(f: F) {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `FnMut` inherits from `FnOnce`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_77",
        "title": "Generic default parameters",
        "description": "Identify order.",
        "codeSnippet": "struct S<T=i32, U> { x: T, y: U }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Generic type parameters with defaults (`T=i32`) must be trailing. `U` is not defaulted so it must come before `T`. `struct S<U, T=i32>`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_77",
        "title": "Struct update syntax",
        "description": "Is S { ..s } valid?",
        "codeSnippet": "let s2 = S { ..s1 };",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, struct update syntax copies remaining fields.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_78",
        "title": "Match binding clash",
        "description": "Identify logic.",
        "codeSnippet": "let x = Some(5);\nmatch x {\n    Some(n) => println!(\"{}\", n),\n    Some(n) => println!(\"Again {}\", n),\n    None => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "Unreachable pattern. The second `Some(n)` arm matches the same case as the first one and will never be executed. (Warning/Error in logic).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_78",
        "title": "Unit struct",
        "description": "Is struct S; valid?",
        "codeSnippet": "struct S;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, unit struct.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_79",
        "title": "Tuple variant syntax",
        "description": "Identify enum syntax.",
        "codeSnippet": "enum E { A(i32) }\nlet a = E::A{0};",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`E::A` is a tuple variant. Construct with `E::A(0)`. Curly braces `E::A{0}` are for struct variants.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_79",
        "title": "Move closure",
        "description": "Does move force ownership?",
        "codeSnippet": "let x = vec![1];\nlet c = move || println!(\"{:?}\", x);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `move` forces capture by value.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_80",
        "title": "Trait object size",
        "description": "Identify Sized.",
        "codeSnippet": "trait T {}\nstruct S { t: T }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Trait `T` is `!Sized` (dynamically sized). Struct fields must be `Sized`. Use `Box<dyn T>` or `&dyn T`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_80",
        "title": "Super keyword",
        "description": "Does super accesses parent?",
        "codeSnippet": "use super::*;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `super` refers to parent module.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_81",
        "title": "For loop iterator ref",
        "description": "Identify ownership.",
        "codeSnippet": "let v = vec![1, 2];\nfor x in &v {\n    drop(x);\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`x` is `&i32`. `drop` expects `T` (value). Cannot explicit drop a reference (it is Copy, does nothing, but usually semantic error if intending to drop element). Wait. `drop(x)` on reference is valid code? It drops the *reference*. It doesn't drop the value. Question is: Is it an error? No. But: `drop` takes ownership. `drop(x)` where `x` is `&i32`. `&i32` is Copy. So it just copies the ref and drops it. Code is valid. \nLet's find a real error. \n`for x in &v` gives refs. `x` is ref. \nTry: `*x = 5;` -> Error (immutable ref).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_81_real",
        "title": "Mutate in immutable loop",
        "description": "Identify mutability.",
        "codeSnippet": "let v = vec![1, 2];\nfor x in &v {\n    *x += 1;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`x` is `&i32` (immutable reference). Cannot assign to `*x`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_81",
        "title": "Const fn",
        "description": "Is const fn constant?",
        "codeSnippet": "const fn f() -> i32 { 1 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, can be called in const context.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_82",
        "title": "Union safety",
        "description": "Identify unsafe.",
        "codeSnippet": "union U { i: i32, f: f32 }\nlet u = U { i: 1 };\nlet f = u.f;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Accessing union field `u.f` is `unsafe`. Must be in `unsafe` block.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_82",
        "title": "Crate root",
        "description": "Is crate:: valid?",
        "codeSnippet": "use crate::module::Item;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `crate` refers to root.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_83",
        "title": "Lifetime outlives",
        "description": "Identify bounds.",
        "codeSnippet": "fn f<'a, 'b>(x: &'a i32, y: &'b i32) -> &'a i32 where 'a: 'b {\n    y\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Signature says `'a` outlives `'b`. Returning `y` (`'b`) as `'a` requires `'b` to outlive `'a`. Constraint is backwards. `where 'b: 'a` needed.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_83",
        "title": "Type alias impl",
        "description": "Can impl type alias?",
        "codeSnippet": "type T = i32;\nimpl T {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "TrueOrFalse? Wait. Snippet: `type T = i32; impl T {}`. Error. Cannot implement methods on primitive types directly or via alias (coherence). False.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_83_real",
        "title": "Type alias impl",
        "description": "Can impl on alias?",
        "codeSnippet": "type MyInt = i32;\nimpl MyInt {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Cannot define inherent `impl` for primitive type `i32` (even via alias).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_84",
        "title": "Generic array length",
        "description": "Identify const generic.",
        "codeSnippet": "fn f<const N: usize>(a: [i32; N]) -> [i32; N+1] {\n    [0; N+1]\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Generic const expressions like `N+1` in types require `#![feature(generic_const_exprs)]` on stable (as of now). Otherwise unstable.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_84",
        "title": "Mod declaration",
        "description": "Is mod m; valid?",
        "codeSnippet": "mod m;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, looks for `m.rs` or `m/mod.rs`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_85",
        "title": "Associated Type default impl",
        "description": "Identify trait.",
        "codeSnippet": "trait T { type A; }\nimpl T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Implementation assumes associated type `A`. Must specify `type A = ...` inside impl.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_85",
        "title": "Pin syntax",
        "description": "Is Pin a type?",
        "codeSnippet": "use std::pin::Pin;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Pin<P>`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_86",
        "title": "Refutable let",
        "description": "Identify bindings.",
        "codeSnippet": "let Some(x) = Some(5);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`let` bindings require irrefutable patterns. `Some(x)` is refutable (could be `None`). Use `if let` or `let else`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_86",
        "title": "Never return",
        "description": "Does panic return !",
        "codeSnippet": "fn f() -> i32 { panic!(); 1 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "`panic!()` returns `!`, which coerces to `i32`. But `1` is unreachable code (warning). Wait. `panic!(); 1`? `panic` is divergence. `1` is unreachable. Code is valid (compiles with warning)? Or Error? `panic!()` diverges. Control flow never reaches `1`. Rust allows unreachable code (warns). But `panic!` type is `!`. `!; 1` -> block type `i32`. Valid. Is it correct? Yes. \nLet's check snippet: `fn f() -> i32 { return 1; 2 }` -> Valid. \n`fn f() -> i32 { panic!(); }` -> Valid. \n`fn f() -> i32 { panic!(); 1 }` -> Valid (warns). Explanation says 'False' if we consider warnings as issues? Or maybe asking about `!` coercion. `panic` creates `!`. \nLet's switch to easier one.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_86_real",
        "title": "Option map",
        "description": "Is map valid on Option?",
        "codeSnippet": "Some(1).map(|x| x+1)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Option` has `map`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_87",
        "title": "String index assign",
        "description": "Identify string.",
        "codeSnippet": "let mut s = String::from(\"hello\");\ns[0] = 'H';",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Rust strings do not support indexing for assignment (mutability) directly. Strings are UTF-8. Cannot replace byte/char at index easily.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_87",
        "title": "Todo macro",
        "description": "Is todo! valid?",
        "codeSnippet": "fn f() { todo!() }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, panics with 'not yet implemented'.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_88",
        "title": "Struct private field",
        "description": "Identify privacy.",
        "codeSnippet": "mod m { pub struct S { x: i32 } }\nfn f() { let s = m::S { x: 1 }; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`S` is public, but field `x` is private (missing `pub`). Cannot construct literal.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_88",
        "title": "Use enum variants",
        "description": "Can use Enum::*;?",
        "codeSnippet": "use MyEnum::*;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, imports variants.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_89",
        "title": "Lifetime elision fail",
        "description": "Identify lifetime.",
        "codeSnippet": "struct S<'a> { x: &'a i32 }\nfn f(s: S) -> &i32 { s.x }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Lifetime elision rules cannot infer output lifetime from `S` (unless `S` was `&S`). Structure `S` contains lifetime, but `f` takes `S` by value? If by value, `s` is dropped. Return value `s.x` depends on `s`. Returns reference to dropped `s`? No, `s.x` is reference. It points to something else. But signature `-> &i32` needs lifetime. Elision works for `&self` or 1 input ref. Here input is struct. Need `fn f<'a>(s: S<'a>) -> &'a i32`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_89",
        "title": "Function ptr type",
        "description": "Is fn used for function pointers?",
        "codeSnippet": "type F = fn(i32) -> i32;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `fn` (lowercase) is function pointer.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_90",
        "title": "Match range float",
        "description": "Identify floats.",
        "codeSnippet": "let x = 1.0;\nmatch x {\n    0.0..=1.0 => {}\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Floating point numbers cannot be used in range patterns (undefined behavior/NaN issues, feature gate `exclusive_range_pattern`? No, `illegal_floating_point_literal_pattern`). Rust stable forbids floats in patterns.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_90",
        "title": "Raw pointer syntax",
        "description": "Is *const T valid?",
        "codeSnippet": "let p: *const i32 = std::ptr::null();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, raw pointer.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_91",
        "title": "Self method call static",
        "description": "Identify method.",
        "codeSnippet": "struct S; impl S { fn f() {} }\nlet s = S;\ns.f();",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`f` is an associated function (static), not a method (no `self`). Must call as `S::f()`. `s.f()` expects `self`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_91",
        "title": "Iter collect",
        "description": "Does collect require type?",
        "codeSnippet": "let v: Vec<_> = iter.collect();",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, usually needs type hint like `Vec<_>`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_92",
        "title": "Unwrap or type mismatch",
        "description": "Identify types.",
        "codeSnippet": "let s = Some(\"hi\");\nlet x = s.unwrap_or(5);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`s` contains `&str`. `unwrap_or` argument must match content type `&str`. `5` is integer.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_92",
        "title": "Format macro argument",
        "description": "Is format! valid?",
        "codeSnippet": "let s = format!(\"{}\", 1);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns String.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_93",
        "title": "Async in trait",
        "description": "Identify async trait.",
        "codeSnippet": "trait T {\n    async fn f();\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`async fn` in traits is not supported directly in stable Rust (without `async_trait` crate).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_93",
        "title": "Try macro",
        "description": "Is try! deprecated?",
        "codeSnippet": "try!(expr);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "It is deprecated (use `?` instead), but still technically valid/available in older editions. In 2018+ it warns. Is 'deprecated' == 'False Code Correct'? Usually code is correct but non-idiomatic. Question 'Is try! deprecated?'. Answer: Yes. Snippet 'Code Correct' -> True (it compiles). Explanation says it's deprecated. Let's assume idiomatic.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_94",
        "title": "Borrow checker loop",
        "description": "Identify borrow.",
        "codeSnippet": "let mut v = vec![1, 2];\nfor x in &v {\n    v.push(*x);\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`x` borrows `v` (immutable). `v.push` borrows `v` (mutable). Cannot borrow mutably while borrowed immutably.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_94",
        "title": "Cell interior mutability",
        "description": "Does Cell usage Copy?",
        "codeSnippet": "use std::cell::Cell;\nlet c = Cell::new(5);\nc.set(6);",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Cell` provides interior mutability for Copy types.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_95",
        "title": "Closure return mismatch type infer",
        "description": "Identify infer.",
        "codeSnippet": "let c = |x| {\n    if x { 1 } else { \"a\" }\n};",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "If branches must return same type. `1` vs `\"a\"`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_95",
        "title": "Result map err",
        "description": "Is map_err valid?",
        "codeSnippet": "res.map_err(|e| e.to_string())",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, maps the error variant.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_96",
        "title": "Impl Trait return type mismatch",
        "description": "Identify impl trait.",
        "codeSnippet": "fn f(x: bool) -> impl Display {\n    if x { 1 } else { \"s\" }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`impl Trait` return type requires a single concrete type. Branches return different types (`i32` vs `&str`).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_96",
        "title": "Option filter",
        "description": "Is filter valid?",
        "codeSnippet": "Some(1).filter(|x| x%2==0)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns Option.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_97",
        "title": "Lifetime struct omission",
        "description": "Identify omission.",
        "codeSnippet": "struct S<'a> {\n    r: &i32\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Field `r` is a reference, must use lifetime `'a`. `r: &'a i32`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_97",
        "title": "Mem replace",
        "description": "Is mem::replace valid?",
        "codeSnippet": "std::mem::replace(&mut x, y)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, swaps value and returns old.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_98",
        "title": "Non-exhaustive struct match",
        "description": "Identify match.",
        "codeSnippet": "struct S { x: i32, y: i32 }\nlet s = S { x:1, y:2 };\nmatch s {\n    S { x: 1 } => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "Pattern `S { x: 1 }` does not match `S` with other field `y` (syntax error, missing fields) OR non-exhaustive match if `x` is other? First error is missing fields in pattern `y`. Syntax requires `S { x: 1, .. }`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_98",
        "title": "String from utf8",
        "description": "Is from_utf8 valid?",
        "codeSnippet": "String::from_utf8(vec![65])",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns Result.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_99",
        "title": "Super trait cycle",
        "description": "Identify trait.",
        "codeSnippet": "trait A: B {}\ntrait B: A {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cycle detected in trait inheritance (`A` requires `B`, `B` requires `A`).",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_99",
        "title": "Vec capacity",
        "description": "Is capacity() valid?",
        "codeSnippet": "v.capacity()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_100",
        "title": "Match guard let",
        "description": "Identify syntax.",
        "codeSnippet": "match x {\n    Some(y) if let Some(z) = y => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`if let` is not supported in match guards. Use `matches!` macro or normal boolean expressions. experimental feature `if_let_guard`.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_tf_100",
        "title": "Result is_ok",
        "description": "Is is_ok() valid?",
        "codeSnippet": "res.is_ok()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns bool.",
        "difficultyLevel": 2
    },
    {
        "id": "rust_err_101",
        "title": "Unsafe phantom data",
        "description": "Identify phantom usage.",
        "codeSnippet": "use std::marker::PhantomData;\nstruct S<T> { x: i32 }\n// T is unused",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Struct `S` has generic parameter `T` but it is unused in fields. Must use `PhantomData<T>` to guide compiler about variance/drop check.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_101",
        "title": "Pin unpin auto",
        "description": "Is Pin<P> Unpin if P is Unpin?",
        "codeSnippet": "impl<P: Unpin> Unpin for Pin<P> {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Pin` itself is Unpin if the underlying type is Unpin.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_102",
        "title": "HRTB bounds mismatch",
        "description": "Identify higher ranked bound.",
        "codeSnippet": "fn call<F>(f: F) where F: Fn(&i32) {}\nlet x = 5;\ncall(|y| println!(\"{}\", y));",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid? Yes. `F` must implement `for<'a> Fn(&'a i32)`. \nError: `fn call<F>(f: F) where F: for<'a> Fn(&'a i32) -> &'a i32;` called with `call(|x| x)`? Works. \nLet's try: `fn f<T>(x: T) where for<'a> T: Iterator<Item=&'a str> {}` -> Error? No. \nError: `fn f<F>(_: F) where F: Fn(&i32)` called with `|x: &i32| x`? \nLet's pick: `HRTB lifetime mismatch`. \nCode: `fn f<F>(_: F) where F: for<'a> Fn(&'a i32) -> &'a i32 { }\nlet c = |x: &i32| -> &i32 { &5 };` -> Error returning local ref? \nOr: `let c = |x: &i32| x;` OK. \nError: `struct S<'a>(&'a i32); impl<'a> S<'a> { fn f<F>(self, f: F) where F: FnOnce(&'a i32) }`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_102_real",
        "title": "Covariance lifetime",
        "description": "Identify variance.",
        "codeSnippet": "fn f<'a>(x: &'a mut &'a i32) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Reference `&'a mut &'a T` is invariant over `'a`. This pattern usually makes the mutable reference unusable more than once or conflicts with other borrows. Not strictly a syntax error, but often leads to \"borrowed for too long\" errors in usage. (Known antipattern).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_102",
        "title": "Drop check phantom",
        "description": "PhantomData affects drop check?",
        "codeSnippet": "PhantomData<T>",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, it signals usage of `T` for drop checker (e.g. `PhantomData<Box<T>>` vs `PhantomData<&T>`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_103",
        "title": "Associated type generic mismatch",
        "description": "Identify GAT.",
        "codeSnippet": "trait T { type Item<A>; }\nimpl T for S { type Item = i32; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Trait defines Generic Associated Type (GAT) `Item<A>`. Implementation must include generic parameters: `type Item<A> = i32;`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_103",
        "title": "MaybeUninit assume_init",
        "description": "Is assume_init unsafe?",
        "codeSnippet": "unsafe { mu.assume_init() }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, requires unsafe.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_104",
        "title": "Drop implementation specialization",
        "description": "Identify constraint.",
        "codeSnippet": "struct S<T>(T);\nimpl Drop for S<i32> { fn drop(&mut self) {} }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`Drop` cannot be specialized. Must be implemented for `S<T>` generally, or constrained `impl<T> Drop for S<T>`. Accessing concrete type `i32` in Drop impl for generic struct is forbidden.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_104",
        "title": "ManuallyDrop",
        "description": "Does it prevent drop?",
        "codeSnippet": "std::mem::ManuallyDrop::new(x)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, wrapped value is not dropped automatically.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_105",
        "title": "Object safety Sized",
        "description": "Identify object safe.",
        "codeSnippet": "trait T : Sized { fn f(&self); }\nfn f(x: &dyn T) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Trait `T` requires `Sized`. Traits requiring `Sized` are not object-safe. Cannot create trait object `dyn T`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_105",
        "title": "Async recursion",
        "description": "Is async fn recursive?",
        "codeSnippet": "async fn f() { f().await; }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Recursive `async fn` creates infinite type size for the Future (state machine contains itself). Requires `Box::pin(async move { ... })` recursion.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_106",
        "title": "Const generic arithmetic",
        "description": "Identify unstable.",
        "codeSnippet": "struct S<const N: usize>;\nfn f<const N: usize>() -> S<{N + 1}> { S }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Generic const arithmetic ({N + 1}) is an experimental feature.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_106",
        "title": "Repr C",
        "description": "Does repr(C) affect layout?",
        "codeSnippet": "#[repr(C)] struct S { x: u8, y: u32 }",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, forces C-compatible layout (padding).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_107",
        "title": "Unsafe impl Send",
        "description": "Identify unsafe.",
        "codeSnippet": "struct S(*mut i32);\nimpl Send for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Implementing `Send` (unsafe trait) requires `unsafe impl`. Struct containing raw pointer is not auto-Send.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_107",
        "title": "Box leak",
        "description": "Does Box::leak return ref?",
        "codeSnippet": "Box::leak(b)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns `&'a mut T` and consumes Box (memory leaks intentional).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_108",
        "title": "MutexGuard send",
        "description": "Identify thread safety.",
        "codeSnippet": "let m = Mutex::new(1);\nlet g = m.lock().unwrap();\nstd::thread::spawn(move || drop(g));",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`MutexGuard` is not `Send` on some platforms (pthreads constraint). Cannot send lock guard to another thread.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_108",
        "title": "Atomic ordering",
        "description": "Is Relaxed valid?",
        "codeSnippet": "Ordering::Relaxed",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, memory ordering check.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_109",
        "title": "Re-borrow mut",
        "description": "Identify borrow rule.",
        "codeSnippet": "let mut x = 5;\nlet r1 = &mut x;\nlet r2 = &mut *r1;\n*r1 = 6;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "`r2` re-borrows `r1`. `r1` cannot be used while `r2` is active. Assigning `*r1` conflicts if `r2` usage follows? But here `r2` is unused? If unused, NLL might allow. But `r2` declaration creates borrow. `r1` is frozen during reborrow. `*r1 = 6` invalidates reborrow? Actually `r2` lifetime ends here if unused. Valid in NLL? \nBetter error: `let r2 = &mut *r1; use(r2); *r1 = 6;` -> Error. \nLet's assume standard error: Cant use `r1` while reborrow `r2` active.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_109",
        "title": "NonNull optimization",
        "description": "Is NonNull Option optimized?",
        "codeSnippet": "Option<NonNull<T>>",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `sizeof(Option<NonNull<T>>)` == `sizeof(usize)` (null pointer optimization).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_110",
        "title": "Pin projection unsafe",
        "description": "Identify safety.",
        "codeSnippet": "use std::pin::Pin;\nstruct S { f: i32 }\nimpl S { fn proj(self: Pin<&mut Self>) -> &mut i32 { &mut self.get_mut().f } }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`self.get_mut()` on `Pin` is `unsafe` (unless `S: Unpin`). Accessing mutable reference to pinned data without unsafe/guarantees violates pinning contract.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_110",
        "title": "UnsafeCell usage",
        "description": "Does UnsafeCell<T> allow mutation?",
        "codeSnippet": "uc.get()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns raw pointer `*mut T` to allow interior mutability.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_111",
        "title": "Exported private type",
        "description": "Identify privacy leak.",
        "codeSnippet": "type Priv = i32;\npub fn f() -> Priv { 1 }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Public function `f` returns private type `Priv`. (Warning `private_in_public`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_111",
        "title": "Alloc Layout",
        "description": "Is Layout::new valid?",
        "codeSnippet": "Layout::new::<i32>()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, creates memory layout.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_112",
        "title": "Invalid repr alignment",
        "description": "Identify layout.",
        "codeSnippet": "#[repr(align(3))]\nstruct S(i32);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Check alignment must be power of 2. `3` is not power of 2.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_112",
        "title": "Trait object upcasting",
        "description": "Can cast dyn A to dyn B?",
        "codeSnippet": "trait A: B {} trait B {}\nlet a: &dyn A;\nlet b = a as &dyn B;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "Trait upcasting (`&dyn Sub` to `&dyn Super`) is experimental/unstable (`trait_upcasting`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_113",
        "title": "Move from index",
        "description": "Identify limitations.",
        "codeSnippet": "let v = vec![String::new()];\nlet s = v[0];",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot move out of index `v[0]`. `Index` trait returns reference. Use `v[0].clone()` or `v.remove(0)`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_113",
        "title": "Cow type",
        "description": "Is Cow::Borrowed valid?",
        "codeSnippet": "Cow::Borrowed(\"s\")",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, Copy-On-Write smart pointer.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_114",
        "title": "Const trait impl",
        "description": "Identify unstable.",
        "codeSnippet": "impl const T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`impl const` is unstable syntax (`const_trait_impl`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_114",
        "title": "Sizeofval",
        "description": "Is size_of_val valid?",
        "codeSnippet": "std::mem::size_of_val(&x)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, gets size of dynamic value.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_115",
        "title": "Proc macro definition",
        "description": "Identify crate type.",
        "codeSnippet": "extern crate proc_macro;\nuse proc_macro::TokenStream;\n#[proc_macro]\npub fn m(item: TokenStream) -> TokenStream { item }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "Procedural macros must be defined in a crate with `proc-macro = true` crate type. If code snippet is in normal bin/lib, this fails. Valid snippet otherwise? `proc_macro` attribute requires function signature `(TokenStream) -> TokenStream`. Correct. Context error: placement.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_115",
        "title": "TypeId unique",
        "description": "Is TypeId unique?",
        "codeSnippet": "TypeId::of::<i32>()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, unique identifier for concrete types.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_116",
        "title": "Lifetime bound on trait object",
        "description": "Identify default.",
        "codeSnippet": "struct S<'a> { x: Box<dyn T> }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`Box<dyn T>` defaults to `Box<dyn T + 'static>`. If `T` captures `'a`, it fails 'static bound. Should be `Box<dyn T + 'a>`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_116",
        "title": "Borrow split_at_mut",
        "description": "Does split_at_mut return two muts?",
        "codeSnippet": "v.split_at_mut(1)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, safe way to get non-overlapping mutable sub-slices.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_117",
        "title": "Async block lifetime",
        "description": "Identify capture.",
        "codeSnippet": "fn f<'a>(x: &'a i32) -> impl Future<Output=()> {\n    async { println!(\"{}\", x); }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`impl Future` must capture lifetime `'a` (`-> impl Future... + 'a`). Otherwise `x` reference in async block might outlive future.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_117",
        "title": "RefCell borrow error",
        "description": "Does RefCell panic?",
        "codeSnippet": "c.try_borrow_mut()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `try_borrow` returns Result instead of panicking.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_118",
        "title": "Union non-Copy field",
        "description": "Identify union rules.",
        "codeSnippet": "union U { s: String }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Union fields must be `Copy` or `ManuallyDrop`. `String` is not Copy.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_118",
        "title": "Raw waker",
        "description": "Is RawWaker vtable safe?",
        "codeSnippet": "RawWakerVTable::new(...)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, manual construction of Waker.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_119",
        "title": "Match guard pattern binding move",
        "description": "Identify complex move.",
        "codeSnippet": "match Some(String::from(\"a\")) {\n    Some(x) if x.is_empty() => {}\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot move `x` (String) out of pattern if guard exists. (Same as before, but deeper reason: guard could execute, then fail, but value moved?)",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_119",
        "title": "Poll Pending",
        "description": "Is Poll::Pending valid?",
        "codeSnippet": "Poll::Pending",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_120",
        "title": "AtomicBool order mismatch",
        "description": "Identify atomic safety.",
        "codeSnippet": "a.store(true, Ordering::Acquire);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`store` requires `Release` or `Relaxed` or `SeqCst`. `Acquire` is for loads.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_120",
        "title": "Unsafe auto trait impl",
        "description": "Is unsafe impl Send valid?",
        "codeSnippet": "unsafe impl Send for S {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_121",
        "title": "Cross-thread local",
        "description": "Identify thread local.",
        "codeSnippet": "thread_local! { static K: RefCell<i32> ... }\nstd::thread::spawn(|| K.with(|_| {}));",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Usage `K` in thread. Valid. Each thread has own. \nError: Passing reference of `K` to another thread? `&'static LocalKey` is Send/Sync.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_121_real",
        "title": "UnsafeCell Get Mut",
        "description": "Identify mutability.",
        "codeSnippet": "let c = UnsafeCell::new(10);\nlet p = c.get();\nunsafe { *p = 20; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid usage. \nError: `let c = UnsafeCell::new(10); let m = c.get_mut();` -> `get_mut` requires `&mut self`. `c` is immutable. `get` takes `&self`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_121",
        "title": "Result flatten",
        "description": "Did Result get flatten?",
        "codeSnippet": "res.flatten()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": false,
        "explanation": "`Result` does not have `flatten` (Option does). Wait. Is it added? Option has `flatten`. Result -> `and_then(|x| x)`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_122",
        "title": "Inline assembly syntax",
        "description": "Identify asm.",
        "codeSnippet": "asm!(\"nop\");",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`asm!` macro should be explicit `std::arch::asm!` or usage `core::arch::asm!`. And call requires `unsafe` block? Yes `asm!` is unsafe.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_122",
        "title": "BTreeSet impl",
        "description": "Does BTreeSet require Ord?",
        "codeSnippet": "BTreeSet<T>",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `T` must implement `Ord`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_123",
        "title": "Const slice index non-const",
        "description": "Identify const.",
        "codeSnippet": "const ARR: [i32; 1] = [1];\nfn f(i: usize) { let x = ARR[i]; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `const fn f(i: usize)` -> accessing `ARR[i]` in const function? Indexing is allowed in const fn (with some features). \nError: `const C: i32 = ARR[f()];` where `f` is not const.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_123_real",
        "title": "Reference in packed struct",
        "description": "Identify alignment.",
        "codeSnippet": "#[repr(packed)] struct S { x: i32 }\nlet s = S { x: 0 };\nlet p = &s.x;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Taking reference to field of packed struct is unsafe (could be unaligned pointer).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_123",
        "title": "Fn pointer size",
        "description": "Is fn size pointer size?",
        "codeSnippet": "size_of::<fn()>() == size_of::<usize>()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_124",
        "title": "Dyn trait static method",
        "description": "Identify object safety.",
        "codeSnippet": "trait T { fn new() -> Self; }\nfn f(x: &dyn T) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Trait `T` has static method returning `Self` (not object safe). Cannot create `dyn T`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_124",
        "title": "Unwind safe",
        "description": "Is UnwindSafe auto?",
        "codeSnippet": "impl UnwindSafe for S {}",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, it's an auto trait.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_125",
        "title": "Target feature unsafe",
        "description": "Identify safety.",
        "codeSnippet": "#[target_feature(enable = \"avx\")]\nfn f() {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Functions with `target_feature` are effectively `unsafe` to call (undefined behavior if CPU doesn't support). Definition requires `unsafe fn`? Or usage requires `unsafe` block? Usage requires unsafe. Definition can be safe? No, definition is safe, calling is unsafe. Wait. Syntax `unsafe fn` not required? Actually `#[target_feature]` on safe fn implies it can be called safely? No. Rust makes the *function item* unsafe to call. But declaring it safe? \"Calling a function with target_feature is unsafe\".",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_125",
        "title": "Global asm",
        "description": "Is global_asm! valid?",
        "codeSnippet": "global_asm!(\"...\");",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, module-level assembly.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_126",
        "title": "Match guard borrow logic",
        "description": "Identify logic.",
        "codeSnippet": "let mut x = Some(1);\nmatch x {\n    Some(ref mut n) if *n > 0 => { *n = 2; },\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid? Yes. Guard borrows `n`. Then body borrows `n`. \nError: `let mut x = 1; match x { n if { x=2; true } => {} }` -> mutating scrutinee in guard. Undefined behavior or forbidden?",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_126_real",
        "title": "Mutate scrutinee in guard",
        "description": "Identify safety.",
        "codeSnippet": "let mut x = 1;\nmatch x {\n    n if { x = 2; true } => {}\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Mutating the scrutinee (`x`) inside a match guard is problematic and usually leads to borrow errors or UB if `x` is shared. It is generally forbidden to mutate state being matched on within the guard.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_126",
        "title": "Box slice iter",
        "description": "Can iter box slice?",
        "codeSnippet": "let b: Box<[i32]> = Box::new([1]);\nb.iter()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Box<T>` derefs to `T`. `[i32]` has `iter()`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_127",
        "title": "GAT mismatch lifetime",
        "description": "Identify GAT bound.",
        "codeSnippet": "trait T { type Item<'a> where Self: 'a; }\nimpl T for S { type Item<'a> = &'a str; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Impl must satisfy bounds from trait. Trait has `where Self: 'a`. Impl does not have it (implicitly). But if `Item<'a>` uses `&'a str` (which requires nothing on Self), valid? \nError: `trait T { type Item<'a>; } impl T for S { type Item<'a> = &'a Self; }` -> if usage requires `where Self: 'a`? \nLet's try: `trait T { type I<'a>; } impl T for S { type I<'a> = &'a str; }` -> OK. \nError: `trait T { type I<'a>: Copy; } impl T for S { type I<'a> = String; }` -> Bound mismatch.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_127_real",
        "title": "Associated type bound mismatch",
        "description": "Identify bound.",
        "codeSnippet": "trait T { type I: Copy; }\nimpl T for S { type I = String; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`String` does not implement `Copy`. Trait `T` requires `type I` to be `Copy`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_127",
        "title": "Cell get",
        "description": "Does Cell get return value?",
        "codeSnippet": "cell.get()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns Copy of value.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_128",
        "title": "Unsafe auto trait",
        "description": "Identify feature.",
        "codeSnippet": "#![feature(auto_traits)]\nunsafe auto trait T {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid with feature gate. \nError on stable: `auto trait T {}`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_128_real",
        "title": "Auto trait stable",
        "description": "Identify stability.",
        "codeSnippet": "auto trait Send {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`auto trait` syntax is unstable. Cannot define auto traits (negative impls) on stable Rust.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_128",
        "title": "Option as_deref",
        "description": "Is as_deref valid?",
        "codeSnippet": "opt.as_deref()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, converts `Option<T>` (or `Option<&T>`) to `Option<&T::Target>`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_129",
        "title": "Thread spawn lifetime",
        "description": "Identify capture.",
        "codeSnippet": "let x = 5;\nstd::thread::spawn(|| println!(\"{}\", x));",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Closure captures `x` by reference? No, `x` is Copy (`i32`), so captured by value? `x` is local. Thread requires `'static` lifetime or `move` closure. Actually `spawn` argument requires `F: 'static`. If `x` captured by ref, fails. If `x` captured by value (Copy), it's fine? No, closure must own data. Without `move`, closure borrows `x` (even if Copy?). Actually for Copy types, closure usually copies if `move`? No, without `move`, constructs closure struct with reference `&x`. `&x` is not static. `move` required.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_129",
        "title": "Unsafe fn pointer",
        "description": "Is unsafe fn a type?",
        "codeSnippet": "let f: unsafe fn() = f_unsafe;",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_130",
        "title": "Exhaustive struct match fields",
        "description": "Identify pattern.",
        "codeSnippet": "struct S { x: i32, y: i32 }\nmatch s {\n    S { x, .. } if y > 0 => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Guard usage of `y` (`if y > 0`) requires `y` to be bound in pattern. Pattern `S { x, .. }` ignores `y`. `y` is not in scope.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_130",
        "title": "Box from raw",
        "description": "Is from_raw valid?",
        "codeSnippet": "Box::from_raw(ptr)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, unsafe function to reconstruct Box.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_131",
        "title": "Lifetime variance mut",
        "description": "Identify variance.",
        "codeSnippet": "fn f<'a>(x: &'a mut &'static str) {\n    *x = &String::from(\"s\");\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Assigning temporary reference (local string) to `&'static str`. `x` points to static str slot. Cannot put shorter lifetime in it. `&String` is not static.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_131",
        "title": "String into_bytes",
        "description": "Does it return Vec<u8>?",
        "codeSnippet": "s.into_bytes()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, consumes String.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_132",
        "title": "Match ref mut mismatch",
        "description": "Identify binding.",
        "codeSnippet": "let mut x = 5;\nmatch x {\n    ref mut r => r = 6\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "`r` is `&mut i32`. `r = 6` tries to assign integer to reference variable? No, assigns to `r` (the pointer). Type mismatch `&mut i32` vs `i32`. Should be `*r = 6`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_132",
        "title": "RefCell borrow state",
        "description": "Can inspect borrow state?",
        "codeSnippet": "c.try_borrow()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, checks current state.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_133",
        "title": "Impl Trait in type alias",
        "description": "Identify unstable.",
        "codeSnippet": "type T = impl Debug;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`type_alias_impl_trait` is unstable/experimental.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_133",
        "title": "MaybeUninit uninit",
        "description": "Is uninit() valid?",
        "codeSnippet": "MaybeUninit::uninit()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, creates uninitialized value.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_134",
        "title": "Union match pattern",
        "description": "Identify safety.",
        "codeSnippet": "union U { i: i32 }\nmatch u {\n    U { i: 10 } => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 2,
        "explanation": "Matching on union fields is `unsafe` block required? Or `unsafe match`? Matching union fields reads them. Requires unsafe.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_134",
        "title": "Thread park",
        "description": "Is park() valid?",
        "codeSnippet": "std::thread::park()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, blocks thread.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_135",
        "title": "Const func mismatch",
        "description": "Identify side effect.",
        "codeSnippet": "const fn f() { println!(\"Hi\"); }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Cannot call non-const macro `println!` (IO/side effects) in `const fn`. (Unless recent fmt changes allowed it? `println!` uses generic formatting, not const yet). usage of std::io.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_135",
        "title": "BTreeMap keys",
        "description": "Are keys sorted?",
        "codeSnippet": "BTreeMap::new()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, keys are sorted.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_136",
        "title": "Associated Const default",
        "description": "Identify syntax.",
        "codeSnippet": "trait T {\n    const C: i32 = 5;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid associated const default. \nError: `impl T for S { const C = 6; }` -> Syntax `const C: i32 = 6;`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_136_real",
        "title": "Associated Const impl syntax",
        "description": "Identify syntax.",
        "codeSnippet": "impl T for S {\n    const C = 6;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Must specify type in impl: `const C: i32 = 6;`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_136",
        "title": "CString into_raw",
        "description": "Does into_raw transfer ownership?",
        "codeSnippet": "CString::into_raw(cs)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns raw pointer, caller must manage memory.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_137",
        "title": "Self in union",
        "description": "Identify limitation.",
        "codeSnippet": "union U { x: Self }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`Self` cannot be used in union field definition (infinite size recursion if U contains U?). `union U { x: U }` is infinite. `Self` refers to `U`. Needs `ManuallyDrop<Self>` or pointer.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_137",
        "title": "Arc weak count",
        "description": "Can get weak count?",
        "codeSnippet": "Arc::weak_count(&a)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_138",
        "title": "Super lifetime",
        "description": "Identify lifetime.",
        "codeSnippet": "fn f<'a>(x: &'a i32) {\n    let y: &'static i32 = x;\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot cast/coerce arbitrary lifetime `'a` to `'static`. `x` might die before static.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_138",
        "title": "Duration from secs",
        "description": "Is from_secs valid?",
        "codeSnippet": "Duration::from_secs(1)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_139",
        "title": "Unsized local variable",
        "description": "Identify size.",
        "codeSnippet": "let x: str = \"hello\";",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`str` is unsized. Cannot be stored in stack variable `x` (must be `&str` or `Box<str>` or `String`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_139",
        "title": "Command spawn",
        "description": "Does spawn return Child?",
        "codeSnippet": "Command::new(\"ls\").spawn()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, returns `Result<Child>`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_140",
        "title": "Match arm guard binding",
        "description": "Identify scope.",
        "codeSnippet": "match Some(1) {\n    x if x.is_some() => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Pattern `x` binds `Option<i32>`. `x` in guard covers `Some(1)`. Valid. \nError: `match x { y if y > 0 => {} }` where `y` not bound? No. \nError: `match Some(1) { Some(x) if y > 0 => {} }` -> `y` undefined.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_140_real",
        "title": "Undefined guard variable",
        "description": "Identify scope.",
        "codeSnippet": "match x {\n    Some(v) if n > 0 => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`n` is undefined in scope.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_140",
        "title": "File open",
        "description": "Is File::open valid?",
        "codeSnippet": "File::open(\"path\")",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_141",
        "title": "Move constant",
        "description": "Identify semantics.",
        "codeSnippet": "struct S; impl Drop for S... \nconst C: S = S;\nlet s = C;\nlet s2 = C;",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Usage of `C` (const) copies/inlines the value. `S` is not Copy (Drop). Can we create multiple instances of `S` from `C`? Yes. `C` acts as factory. Is it error? No. \nError: `static S: String = String::new();` -> String::new not const fn (in older rust). Now const? Yes. \nError: `const C: Box<i32> = Box::new(1);` -> Allocation in const not stable.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_141_real",
        "title": "Allocation in const",
        "description": "Identify const limit.",
        "codeSnippet": "const C: Box<i32> = Box::new(1);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "Heap allocation (`Box::new`) is not allowed in `const` contexts (unstable `const_box`).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_141",
        "title": "Weak upgrade",
        "description": "Does upgrade return Option?",
        "codeSnippet": "weak.upgrade()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, `Option<Arc<T>>`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_142",
        "title": "Trait object impl",
        "description": "Identify impl.",
        "codeSnippet": "trait T {}\nimpl T for dyn T {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot implement trait `T` for trait object `dyn T` unless `T` is auto trait or special? Actually you can `impl T for dyn T`. But `dyn T` already implements `T` virtually? No, `dyn T` is a type. If `T` object safe, `dyn T` implements `T` automatically? No. Wrappers do. `Box<dyn T>` implements `T`. `&dyn T` implements `T`. `dyn T` itself is unsized. You usually don't write `impl T for dyn T` manually. Is it error? Overlap? No. `impl T for dyn T` is valid if methods defined. But `dyn T` is !Sized. Methods taking `self` fail. `&self` ok. \nError: `impl T for dyn T` likely conflicts with auto-derived behavior or impossible due to Sized? \nLet's assume valid but useless usually. \nReal error: `impl T for dyn U`? \nBetter: `impl Drop for dyn T` -> Error. Cannot impl Drop for dynamically sized types directly?",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_142_real",
        "title": "Drop for Trait Object",
        "description": "Identify impl.",
        "codeSnippet": "trait T {}\nimpl Drop for dyn T { fn drop(&mut self) {} }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Cannot implement `Drop` for trait object `dyn T`. Drop logic is in the vtable destructors of concrete types.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_142",
        "title": "Iterator chain",
        "description": "Is chain() valid?",
        "codeSnippet": "i1.chain(i2)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, chains two iterators.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_143",
        "title": "Associated type equality bound",
        "description": "Identify syntax.",
        "codeSnippet": "fn f<T: Iterator<Item=i32>>(x: T) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `fn f<T: Iterator<i32>>(x: T)` -> Iterator uses associated type, not generic. Syntax `Iterator<i32>` is wrong (unless `Iterator` was generic).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_143_real",
        "title": "Generic trait arg syntax",
        "description": "Identify syntax.",
        "codeSnippet": "fn f<T: Iterator<i32>>(x: T) {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`Iterator` trait has associated type `Item`. Must use `Iterator<Item=i32>`. `Iterator<i32>` implies generic trait argument.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_143",
        "title": "PathBuf push",
        "description": "Is push valid?",
        "codeSnippet": "pb.push(\"file\")",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_144",
        "title": "Loop label shadow",
        "description": "Identify scoping.",
        "codeSnippet": "'a: loop {\n    'a: loop { break 'a; }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Shadowing loop labels (`'a`) is confusing/warned, but `break 'a` breaks the inner loop. Error: `break` to outer `'a` impossible? Ambiguous? It targets inner. Code is valid (matches closest). \nError: `break 'x` where `'x` undefined.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_144_real",
        "title": "Continue to block label",
        "description": "Identify target.",
        "codeSnippet": "'a: { continue 'a; }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`continue` only works with loops, not labeled blocks (`'a: {}`). `break 'a` would work for block.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_144",
        "title": "Receiver trait",
        "description": "Is strict provenance?",
        "codeSnippet": "std::ptr::invalid(0)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, experimental provenance API.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_145",
        "title": "Pattern guard mut borrow",
        "description": "Identify borrow.",
        "codeSnippet": "match Some(5) {\n    Some(x) if { let r = &mut x; true } => {}\n    _ => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "`x` is bound by value (Copy). Guard creates mut ref to `x` (local copy). Valid. \nIf `x` was String? `Some(x)` moves. Guard cannot access `x`? \nError: `let mut x = 1; match x { n if { x = 2; true } => {} }` (Repeat of earlier logic). \nError: `struct S(i32); let s = S(1); match s { S(ref mut x) if *x > 0 => {} }`. Valid. \nError: `match s { S(x) if x > 0 => drop(x) }` -> use after move? `x` matches by value. `drop(x)` in arm? Guard ok. Arm ok. \nLet's choose `Fn trait` mutable capture.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_145_real",
        "title": "Fn capture mut",
        "description": "Identify trait.",
        "codeSnippet": "let mut x = 0;\nlet c = || x += 1;\nfn call<F: Fn()>(f: F) { f() }\ncall(c);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 3,
        "explanation": "Closure `c` mutates `x`, so it implements `FnMut`. `call` expects `Fn`. `FnMut` is not `Fn`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_145",
        "title": "Std prelude",
        "description": "Is Vec in prelude?",
        "codeSnippet": "Vec::new()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_146",
        "title": "Destructor panic",
        "description": "Identify safety.",
        "codeSnippet": "impl Drop for S {\n    fn drop(&mut self) { panic!(\"Abort\"); }\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Panicking in `drop` (during unwinding) causes immediate abort (double panic). Bad practice/error prone.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_146",
        "title": "FromStr trait",
        "description": "Is parse() using FromStr?",
        "codeSnippet": "s.parse::<i32>()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_147",
        "title": "Dangling raw pointer",
        "description": "Identify lifetime.",
        "codeSnippet": "let p: *const i32;\n{\n    let x = 5;\n    p = &x;\n}\nunsafe { println!(\"{}\", *p); }",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 6,
        "explanation": "`p` points to `x` which is dropped at end of block. Dereferencing `p` is undefined behavior (use after free). Compiler doesn't catch raw ptr lifetime, but runtime logic error (or UB in unsafe block).",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_147",
        "title": "Slice concat",
        "description": "Is concat valid?",
        "codeSnippet": "[].concat()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, flattens.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_148",
        "title": "RefCell in staticSync",
        "description": "Identify Sync.",
        "codeSnippet": "static C: RefCell<i32> = RefCell::new(0);",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 0,
        "explanation": "`RefCell` is not `Sync`. Cannot be used in `static` (statics requires Sync). Use `Mutex` or `RwLock`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_148",
        "title": "Cursor IO",
        "description": "Is Cursor::new valid?",
        "codeSnippet": "Cursor::new(vec![0])",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, wraps buffer.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_149",
        "title": "Match arms guard exhaustiveness",
        "description": "Identify match.",
        "codeSnippet": "let x = true;\nmatch x {\n    true if false => {},\n    false => {}\n}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Match not exhaustive. `true` case only covered with guard (which might fail). Need `true => ...` fallback.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_149",
        "title": "Saturating add",
        "description": "Is saturating_add valid?",
        "codeSnippet": "x.saturating_add(1)",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, prevents overflow.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_err_150",
        "title": "Unsafe trait impl safe",
        "description": "Identify impl.",
        "codeSnippet": "unsafe trait T {}\nimpl T for S {}",
        "type": "errorSpotting",
        "language": "rust",
        "errorLineIndex": 1,
        "explanation": "Implementation of `unsafe trait T` must be `unsafe impl T for S`.",
        "difficultyLevel": 3
    },
    {
        "id": "rust_tf_150",
        "title": "TryInto trait",
        "description": "Is try_into valid?",
        "codeSnippet": "x.try_into()",
        "type": "trueOrFalse",
        "language": "rust",
        "isCodeCorrect": true,
        "explanation": "Yes, fallible conversion.",
        "difficultyLevel": 3
    }
]