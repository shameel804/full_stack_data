[
    {
        "id": "scala_err_1",
        "title": "Val reassignment",
        "description": "Identify mutability.",
        "codeSnippet": "val x = 1\nx = 2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`val` declares an immutable variable. It cannot be reassigned. Use `var` for mutable variables.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_1",
        "title": "Var usage",
        "description": "True or False?",
        "codeSnippet": "var x = 1\nx = 2",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `var` allows reassignment.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_2",
        "title": "Type mismatch",
        "description": "Identify typing.",
        "codeSnippet": "var x: Int = \"string\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Cannot assign a String to a variable explicitly typed as `Int`. Scala is statically typed.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_2",
        "title": "Type inference",
        "description": "True or False?",
        "codeSnippet": "val x = \"string\"",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Scala infers type String.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_3",
        "title": "Function return missing =",
        "description": "Identify syntax.",
        "codeSnippet": "def add(a: Int, b: Int) { a + b }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "In Scala, defining a function with `{}` but without `=` before the body (procedure syntax) means it returns `Unit` (void). The result `a + b` is discarded. To return a value, use `=`: `def add(...) = { ... }` or just `def add(...) = a + b`. Note: Procedure syntax is deprecated in Scala 2.13+ and removed in Scala 3.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_3",
        "title": "Function definition",
        "description": "True or False?",
        "codeSnippet": "def add(a: Int, b: Int): Int = a + b",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_4",
        "title": "Print println",
        "description": "Identify typo.",
        "codeSnippet": "System.out.println(\"Hello\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid (Java interop). \nError: `printline`? \nCode: `printline(\"hi\")`. \nError: `println` is the function. `printline` does not exist.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_4_real",
        "title": "Println missing",
        "description": "Identify typo.",
        "codeSnippet": "printline(\"Hello\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "The standard function is `println` or `print`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_4",
        "title": "Main method object",
        "description": "True or False?",
        "codeSnippet": "object Main extends App { println(\"Hi\") }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Extending `App` makes it runnable.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_5",
        "title": "Class params var",
        "description": "Identify scope.",
        "codeSnippet": "class Person(name: String) \nval p = new Person(\"A\")\np.name = \"B\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Class parameters without `val` or `var` are private fields (or constructor args only) effectively. They do not generate public getters/setters. Even if public, default is immutable. If `var name: String` was used, reassignment works. Here `name` is not accessible or not mutable.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_5",
        "title": "Case class access",
        "description": "True or False?",
        "codeSnippet": "case class Point(x: Int, y: Int)\nval p = Point(1, 2)\nprintln(p.x)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Case class params are public `val`s by default.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_6",
        "title": "If else return type",
        "description": "Identify typing.",
        "codeSnippet": "val x: Int = if (true) 1 else \"string\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`if` expression returns the common supertype of branches. `Int` and `String` -> `Any`. Cannot assign `Any` to `Int` variable.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_6",
        "title": "If expression value",
        "description": "True or False?",
        "codeSnippet": "val x = if (true) 1 else 0",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. x is Int.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_7",
        "title": "List append syntax",
        "description": "Identify syntax.",
        "codeSnippet": "val l = List(1, 2)\nl.add(3)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Scala `List` is immutable. It does not have an `add` method. Use `:+` (append) or `::` (prepend) to create a new list.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_7",
        "title": "List prepend",
        "description": "True or False?",
        "codeSnippet": "val l = 1 :: List(2, 3)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_8",
        "title": "Array access",
        "description": "Identify syntax.",
        "codeSnippet": "val arr = Array(1, 2)\nval x = arr[0]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Scala uses parentheses `()` for array access, not brackets `[]` like Java. `arr(0)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_8",
        "title": "Map basics",
        "description": "True or False?",
        "codeSnippet": "val m = Map(\"a\" -> 1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_9",
        "title": "While loop condition",
        "description": "Identify syntax.",
        "codeSnippet": "while 1 < 2 { println(\"hi\") }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`while` requires parentheses around condition. `while (1 < 2) { ... }`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_9",
        "title": "For loop range",
        "description": "True or False?",
        "codeSnippet": "for (i <- 1 to 5) println(i)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_10",
        "title": "Private member access",
        "description": "Identify visibility.",
        "codeSnippet": "class C { private val x = 1 }\nval c = new C\nprintln(c.x)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "`x` is private to class `C`. Cannot be accessed from outside.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_10",
        "title": "Import usage",
        "description": "True or False?",
        "codeSnippet": "import scala.collection.mutable.ArrayBuffer",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_11",
        "title": "Trait constructor args",
        "description": "Identify limitation.",
        "codeSnippet": "trait T(val x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Prior to Scala 3, traits cannot have constructor parameters. (In Scala 3 they can). Assuming Scala 2 context or standard quiz, this is error. If targeting Scala 3, valid. CodeReviewer usually assumes standard/common caveats. \"Trait parameters are a Scala 3 feature\".",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_11",
        "title": "Extends trait",
        "description": "True or False?",
        "codeSnippet": "class C extends T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_12",
        "title": "Abstract class instantiation",
        "description": "Identify concept.",
        "codeSnippet": "abstract class A\nval a = new A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot instantiate an abstract class directly.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_12",
        "title": "Anonymous class",
        "description": "True or False?",
        "codeSnippet": "abstract class A { def f: Int }\nval a = new A { def f = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_13",
        "title": "Override missing keyword",
        "description": "Identify syntax.",
        "codeSnippet": "class A { def f = 1 }\nclass B extends A { def f = 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "In Scala, overriding a concrete member requires the `override` keyword. `override def f = 2`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_13",
        "title": "Override abstract",
        "description": "True or False?",
        "codeSnippet": "abstract class A { def f: Int }\nclass B extends A { def f = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Overriding abstract member doesn't strictly require `override` (optional but good practice).",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_14",
        "title": "String interpolation syntax",
        "description": "Identify syntax.",
        "codeSnippet": "val name = \"Bob\"\nprintln(\"Hello $name\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Standard string literals do not support interpolation. Must prefix with `s`. `println(s\"Hello $name\")`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_14",
        "title": "Raw string literal",
        "description": "True or False?",
        "codeSnippet": "val s = \"\"\"line1\nline2\"\"\"",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Tripple quotes for multi-line.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_15",
        "title": "Match missing cases",
        "description": "Identify rules.",
        "codeSnippet": "val x = 1\nx match {\n  case 2 => \"two\"\n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`match` must be exhaustive or throw MatchError at runtime. If `x` is 1, it throws.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_15",
        "title": "Match wildcard",
        "description": "True or False?",
        "codeSnippet": "x match { case _ => \"default\" }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_16",
        "title": "Option get unsafe",
        "description": "Identify best-practice.",
        "codeSnippet": "val o: Option[Int] = None\nval x = o.get",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Calling `.get` on `None` throws NoSuchElementException. Use `getOrElse`, pattern matching, or `map`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_16",
        "title": "Option map",
        "description": "True or False?",
        "codeSnippet": "Some(1).map(_ + 1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `Some(2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_17",
        "title": "Null vs Option",
        "description": "Identify best-practice.",
        "codeSnippet": "def f(x: String): Option[String] = if (x == null) null else Some(x)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Returning `null` when return type is `Option` defeats the purpose. Should return `None`. `Option` types are reference types so `null` is valid value but incorrect logic.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_17",
        "title": "Option apply",
        "description": "True or False?",
        "codeSnippet": "Option(null)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `None`. Safe factory.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_18",
        "title": "Try catch syntax",
        "description": "Identify syntax.",
        "codeSnippet": "try { 1/0 } catch { Exception e => println(e) }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Catch block uses case syntax. `catch { case e: Exception => println(e) }`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_18",
        "title": "Try finally",
        "description": "True or False?",
        "codeSnippet": "try { } finally { println(\"done\") }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_19",
        "title": "Foreach return",
        "description": "Identify behavior.",
        "codeSnippet": "val x = List(1, 2).foreach(i => i * 2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`foreach` returns `Unit`. `x` is `()`. It does not map values. Use `map` to transform.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_19",
        "title": "Filter usage",
        "description": "True or False?",
        "codeSnippet": "List(1, 2).filter(_ > 1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_20",
        "title": "Def without parens",
        "description": "Identify behavior.",
        "codeSnippet": "def hello = println(\"hi\")\nhello()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "If a method is defined without parentheses `def hello = ...`, it cannot be called with empty parentheses `hello()`. Must be called as `hello`. (Convention: no side-effects -> no parens, but here it has side effect so should interpret as properties access style, but invocation fails syntax check).",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_20",
        "title": "Apply method",
        "description": "True or False?",
        "codeSnippet": "object O { def apply() = 1 }\nO()",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Calls `apply`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_21",
        "title": "Singleton object new",
        "description": "Identify syntax.",
        "codeSnippet": "object O\nval x = new O",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Objects are singletons. Cannot use `new` on an object.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_21",
        "title": "Companion object",
        "description": "True or False?",
        "codeSnippet": "class C; object C",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_22",
        "title": "Lazy val syntax",
        "description": "Identify syntax.",
        "codeSnippet": "lazy var x = 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`lazy` can only be used with `val`, not `var`. Mutable variables cannot be lazy.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_22",
        "title": "Lazy val usage",
        "description": "True or False?",
        "codeSnippet": "lazy val x = { print(\"init\"); 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_23",
        "title": "Tuple access index",
        "description": "Identify syntax.",
        "codeSnippet": "val t = (1, 2)\nval x = t(0)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Tuple elements are accessed via `_1`, `_2`, etc. `t._1`. Not index.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_23",
        "title": "Tuple creation",
        "description": "True or False?",
        "codeSnippet": "val t = 1 -> 2",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Creates `(1, 2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_24",
        "title": "Set duplicate",
        "description": "Identify behavior.",
        "codeSnippet": "val s = Set(1, 1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid, but creates `Set(1)`. \nError: `Set` add mutable? \nCode: `val s = Set(1); s += 2`. \nError: `s` is val (immutable reference) and default `Set` is immutable. `+=` fails. If `var s = Set(1)`, `s += 2` works (reassigns `s = s + 2`). \nReal Error: `Array` print. \nCode: `println(Array(1))`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_24_real",
        "title": "Immutable set modify",
        "description": "Identify mutability.",
        "codeSnippet": "val s = Set(1)\ns += 2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot reassign to a `val`. Even if logic implies mutation, immutable set returns new set, requiring reassignment.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_24",
        "title": "Var set modify",
        "description": "True or False?",
        "codeSnippet": "var s = Set(1); s += 2",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Desugars to `s = s + 2`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_25",
        "title": "Range inclusive",
        "description": "Identify syntax.",
        "codeSnippet": "1 to 5",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `until` syntax. \nCode: `1 until 5`. Valid. \nReal Error: `String` to Int cast? \nCode: `\"1\".toInt()`. valid. \nReal Error: `Int` method call on null? \nCode: `val x: Integer = null; x.toInt`. \nError: NPE. \nLet's check `def` args default. \nCode: `def f(x=1)`. \nError: Syntax is `def f(x: Int = 1)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_25_real",
        "title": "Default arg syntax",
        "description": "Identify syntax.",
        "codeSnippet": "def f(x = 1) = x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Parameter type is required required unless inferred in some contexts? No, method parameters must have types. `def f(x: Int = 1)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_25",
        "title": "Named arguments",
        "description": "True or False?",
        "codeSnippet": "def f(a: Int, b: Int) = a - b\nf(b=1, a=2)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_26",
        "title": "String immutability",
        "description": "Identify library.",
        "codeSnippet": "var s = \"hello\"\ns.toUpperCase\nprintln(s)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid, but logical error if user expects `S` to change. Strings are immutable. `s` remains \"hello\". The result of `toUpperCase` is discarded. Correct: `s = s.toUpperCase`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_26_real",
        "title": "String replace mutation",
        "description": "Identify mutability.",
        "codeSnippet": "val s = \"a\"\ns.replace(\"a\", \"b\")\nif (s == \"b\") println(\"ok\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`replace` returns a new String. `s` is not modified. The condition `s == \"b\"` will be false.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_26",
        "title": "String equality",
        "description": "True or False?",
        "codeSnippet": "val s1 = \"hello\"\nval s2 = \"hello\"\ns1 == s2",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `==` in Scala calls `equals`, comparing content (unlike Java `==`).",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_27",
        "title": "Reference equality",
        "description": "Identify operator.",
        "codeSnippet": "class A\nval a1 = new A\nval a2 = new A\na1 eq a2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. `eq` checks reference equality. False. \nError: `===` usage? \nCode: `1 === 1`. \nError: `===` is not standard Scala operator (unless using Scalactic/Spark). Standard is `==`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_27_real",
        "title": "Triple equals syntax",
        "description": "Identify syntax.",
        "codeSnippet": "if (1 === 1) true",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`===` is not a default Scala operator. Use `==`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_27",
        "title": "Object equality",
        "description": "True or False?",
        "codeSnippet": "List(1) == List(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Collections compare by structural equality.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_28",
        "title": "Assert vs Require",
        "description": "Identify keyword.",
        "codeSnippet": "def f(x: Int) = { require(x > 0); x }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `assert` failure return? \nCode: `assert(false)`. \nError: Throws `java.lang.AssertionError`. \nReal Error: `def` by name syntax. \nCode: `def f(x: => Int)`. Valid. \nReal Error: `call-by-name` var? \nCode: `class C(var x: => Int)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_28_real",
        "title": "Class param call-by-name",
        "description": "Identify syntax.",
        "codeSnippet": "class C(val x: => Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Class parameters cannot be call-by-name `=> Type` if they are `val` or `var` fields. Only method/constructor parameters can be call-by-name.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_28",
        "title": "Def call by name",
        "description": "True or False?",
        "codeSnippet": "def log(msg: => String) = println(msg)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_29",
        "title": "ArrayBuffer mutable",
        "description": "Identify library.",
        "codeSnippet": "import scala.collection.mutable.ArrayBuffer\nval b = ArrayBuffer(1)\nb += 2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `List` mutation? \nCode: `val l = List(1); l += 2`. \nError: `List` is immutable. \nReal Error: `ListBuffer` import missing. \nCode: `val b = ListBuffer(1)` (without import).",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_29_real",
        "title": "ListBuffer import",
        "description": "Identify missing.",
        "codeSnippet": "val b = ListBuffer(1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`ListBuffer` is not imported by default. `import scala.collection.mutable.ListBuffer`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_29",
        "title": "Set apply check",
        "description": "True or False?",
        "codeSnippet": "val s = Set(1)\ns(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns boolean (true). Sets are functions.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_30",
        "title": "Yield in for loop",
        "description": "Identify syntax.",
        "codeSnippet": "val x = for (i <- 1 to 3) yield i",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns vector/seq. \nError: `yield` with braces block? \nCode: `for { i <- 1 to 3 } yield i`. Valid. \nReal Error: `break` keyword. \nCode: `while(true) { break }`. \nError: `break` is not a keyword in Scala. Must import `scala.util.control.Breaks._` and wrap in `breakable`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_30_real",
        "title": "Break keyword",
        "description": "Identify syntax.",
        "codeSnippet": "while (true) { if (1==1) break }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala does not have a native `break` keyword like Java. Use `scala.util.control.Breaks`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_30",
        "title": "For yield type",
        "description": "True or False?",
        "codeSnippet": "val res = for (i <- Array(1)) yield i",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns Array(1). Preserves collection type.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_31",
        "title": "Import rename syntax",
        "description": "Identify syntax.",
        "codeSnippet": "import java.util.{Date => _}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Hides Date. Valid. \nError: `Date as D`? \nCode: `import java.util.{Date as D}`. \nError: Scala uses `=>` for renaming. `as` is Python/Scala3(maybe?). In Scala 2, `=>`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_31_real",
        "title": "Import alias syntax",
        "description": "Identify syntax.",
        "codeSnippet": "import java.util.{Date as D}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala 2 uses `=>` for renaming. `import java.util.{Date => D}`. Scala 3 introduces `as` but `=>` is standard for legacy/compat.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_31",
        "title": "Import multiple",
        "description": "True or False?",
        "codeSnippet": "import java.util.{Date, List}",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_32",
        "title": "Case class copy",
        "description": "Identify method.",
        "codeSnippet": "case class P(x: Int)\nval p = P(1)\nval p2 = p.copy(y = 2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "`copy` arguments must match case class fields. `P` has no field `y`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_32",
        "title": "Copy method",
        "description": "True or False?",
        "codeSnippet": "case class P(x: Int, y: Int)\nP(1, 2).copy(x = 3)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `P(3, 2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_33",
        "title": "Protected member access",
        "description": "Identify visibility.",
        "codeSnippet": "class A { protected def f = 1 }\nclass B { def g = (new A).f }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`protected` in Scala is more restrictive than Java. Valid only in subclasses. `B` is not subclass of `A`. Access denied.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_33",
        "title": "Protected subclass",
        "description": "True or False?",
        "codeSnippet": "class A { protected def f = 1 }\nclass B extends A { def g = f }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_34",
        "title": "Trait instantiation",
        "description": "Identify syntax.",
        "codeSnippet": "trait T\nval t = new T",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot instantiate trait directly without body (anonymous class). `new T {}` works. `new T` fails.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_34",
        "title": "Trait mixin",
        "description": "True or False?",
        "codeSnippet": "class A\ntrait T\nclass B extends A with T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_35",
        "title": "Multiple inheritance class",
        "description": "Identify limitation.",
        "codeSnippet": "class A; class B\nclass C extends A, B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Scala does not support multiple inheritance of classes. Use `extends A with T` (traits). `extends A, B` is invalid syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_35",
        "title": "With keyword",
        "description": "True or False?",
        "codeSnippet": "trait A; trait B\nclass C extends A with B",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_36",
        "title": "Val overrides def",
        "description": "Identify rules.",
        "codeSnippet": "class A { def f: Int = 1 }\nclass B extends A { override val f = 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. `val` can override `def` (stable value is valid implementation of no-arg method). \nError: `def` overrides `val`? \nCode: `class A { val f = 1 }; class B extends A { override def f = 2 }`. \nError: `def` cannot override `val`. `val` implies stability.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_36_real",
        "title": "Def overrides val",
        "description": "Identify rules.",
        "codeSnippet": "class A { val f = 1 }\nclass B extends A { override def f = 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "A `def` cannot override a `val`. A `val` is stable; a `def` might change over time, violating the contract of the superclass field.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_36",
        "title": "Var overrides var",
        "description": "True or False?",
        "codeSnippet": "abstract class A { var x: Int }\nclass B extends A { var x: Int = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_37",
        "title": "Case class inheritance",
        "description": "Identify best-practice.",
        "codeSnippet": "case class A()\ncase class B() extends A()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Case class-to-case class inheritance is prohibited/deprecated to prevent equality mess. `A` must not be a case class if `B` extends it, or `B` shouldn't be case class.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_37",
        "title": "Sealed trait",
        "description": "True or False?",
        "codeSnippet": "sealed trait T\ncase class A() extends T\ncase class B() extends T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_38",
        "title": "Return keyword usage",
        "description": "Identify behavior.",
        "codeSnippet": "def f: Int = { (1 to 5).foreach(i => return i); 0 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`return` in a closure (lambda passed to foreach) throws NonLocalReturnControl exception. It effectively returns from `f`, not the lambda. This is often unexpected or inefficient. While valid syntax, it's a common 'error' in logic if user expects lambda return.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_38",
        "title": "Implicit return",
        "description": "True or False?",
        "codeSnippet": "def f = { 1; 2 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 2.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_39",
        "title": "Try catch type matching",
        "description": "Identify syntax.",
        "codeSnippet": "try { error } catch { case e => println(e) }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`case e` matches *all* throwables, including fatal ones (OutOfMemoryError). Usually should match `case e: Exception` or `NonFatal(e)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_39",
        "title": "Throw exception",
        "description": "True or False?",
        "codeSnippet": "def f: Nothing = throw new Exception",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Throw returns `Nothing`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_40",
        "title": "Package object file",
        "description": "Identify convention.",
        "codeSnippet": "package object mypkg { val x = 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. Usually placed in `package.scala`. \nError: `package` keyword typo? \nCode: `package mypkg { ... }`. \nError: Valid syntax for package block. \nReal Error: `val` in trait with params? \nCode: `trait T(val x: Int)` (Scala 2). Error.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_40_real",
        "title": "Class definition syntax",
        "description": "Identify syntax.",
        "codeSnippet": "class C { constructor() {} }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala does not use `constructor` keyword. The class body *is* the constructor. `class C { ... }`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_40",
        "title": "Auxiliary constructor",
        "description": "True or False?",
        "codeSnippet": "class C(x: Int) { def this() = this(0) }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_41",
        "title": "Case object new",
        "description": "Identify syntax.",
        "codeSnippet": "case object O\nval x = new O()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot instantiate an object (singleton). `new O` is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_41",
        "title": "Case object usage",
        "description": "True or False?",
        "codeSnippet": "case object O; println(O)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_42",
        "title": "Partial function literal fail",
        "description": "Identify syntax.",
        "codeSnippet": "val f: Int => String = { case 1 => \"one\" }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Valid, `{ case ... }` expands to function. \nError: `PartialFunction` usage? \nCode: `val f: PartialFunction[Int, String] = x => \"s\"`. \nError: Lambda `x => ...` is a total function `Function1`, not `PartialFunction` literal (needs `case`). But wait, Function1 < PartialFunction? No. PartialFunction < Function1. \nReal error: `Nil` usage. \nCode: `val l = Nil(1)`. \nError: `Nil` is empty list object. Cannot apply args.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_42_real",
        "title": "Nil apply",
        "description": "Identify library.",
        "codeSnippet": "val l = Nil(1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`Nil` represents an empty list. It takes no arguments. Use `List(1)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_42",
        "title": "Cons operator",
        "description": "True or False?",
        "codeSnippet": "1 :: 2 :: Nil",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Creates `List(1, 2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_43",
        "title": "Tuple 1 syntax",
        "description": "Identify syntax.",
        "codeSnippet": "val t = (1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`t` is just Int 1 (parentheses for grouping). To make a Tuple1, need `Tuple1(1)`. `(1)` is not a tuple.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_43",
        "title": "Unit value",
        "description": "True or False?",
        "codeSnippet": "val u: Unit = ()",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_44",
        "title": "For loop no yield assign",
        "description": "Identify behavior.",
        "codeSnippet": "val x = for (i <- 1 to 5) println(i)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`x` is `Unit` because `yield` was omitted. Printing happens, but no list created.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_44",
        "title": "Do while",
        "description": "True or False?",
        "codeSnippet": "do { println(\"hi\") } while (false)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_45",
        "title": "Abstract method implicit returns",
        "description": "Identify syntax.",
        "codeSnippet": "class C { def f }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Method without `=` and body. In a concrete class, methods must be implemented. `class C` is not abstract. `def f` requires implementation.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_45",
        "title": "Abstract class method",
        "description": "True or False?",
        "codeSnippet": "abstract class C { def f: Int }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_46",
        "title": "This in object",
        "description": "Identify scope.",
        "codeSnippet": "object O { this.type }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid usage. \nError: `super` in object? objects can extend classes. \nError: `final class` extend? \nCode: `final class A; class B extends A`. \nError: Cannot inherit from final class.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_46_real",
        "title": "Extend final class",
        "description": "Identify rules.",
        "codeSnippet": "final class A\nclass B extends A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Final classes cannot be extended.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_46",
        "title": "Final member",
        "description": "True or False?",
        "codeSnippet": "class A { final def f = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Cannot override f.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_47",
        "title": "Lazy lazy",
        "description": "Identify syntax.",
        "codeSnippet": "lazy lazy val x = 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Double lazy keyword is a syntax error.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_47",
        "title": "Type alias",
        "description": "True or False?",
        "codeSnippet": "type S = String\nval x: S = \"s\"",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_48",
        "title": "Class type params value",
        "description": "Identify syntax.",
        "codeSnippet": "class C[T](val x: T)\nval c = new C[1](1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Type parameter `T` must be a Type, not a value `1`. `C[Int]` is correct. `1` is a literal.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_48",
        "title": "Generic class",
        "description": "True or False?",
        "codeSnippet": "class Box[T](val x: T)\nval b = new Box(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. T inferred as Int.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_49",
        "title": "Companion implicit class",
        "description": "Identify syntax.",
        "codeSnippet": "object O { implicit class C(x: Int) }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid extension method pattern. \nError: `implicit` val without type? \nCode: `implicit val x = 1`. Valid. \nReal Error: `new` on implicit class wrapper? \nCode: `implicit class W(x: Int); new W(1)` is valid. \nReal Error: `def` variable arguments java style `...`. \nCode: `def f(args: String...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_49_real",
        "title": "Varargs syntax",
        "description": "Identify syntax.",
        "codeSnippet": "def f(args: String...)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala uses `*` for varargs, not `...` (Java). `def f(args: String*)`.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_49",
        "title": "Varargs usage",
        "description": "True or False?",
        "codeSnippet": "def f(xs: Int*) = xs.sum\nf(1, 2, 3)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_50",
        "title": "Currying syntax",
        "description": "Identify syntax.",
        "codeSnippet": "def f(x: Int)(y: Int) = x+y\nf(1, 2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Curried functions must be called with separate argument lists. `f(1)(2)`. `f(1, 2)` fails.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_tf_50",
        "title": "Higher order function",
        "description": "True or False?",
        "codeSnippet": "val f = (x: Int) => x + 1\nList(1).map(f)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "scala_err_51",
        "title": "Implicit recursion",
        "description": "Identify rules.",
        "codeSnippet": "implicit def i2s(i: Int): String = i.toString\nimplicit def s2i(s: String): Int = s.toInt\nval x: Int = \"1\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Converters defined. \nError: `implicit` cyclic resolution? \nCode: `implicit val a: Int = implicitly[Int]`. \nError: Diverging implicit expansion or self-reference. \nReal Error: `Array` invariant? \nCode: `val a: Array[Any] = Array(\"s\")`. \nError: `Array` is invariant in Scala. `Array[String]` is NOT `Array[Any]`. (Unlike Java arrays which are covariant but unsafe).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_51_real",
        "title": "Array invariance",
        "description": "Identify typing.",
        "codeSnippet": "val a: Array[Any] = Array(\"s\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Arrays in Scala are invariant. `Array[String]` is not a subtype of `Array[Any]`. Use `List` or `Seq` (covariant) or `Array[Any](\"s\")`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_51",
        "title": "List covariance",
        "description": "True or False?",
        "codeSnippet": "val l: List[Any] = List(\"s\")",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. List is covariant `List[+A]`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_52",
        "title": "Tailrec on non-tail",
        "description": "Identify behavior.",
        "codeSnippet": "import scala.annotation.tailrec\n@tailrec def f(n: Int): Int = if (n==0) 1 else n * f(n-1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Recursive call `f(n-1)` is multiplied by `n` *after* return. Not in tail position. Compilation error due to `@tailrec` annotation.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_52",
        "title": "Tailrec valid",
        "description": "True or False?",
        "codeSnippet": "@annotation.tailrec def f(n: Int, acc: Int): Int = if (n==0) acc else f(n-1, n*acc)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Tail recursive.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_53",
        "title": "Var in case class default",
        "description": "Identify best-practice.",
        "codeSnippet": "case class C(var x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. \nError: `hashCode` with mutable var? \nCode: `case class C(var x: Int); val s = Set(C(1)); s.head.x = 2; s contains C(2)`. \nError: Using mutable fields in `hashCode`/`equals` (default for case classes) breaks Hash collections contract. Object is lost in Set bucket. Dangerous.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_53_real",
        "title": "Case class mutable hash",
        "description": "Identify simple-bug.",
        "codeSnippet": "case class User(var name: String)\nval s = scala.collection.mutable.HashSet(User(\"A\"))\ns.head.name = \"B\"\nval found = s.contains(User(\"B\"))",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Modifying a field used in `hashCode` (case class var) while object is in a HashSet corrupts the set. `contains` will likely return false despite object being there (in wrong bucket).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_53",
        "title": "Case class val default",
        "description": "True or False?",
        "codeSnippet": "case class C(x: Int)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. x is val.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_54",
        "title": "Implicit ambiguity",
        "description": "Identify resolution.",
        "codeSnippet": "implicit val x = 1\nimplicit val y = 2\ndef f(implicit i: Int) = i\nf",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 3,
        "explanation": "Two implicit values of type `Int` are in scope. Compiler cannot disambiguate. ambiguous implicit values error.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_54",
        "title": "Implicit parameter",
        "description": "True or False?",
        "codeSnippet": "implicit val x = 1\ndef f(implicit i: Int) = i\nf",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_55",
        "title": "Future context missing",
        "description": "Identify library.",
        "codeSnippet": "import scala.concurrent.Future\nFuture { 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`Future` requires an implicit `ExecutionContext` in scope. `Cannot find implicit value for parameter executor: ExecutionContext`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_55",
        "title": "Global context",
        "description": "True or False?",
        "codeSnippet": "import scala.concurrent.ExecutionContext.Implicits.global\nscala.concurrent.Future { 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_56",
        "title": "Map values lazy",
        "description": "Identify api.",
        "codeSnippet": "val m = Map(1->1).mapValues(_ + 1)\nprintln(m)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "`mapValues` (in recent Scala versions 2.13+) returns a `MapView`, which is lazy. Printing it shows `Map(<not computed>)` or similar type name, not the content. It's often unexpected. (Deprecated in 2.13, recommends `view.mapValues`). But not compilation error. \nReal Error: `Set` map to duplicate. \nCode: `Set(1, 2).map(_ => 1)`. \nError: Returns `Set(1)`. Size reduced. Not error but feature. \nReal Error: `_` in type lambda? \nCode: `type F = [X] => List[X]`. \nError: Scala 3 syntax. \nReal Error: `unapply` return type. \nCode: `object O { def unapply(x: Int): Int = x }`. \nError: `unapply` must return `Option` (or Boolean, or product). `Int` is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_56_real",
        "title": "Unapply return type",
        "description": "Identify signature.",
        "codeSnippet": "object O { def unapply(x: Any): String = \"match\" }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`unapply` must return `Boolean`, `Option[T]`, or a product type (for extraction). Returning `String` is invalid for pattern matching.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_56",
        "title": "Unapply option",
        "description": "True or False?",
        "codeSnippet": "object O { def unapply(x: Int): Option[String] = Some(x.toString) }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_57",
        "title": "Try get failure",
        "description": "Identify runtime.",
        "codeSnippet": "import scala.util.Try\nval t = Try { throw new Exception }\nt.get",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "`Try` wraps the exception. Calling `.get` on a Failure unwraps/re-throws the exception.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_57",
        "title": "Try recover",
        "description": "True or False?",
        "codeSnippet": "import scala.util.Try\nTry { throw new Exception }.recover { case _ => 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `Success(1)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_58",
        "title": "Lazy val deadlock",
        "description": "Identify concurrency.",
        "codeSnippet": "object A { lazy val a: Int = B.b }\nobject B { lazy val b: Int = A.a }\n// in separate thread: print(A.a)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Circular dependency between lazy vals in singleton objects often leads to deadlock during initialization logic.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_58",
        "title": "Lazy val safety",
        "description": "True or False?",
        "codeSnippet": "class C { lazy val x = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `lazy val` uses double-checked locking, thread-safe initialization.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_59",
        "title": "View usage",
        "description": "Identify library.",
        "codeSnippet": "val l = List(1, 2, 3).view.map(_ * 2)\nval x = l(0)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Accessing view elements re-computes them. \nError: `Stream` infinite print? \nCode: `Stream.from(1).map(println)`. \nError: Does nothing until evaluated? or prints 1 if strict head? Scala 2.13 `LazyList`. \nReal Error: `Seq` vs `List` match. \nCode: `val s: Seq[Int] = List(1); s match { case x :: xs => ... }`. \nError: `::` is valid pattern for `List`, but if static type is `Seq`, does compiler allow `::`? Yes (unchecked warning maybe, or relies on extractors). \nReal Error: `sealed` outside file. \nCode: `sealed trait T` (file 1); `class C extends T` (file 2). \nError: Sealed trait children must be in same file.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_59_real",
        "title": "Sealed trait violation",
        "description": "Identify syntax.",
        "codeSnippet": "// File1.scala: sealed trait T\n// File2.scala: class C extends T",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Subclasses of a `sealed` trait or class must be defined in the same source file.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_59",
        "title": "Sealed same file",
        "description": "True or False?",
        "codeSnippet": "sealed trait T; class C extends T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_60",
        "title": "Match scrutinee type",
        "description": "Identify behavior.",
        "codeSnippet": "val x: Int = 1\nx match { case \"s\" => 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Pattern type `String` (\"s\") is incompatible with scrutinee type `Int`. Compiler error (in modern Scala) or warning + match error.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_60",
        "title": "Type pattern",
        "description": "True or False?",
        "codeSnippet": "val x: Any = 1\nx match { case i: Int => i }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_61",
        "title": "Type erasure pattern",
        "description": "Identify erasure.",
        "codeSnippet": "val x: List[Any] = List(1)\nx match { case l: List[String] => true }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Type erasure! At runtime, `List[String]` is just `List`. This pattern matches `List[Int]` too (unchecked warning). Logic error if relying on generic type check.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_61",
        "title": "Array match precise",
        "description": "True or False?",
        "codeSnippet": "val a: Any = Array(1)\na match { case x: Array[Int] => true }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Arrays are not erased (they exist at runtime).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_62",
        "title": "Enumeration id",
        "description": "Identify api.",
        "codeSnippet": "object E extends Enumeration { val A = Value }\nE.A.id = 2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Enumeration values are immutable vals. `id` is a property, not mutable. Note: Enumeration is often discouraged for ADTs/case objects.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_62",
        "title": "ADT Enum",
        "description": "True or False?",
        "codeSnippet": "sealed trait Color; case object Red extends Color",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Preferred enum style in Scala 2.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_63",
        "title": "Partial function compose",
        "description": "Identify rules.",
        "codeSnippet": "val f: PartialFunction[Int, Int] = { case 1 => 2 }\nval g = f.andThen(_ + 1)\nf(2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "`f` is defined only for `1`. calling `f(2)` throws MatchError.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_63",
        "title": "Lift partial function",
        "description": "True or False?",
        "codeSnippet": "val f: PartialFunction[Int, Int] = { case 1 => 2 }\nf.lift(2)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `None`. Safe.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_64",
        "title": "FlatMap return type",
        "description": "Identify signature.",
        "codeSnippet": "List(1).flatMap(x => x)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`flatMap` requires function returning a collection (`GenTraversableOnce`). `x` is `Int`. `Int` is not a collection. Error.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_64",
        "title": "FlatMap option",
        "description": "True or False?",
        "codeSnippet": "List(1).flatMap(x => Some(x))",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Option is iterable.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_65",
        "title": "Either map",
        "description": "Identify hierarchy.",
        "codeSnippet": "val e: Either[String, Int] = Right(1)\ne.map(_ + 1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Prior to Scala 2.12, `Either` was not right-biased. `map` did not exist directly on Either; needed `e.right.map`. In Scala 2.12+, this is VALID. If context implies older Scala, it's error. Assuming modern Scala (2.13/3), this is VALID. \nError: `Right` projection fail. \nReal Error: `Option` get key map. \nCode: `Map(1->2).get(1).get`. \nError: `Map.get` returns Option. `Option.get` is unsafe. \nReal Error: `Set` map changes size. \nCode: `val s = Set(1, -1); val s2 = s.map(_.abs); assert(s.size == s2.size)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_65_real",
        "title": "Set map size change",
        "description": "Identify behavior.",
        "codeSnippet": "val s = Set(1, -1).map(_.abs)\nassume(s.size == 2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`s` becomes `Set(1)`. Size is 1. `assume` fails. Mapping a Set can reduce its size due to collisions.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_65",
        "title": "Option filter",
        "description": "True or False?",
        "codeSnippet": "Some(2).filter(_ % 2 == 0)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns `Some(2)`. If false, `None`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_66",
        "title": "String interpolation type",
        "description": "Identify syntax.",
        "codeSnippet": "val i = 1\nf\"$i%2d\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Formatted. \nError: `raw` escape? \nCode: `raw\"\\n\".length`. \nError: Returns 2 (backslash and n). \nReal Error: `s` interpolation object. \nCode: `s\"$x\"` where x is object without toString? No, works. \nReal Error: `s` interpolation missing var. \nCode: `s\"$missing\"`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_66_real",
        "title": "String interpolation variable",
        "description": "Identify scope.",
        "codeSnippet": "s\"$missingVariable\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Variable `missingVariable` not found in scope.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_66",
        "title": "Expression interpolation",
        "description": "True or False?",
        "codeSnippet": "s\"${1 + 1}\"",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"2\".",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_67",
        "title": "Implicit class constructor",
        "description": "Identify syntax.",
        "codeSnippet": "implicit class C(x: Int, y: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Implicit classes must have exactly one primary constructor parameter/argument (the wrapped type). `(x: Int, y: Int)` is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_67",
        "title": "Implicit class valid",
        "description": "True or False?",
        "codeSnippet": "implicit class RichInt(x: Int) { def twice = x * 2 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_68",
        "title": "Trait method collision",
        "description": "Identify inheritance.",
        "codeSnippet": "trait A { def f = 1 }\ntrait B { def f = 2 }\nclass C extends A with B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Method `f` is inherited from both A and B. Conflict. `C` must override `f` to disambiguate. `override def f = super[A].f` etc.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_68",
        "title": "Trait stackable",
        "description": "True or False?",
        "codeSnippet": "trait A { def f = 1 }\ntrait B extends A { override def f = super.f + 1 }\nclass C extends A with B",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Linearization. C.f is 2.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_69",
        "title": "ByName params function",
        "description": "Identify type.",
        "codeSnippet": "val f: (=> Int) => Int = { x => x }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Function types cannot have call-by-name parameters like `(=> Int) => Int`. Only methods `def` can have call-by-name parameters. Function literals must take values.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_69",
        "title": "No-arg function",
        "description": "True or False?",
        "codeSnippet": "val f: () => Int = () => 1",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_70",
        "title": "Try in map",
        "description": "Identify type.",
        "codeSnippet": "List(\"1\", \"a\").map { s => try { s.toInt } }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Compiles, but returns `List[Any]`. The `try` block returns `Int` (success) or `Unit`/`Nothing` (implicit catch? no). Wait `map { try ... }` without catch? If it throws, the whole expression throws. Not ErrorSpotting per se unless logic. \nReal Error: `catch` missing? \nCode: `try { 1 }`. Valid (returns 1). \nReal Error: `Option.get` in map? \nCode: `List(None).map(_.get)`. Throws. \nReal Error: `Stream` laziness? \nCode: `val s = Stream(1, 2, 3)` (deprecated). `LazyList`? \nLet's go with `Unit` return in `map`. \nCode: `List(1).map(println)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_70_real",
        "title": "Map unit return",
        "description": "Identify behavior.",
        "codeSnippet": "val l: List[Int] = List(1).map(println)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`println` returns `Unit`. The result is `List[Unit]`, which cannot be assigned to `List[Int]`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_70",
        "title": "Foreach unit",
        "description": "True or False?",
        "codeSnippet": "List(1).foreach(println)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns Unit.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_71",
        "title": "Collect partial fail",
        "description": "Identify behavior.",
        "codeSnippet": "List(1, \"s\").collect { case i: Int => i.toString }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Filters and maps. Returns `List(\"1\")`. \nError: `reduce` on empty? \nCode: `List[Int]().reduce(_ + _)`. \nError: `reduce` throws `UnsupportedOperationException` on empty list. Use `fold` or `reduceOption`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_71_real",
        "title": "Reduce on empty",
        "description": "Identify runtime.",
        "codeSnippet": "List.empty[Int].reduce(_ + _)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`reduce` is not safe for empty collections. It throws an exception. Use `foldLeft` (with initial value) or `reduceOption`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_71",
        "title": "FoldLeft empty",
        "description": "True or False?",
        "codeSnippet": "List.empty[Int].foldLeft(0)(_ + _)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 0.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_72",
        "title": "Option.orNull type",
        "description": "Identify typing.",
        "codeSnippet": "val x: Int = Some(1).orNull",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`orNull` returns `A` or `null`. `Int` is a value type (`AnyVal`), cannot be null. But wait, boxing? `orNull` requires `A >: Null`. `Int` isn't `>: Null`. Error: `Cannot prove that Null <:< Int`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_72",
        "title": "Option filter map",
        "description": "True or False?",
        "codeSnippet": "Some(1).filter(_ > 0).map(_ + 1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_73",
        "title": "Synchronized on value",
        "description": "Identify thread-safety.",
        "codeSnippet": "class C { def f = synchronized { println(\"hi\") } }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Synchronizes on `this`. \nError: `synchronized` on val? \nCode: `val x = 1; x.synchronized {}`. \nError: `Int` is AnyVal. Cannot synchronize on primitive value (boxing might make new objects). Similar to Clojure locking.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_73_real",
        "title": "Synchronized on anyval",
        "description": "Identify runtime.",
        "codeSnippet": "val x: Int = 1\nx.synchronized { }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Synchronizing on a value type `Int` (which might be boxed to temporary `Integer`) provides no guarantee of mutual exclusion, or is disallowed.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_73",
        "title": "Future successful",
        "description": "True or False?",
        "codeSnippet": "Future.successful(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_74",
        "title": "Private this access",
        "description": "Identify visibility.",
        "codeSnippet": "class C { private[this] val x = 1; def f(c: C) = c.x }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`private[this]` means object-private. Cannot access `x` of *another* instance `c`, only `this.x`. `c.x` is invalid here.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_74",
        "title": "Private class access",
        "description": "True or False?",
        "codeSnippet": "class C { private val x = 1; def f(c: C) = c.x }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `private` is class-private (accessible in other instances of same class).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_75",
        "title": "Match guard syntax",
        "description": "Identify syntax.",
        "codeSnippet": "x match { case i if(i > 0) => i }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: Guard with boolean operator syntax? \nCode: `case i && i > 0 =>`. \nError: Guard syntax is `if ...`. \nReal Error: `case class` pattern arity. \nCode: `case class C(x: Int, y: Int); C(1, 2) match { case C(x) => x }`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_75_real",
        "title": "Pattern match arity",
        "description": "Identify syntax.",
        "codeSnippet": "case class C(x: Int, y: Int)\nval c = C(1, 2)\nc match { case C(x) => x }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Pattern match must match structure. `C` expects 2 arguments. `case C(x, y)` or `case C(x, _)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_75",
        "title": "UnapplySeq",
        "description": "True or False?",
        "codeSnippet": "List(1, 2) match { case List(x, _*) => x }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Matches head 1.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_76",
        "title": "String to Float locale",
        "description": "Identify runtime.",
        "codeSnippet": "\"1,5\".toFloat",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`toFloat` relies on Java's assumption of dot `.` as separator or locale-dependent? It throws `NumberFormatException` for \"1,5\" unless locale is specifically set to allow comma (not default behavior of standard String.toFloat usually wrapping ValueOf). JVM defaults often expect dot.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_76",
        "title": "String interpolator f",
        "description": "True or False?",
        "codeSnippet": "val d = 1.2\nf\"$d%.2f\".length > 0",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_77",
        "title": "List append performance",
        "description": "Identify performance.",
        "codeSnippet": "var l = List(1)\n(1 to 10000).foreach(i => l = l :+ i)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Appending to a List (`:+`) is O(N). Doing this in a loop makes it O(N^2). Performance disaster. Use `ListBuffer` or prepend (`::`) and reverse.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_77",
        "title": "Vector append performance",
        "description": "True or False?",
        "codeSnippet": "var v = Vector(1)\n(1 to 1000).foreach(i => v = v :+ i)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Vector append is effectively constant time (O(1)).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_78",
        "title": "Implicit conversion scope",
        "description": "Identify resolution.",
        "codeSnippet": "object O { implicit def s2i(s: String) = s.length }\nval x: Int = \"s\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Implicit conversion `s2i` is in object `O`, not imported or in companion. Not in scope. Compile error. Needs `import O._`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_78",
        "title": "Companion implicit scope",
        "description": "True or False?",
        "codeSnippet": "case class A(i: Int)\nobject A { implicit def s2a(s: String) = A(s.length) }\nval a: A = \"s\"",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Companion object of target type A is searched for implicits.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_79",
        "title": "Ordering vs Ordered",
        "description": "Identify api.",
        "codeSnippet": "def f[T: Ordered](x: T, y: T) = x < y",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid if T implements Ordered. \nError: `implicitly` fail? \nCode: `implicitly[Ordering[Int]]`. Valid. \nReal Error: `Array` deep equals. \nCode: `Array(1) == Array(1)`. \nError: Reference equality for Arrays (Java syntax). Returns false. Use `sameElements` or wrap in `Seq`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_79_real",
        "title": "Array equality check",
        "description": "Identify behavior.",
        "codeSnippet": "if (Array(1, 2) == Array(1, 2)) println(\"same\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Arrays use reference equality (`==` matches Java `==`). Two different array instances are not equal. Use `.sameElements` or `deep`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_79",
        "title": "List equality",
        "description": "True or False?",
        "codeSnippet": "List(1, 2) == List(1, 2)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Structural equality.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_80",
        "title": "Call by name cache",
        "description": "Identify behavior.",
        "codeSnippet": "def f(x: => Int) = x + x\nf({ println(\"calc\"); 1 })",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Call-by-name parameter `x` is evaluated *every time* it is accessed. \"calc\" is printed twice. Not an error, but often performance bug. Use `lazy val` inside function if caching needed.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_80",
        "title": "Lazy val cache",
        "description": "True or False?",
        "codeSnippet": "def f(x: => Int) = { lazy val y = x; y + y }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. x evaluated once.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_81",
        "title": "Private constructor instantiation",
        "description": "Identify visibility.",
        "codeSnippet": "class C private (val x: Int)\nval c = new C(1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Constructor is private. Cannot instantiate from outside. Use companion object factory if provided.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_81",
        "title": "Private ctor companion",
        "description": "True or False?",
        "codeSnippet": "class C private (x: Int); object C { def make = new C(1) }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_82",
        "title": "Abstract override requirement",
        "description": "Identify syntax.",
        "codeSnippet": "trait T { def f: Int }\ntrait M extends T { override def f = super.f + 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Calling `super.f` on an abstract method in a trait requires `abstract override` modifier safely (stackable trait pattern). `override` alone is insufficient if `super.f` is abstract.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_82",
        "title": "Abstract override valid",
        "description": "True or False?",
        "codeSnippet": "trait T { def f: Int }\ntrait M extends T { abstract override def f = super.f + 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_83",
        "title": "Regex invalid group",
        "description": "Identify runtime.",
        "codeSnippet": "val r = \"(a)(b)\".r\nval r(x) = \"ab\"",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Regex has 2 capturing groups `(a)` and `(b)`. Extractor pattern `r(x)` expects 1 argument (or match logic mismatch). It throws MatchError or arity matching error.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_83",
        "title": "Regex unapply",
        "description": "True or False?",
        "codeSnippet": "val r = \"(\\d+)\".r\n\"123\" match { case r(n) => true }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_84",
        "title": "App delayed init",
        "description": "Identify behavior.",
        "codeSnippet": "object O extends App {\n  if (args.length > 0) println(\"Has args\")\n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid in Scala 2 (Deprecated usage of args in body sometimes? No, args is available). \nError: `App` in Scala 3 main method? \nCode: `object O extends App { override def main() ... }`. \nError: `App` implements main. Overriding it might ignore body. \nReal Error: `return` inside `App` body? \nCode: `object O extends App { return }`. \nError: Body of `App` is effectively constructor/init code. `return` deprecated/invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_84_real",
        "title": "Return in App body",
        "description": "Identify behavior.",
        "codeSnippet": "object O extends App { return }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Using `return` at the top level of an object extending `App` is not supported (or throws exception/deprecated), as the body is executed via `DelayedInit` (Scala 2).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_84",
        "title": "Main method standard",
        "description": "True or False?",
        "codeSnippet": "object O { def main(args: Array[String]): Unit = {} }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Standard entry point.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_85",
        "title": "TypeTag arguments",
        "description": "Identify library.",
        "codeSnippet": "import scala.reflect.runtime.universe.TypeTag\ndef f[T](x: T)(implicit tag: TypeTag[String])",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "It asks for a TypeTag of `String` explicitly, ignoring `T`. Usually one wants `TypeTag[T]` to inspect T. Not invalid syntax, but logic error for generic introspection.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_85",
        "title": "ClassTag usage",
        "description": "True or False?",
        "codeSnippet": "import scala.reflect.ClassTag\ndef f[T: ClassTag](x: T) = implicitly[ClassTag[T]].runtimeClass.getName",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_86",
        "title": "Set intersection type",
        "description": "Identify api.",
        "codeSnippet": "val s1 = Set(1)\nval s2 = Set(\"2\")\nval s3 = s1 & s2",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. `Set[Any]`. Empty set. \nError: `Set` union `|`? Works. \nError: `Map` + tuple syntax? \nCode: `Map(1->2) + (3->4)`. \nError: `Map` `+` expects tuple argument `(key, value)`. Syntax `(3->4)` IS a tuple. Valid. \nReal Error: `Map` merge duplicate key default. \nCode: `Map(1->2, 1->3)`. \nError: Valid (last wins). \nReal Error: `PartialFunction` isDefinedAt? \nCode: `val f: PartialFunction[Int,Int] = { case 1 => 2 }; f.isDefinedAt(2)` returns false. \nReal Error: `def` inside `val` block scope? \nCode: `val x = { def f = 1; f }`. Valid. \nReal Error: `trait` parameter standard Scala 2. \nCode: `trait T(x: Int)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_86_real",
        "title": "Trait parameter Scala 2",
        "description": "Identify syntax.",
        "codeSnippet": "trait T(x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "In standard Scala 2, traits cannot have parameters. (Added in Scala 3).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_86",
        "title": "Trait method impl",
        "description": "True or False?",
        "codeSnippet": "trait T { def f = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_87",
        "title": "Dynamic apply",
        "description": "Identify api.",
        "codeSnippet": "class C extends Dynamic\nval c = new C\nc.foo",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Extending `Dynamic` helper trait is not enough. Must implement `applyDynamic` or `selectDynamic`. Compile error: method foo not found (dynamic lookup fails without impl).",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_87",
        "title": "Dynamic valid",
        "description": "True or False?",
        "codeSnippet": "import scala.language.dynamics\nclass C extends Dynamic { def selectDynamic(name: String) = name }\n(new C).foo",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"foo\".",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_88",
        "title": "Varargs expansion",
        "description": "Identify syntax.",
        "codeSnippet": "def f(xs: Int*) = xs.sum\nval l = List(1, 2)\nf(l)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Cannot pass a List directly to a varargs method. Must explode it using `:_*`. `f(l:_*)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_88",
        "title": "Varargs explode",
        "description": "True or False?",
        "codeSnippet": "def f(xs: Int*) = xs.sum\nf(Seq(1, 2):_*)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_89",
        "title": "Case class private params",
        "description": "Identify syntax.",
        "codeSnippet": "case class C(private val x: Int)\nval c = C(1)\nc.x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Parameter `x` is declared `private`. Cannot be accessed outside class C.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_89",
        "title": "Case class access default",
        "description": "True or False?",
        "codeSnippet": "case class C(x: Int)\nC(1).x",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_90",
        "title": "For comprehension filter",
        "description": "Identify syntax.",
        "codeSnippet": "for (i <- 1 to 5; if i > 2) yield i",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid syntax (semicolon + if). \nError: `match` inside for? \nCode: `for (i <- 1 to 5 match ...)`. \nError: Invalid syntax. \nReal Error: `def` inside method args. \nCode: `f(def x = 1)`. \nError: `def` not allowed in expression argument position.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_90_real",
        "title": "Option getOrElse type",
        "description": "Identify typing.",
        "codeSnippet": "val x: Int = Some(1).getOrElse(\"s\")",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`getOrElse` returns the LUB (Least Upper Bound) of Option type and default type. `Int` vs `String` -> `Any`. `Any` cannot be assigned to `Int`. Compile error.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_90",
        "title": "Option fold",
        "description": "True or False?",
        "codeSnippet": "Some(1).fold(0)(_ + 1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 2.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_91",
        "title": "String multiply",
        "description": "Identify api.",
        "codeSnippet": "\"a\" * 3",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid in Scala (`StringOps`). Returns \"aaa\". \nError: `Set` index access? \nCode: `Set(1)(0)`. \nError: Sets are functions `T => Boolean`. `Set(1)(0)` checks if 0 is in set (returns false). Not index access. If user expects index, it's logic error, but code compiles. \nReal Error: `Map` apply missing key. \nCode: `Map(1->1)(2)`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_91_real",
        "title": "Map apply missing key",
        "description": "Identify runtime.",
        "codeSnippet": "val m = Map(1->1)\nm(2)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Calling `apply` on a Map with a missing key throws `NoSuchElementException`. Use `get` (returns Option) or `getOrElse`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_91",
        "title": "Map withDefaultValue",
        "description": "True or False?",
        "codeSnippet": "val m = Map(1->1).withDefaultValue(0)\nm(2)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Returns 0.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_92",
        "title": "Package visibility",
        "description": "Identify visibility.",
        "codeSnippet": "package p { class C { private[p] def f = 1 } }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. package private. \nError: `protected[this]` access? \nCode: `class C { protected[this] def f=1 }; (new C).f`. \nError: `protected[this]` is object-protected. Cannot access on another instance.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_92_real",
        "title": "Protected this access",
        "description": "Identify visibility.",
        "codeSnippet": "class C { protected[this] def f = 1; def g(other: C) = other.f }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`protected[this]` restricts access to the current instance `this`. Accessing `other.f` is forbidden.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_92",
        "title": "Object private access",
        "description": "True or False?",
        "codeSnippet": "class C { private def f = 1; def g(other: C) = other.f }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Private implies class-private in Scala.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_93",
        "title": "ClassOf generics",
        "description": "Identify syntax.",
        "codeSnippet": "classOf[List[Int]]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`classOf` takes a raw type/class literal. Generics are erased. `classOf[List[Int]]` is invalid syntax/error. Use `classOf[List[_]]` or just `classOf[List]`. Class literals don't have type args in JVM.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_93",
        "title": "ClassOf valid",
        "description": "True or False?",
        "codeSnippet": "val c = classOf[String]",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_94",
        "title": "Function vs Method",
        "description": "Identify type.",
        "codeSnippet": "def m(x: Int) = x\nval f = m",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot assign method `m` to value `f` without eta-expansion. Missing arguments. Use `val f = m _`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_94",
        "title": "Eta expansion",
        "description": "True or False?",
        "codeSnippet": "def m(x: Int) = x\nval f: Int => Int = m",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Target type expected allows auto eta-expansion.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_95",
        "title": "Stream legacy",
        "description": "Identify deprecation.",
        "codeSnippet": "val s = Stream(1, 2, 3)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid in 2.12. Deprecated in 2.13 (use LazyList). Not strictly 'ErrorSpotting' unless checking modern constraints. \nError: `def` macro definition? \nCode: `def m = macro impl`. \nError: Macro implementation must be static/object? \nReal Error: `lazy val` in trait initialization. \nCode: `trait T { val x: Int; val y = x + 1 }; class C extends T { val x = 10 }; (new C).y`. \nError: `y` is initialized BEFORE `x` in subclass. `x` is 0 (default). `y` becomes 1. Expectation 11. Use `lazy val y` or `def y`.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_95_real",
        "title": "Trait initialization order",
        "description": "Identify behavior.",
        "codeSnippet": "trait T { val x: Int; val y = x + 1 }\nclass C extends T { val x = 10 }\nprintln((new C).y)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Prints 1, not 11. `T` is initialized before `C`. `x` is 0 (default Int) when `y` is calculated. Use `lazy val y` or early initializers (deprecated) to fix.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_95",
        "title": "Lazy val in trait",
        "description": "True or False?",
        "codeSnippet": "trait T { val x: Int; lazy val y = x + 1 }\nclass C extends T { val x = 10 }\n(new C).y == 11",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_96",
        "title": "Covariant mutable",
        "description": "Identify rules.",
        "codeSnippet": "class Box[+T](var x: T)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Covariant type parameter `T` occurs in contravariant position (mutable setter `x_=`). Mutable fields cannot be covariant.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_96",
        "title": "Covariant immutable",
        "description": "True or False?",
        "codeSnippet": "class Get[+T](val x: T)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_97",
        "title": "Contravariant return",
        "description": "Identify rules.",
        "codeSnippet": "trait T[-A] { def get: A }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Contravariant type `A` occurs in covariant position (return type). Unsafe.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_97",
        "title": "Contravariant argument",
        "description": "True or False?",
        "codeSnippet": "trait Consumer[-A] { def eat(a: A): Unit }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_98",
        "title": "Implicit class top level",
        "description": "Identify syntax.",
        "codeSnippet": "implicit class C(x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Implicit classes cannot be top-level. Must be inside object, class, or package object.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_98",
        "title": "Value class",
        "description": "True or False?",
        "codeSnippet": "class Wrapper(val x: Int) extends AnyVal",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_99",
        "title": "Repeated param position",
        "description": "Identify syntax.",
        "codeSnippet": "def f(xs: Int*, y: Int) = 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Varargs parameter `xs: Int*` must be the last parameter.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_99",
        "title": "Default args varargs",
        "description": "True or False?",
        "codeSnippet": "def f(s: String = \"\", xs: Int*) = 1",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_100",
        "title": "Object equals",
        "description": "Identify logic.",
        "codeSnippet": "object O\nO == new Object",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid expression. False. \nError: `Set` containing array? \nCode: `Set(Array(1)).contains(Array(1))`. \nError: Returns false. Arrays use reference equality. Checking for content fails.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_100_real",
        "title": "Set of arrays",
        "description": "Identify behavior.",
        "codeSnippet": "val s = Set(Array(1))\nval has = s.contains(Array(1))",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Arrays do not implement structural `hashCode`/`equals`. `Set` relies on them. Effectively, `Set` stores reference. New array has different reference. Returns false.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_tf_100",
        "title": "Set of lists",
        "description": "True or False?",
        "codeSnippet": "Set(List(1)).contains(List(1))",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "scala_err_101",
        "title": "Structural type reflection",
        "description": "Identify reflection.",
        "codeSnippet": "def closeUsually(x: { def close(): Unit }) = x.close()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid syntax (Reflective Call). \nError: `import` logic? \nCode: `import scala.language.reflectiveCalls`. \nError: If not imported, compiler emits warning about reflective access being slow/unsafe. Not strict error unless `-Xfatal-warnings`. \nReal Error: `implicit` search failure. \nCode: `implicitly[Ordering[Any]]`. \nError: No implicit Ordering for Any.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_101_real",
        "title": "Implicit missing",
        "description": "Identify resolution.",
        "codeSnippet": "implicitly[Ordering[Any]]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "No implicit value of type `Ordering[Any]` found. `Any` does not define an ordering.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_101",
        "title": "Structural type syntax",
        "description": "True or False?",
        "codeSnippet": "import scala.language.reflectiveCalls\ntype Closer = { def close(): Unit }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Structural type.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_102",
        "title": "Path dependent type mismatch",
        "description": "Identify types.",
        "codeSnippet": "class Outer { class Inner }\nval o1 = new Outer\nval o2 = new Outer\nval i: o1.Inner = new o2.Inner",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 3,
        "explanation": "`Inner` is path-dependent. `o1.Inner` and `o2.Inner` are distinct types. Cannot assign `o2.Inner` instance to `o1.Inner` variable.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_102",
        "title": "Type projection",
        "description": "True or False?",
        "codeSnippet": "class Outer { class Inner }\nval i: Outer#Inner = new (new Outer).Inner",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `Outer#Inner` is the supertype of all inner instances.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_103",
        "title": "Self type requirement",
        "description": "Identify inheritance.",
        "codeSnippet": "trait A\ntrait B { self: A => }\nclass C extends B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Trait `B` has a self-type `A`. Any class mixing in `B` must also mix in `A`. `class C extends B` fails. Must be `class C extends B with A` (or `extends A with B`).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_103",
        "title": "Self type mixed",
        "description": "True or False?",
        "codeSnippet": "trait User; trait Tweeter { self: User => }\nclass Bot extends User with Tweeter",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_104",
        "title": "Existential type access",
        "description": "Identify types.",
        "codeSnippet": "val l: List[_] = List(1)\nl.head + 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`l.head` has type `Any` (or existential capture `T`). Cannot add `1` to it. Compiler doesn't know it's an Int.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_104",
        "title": "Existential type safety",
        "description": "True or False?",
        "codeSnippet": "val l: List[_] = List(1)\nl.size",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Size is independent of content type.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_105",
        "title": "Context bound syntax",
        "description": "Identify syntax.",
        "codeSnippet": "def f[T: Ordering](x: T, y: T): Boolean = implicitly[Ordering[T]].lt(x, y)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `abstract class` parameters val? \nCode: `abstract class A(x: Int); class B extends A(1)`. \nError: Valid. \nReal Error: `val` in `def` param? \nCode: `def f(val x: Int) = x`. \nError: `val` keyword not allowed in method parameters (implicitly val).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_105_real",
        "title": "Val in def args",
        "description": "Identify syntax.",
        "codeSnippet": "def f(val x: Int) = x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`val` or `var` keywords are not allowed in method parameter lists. (Case classes allow them, simple methods do not).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_105",
        "title": "Implicit parameter val",
        "description": "True or False?",
        "codeSnippet": "def f(implicit x: Int) = x",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. implicit keyword is allowed (and required).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_106",
        "title": "Contravariant position 2",
        "description": "Identify rules.",
        "codeSnippet": "trait T[-A] { def f(a: A): A }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Return type `A` is in covariant position. `A` is contravariant. Error: contravariant type A occurs in covariant position in type (a: A)A.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_106",
        "title": "Lower bound constraint",
        "description": "True or False?",
        "codeSnippet": "trait List[+A] { def prepend[B >: A](elem: B): List[B] }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Lower bound `B >: A` fixes the variance issue.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_107",
        "title": "Abstract type alias bound",
        "description": "Identify syntax.",
        "codeSnippet": "trait T { type A <: Int }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid (abstract type member). \nError: `Int` as upper bound? `Int` is AnyVal, final. \nCode: `trait T { type A <: String }`. String is final. Can we extend final classes? No. Can we have types bounded by them? Yes, technically `type A = String` satisfies it. \nReal Error: `def` with dependent type return. \nCode: `def f(x: AnyRef): x.type = x`. \nError: Valid path dependent type. \nReal Error: `Aux` pattern missing. \nCode: `implicitly[Foo[Int]]` where Foo needs internal type matching.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_107_real",
        "title": "Final class inheritance",
        "description": "Identify syntax.",
        "codeSnippet": "final class C\nclass D extends C",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot extend a `final` class.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_107",
        "title": "Abstract type member",
        "description": "True or False?",
        "codeSnippet": "trait T { type A; def get: A }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_108",
        "title": "Higher kinded type syntax",
        "description": "Identify syntax.",
        "codeSnippet": "trait Monad[F] { def pure[A](a: A): F[A] }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Type parameter `F` is used as a constructor `F[A]`. It must be declared as higher-kinded: `trait Monad[F[_]]`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_108",
        "title": "Higher kinded usage",
        "description": "True or False?",
        "codeSnippet": "trait Functor[F[_]] { def map[A, B](fa: F[A])(f: A => B): F[B] }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_109",
        "title": "Implicit conversion chaining",
        "description": "Identify resolution.",
        "codeSnippet": "implicit def a2b(a: A): B = ...\nimplicit def b2c(b: B): C = ...\nval c: C = new A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Scala implicit resolution does not chain conversions automatically (one step only). `A` -> `B` -> `C` is not explored. Error/Mismatch.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_109",
        "title": "Implicit param chaining",
        "description": "True or False?",
        "codeSnippet": "implicit val a = 1; implicit def b(implicit i: Int) = i.toString\ndef f(implicit s: String) = s\nf",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Implicit parameters are resolved recursively (implicit values can depend on other implicits).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_110",
        "title": "Right associative colon",
        "description": "Identify mechanics.",
        "codeSnippet": "class C { def ::(x: Int) = x }\nval c = new C\nc :: 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Methods ending in `:` are right-associative. `c :: 1` is desugared to `1.::(c)`. `Int` does not have method `::` taking `C`. Error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_110",
        "title": "List cons right assoc",
        "description": "True or False?",
        "codeSnippet": "1 :: List(2)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Becomes `List(2).::(1)`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_111",
        "title": "ByName param in class",
        "description": "Identify syntax.",
        "codeSnippet": "class C(x: => Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Call-by-name parameters in classes must be `private` or not a `val`/`var`. Standard class parameters are private vals? Wait. \n`class C(x: => Int)` is valid constructor param. But accessing it as `c.x`? If it's a `case class`, they are public vals. `case class C(x: => Int)` -> Error: `val` parameters cannot be call-by-name. \nCode above is regular class. `x` is constructor arg.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_111_real",
        "title": "Case class by-name val",
        "description": "Identify syntax.",
        "codeSnippet": "case class C(x: => Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Case class parameters are public vals by default. `val` cannot be call-by-name. Syntax error or forbidden.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_111",
        "title": "Class by-name param",
        "description": "True or False?",
        "codeSnippet": "class C(x: => Int) { def get = x }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `x` is captured as a function/thunk in the class body.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_112",
        "title": "Volatile var usage",
        "description": "Identify concurrency.",
        "codeSnippet": "@volatile var x = 0\n// thread 1: x += 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. \nError: Logic? `x += 1` is not atomic. Race condition. But code compiles. \nReal Error: `lazy val` inside function not thread safe? No it is. \nReal Error: `def` overloading with defaults? \nCode: `def f(a: Int = 1) = 1; def f() = 2`. \nError: Ambiguous call `f()`. Compiler error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_112_real",
        "title": "Ambiguous method overloading",
        "description": "Identify resolution.",
        "codeSnippet": "def f(a: Int = 1) = a\ndef f() = 2\nf()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Call `f()` is ambiguous. Could be `f(1)` (default args) or `f()` (no args). Compiler cannot decide.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_112",
        "title": "Overloading difference",
        "description": "True or False?",
        "codeSnippet": "def f(x: Int) = 1\ndef f(x: String) = 2",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_113",
        "title": "Aux pattern usage",
        "description": "Identify pattern.",
        "codeSnippet": "trait Foo[A] { type B; def value: B }\nimplicit def mkFoo[A]: Foo[A] = new Foo[A] { type B = String; def value = \"s\" }\ndef f[A](implicit foo: Foo[A]): foo.B = foo.value",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `implicit` not found due to type mismatch? \nReal Error: `shapeless` `HList` :: missing import? \nReal Error: `Option` match `Some(null)`? \nCode: `Some(null)`. Valid. \nReal Error: `unapply` boolean return. \nCode: `object O { def unapply(x: Int): Boolean = x > 0 }`. \nCode: `1 match { case O() => }`. \nError: Boolean unapply used as `O()`. Valid. \nReal Error: `unapply` product return. \nCode: `object O { def unapply(x: Int) = (x, x) }`. `1 match { case O(a, b) => }`. \nError: Tuples are Products. Valid. \nReal Error: `val` override `def`. \nCode: `trait T { def x: Int }; class C extends T { val x = 1 }`. Valid. \nReal Error: `def` override `val`. \nCode: `trait T { val x: Int }; class C extends T { def x = 1 }`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_113_real",
        "title": "Override val with def",
        "description": "Identify inheritance.",
        "codeSnippet": "class A { val x = 1 }\nclass B extends A { override def x = 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot override mutable/stable `val` with `def`. `val` implies stable computed value; `def` implies re-evaluation. Subclass cannot weaken the guarantee.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_113",
        "title": "Override def with val",
        "description": "True or False?",
        "codeSnippet": "trait A { def x: Int }\nclass B extends A { val x = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `def` is general, `val` is specific (stable).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_114",
        "title": "Trait constructor args 2",
        "description": "Identify syntax.",
        "codeSnippet": "trait T(val x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Trait parameters illegal in Scala 2. Valid in Scala 3. Assuming Scala 2 context (common codebase), this is error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_114",
        "title": "Early initializer",
        "description": "True or False?",
        "codeSnippet": "trait T { val x: Int }; class C extends { val x = 1 } with T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Early definitions syntax (deprecated in 3, valid in 2).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_115",
        "title": "Package object collision",
        "description": "Identify layout.",
        "codeSnippet": "// package.scala\npackage com.example\npackage object utils { val x = 1 }\n// Other.scala\npackage com.example.utils\nclass C",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Package object `utils` and package `utils` coexist? \nPackage `com.example.utils` corresponds to package object. \nInside `com.example.utils` package (Other.scala), can we access `x`? Yes. \nError: Defining `package object` inside another package object? \nCode: `package object outer { package object inner {} }`. \nError: package objects must be defined in the enclosing package, not inside other objects.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_115_real",
        "title": "Nested package object",
        "description": "Identify syntax.",
        "codeSnippet": "object O {\n  package object P {\n    val x = 1\n  }\n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Package objects cannot be defined inside other objects or classes. They must be top-level in a package.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_115",
        "title": "Package object usage",
        "description": "True or False?",
        "codeSnippet": "package object mypkg { val x = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Defines `mypkg` package members.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_116",
        "title": "Multiple implicit matches",
        "description": "Identify resolution.",
        "codeSnippet": "trait A\nimplicit val a1 = new A {}\nimplicit val a2 = new A {}\ndef f(implicit a: A) = a\nf",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 4,
        "explanation": "Ambiguous implicit values `a1` and `a2` of type `A`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_116",
        "title": "Implicit priority",
        "description": "True or False?",
        "codeSnippet": "trait A; trait B extends A\nimplicit val a = new A {}\nimplicit val b = new B {}\ndef f(implicit x: A) = x\nf",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `b` is more specific than `a`. `b` is chosen.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_117",
        "title": "Default arg macro",
        "description": "Identify limits.",
        "codeSnippet": "def f(x: Int = defaultValue)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "If `defaultValue` is not defined? obvious. \nError: `lazy val` in default arg? \nCode: `def f(x: Int = { println(\"hi\"); 1 })`.\nValid. \nError: recursive default arg? \nCode: `def f(x: Int = f())`. \nError: Recursive call.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_117_real",
        "title": "Recursive default argument",
        "description": "Identify logic.",
        "codeSnippet": "def f(x: Int = f(1)): Int = x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Recursive method call in default argument with no base case or circular logic. `f()` calls `f(f(1))` calls `f(1)`. Wait. `f(1)` returns 1. `f()` becomes `f(1)`. It works? \nCode: `def g(x: Int = g())` -> Infinite recursion at runtime. \nLet's assume the recursive call is infinite.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_117",
        "title": "Default arg scope",
        "description": "True or False?",
        "codeSnippet": "def f(x: Int = 1, y: Int = x) = x + y",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": false,
        "explanation": "False. Parameters in the same list cannot depend on each other (scope of `x` starts after param list?). In Scala, strictly: `x` is not in scope for `y`'s default. Valid if curried: `def f(x: Int)(y: Int = x)`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_118",
        "title": "Unsafe null logical",
        "description": "Identify best-practice.",
        "codeSnippet": "val x: String = null\nx.length",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "NullPointerException. Scala does not protect against `null` if assigned explicitly or from Java. `Option` should be used.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_118",
        "title": "Option(null)",
        "description": "True or False?",
        "codeSnippet": "Option(null) == None",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `Option.apply` handles null.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_119",
        "title": "Case object inheritance",
        "description": "Identify syntax.",
        "codeSnippet": "case object A\ncase object B extends A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Case objects cannot be extended (they are effectively final, though `case class` can sometimes be inherited in old Scala, case object `A` is a value/module). `A` is not a type suitable for extension? `A` is an object. Cannot extend an object.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_119",
        "title": "Extend case class",
        "description": "True or False?",
        "codeSnippet": "case class A(x: Int); class B extends A(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": false,
        "explanation": "False. Case classes should not be extended (it breaks equality contracts and product prefix). Compiler deprecates or forbids it.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_120",
        "title": "Super constructor order",
        "description": "Identify behavior.",
        "codeSnippet": "class A { println(\"A\") }\nclass B extends A { println(\"B\") }\nnew B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Prints A then B. \nError: `this` call must be first. \nCode: `class A { def this(x: Int) = { println(\"hi\"); this() } }`. \nError: Auxiliary constructor must call primary/other constructor as first statement.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_120_real",
        "title": "Auxiliary ctor statement",
        "description": "Identify syntax.",
        "codeSnippet": "class A {\n  def this(x: Int) = {\n    println(\"hi\")\n    this()\n  }\n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Alternative constructor call `this(...)` must be the first statement in an auxiliary constructor.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_120",
        "title": "Primary ctor body",
        "description": "True or False?",
        "codeSnippet": "class A { println(\"A\") }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Class body is the primary constructor.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_121",
        "title": "Implicit class implicit param",
        "description": "Identify syntax.",
        "codeSnippet": "implicit class C(implicit x: Int)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Implicit classes must take one non-implicit argument (the wrappee). Cannot take *only* implicit args.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_121",
        "title": "Implicit class mixed args",
        "description": "True or False?",
        "codeSnippet": "implicit class C(val x: Int)(implicit y: Double)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_122",
        "title": "Trait val override",
        "description": "Identify behavior.",
        "codeSnippet": "trait A { val x = 1 }\ntrait B extends A { override val x = 2 }\nclass C extends A with B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `lazy val` override `val`? \nCode: `trait T { val x: Int }; trait S extends T { override lazy val x = 1 }`. \nError: Cannot override `val` with `lazy val` (stability/strictness mismatch).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_122_real",
        "title": "Override val with lazy val",
        "description": "Identify syntax.",
        "codeSnippet": "class A { val x = 1 }\nclass B extends A { override lazy val x = 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Cannot override a strict `val` with a `lazy val`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_122",
        "title": "Override def with lazy val",
        "description": "True or False?",
        "codeSnippet": "trait A { def x: Int }\nclass B extends A { lazy val x = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_123",
        "title": "Import selector rename",
        "description": "Identify syntax.",
        "codeSnippet": "import java.util.{List => JList, Map}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `=> _` means exclude. \nCode: `import java.util.{List => _, _}`. \nError: Valid (hides List, imports others). \nReal Error: `lazy` var. \nCode: `lazy var x = 1`. \nError: `lazy` not allowed on `var`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_123_real",
        "title": "Lazy var",
        "description": "Identify syntax.",
        "codeSnippet": "lazy var x = 10",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`lazy` keyword can only be used with `val`, not `var`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_123",
        "title": "Abstract lazy val",
        "description": "True or False?",
        "codeSnippet": "trait T { lazy val x: Int }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": false,
        "explanation": "False. `lazy` values must be initialized (cannot be abstract). Abstract member should be `def` or `val`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_124",
        "title": "Private package definition",
        "description": "Identify syntax.",
        "codeSnippet": "private package foo",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Package declarations cannot be private.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_124",
        "title": "Package visibility object",
        "description": "True or False?",
        "codeSnippet": "package p; private[p] object O",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_125",
        "title": "Sealed class extension",
        "description": "Identify syntax.",
        "codeSnippet": "// File1.scala: sealed class C\n// File2.scala: class D extends C",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Sealed class `C` in File1 cannot be extended by `D` in File2. Must be in same file.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_125",
        "title": "Final case class",
        "description": "True or False?",
        "codeSnippet": "final case class C(x: Int)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Redundant but valid (case classes are not final by default, so final makes them truly final).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_126",
        "title": "Tailrec with try catch",
        "description": "Identify limitations.",
        "codeSnippet": "import scala.annotation.tailrec\n@tailrec def f(x: Int): Int = try {\n  if (x == 0) 0 else f(x - 1)\n} catch { case e: Exception => 0 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid? No. Calls inside `try` block are not in tail position (JVM limitation). Cannot assume no stack growth. Compilation error due to `@tailrec`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_126_real",
        "title": "Tailrec try position",
        "description": "Identify limitations.",
        "codeSnippet": "@tailrec def f(n: Int): Int = try { f(n-1) } catch { case _ => 0 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Recursion inside a `try` block prevents tail-call optimization on the JVM. Compiler error with `@tailrec`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_126",
        "title": "Tailrec return position",
        "description": "True or False?",
        "codeSnippet": "@tailrec def f(n: Int): Int = if(n==0) 0 else f(n-1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_127",
        "title": "Manifest deprecated",
        "description": "Identify deprecation.",
        "codeSnippet": "def f[T: Manifest](x: T) = manifest[T].runtimeClass",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`Manifest` is deprecated (superseded by `ClassTag` and `TypeTag`). It is considered best practice to avoid it.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_127",
        "title": "ClassTag primitive",
        "description": "True or False?",
        "codeSnippet": "implicitly[ClassTag[Int]] eq ClassTag.Int",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Specialized class tags.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_128",
        "title": "Raw string escape",
        "description": "Identify syntax.",
        "codeSnippet": "raw\"\\n\".length",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns 2. \nError: `s` string interpolation unescaped quote? \nCode: `s\"Hello \"World\"\"`. \nError: Parse error. Need `\\\"` or triple quotes. \nReal Error: `case class` limit 22? \nCode: `case class C(x1: Int, ... x23: Int)`. \nError: Scala 2 limit is 22. Scala 3 removed it and 2.13 has generic tuples too? 2.13 relaxed it? No, tuples limit 22. Case class limit 254 in 2.11+. \nReal Error: `Function23`. \nCode: `val f: (T1...T23) => R`. \nError: Max arity is 22.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_128_real",
        "title": "Function arity limit",
        "description": "Identify limits.",
        "codeSnippet": "val f = (x1: Int, ..., x23: Int) => 1 // 23 args",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala 2 standard library defines `Function1` up to `Function22`. 23 arguments is not supported natively for functions/tuples.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_128",
        "title": "Tuple arity limit",
        "description": "True or False?",
        "codeSnippet": "val t = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Tuple22 is max.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_129",
        "title": "Symbol literal deprecated",
        "description": "Identify deprecation.",
        "codeSnippet": "val s = 'mySymbol",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Symbol literals `'symbol` are deprecated in Scala 2.13 and removed in Scala 3. Use `Symbol(\"mySymbol\")` or just Strings.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_129",
        "title": "Symbol apply",
        "description": "True or False?",
        "codeSnippet": "val s = Symbol(\"foo\")",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Valid API.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_130",
        "title": "Future traverse serial",
        "description": "Identify concurrency.",
        "codeSnippet": "val futures = List(1, 2).map { i => \n  Thread.sleep(100); Future.successful(i) \n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. Runs roughly sequential creation? No. \nError: `Future.traverse` with blocking code inside `Future`? \nReal Error: `Await.result` blocking threads? \nCode: `Future { Await.result(...) }`. \nError: Thread starvation (blocking thread pool). Use `blocking {}` wrapper. \nReal Error: `Try` flatMap Signature? \nCode: `Try(1).flatMap(x => x)`. \nError: `x` is Int, return must be `Try`. \nReal Error: `Either.merge` type. \nCode: `Right[Int,Int](1).merge`. Returns Int. Valid. \nReal Error: Type alias cyclic? \nCode: `type A = B; type B = A`. Error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_130_real",
        "title": "Type alias cycle",
        "description": "Identify syntax.",
        "codeSnippet": "type A = B\ntype B = A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Cyclic type alias definition is not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_130",
        "title": "Recursive type alias",
        "description": "True or False?",
        "codeSnippet": "type F[A] = A => F[A]",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": false,
        "explanation": "False. Cyclic reference in type alias usually illegal without class wrapper.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_131",
        "title": "Type lambda syntax 2",
        "description": "Identify syntax.",
        "codeSnippet": "type T[X] = ({ type L[Y] = Map[X, Y] })#L[Int]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid (classic type lambda pattern). \nError: `kind-projector` syntax `Map[X, ?]` without plugin? \nCode: `type T[X] = Map[X, ?]`. \nError: Invalid syntax without plugin or Scala 3 (`*`). \nReal Error: `def` with `val` syntax? \nCode: `def x = val y = 1; y`. \nError: Block required `{ ... }`. `def x = { val y = 1; y }`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_131_real",
        "title": "Def block syntax",
        "description": "Identify syntax.",
        "codeSnippet": "def f = val x = 1; x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Single expression body cannot start with `val`. Must be a block `{ val x = 1; x }`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_131",
        "title": "Def single expr",
        "description": "True or False?",
        "codeSnippet": "def f = 1 + 1",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_132",
        "title": "WeakTypeTag usage",
        "description": "Identify reflection.",
        "codeSnippet": "import scala.reflect.runtime.universe._\ndef f[T](x: List[T])(implicit tag: TypeTag[T]) = tag.tpe",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: Introspecting abstract type? \nCode: `def f[T] = typeOf[T]`. \nError: `typeOf` requires T to be concrete or have TypeTag? `typeOf` macro requires known type at compile time. \nCode: `def g[T] = typeOf[T]`. \nError: No TypeTag available for T. \nReal Error: `WeakTypeTag` for abstract? \nCode: `def f[T](implicit tag: TypeTag[T])`. \nIf T is abstract (e.g. inside another generic method without context bound), `TypeTag` fails. usage of `WeakTypeTag` needed? \nCode: `class C[T] { def m = typeOf[T] }`. Error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_132_real",
        "title": "TypeOf generic erasure",
        "description": "Identify reflection.",
        "codeSnippet": "import scala.reflect.runtime.universe._\ndef get[T] = typeOf[T]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`typeOf[T]` requires `T` to be known at compile time or have a `TypeTag` in context. Pure generic `T` is erased.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_132",
        "title": "TypeOf context bound",
        "description": "True or False?",
        "codeSnippet": "import scala.reflect.runtime.universe._\ndef get[T: TypeTag] = typeOf[T]",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_133",
        "title": "PartialFunction orElse type",
        "description": "Identify typing.",
        "codeSnippet": "val f: PartialFunction[Int, Int] = { case 1 => 1 }\nval g: PartialFunction[Int, String] = { case 2 => \"2\" }\nval h = f orElse g",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "`orElse` combines partial functions. Return types must match (or LUB). `Int` vs `String` -> `Any`. `h` will be `PartialFunction[Int, Any]`. If assigned to `PartialFunction[Int, Int]`, it's an error. snippet implies inference `h`. `h(1)` is Int(1), `h(2)` is String(\"2\"). Valid but maybe not type safe usage intended. \nReal Error: `collect` with mismatched type. \nCode: `List(1).collect { case i: Int => \"s\" }` -> `List[String]`. \nCode: `List(1).collect(f)`. If f is `PF[Int, Int]`, result is `List[Int]`. \nReal Error: `unapplySeq` with fixed args return. \nCode: `def unapplySeq(x: Any): Option[(Int, Int)]`. \nError: unapplySeq must return `Option[Seq[T]]` or `Option[(T1, Seq[T2])]` etc. Fixed tuple is for `unapply`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_133_real",
        "title": "UnapplySeq return signature",
        "description": "Identify signature.",
        "codeSnippet": "object O { def unapplySeq(x: Any): Option[(Int, Int)] = Some((1, 2)) }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`unapplySeq` is used for variadic matching. It should return `Option[Seq[T]]`. Returning a fixed tuple `(Int, Int)` corresponds to `unapply`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_133",
        "title": "UnapplySeq valid",
        "description": "True or False?",
        "codeSnippet": "object O { def unapplySeq(x: Any): Option[Seq[Int]] = Some(List(1)) }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_134",
        "title": "Value class boxing",
        "description": "Identify performance.",
        "codeSnippet": "class Meter(val x: Int) extends AnyVal\nval m = new Meter(1)\nval list = List(m)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Valid, but triggers boxing. Arrays of value classes are optimized, but Lists are generic, so `m` is boxed. Performance warning in high-throughput loops.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_134",
        "title": "Value class allocation",
        "description": "True or False?",
        "codeSnippet": "class Wrapper(val x: Int) extends AnyVal\nval w = new Wrapper(1)\nval i = w.x",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. No allocation here (erased to Int).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_135",
        "title": "BitSet negative",
        "description": "Identify library.",
        "codeSnippet": "val b = scala.collection.immutable.BitSet(-1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`BitSet` can only contain non-negative integers. throws IllegalArgumentException.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_135",
        "title": "BitSet capacity",
        "description": "True or False?",
        "codeSnippet": "scala.collection.immutable.BitSet(1000)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_136",
        "title": "Stream cons strictness",
        "description": "Identify laziness.",
        "codeSnippet": "def loop: Int = loop\nval s = 1 #:: loop #:: Stream.empty",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. `#::` is by-name on right hand side. `loop` is not evaluated. \nError: `Stream.cons` strict? \nCode: `Stream.cons(1, loop)`. \nError: `cons` second arg is by-name. \nReal Error: `List` prepend by name? \nCode: `1 :: loop`. \nError: `::` takes arg by value. `loop` evaluates and hangs.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_136_real",
        "title": "List prepend strictness",
        "description": "Identify laziness.",
        "codeSnippet": "def crash: Int = throw new Exception\nval l = 1 :: crash :: Nil",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`::` (Cons) on List is strict. Arguments are evaluated eagerly. `crash` is evaluated, throwing exception.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_136",
        "title": "Stream append lazy",
        "description": "True or False?",
        "codeSnippet": "def crash: Int = throw new Exception\nval s = 1 #:: crash #:: Stream.empty",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. `#::` is lazy on RHS.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_137",
        "title": "For comprehension flatMap filter mismatch",
        "description": "Identify desugaring.",
        "codeSnippet": "for { x <- List(1); y = x + 1 } yield y",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `y =` is value definition. \nReal Error: `withFilter` missing? \nCode: `class C { def map[B](f: A=>B) = ... }; for(x <- new C; if x > 0) yield x`. \nError: `if` guard requires `withFilter` or `filter`. Method missing.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_137_real",
        "title": "Desugar filter requirement",
        "description": "Identify api.",
        "codeSnippet": "class Wrapper[A](val a: A) { def map[B](f: A=>B) = new Wrapper(f(a)) }\nfor (x <- new Wrapper(1); if x > 0) yield x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "For-comprehension with guard (`if`) desugars to `withFilter` (or `filter`). `Wrapper` does not define it.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_137",
        "title": "For yield map",
        "description": "True or False?",
        "codeSnippet": "class W[A](val a: A) { def map[B](f: A=>B) = new W(f(a)) }\nfor (x <- new W(1)) yield x + 1",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Map is sufficient.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_138",
        "title": "Abstract class implicit",
        "description": "Identify syntax.",
        "codeSnippet": "abstract class C { implicit val x: Int }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Abstract members can be implicit. Valid. \nError: `implicit` variable? `implicit var x = 1`. \nError: `implicit` cannot be `var`. Must be stable value (`val` or `object` or `def`).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_138_real",
        "title": "Implicit var",
        "description": "Identify syntax.",
        "codeSnippet": "implicit var x = 1",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`implicit` modifier is not allowed on `var`. Only `val`, `def`, `class`, `object`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_138",
        "title": "Implicit def",
        "description": "True or False?",
        "codeSnippet": "implicit def x = 1",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_139",
        "title": "Extractor pattern overlap",
        "description": "Identify logic.",
        "codeSnippet": "object P { def unapply(x: Int) = Some(x) }\n1 match { case P(1) => 1; case P(1) => 2 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Duplicate case pattern. Second case is unreachable. Compiler warning/error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_139",
        "title": "Extractor match",
        "description": "True or False?",
        "codeSnippet": "object Even { def unapply(x: Int) = if (x%2==0) Some(x) else None }\n2 match { case Even(n) => true }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_140",
        "title": "Try flatMap signature",
        "description": "Identify signature.",
        "codeSnippet": "import scala.util.Try\nTry(1).flatMap(x => x)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`flatMap` expects specific signature `A => Try[B]`. `x` is Int, not `Try[Int]`. Type mismatch.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_140",
        "title": "Try map",
        "description": "True or False?",
        "codeSnippet": "import scala.util.Try\nTry(1).map(x => x)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_141",
        "title": "Type alias override",
        "description": "Identify inheritance.",
        "codeSnippet": "trait A { type T = Int }\ntrait B extends A { override type T = String }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Type member `T` is defined as `Int` (concrete) in A. Cannot be overridden with incompatible type `String` in B unless separate or path dependent overrides logic (usually error for concrete aliases).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_141",
        "title": "Abstract type override",
        "description": "True or False?",
        "codeSnippet": "trait A { type T }\ntrait B extends A { type T = Int }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_142",
        "title": "Multiple inheritance conflict",
        "description": "Identify inheritance.",
        "codeSnippet": "class A { def f = 1 }\ntrait B { def f = 2 }\nclass C extends A with B",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 2,
        "explanation": "Class `C` inherits conflicting members `f` from class `A` and trait `B`. `A.f` is concrete. `B.f` is concrete. Ambiguity. Must override `f` in `C`.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_142",
        "title": "Override conflict resolution",
        "description": "True or False?",
        "codeSnippet": "class A { def f = 1 }\ntrait B { def f = 2 }\nclass C extends A with B { override def f = super[B].f }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_143",
        "title": "Implicit recursion limit",
        "description": "Identify compiler.",
        "codeSnippet": "implicit def listOrd[T](implicit ord: Ordering[List[T]]): Ordering[List[T]] = ord\nimplicitly[Ordering[List[Int]]]",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Diverging implicit expansion. `listOrd` asks for `Ordering[List[T]]` to produce `Ordering[List[T]]`. Infinite cycle.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_143",
        "title": "Implicit recursion valid",
        "description": "True or False?",
        "codeSnippet": "implicit def listOrd[T](implicit ord: Ordering[T]): Ordering[List[T]] = ??? // valid signature",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Inductive definition.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_144",
        "title": "ByName implicit",
        "description": "Identify syntax.",
        "codeSnippet": "def f(implicit x: => Int) = x",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "By-name implicit parameters `implicit x: => Int` are not allowed (or highly erratic/deprecated usage). Implicit resolution happens at call site value.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_144",
        "title": "Implicit function",
        "description": "True or False?",
        "codeSnippet": "implicit val f: String => Int = _.length\ndef g(implicit conv: String => Int) = conv(\"s\")",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_145",
        "title": "Private inheritance",
        "description": "Identify visibility.",
        "codeSnippet": "class A\nprivate class B extends A",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `sealed` trait extended by object in other file? Yes. \nReal Error: `case class` inheritance from `case class`? \nCode: `case class A(x:Int); case class B(y:Int) extends A(1)`. \nError: Forbidden (deprecation).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_145_real",
        "title": "Case class inheritance",
        "description": "Identify syntax.",
        "codeSnippet": "case class A(x: Int)\ncase class B(y: Int) extends A(y)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Inheriting from a case class `A` is deprecated/prohibited. Case classes should be leaves in the inheritance hierarchy to preserve equality contracts.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_145",
        "title": "Case class extends Trait",
        "description": "True or False?",
        "codeSnippet": "trait T; case class C(x: Int) extends T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_146",
        "title": "Return in lambda",
        "description": "Identify flow.",
        "codeSnippet": "def f(l: List[Int]): Int = {\n  l.foreach(x => if(x==0) return 0)\n  1\n}",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "`return` inside a lambda passed to `foreach` (which is inlined/high-order) implements non-local return using Exceptions. It's safe in `foreach` but dangerous (deprecated?) in `Future` or unknown context. Valid code but bad practice usually. Is it strict error? No. \nReal Error: `case` missing in partial function? \nCode: `val f: Int => Int = { x => x + 1 }`. Valid. \nCode: `val f: Int => Int = { case 1 => 2 }`. Valid. \nReal Error: `match` argument not found. \nCode: `1 match { case _ => }`. \nLet's go with `final` on trait.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_146_real",
        "title": "Final trait",
        "description": "Identify syntax.",
        "codeSnippet": "final trait T",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Traits cannot be `final` because they are meant to be mixed in/extended. (Objects and classes can be final).",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_146",
        "title": "Sealed trait",
        "description": "True or False?",
        "codeSnippet": "sealed trait T",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_147",
        "title": "Covariance mutable Set",
        "description": "Identify rules.",
        "codeSnippet": "val s: scala.collection.mutable.Set[Any] = scala.collection.mutable.Set[String]()",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Mutable collections are invariant. `Set[String]` is not a subtype of `Set[Any]`. Error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_147",
        "title": "Covariance immutable Set",
        "description": "True or False?",
        "codeSnippet": "val s: Set[Any] = Set[String]()",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True. Immutable Set is covariant.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_148",
        "title": "Abstract override position",
        "description": "Identify syntax.",
        "codeSnippet": "class C { abstract override def f = 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "`abstract override` can only be used in traits, not classes.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_148",
        "title": "Final definition",
        "description": "True or False?",
        "codeSnippet": "trait T { final def f = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_149",
        "title": "Map generic type",
        "description": "Identify syntax.",
        "codeSnippet": "val m: Map<Int, Int> = Map(1->1)",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 0,
        "explanation": "Scala uses `[]` for generics, not `<>`. Syntax error.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_149",
        "title": "Generic syntax",
        "description": "True or False?",
        "codeSnippet": "val l: List[Int] = List(1)",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_err_150",
        "title": "Private type alias",
        "description": "Identify visibility.",
        "codeSnippet": "class A { private type T = Int }\nclass B extends A { val x: T = 1 }",
        "type": "errorSpotting",
        "language": "scala",
        "errorLineIndex": 1,
        "explanation": "Type `T` is private in A. Not visible in subclass B.",
        "difficultyLevel": 3
    },
    {
        "id": "scala_tf_150",
        "title": "Protected type alias",
        "description": "True or False?",
        "codeSnippet": "class A { protected type T = Int }\nclass B extends A { val x: T = 1 }",
        "type": "trueOrFalse",
        "language": "scala",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    }
]