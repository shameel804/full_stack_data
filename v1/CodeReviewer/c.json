[
    {
        "id": "c_err_1",
        "title": "Uninitialized Variable",
        "description": "Identify potential undefined behavior.",
        "codeSnippet": "int main() {\n    int x;\n    printf(\"%d\", x);\n    return 0;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Variable `x` is used without initialization. Printing it results in undefined behavior (prints garbage value).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_1",
        "title": "Main Return Type",
        "description": "Is void main() standard?",
        "codeSnippet": "void main() { }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Standard C requires `main` to return `int` (e.g., `int main()`). `void main()` is a non-standard extension.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_2",
        "title": "Missing Semicolon",
        "description": "Identify syntax error.",
        "codeSnippet": "int x = 5\nint y = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Missing semicolon at the end of the declaration of `x`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_2",
        "title": "Multi-line Comment",
        "description": "Is /* ... */ valid?",
        "codeSnippet": "/* This is a \n   comment */",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `/* ... */` is the standard syntax for multi-line comments in C.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_3",
        "title": "Array Index Out of Bounds",
        "description": "Identify memory usage error.",
        "codeSnippet": "int arr[5];\narr[5] = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Array indices are 0-based. Valid indices for `arr[5]` are 0 to 4. Accessing `arr[5]` is out of bounds.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_3",
        "title": "Include Syntax",
        "description": "Is #include <stdio.h> correct?",
        "codeSnippet": "#include <stdio.h>",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, correct syntax to include the standard input/output header.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_4",
        "title": "Integer Division",
        "description": "Identify logic error.",
        "codeSnippet": "float f = 5 / 2;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Integer division `5 / 2` results in `2`. The result is then cast to float `2.0`, losing the decimal part. Use `5.0 / 2` or `(float)5 / 2`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_4",
        "title": "Scanf Address",
        "description": "Does scanf need &?",
        "codeSnippet": "int x; scanf(\"%d\", &x);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `scanf` requires the address of the variable to store the input.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_5",
        "title": "Pointer Declaration",
        "description": "Identify syntax confusion.",
        "codeSnippet": "int* p, q;\nq = &x; // x is int",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "In `int* p, q;`, `p` is a pointer to int, but `q` is just an `int`. Assigning address `&x` to `q` is a type mismatch (without cast) and logically wrong if pointer intended.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_5",
        "title": "String Literal Type",
        "description": "Is \"hello\" a char array?",
        "codeSnippet": "char *s = \"hello\";",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, string literals are arrays of characters (decay to char pointers), stored in read-only memory.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_6",
        "title": "Malloc cast",
        "description": "Identify type mismatch.",
        "codeSnippet": "int *p = malloc(10);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`malloc` allocates items in bytes. `malloc(10)` allocates 10 bytes, not 10 integers. Should be `malloc(10 * sizeof(int))`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_6",
        "title": "Null Pointer",
        "description": "Is numeric 0 valid null?",
        "codeSnippet": "int *p = 0;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, an integer constant expression with the value 0 is a null pointer constant.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_7",
        "title": "Comparison vs Assignment",
        "description": "Identify logical flaw.",
        "codeSnippet": "if (x = 5) {\n    printf(\"Equal\");\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Using assignment `=` instead of comparison `==`. This assigns 5 to x and evaluates to true (5), always executing the block.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_7",
        "title": "Sizeof Operator",
        "description": "Is sizeof compile-time?",
        "codeSnippet": "int s = sizeof(int);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `sizeof` is computed at compile-time (except for VLAs in C99).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_8",
        "title": "Dangling Pointer",
        "description": "Identify lifetime issue.",
        "codeSnippet": "int* f() {\n    int x = 10;\n    return &x;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Returning address of local variable `x`. `x` is destroyed when function returns, leaving the pointer dangling.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_8",
        "title": "Switch Fallthrough",
        "description": "Is break optional?",
        "codeSnippet": "switch(x) { case 1: print(\"1\"); default: print(\"2\"); }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, syntactically valid. Execution falls through from case 1 to default if x is 1.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_9",
        "title": "String Concatenation",
        "description": "Identify operator missing.",
        "codeSnippet": "char s[] = \"Hel\" + \"lo\";",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "C does not support `+` for string concatenation. Use `strcat` or adjacent string literals implicitly: `\"Hel\" \"lo\"`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_9",
        "title": "Break Keyword",
        "description": "Does break exit if?",
        "codeSnippet": "if (1) { break; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`break` is only valid inside loops (`for`, `while`, `do`) or `switch` statements. Cannot appear directly in `if`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_10",
        "title": "Const Modification",
        "description": "Identify violation.",
        "codeSnippet": "const int x = 5;\nx = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`x` is declared `const` (read-only). Assigning to it is a compiler error.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_10",
        "title": "For Loop Syntax",
        "description": "Is for(;;) valid?",
        "codeSnippet": "for(;;) {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, this creates an infinite loop.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_11",
        "title": "Structure Declaration",
        "description": "Identify missing semicolon.",
        "codeSnippet": "struct Point {\n    int x, y;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Struct declarations must end with a semicolon.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_11",
        "title": "Typedef Syntax",
        "description": "Is typedef valid?",
        "codeSnippet": "typedef unsigned long ulong;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, defines `ulong` as an alias for `unsigned long`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_12",
        "title": "Void Pointer Arith",
        "description": "Identify standard violation.",
        "codeSnippet": "void *p;\np++;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Arithmetic on `void*` is not defined in standard C because `void` has unknown size. (GCC supports it as an extension, treating as char*, but it's non-standard).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_12",
        "title": "Boolean Type",
        "description": "Is bool native in C89?",
        "codeSnippet": "bool b = true;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "C89 has no `bool`. C99 added `_Bool` and `<stdbool.h>` which defines `bool` macro.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_13",
        "title": "Function Prototype Mismatch",
        "description": "Identify argument error.",
        "codeSnippet": "void f(int x);\n// ...\nf(5, 10);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Function `f` expects 1 argument `int`. Called with 2 arguments.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_13",
        "title": "Modulus Operator",
        "description": "Works on floats?",
        "codeSnippet": "float r = 5.5 % 2;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "The modulus operator `%` works only with integer operands.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_14",
        "title": "Macro Semicolon",
        "description": "Identify expansion error.",
        "codeSnippet": "#define SIZE 10;\nint arr[SIZE];",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Macro expands to `int arr[10;];` due to the semicolon in `#define`, causing a syntax error.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_14",
        "title": "Do While Loop",
        "description": "Does it run once?",
        "codeSnippet": "do { x++; } while(0);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `do-while` loops always execute the body at least once.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_15",
        "title": "Unterminated String",
        "description": "Identify syntax error.",
        "codeSnippet": "char *s = \"Hello world;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "String literal is missing the closing quote `\"`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_15",
        "title": "Ternary Operator",
        "description": "Is ?: valid?",
        "codeSnippet": "int m = (a > b) ? a : b;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, standard conditional operator.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_16",
        "title": "Printf Format Mismatch",
        "description": "Identify type mismatch.",
        "codeSnippet": "double d = 3.14;\nprintf(\"%d\", d);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`%d` expects `int`. Passing `double` leads to undefined behavior (often prints valid-looking garbage). Use `%f` or `%lf`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_16",
        "title": "Main No Arguments",
        "description": "Is int main(void) valid?",
        "codeSnippet": "int main(void) {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, explicitly declaring no arguments.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_17",
        "title": "Re-declaration",
        "description": "Identify scope error.",
        "codeSnippet": "int x = 5;\nint x = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Variable `x` is already declared in the same scope. Cannot redefine.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_17",
        "title": "Goto usage",
        "description": "Is goto valid?",
        "codeSnippet": "goto label;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `goto` is a valid keyword in C (though often discouraged).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_18",
        "title": "Bitwise OR usage",
        "description": "Identify syntax/logic.",
        "codeSnippet": "if (ptr | NULL) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Bitwise OR `|` between pointer and NULL (likely 0) is invalid operand types (pointer bitwise). Even if 0, result of pointer | int is often error without cast. Logic likely meant `!=` or `||`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_18",
        "title": "Increment Operator",
        "description": "Is i++ valid?",
        "codeSnippet": "i++;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, post-increment.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_19",
        "title": "Include Quotes",
        "description": "Identify missing file.",
        "codeSnippet": "#include \"stdio.h\"",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Actually valid syntax. Quotes search local dirs first, then system. Usually `<>` for system headers but `\"\"` works. \nError: `#include <stdio>` (missing .h in C).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_19_real",
        "title": "Include Extension",
        "description": "Identify missing extension.",
        "codeSnippet": "#include <stdio>",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "C standard library headers have `.h` extension (e.g., `<stdio.h>`). `<stdio>` is C++.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_19",
        "title": "Char Literal",
        "description": "Is 'A' an int?",
        "codeSnippet": "int size = sizeof('A');",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "In C, character literals like `'A'` have type `int`, so `sizeof('A')` is `sizeof(int)` (usually 4). In C++, it's `sizeof(char)` (1).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_20",
        "title": "Reserved Keyword",
        "description": "Identify naming error.",
        "codeSnippet": "int while = 5;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`while` is a reserved keyword, cannot be used as variable name.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_20",
        "title": "Global Variable",
        "description": "Is global init 0?",
        "codeSnippet": "int global_x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, global (static storage duration) variables are initialized to 0 by default.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_21",
        "title": "Call main recursively",
        "description": "Identify standard compliance.",
        "codeSnippet": "int main() { main(); }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Actually valid in C. Allowed to call `main` recursively. \nError: `main` calling with args (if main has args)?\nLet's choose a better error. Function definition inside function.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_21_real",
        "title": "Nested Function",
        "description": "Identify syntax error.",
        "codeSnippet": "void f() {\n   void g() {} \n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Standard C does not support nested functions (defining a function inside another). (GCC supports as extension).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_21",
        "title": "Static Local",
        "description": "Is static retained?",
        "codeSnippet": "void f() { static int x = 0; x++; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `static` local variable retains value between calls.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_22",
        "title": "Modulo Zero",
        "description": "Identify runtime error.",
        "codeSnippet": "int x = 5 % 0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Modulo by zero is undefined behavior (crash).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_22",
        "title": "Register Keyword",
        "description": "Is register valid?",
        "codeSnippet": "register int x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, hints compiler to store in register (cannot take address of it). Deprecated in C++17, but valid in C.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_23",
        "title": "Assignment in Conditional",
        "description": "Identify warning.",
        "codeSnippet": "if (x = 0) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Assignment `x=0` evaluates to 0 (false). Body never runs. Compiler usually warns as comparison `==` likely intended.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_23",
        "title": "Unsigned Negative",
        "description": "Is assignment valid?",
        "codeSnippet": "unsigned int x = -1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, assignment wraps around (becomes UINT_MAX).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_24",
        "title": "Char Single Quotes",
        "description": "Identify syntax.",
        "codeSnippet": "char c = \"A\";",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`\"A\"` is a string literal (char pointer), `c` is a char. Assigning pointer to char. Use single quotes: `'A'`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_24",
        "title": "Enum default values",
        "description": "Does it start at 0?",
        "codeSnippet": "enum { A, B };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, first enumerator is 0 by default, next is 1.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_25",
        "title": "Missing Return Value",
        "description": "Identify function type.",
        "codeSnippet": "int f() { \n    return;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Function declared with `int` return type must return a value.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_25",
        "title": "Comma Operator",
        "description": "Is x = (1, 2) valid?",
        "codeSnippet": "int x = (1, 2);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, comma operator evaluates operands left-to-right, result is the right operand. `x` becomes 2.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_26",
        "title": "Float Equality",
        "description": "Identify precision issue.",
        "codeSnippet": "float f = 0.1;\nif (f == 0.1) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`0.1` is a double literal. `f` is float. `0.1` cannot be exactly represented. Comparing float `f` with double `0.1` often fails. Use epsilon or `0.1f`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_26",
        "title": "Continue Keyword",
        "description": "Skips loop iteration?",
        "codeSnippet": "for(i=0;i<10;i++) { if(i==5) continue; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `continue` skips the rest of the loop body and proceeds to the next iteration (increment step).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_27",
        "title": "Uninitialized Pointer value",
        "description": "Identify safety.",
        "codeSnippet": "int *p;\n*p = 5;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Pointer `p` is uninitialized (wild pointer). Dereferencing it causes undefined behavior (crash or corruption).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_27",
        "title": "Short Circuit OR",
        "description": "Does || skip?",
        "codeSnippet": "if (1 || func()) {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, logic OR `||` short-circuits. If left operand is true, right operand `func()` is NOT executed.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_28",
        "title": "Invalid Identifier",
        "description": "Identify naming rule.",
        "codeSnippet": "int 2ndVar = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Identifiers cannot start with a digit.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_28",
        "title": "Pre-processor logical",
        "description": "Is #if defined valid?",
        "codeSnippet": "#if defined(MACRO)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, checks if MACRO is defined.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_29",
        "title": "Const Pointer Assignment",
        "description": "Identify constness.",
        "codeSnippet": "int x = 5;\nint * const p = &x;\np++;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "`p` is a const pointer (pointer itself is const). Cannot increment/change the pointer address.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_29",
        "title": "Arrow Operator",
        "description": "Is ptr->member valid?",
        "codeSnippet": "struct A { int x; } a; struct A* p = &a; p->x = 1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `->` is used to access members via a pointer.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_30",
        "title": "Octal Literal Confusion",
        "description": "Identify value.",
        "codeSnippet": "int x = 010;\nif (x == 10) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`010` is octal (base 8), decimal value 8. `8 == 10` is false.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_30",
        "title": "Function Pointer Syntax",
        "description": "Is declaration valid?",
        "codeSnippet": "void (*f)(int);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, declares a pointer `f` to a function taking `int` and returning `void`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_31",
        "title": "Break outside loop",
        "description": "Identify context error.",
        "codeSnippet": "void f() {\n    if (1) break;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`break` cannot be used inside an `if` statement unless that `if` is inside a loop or switch.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_31",
        "title": "Unsigned Char",
        "description": "Is unsigned char valid?",
        "codeSnippet": "unsigned char c = 255;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, standard type guaranteed to hold 0 to at least 255.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_32",
        "title": "Else without If",
        "description": "Identify structure error.",
        "codeSnippet": "else {\n    printf(\"Error\");\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`else` must be preceded by an `if` block.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_32",
        "title": "Static Global",
        "description": "Is static global private?",
        "codeSnippet": "static int g_var;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `static` on a global variable limits its scope (linkage) to the current translation unit (file).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_33",
        "title": "Mismatched Braces",
        "description": "Identify syntax.",
        "codeSnippet": "int main() {\n    if (1) {\n        return 0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Missing closing braces `}` for `if` and `main`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_33",
        "title": "Auto Keyword C",
        "description": "Is auto type deduction?",
        "codeSnippet": "auto int x = 5;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "In C (before C23), `auto` is a storage class specifier (automatic storage), not type deduction. Usage `auto int x` is valid legacy C.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_34",
        "title": "Variable Length Array Init",
        "description": "Identify limitation.",
        "codeSnippet": "int n = 5;\nint arr[n] = {1, 2, 3};",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Variable Length Arrays (VLAs) cannot be initialized in the declaration.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_34",
        "title": "Nullptr C",
        "description": "Is nullptr in C?",
        "codeSnippet": "int *p = nullptr;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`nullptr` is C++ (and C23). Pre-C23 C uses `NULL` or `0`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_35",
        "title": "Struct Member Access",
        "description": "Identify operator.",
        "codeSnippet": "struct A { int x; } a;\na->x = 5;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`a` is a value, not a pointer. Use dot operator: `a.x`. `->` is for pointers.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_35",
        "title": "Volatile Keyword",
        "description": "Is volatile C?",
        "codeSnippet": "volatile int x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, prevents compiler optimization on the variable.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_36",
        "title": "Array Function Param",
        "description": "Identify sizeof misconception.",
        "codeSnippet": "void f(int a[10]) {\n    if (sizeof(a) == 40) {}\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Array parameter `a` decays to pointer. `sizeof(a)` returns pointer size (e.g. 8 bytes), not 40.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_36",
        "title": "Extern storage",
        "description": "Is extern valid?",
        "codeSnippet": "extern int x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, declares `x` is defined elsewhere.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_37",
        "title": "Empty Char Literal",
        "description": "Identify syntax.",
        "codeSnippet": "char c = '';",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Empty character constant `''` is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_37",
        "title": "Union Size",
        "description": "Is union size sum?",
        "codeSnippet": "union U { int i; double d; };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes valid. Size of union is size of largest member (plus padding), not sum.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_38",
        "title": "Address of Register",
        "description": "Identify restriction.",
        "codeSnippet": "register int x;\nint *p = &x;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Cannot take the address `&` of a `register` variable.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_38",
        "title": "Enumerated Type",
        "description": "Can enum be negative?",
        "codeSnippet": "enum { A = -1 };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, enumerators can be negative.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_39",
        "title": "String Literal Write",
        "description": "Identify segfault.",
        "codeSnippet": "char *s = \"Hello\";\ns[0] = 'h';",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Modifying a string literal results in undefined behavior (usually segmentation fault on modern systems).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_39",
        "title": "Int Literal Type",
        "description": "Is 10L long?",
        "codeSnippet": "long x = 10L;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `L` suffix specifies `long` type.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_40",
        "title": "Conflicting Types",
        "description": "Identify signature mismatch.",
        "codeSnippet": "void f(int x);\nvoid f(float x) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Function `f` declared taking `int` but defined taking `float`. Conflicting types (and no overloading in C).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_40",
        "title": "Implicit Int",
        "description": "Is implicit int valid C99?",
        "codeSnippet": "f() { return 0; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Implicit return type `int` was removed in C99. Must specify `int f()`.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_41",
        "title": "Divide by Zero Float",
        "description": "Identify checking.",
        "codeSnippet": "float f = 1.0 / 0.0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Division by zero. Standard undefined behavior, though many implementations produce Infinity.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_41",
        "title": "Macro Args",
        "description": "Arguments valid?",
        "codeSnippet": "#define MAX(a,b) ((a)>(b)?(a):(b))",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, correct macro definition with parentheses protection.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_42",
        "title": "Return Static Address",
        "description": "Identify safety.",
        "codeSnippet": "int* f() { static int x; return &x; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid. Static variable persists after function return. Pointer is safe. \nError: `return &x` where x is NOT static (auto).",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_42_real",
        "title": "Auto Return Addr",
        "description": "Identify dangling.",
        "codeSnippet": "int* f() { int x; return &x; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Returning address of automatic local variable `x`. Dangling pointer.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_42",
        "title": "Restrict Keyword",
        "description": "Is restrict valid C99?",
        "codeSnippet": "void f(int * restrict p);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `restrict` added in C99 for optimization hinting.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_43",
        "title": "Void Function Return",
        "description": "Identify syntax error.",
        "codeSnippet": "void f() { return 5; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Void function cannot return a value.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_43",
        "title": "Inline Function",
        "description": "Is inline valid C99?",
        "codeSnippet": "inline void f() {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `inline` keyword added in C99.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_44",
        "title": "Bad Char Escape",
        "description": "Identify syntax.",
        "codeSnippet": "char c = '\\q';",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`\\q` is not a valid escape sequence. (Valid: \\n, \\t, \\', etc).",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_44",
        "title": "Block Scope",
        "description": "Variables in blocks?",
        "codeSnippet": "void f() { { int x; } }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, blocks introduce new scope.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_45",
        "title": "Case Range GNU",
        "description": "Identify extension.",
        "codeSnippet": "case 1 ... 5:",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Case ranges `1 ... 5` are a GCC extension, not standard C. Standard uses individual cases.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_45",
        "title": "Compound Literal",
        "description": "Is (type){val} valid?",
        "codeSnippet": "int *p = (int[]){1, 2};",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, compound literals introduced in C99.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_46",
        "title": "Assign to Array",
        "description": "Identify type restriction.",
        "codeSnippet": "int a[5], b[5];\na = b;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Arrays are not assignable. Must use `memcpy` or loop.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_46",
        "title": "Static Assert C11",
        "description": "Is _Static_assert valid?",
        "codeSnippet": "_Static_assert(1, \"fail\");",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Static_assert` introduced in C11.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_47",
        "title": "Dereference Void Pointer",
        "description": "Identify type error.",
        "codeSnippet": "void *p; *p;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Cannot dereference `void*`. Unknown size/type. Cast to valid pointer type (e.g., `*(int*)p`) first.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_47",
        "title": "Generic Selection",
        "description": "Is _Generic C11?",
        "codeSnippet": "_Generic(x, int: 1, default: 0)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Generic` generic selection added in C11.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_48",
        "title": "Sizeof Function Type",
        "description": "Identify invalid op.",
        "codeSnippet": "sizeof(void)",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`sizeof(void)` is undefined/invalid in standard C (`void` has no size). GCC allows as 1.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_48",
        "title": "Standard Headers",
        "description": "Is stdlib.h standard?",
        "codeSnippet": "#include <stdlib.h>",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_49",
        "title": "Function Redefinition",
        "description": "Identify collision.",
        "codeSnippet": "void f() {} \nvoid f() {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Function `f` defined twice. Multiple definitions.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_49",
        "title": "Const Int Size",
        "description": "Is const size fixed?",
        "codeSnippet": "const int n = 5; int a[n];",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "In C99+, this is valid (Variable Length Array). In C89, invalid (array size must be integral constant expression, and `const int` is not constant expression in C89, unlike C++). Assuming C99/modern C, True.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_50",
        "title": "Too Many Initializers",
        "description": "Identify bounds.",
        "codeSnippet": "int a[2] = {1, 2, 3};",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Excess elements in array initializer. `a` has size 2, but 3 checkers provided.",
        "difficultyLevel": 1
    },
    {
        "id": "c_tf_50",
        "title": "Char pointer diff",
        "description": "Is ptr diff defined?",
        "codeSnippet": "char *p1, *p2; long d = p1 - p2;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, pointer subtraction is valid (returns `ptrdiff_t`), assuming they point to same array object.",
        "difficultyLevel": 1
    },
    {
        "id": "c_err_51",
        "title": "Flexible Array Member",
        "description": "Identify struct layout.",
        "codeSnippet": "struct S { int n; char arr[]; };\nstruct S s;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Structs with flexible array members (C99) cannot be instantiated directly as automatic/static variables if you intend to use the array. `s.arr` has 0 size. Must allocate structurally with malloc: `malloc(sizeof(struct S) + size)`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_51",
        "title": "Anonymous Struct",
        "description": "Is valid C11?",
        "codeSnippet": "struct { int x; };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C11 standardizes anonymous structs/unions (especially nested). As top level it declares nothing.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_52",
        "title": "Goto skipping init",
        "description": "Identify scope issue.",
        "codeSnippet": "goto label;\nint x = 5;\nlabel: printf(\"%d\", x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Jumping over variable initialization is allowed in C (unlike C++ which forbids it). However, using `x` which is uninitialized (because init was skipped) is undefined behavior logic error.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_52",
        "title": "Designated Initializer",
        "description": "Is .member valid?",
        "codeSnippet": "struct A { int x, y; };\nstruct A a = { .y = 2, .x = 1 };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, designated initializers introduced in C99.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_53",
        "title": "Memcpy Overlap",
        "description": "Identify UB.",
        "codeSnippet": "char s[] = \"hello\";\nmemcpy(s+1, s, 3);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Source and destination regions overlap. `memcpy` behavior is undefined. Use `memmove`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_53",
        "title": "Variable Array Size",
        "description": "Can static array be variable?",
        "codeSnippet": "void f(int n) { static int a[n]; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Static storage duration objects must have constant size. VLAs must be automatic storage.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_54",
        "title": "Alignof usage",
        "description": "Identify C standard.",
        "codeSnippet": "size_t a = alignof(int);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`alignof` is C++ keyword. In C11, it is `_Alignof`. (`<stdalign.h>` defines `alignof` macro). Without header/C11, invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_54",
        "title": "Thread Local",
        "description": "Is _Thread_local C11?",
        "codeSnippet": "_Thread_local int x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Thread_local` is the C11 keyword for thread-local storage.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_55",
        "title": "Restrict on non-pointer",
        "description": "Identify semantics.",
        "codeSnippet": "int restrict x;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`restrict` qualifier can only be applied to pointers.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_55",
        "title": "Atomic Type",
        "description": "Is _Atomic C11?",
        "codeSnippet": "_Atomic int counter;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Atomic` type specifier added in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_56",
        "title": "Const parameter mod",
        "description": "Identify signature.",
        "codeSnippet": "void f(const int *p) { *p = 0; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`p` points to const int. `*p = 0` attempts to modify read-only location.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_56",
        "title": "Complex number",
        "description": "Is _Complex C99?",
        "codeSnippet": "double _Complex z = 1.0 + 2.0 * I;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C99 introduced complex number support.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_57",
        "title": "Inline Static separation",
        "description": "Identify linkage.",
        "codeSnippet": "inline void f();\nvoid f() {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Inline function without `static` or `extern` in C99 has strange linkage rules (keeps definition available but may not emit body unless extern used elsewhere?). Actually, if a function is declared `inline`, it must be defined in the same translation unit. If strictly `inline`, it might not be callable from other units. C inline rules are complex. A simpler error: `inline` not supported in C89?",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_57_real",
        "title": "Switch Case Duplicate",
        "description": "Identify logic.",
        "codeSnippet": "switch(x) { case 1: break; case 1: break; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Duplicate case label `1`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_57",
        "title": "Typedef Redefinition",
        "description": "Is valid C11?",
        "codeSnippet": "typedef int T; typedef int T;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C11 allows benign typedef redefinition to the same type.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_58",
        "title": "Void Pointer Arithmetic Explicit",
        "description": "Identify standard.",
        "codeSnippet": "void *a, *b; int d = b - a;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Pointer subtraction requires pointers to object types. `void` is incomplete type. `b-a` is invalid in standard C.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_58",
        "title": "Main Recursion",
        "description": "Can main be called?",
        "codeSnippet": "int main() { return main(); }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `main` is a normal function in C (unlike C++ where calling main is forbidden).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_59",
        "title": "Sizeof flexible array",
        "description": "Identify size.",
        "codeSnippet": "struct S { int n; char a[]; };\nint s = sizeof(struct S);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`sizeof` ignores the flexible array member. `s` will be equal to `sizeof(int)` (plus padding). Not an error per se, but if expecting size with array, logic error. Let's find syntax error.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_59_real",
        "title": "Flexible Array not last",
        "description": "Identify struct rule.",
        "codeSnippet": "struct S { char a[]; int n; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Flexible array member `a[]` must be the last member of the struct.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_59",
        "title": "Printf %zu",
        "description": "Is %zu for size_t?",
        "codeSnippet": "size_t s = 10; printf(\"%zu\", s);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `%zu` introduced in C99 for `size_t`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_60",
        "title": "Comparison of Structs",
        "description": "Identify op availability.",
        "codeSnippet": "struct A { int x; } a, b;\nif (a == b) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Structure types do not support strict comparison using `==`. Must compare members individually or use `memcmp` (with padding caution).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_60",
        "title": "Bool Macro",
        "description": "Is true/false defined?",
        "codeSnippet": "#include <stdbool.h>\nbool b = false;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `<stdbool.h>` defines `bool`, `true`, and `false`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_61",
        "title": "Null char constant",
        "description": "Identify value.",
        "codeSnippet": "char c = 0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid. Sets char to null terminator. \nError: `char *s = 0; s[0];`",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_61_real",
        "title": "Call via uninit pointer",
        "description": "Identify safety.",
        "codeSnippet": "void (*f)(void);\nf();",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Calling function via uninitialized pointer `f`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_61",
        "title": "Pragma operator",
        "description": "Is _Pragma C99?",
        "codeSnippet": "_Pragma(\"once\")",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Pragma` operator introduced in C99 as alternative to `#pragma` directive.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_62",
        "title": "Macro Recursion",
        "description": "Identify expansion.",
        "codeSnippet": "#define FOO FOO\nint x = FOO;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Macro self-reference is not expanded recursively. `FOO` expands to `FOO`. `int x = FOO;` results in syntax error (symbol `FOO` not defined as variable).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_62",
        "title": "Alignas C11",
        "description": "Is _Alignas valid?",
        "codeSnippet": "_Alignas(16) int x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Alignas` introduced in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_63",
        "title": "Variadic Macro args",
        "description": "Identify mismatch.",
        "codeSnippet": "#define LOG(...) printf(__VA_ARGS__)\nLOG();",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Empty arguments for `...` is not allowed in C99 (must be at least one token). Allowed in C++20 or with GCC extension (`##__VA_ARGS__`). C standard violation.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_63",
        "title": "Floating Hex Literal",
        "description": "Is 0x1.fp1 valid?",
        "codeSnippet": "double d = 0x1.fp1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, hexadecimal floating-point literals introduced in C99.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_64",
        "title": "Bitfield Width",
        "description": "Identify size error.",
        "codeSnippet": "struct S { int x : 33; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Bitfield width `33` exceeds width of type `int` (usually 32). Implementation defined or error.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_64",
        "title": "NoReturn function",
        "description": "Is _Noreturn C11?",
        "codeSnippet": "_Noreturn void exit(int);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Noreturn` specifier added in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_65",
        "title": "Realloc pointer",
        "description": "Identify leak.",
        "codeSnippet": "int *p = malloc(10);\np = realloc(p, 20);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "If `realloc` fails (returns NULL), the original pointer `p` is lost (memory leak). Should assign to temporary `tmp = realloc(...)` first.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_65",
        "title": "Idempotent Const",
        "description": "Is const const int valid?",
        "codeSnippet": "const const int x = 5;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, Duplicate type qualifiers are allowed (and ignored) in C.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_66",
        "title": "Function Returning Array",
        "description": "Identify type error.",
        "codeSnippet": "int[] f() { int a[5]; return a; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Functions cannot return an array type `int[]`. Can return pointer `int*`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_66",
        "title": "Static Assert Message",
        "description": "Is message required?",
        "codeSnippet": "_Static_assert(1);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "In C11, the message argument is mandatory. _Static_assert(expr, msg). C23 makes it optional.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_67",
        "title": "Shift greater than width",
        "description": "Identify ub.",
        "codeSnippet": "int x = 1; int y = x << 32;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Shifting by >= width of type (32 for int typically) is undefined behavior.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_67",
        "title": "Null pointer constant",
        "description": "Is (void*)0 valid null?",
        "codeSnippet": "int* p = (void*)0;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `(void*)0` is a null pointer constant definition.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_68",
        "title": "Union Initialization",
        "description": "Identify ambiguity.",
        "codeSnippet": "union U { int i; float f; };\nunion U u = { 1 };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Initializes the *first* member `i`. This is valid. \nError: `union U u = { 1, 2.0 };`",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_68_real",
        "title": "Union Multiple Init",
        "description": "Identify syntax.",
        "codeSnippet": "union U { int i; float f; };\nunion U u = { 1, 2.0 };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Can only initialize one member of a union (the first one, unless designated).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_68",
        "title": "Unicode Literal",
        "description": "Is u8 string valid?",
        "codeSnippet": "char *s = u8\"text\";",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `u8` prefix for UTF-8 string literals introduced in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_69",
        "title": "Array Decaying Size",
        "description": "Identify sizeof misuse.",
        "codeSnippet": "int a[10]; int *p = a;\nif (sizeof(p) == sizeof(a)) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`p` is pointer (size 4/8), `a` is array (size 40). Comparison valid but logic likely wrong.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_69",
        "title": "Wide Char",
        "description": "Is wchar_t standard?",
        "codeSnippet": "#include <stddef.h>\nwchar_t w = L'A';",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, wide characters stored in `wchar_t`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_70",
        "title": "Typedef Scope",
        "description": "Identify scope.",
        "codeSnippet": "void f() { typedef int T; }\nT x;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`T` is defined inside `f` block scope. Not visible outside.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_70",
        "title": "Sizeof Expr Evaluation",
        "description": "Does operand run?",
        "codeSnippet": "int i=0; sizeof(i++);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Code is correct, but side effect `i++` is NOT evaluated because `sizeof` operand is not evaluated (unless VLA).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_71",
        "title": "Const Cast",
        "description": "Identify keyword.",
        "codeSnippet": "const int x = 5;\nint *p = const_cast<int*>(&x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`const_cast` is C++. In C, use `(int*)&x`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_71",
        "title": "For loop decl C99",
        "description": "Is for(int i..) valid?",
        "codeSnippet": "for (int i=0; i<10; i++) {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, loop declaration allowed in C99.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_72",
        "title": "Char signedness",
        "description": "Identify assumption.",
        "codeSnippet": "char c = 255;\nif (c == 255) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Whether `char` is signed or unsigned is implementation defined. If signed (range -128 to 127), `255` becomes `-1`. Comparison fails.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_72",
        "title": "Unsequenced Mod",
        "description": "Is i = ++i + 1 undefined?",
        "codeSnippet": "i = ++i + 1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Undefined behavior due to unsequenced modification of `i`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_73",
        "title": "String Literal Mod via pointer",
        "description": "Identify UB.",
        "codeSnippet": "char *p = \"str\"; *p = 'S';",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Modifying string literal via pointer is UB.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_73",
        "title": "Struct Padding",
        "description": "Can have holes?",
        "codeSnippet": "struct A { char c; int i; };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler adds padding between `c` and `i` for alignment.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_74",
        "title": "Pointer Diff Type",
        "description": "Identify type.",
        "codeSnippet": "int a[10]; int *p = a; \nunsigned int d = &a[5] - p;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Pointer difference result type is `ptrdiff_t` (signed integer). Assigning to `unsigned` might be mismatched semantics but valid C. Error: logic? No. \nReal Error: `void*` arithmetic again?",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_74_real",
        "title": "Function Param Pointer Decay",
        "description": "Identify array vs pointer.",
        "codeSnippet": "void f(int a[5]) { a++; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Valid! Array parameter decays to pointer, so `a` is `int*` (variable). Can be incremented. \nError: `int a[5]; a++;` (local array name is constant address).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_74",
        "title": "Timespec",
        "description": "Is timespec C11?",
        "codeSnippet": "struct timespec ts;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, standardized in C11 (from POSIX).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_75",
        "title": "Implicit Float double",
        "description": "Identify constant type.",
        "codeSnippet": "float f = 3.14;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`3.14` is `double`. Assignment to `float` causes implicit truncation/demotion warning. (Not strictly error, but precision mismatch).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_75",
        "title": "Quick Exit",
        "description": "Is quick_exit C11?",
        "codeSnippet": "quick_exit(0);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `quick_exit` added in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_76",
        "title": "Use of gets",
        "description": "Identify vulnerability.",
        "codeSnippet": "char buf[10];\ngets(buf);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`gets` is unsafe (buffer overflow vulnerability) and removed in C11. Use `fgets`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_76",
        "title": "C11 Threads",
        "description": "Is threads.h standard?",
        "codeSnippet": "#include <threads.h>\nthrd_t t;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `<threads.h>` allows optional threading support in C11.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_77",
        "title": "Variable Shadowing Logic",
        "description": "Identify logic error.",
        "codeSnippet": "int x = 10;\nif (1) { int x = 5; }\nprintf(\"%d\", x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Inner `x` shadows outer `x`. Changes to inner `x` (init to 5) are lost. Prints 10, which might be unintended.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_77",
        "title": "Struct Assignment",
        "description": "Is a = b valid?",
        "codeSnippet": "struct S { int a[10]; } s1, s2;\ns1 = s2;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, structs are assignable (performs shallow copy of members, including arrays inside).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_78",
        "title": "Invalid Free",
        "description": "Identify heap error.",
        "codeSnippet": "int x;\nfree(&x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Attempting to `free` a stack variable (not allocated via `malloc/calloc`). Crashes.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_78",
        "title": "VLA Parameter",
        "description": "Is int a[n] argument valid?",
        "codeSnippet": "void f(int n, int a[n]);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, VLA syntax in function parameters is valid C99.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_79",
        "title": "Wrong format double scanf",
        "description": "Identify format.",
        "codeSnippet": "double d;\nscanf(\"%f\", &d);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`%f` in `scanf` reads a `float`. For `double`, must use `%lf`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_79",
        "title": "Const Pointer to Const",
        "description": "Is const int * const valid?",
        "codeSnippet": "const int x = 1;\nconst int * const p = &x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, constant pointer to constant integer.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_80",
        "title": "Strcpy overflow",
        "description": "Identify buffer overflow.",
        "codeSnippet": "char dest[5];\nstrcpy(dest, \"Hello\");",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`\"Hello\"` is 6 bytes (including null). `dest` is 5 bytes. Overflow.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_80",
        "title": "Generic default",
        "description": "Is default valid in _Generic?",
        "codeSnippet": "_Generic(x, default: 0)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `default` handles unmatched types.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_81",
        "title": "Scanf string limit",
        "description": "Identify safety.",
        "codeSnippet": "char s[10];\nscanf(\"%s\", s);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`%s` without field width limits allows buffer overflow. Should be `%9s`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_81",
        "title": "Function returning struct",
        "description": "Is return valid?",
        "codeSnippet": "struct S { int x; }; struct S f() { struct S s; return s; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, functions can return structs by value.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_82",
        "title": "Pointer comparison distinct objects",
        "description": "Identify UB.",
        "codeSnippet": "int a, b;\nif (&a < &b) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Comparing pointers to distinct objects (not members of same array/struct) using relational operators `<` is undefined behavior.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_82",
        "title": "Static Inline",
        "description": "Is static inline valid?",
        "codeSnippet": "static inline void f() {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, common pattern for header-only functions in C.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_83",
        "title": "Missing Case Break",
        "description": "Identify logic.",
        "codeSnippet": "case 1: \n    x = 1;\ncase 2:",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Missing `break` causes fallthrough to `case 2`, executing its code as well (often bug).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_83",
        "title": "Noreturn header",
        "description": "Is stdnoreturn.h standard?",
        "codeSnippet": "#include <stdnoreturn.h>\nnoreturn void f();",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, defines `noreturn` macro for `_Noreturn`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_84",
        "title": "Double Free",
        "description": "Identify corruption.",
        "codeSnippet": "free(p);\nfree(p);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Freeing the same pointer twice causes memory corruption/abort.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_84",
        "title": "Imaginary Macro",
        "description": "Is _Imaginary supported?",
        "codeSnippet": "double _Imaginary i = 2.0 * I;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "It specifies an imaginary type. Support is optional in C99/C11 implementations.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_85",
        "title": "Unsequenced modification",
        "description": "Identify UB.",
        "codeSnippet": "int i = 0;\nf(i++, i++);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Order of argument evaluation is unspecified. Modifying `i` twice without sequence point is undefined behavior.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_85",
        "title": "Sizeof VLA",
        "description": "Is runtime evaluated?",
        "codeSnippet": "int n=10; int a[n]; int s = sizeof(a);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, for VLAs, `sizeof` is evaluated at runtime.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_86",
        "title": "Calloc args swap",
        "description": "Identify API usage.",
        "codeSnippet": "int *p = calloc(sizeof(int), 10);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`calloc` signature is `(num, size)`. Swapped args technically work (same product) but semantic violation.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_86",
        "title": "Struct Member Offset",
        "description": "Is offsetof standard?",
        "codeSnippet": "size_t o = offsetof(struct S, m);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `offsetof` in `<stddef.h>` return byte offset.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_87",
        "title": "Const Struct Pointer Member Mod",
        "description": "Identify const.",
        "codeSnippet": "struct S { int x; };\nconst struct S *p = &s;\np->x = 5;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Pointer `p` treats struct as constant. Cannot modify member `x`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_87",
        "title": "Unreachable Macro",
        "description": "Is unreachable C23?",
        "codeSnippet": "unreachable();",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `unreachable()` is standard in C23 (in `<stddef.h>`). Before that, compiler specific.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_88",
        "title": "Unsigned wrap assumption",
        "description": "Identify logic.",
        "codeSnippet": "for (unsigned i = 10; i >= 0; i--) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Unsigned `i` is always >= 0. Loop is infinite (`0 - 1` wraps to huge value).",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_88",
        "title": "Bool type size",
        "description": "Is bool 1 bit?",
        "codeSnippet": "sizeof(_Bool)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "No guarantee it's 1 bit or 1 byte. Implementation defined (usually 1 byte). Code is syntactically correct though. Question is 'Is bool 1 bit?'. Answer is False.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_89",
        "title": "Void param omitted",
        "description": "Identify prototype.",
        "codeSnippet": "void f(); // declaration\n// ...\nf(10);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "In C, `f()` declares a function taking unspecified arguments. Calling it with `10` is valid syntax but dangerous if definition expects none. Ideally `f(void)`. Error: Mismatch if definition is `void f(void) { ... }`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_89",
        "title": "Max Align T",
        "description": "Is max_align_t standard?",
        "codeSnippet": "max_align_t m;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `max_align_t` in `<stddef.h>` (C11) has greatest alignment.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_90",
        "title": "Strcat uninit",
        "description": "Identify logic.",
        "codeSnippet": "char s[10];\nstrcat(s, \"Hi\");",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`s` is uninitialized. `strcat` looks for null terminator in garbage data, causing overflow/crash.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_90",
        "title": "UTF-16 Literal",
        "description": "Is u\"...\" valid?",
        "codeSnippet": "char16_t *s = u\"text\";",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `u` prefix for UTF-16 string literals.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_91",
        "title": "Function Local Static Init",
        "description": "Identify restriction.",
        "codeSnippet": "void f(int n) {\n    static int x = n;\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Static variable initializer must be a constant expression. `n` is runtime variable.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_91",
        "title": "Typedef Array",
        "description": "Is typedef int A[10] valid?",
        "codeSnippet": "typedef int A[10]; A a;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, implies `int a[10]`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_92",
        "title": "Comma Operator Precedence",
        "description": "Identify evaluation.",
        "codeSnippet": "int x = 1, 2;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Syntax error in declaration. Comma here is a separator. `int x=1` valid, `2` is syntax error. Intended `int x = (1, 2);`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_92",
        "title": "Floating Point Exception",
        "description": "Is FE_DIVBYZERO a macro?",
        "codeSnippet": "#include <fenv.h>\nint x = FE_DIVBYZERO;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, used with `fexcept_t`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_93",
        "title": "Pthread Join Missing",
        "description": "Identify leak/crash.",
        "codeSnippet": "pthread_t t; pthread_create(&t, 0, f, 0);\nreturn 0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Exiting main without joining or detaching thread. Thread is killed abruptly (if main exits). Resource leak.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_93",
        "title": "Pthread once",
        "description": "Is pthread_once standard?",
        "codeSnippet": "pthread_once_t o = PTHREAD_ONCE_INIT;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, standard POSIX thread initialization.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_94",
        "title": "Bitwise Shift Negative",
        "description": "Identify UB.",
        "codeSnippet": "int x = -1 << 1;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Left shifting a negative signed integer is undefined behavior (in C99/C11). C++20 made it defined.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_94",
        "title": "Alignof Expression",
        "description": "Is _Alignof(expr) valid?",
        "codeSnippet": "int x; size_t s = _Alignof(x);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`_Alignof` applies to types, not expressions. `_Alignof(int)` is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_95",
        "title": "Main signature args",
        "description": "Identify standard.",
        "codeSnippet": "int main(int argc) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Standard `main` takes either `void` or `int argc, char *argv[]`. Just `argc` is non-standard.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_95",
        "title": "Function Specifiers",
        "description": "Is noreturn a specifier?",
        "codeSnippet": "noreturn void f();",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes (via macro). `_Noreturn` is the keyword.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_96",
        "title": "Union Type Punning Write",
        "description": "Identify UB.",
        "codeSnippet": "float f = 1.0; int i = *(int*)&f;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Strict aliasing violation. Dereferencing `int*` cast from `float*` is UB. Use `union` or `memcpy`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_96",
        "title": "Char16_t type",
        "description": "Is char16_t unsigned?",
        "codeSnippet": "char16_t c;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, same as `uint_least16_t`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_97",
        "title": "Extern with Init",
        "description": "Identify semantics.",
        "codeSnippet": "extern int x = 10;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`extern` with an initializer becomes a definition. It overrides `extern`. Warns usually.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_97",
        "title": "File Scope VLA",
        "description": "Is file scope VLA valid?",
        "codeSnippet": "int n=10; int a[n];",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "VLAs must be automatic storage duration (inside function).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_98",
        "title": "Incomplete Struct Instantiation",
        "description": "Identify type error.",
        "codeSnippet": "struct S; struct S s;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`struct S` is forward declared (incomplete). Cannot instantiate it without definition.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_98",
        "title": "Atomic Flag",
        "description": "Is atomic_flag standard?",
        "codeSnippet": "atomic_flag f = ATOMIC_FLAG_INIT;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, lock-free boolean flag.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_99",
        "title": "Null Terminate Strncpy",
        "description": "Identify usage.",
        "codeSnippet": "char d[3];\nstrncpy(d, \"abc\", 3);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`strncpy` does NOT null-terminate if source length >= n. `d` is not null terminated. Printing it causes issues.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_99",
        "title": "Exit function",
        "description": "Does exit flush buffers?",
        "codeSnippet": "exit(0);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `exit` flushes streams and closes files. `_Exit` does not.",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_100",
        "title": "Memset value",
        "description": "Identify argument.",
        "codeSnippet": "int a[5];\nmemset(a, 1, sizeof(a));",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`memset` sets bytes. Setting `1` puts `0x01` in every byte, resulting in large integer `0x01010101`, not integer `1`.",
        "difficultyLevel": 2
    },
    {
        "id": "c_tf_100",
        "title": "C23 True False",
        "description": "Are they keywords in C23?",
        "codeSnippet": "bool b = true;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C23 makes `bool`, `true`, `false` keywords (no header needed).",
        "difficultyLevel": 2
    },
    {
        "id": "c_err_101",
        "title": "Setjmp Longjmp Volatile",
        "description": "Identify optimization safety.",
        "codeSnippet": "int x = 0;\nif (setjmp(buf)) { printf(\"%d\", x); } \nelse { x = 1; longjmp(buf, 1); }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Local variable `x` modified between `setjmp` and `longjmp` must be declared `volatile` to ensure correct value is restored/accessed after longjmp. Without volatile, value is indeterminate.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_101",
        "title": "Function storage class",
        "description": "Is auto valid on functions?",
        "codeSnippet": "auto void f() {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Function definitions can only have `static` or `extern` storage class specifiers (and inline/_Noreturn). `auto` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_102",
        "title": "Signal Handler Async Safety",
        "description": "Identify restricted call.",
        "codeSnippet": "void handler(int sig) {\n    printf(\"Signal caught\");\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`printf` is not async-signal-safe. Calling it from a signal handler leads to undefined behavior (deadlocks/memory corruption). Use `write`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_102",
        "title": "Bit field signedness",
        "description": "Is int x:1 signed?",
        "codeSnippet": "struct S { int x : 1; };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, but whether `int` bit-field is signed or unsigned is implementation-defined. If signed, `x` can only hold `0` and `-1`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_103",
        "title": "Struct Alignment Packing",
        "description": "Identify member offset.",
        "codeSnippet": "struct __attribute__((packed)) S { char c; int i; };\nint *p = &((struct S*)0)->i;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Taking address of packed member `i` which might be unaligned. Accessing unaligned pointer `p` can cause bus error/fault on strict architectures (ARM/SPARC).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_103",
        "title": "Main recursive",
        "description": "Can main be recursive?",
        "codeSnippet": "int main(int c) { if(c) main(c-1); }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `main` can be called recursively in C.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_104",
        "title": "VLA in struct",
        "description": "Identify syntax limit.",
        "codeSnippet": "struct S { int n; int a[n]; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Variable Length Arrays (VLAs) are not allowed as struct members. Array size in struct must be constant expression.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_104",
        "title": "Atomic Load",
        "description": "Is atomic_load explicit?",
        "codeSnippet": "atomic_load(&a);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C11 atomic load.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_105",
        "title": "Memory Order Relaxed",
        "description": "Identify race.",
        "codeSnippet": "atomic_store_explicit(&x, 1, memory_order_relaxed);\nif (atomic_load_explicit(&y, memory_order_relaxed)) assert(x==1);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Relaxed ordering does not guarantee visibility or ordering relative to other variables. `x` write might not be visible even if `y` is seen.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_105",
        "title": "Fopen x mode",
        "description": "Is wx mode C11?",
        "codeSnippet": "fopen(\"file\", \"wx\");",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `x` sub-specifier in C11 forces fail if file exists (exclusive create).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_106",
        "title": "Char pointer cast strict aliasing",
        "description": "Identify aliasing.",
        "codeSnippet": "int i = 0;\nchar *c = (char*)&i; *c = 1;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid! `char*` is the exception to strict aliasing. Can alias any type. \nError: `short *s = (short*)&i;` (if not compatible type).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_106_real",
        "title": "Float to Int Pointer Aliasing",
        "description": "Identify strict aliasing.",
        "codeSnippet": "void f(float *fp, int *ip) { *fp = 0.0; *ip = 1; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Strict aliasing rule violation if `fp` and `ip` point to same address. The compiler assumes they don't alias (incompatible types). Write to `*ip` might not be seen when reading back `*fp` or reordering occurs. (Context dependent, but unsafe assumption).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_106",
        "title": "Generic array",
        "description": "Can generic match array?",
        "codeSnippet": "_Generic((int[]){0}, int*: 1)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, array decays to pointer `int*` in the expression context passed to `_Generic`? Actually `_Generic` operand does NOT decay values like function arguments. But `(int[]){0}` is an array lvalue. Wait, `_Generic` matches the type of the expression. Does array decay? Standard says: 'lvalue conversion does not take place'. So it is `int[1]`. `int*` would NOT match.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_106_real",
        "title": "Generic Array Decay",
        "description": "Does Generic decay?",
        "codeSnippet": "_Generic(\"str\", char*: 1, char[4]: 2)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "`_Generic` does NOT perform array-to-pointer decay. `\"str\"` is `char[4]`. So it matches `char[4]` (or similar), not `char*`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_107",
        "title": "Zero length array",
        "description": "Identify standard vs extension.",
        "codeSnippet": "struct S { int n; char a[0]; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Zero-length arrays `a[0]` are a GNU extension. Standard C99 uses flexible array member `a[]` (no size).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_107",
        "title": "Thread Local Storage Init",
        "description": "Can thread_local be dynamic?",
        "codeSnippet": "int f();\n_Thread_local int x = f();",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Thread local variables in C must have constant initializers (unlike C++).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_108",
        "title": "C11 Annex K safe functions",
        "description": "Identify usage requirement.",
        "codeSnippet": "#define __STDC_WANT_LIB_EXT1__ 1\n#include <string.h>\n// strcpy_s usage",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Seems valid. \nError: Calling `strcpy_s` without checking return value or constraint handler?",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_108_real",
        "title": "Memcpy NULL pointers",
        "description": "Identify UB.",
        "codeSnippet": "memcpy(0, 0, 0);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Passing `NULL` to `memcpy` is undefined behavior, even if size is 0.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_108",
        "title": "Atomic Struct",
        "description": "Can struct be atomic?",
        "codeSnippet": "struct S { int x; }; _Atomic struct S s;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Atomic` can be applied to structs.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_109",
        "title": "Ternary Operands Type",
        "description": "Identify type mismatch.",
        "codeSnippet": "int *p = 0;\nlong n = 0;\nauto x = 1 ? p : n;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Conditional operator operands must have compatible types. Pointer and integer (other than 0 constant) are incompatible. `n` is a variable (value 0 but not constant 0 in C89). In C, mixing pointer and integer triggers warning/error mostly. With `NULL` (void*) it works.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_109",
        "title": "C11 Aligned Alloc",
        "description": "Is aligned_alloc standard?",
        "codeSnippet": "void *p = aligned_alloc(16, 32);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `aligned_alloc` introduced in C11. Size must be multiple of alignment.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_110",
        "title": "Designated Init Duplicate",
        "description": "Identify evaluation order.",
        "codeSnippet": "int a[3] = { [0]=1, [0]=2 };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Duplicate initialization index `0`. Valid in C (later overrides earlier) but often suspicious logic error warning.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_110",
        "title": "Decimal Float Extension",
        "description": "Is _Decimal32 standard?",
        "codeSnippet": "_Decimal32 d = 1.0df;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, optional decimal floating point extension (TR 24732 / C23).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_111",
        "title": "Identifier Significant Chars",
        "description": "Identify implementation limit.",
        "codeSnippet": "int a_very_long_identifier_name_that_exceeds_31_chars_A = 1;\nint a_very_long_identifier_name_that_exceeds_31_chars_B = 2;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "C89 guaranteed only 31 significant characters for internal identifiers. If limit is 31 and first 31 chars match, they are the same identifier. (C99 increased to 63).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_111",
        "title": "Complex Cast",
        "description": "Can cast to complex?",
        "codeSnippet": "double d = 1.0; double _Complex c = (double _Complex)d;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, cast to complex valid.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_112",
        "title": "Unions and Type Punning Read",
        "description": "Identify standard guarantee.",
        "codeSnippet": "union { int i; float f; } u;\nu.f = 1.0;\nint x = u.i;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Reading `u.i` after writing `u.f` (active member is float) is implementation-defined in C99, but *allowed*/defined in C11 as type punning (inspect representation). Not strictly 'undefined' like pointer casting. Wait. Many consider it UB or ImpDef. Let's pick strict UB.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_112_real",
        "title": "Shift overflow signed",
        "description": "Identify UB.",
        "codeSnippet": "int x = 1 << 31;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "If `int` is 32-bit, `1 << 31` pushes bit into sign bit. For signed int, this is technically UB in C99 (overflow). `1U << 31` is valid.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_112",
        "title": "C11 Timespec Get",
        "description": "Is timespec_get C11?",
        "codeSnippet": "timespec_get(&ts, TIME_UTC);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `timespec_get` added in C11.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_113",
        "title": "Const Volatile",
        "description": "Identify semantics.",
        "codeSnippet": "const volatile int port = 0x1000;\nport = 5;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Variable is `const` (read-only for program) and `volatile` (can be changed by hardware). Program `port = 5` violates `const`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_113",
        "title": "Static Param Array",
        "description": "Is int a[static 5] valid?",
        "codeSnippet": "void f(int a[static 5]);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C99 syntax guaranteeing array `a` has at least 5 elements.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_114",
        "title": "Compound Literal Lifetime",
        "description": "Identify dangling.",
        "codeSnippet": "int *p;\n{ p = (int[]){1, 2}; }\n*p = 3;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Compound literal has automatic storage duration associated with enclosing block. Leaving block lifetime ends. `p` dangles.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_114",
        "title": "Generic default position",
        "description": "Can default be anywhere?",
        "codeSnippet": "_Generic(x, default: 0, int: 1)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, order in `_Generic` does not matter.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_115",
        "title": "Register Address with compound literal",
        "description": "Identify semantics.",
        "codeSnippet": "register int *p = (int[]){1};",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `register int a[5]; int *p = a;` -> Cannot decay array to pointer if register?",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_115_real",
        "title": "Register Array Decay",
        "description": "Identify restriction.",
        "codeSnippet": "register int a[5];\nint *p = a;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Array `a` has `register` storage. Decaying to pointer requires taking address of first element. Cannot take address of `register`. UB/Error.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_115",
        "title": "Wchar_t size",
        "description": "Is wchar_t 16 bit?",
        "codeSnippet": "sizeof(wchar_t) == 2",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Implementation defined. On Windows 2 bytes, Linux 4 bytes. Statement could be true or false. 'True or False' question implies universality? Or 'Is code valid syntactically?' -> Snippet returns bool. Valid C.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_116",
        "title": "Macro stringify invalid",
        "description": "Identify preproc.",
        "codeSnippet": "#define S(x) #x\nchar *s = S(  a  b  );",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Result is `\"a b\"`. Spaces collapsed. Valid. \nError: `#define C(a,b) a ## b` -> `C(1, +)` -> `1+` token? `##` must produce valid token.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_116_real",
        "title": "Token Pasting invalid token",
        "description": "Identify preproc.",
        "codeSnippet": "#define PASTE(a, b) a ## b\nint x = PASTE(1, +);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`1+` is not a single valid pp-token. Result of `##` must be a valid token.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_116",
        "title": "C11 Annex K",
        "description": "Is it optional?",
        "codeSnippet": "__STDC_LIB_EXT1__",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, macro defined if Annex K (bounds-checking interfaces) is supported.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_117",
        "title": "Volatile access reordering",
        "description": "Identify concurrency.",
        "codeSnippet": "volatile int flag = 0; int data = 0;\ndata = 1; flag = 1;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "In multi-threaded env, compiler/CPU can reorder non-volatile `data` write after `flag` write. `volatile` does not imply memory fence/barrier. Use atomic or barriers.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_117",
        "title": "Imaginary constant",
        "description": "Is I standard?",
        "codeSnippet": "float _Complex c = 1.0f * I;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `I` expands to `_Imaginary_I` or `_Complex_I`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_118",
        "title": "Restrict Aliasing",
        "description": "Identify optimization UB.",
        "codeSnippet": "void f(int *restrict a, int *restrict b) { *a = 1; *b = 1; }\nint x; f(&x, &x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`restrict` promises pointers `a` and `b` don't alias. Calling with `&x, &x` violates contract. UB.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_118",
        "title": "Function defined in return C11",
        "description": "Is alignment specifier allowed?",
        "codeSnippet": "_Alignas(8) char c;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_119",
        "title": "Comparison function pointer void",
        "description": "Identify type compatibility.",
        "codeSnippet": "int cmp(const void *a, const void *b);\nqsort(arr, 10, 4, cmp);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Snippet valid usage. \nError: `qsort` expects `int (*)(const void*, const void*)`. If `cmp` is `int cmp(int *a, int *b)` -> incompatible function pointer.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_119_real",
        "title": "Qsort function mismatch",
        "description": "Identify signature.",
        "codeSnippet": "int cmp(int *a, int *b) { return *a - *b; }\n// ... qsort(..., (int(*)(const void*,const void*))cmp);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Casting function pointer `cmp` (taking `int*`) to expected `const void*` signature and calling it is UB (incompatible types). Function must officially take `const void*`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_119",
        "title": "Static Assert expression",
        "description": "Can assert non-constant?",
        "codeSnippet": "int n; _Static_assert(sizeof(n) == 4, \"Chk\");",
        "type": "trueOrFalse",
        "language": "c",
        "errorLineIndex": 0,
        "isCodeCorrect": true,
        "explanation": "Yes, `sizeof(n)` is integer constant expression (unless VLA).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_120",
        "title": "Unputc usage",
        "description": "Identify limit.",
        "codeSnippet": "ungetc('A', fp); ungetc('B', fp);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Guaranteed pushback is only 1 char. Pushing multiple characters without interleaving reads is not guaranteed and may fail.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_120",
        "title": "Math Errno",
        "description": "Does sqrt set errno?",
        "codeSnippet": "errno = 0; sqrt(-1);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, sets `errno` to `EDOM` (domain error).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_121",
        "title": "Sizeof side effects complex",
        "description": "Identify usage.",
        "codeSnippet": "int n = 5; \nsizeof(int[n++]);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Because argument is type-name involving VLA `int[n++]`, size is evaluated at runtime, so `n++` IS executed. Confusing side-effect inside sizeof.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_121",
        "title": "Struct Flexible Init",
        "description": "Init flexible member?",
        "codeSnippet": "struct S { int n; int a[]; } s = { 1, {2} };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Flexible array member cannot be initialized.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_122",
        "title": "Identifier mismatch universal char",
        "description": "Identify unicode.",
        "codeSnippet": "int \\u00C0; int \\u00c0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Universal character names like `\\u00C0` designate characters. Case sensitivity depends on underlying char. Actually `\\u00C0` (upper) and `\\u00c0` (lower) are same char? No, hexcodes. `C0` is ``. Maybe redeclaration if normalized? The main error: Not allowed in start of identifier in C99 if digit? No, it's letter. \nSimple error: `int \\u0024` ($) is not valid start?",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_122_real",
        "title": "UCN in Identifier Digits",
        "description": "Identify constraint.",
        "codeSnippet": "int \\u0030 = 0;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`\\u0030` is digit '0'. Identifiers cannot start with digit.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_122",
        "title": "Struct Copy Overlap",
        "description": "Is assignment safe?",
        "codeSnippet": "struct S s; s = s;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Self-assignment is safe (though useless).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_123",
        "title": "Enum Type Compatibility",
        "description": "Identify type diff.",
        "codeSnippet": "enum E1 { A }; enum E2 { B };\nenum E1 *p = 0; enum E2 *q = p;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Enumerations types `enum E1` and `enum E2` are compatible with some integer type, but pointers to them `enum E1*` and `enum E2*` are incompatible pointer types (unless compatible to same int, often warn). Strict aliasing also relevant.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_123",
        "title": "Char bit macro",
        "description": "Is CHAR_BIT standard?",
        "codeSnippet": "int b = CHAR_BIT;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, in `<limits.h>`, typically 8.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_124",
        "title": "Fflush input stream",
        "description": "Identify UB.",
        "codeSnippet": "fflush(stdin);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`fflush` is defined only for output/update streams. `fflush(stdin)` is undefined behavior (works in Windows/MSVC, but non-portable/UB).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_124",
        "title": "Complex I Type",
        "description": "Is I float complex?",
        "codeSnippet": "sizeof(I) == sizeof(float _Complex)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `I` is usually `float _Complex` constant.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_125",
        "title": "Signal handler calling Standard Lib",
        "description": "Identify restriction.",
        "codeSnippet": "void h(int s) { malloc(10); }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`malloc` is not async-signal-safe. Do not call in signal handler.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_125",
        "title": "Bitfield Bool",
        "description": "Bool bitfield 1 bit?",
        "codeSnippet": "_Bool b : 1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `_Bool` bit-field of width 1 is valid.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_126",
        "title": "Va_start second arg",
        "description": "Identify wrong arg.",
        "codeSnippet": "void f(int a, ...) {\n    va_list ap;\n    va_start(ap, 0);\n}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 2,
        "explanation": "Second argument to `va_start` must be the name of the last named parameter before the ellipsis (`a`). `0` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_126",
        "title": "Atomic Exchange",
        "description": "Is atomic_exchange standard?",
        "codeSnippet": "atomic_exchange(&a, 1);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C11 standard.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_127",
        "title": "Macro parameter prescan",
        "description": "Identify preproc.",
        "codeSnippet": "#define F(x) x\n#define G(x) F(x)\n#define A 1, 2\nG(A)",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 3,
        "explanation": "`G(A)` expands `A` to `1, 2`. Then calls `F(1, 2)`. `F` expects 1 argument but gets 2 (separated by comma). Error.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_127",
        "title": "Signal Atomic",
        "description": "Is sig_atomic_t atomic?",
        "codeSnippet": "volatile sig_atomic_t f;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, guaranteed atomic read/write (usually integer). Essential for signal handlers.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_128",
        "title": "Const parameter array size",
        "description": "Identify syntax.",
        "codeSnippet": "void f(int a[const 5]) { a++; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid syntax (C99). `[const 5]` makes the pointer `a` constant? Actually `a` is `int * const`. So `a++` is trying to modify a const pointer. Correct error.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_128_real",
        "title": "Static Param Array Modify",
        "description": "Identify const.",
        "codeSnippet": "void f(int a[static const 5]) { a[0]=1; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "`static const` inside array brackets? Syntax is `static` expression or type qualifiers. `[const static 5]`? Order matters? Standard says `[ static type-qualifier-list expression ]`. `const` applies to pointer? Actually `const` there means `int * const a`. Modification of `a` (pointer) is forbidden. But `a[0] = 1` modifies value pointed to. Valid? Snippet likely confusing. \nError: `void f(int n) { struct S { int a[n]; }; }` -> VLA in struct in function.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_128",
        "title": "Va_copy usage",
        "description": "Is va_copy standard?",
        "codeSnippet": "va_copy(dest, src);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, added in C99.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_129",
        "title": "Typedef void param",
        "description": "Identify usage.",
        "codeSnippet": "typedef void V;\nvoid f(V x) {}",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Parameter `x` has type `void`, which is incomplete type. Cannot declare parameter of type void.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_129",
        "title": "UCN in Identifier Start",
        "description": "Is \\u00C0 valid start?",
        "codeSnippet": "int \\u00C0 = 1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, universal character names representing letters are allowed in identifiers in C99/C11.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_130",
        "title": "Goto into VLA scope",
        "description": "Identify C99 restriction.",
        "codeSnippet": "goto lab;\nint n=10; int a[n];\nlab: ;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Cannot jump (`goto`) into scope of VLA `a` (violates C99). Skips VLA sizing code.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_130",
        "title": "Struct return copy",
        "description": "Does return copy struct?",
        "codeSnippet": "struct S { int x; }; struct S f() { struct S s={1}; return s; }",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, result is a copy.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_131",
        "title": "Tentative Definition Mismatch",
        "description": "Identify link error.",
        "codeSnippet": "int x; \nlong x;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Redeclaration of `x` with different type `long` (conflicting types).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_131",
        "title": "Enum trailing comma",
        "description": "Is comma allowed at end?",
        "codeSnippet": "enum E { A, B, };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, allowed in C99.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_132",
        "title": "Comma in default args",
        "description": "Identify syntax.",
        "codeSnippet": "#define M(a,b) a+b\nM(1, 2, 3)",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Macro `M` expects 2 arguments. 3 provided. (Comma in `1, 2, 3` treated as separator).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_132",
        "title": "Typeof GNU",
        "description": "Is typeof standard?",
        "codeSnippet": "typeof(int) x;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`typeof` is a GNU extension. C23 adds `typeof` (finally!). In C99/C11 code it is often `__typeof__` or unavailable.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_133",
        "title": "Compound literal const mod",
        "description": "Identify runtime error.",
        "codeSnippet": "int *p = (const int[]){1};\n*p = 2;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Literals is const. Modifying it via pointer (casted or not) is UB.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_133",
        "title": "Struct Member function",
        "description": "Can struct have methods?",
        "codeSnippet": "struct S { void f() {} };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "C structs cannot contain functions (only function pointers).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_134",
        "title": "Incomplete Array Element",
        "description": "Identify recursive.",
        "codeSnippet": "struct S { struct S arr[10]; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Struct `S` contains an array of `S`. `S` is incomplete at that point. Infinite size.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_134",
        "title": "Empty Struct",
        "description": "Is struct {} valid?",
        "codeSnippet": "struct S {};",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Empty structs are not defined in standard C (undefined behavior/extension). Valid in C++.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_135",
        "title": "Bitfield pointer",
        "description": "Identify constraint.",
        "codeSnippet": "struct S { int *p : 1; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Bit-fields must have qualified or unqualified integer type (or `_Bool`). Pointers not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_135",
        "title": "Auto Inference C23",
        "description": "Is auto x = 1 valid C23?",
        "codeSnippet": "auto x = 1;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C23 introduced type inference for `auto` (like C++).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_136",
        "title": "Thread create arg",
        "description": "Identify cast.",
        "codeSnippet": "pthread_create(&t, 0, f, 10);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Last argument to `pthread_create` is `void*`. Passing `10` (int) as pointer is dangerous implementation defined/UB if dereferenced or size mismatch. Should be cast `(void*)(intptr_t)10` or passing address.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_136",
        "title": "Null pointer check",
        "description": "Is !p valid?",
        "codeSnippet": "int *p = 0; if (!p) {}",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `!p` checks if pointer is null.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_137",
        "title": "Static assert msg C11",
        "description": "Identify arg count.",
        "codeSnippet": "_Static_assert(1);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "In C11, message string required. `_Static_assert(1, \"\")`. (Fixed in C23).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_137",
        "title": "Complex conj",
        "description": "Is conj standard?",
        "codeSnippet": "double complex z; conj(z);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, computes complex conjugate.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_138",
        "title": "Enum Duplicate Value",
        "description": "Identify syntax/warning.",
        "codeSnippet": "enum E { A=1, B=1 };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `enum E { A, A };` -> Duplicate identifier.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_138_real",
        "title": "Duplicate Enum Constant",
        "description": "Identify logic.",
        "codeSnippet": "enum E { A, A };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Redefinition of enumerator `A`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_138",
        "title": "Bool constant",
        "description": "Is true 1?",
        "codeSnippet": "#include <stdbool.h>\nif (true == 1)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, `true` expands to integer constant 1.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_139",
        "title": "Function Array Param Return",
        "description": "Identify semantics.",
        "codeSnippet": "int f(int a[3]) { return sizeof(a); }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Returns size of pointer (4/8), not array size (12). `a` decays. Common bug.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_139",
        "title": "Va_arg type",
        "description": "Does va_arg cast?",
        "codeSnippet": "va_arg(ap, float);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`float` arguments are promoted to `double` in variadic functions. `va_arg` must use `double`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_140",
        "title": "Restrict violation overlap",
        "description": "Identify UB.",
        "codeSnippet": "void f(int *restrict p, int *q) { *p = 1; *q = 2; }\nint x; f(&x, &x);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Argument `q` aliases restricted `p`. Inside `f`, `p` expects exclusive access (or no aliases via other args). UB.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_140",
        "title": "Complex Abs",
        "description": "Is cabs standard?",
        "codeSnippet": "cabs(z);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, complex absolute value.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_141",
        "title": "VLA jump",
        "description": "Identify scope.",
        "codeSnippet": "switch(n) { case 1: int a[n]; break; case 2: break; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Jumping into scope of VLA `a` (via case label) is illegal in C99. Same as goto.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_141",
        "title": "Constexpr C23",
        "description": "Is constexpr valid C23?",
        "codeSnippet": "constexpr int x = 5;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, C23 adds `constexpr` for object definitions.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_142",
        "title": "Static main",
        "description": "Identify linkage.",
        "codeSnippet": "static int main() { return 0; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Standard requires `main` to have external linkage (no static).",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_142",
        "title": "Bitfield 0 width",
        "description": "Is :0 valid?",
        "codeSnippet": "struct S { int x:1; int :0; int y:1; };",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, zero-width bit-field forces alignment to next storage unit boundary.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_143",
        "title": "Flexible Array Member placement",
        "description": "Identify struct.",
        "codeSnippet": "struct S { int a[]; int n; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "Flexible array member `a[]` must be the last member.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_143",
        "title": "Include next",
        "description": "Is include_next standard?",
        "codeSnippet": "#include_next <header.h>",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "`#include_next` is a GCC extension, not C standard.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_144",
        "title": "Noreturn return",
        "description": "Identify flow.",
        "codeSnippet": "_Noreturn void f() { return; }",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`_Noreturn` function must not return to caller. UB if it does.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_144",
        "title": "Enum scope",
        "description": "Is enum value global?",
        "codeSnippet": "void f() { enum { A }; } int x = A;",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Enumerator `A` is scoped to function `f` block. Not visible outside.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_145",
        "title": "Char subscript signed",
        "description": "Identify UB.",
        "codeSnippet": "char c = -1; int a[10];\nint x = a[c];",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Using negative index `-1` (if char is signed) on array `a`. Bounds error.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_145",
        "title": "Generic function match",
        "description": "Does Generic support functions?",
        "codeSnippet": "_Generic(f, void (*)(void): 1)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, function designator decays to function pointer.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_146",
        "title": "Struct redefinition",
        "description": "Identify collision.",
        "codeSnippet": "struct S { int x; };\nstruct S { int y; };",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Redefinition of `struct S`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_146",
        "title": "Sizeof bitfield",
        "description": "Can take sizeof bitfield?",
        "codeSnippet": "struct S { int x:1; }; sizeof(s.x);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": false,
        "explanation": "Cannot apply `sizeof` to a bit-field.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_147",
        "title": "Atomic Init non-atomic",
        "description": "Identify type.",
        "codeSnippet": "atomic_int x; atomic_init(&x, 1);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `atomic_init(&int_var, 1)` -> expects atomic ptr.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_147_real",
        "title": "Atomic flag clear relaxed",
        "description": "Identify fence.",
        "codeSnippet": "atomic_flag_clear_explicit(&f, memory_order_acquire);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 0,
        "explanation": "`atomic_flag_clear` (store operation) supports `release` or `relaxed` or `seq_cst`. `acquire` is invalid for store.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_147",
        "title": "Null pointer check macro",
        "description": "Is NULL guaranteed 0?",
        "codeSnippet": "if (p == NULL)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, NULL checks generic null pointer.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_148",
        "title": "Sizeof incomplete type",
        "description": "Identify constraint.",
        "codeSnippet": "struct S;\nsizeof(struct S);",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Cannot take sizeof incomplete type `struct S`.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_148",
        "title": "Alignof array",
        "description": "Is alignment of array same as element?",
        "codeSnippet": "_Alignof(int[10]) == _Alignof(int)",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, array alignment is alignment of its element.",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_149",
        "title": "Address of bitfield",
        "description": "Identify restriction.",
        "codeSnippet": "struct S { int x:1; } s;\nint *p = &s.x;",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "Cannot take address of bit-field member.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_149",
        "title": "Types of string literal",
        "description": "Is type char[]?",
        "codeSnippet": "sizeof(\"A\") == 2",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, type is `char[2]` ('A' + null).",
        "difficultyLevel": 3
    },
    {
        "id": "c_err_150",
        "title": "Memcmp structs padding",
        "description": "Identify UB.",
        "codeSnippet": "struct S { char c; int x; } a, b;\nmemcmp(&a, &b, sizeof(struct S));",
        "type": "errorSpotting",
        "language": "c",
        "errorLineIndex": 1,
        "explanation": "`memcmp` compares padding bytes which may contain indeterminate values. Result is unreliable for equality check.",
        "difficultyLevel": 3
    },
    {
        "id": "c_tf_150",
        "title": "Typedef function",
        "description": "Is it valid?",
        "codeSnippet": "typedef void F(void);",
        "type": "trueOrFalse",
        "language": "c",
        "isCodeCorrect": true,
        "explanation": "Yes, defines `F` as function type.",
        "difficultyLevel": 3
    }
]