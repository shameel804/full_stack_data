[
    {
        "id": "csharp_err_1",
        "title": "Variable Declaration",
        "description": "Identify the syntax error.",
        "codeSnippet": "int x = 10\nint y = 20;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Missing semicolon `;` at the end of the first line.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_1",
        "title": "String Literal",
        "description": "Is this a valid string?",
        "codeSnippet": "string s = 'Hello';",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, strings must be enclosed in double quotes `\"`. Single quotes are for `char`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_2",
        "title": "If Condition",
        "description": "Identify the type mismatch.",
        "codeSnippet": "int x = 1;\nif (x) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "In C#, `if` conditions must evaluate to `bool`. Integers are not automatically converted to boolean.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_2",
        "title": "Main Method",
        "description": "Is Main capitalized?",
        "codeSnippet": "static void Main(string[] args) { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, in C# the entry point method is capitalized `Main`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_3",
        "title": "Array Initialization",
        "description": "Identify the size syntax.",
        "codeSnippet": "int[] arr = new int[];",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Array size must be specified `new int[5]` or initialized `new int[] { 1, 2 }`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_3",
        "title": "Console WriteLine",
        "description": "Is System.out.println valid?",
        "codeSnippet": "System.out.println(\"Hi\");",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, that is Java syntax. C# uses `Console.WriteLine(\"Hi\");`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_4",
        "title": "Const Assignment",
        "description": "Identify the re-assignment.",
        "codeSnippet": "const int x = 10;\nx = 20;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Constants cannot be modified after declaration.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_4",
        "title": "Foreach Loop",
        "description": "Can you iterate arrays?",
        "codeSnippet": "foreach (int i in arr) { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `foreach` is the standard way to iterate over collections in C#.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_5",
        "title": "Method Return",
        "description": "Identify the missing return.",
        "codeSnippet": "int Add(int a, int b) {\n    int sum = a + b;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Method declared to return `int` must return a value.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_5",
        "title": "Null Coalescing",
        "description": "Is ?? a valid operator?",
        "codeSnippet": "string s = null;\nstring r = s ?? \"default\";",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `??` is the null-coalescing operator.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_6",
        "title": "Switch Case Break",
        "description": "Identify the missing break.",
        "codeSnippet": "switch(x) {\n    case 1: \n        Console.WriteLine(1);\n    case 2: break;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "C# does not allow fall-through for non-empty cases. Using `break` (or `goto`, `return`) is required.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_6",
        "title": "Var Keyword",
        "description": "Is var allowed for locals?",
        "codeSnippet": "var x = 10;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `var` is used for implicit typing of local variables.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_7",
        "title": "Private visibility",
        "description": "Identify the default access.",
        "codeSnippet": "class A {\n    int x;\n}\n// in another class: new A().x = 1;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Class members are private by default. `x` is not accessible outside `A`. (Snippet assumes usage context).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_7_real",
        "title": "Access Modifier",
        "description": "Find the visibility issue.",
        "codeSnippet": "class A { int x; }\nclass B { void M() { new A().x = 1; } }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`x` is private by default in class `A`. It is not accessible in `B`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_7",
        "title": "String Interpolation",
        "description": "Is $ syntax correct?",
        "codeSnippet": "string s = $\"Value: {x}\";",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `$` declares an interpolated string.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_8",
        "title": "Float Literal",
        "description": "Identify the suffix requirement.",
        "codeSnippet": "float f = 3.14;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`3.14` is a `double`. Assigning to `float` requires 'f' suffix: `3.14f`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_8",
        "title": "Region Directive",
        "description": "Is #region valid?",
        "codeSnippet": "#region MyRegion\n#endregion",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, standard C# preprocessor directive for code folding.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_9",
        "title": "Class Inheritance",
        "description": "Identify syntax error.",
        "codeSnippet": "class A extends B { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# uses colon `:` for inheritance, not `extends`. `class A : B { }`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_9",
        "title": "Property Syntax",
        "description": "Is get; set; valid?",
        "codeSnippet": "public int Age { get; set; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, this is an auto-implemented property.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_10",
        "title": "Interface Method Body",
        "description": "Identify the legacy rule.",
        "codeSnippet": "interface I {\n    void M() { }\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Prior to C# 8, interfaces could not have bodies. Even in C# 8+, strict/default expectations often assume abstracts. But technically valid in modern C# (default implementation). Let's pick a clearer error for difficulty 1.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_10_real",
        "title": "Multiple Inheritance",
        "description": "Identify the structural error.",
        "codeSnippet": "class A : B, C { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# creates logical error here if B and C are classes. C# does not support multiple class inheritance.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_10",
        "title": "Using Directive",
        "description": "Is using for namespaces?",
        "codeSnippet": "using System;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `using` imports namespaces.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_11",
        "title": "Static Method Call",
        "description": "Identify invalid access.",
        "codeSnippet": "class A { static void M() {} }\nA a = new A();\na.M();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "Static methods cannot be accessed instance variables. Use `A.M()`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_11",
        "title": "Enum Declaration",
        "description": "Is enum valid type?",
        "codeSnippet": "enum Color { Red, Blue }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `enum` declares an enumeration.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_12",
        "title": "Byte Overflow",
        "description": "Identify the range error.",
        "codeSnippet": "byte b = 300;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`byte` is 8-bit unsigned (0-255). 300 is too large.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_12",
        "title": "Checked Context",
        "description": "Does checked throw overflow?",
        "codeSnippet": "checked { int x = int.MaxValue + 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "Wait, code snippet is 'correct' syntax, question asks if code is correct (will run?). No, it throws `OverflowException` at runtime.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_13",
        "title": "Abstract Class Instantiation",
        "description": "Identify the creation error.",
        "codeSnippet": "abstract class A {}\nA a = new A();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Abstract classes cannot be instantiated.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_13",
        "title": "Reference Parameters",
        "description": "Is ref keyword usage valid?",
        "codeSnippet": "void Swap(ref int a, ref int b) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `ref` passes arguments by reference.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_14",
        "title": "Foreach Modification",
        "description": "Identify the iterator invalidation.",
        "codeSnippet": "foreach (int i in list) {\n    list.Add(1);\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Cannot modify specific collections inside a `foreach` loop.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_14",
        "title": "Struct vs Class",
        "description": "Are structs value types?",
        "codeSnippet": "struct Point { int x, y; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, structs are value types in C#.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_15",
        "title": "Override without Virtual",
        "description": "Identify the missing keyword.",
        "codeSnippet": "class A { void M() {} }\nclass B : A { override void M() {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Method `M` in A is not marked `virtual`, `abstract`, or `override`, so it cannot be overridden.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_15",
        "title": "Base Keyword",
        "description": "Can you access parent members?",
        "codeSnippet": "base.ToString();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `base` refers to the base class instance.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_16",
        "title": "String Mutable",
        "description": "Identify the misconception.",
        "codeSnippet": "string s = \"a\";\ns[0] = 'b';",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Strings are immutable. Indexer is read-only.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_16",
        "title": "Params Keyword",
        "description": "Is params for variable arguments?",
        "codeSnippet": "void M(params int[] numbers) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `params` allows passing a variable number of arguments.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_17",
        "title": "Namespace Syntax",
        "description": "Identify the missing usage.",
        "codeSnippet": "namespace MySpace\nclass A {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Namespace requires braces `{}` (or file-scoped `;` in C# 10). Assuming older syntax styles, missing braces.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_17",
        "title": "Out Keyword",
        "description": "Must out parameter be assigned?",
        "codeSnippet": "void M(out int x) { x = 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `out` parameters must be assigned before the method returns.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_18",
        "title": "Constructors Void",
        "description": "Identify the signature error.",
        "codeSnippet": "class A {\n   void A() { }\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Constructors do not have a return type, not even `void`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_18",
        "title": "Delegate Definition",
        "description": "Is delegate a type?",
        "codeSnippet": "delegate void MyDel();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `delegate` defines a reference type for methods.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_19",
        "title": "Destructor Args",
        "description": "Identify the syntax error.",
        "codeSnippet": "~A(int x) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Destructors (finalizers) cannot take arguments.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_19",
        "title": "Is Operator",
        "description": "Is 'is' for type checking?",
        "codeSnippet": "if (obj is string) { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `is` checks compatibility with a given type.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_20",
        "title": "Try Catch Order",
        "description": "Identify the unreachable block.",
        "codeSnippet": "try { }\ncatch (Exception e) {}\ncatch (DivideByZeroException e) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "`DivideByZeroException` is derived from `Exception`. It is unreachable because the base class catch handles it first.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_20",
        "title": "As Operator",
        "description": "Does 'as' throw exception?",
        "codeSnippet": "string s = obj as string;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "No, `as` returns `null` on failure, it does not throw `InvalidCastException`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_21",
        "title": "Event Syntax",
        "description": "Identify the declaration.",
        "codeSnippet": "public event Action;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Missing event name. `public event Action MyEvent;`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_21",
        "title": "Lambda Expression",
        "description": "Is => syntax correct?",
        "codeSnippet": "Func<int, int> f = x => x * x;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `=>` is the lambda operator.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_22",
        "title": "Foreach Iteration Variable",
        "description": "Identify the write error.",
        "codeSnippet": "foreach (var x in list) {\n    x = null;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "The iteration variable `x` is read-only.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_22",
        "title": "Nullable Types",
        "description": "Is int? nullable?",
        "codeSnippet": "int? x = null;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `int?` is shorthand for `Nullable<int>`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_23",
        "title": "Throw Syntax",
        "description": "Identify the keyword usage.",
        "codeSnippet": "throws new Exception();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Use `throw`, not `throws`. `throws` is Java.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_23",
        "title": "Object Class",
        "description": "Is object base of all?",
        "codeSnippet": "object o = 10;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, all classes inherit from `System.Object` (keyword `object`).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_24",
        "title": "Interface Public Method",
        "description": "Identify redundancy (older C#).",
        "codeSnippet": "interface I {\n    public void M();\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "In older C#, interface methods are implicitly public and cannot have access modifiers. In C# 8+, this is actually valid.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_24_real",
        "title": "Interface Private Member",
        "description": "Identify visibility error (Pre-C# 8).",
        "codeSnippet": "interface I { private void M(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Before C# 8, interfaces could not have private members. Even now, they must be implemented.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_24",
        "title": "Sealed Class",
        "description": "Can you inherit sealed?",
        "codeSnippet": "sealed class A {} \nclass B : A {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, `sealed` classes cannot be inherited from.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_25",
        "title": "Readonly Write",
        "description": "Identify the assignment error.",
        "codeSnippet": "class A {\n    readonly int x;\n    void M() { x = 10; }\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "`readonly` fields can only be assigned in declaration or constructor.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_25",
        "title": "Async Await",
        "description": "Is async void best practice?",
        "codeSnippet": "async void M() { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "It compiles, so `true`. However, `async Task` is preferred usually, except for event handlers.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_26",
        "title": "Goto Case",
        "description": "Identify the syntax.",
        "codeSnippet": "switch(x) {\n    case 1: goto case 2;\n    case 2: break;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code! `goto case` is the mechanism for fall-through in C#.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_26_real",
        "title": "Fallthrough",
        "description": "Identify switch behavior.",
        "codeSnippet": "case 1: Do();\ncase 2: Do(); break;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "C# forbids implicit fallthrough between non-empty case labels.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_26",
        "title": "Partial Class",
        "description": "Can class start with partial?",
        "codeSnippet": "partial class A { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `partial` keyword splits class definition.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_27",
        "title": "Static Constructor",
        "description": "Identify access modifier.",
        "codeSnippet": "static class A {\n    public static A() { }\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Static constructors cannot have access modifiers (public/private) or arguments.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_27",
        "title": "Dynamic Keyword",
        "description": "Is dynamic typed at runtime?",
        "codeSnippet": "dynamic d = 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `dynamic` bypasses static type checking.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_28",
        "title": "Int Parse",
        "description": "Identify runtime risk.",
        "codeSnippet": "int x = int.Parse(\"abc\");",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Throws `FormatException`. Use `int.TryParse` for safety.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_28",
        "title": "Yield Return",
        "description": "Does yield return create iterator?",
        "codeSnippet": "IEnumerable<int> M() { yield return 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `yield return` builds a state machine for iteration.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_29",
        "title": "Method Overload",
        "description": "Identify signature conflict.",
        "codeSnippet": "void M(int x) {}\nint M(int y) { return y; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Methods cannot be overloaded solely by return type. Parameter types must differ.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_29",
        "title": "Abstract Method Definition",
        "description": "Does abstract method have body?",
        "codeSnippet": "abstract void M();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, abstract methods have no body and end with semicolon.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_30",
        "title": "New Modifier",
        "description": "Identify warning suppression.",
        "codeSnippet": "class B : A { void M() {} } // A has M()",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Hiding an inherited member prompts a warning. Use `new void M()` to explicitly hide.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_30",
        "title": "Const vs Readonly",
        "description": "Is const static implicit?",
        "codeSnippet": "const int x = 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, const members are implicitly static.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_31",
        "title": "Lock usage",
        "description": "Identify lock target.",
        "codeSnippet": "lock(5) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot lock on value types (like `int`). Must lock on a reference type.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_31",
        "title": "Using Statement",
        "description": "Does using dispose?",
        "codeSnippet": "using(var x = new FileStream(...)) { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `using` block ensures `Dispose()` is called at the end.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_32",
        "title": "Var Field",
        "description": "Identify invalid var context.",
        "codeSnippet": "class A {\n    var x = 10;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`var` cannot be used for field declarations.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_32",
        "title": "Extension Method",
        "description": "Is 'this' keyword used?",
        "codeSnippet": "static void M(this string s) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `this` before the first parameter marks an extension method.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_33",
        "title": "Property Private Set",
        "description": "Identify syntax error.",
        "codeSnippet": "public int X { get; private set; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code! Correct syntax for private setter.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_33_real",
        "title": "Interface Property",
        "description": "Identify invalid syntax.",
        "codeSnippet": "interface I { int P { get; set; } = 1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Interfaces cannot have instance field initializers syntax on properties (usually).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_33",
        "title": "Tuple return",
        "description": "Can method return tuple?",
        "codeSnippet": "(int, int) M() { return (1, 2); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 7+ supports tuple return values.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_34",
        "title": "Local Function",
        "description": "Identify placement.",
        "codeSnippet": "void M() {\n    void Local() {}\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid! Local functions are allowed since C# 7.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_34_real",
        "title": "Local Function Static",
        "description": "Identify invalid capture.",
        "codeSnippet": "int y = 1; static void Local() { Print(y); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Static local function cannot access variables (`y`) from the enclosing scope.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_34",
        "title": "Nameof Operator",
        "description": "Does nameof return string?",
        "codeSnippet": "string s = nameof(Console);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `nameof` returns the string name of the symbol.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_35",
        "title": "Generic Constraint",
        "description": "Identify syntax.",
        "codeSnippet": "class A<T> where T : class {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code. Constrains T to reference types.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_35_real",
        "title": "Generic New Constraint",
        "description": "Identify missing parens.",
        "codeSnippet": "where T : new",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Must be `new()` with parentheses.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_35",
        "title": "Foreach Dictionary",
        "description": "Is iteration type KeyValuePair?",
        "codeSnippet": "foreach(KeyValuePair<int,int> kvp in dict) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, iterating a Dictionary yields KeyValuePair items.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_36",
        "title": "Goto usage",
        "description": "Identify bad practice/syntax.",
        "codeSnippet": "goto Label;\nLabel: Console.WriteLine();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code. Not error, just discouraged.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_36_real",
        "title": "Uninitialized Out",
        "description": "Identify flow error.",
        "codeSnippet": "void M(out int i) { if(false) i=1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`out` parameter `i` must be assigned before control leaves the method. Here it might not be assigned.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_36",
        "title": "String comparison",
        "description": "Is == operator overloaded?",
        "codeSnippet": "string a=\"a\", b=\"a\"; if(a==b){}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `==` for strings compares values (characters), not just references.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_37",
        "title": "Method Hiding",
        "description": "Identify warning.",
        "codeSnippet": "class A { public void M(){} } class B:A { public void M(){} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "In B, `void M()` hides inherited `M`. Should use `new` keyword or `override` (if virtual).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_37",
        "title": "Default Value",
        "description": "Is default(int) 0?",
        "codeSnippet": "int x = default;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `default` operator produces default value (0 for int, null for reference).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_38",
        "title": "Static Class Instance",
        "description": "Identify usage error.",
        "codeSnippet": "static class S {}\nS s = new S();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Cannot create instance of static class.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_38",
        "title": "Checked Block",
        "description": "Does checked detect overflow?",
        "codeSnippet": "checked { byte b = 255; b++; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No (snippet throws exception). Wait, question: 'isCodeCorrect'? Code causes runtime exception, so logically false usage.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_39",
        "title": "Ref Return",
        "description": "Identify syntax.",
        "codeSnippet": "ref int M() { return 1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot return a literal/value by reference. Must return a variable/field.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_39",
        "title": "Pattern Matching",
        "description": "Is 'is' pattern matching?",
        "codeSnippet": "if (o is int i) { Print(i); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `is` with a declaration pattern assigns types safe value to `i`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_40",
        "title": "Async Task Return",
        "description": "Identify return type mismatch.",
        "codeSnippet": "async Task<int> M() { return; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Method returning `Task<int>` must return an integer value.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_40",
        "title": "Expression Bodied Member",
        "description": "Is => valid for methods?",
        "codeSnippet": "int Add(int x) => x + 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, expression-bodied notation allows shorthand for one-line methods.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_41",
        "title": "Array Rank",
        "description": "Identify multi-dim syntax.",
        "codeSnippet": "int[,] a = new int[2];",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`int[,]` is 2D array, requires two dimensions size `new int[2,2]`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_41",
        "title": "Null Conditional",
        "description": "Is ?. operator valid?",
        "codeSnippet": "var len = s?.Length;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `?.` allows safe access to members of potential nulls.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_42",
        "title": "Base Constructor",
        "description": "Identify syntax error.",
        "codeSnippet": "B() { base(1); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Base constructor call syntax is `B() : base(1) { }`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_42",
        "title": "Discard",
        "description": "Is _ a discard?",
        "codeSnippet": "var (_, y) = GetTuple();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `_` is used to discard unwanted return values.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_43",
        "title": "Unsafe Block",
        "description": "Identify compilation requirement.",
        "codeSnippet": "unsafe { int* p = &x; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Valid code, but requires `/unsafe` compiler flag. Questionable if invalid syntax, but error text: 'Pointers only allowed in unsafe context'.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_43_real",
        "title": "Pointer outside unsafe",
        "description": "Identify context error.",
        "codeSnippet": "int* p;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Pointers (`*`) can only be used in an `unsafe` context.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_43",
        "title": "Throw Expression",
        "description": "Can throw be expression?",
        "codeSnippet": "int x = y ?? throw new Exception();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `throw` can be used as an expression in limited contexts (like null coalescing).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_44",
        "title": "Immutable String",
        "description": "Identify string creation.",
        "codeSnippet": "string s = new string(\"val\");",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`string` does not have a constructor taking a string. Use assignment `string s = \"val\";` or `char[]` constructor.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_44",
        "title": "Foreach Type Inference",
        "description": "Can you use var in foreach?",
        "codeSnippet": "foreach(var x in list) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, type of `x` is inferred from collection.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_45",
        "title": "Abstract Interface",
        "description": "Identify redundant keyword.",
        "codeSnippet": "abstract interface I {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Interfaces are implicitly abstract. `abstract` keyword not allowed.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_45",
        "title": "Switch Expression",
        "description": "Is switch expression valid?",
        "codeSnippet": "var x = i switch { 1 => \"one\", _ => \"other\" };",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, this is the C# 8 switch expression syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_46",
        "title": "Event Invocation",
        "description": "Identify safety.",
        "codeSnippet": "public event Action E;\nvoid OnE() { E(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Calling `E()` directly throws `NullReferenceException` if no subscribers. Use `E?.Invoke()`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_46",
        "title": "Using Static",
        "description": "Can you import static class?",
        "codeSnippet": "using static System.Math;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `using static` imports static members like `PI` directly.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_47",
        "title": "Anonymous Type",
        "description": "Identify declaration.",
        "codeSnippet": "var x = { A = 1 };",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Anonymous type syntax requires `new`: `var x = new { A = 1 };`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_47",
        "title": "Verbatim String",
        "description": "Does @ ignore escapes?",
        "codeSnippet": "string s = @\"C:\\Path\";",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `@` disables escape sequences (except `\"\"`).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_48",
        "title": "Index from end",
        "description": "Identify syntax support.",
        "codeSnippet": "var last = arr[^1];",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 8+. `^1` is the last element. Error: `arr[-1]` (runtime).",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_48_real",
        "title": "Negative Index",
        "description": "Identify runtime error.",
        "codeSnippet": "var x = arr[-1];",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# indices are 0-based non-negative. Throws `IndexOutOfRangeException`.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_48",
        "title": "While Loop",
        "description": "Is do-while same as while?",
        "codeSnippet": "do { } while(false);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Valid syntax. Logic: No, it runs at least once.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_49",
        "title": "Generic Array Init",
        "description": "Identify valid type.",
        "codeSnippet": "T[] arr = new T[5];",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Creating array of generic type `T` is actually valid in C# (unlike Java), assuming proper compilation. Wait... actually `new T[5]` IS valid in C# generics.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_49_real",
        "title": "Comparison of Structs",
        "description": "Identify missing operator.",
        "codeSnippet": "struct S { } S a, b; if (a == b) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Structs do not support `==` operator by default unless overloaded.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_49",
        "title": "Fixed Statement",
        "description": "Does fixed pin memory?",
        "codeSnippet": "fixed(int* p = arr)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `fixed` prevents the GC from moving the object during execution of the block.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_50",
        "title": "Destructor Visibility",
        "description": "Identify syntax error",
        "codeSnippet": "public ~A() { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Destructors cannot have access modifiers.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_tf_50",
        "title": "Goto switch",
        "description": "Can goto jump to case?",
        "codeSnippet": "goto case 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `goto case` transfers control to a specific switch section.",
        "difficultyLevel": 1
    },
    {
        "id": "csharp_err_51",
        "title": "Delegate Covariance",
        "description": "Identify type mismatch.",
        "codeSnippet": "delegate object D();\nD d = () => \"s\";",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code (Covariance). `string` \"s\" is assignable to `object`. Error: `delegate string D(); D d = () => new object();` (Contravariance not for return types).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_51_real",
        "title": "Unsafe Cast",
        "description": "Identify cast error.",
        "codeSnippet": "object o = \"s\";\nint i = (int)o;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Direct cast from boxed `string` to `int` throws `InvalidCastException`. Must allow only compatible types.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_51",
        "title": "Yield in Try-Catch",
        "description": "Can you yield in try block with catch?",
        "codeSnippet": "try { yield return 1; } catch {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, `yield return` is not allowed inside a `try` block that contains a `catch` block (before C# 6/maybe relaxed later? No, still restricted in Catch/Finally). Try with Catch: restricted.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_52",
        "title": "Async Void Exception",
        "description": "Identify exception behavior.",
        "codeSnippet": "async void Throw() { throw new Exception(); }\ntry { Throw(); } catch {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Exceptions from `async void` methods cannot be caught by the caller's catch block; they crash the process (unless synchronization context handles it).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_52",
        "title": "Struct No-Arg Constructor",
        "description": "Can structs have parameterless constructor?",
        "codeSnippet": "struct S { public S() { } }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 10+ allows parameterless constructors for structs.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_53",
        "title": "Closure Variable",
        "description": "Identify loop variable capture.",
        "codeSnippet": "var acts = new List<Action>();\nfor(int i=0; i<3; i++) acts.Add(() => Print(i));",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Prior to C# 5, this captured the *variable* `i`, so all actions printed the final value (3). In C# 5+, foreach is fixed, but `for` loop variable `i` is still shared. All print 3.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_53",
        "title": "Static Class Sealed",
        "description": "Are static classes sealed?",
        "codeSnippet": "static class S {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, static classes are implicitly sealed and abstract (cannot inherit/instantiate).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_54",
        "title": "Ref Local Reassignment",
        "description": "Identify ref reassignment.",
        "codeSnippet": "ref int x = ref y;\nx = z;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "`x = z` assigns the *value* of z to y (via x). To rebind the reference `x` itself, use `x = ref z;` (C# 7.3+). Snippet implies value assignment, which is valid. Question: syntax. `x = z` is value copy.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_54_real",
        "title": "Ref Local ref-assign",
        "description": "Identify bind error.",
        "codeSnippet": "ref int x = ref y;\nx = ref z;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Wait, `x = ref z` IS valid rebinding in C# 7.3. Error: `ref int x = 1` (cannot ref literal).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_54",
        "title": "Interface Default Method",
        "description": "Can interface method call private method?",
        "codeSnippet": "interface I { private void P() {} default void M() { P(); } }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 8+ allows default interface methods calling private members.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_55",
        "title": "Generic Covariance List",
        "description": "Identify type usage.",
        "codeSnippet": "List<object> l = new List<string>();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`List<T>` is invariant. `IEnumerable<T>` is covariant (`IEnumerable<object> = new List<string>()` ok), but mutable `List` is not.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_55",
        "title": "Expression Tree",
        "description": "Can lambda be Expression?",
        "codeSnippet": "Expression<Func<int>> e = () => 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler converts lambda to expression tree data structure.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_56",
        "title": "Destructor Exception",
        "description": "Identify the risk.",
        "codeSnippet": "~A() { throw new Exception(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Exceptions in finalizers terminate the runtime (process crash). Cannot be caught.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_56",
        "title": "Tuple Equality",
        "description": "Do tuples support ==?",
        "codeSnippet": "var t1 = (1, 2); var t2 = (1, 2); if(t1 == t2)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 7.3+ supports `==` for tuple types (member-wise comparison).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_57",
        "title": "Const Reference",
        "description": "Identify the type constraint.",
        "codeSnippet": "const object o = new object();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Const fields must be compile-time constants. `new object()` is runtime. Const reference types can only be `null` or strings.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_57",
        "title": "Range Operator",
        "description": "Is 1..^1 valid?",
        "codeSnippet": "var sub = arr[1..^1];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, range operator creates a slice.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_58",
        "title": "Volatile Int",
        "description": "Identify valid usage.",
        "codeSnippet": "volatile int x;\nInterlocked.Increment(ref x);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid code. `x` is volatile and passed by ref to Interlocked. Error: `volatile long x` on 32-bit? (C# guarantees atomicity for reference assignment, volatile works on int/ref/pointer/char/bool).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_58_real",
        "title": "Volatile Double Field",
        "description": "Identify type constraint.",
        "codeSnippet": "volatile double d;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`double` cannot be `volatile`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_58",
        "title": "String IsInterned",
        "description": "Does literals auto-intern?",
        "codeSnippet": "string.IsInterned(\"literal\");",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, literals are interned automatically.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_59",
        "title": "Attribute Usage",
        "description": "Identify target error.",
        "codeSnippet": "[Serializable] void M() {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`SerializableAttribute` is only valid on classes/structs/enums/delegates, NOT methods.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_59",
        "title": "Switch Type Pattern",
        "description": "Can switch match types?",
        "codeSnippet": "switch(o) { case int i: break; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 7+ supports type patterns in switch cases.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_60",
        "title": "Checked Exception",
        "description": "Identify feature existence.",
        "codeSnippet": "void M() throws Exception {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# does not have checked exceptions or `throws` clause.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_60",
        "title": "StackAlloc Reference",
        "description": "Can stackalloc hold strings?",
        "codeSnippet": "Span<string> s = stackalloc string[10];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, `stackalloc` only works with unmanaged types (primitives, structs/enums with fields of unmanaged types). `string` is reference type.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_61",
        "title": "Params Position",
        "description": "Identify argument rule.",
        "codeSnippet": "void M(params int[] a, int b) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`params` parameter must be the last parameter in the list.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_61",
        "title": "Init Only Setter",
        "description": "Is init accessor valid?",
        "codeSnippet": "public int X { get; init; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 9+ allows `init` accessor for initialization-time setting.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_62",
        "title": "Iterator Block Return",
        "description": "Identify syntax error.",
        "codeSnippet": "IEnumerable<int> M() { yield return 1; return 2; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot mix `yield return` and `return value`. Use `yield break` to stop iteration.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_62",
        "title": "Foreach Reference",
        "description": "Can you ref return in foreach?",
        "codeSnippet": "foreach (ref int x in span) { x++; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 7.3+ supports `ref` loop variables for spans.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_63",
        "title": "Access Modifier Struct",
        "description": "Identify inheritance syntax.",
        "codeSnippet": "protected struct S {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Top-level types cannot be `protected`. Nested structs can be, but protected suggests inheritance, and structs cannot be inherited.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_63",
        "title": "Discard in Switch",
        "description": "Is _ the default case?",
        "codeSnippet": "switch (x) { case _: break; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `case _` matches everything (like default, but using pattern matching semantics).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_64",
        "title": "Delegate Event Assignment",
        "description": "Identify encapsulation.",
        "codeSnippet": "// Outside class\nobj.MyEvent = null;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Events can only be assigned `+=` or `-=` outside the declaring class. Direct assignment `=` is prohibited.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_64",
        "title": "Null Forgiving Operator",
        "description": "Is ! used to suppress null warning?",
        "codeSnippet": "string s = null!;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `!` (null-forgiving operator) tells compiler variable is not null.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_65",
        "title": "Ref Extension Method",
        "description": "Identify restrictions.",
        "codeSnippet": "static void M(this ref int x) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Extension methods on value types can be `ref` (`this ref int x`) in newer C# (7.2+ struct/ref struct contexts). Wait, actually valid for structs. Error: `this out int x`. `ref` is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_65_real",
        "title": "Extension Method Class",
        "description": "Identify class requirement.",
        "codeSnippet": "class A { static void Eq(this int x) {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Extension methods must be defined in a `static` class.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_65",
        "title": "Local Static Function",
        "description": "Can local function be static?",
        "codeSnippet": "static void L() {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, static local functions ensure no variables are captured.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_66",
        "title": "Abstract Static",
        "description": "Identify conflict.",
        "codeSnippet": "abstract static void M();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "A method cannot be both `abstract` and `static`. Java allows `static` interface methods but not abstract. C# same logic.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_66",
        "title": "Record Struct",
        "description": "Is record struct valid?",
        "codeSnippet": "record struct Point(int x, int y);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 10 introduced `record struct`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_67",
        "title": "Fixed Size Buffer",
        "description": "Identify context.",
        "codeSnippet": "struct S { fixed int arr[10]; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Fixed size buffers in structs are unsafe. Struct must be marked `unsafe`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_67",
        "title": "Pattern Matching Property",
        "description": "Is property pattern valid?",
        "codeSnippet": "if (o is { Age: 10 })",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, property pattern matching checks strict equality.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_68",
        "title": "Interpolated String Escaping",
        "description": "Identify brace escape.",
        "codeSnippet": "$\"Val: {x} {{ }}\"",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Code valid (`{{` escapes brace). Error: `$\"Val: {x\"` (missing brace).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_68_real",
        "title": "Interpolation format",
        "description": "Identify escape seq.",
        "codeSnippet": "$\"Val: {x}\"\"",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Unbalanced quotes/braces.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_68",
        "title": "Target Typed New",
        "description": "Is new() valid inference?",
        "codeSnippet": "List<int> l = new();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 9+ infers typ from LHS.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_69",
        "title": "Ref Struct Heap",
        "description": "Identify constraint.",
        "codeSnippet": "ref struct S {} \nclass C { S s; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`ref struct` types (like Span) cannot be fields of a class (heap allocated). Must be stack-only.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_69",
        "title": "Foreach Span",
        "description": "Can you foreach span?",
        "codeSnippet": "foreach(var c in span) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, Spans (and ReadOnlySpan) have GetEnumerator support via duck typing.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_70",
        "title": "Partial Method Scope",
        "description": "Identify allowed context.",
        "codeSnippet": "class A { partial void M(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Partial methods can only be defined in partial classes.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_70",
        "title": "Unmanaged Constraint",
        "description": "Is where T : unmanaged valid?",
        "codeSnippet": "class A<T> where T : unmanaged {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `unmanaged` constraint allows T to be used as pointer/fixed buffer type.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_71",
        "title": "Foreach Remove",
        "description": "Identify runtime modification.",
        "codeSnippet": "foreach(var x in list) list.Remove(x);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Modifying collection inside foreach throws `InvalidOperationException`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_71",
        "title": "CallerMemberName",
        "description": "Does it inject name?",
        "codeSnippet": "void Log([CallerMemberName] string n = \"\")",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler injects the caller's member name.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_72",
        "title": "Lock String",
        "description": "Identify logical flaw.",
        "codeSnippet": "lock(\"mylock\") { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Locking on interned strings is dangerous; other code might lock on same string causing deadlock. Use `private readonly object`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_72",
        "title": "Required Interface Member",
        "description": "Can interface properties be 'required'?",
        "codeSnippet": "interface I { required int X { get; set; } }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, `required` modifier is for class/struct fields/properties, ensuring they are set at initialization. Not for interface members.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_73",
        "title": "Using Var Dispose",
        "description": "Identify interface missing.",
        "codeSnippet": "using(var x = 1) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "The type used in `using` must implement `IDisposable`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_73",
        "title": "Switch Expression Void",
        "description": "Does switch expression return value?",
        "codeSnippet": "x switch { _ => Console.WriteLine() };",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, switch expressions MUST produce a value. Use switch statement for actions.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_74",
        "title": "Struct Field Init",
        "description": "Identify invalid syntax (Old C#).",
        "codeSnippet": "struct S { int x = 1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Prior to C# 10, structs could not have field initializers. In recent C#, they can!",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_74_real",
        "title": "Struct Inheritance",
        "description": "Identify hierarchy.",
        "codeSnippet": "struct A {} struct B : A {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Structs cannot inherit from other structs.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_74",
        "title": "Lambda Capture Value",
        "description": "Does lambda capture by value?",
        "codeSnippet": "int i=1; Func<int> f = () => i;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Code compiles. Logic: No, it captures the *variable* `i` (by reference semantics, essentially closure class field).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_75",
        "title": "Async Out Parameter",
        "description": "Identify signature constraint.",
        "codeSnippet": "async Task M(out int x) { x=1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Async methods cannot have `out` or `ref` parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_75",
        "title": "Is Null Check",
        "description": "Is 'is null' better than '== null'?",
        "codeSnippet": "if (x is null)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `is null` ignores operator overloads for `==`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_76",
        "title": "Covariant Return",
        "description": "Identify return type override.",
        "codeSnippet": "class A { virtual A Clone() => new A(); }\nclass B : A { override B Clone() => new B(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 9+! Covariant return types are supported.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_76_real",
        "title": "Contravariant Return",
        "description": "Identify return type error.",
        "codeSnippet": "class A { virtual B Clone() => new B(); }\nclass B : A { override A Clone() => new A(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Return type must be same or more derived (covariant). `A` is less derived than `B`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_76",
        "title": "Static Lambda",
        "description": "Can lambda be static?",
        "codeSnippet": "Func<int, int> f = static x => x + 1;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `static` lambda prevents variable capture.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_77",
        "title": "Async Lambda Ref",
        "description": "Identify capture error.",
        "codeSnippet": "void M(ref int x) {\n    Func<Task> f = async () => x++;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Lambdas cannot capture `ref` or `out` parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_77",
        "title": "Module Initializer",
        "description": "Is ModuleInitializer valid?",
        "codeSnippet": "[ModuleInitializer] internal static void Init() {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 9 allows module initializers via attribute.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_78",
        "title": "Unsafe in Iterator",
        "description": "Identify context restriction.",
        "codeSnippet": "IEnumerable<int> M() {\n    unsafe { yield return 1; }\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`yield return` cannot be used inside an `unsafe` block.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_78",
        "title": "File Scoped Type",
        "description": "Is file class valid?",
        "codeSnippet": "file class A {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 introduces file-local types.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_79",
        "title": "Generic Unmanaged",
        "description": "Identify pointer usage.",
        "codeSnippet": "unsafe void M<T>(T* p) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Must constrain T to unmanaged: `where T : unmanaged`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_79",
        "title": "Raw String Literal",
        "description": "Is \"\"\" valid?",
        "codeSnippet": "var s = \"\"\"line 1\nline 2\"\"\";",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, raw string literals start/end with 3+ quotes.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_80",
        "title": "Extension GetEnumerator",
        "description": "Identify foreach support.",
        "codeSnippet": "/* Extension */ public static IEnumerator GetEnumerator(this int i) ...\nforeach(var x in 10) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid! `foreach` respects extension methods for `GetEnumerator`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_80_real",
        "title": "Extension Property",
        "description": "Identify syntax error.",
        "codeSnippet": "public static int Prop(this string s) { get; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Extension members must be methods. Extension *properties* are not supported.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_80",
        "title": "List Pattern",
        "description": "Is [1, ..] valid?",
        "codeSnippet": "if (arr is [1, ..])",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 list patterns support spread.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_81",
        "title": "Struct Event Field",
        "description": "Identify memory risk.",
        "codeSnippet": "struct S { public event Action E; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Compiler warning/error? It's allowed but dangerous since copying the struct copies the event backing field (delegate list). Modifying copy doesn't affect original.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_81",
        "title": "Foreach Multi-Dimensional",
        "description": "Does foreach flatten array?",
        "codeSnippet": "int[,] m = new int[2,2]; foreach(int i in m) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `foreach` iterates all elements of multi-dim array.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_82",
        "title": "Volatile Reference",
        "description": "Identify reference safety.",
        "codeSnippet": "volatile string s;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Reference types can be `volatile`. It ensures the *reference* assignment is atomic/visible.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_82_real",
        "title": "Volatile Struct",
        "description": "Identify type constraint.",
        "codeSnippet": "volatile Guid g;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`Guid` is a struct (user defined value type). Cannot be volatile.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_82",
        "title": "Generic Attribute",
        "description": "Can attribute be generic?",
        "codeSnippet": "class MyAttr<T> : Attribute {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 introduces generic attributes.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_83",
        "title": "Base in Lambda",
        "description": "Identify scope error.",
        "codeSnippet": "Func<string> f = () => base.ToString();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot access `base` members inside a lambda expression.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_83",
        "title": "Utf8 String Literal",
        "description": "Is u8 valid suffix?",
        "codeSnippet": "var bytes = \"text\"u8;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 creates ReadOnlySpan<byte>.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_84",
        "title": "Out Var Scope",
        "description": "Identify leak.",
        "codeSnippet": "while(M(out int i)) { } \nConsole.WriteLine(i);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid! `i` leaks to outer scope of the loop statement.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_84_real",
        "title": "For loop decl scope",
        "description": "Identify scope availability.",
        "codeSnippet": "for(int i=0; i<1; i++) {} \nPrint(i);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Symbol `i` is not defined outside the `for` loop.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_84",
        "title": "Static Abstract Interface",
        "description": "Can interface have static abstract?",
        "codeSnippet": "interface I<T> { static abstract T Create(); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 supports static abstract members in interfaces.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_85",
        "title": "Const Interpolation",
        "description": "Identify const restriction.",
        "codeSnippet": "const string s = $\"Val: {1}\";",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid only if placeholders are also const strings. `$\"Val: {1}\"` (int) is not const. Wait, C# 10 allows const interpolation if strings. But `1` is int, ToString is runtime. ERROR.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_85",
        "title": "Required Property init",
        "description": "Must use object initializer?",
        "codeSnippet": "var c = new C(); // C as required prop",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, if `C` has `required` properties, they must be set in object initializer `new C { Prop = ... }`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_86",
        "title": "Record Inheritance",
        "description": "Identify rules.",
        "codeSnippet": "record R; class C : R;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Classes cannot inherit from records, and vice versa.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_86",
        "title": "Lambda Attribute",
        "description": "Can lambda have attribute?",
        "codeSnippet": "var f = [Attr] () => {};",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, lambda attributes supported in recent C#.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_87",
        "title": "Switch Duplicate",
        "description": "Identify logic error.",
        "codeSnippet": "switch(i) {\n case 1: break; \n case 1: break;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "Duplicate case label `1`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_87",
        "title": "Global Using",
        "description": "Does global using work file-wide?",
        "codeSnippet": "global using System;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `global using` applies to the entire project/compilation.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_88",
        "title": "Interface Field",
        "description": "Identify syntax error.",
        "codeSnippet": "interface I { int x; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Interfaces cannot contain instance fields.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_88",
        "title": "Async Main",
        "description": "Can Main be async?",
        "codeSnippet": "static async Task Main() {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 7.1+ supports async Main.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_89",
        "title": "Anonymous Func Pointer",
        "description": "Identify usage.",
        "codeSnippet": "delegate*<void> p = &Local;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Function pointers require `unsafe` context.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_89",
        "title": "Ref Readonly Return",
        "description": "Can return constant by ref?",
        "codeSnippet": "ref readonly int M() => ref x;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `ref readonly` returns a reference that cannot be modified.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_90",
        "title": "Virtual Struct Method",
        "description": "Identify polymorphism.",
        "codeSnippet": "struct S { virtual void M() {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Structs are implicitly sealed. Cannot have `virtual` methods (except overriding object methods).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_90",
        "title": "Skip Locals Init",
        "description": "Does it improve perf?",
        "codeSnippet": "[SkipLocalsInit] void M() { int x; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, skips zero-initialization of locals for performance.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_91",
        "title": "Dynamic Extension",
        "description": "Identify runtime resolution.",
        "codeSnippet": "dynamic d = 1;\nd.ExtensionMethod();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Extension methods are not supported on `dynamic` dispatch.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_91",
        "title": "Half Type",
        "description": "Is Half a float?",
        "codeSnippet": "Half h = (Half)1.0;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `Half` is 16-bit floating point.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_92",
        "title": "New Constraint Struct",
        "description": "Identify conflict.",
        "codeSnippet": "where T : struct, new()",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`struct` constraint implies `new()`. Specifying both is redundant (error in some versions, allowed in latest but marked redundant). Let's use `where T : unmanaged, new()` - wait `unmanaged` implies struct. Error: `where T : U, struct` -> `struct` must be first.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_92_real",
        "title": "Constraint Order",
        "description": "Identify syntax error.",
        "codeSnippet": "where T : new(), class",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`class`/`struct` constraints must come before `new()`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_92",
        "title": "Unscoped Ref",
        "description": "Does scoped allow escape?",
        "codeSnippet": "scoped ref int x",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `scoped` restricts the lifetime of the ref to the current method (C# 11).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_93",
        "title": "Partial Method Implementation",
        "description": "Identify signature match.",
        "codeSnippet": "partial void M(); \npublic partial void M() {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Implementation signature must match declaration exactly. Declaration implicitly private; implementation cannot be public.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_93",
        "title": "Nameof Type Param",
        "description": "Can nameof use T?",
        "codeSnippet": "void M<T>() { var n = nameof(T); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `nameof(T)` returns \"T\".",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_94",
        "title": "Event override key",
        "description": "Identify syntax.",
        "codeSnippet": "override event Action E;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Events are overridden with `add`/`remove` accessors, or standard field syntax if base is virtual auto-event. This snippet is valid field-like override.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_94_real",
        "title": "Abstract Property Body",
        "description": "Identify syntax error.",
        "codeSnippet": "abstract int P { get { return 0; } }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Abstract properties cannot have accessors with bodies.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_94",
        "title": "Using Alias Generic",
        "description": "Can using alias be generic?",
        "codeSnippet": "using ListInt = System.Collections.Generic.List<int>;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, using alias can reference specific generic instantiation.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_95",
        "title": "Async Constructor",
        "description": "Identify invalid syntax.",
        "codeSnippet": "async Example() { await Task.Yield(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Constructors cannot be `async`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_95",
        "title": "Interface Static Field",
        "description": "Can interface have static field?",
        "codeSnippet": "interface I { static int X = 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 8+ allows static members with implementation/values in interfaces.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_96",
        "title": "Ref Conditional",
        "description": "Identify type mismatch.",
        "codeSnippet": "ref int x = (cond) ? ref a : ref b;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 7.2+. Error: `ref int x = (cond) ? ref a : 1;` (cannot mix ref and value).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_96_real",
        "title": "Ref Conditional Mix",
        "description": "Identify mix error.",
        "codeSnippet": "ref int x = true ? ref a : 1;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Conditional operator must return refs on both branches for `ref result`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_96",
        "title": "Function Pointer",
        "description": "Is delegate* valid?",
        "codeSnippet": "unsafe { delegate*<void> f; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 9 function pointers.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_97",
        "title": "Enum Inheritance",
        "description": "Identify hierarchy.",
        "codeSnippet": "enum E : System.Enum {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Enums cannot explicitly inherit from `System.Enum`. Can specify underlying type `enum E : int`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_97",
        "title": "Foreach Deconstruct",
        "description": "Can foreach deconstruct?",
        "codeSnippet": "foreach(var (x, y) in list) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, if element type supports deconstruction.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_98",
        "title": "Static extension access",
        "description": "Identify calling convention.",
        "codeSnippet": "obj.StaticExt();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid. Error: `ExtensionClass.StaticExt(obj)` (Valid). Error: `obj.StaticMethodOnClass()` (if not extension). Question unclear.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_98_real",
        "title": "Extension on Pointer",
        "description": "Identify support.",
        "codeSnippet": "unsafe static void E(this int* p) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Extension methods cannot handle pointer types (unless maybe in latest versions? No, `this` param cannot be pointer).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_98",
        "title": "Generic Math",
        "description": "Does T support operators?",
        "codeSnippet": "T Add<T>(T a, T b) where T: INumber<T> => a + b;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 Generic Math via `INumber`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_99",
        "title": "Volatile ReadOnly",
        "description": "Identify contradiction.",
        "codeSnippet": "volatile readonly int x;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Field cannot be both `volatile` and `readonly`.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_99",
        "title": "String Literal Split",
        "description": "Can string span lines?",
        "codeSnippet": "string s = \"line1\nline2\";",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, regular string literals cannot contain newlines (unless escaped `\\n` on one line or using `@\"\"`).",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_100",
        "title": "Async Lock",
        "description": "Identify deadlock/syntax.",
        "codeSnippet": "lock(obj) { await Task.Delay(1); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot `await` inside a `lock` block.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_tf_100",
        "title": "Null Coalescing Assoc",
        "description": "Is ?? associative?",
        "codeSnippet": "a ?? b ?? c",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, right-associative.",
        "difficultyLevel": 2
    },
    {
        "id": "csharp_err_101",
        "title": "Span in Async",
        "description": "Identify async restriction.",
        "codeSnippet": "async Task M() {\n    Span<int> s = stackalloc int[10];\n    await Task.Delay(1);\n    s[0] = 1;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`Span<T>` cannot be persisted across `await` points because it is a stack-only type (ref struct).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_101_real",
        "title": "Ref Struct Field",
        "description": "Identify class member error.",
        "codeSnippet": "class Container { Span<int> s; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`ref struct` types like `Span<T>` cannot be fields of a class (on the heap).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_101",
        "title": "Unsafe Delegate",
        "description": "Can delegate capture unsafe ptr?",
        "codeSnippet": "unsafe { int* p; Action a = () => *p = 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, anonymous functions/lambdas cannot capture variables in an `unsafe` context (pointers) due to lifetime tracking issues (unless fixed/ref improvements allow it? Usually error: 'Cannot capture in a lambda').",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_102",
        "title": "In Parameter Mod",
        "description": "Identify readonly violation.",
        "codeSnippet": "void M(in int x) { x = 10; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`in` parameters are passed by readonly reference. They cannot be modified.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_102",
        "title": "Volatile bool",
        "description": "Is volatile bool thread safe?",
        "codeSnippet": "volatile bool flag;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `volatile` ensures visibility of the latest value across threads, though not atomicity of read-modify-write ops alone.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_103",
        "title": "Finalizer Syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "override void Finalize() { base.Finalize(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# does not allow overriding `Finalize`. Must use destructor syntax `~ClassName() { }`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_103",
        "title": "Reference Equality",
        "description": "Does object.ReferenceEquals work on values?",
        "codeSnippet": "object.ReferenceEquals(1, 1);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Code runs, but returns `false`. Each `1` is boxed into a new object.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_104",
        "title": "Struct Cycle",
        "description": "Identify recursive layout.",
        "codeSnippet": "struct A { A a; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Structs cannot contain fields of their own type (creates infinite size cycle). Reference `A?` or class needed.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_104",
        "title": "SIMD Vector",
        "description": "Is Vector<T> H/W accelerated?",
        "codeSnippet": "Vector<int> v = new Vector<int>(1);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `System.Numerics.Vectors` uses SIMD if available.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_105",
        "title": "Event Interface Implementation",
        "description": "Identify missing accessors.",
        "codeSnippet": "interface I { event Action E; }\nclass C : I { public event Action E { add{} } }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Explicit event implementation with accessors must implement both `add` and `remove`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_105",
        "title": "Unsafe StackAlloc",
        "description": "Is stackalloc safe now?",
        "codeSnippet": "Span<int> s = stackalloc int[10];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, when assigned to `Span<T>`, `stackalloc` does not require `unsafe` context.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_106",
        "title": "WeakReference Target",
        "description": "Identify cast safety.",
        "codeSnippet": "WeakReference w = ...; \nvar o = (MyObj)w.Target; o.Method();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`w.Target` might be null (collected). Must check for null before using. Also `Target` is object, hard cast fine, but usage dangerous.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_106",
        "title": "Interface Virtual Member",
        "description": "Are interface members virtual?",
        "codeSnippet": "interface I { void M(); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Conceptually yes (polymorphic). In C# 8+, they can be sealed or non-virtual (default impl). Standard members are virtual mechanism.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_107",
        "title": "Lock Value Type",
        "description": "Identify lock error.",
        "codeSnippet": "int x = 0; lock(x) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Locking on value type `x` causes boxing. A new object is created each time, so `lock/Monitor` fails to synchronize.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_107",
        "title": "Task.Run Exception",
        "description": "Does Task.Run crash app?",
        "codeSnippet": "Task.Run(() => throw new Exception());",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Code is valid. Logic: No, it captures exception in returned Task (unless generic void delegate usage, but Task.Run captures).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_108",
        "title": "Constructor Exception Filter",
        "description": "Identify context.",
        "codeSnippet": "public C() when (true) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Constructors cannot have exception filters (`when`) or catch clauses attached (unlike methods in IL, but C# syntax forbids). Wait, `context`? Maybe meaning 'constructor chaining with when'? No, syntax invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_108_real",
        "title": "Destructor Async",
        "description": "Identify capability.",
        "codeSnippet": "~C() { await Task.Delay(1); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Finalizers cannot be async (return void, no Task, cannot await).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_108",
        "title": "Static Constructor Throw",
        "description": "Does it retry?",
        "codeSnippet": "static C() { throw new Exception(); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Code runs, throws `TypeInitializationException`. The type remains unusable for the app lifetime.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_109",
        "title": "Generic Attribute Type",
        "description": "Identify valid args.",
        "codeSnippet": "[MyAttr<T>] class C<T> {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Attribute arguments must be compile-time constants or `typeof`. Cannot pass generic `T` from C to open generic attribute usage (unless attribute is closed). Snippet implies open generic T usage inside attribute on C<T>.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_109",
        "title": "ModuleInitializers Order",
        "description": "Is order guaranteed?",
        "codeSnippet": "[ModuleInitializer] static void A(){}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Feature valid. Logic: Order of multiple initializers is undefined (reserved).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_110",
        "title": "Tuple Name Mismatch",
        "description": "Identify assignment rules.",
        "codeSnippet": "(int a, int b) t = (x: 1, y: 2); var z = t.x;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Tuple names on RHS (`x`, `y`) are ignored if LHS specifies names (`a`, `b`). Accessing `t.x` is error; must use `t.a`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_110",
        "title": "Dynamic Overload",
        "description": "Does dynamic resolve overload?",
        "codeSnippet": "void M(int i){} void M(string s){} dynamic d=1; M(d);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `dynamic` defers overload resolution to runtime, picking `M(int)`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_111",
        "title": "Foreach Cast",
        "description": "Identify runtime error.",
        "codeSnippet": "var objList = new List<object> { \"s\" };\nforeach(int i in objList) { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "C# `foreach` performs an explicit cast `(int)element`. Since element is string, this throws `InvalidCastException` at runtime.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_111",
        "title": "Using Declaration Scope",
        "description": "When is it disposed?",
        "codeSnippet": "if(true) { using var f = new File(); }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, disposed at end of enclosing block (the if block).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_112",
        "title": "Unsafe Fixed Buffer Ref",
        "description": "Identify pointer usage.",
        "codeSnippet": "fixed int buff[10];\nint* p = buff;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Must use `fixed` statement to get pointer to fixed buffer if it's moveable. If in fixed statement, logic ok. Error: usage of fixed buffer name `buff` directly decays to pointer ONLY in `fixed` context.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_112_real",
        "title": "Fixed Buffer Allocation",
        "description": "Identify location.",
        "codeSnippet": "void M() { fixed int buff[10]; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Fixed size buffers can only be declared in structs (unsafe). Not as local variables.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_112",
        "title": "Function Pointer Call",
        "description": "Can you invoke delegate*?",
        "codeSnippet": "p();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, standard invocation syntax works.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_113",
        "title": "Async Return Void",
        "description": "Identify caller issue.",
        "codeSnippet": "async void Do() {} \nawait Do();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Cannot `await` void-returning method. Must return `Task`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_113",
        "title": "Collection Exp Element",
        "description": "Can you mix spread?",
        "codeSnippet": "int[] a = [1, ..b, 3];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 12 collection expressions support spread element.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_114",
        "title": "Checked Operator Override",
        "description": "Identify syntax support.",
        "codeSnippet": "public static C operator checked +(C a, C b) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "C# 11+ supports checked operators. Syntax is `operator checked +`. Valid now. Error is likely if user targets older language version.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_114_real",
        "title": "Operator Override Visibility",
        "description": "Identify requirement.",
        "codeSnippet": "static C operator +(C a, C b) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Operator overloads must be `public static`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_114",
        "title": "Anonymous Type Mutability",
        "description": "Are anon types mutable?",
        "codeSnippet": "var x = new { A = 1 }; x.A = 2;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, anonymous types are immutable (properties are readonly).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_115",
        "title": "Ref Return Scope",
        "description": "Identify lifetime error.",
        "codeSnippet": "ref int M() { int x = 1; return ref x; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot return reference to local variable `x` because it dies when method returns.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_115",
        "title": "Partial Method Access",
        "description": "Can partial method be public?",
        "codeSnippet": "public partial void M();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, in C# 9+ extended partial methods can have access modifiers (must be implemented).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_116",
        "title": "Interface Static Abstract",
        "description": "Identify impl missing.",
        "codeSnippet": "interface I { static abstract void M(); } \nclass C : I {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Class `C` must implement static abstract member `M`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_116",
        "title": "Interpolated String Handler",
        "description": "Can you customize interpolation?",
        "codeSnippet": "[InterpolatedStringHandler] ref struct H { ... }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 10 custom handlers avoid allocation.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_117",
        "title": "Method Group Delegate",
        "description": "Identify logic.",
        "codeSnippet": "Func<int> f = new Random().Next;\nvar f2 = new Random().Next;\nbool b = (f == f2);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Code valid. Logic: `b` is false. Each method group conversion creates a new delegate instance pointing to different Random objects (created inline).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_117_real",
        "title": "Event Add Remove",
        "description": "Identify missing body.",
        "codeSnippet": "event Action E { add; remove; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Must provide `{}` bodies or use semicolon field syntax `event Action E;`. `add;` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_117",
        "title": "Primary Constructor",
        "description": "Is constructor on class valid?",
        "codeSnippet": "class C(int x) { }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 12 introduces primary constructors for classes/structs.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_118",
        "title": "Const Decimal",
        "description": "Identify invalid type.",
        "codeSnippet": "const decimal d = 1.0m;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`decimal` cannot be a compile-time constant (runtime ref type logic essentially, though value type). Only primitives/strings/null. Wait, `decimal` IS allowed in const since it has literal support? Checked: Yes, `const decimal` IS allowed. Error is `const MyStruct s`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_118_real",
        "title": "Const DateTime",
        "description": "Identify constant type.",
        "codeSnippet": "const DateTime d = DateTime.Now;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Reference types (except string) and structs (except primitives/decimal) cannot be const. `DateTime` is struct, not const capable (new object).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_118",
        "title": "Ref Field",
        "description": "Can ref struct have ref field?",
        "codeSnippet": "ref struct S { ref int x; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 introduces `ref` fields in `ref struct`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_119",
        "title": "Pointer Arithmetic",
        "description": "Identify type constraint.",
        "codeSnippet": "unsafe { void* p; p++; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot perform arithmetic on `void*`. Must cast to `byte*` or specific type.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_119",
        "title": "Generic Attribute Type Param",
        "description": "Can generic attribute use T?",
        "codeSnippet": "class A<T> : Attribute { T Value; } [A<int>] class C {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 11 allows this.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_120",
        "title": "Interface Const",
        "description": "Identify syntax support.",
        "codeSnippet": "interface I { const int X = 1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 8+. Before that, interfaces couldn't have constants or static members.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_120_real",
        "title": "Default Interface Field",
        "description": "Identify field limit.",
        "codeSnippet": "interface I { int x = 1; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Interfaces cannot have instance fields (`x`), even with default implementations. Can have properties.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_120",
        "title": "Destructor Call",
        "description": "Can you call Finalize?",
        "codeSnippet": "obj.Finalize();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, `Finalize` is protected. Can only be called by GC or base.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_121",
        "title": "Switch Case Scope",
        "description": "Identify variable collision.",
        "codeSnippet": "switch(x) {\n case 1: int i=0; break;\n case 2: int i=1; break;\n}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "Switch sections share the same scope. `i` is already defined in the scope. Must use braces `{ ... }` around case bodies.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_121",
        "title": "StackAlloc Expression",
        "description": "Is stackalloc in expression?",
        "codeSnippet": "Span<int> s = useStack ? stackalloc int[10] : new int[10];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, allowed since C# 8.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_122",
        "title": "Using Directive Placement",
        "description": "Identify order rules.",
        "codeSnippet": "namespace N {}\nusing System;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`using` directives must precede namespace elements (classes etc.) in the file, or be inside the namespace. Cannot be after `namespace N{}` closed block if file continues? Wait, snippet shows `namespace {}` then `using`. Valid if top level. But if `namespace N { using... }` valid. Snippet structure ambiguous. Let's error: `using` inside method.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_122_real",
        "title": "Using Inside Class",
        "description": "Identify placement.",
        "codeSnippet": "class C { using System; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`using` namespace directives cannot be inside a class body.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_122",
        "title": "Alias Any Type",
        "description": "Can using alias tuple?",
        "codeSnippet": "using Point = (int, int);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 12 aliases any type.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_123",
        "title": "Generic Operator",
        "description": "Identify overload rule.",
        "codeSnippet": "static T operator +(T a, T b)",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Operators must be defined on the enclosing type. If `T` is the enclosing generic class parameters, it's valid. If `T` is method generic, operators cannot be generic methods.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_123",
        "title": "Lambda Natural Type",
        "description": "Is var f = () => {}; valid?",
        "codeSnippet": "var f = () => {};",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, in C# 10+, compiler infers natural delegate type (Action).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_124",
        "title": "Fixed Statement Resize",
        "description": "Identify runtime/syntax.",
        "codeSnippet": "fixed(int* p = &arr[0]) { arr = new int[20]; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Resizing/reassigning the array variable `arr` inside `fixed` is allowed, but `p` continues to point to the OLD pinned array (until block ends). Logical pitfall, not syntax error. Error: `fixed(int* p = null)`. Valid.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_124_real",
        "title": "Fixed Statement Assign",
        "description": "Identify pointer safety.",
        "codeSnippet": "fixed(int* p = arr) { p++; }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`p` is read-only in `fixed`. Cannot modify `p` itself (`p++`). Must assign to another pointer `int* q = p; q++;`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_124",
        "title": "Async Dispose",
        "description": "Is DisposeAsync valid?",
        "codeSnippet": "await using var x = new Res();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, calls `DisposeAsync` from `IAsyncDisposable`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_125",
        "title": "Null Coalesce Throw",
        "description": "Identify usage.",
        "codeSnippet": "string s = null ?? throw new Ex();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid. Error: `string s = throw new Ex();` (invalid in isolation).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_125_real",
        "title": "Null Coalesce Assignment",
        "description": "Identify precedence.",
        "codeSnippet": "x ??= y ??= z;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid (right associative). Error: `(x ??= y) = z` (result is value, not variable?). Assignment returns value. Syntax check `??=` is valid.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_125",
        "title": "Collection Expression Type",
        "description": "Does [] create List?",
        "codeSnippet": "List<int> l = [1, 2];",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, target-typed collection expression.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_126",
        "title": "Delegate Combine Generic",
        "description": "Identify variance safety.",
        "codeSnippet": "Action<object> a1 = o => {}; \nAction<string> a2 = s => {}; \nvar c = Delegate.Combine(a1, a2);",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 2,
        "explanation": "`Delegate.Combine` throws `ArgumentException` if delegates are of different types. `Action<object>` and `Action<string>` are different types, even if compatible via variance.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_126",
        "title": "Unsafe SizeOf",
        "description": "Does sizeof require unsafe?",
        "codeSnippet": "int s = sizeof(int);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "No, `sizeof` for built-in types is safe. For custom structs required `unsafe` until recently (C# 7+ made it safe if no managed fields).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_127",
        "title": "Lambda Discard Param",
        "description": "Identify multiple discards.",
        "codeSnippet": "Func<int, int, int> f = (_, _) => 0;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 9+. Multiple `_` parameters allowed as discards.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_127_real",
        "title": "Lambda Discard Pre-9",
        "description": "Identify parameter conflict.",
        "codeSnippet": "Func<int, int, int> f = (_, _) => 0;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Prior to C# 9, `_` was a valid variable name, so `(_, _)` caused duplicate parameter name error.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_127",
        "title": "Static Class Extension",
        "description": "Can static class have extension?",
        "codeSnippet": "public static void E(this StaticClass s) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, static classes cannot be used as type of extension method parameter (cannot instantiate/reference).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_128",
        "title": "Expression Body Property",
        "description": "Identify syntax error.",
        "codeSnippet": "int P => get { return 1; };",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Expression body `=>` replaces the block. Cannot use `get {}` keyword inside expression body. Should be `int P => 1;` or `int P { get => 1; }`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_128",
        "title": "Generic Attribute Constraints",
        "description": "Are constraints checked?",
        "codeSnippet": "[MyAttr<string>] class C {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, attribute usage checks generic constraints.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_129",
        "title": "Default Parameter ref",
        "description": "Identify invalid default.",
        "codeSnippet": "void M(ref int x = 1) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`ref` or `out` parameters cannot have default values (until very recently? No, still restriction).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_129",
        "title": "Implicit Operator",
        "description": "Can implicit operator throw?",
        "codeSnippet": "public static implicit operator int(C c) => throw new Ex();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Syntax valid. Best practice: Implicit casts should not throw.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_130",
        "title": "Iterator TryCatch",
        "description": "Identify yield location.",
        "codeSnippet": "IEnumerable<int> M() { try { yield return 1; } catch {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot `yield return` in a `try` block with a `catch` clause.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_130",
        "title": "Pattern Matching Switch",
        "description": "Does case null match type?",
        "codeSnippet": "switch(o) { case string s: break; } // o is null",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Code runs. Logic warning: `case string s` does NOT match `null`. It falls through or goes to default.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_131",
        "title": "Async Lock Await",
        "description": "Identify context.",
        "codeSnippet": "lock(o) { await Task.Yield(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot await inside lock statement.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_131",
        "title": "Using Disposable Struct",
        "description": "Does it box?",
        "codeSnippet": "using(new MutableStructDisposable()) {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, valid. Optimizes to not box if IDisposable is implemented implicitly? No, interface call often boxes unless constrained generic or pattern-based Dispose (ref structs).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_132",
        "title": "Partial Class Base",
        "description": "Identify conflict.",
        "codeSnippet": "partial class C : A { } \npartial class C : B { }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Partial classes must agree on the base class. Cannot inherit from both `A` and `B`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_132",
        "title": "List Pattern Var",
        "description": "Can pattern capture var?",
        "codeSnippet": "if(a is [var x, ..])",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, captures first element into `x`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_133",
        "title": "Extension Method Ambiguity",
        "description": "Identify resolution.",
        "codeSnippet": "c.Method(); // C has Method(), Ext has Method(this C)",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Instance method always wins over extension method (no ambiguity error). Warning: extension method hidden.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_133_real",
        "title": "Extension on Dynamic",
        "description": "Identify support.",
        "codeSnippet": "dynamic d; d.Ext();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Extension methods are not supported on dynamic dispatch.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_133",
        "title": "Extern Alias",
        "description": "Can you alias assembly?",
        "codeSnippet": "extern alias Grid;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, used to resolve conflicting types from different assemblies.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_134",
        "title": "Unsafe Delegate Func",
        "description": "Identify type constraint.",
        "codeSnippet": "Func<int*> f;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Type arguments must be types (not pointers). `Func` cannot take `int*`. Must use custom delegate.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_134",
        "title": "Unmanaged Alloc",
        "description": "Is AllocHGlobal valid?",
        "codeSnippet": "Marshal.AllocHGlobal(100);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, allocates unmanaged memory.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_135",
        "title": "Lambda Ref Return",
        "description": "Identify support.",
        "codeSnippet": "delegate ref int D(); \nD d = () => ref x;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Supported checking... C# 7 supports ref return lambda? Yes. Code likely valid.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_135_real",
        "title": "Async Ref Return",
        "description": "Identify feature.",
        "codeSnippet": "async ref int M() {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Async methods cannot return by reference.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_135",
        "title": "Checked Expression",
        "description": "Is checked() an expression?",
        "codeSnippet": "int x = checked(a + b);",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `checked(...)` evaluates expression with overflow checking.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_136",
        "title": "ArgList usage",
        "description": "Identify support.",
        "codeSnippet": "void M(__arglist) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`__arglist` is an undocumented/deprecated feature. Valid in compiler but discouraged/legacy. Sometimes flagged.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_136",
        "title": "Operator is True",
        "description": "Can you overload true/false?",
        "codeSnippet": "public static bool operator true(C c)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, used to control boolean evaluation of the type (e.g. if(c)).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_137",
        "title": "Foreach Null",
        "description": "Identify runtime error.",
        "codeSnippet": "IEnumerable<int> list = null;\nforeach(var x in list) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`foreach` throws `NullReferenceException` if the collection expression is null.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_137",
        "title": "Static Local Function Attributes",
        "description": "Can local function have attribute?",
        "codeSnippet": "static void M() { [MethodImpl(256)] void L() {} }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, attributes allowed locally.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_138",
        "title": "Partial Method Ref/Out",
        "description": "Identify mismatch.",
        "codeSnippet": "partial void M(ref int x); \npartial void M(out int x) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "Signatures must match. `ref` and `out` differ.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_138",
        "title": "Unsafe in Async",
        "description": "Can async method be unsafe?",
        "codeSnippet": "unsafe async Task M() {}",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_139",
        "title": "Generic Covariance ValueType",
        "description": "Identify implicit cast.",
        "codeSnippet": "IEnumerable<object> e = new List<int>();",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Generic covariance (`IEnumerable<out T>`) only applies when T is a reference type. `int` is value type, so `IEnumerable<int>` is not convertible to `IEnumerable<object>`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_139",
        "title": "Raw String Indent",
        "description": "Does compiler strip indent?",
        "codeSnippet": "\"\"\"\n  Line\n  \"\"\"",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, leading whitespace matching the closing quotes is stripped.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_140",
        "title": "New Virtual Slot",
        "description": "Identify vtable logic.",
        "codeSnippet": "class A { virtual void M() {} } \nclass B : A { new virtual void M() {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid. `new virtual` creates a new vtable slot, hiding the base.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_140_real",
        "title": "Override New Virtual",
        "description": "Identify logical ambiguity.",
        "codeSnippet": "// B has new virtual M. C : B\noverride void M()",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Overrides B's M, not A's. Valid code. Error: logic.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_140",
        "title": "Recursive Pattern",
        "description": "Is { A: { B: 1 } } valid?",
        "codeSnippet": "o is { Prop: { Sub: 1 } }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 8 property patterns allow recursion.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_141",
        "title": "Volatile Increment",
        "description": "Identify atomicity.",
        "codeSnippet": "volatile int x; x++;",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`x++` is not atomic even on volatile fields. Use `Interlocked.Increment`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_141",
        "title": "Default Parameter Attribute",
        "description": "Is direct default valid?",
        "codeSnippet": "void M([Optional] int x)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, using `Optional` attribute instead of `=` syntax (valid COM interop style).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_142",
        "title": "Ref Struct Interface",
        "description": "Identify limitation.",
        "codeSnippet": "ref struct S : IDisposable { void Dispose(){} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`ref struct` cannot implement interfaces (because boxing to interface is impossible for stack types). (Note: C# 12+ might allow implementation IF not boxed? No, still generally error unless `I` is not used boxed).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_142",
        "title": "String Switch Optimization",
        "description": "Is switch string hashed?",
        "codeSnippet": "switch(s) { case \"a\": ... }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, compiler optimizes string switch using hash table/trie.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_143",
        "title": "Private Protected Access",
        "description": "Identify visibility.",
        "codeSnippet": "// Assem1: class A { private protected int x; }\n// Assem2: class B : A { void M() { x=1; } }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 1,
        "explanation": "`private protected` is visible only to derived classes WITHIN the same assembly.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_143",
        "title": "Module Initializer Scope",
        "description": "Can it be internal?",
        "codeSnippet": "[ModuleInitializer] internal static void I()",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, must be static void parameterless, can be internal/public.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_144",
        "title": "Static Class Constructor Parameter",
        "description": "Identify syntax error.",
        "codeSnippet": "static class S { static S(int x){} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Static constructors cannot accept parameters.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_144",
        "title": "Unsafe Block in Iterator",
        "description": "Is unsafe context flowed?",
        "codeSnippet": "IEnumerable<int> M() { unsafe { int* p; } yield return 1; }",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `unsafe` block is allowed if it does not contain the `yield` statement directly inside usage violations. Snippet seems safe.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_145",
        "title": "Abstract Sealed",
        "description": "Identify contradiction.",
        "codeSnippet": "abstract sealed class C {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`static` classes are technically abstract sealed in IL, but in C# `abstract sealed` combo is disallowed syntax. Use `static`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_145",
        "title": "Generic Attribute Open",
        "description": "Can you use open generic attr?",
        "codeSnippet": "[Attr<>] class C",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": false,
        "explanation": "No, must supply type arguments.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_146",
        "title": "Unmanaged Constraint Class",
        "description": "Identify mismatch.",
        "codeSnippet": "class C<T> where T : class, unmanaged",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`unmanaged` implies `struct` (value type). `class` constraint conflicts.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_146",
        "title": "Foreach Custom GetEnumerator",
        "description": "Does duck typing work?",
        "codeSnippet": "foreach(var x in instanceWithGetEnum)",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, `foreach` uses duck typing (looks for GetEnumerator method), doesn't require IEnumerable interface.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_147",
        "title": "Async Void Main",
        "description": "Identify syntax error.",
        "codeSnippet": "static async void Main() {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "EntryPoint cannot be `async void`. Must be `async Task` or `void`.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_147",
        "title": "Target Type Conditional",
        "description": "Is shared type inferred?",
        "codeSnippet": "Base b = cond ? new Derived1() : new Derived2();",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, C# 9+ target-typed conditional expression found common base.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_148",
        "title": "Interface Sealed Member",
        "description": "Identify usage.",
        "codeSnippet": "interface I { sealed void M() {} }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": -1,
        "explanation": "Valid in C# 8+ (prevents override in derived interfaces/implementers?). It's for DIM. Error: `sealed` without body.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_148_real",
        "title": "Sealed without Body",
        "description": "Identify requirement.",
        "codeSnippet": "interface I { sealed void M(); }",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Sealed interface member must have a body (default implementation).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_148",
        "title": "Null Forgiving Lambda",
        "description": "Is null! valid return?",
        "codeSnippet": "Func<string> f = () => null!;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, suppresses nullable warning.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_149",
        "title": "Goto Try",
        "description": "Identify jump rule.",
        "codeSnippet": "goto Label; \n try { Label:; } catch {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "Cannot `goto` into a `try` block.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_149",
        "title": "List Pattern Empty",
        "description": "Is [] empty list match?",
        "codeSnippet": "if (list is [])",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, matches empty list.",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_err_150",
        "title": "Ref Struct Async",
        "description": "Identify capture.",
        "codeSnippet": "async Task M(Span<int> s) {}",
        "type": "errorSpotting",
        "language": "csharp",
        "errorLineIndex": 0,
        "explanation": "`ref struct` parameters cannot be used in async methods (state machine capture impossible).",
        "difficultyLevel": 3
    },
    {
        "id": "csharp_tf_150",
        "title": "Field Offset",
        "description": "Can you overlap fields?",
        "codeSnippet": "[FieldOffset(0)] int x; [FieldOffset(0)] float y;",
        "type": "trueOrFalse",
        "language": "csharp",
        "isCodeCorrect": true,
        "explanation": "Yes, using `[StructLayout(LayoutKind.Explicit)]` creates a union.",
        "difficultyLevel": 3
    }
]