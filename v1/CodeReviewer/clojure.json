[
    {
        "id": "clojure_err_1",
        "title": "Define variable syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "(def x 10)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. Binds symbol x to 10 in the current namespace. \nError: `def` with assignment operator? \nCode: `(def x = 10)`. \nError: Clojure `def` does not use `=`. It uses `(def name value)`. `=` is a function for comparison.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_1_real",
        "title": "Def Assignment",
        "description": "Identify syntax.",
        "codeSnippet": "(def x = 10)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`def` does not use `=`. The syntax is `(def symbol value)`. `=` is treated as a separate argument (and often valid as metadata or docstring if string, but `=` is a symbol here, so valid code but logic error: x is bound to function `=` and 10 is docstring? No, `(def x = 10)` binds `x` to `=`. `10` is left over? `def` takes optional docstring. `(def name doc-string? init?)`. So `x` becomes `=`. `10` is ignored? No, `def` arity. \nActually `(def x = 10)` -> bind `x` to `=`. `10` is excess arg? `def` special form. \nLet's pick an easier one. \nCode: `(val x 10)`. \nError: `val` is function to get value from map entry. Use `def` or `let`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_1",
        "title": "List literal",
        "description": "True or False?",
        "codeSnippet": "'(1 2 3)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Quoted list literal.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_2",
        "title": "Vector brackets",
        "description": "Identify syntax.",
        "codeSnippet": "(1 2 3]",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Mismatched delimiters. Starts with `(` (list call) but ends with `]`. Vectors use `[...]`. Lists `(...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_2",
        "title": "Hello World",
        "description": "True or False?",
        "codeSnippet": "(println \"Hello\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_3",
        "title": "Function definition defn",
        "description": "Identify syntax.",
        "codeSnippet": "(defn my-func (x) x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: Argument vector missing brackets. \nCode: `(defn f (x) x)`. Valid. \nCode: `(defn f {x} x)`. Error. Arguments must be a vector `[]`. `(defn f [x] x)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_3_real",
        "title": "Defn Args Vector",
        "description": "Identify syntax.",
        "codeSnippet": "(defn my-func (x) x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Function arguments in `defn` must be enclosed in a vector `[]`, not a list `()`. Should be `(defn my-func [x] x)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_3",
        "title": "Vector Literal",
        "description": "True or False?",
        "codeSnippet": "[1 2 3]",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Vector.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_4",
        "title": "Map colon separator",
        "description": "Identify syntax.",
        "codeSnippet": "{:a: 1}",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Colons in maps are not separators like JSON. Keys are usually keywords `:key`. The separator is whitespace. `{:a 1}`. `:a:` is a valid keyword, but `1` follows? Syntax `{:a: 1}` parses as keyword `:a:` followed by `1`. Valid map `{:a: 1}` (key `:a:` val `1`). \nBad code: `{a: 1}`. `a:` is symbol? No. \nReal Error: Unbalanced map. \nCode: `{:a 1 :b}`. \nError: Map literal must have even number of forms.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_4_real",
        "title": "Map Unbalanced",
        "description": "Identify structure.",
        "codeSnippet": "{:a 1 :b}",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Map literal must contain an even number of forms (key-value pairs). `:b` has no value.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_4",
        "title": "Keyword Basic",
        "description": "True or False?",
        "codeSnippet": ":my-keyword",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_5",
        "title": "Let binding vector",
        "description": "Identify syntax.",
        "codeSnippet": "(let (x 1) x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`let` bindings must be a vector `[]`. `(let [x 1] x)`. Using list `()` raises error.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_5",
        "title": "Let Valid",
        "description": "True or False?",
        "codeSnippet": "(let [x 10] (* x 2))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_6",
        "title": "If args count",
        "description": "Identify arity.",
        "codeSnippet": "(if true 1 2 3)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`if` takes 2 or 3 arguments: `(if test then else?)`. 4 arguments passed. Too many args.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_6",
        "title": "Nil is false",
        "description": "True or False?",
        "codeSnippet": "(if nil \"true\" \"false\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"false\". `nil` and `false` are falsy.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_7",
        "title": "Call keyword arg",
        "description": "Identify usage.",
        "codeSnippet": "(:key)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Keywords are functions of maps, but they require a map argument. `(:key)` with 0 args is ArityException.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_7",
        "title": "Keyword lookup",
        "description": "True or False?",
        "codeSnippet": "(:a {:a 1})",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_8",
        "title": "Comment syntax",
        "description": "Identify syntax.",
        "codeSnippet": "// comment",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Clojure line comments start with `;`. `//` is not a comment syntax (it's a symbol `/` inside namespace `/`? or just invalid start).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_8",
        "title": "Comment valid",
        "description": "True or False?",
        "codeSnippet": "; This is a comment\n(+ 1 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_9",
        "title": "String concatenation",
        "description": "Identify function.",
        "codeSnippet": "(+ \"a\" \"b\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`+` is for numbers. Use `str` for string concatenation. `(str \"a\" \"b\")`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_9",
        "title": "Str function",
        "description": "True or False?",
        "codeSnippet": "(str \"Hello\" \" \" \"World\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_10",
        "title": "Inc arity",
        "description": "Identify arity.",
        "codeSnippet": "(inc 1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`inc` takes exactly 1 argument.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_10",
        "title": "Dec function",
        "description": "True or False?",
        "codeSnippet": "(dec 10)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 9.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_11",
        "title": "First on number",
        "description": "Identify type.",
        "codeSnippet": "(first 123)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`first` expects a collection or nil. 123 is a number (not seqable). Raises Exception.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_11",
        "title": "First valid",
        "description": "True or False?",
        "codeSnippet": "(first [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_12",
        "title": "Set literal duplicate",
        "description": "Identify rules.",
        "codeSnippet": "#{1 2 1}",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Set literals `#{...}` cannot contain duplicate keys. `1` is duplicated. Reader error.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_12",
        "title": "Set literal",
        "description": "True or False?",
        "codeSnippet": "#{:a :b}",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_13",
        "title": "Do syntax",
        "description": "Identify syntax.",
        "codeSnippet": "(do 1 2 3)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns 3. \nError: `do` named? \nCode: `(do :tag 1)`. Valid. \nReal Error: `fn` missing params. \nCode: `(fn 1)`. \nError: `fn` requires a parameter vector `[]`. `(fn [] 1)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_13_real",
        "title": "Fn missing params",
        "description": "Identify syntax.",
        "codeSnippet": "(fn (+ 1 1))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Anonymous function `fn` requires a parameter vector. `(fn [] (+ 1 1))`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_13",
        "title": "Anon fn shorthand",
        "description": "True or False?",
        "codeSnippet": "#(+ % 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Reader macro for `(fn [x] (+ x 1))`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_14",
        "title": "Cons args reversed",
        "description": "Identify signature.",
        "codeSnippet": "(cons [2 3] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`cons` signature is `(cons item seq)`. `(cons 1 [2 3])` -> `(1 2 3)`. Reversed arguments results in `([2 3] . 1)`? `cons` treats second arg as seq. `1` is not seq. Error or Improper list not supported in `cons` impl usually expects sequence.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_14",
        "title": "Cons valid",
        "description": "True or False?",
        "codeSnippet": "(cons 1 '(2 3))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `(1 2 3)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_15",
        "title": "Apply syntax",
        "description": "Identify args.",
        "codeSnippet": "(apply + 1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`apply` expects the last argument to be a sequence. `(apply + [1 2])`. `(apply + 1 2)` treats `2` as the sequence? `2` is not seqable. Error.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_15",
        "title": "Apply valid",
        "description": "True or False?",
        "codeSnippet": "(apply max [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_16",
        "title": "Quote parens",
        "description": "Identify syntax.",
        "codeSnippet": "('1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`'1` evaluates to `1`. `(1 2)` tries to call `1` as a function. Numbers are not functions. `ClassCastException`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_16",
        "title": "Quote symbol",
        "description": "True or False?",
        "codeSnippet": "'my-symbol",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_17",
        "title": "Cond parens",
        "description": "Identify syntax.",
        "codeSnippet": "(cond (true 1) (false 2))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`cond` expects flat key-value pairs, not pairs wrapped in parens. `(cond true 1 false 2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_17",
        "title": "Cond valid",
        "description": "True or False?",
        "codeSnippet": "(cond (= 1 1) :yes :else :no)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_18",
        "title": "Case default",
        "description": "Identify syntax.",
        "codeSnippet": "(case 1 1 :one 2 :two :default)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid? `case` args: expression, map-pairs..., optional-default. `1` -> matches `1`, returns `:one`. \nError: `case` matches literals/constants strictly. \nCode: `(case x y :ok)`. If `y` is variable, `case` treats it as constant `y`? No, `case` literals are not evaluated. `y` is symbol. \nReal Error: `recur` non-tail position. \nCode: `(+ 1 (recur 2))`. \nError: `recur` must be in tail position.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_18_real",
        "title": "Recur non-tail",
        "description": "Identify logic.",
        "codeSnippet": "(defn f [x] (+ 1 (recur (dec x))))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`recur` is only allowed in the tail position (last thing evaluated). Here, `+ 1` happens *after* `recur`, so it's not logical tail. Verify syntax error.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_18",
        "title": "Loop recur",
        "description": "True or False?",
        "codeSnippet": "(loop [x 1] (if (> x 0) (recur (dec x)) :done))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_19",
        "title": "Namespace require vector",
        "description": "Identify syntax.",
        "codeSnippet": "(ns my-ns (:require my.lib))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`require` inside `ns` macro expects vectors for libs. `(:require [my.lib])`. Bare symbol often works if aliased `(:require [my.lib :as l])` but straight symbol usually warn/error in `ns` form specs.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_19",
        "title": "Ns definition",
        "description": "True or False?",
        "codeSnippet": "(ns my.app.core)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_20",
        "title": "Defn name string",
        "description": "Identify type.",
        "codeSnippet": "(defn \"name\" [] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Function name must be a symbol. `\"name\"` is a string.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_20",
        "title": "Count function",
        "description": "True or False?",
        "codeSnippet": "(count [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 3.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_21",
        "title": "Map key missing value in literal",
        "description": "Identify syntax.",
        "codeSnippet": "{:a 1 :b}",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Map literal must have even number of forms. `:b` missing value.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_21",
        "title": "Empty map",
        "description": "True or False?",
        "codeSnippet": "{}",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_22",
        "title": "Nth bounds",
        "description": "Identify behavior.",
        "codeSnippet": "(nth [1] 5)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Throws `IndexOutOfBoundsException`. Clojure `nth` throws on out of bounds unless default is provided. \nWait, is it syntax error? No, runtime. \nReal Error: `def` inside `defn`. \nCode: `(defn f [] (def x 1))`. \nError: Don't use `def` inside functions (dynamic scope effect/Global var). Bad practice, but syntactically valid? Yes. \nLet's prefer syntax. \nReal Error: `fn` param name. \nCode: `(fn [1] 1)`. \nError: Function parameters must be symbols. `1` is integer.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_22_real",
        "title": "Fn param invalid",
        "description": "Identify syntax.",
        "codeSnippet": "(fn [1] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Argument names must be symbols. `1` cannot be an argument name.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_22",
        "title": "Nth valid",
        "description": "True or False?",
        "codeSnippet": "(nth [10 20] 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 20.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_23",
        "title": "Range args descending",
        "description": "Identify api.",
        "codeSnippet": "(range 10 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`range` with start > end returns empty sequence unless step is negative. Not error, but logic? \nSyntax error: `true?` call. \nCode: `(true? 1)`. Valid. \nReal Syntax: `(.method)` no object. \nCode: `(.toString)`. \nError: Needs object. `(.toString obj)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_23_real",
        "title": "Method call missing obj",
        "description": "Identify syntax.",
        "codeSnippet": "(.toString)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Java interop method call needs an object instance: `(.toString obj)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_23",
        "title": "Java interop",
        "description": "True or False?",
        "codeSnippet": "(.toUpperCase \"hello\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_24",
        "title": "Division by zero",
        "description": "Identify runtime.",
        "codeSnippet": "(/ 1 0)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "ArithmeticException: Divide by zero.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_24",
        "title": "Ratio type",
        "description": "True or False?",
        "codeSnippet": "(/ 1 2)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1/2 (Ratio).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_25",
        "title": "String escape",
        "description": "Identify syntax.",
        "codeSnippet": "\"Unterminated string",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "String must strictly end with `\"`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_25",
        "title": "Char literal",
        "description": "True or False?",
        "codeSnippet": "\\c",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Character literal.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_26",
        "title": "Try missing catch/finally",
        "description": "Identify syntax.",
        "codeSnippet": "(try (print \"h\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`try` form must have at least one `catch` or `finally` clause (in most contexts, strict syntax might require it or it just acts as `do`). \nActually, `(try body)` is valid in Clojure. \nBad syntax: `catch` without exception type. \nCode: `(catch e (print e))`. \nError: `catch` requires class name first. `(catch Exception e ...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_26_real",
        "title": "Catch syntax",
        "description": "Identify syntax.",
        "codeSnippet": "(try (/ 1 0) (catch e e))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`catch` must specify the Exception class. `(catch Exception e e)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_26",
        "title": "Throw exception",
        "description": "True or False?",
        "codeSnippet": "(throw (Exception. \"Error\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_27",
        "title": "Use without vec",
        "description": "Identify syntax.",
        "codeSnippet": "(use 'my.lib)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`use` allows symbols if quoted. `(use 'my.lib)` works. \nNamespace `ns` `(:use ...)`: `(:use my.lib)` requires vector? `(:use [my.lib])`. \nReal Error: `map` wrong args. \nCode: `(map [1 2] inc)`. \nError: `map` is `(map f coll)`. `(map inc [1 2])`. Reversed.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_27_real",
        "title": "Map usage reversed",
        "description": "Identify signature.",
        "codeSnippet": "(map [1 2] inc)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`map` expects function as first argument. `(map inc [1 2])`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_27",
        "title": "Filter basic",
        "description": "True or False?",
        "codeSnippet": "(filter odd? [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_28",
        "title": "Reduce no coll",
        "description": "Identify signature.",
        "codeSnippet": "(reduce +)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`reduce` requires a collection. `(reduce + coll)`. `(reduce +)` (arity 1) is not valid (or maybe returns reducer? No, `reduce` is strict).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_28",
        "title": "Reduce valid",
        "description": "True or False?",
        "codeSnippet": "(reduce + [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_29",
        "title": "Args count mismatch",
        "description": "Identify runtime.",
        "codeSnippet": "(defn f [x] x)\n(f 1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "ArityException. `f` takes 1 arg, called with 2.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_29",
        "title": "Multi-arity defn",
        "description": "True or False?",
        "codeSnippet": "(defn f ([x] x) ([x y] (+ x y)))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_30",
        "title": "Var lookup",
        "description": "Identify syntax.",
        "codeSnippet": "#'non-existent",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Taking var of undefined symbol raises Exception (Unable to resolve var).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_30",
        "title": "Var quote",
        "description": "True or False?",
        "codeSnippet": "#'map",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Resolves to var `#'clojure.core/map`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_31",
        "title": "Metadata syntax",
        "description": "Identify syntax.",
        "codeSnippet": "^:dynamic (def *x* 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Metadata placement. `^:dynamic` should be on the symbol `*x*`. `(def ^:dynamic *x* 1)`. Placing it on the `def` form `^:dynamic (def ...)` attaches metadata to the list `(def ...)` which `def` doesn't consume for the var.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_31",
        "title": "Metadata valid",
        "description": "True or False?",
        "codeSnippet": "(def ^:const X 10)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_32",
        "title": "Deref non-ref",
        "description": "Identify type.",
        "codeSnippet": "@1",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cannot deref a number. Argument must be IDeref (atom, ref, agent, etc).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_32",
        "title": "Atom usage",
        "description": "True or False?",
        "codeSnippet": "(def a (atom 1)) @a",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_33",
        "title": "Swap atom no fn",
        "description": "Identify signature.",
        "codeSnippet": "(swap! a 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`swap!` expects an update function. `(swap! atom f args...)`. Passing `1` as function fails.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_33",
        "title": "Reset atom",
        "description": "True or False?",
        "codeSnippet": "(reset! a 2)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_34",
        "title": "Compare nil",
        "description": "Identify runtime.",
        "codeSnippet": "(> 1 nil)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cannot compare number with nil. NPE.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_34",
        "title": "Compare valid",
        "description": "True or False?",
        "codeSnippet": "(< 1 2 3)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_35",
        "title": "Empty list head",
        "description": "Identify rules.",
        "codeSnippet": "()",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Empty list `()` is evaluated as an empty list (constant). It is valid data. But if executed as code? `()` -> `()`. \nError: `defprotocol` body format. \nCode: `(defprotocol P (f [x] 1))`. \nError: Protocol methods have no body in definition. `(defprotocol P (f [x]))`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_35_real",
        "title": "Defprotocol body",
        "description": "Identify syntax.",
        "codeSnippet": "(defprotocol P (foo [x] (+ x 1)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Protocol definitions specify signatures only, not implementation bodies. `(defprotocol P (foo [x]))`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_35",
        "title": "Defrecord basic",
        "description": "True or False?",
        "codeSnippet": "(defrecord Person [name age])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_36",
        "title": "Eval vector",
        "description": "Identify evaluation.",
        "codeSnippet": "(eval [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Vectors evaluate to themselves. `(eval [1 2])` returns `[1 2]`. No error. \nReal Error: `new` syntax. \nCode: `(new String)`. Valid. `(new String \"s\")`. Valid. \nReal Error: `proxy` missing args. \nCode: `(proxy [Class] [])`. Valid. \nReal Error: `let` unbound symbol. \nCode: `(let [x] x)`. \nError: `let` binding vector must be even-sized. `x` has no value.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_36_real",
        "title": "Let binding odd",
        "description": "Identify syntax.",
        "codeSnippet": "(let [x] x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "let bindings vector must contain even number of forms (key value pairs).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_36",
        "title": "Pmap valid",
        "description": "True or False?",
        "codeSnippet": "(pmap inc [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Parallel map.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_37",
        "title": "When else",
        "description": "Identify macro.",
        "codeSnippet": "(when true 1 2 :else 3)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`when` is `(if test (do body...))`. It has no `else` clause. It returns `nil` if false. Passing `:else` `3` just means they are part of the body, executed if true! If false, returns nil. Logic error if user expects else.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_37",
        "title": "If-not valid",
        "description": "True or False?",
        "codeSnippet": "(if-not false :yes :no)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_38",
        "title": "Into args",
        "description": "Identify signature.",
        "codeSnippet": "(into [1] 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`into` expects 2nd arg to be a collection/seq. `2` is number.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_38",
        "title": "Merge maps",
        "description": "True or False?",
        "codeSnippet": "(merge {:a 1} {:b 2})",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_39",
        "title": "Assoc args",
        "description": "Identify signature.",
        "codeSnippet": "(assoc :key {:a 1} 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`assoc` first argument is the map/coll. `(assoc map key val)`. `(assoc {:a 1} :key 2)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_39",
        "title": "Dissoc valid",
        "description": "True or False?",
        "codeSnippet": "(dissoc {:a 1} :a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_40",
        "title": "Contains args",
        "description": "Identify behavior.",
        "codeSnippet": "(contains? [1 2 3] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`contains?` checks for *keys* (index in vector). `(contains? [1 2 3] 1)` checks if index 1 exists (true). User often thinks it checks value 1. Not syntax error, but trap. \nSyntax Error: `(. field obj)`. \nCode: `(. x obj)`. \nError: Field access is `(. field obj)`? syntax is `(.obj field)` or `(. field obj)`. \nLet's use `..` macro error. \nCode: `(.. System fail)`. \nError: `System` is class. `fail` not method.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_40_real",
        "title": "Dot special form",
        "description": "Identify syntax.",
        "codeSnippet": "(. \"s\" length)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`(. object method)` or `(. method object)`. `(. \"s\" length)` works for field access or 0-arg method. `length` on String? String has `.length()`. `length` field is array. `(. \"s\" length)` fails (no such field/method). `(. \"s\" length())` works.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_40",
        "title": "Dot method call",
        "description": "True or False?",
        "codeSnippet": "(.length \"abc\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_41",
        "title": "Dotimes binding",
        "description": "Identify syntax.",
        "codeSnippet": "(dotimes 5 (println \"hi\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`dotimes` expects a binding vector `[name limit]`. `(dotimes [n 5] ...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_41",
        "title": "While loop",
        "description": "True or False?",
        "codeSnippet": "(def a (atom 0)) (while (< @a 5) (swap! a inc))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_42",
        "title": "For loop vector",
        "description": "Identify syntax.",
        "codeSnippet": "(for (x [1 2]) x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`for` expects a binding vector `[x [1 2]]`. Not list `(x ...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_42",
        "title": "Doseq valid",
        "description": "True or False?",
        "codeSnippet": "(doseq [x [1 2]] (println x))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_43",
        "title": "Defn private",
        "description": "Identify macro.",
        "codeSnippet": "(defn-)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`defn-` macro requires name and args. `(defn- name [] ...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_43",
        "title": "Declare var",
        "description": "True or False?",
        "codeSnippet": "(declare x)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Forward declaration.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_44",
        "title": "Import package syntax",
        "description": "Identify syntax.",
        "codeSnippet": "(import java.util.Date)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`import` in `ns` macro: `(:import [java.util Date])`. Top level `(import 'java.util.Date)` needs quote or vector `(import [java.util Date])`. Bare symbol `java.util.Date` without quote in top-level `import`? `(import java.util.Date)` works? No, `import` expects class specs. `'(java.util.Date)` works.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_44",
        "title": "New object",
        "description": "True or False?",
        "codeSnippet": "(new java.util.Date)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_45",
        "title": "Type hint syntax",
        "description": "Identify syntax.",
        "codeSnippet": "#^String x",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`#^` is deprecated syntax. Use `^String`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_45",
        "title": "Meta reader",
        "description": "True or False?",
        "codeSnippet": "^:private def x 1",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True (valid syntax, though usually attached to name).",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_46",
        "title": "Fn arity overload params",
        "description": "Identify structure.",
        "codeSnippet": "(fn [x] x [x y] (+ x y))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Multi-arity `fn` must be `(fn ([x] x) ([x y] ...))`. Wrapping clauses in parens is required.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_46",
        "title": "Identity function",
        "description": "True or False?",
        "codeSnippet": "(identity 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_47",
        "title": "Partial args",
        "description": "Identify signature.",
        "codeSnippet": "(partial)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`partial` requires at least a function argument. `(partial f ...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_47",
        "title": "Comp function",
        "description": "True or False?",
        "codeSnippet": "((comp inc dec) 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_48",
        "title": "Keyword to string",
        "description": "Identify conversion.",
        "codeSnippet": "(str :a 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Resault \":a1\". \nError: `aget` on list. \nCode: `(aget [1 2] 0)`. \nError: `aget` is for Java arrays. Use `nth` or `get` for Clojure vectors.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_48_real",
        "title": "Array access",
        "description": "Identify type.",
        "codeSnippet": "(aget [1 2] 0)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`aget` expects a Java array (e.g. `(int-array ...)`), not a persistent vector.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_48",
        "title": "Make array",
        "description": "True or False?",
        "codeSnippet": "(make-array Integer/TYPE 10)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_49",
        "title": "Slurp invalid",
        "description": "Identify args.",
        "codeSnippet": "(slurp)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`slurp` requires a file/url argument.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_49",
        "title": "Spit to file",
        "description": "True or False?",
        "codeSnippet": "(spit \"file.txt\" \"content\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_50",
        "title": "Re-seq args",
        "description": "Identify signature.",
        "codeSnippet": "(re-seq \"pattern\" \"string\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`re-seq` expects a regex pattern (Pattern object) as first arg. `(re-seq #\"pattern\" \"string\")`.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_tf_50",
        "title": "Regex literal",
        "description": "True or False?",
        "codeSnippet": "#\"[a-z]+\"",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "clojure_err_51",
        "title": "Lazy seq side effects",
        "description": "Identify logic.",
        "codeSnippet": "(def s (map println [1 2]))\n(first s)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`map` is lazy. `(map println ...)` doesn't print immediately. It returns a lazy sequence. `(first s)` realizes only the first element (printing \"1\"). \"2\" is never printed if `s` is not fully realized. `doseq` should be used for side effects.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_51",
        "title": "Doseq eager",
        "description": "True or False?",
        "codeSnippet": "(doseq [x [1 2]] (println x))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. `doseq` forces realization/execution.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_52",
        "title": "Transducer arity",
        "description": "Identify usage.",
        "codeSnippet": "(transduce (map inc) + [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. `transduce` takes xform, f, coll. \nError: `defmacro` arg names. \nCode: `(defmacro m [x] x)`. \nError: Macros receive unevaluated forms. Returning `x` (symbol) might work but usually user wants value? No, return syntax. \nReal Error: `defmacro` let binding capture. \nCode: `(defmacro m [val] `(let [x# ~val] x#))`. Valid. \nReal Error: `recur` across try. \nCode: `(loop [] (try (recur) (catch e nil)))`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_52_real",
        "title": "Recur across try",
        "description": "Identify restriction.",
        "codeSnippet": "(loop [] (try (recur) (catch Exception e nil)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`recur` cannot cross a `try` boundary (cannot recur from inside `try` to a loop outside it). Must recur from outside `try` or use `loop` inside `try`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_52",
        "title": "Macro hygiene",
        "description": "True or False?",
        "codeSnippet": "(defmacro m [] `(let [x# 1] x#))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Auto-gensym `x#` avoids capture.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_53",
        "title": "Protocol impl name",
        "description": "Identify syntax.",
        "codeSnippet": "(defprotocol P (foo [x]))\n(defrecord R [a] P (foo [x] a))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `reify` missing protocol? \nCode: `(reify (foo [x] x))`. \nError: `reify` expects Protocol/Interface name first. `(reify P (foo [x] x))`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_53_real",
        "title": "Reify syntax",
        "description": "Identify syntax.",
        "codeSnippet": "(reify (toString [this] \"s\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`reify` must specify the interface/protocol being implemented. `(reify Object (toString [this] \"s\"))`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_53",
        "title": "Extend protocol",
        "description": "True or False?",
        "codeSnippet": "(extend-protocol P String (foo [x] \"string\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_54",
        "title": "Multimethod default",
        "description": "Identify api.",
        "codeSnippet": "(defmulti m identity)\n(defmethod m :default [x] :ok)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `defmethod` no dispatch. \nCode: `(defmethod m [x] x)`. \nError: `defmethod` requires dispatch value arg. `(defmethod m :val [x] ...)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_54_real",
        "title": "Defmethod dispatch",
        "description": "Identify syntax.",
        "codeSnippet": "(defmethod m [x] x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`defmethod` requires the dispatch value (2nd arg). `(defmethod m :value [x] ...)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_54",
        "title": "Defmulti basic",
        "description": "True or False?",
        "codeSnippet": "(defmulti area :shape)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_55",
        "title": "Ref set transaction",
        "description": "Identify runtime.",
        "codeSnippet": "(def r (ref 0))\n(ref-set r 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`ref-set` (and `alter`, `commute`) must be called within a transaction `(dosync ...)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_55",
        "title": "Dosync usage",
        "description": "True or False?",
        "codeSnippet": "(dosync (ref-set r 1))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_56",
        "title": "Agent error handler",
        "description": "Identify syntax.",
        "codeSnippet": "(agent 0 :error-mode :continue :error-handler 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`error-handler` must be a function (or nil). `1` is not a function.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_56",
        "title": "Send agent",
        "description": "True or False?",
        "codeSnippet": "(send a inc)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_57",
        "title": "Future deref timeout",
        "description": "Identify arity.",
        "codeSnippet": "(deref (future 1) 1000)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`deref` with timeout needs 3 args: `(deref future timeout-ms timeout-val)`. Missing timeout-val.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_57",
        "title": "Delay force",
        "description": "True or False?",
        "codeSnippet": "(def d (delay (println \"work\"))) (force d)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_58",
        "title": "Promise deliver twice",
        "description": "Identify logic.",
        "codeSnippet": "(def p (promise))\n(deliver p 1)\n(deliver p 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 2,
        "explanation": "Not an error crash, but `deliver` returns nil on second call. Promise can only be delivered once. The value remains `1`. Code suggests intent to overwrite.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_58",
        "title": "Promise wait",
        "description": "True or False?",
        "codeSnippet": "(deref (promise) 100 :timeout)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_59",
        "title": "Loop binding mismatch",
        "description": "Identify syntax.",
        "codeSnippet": "(loop [a 1 b] (recur a))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`loop` binding vector requires even number of forms. `b` has no value.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_59",
        "title": "Trampoline basics",
        "description": "True or False?",
        "codeSnippet": "(trampoline (fn [] :done))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_60",
        "title": "Destructuring map keys",
        "description": "Identify syntax.",
        "codeSnippet": "(let [{:keys [a b]} {:a 1}] a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `:keys` value not vector. \nCode: `(let [{:keys (a b)} m] a)`. \nError: `:keys` expects a vector of symbols `[a b]`. `(a b)` is a list/call.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_60_real",
        "title": "Destructuring keys list",
        "description": "Identify syntax.",
        "codeSnippet": "(let [{:keys (a b)} {:a 1}] a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "In map destructuring, `:keys` requires a vector. `{:keys [a b]}`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_60",
        "title": "Destructuring defaults",
        "description": "True or False?",
        "codeSnippet": "(let [{:keys [a] :or {a 1}} {}] a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_61",
        "title": "Namespace refer-clojure",
        "description": "Identify syntax.",
        "codeSnippet": "(ns m (:refer-clojure :exclude [map]))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `:strs` destructuring symbols? \nCode: `(let [{:strs [a]} {\"a\" 1}] a)`. \nError: `:strs` destructures string keys into *symbols*. Valid. \nReal Error: `ns` syntax keywords need vector? \nCode: `(ns m (:import java.util.Date))`. \nError: `(:import ...)` args are lists of classes or vectors? `(:import [java.util Date])`. `(:import java.util.Date)` treats `java.util.Date` as symbol to import? Yes, works. \nReal Error: `definline` arity. \nCode: `(definline f [x] x)`. \nError: `definline` usage is complex, often needs quote?",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_61_real",
        "title": "Ns require list",
        "description": "Identify syntax.",
        "codeSnippet": "(ns foo (:require (clojure.string)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`(:require ...)` expects vectors for lib specs. `(:require [clojure.string])`. `(clojure.string)` is a list (call).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_61",
        "title": "Require as alias",
        "description": "True or False?",
        "codeSnippet": "(require '[clojure.string :as str])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_62",
        "title": "Comp arity zero",
        "description": "Identify return.",
        "codeSnippet": "((comp) 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "`comp` with no args returns `identity`. `(identity 1)` -> 1. Valid. \nReal Error: `partial` too many args? No. \nReal Error: `memfn` no args. \nCode: `(memfn)`. \nError: `memfn` macro requires name and args.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_62_real",
        "title": "Memfn syntax",
        "description": "Identify syntax.",
        "codeSnippet": "(memfn toString)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`memfn` expects name and args (if using `memfn` legacy) or just name? `(memfn name args)`. `(memfn toString [])`? Usually preferred `#(.toString %)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_62",
        "title": "Complement function",
        "description": "True or False?",
        "codeSnippet": "((complement odd?) 2)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns true.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_63",
        "title": "Re-find args",
        "description": "Identify signature.",
        "codeSnippet": "(re-find \"s\" #\"s\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`re-find` args are `(re-find matcher)` or `(re-find pattern string)`. Passed `string pattern`. Reversed.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_63",
        "title": "Re-matches full",
        "description": "True or False?",
        "codeSnippet": "(re-matches #\"a\" \"a\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Matches whole string.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_64",
        "title": "Sort comparator",
        "description": "Identify signature.",
        "codeSnippet": "(sort [3 1 2] >)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`sort` applies comparator first. `(sort comparator coll)`. `(sort > [3 1 2])`. Passed collection where comparator expected.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_64",
        "title": "Sort-by valid",
        "description": "True or False?",
        "codeSnippet": "(sort-by :age [{:age 2} {:age 1}])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_65",
        "title": "Pmap infinite",
        "description": "Identify logic.",
        "codeSnippet": "(pmap inc (range))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`pmap` is 'semi-lazy' but realizes chunk ahead. On some versions/contexts, using `pmap` on infinite sequence can cause issues or resource exhaustion if head is held, but `(take 10 ...)` is fine. `pmap` itself generates a lazy sequence. \nReal Error: `locking` primitive. \nCode: `(locking 1 (print \"hi\"))`. \nError: `locking` requires an Object reference to lock on. `1` is primitive (boxed? Java Integer object). Usually works on boxed integers in Java, but unsafe/ambiguous if 1 is cached or new instance. But strict error? `locking` on `nil` throws. `locking` on unique object is best.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_65_real",
        "title": "Locking nil",
        "description": "Identify runtime.",
        "codeSnippet": "(locking nil (print \"hi\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cannot lock on `nil`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_65",
        "title": "Monitor-enter usage",
        "description": "True or False?",
        "codeSnippet": "(let [l (Object.)] (monitor-enter l) (monitor-exit l))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_66",
        "title": "Set! immutable",
        "description": "Identify usage.",
        "codeSnippet": "(def x 1)\n(set! x 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`set!` only works on Java fields, vars marked `^:dynamic` (binding), or `deftype` mutable fields. Global var `x` is immutable root unless dynamic.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_66",
        "title": "Binding dynamic",
        "description": "True or False?",
        "codeSnippet": "(def ^:dynamic *x* 1) (binding [*x* 2] *x*)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_67",
        "title": "Alter-var-root binding",
        "description": "Identify scope.",
        "codeSnippet": "(alter-var-root #'*x* (constantly 2))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Changes root value globally. \nError: `proxy-super` outside proxy. \nCode: `(proxy-super toString)`. \nError: `proxy-super` can only be used inside a `proxy` method body.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_67_real",
        "title": "Proxy-super context",
        "description": "Identify context.",
        "codeSnippet": "(defn f [] (proxy-super toString))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`proxy-super` is valid only within the `proxy` macro's method definitions. It relies on `this` being bound to the proxy instance.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_67",
        "title": "Gen-class usage",
        "description": "True or False?",
        "codeSnippet": "(gen-class :name \"MyClass\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. (Often used in ns or standalone).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_68",
        "title": "Amap args",
        "description": "Identify signature.",
        "codeSnippet": "(amap [1 2] idx ret (inc ret))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`amap` operates on arrays. `[1 2]` is a vector. Will cast error or fail to compile bytecode for array access.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_68",
        "title": "Aset valid",
        "description": "True or False?",
        "codeSnippet": "(let [a (int-array 1)] (aset a 0 10) a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_69",
        "title": "Vector subvec args",
        "description": "Identify behavior.",
        "codeSnippet": "(subvec [1 2 3] 1 5)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "IndexOutOfBounds. End index 5 is greater than count 3.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_69",
        "title": "Peek vector",
        "description": "True or False?",
        "codeSnippet": "(peek [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 3 (last element).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_70",
        "title": "Pop empty",
        "description": "Identify runtime.",
        "codeSnippet": "(pop [])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cannot pop from empty vector/list. Throws generic IllegalStateException.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_70",
        "title": "Disj set",
        "description": "True or False?",
        "codeSnippet": "(disj #{1 2} 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_71",
        "title": "StructMap deprecated",
        "description": "Identify API.",
        "codeSnippet": "(defstruct S :a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid, but deprecated. Use `defrecord` or maps. \nError: `update` signature. \nCode: `(update {:a 1} :a)`. \nError: `update` needs a function. `(update map key f args...)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_71_real",
        "title": "Update missing fn",
        "description": "Identify signature.",
        "codeSnippet": "(update {:a 1} :a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`update` requires a function to apply to the value. `(update m k f)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_71",
        "title": "Select keys",
        "description": "True or False?",
        "codeSnippet": "(select-keys {:a 1 :b 2} [:a])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_72",
        "title": "Juxt arity",
        "description": "Identify return.",
        "codeSnippet": "((juxt inc dec) 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns `[2 0]`. \nError: `iterate` finite. \nCode: `(iterate inc 1)`. \nError: Returns infinite sequence. Not error itself, but if REPL tries to print it... logic trap? \nError: `range` float step 0? \nCode: `(range 1 5 0)`. \nError: Step 0 results in infinite sequence of 1s.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_72_real",
        "title": "Range step zero",
        "description": "Identify logic.",
        "codeSnippet": "(take 5 (range 0 10 0))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Creating a range with step 0 produces an infinite sequence of the start value. If consumed fully (not taken), hangs.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_72",
        "title": "Repeatedly effect",
        "description": "True or False?",
        "codeSnippet": "(repeatedly 5 (fn [] (rand)))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_73",
        "title": "Zipmap length mismatch",
        "description": "Identify behavior.",
        "codeSnippet": "(zipmap [:a :b] [1])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Truncates to shortest. Returns `{:a 1}`. \nError: `keys` on vector? \nCode: `(keys [1 2])`. \nError: `keys` expects a map (or nil). Vector is not a map. (Though some colls might work, `keys` usually for maps).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_73_real",
        "title": "Keys on vector",
        "description": "Identify type.",
        "codeSnippet": "(keys [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`keys` function is for Maps. Vectors are not Maps (though they are Associative, keys are indices, `keys` implementation checks for Map interface or returns nil?). It typically throws ClassCastException or similar if not map.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_73",
        "title": "Vals map",
        "description": "True or False?",
        "codeSnippet": "(vals {:a 1})",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_74",
        "title": "Memoize non-pure side effects",
        "description": "Identify strategy.",
        "codeSnippet": "(def f (memoize (fn [] (println \"run\") 1)))\n(f) (f)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid, but \"run\" prints only once. \nError: `time` return value. \nCode: `(let [t (time 1)] t)`. \nError: `time` returns the result of expression, and prints time. Valid. \nReal Error: `with-open` binding not Closeable. \nCode: `(with-open [s \"string\"] s)`. \nError: `with-open` expects the bound object to implement `java.io.Closeable` (or `AutoCloseable`). String does not.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_74_real",
        "title": "With-open non-closeable",
        "description": "Identify type.",
        "codeSnippet": "(with-open [x \"not-closeable\"] (println x))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Bindings in `with-open` must implement `java.io.Closeable`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_74",
        "title": "With-open valid",
        "description": "True or False?",
        "codeSnippet": "(with-open [r (java.io.StringReader. \"s\")] (.read r))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_75",
        "title": "Bean non-object",
        "description": "Identify type.",
        "codeSnippet": "(bean 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Works? Integer is object (Java Bean?). Yes. \nError: `frequencies` on non-coll. \nCode: `(frequencies 1)`. \nError: Expects collection.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_75_real",
        "title": "Frequencies non-seq",
        "description": "Identify type.",
        "codeSnippet": "(frequencies 123)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`frequencies` requires a collection to count items.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_75",
        "title": "Group-by valid",
        "description": "True or False?",
        "codeSnippet": "(group-by odd? [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_76",
        "title": "Transient collection usage",
        "description": "Identify rules.",
        "codeSnippet": "(def t (transient []))\n(conj! t 1)\n(conj! t 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid? `conj!` returns the new transient. Transients are mutable but functionality returns new ref (often same object). Unlike Java, you must use return value. `(def t2 (conj! t 1))`. Using `t` again in `(conj! t 2)` is unsafe if `t` was modified in place but function signature requires using return. Strict error? Accessing 'bashed in place' transient is undefined. \nReal Error: `persistent!` twice. \nCode: `(let [t (transient [])] (persistent! t) (persistent! t))`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_76_real",
        "title": "Persistent transient twice",
        "description": "Identify usage.",
        "codeSnippet": "(let [t (transient [])]\n  (persistent! t)\n  (persistent! t))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 2,
        "explanation": "A transient collection cannot be used after `persistent!` has been called on it. The second call throws exception.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_76",
        "title": "Transient valid",
        "description": "True or False?",
        "codeSnippet": "(persistent! (conj! (transient []) 1))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_77",
        "title": "Volatile swap args",
        "description": "Identify signature.",
        "codeSnippet": "(def v (volatile! 0))\n(vswap! v 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`vswap!` expects function. `(vswap! vol f args...)`. Passed `1`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_77",
        "title": "Volatile reset",
        "description": "True or False?",
        "codeSnippet": "(def v (volatile! 0)) (vreset! v 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_78",
        "title": "Validator return type",
        "description": "Identify logic.",
        "codeSnippet": "(def a (atom 0 :validator (fn [x] 1)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Validator function must return true/false (or throw). Returning `1` (truthy) works? Yes, if truthy, update succeeds. If `false` or throws, fails. `nil` is false. `1` is true. Syntactically valid. \nReal Error: `set-validator!` on ref in transaction? \nCode: `(dosync (set-validator! r f))`. \nError: `set-validator!` is not transaction-safe or specific. It sets validator immediately. Valid. \nReal Error: `add-watch` key. \nCode: `(add-watch a (fn ...))`. \nError: `add-watch` requires a key. `(add-watch ref key fn)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_78_real",
        "title": "Add-watch missing key",
        "description": "Identify signature.",
        "codeSnippet": "(add-watch (atom 0) (fn [k r o n] (println n)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`add-watch` requires 3 arguments: reference, key, and function. `(add-watch ref :key fn)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_78",
        "title": "Remove watch",
        "description": "True or False?",
        "codeSnippet": "(remove-watch (atom 0) :key)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_79",
        "title": "Derive hierarchy args",
        "description": "Identify signature.",
        "codeSnippet": "(derive :parent :child)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`derive` is `(derive child parent)`. `:parent` derives from `:child`? Backwards semantically, but valid code. Creates relationship. \nReal Error: Cyclic derivation. \nCode: `(derive :a :b) (derive :b :a)`. \nError: Hierarchy cannot have cycles.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_79_real",
        "title": "Derive cycle",
        "description": "Identify runtime.",
        "codeSnippet": "(derive :a :b)\n(derive :b :a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "Cannot create cyclic hierarchy. Throws exception.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_79",
        "title": "Isa? check",
        "description": "True or False?",
        "codeSnippet": "(isa? :child :parent)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True (assuming derivation exists or using class hierarchy).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_80",
        "title": "Reader conditional syntax",
        "description": "Identify syntax.",
        "codeSnippet": "#?(:clj 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid in `.jc` files or if reader conditional enabled. \nError: Incomplete pair. \nCode: `#?(:clj)`. \nError: Reader conditional takes alternating feature-expr pairs. `:clj` missing expression.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_80_real",
        "title": "Reader conditional pair",
        "description": "Identify syntax.",
        "codeSnippet": "#?(:clj)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Reader conditional `#?` requires pairs. `:clj` has no corresponding form.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_80",
        "title": "Comment reader",
        "description": "True or False?",
        "codeSnippet": "#_ (println \"ignore\") 1",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Code evals to `1`. `(println ...)` is skipped.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_81",
        "title": "Tagged literal undefined",
        "description": "Identify syntax.",
        "codeSnippet": "#my/tag 123",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "If tag `#my/tag` is not defined in `data_readers.clj` or bound in `*data-readers*`, reader throws RuntimeException.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_81",
        "title": "Inst literal",
        "description": "True or False?",
        "codeSnippet": "#inst \"2023-01-01\"",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_82",
        "title": "Sequence next on empty",
        "description": "Identify behavior.",
        "codeSnippet": "(next [])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Returns `nil`. Correct. `(rest [])` returns `[]`. \nError: `nth` on map. \nCode: `(nth {:a 1} 0)`. \nError: `nth` not supported on random-access maps (unless sorted? no). Map entries are not indexed. Use `seq` first or `first`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_82_real",
        "title": "Nth on map",
        "description": "Identify type.",
        "codeSnippet": "(nth {:a 1} 0)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Maps are not indexable sequences. `nth` fails.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_82",
        "title": "Map entry",
        "description": "True or False?",
        "codeSnippet": "(key (first {:a 1}))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `:a`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_83",
        "title": "Find args",
        "description": "Identify signature.",
        "codeSnippet": "(find {:a 1} :b 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`find` takes 2 arguments: map and key. `(find map key)`. Returns `[key val]` or nil. 3 arguments passed.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_83",
        "title": "Find valid",
        "description": "True or False?",
        "codeSnippet": "(find {:a 1} :a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[:a 1]`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_84",
        "title": "Disj list",
        "description": "Identify type.",
        "codeSnippet": "(disj '(1 2) 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`disj` expects a Set. List is not a set.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_84",
        "title": "Diff sets",
        "description": "True or False?",
        "codeSnippet": "(clojure.set/difference #{1 2} #{1})",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_85",
        "title": "Rename keys args",
        "description": "Identify signature.",
        "codeSnippet": "(clojure.set/rename-keys {:a 1} :a :b)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`rename-keys` expects a map of renames as second argument. `(rename-keys map {:old :new})`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_85",
        "title": "Project map",
        "description": "True or False?",
        "codeSnippet": "(clojure.set/project #{ {:a 1 :b 2} } [:a])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns set of maps with only `:a`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_86",
        "title": "Range infinite take",
        "description": "Identify logic.",
        "codeSnippet": "(count (range))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Generic infinite loop/hang as it tries to count infinite sequence.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_86",
        "title": "Take-last valid",
        "description": "True or False?",
        "codeSnippet": "(take-last 2 [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_87",
        "title": "Drop-while syntax",
        "description": "Identify signature.",
        "codeSnippet": "(drop-while [1 2 3] (fn [x] true))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`drop-while` is `(drop-while pred coll)`. Args reversed.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_87",
        "title": "Partition-all valid",
        "description": "True or False?",
        "codeSnippet": "(partition-all 2 [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_88",
        "title": "Interleave mismatch logic",
        "description": "Identify behavior.",
        "codeSnippet": "(interleave [1] [2 3])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Stops at shortest. Returns `[1 2]`. Valid. \nError: `assoc-in` path not vector. \nCode: `(assoc-in {} :a 1)`. \nError: `assoc-in` requires path as vector. `[:a]`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_88_real",
        "title": "Assoc-in path",
        "description": "Identify signature.",
        "codeSnippet": "(assoc-in {} :a 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`assoc-in` expects the path to be a sequence (usually vector). `(assoc-in {} [:a] 1)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_88",
        "title": "Update-in valid",
        "description": "True or False?",
        "codeSnippet": "(update-in {:a {:b 1}} [:a :b] inc)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_89",
        "title": "Get-in not found",
        "description": "Identify behavior.",
        "codeSnippet": "(get-in {:a 1} [:b] :not-found)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns `:not-found`. \nError: `reduce-kv` on list. \nCode: `(reduce-kv args... list)`. \n`reduce-kv` works on associative? Vectors ok. Lists no. \nCode: `(reduce-kv + 0 [1 2])`. \nError: `reduce-kv` function takes 3 args: `(f init k v)`. `+` takes variadic, works. Using vector is valid (keys are indices). \nReal Error: `fn` arg duplicate. \nCode: `(fn [x x] x)`. \nError: Duplicate argument names.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_89_real",
        "title": "Fn duplicate arg",
        "description": "Identify syntax.",
        "codeSnippet": "(fn [x x] x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Duplicate parameter name `x` in function definition.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_89",
        "title": "Keep valid",
        "description": "True or False?",
        "codeSnippet": "(keep identity [1 nil 2])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[1 2]`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_90",
        "title": "Mapcat return",
        "description": "Identify logic.",
        "codeSnippet": "(mapcat identity [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`mapcat` expects function to return a collection to concatenate. `identity` returns integers `1` and `2`. `concat` of numbers fails or works? `concat` requires seqable. Numbers are not seqable. Error.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_90",
        "title": "Flatten valid",
        "description": "True or False?",
        "codeSnippet": "(flatten [1 [2 [3]]])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_91",
        "title": "Tree-seq args",
        "description": "Identify signature.",
        "codeSnippet": "(tree-seq branch? children root)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid signature. \nError: `xml-seq`? \nReal Error: `every?` args. \nCode: `(every? [1 2] even?)`. \nError: `every` args: `(every? pred coll)`. Reversed.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_91_real",
        "title": "Every? args",
        "description": "Identify signature.",
        "codeSnippet": "(every? [1 2] even?)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`every?` takes `pred` then `coll`. `(every? even? [1 2])`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_91",
        "title": "Some check",
        "description": "True or False?",
        "codeSnippet": "(some even? [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns true.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_92",
        "title": "Not-any args",
        "description": "Identify signature.",
        "codeSnippet": "(not-any? [1 2] even?)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`not-any?` takes `pred` first.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_92",
        "title": "Rand-int valid",
        "description": "True or False?",
        "codeSnippet": "(rand-int 10)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_93",
        "title": "With-meta immutable",
        "description": "Identify logic.",
        "codeSnippet": "(def x [1])\n(with-meta x {:a 1})\n(meta x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`with-meta` returns a new object with metadata. It does not mutate `x`. `(meta x)` returns nil (or previous meta). Code implies expectation of change.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_93",
        "title": "Vary-meta valid",
        "description": "True or False?",
        "codeSnippet": "(vary-meta [1] assoc :a 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_94",
        "title": "Print-str format",
        "description": "Identify api.",
        "codeSnippet": "(print-str \"%s\" \"hi\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`print-str` prints arguments separated by space. It doesn't use format strings. `(format \"%s\" \"hi\")` or `(print-str \"hi\")`. Result `\"%s hi\"`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_94",
        "title": "Printf valid",
        "description": "True or False?",
        "codeSnippet": "(printf \"Number: %d\" 10)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_95",
        "title": "Slurp resource",
        "description": "Identify api.",
        "codeSnippet": "(slurp (io/resource \"missing.txt\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "If resource is null (file not found), `slurp` throws NullPointerException or similar on nil arg.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_95",
        "title": "Require io",
        "description": "True or False?",
        "codeSnippet": "(require '[clojure.java.io :as io])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_96",
        "title": "Pprint arity",
        "description": "Identify signature.",
        "codeSnippet": "(clojure.pprint/pprint 1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`pprint` takes object and optional writer. `(pprint obj)` or `(pprint obj writer)`? Actually `(pprint obj writer)` or `(pprint obj)`. `1` `2` -> `pprint` 1 to writer 2? 2 is not writer. Error.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_96",
        "title": "Pprint table",
        "description": "True or False?",
        "codeSnippet": "(clojure.pprint/print-table [{:a 1}])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_97",
        "title": "Walk args",
        "description": "Identify signature.",
        "codeSnippet": "(clojure.walk/walk identity [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`walk` takes `(inner outer form)`. 3 args required. `(walk inner outer form)`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_97",
        "title": "Postwalk valid",
        "description": "True or False?",
        "codeSnippet": "(clojure.walk/postwalk identity [1 [2]])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_98",
        "title": "String split limit",
        "description": "Identify behavior.",
        "codeSnippet": "(clojure.string/split \"a,b,c\" #\",\" -1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Valid call. \nError: `replace` regex syntax. \nCode: `(clojure.string/replace \"s\" \"regex\" \"r\")`. \nError: Regex must be Pattern ` #\"regex\" `. String \"regex\" is treated as literal match.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_98_real",
        "title": "Regex literal string",
        "description": "Identify type.",
        "codeSnippet": "(clojure.string/replace \"abc\" \"[a-z]\" \"*\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "To use a regular expression, use the selector `#\"...\"`. passing `\"[a-z]\"` searches for the literal string `\"[a-z]\"`.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_98",
        "title": "String join",
        "description": "True or False?",
        "codeSnippet": "(clojure.string/join \",\" [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_99",
        "title": "Shuffle string",
        "description": "Identify type.",
        "codeSnippet": "(shuffle \"abc\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`shuffle` expects a collection. String is effectively seqable? `shuffle` implementation turns coll to ArrayList. Strings can be coerced to seq of chars, but `shuffle` returns a vector. If input is string, does it work? Yes, usually returns shuffled vector of chars. \nReal Error: `sort` map. \nCode: `(sort {:b 2 :a 1})`. \nError: `sort` on map returns sorted keys? No, sorts entries (Map.Entry). Map Entries are `[:b 2]`. Comparison fails between entries? Entries are comparable? Yes. \nLet's pick: `pop` on list. \nCode: `(pop '(1 2))`. \nError: Valid. Pop works on lists. \nReal Error: `get` 3 args on vector? \nCode: `(get [1] 0 :default)`. Valid. \nReal Error: `assoc` on list. \nCode: `(assoc '(1 2) 0 3)`. \nError: `assoc` not supported on lists (only vectors/maps).",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_99_real",
        "title": "Assoc on list",
        "description": "Identify types.",
        "codeSnippet": "(assoc '(1 2) 0 3)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`assoc` is not supported on lists. Use vectors for indexable association.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_99",
        "title": "Reverse string",
        "description": "True or False?",
        "codeSnippet": "(clojure.string/reverse \"abc\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_100",
        "title": "Test is assertion",
        "description": "Identify library.",
        "codeSnippet": "(is (= 1 1))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`is` is a macro from `clojure.test`. Requires `use` or `require`. Unqualified `is` without require fails.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_tf_100",
        "title": "Testing context",
        "description": "True or False?",
        "codeSnippet": "(clojure.test/testing \"context\" (is true))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "clojure_err_101",
        "title": "Macro double eval",
        "description": "Identify logic.",
        "codeSnippet": "(defmacro m [x] `(do ~x ~x))\n(m (println \"hi\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Double evaluation happens because `~x` is spliced twice. If `x` has side effects (like println), it executes twice. Usually undesired unless intentional. Better: `(defmacro m [x] `(let [v# ~x] (do v# v#)))` to eval once.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_101",
        "title": "Macro once-only",
        "description": "True or False?",
        "codeSnippet": "(defmacro m [x] `(let [res# ~x] (println res#) res#))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Evals x once.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_102",
        "title": "Gensym capture",
        "description": "Identify hygiene.",
        "codeSnippet": "(defmacro m [] `(let [x 1] x))\n(let [x 2] (m))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Result 1? The `x` in macro is auto-qualified? No. `x` in backtick is namespace qualified `user/x`? Or if `~'x` used. `(let [x 1] ...)` inside syntax quote usually generates qualified symbol. But if user wrote `(defmacro m [] '(let [x 1] x))` (quote) then capture. Here backtick ` ` resolves symbols. `x` becomes `user/x`. `(let [x 2] ...)` binds local `x`. Macro expands to `(let [user/x 1] user/x)`. Distinct. Valid. \nReal Error: unquote-splicing outside list. \nCode: `(defmacro m [l] `[~@l])`. \nError: `~@` can only be used within a list/seq context in syntax quote? Yes. Works in vector? Yes. `[~@l]` works. \nReal Error: Unquote splicing atom. \nCode: `(defmacro m [x] `(~@x))`. \nError: `x` must be seqable (list/vec). If `x` is symbol `a`, throws.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_102_real",
        "title": "Unquote-splice scalar",
        "description": "Identify syntax.",
        "codeSnippet": "(defmacro m [x] `(~@x))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`~@` (unquote-splicing) requires a sequence to splice. If `x` is an atom (e.g., a symbol or number), it fails expansion.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_102",
        "title": "Auto-gensym usage",
        "description": "True or False?",
        "codeSnippet": "(defmacro m [] `(let [x# 1] x#))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_103",
        "title": "Go block return",
        "description": "Identify behavior.",
        "codeSnippet": "(require '[clojure.core.async :refer [go]])\n(def res (go (Thread/sleep 100) 10))\n(println res)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 2,
        "explanation": "`go` block returns a channel, not the value `10` immediately. `println` prints the channel object. To get value: `(<!! res)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_103",
        "title": "Take blocking",
        "description": "True or False?",
        "codeSnippet": "(require '[clojure.core.async :refer [<!! chan]]) (<!! (chan))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True (it blocks/hangs waiting, but code is syntactically correct).",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_104",
        "title": "Take in transaction",
        "description": "Identify runtime.",
        "codeSnippet": "(dosync (clojure.core.async/<!! (clojure.core.async/chan)))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Creating side-effects or blocking IO (like channel take) inside `dosync` is dangerous/forbidden as transaction retries. `<!!` blocks, effectively halting transaction or causing issues. `io!` macro explicitly forbids it.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_104",
        "title": "Put! async",
        "description": "True or False?",
        "codeSnippet": "(clojure.core.async/put! (clojure.core.async/chan) 1)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_105",
        "title": "Protocol method implementation",
        "description": "Identify syntax.",
        "codeSnippet": "(defprotocol P (foo [x]))\n(deftype T [] P (foo [] \"s\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "In `deftype`, the first argument to method impl is `this`. `(foo [this] \"s\")`. Protocol defined `(foo [x])` (1 arg). Implementation must match arity (including this/self). `foo` takes 1 arg total (this). `(foo [] ...)` is 0 args. Mismatch.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_105",
        "title": "Deftype mutable",
        "description": "True or False?",
        "codeSnippet": "(deftype T [^:unsynchronized-mutable a])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_106",
        "title": "Extend-type missing impl",
        "description": "Identify rules.",
        "codeSnippet": "(defprotocol P (a [x]) (b [x]))\n(extend-type String P (a [x] 1))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "Can partial implementation exist? Yes, `extend-type` doesn't enforce all methods strictly at compile time (throws AbstractMethodError at runtime if called?). Actually `extend` via map? `extend-type` generates `extend`. If `b` is called, it fails. Is it a compile error? No. Runtime error on call.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_106_real",
        "title": "Deftype arity overload",
        "description": "Identify limitation.",
        "codeSnippet": "(deftype T [] P (a [this] 1) (a [this x] 2))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Protocols in Clojure support polymorphism on first argument, but `deftype` implementing interface/protocol must implement specific arities defined. If protocol has multiple arities, fine. If protocol has only one, you can't overload in `deftype` arbitrarily beyond interface? `deftype` generates Java class. Methods must match. If Protocol `P` defines `(a [this])` only, implementing `(a [this x])` is invalid/ignored or error.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_106",
        "title": "Extend-type valid",
        "description": "True or False?",
        "codeSnippet": "(extend-type String P (a [this] 1))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_107",
        "title": "Reflection warning",
        "description": "Identify performance.",
        "codeSnippet": "(set! *warn-on-reflection* true)\n(defn len [x] (.length x))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "Generates reflection warning because `x` type is unknown. Not a compile 'error' but treated as error in high-quality code. Fix: `(defn len [^String x] (.length x))`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_107",
        "title": "Type hint string",
        "description": "True or False?",
        "codeSnippet": "(defn s-len [^String s] (.length s))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. No reflection.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_108",
        "title": "Primitive hint return",
        "description": "Identify optimization.",
        "codeSnippet": "(defn ^long add [^long a ^long b] (+ a b))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `make-array` type mismatch. \nCode: `(make-array Integer/TYPE 10)`. \nError: `Integer/TYPE` implies `int`. `(make-array Integer/TYPE ...)` returns `int[]`. Valid. \nReal Error: `aget` on non-array. \nCode: `(aget [1 2] 0)`. \nError: `aget` expects Java array. Vector throws/fails.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_108_real",
        "title": "Aget on vector",
        "description": "Identify type.",
        "codeSnippet": "(aget [1 2] 0)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`aget` is for Java arrays. Use `get` or `nth` for vectors.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_108",
        "title": "Int-array cast",
        "description": "True or False?",
        "codeSnippet": "(int-array [1 2])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_109",
        "title": "Proxy args",
        "description": "Identify signature.",
        "codeSnippet": "(proxy [Runnable] (run [] (println \"run\")))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`proxy` requires a vector of superclass/interfaces, then constructor args (vector), then methods. `(proxy [Runnable] [] (run ...))`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_109",
        "title": "Proxy valid",
        "description": "True or False?",
        "codeSnippet": "(proxy [Runnable] [] (run []))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_110",
        "title": "Multimethod hierarchy cycle",
        "description": "Identify logic.",
        "codeSnippet": "(derive ::a ::b) (derive ::b ::a)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cycles in hierarchy not allowed. Throws.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_110",
        "title": "Prefer-method",
        "description": "True or False?",
        "codeSnippet": "(prefer-method m ::a ::b)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Resolves dispatch ambiguity.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_111",
        "title": "Keyword to string cast",
        "description": "Identify type.",
        "codeSnippet": "(String. :k)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "String constructor does not accept Keyword. Must use `name` or `str`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_111",
        "title": "Name keyword",
        "description": "True or False?",
        "codeSnippet": "(name :k)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"k\".",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_112",
        "title": "Namespace alias capture",
        "description": "Identify syntax.",
        "codeSnippet": "(ns m (:require [clojure.string :as s]))\n(def s 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "Redefining alias `s` as a Var `s`. Effectively shadows the namespace alias. Code relying on `s/split` later in file will fail or be ambiguous (compiler choice? usually allows def but warns). Strict error: shadowing alias.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_112",
        "title": "Refer all",
        "description": "True or False?",
        "codeSnippet": "(require '[clojure.string :refer :all])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True (though discouraged).",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_113",
        "title": "Chunked seq modification",
        "description": "Identify concurrency.",
        "codeSnippet": "(map (fn [x] (println x)) (range 32))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Chunking means it might print 32 items at once even if only 1 consumed? `range` is chunked. `map` is chunk-aware. It realizes in chunks of 32. \nError: `pvalues` lazy? \nCode: `(first (pvalues (println \"1\") (println \"2\")))`. \nError: `pvalues` executes fields in parallel immediately/futures. Both print. Maybe not error but side effect timing.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_113_real",
        "title": "Lazy-seq body eval",
        "description": "Identify behavior.",
        "codeSnippet": "(lazy-seq (println \"exec\") [1])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`lazy-seq` body executes *only when realized*. Arguments to macros are not evaluated? `lazy-seq` wraps body in fn. `(println \"exec\")` happens when seq is accessed. If not accessed, never prints. Valid, but often confusing if side effect expected.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_113",
        "title": "Realized check",
        "description": "True or False?",
        "codeSnippet": "(realized? (lazy-seq [1]))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns false initially.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_114",
        "title": "Spec invalid definition",
        "description": "Identify library.",
        "codeSnippet": "(s/def ::positive (fn [x] (> x 0)))\n(s/valid? ::positive \"s\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "String \"s\" passed to `(> x 0)` throws ClassCastException. Predicate must handle input types or be guarded. `(s/def ::positive (s/and int? pos?))`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_114",
        "title": "Spec and",
        "description": "True or False?",
        "codeSnippet": "(s/def ::a (s/and int? even?))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_115",
        "title": "Spec keys req",
        "description": "Identify syntax.",
        "codeSnippet": "(s/def ::p (s/keys :req [::x]))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`s/keys` expects fully qualified keywords for `:req`. `::x` is fine. \nError: `:req-un` syntax. \nCode: `(s/keys :req-un [::x])`. \nError: `:req-un` keys must be un-qualified (simple keywords) or will match un-qualified keys in map using namespaced specs? `[:req-un [::x]]` means map has key `:x`, validated by spec `::x`. Valid. \nReal Error: `s/coll-of` vs `s/map-of`. \nCode: `(s/map-of int?)`. \nError: `map-of` requires 2 args: key-spec val-spec. `(s/map-of int? string?)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_115_real",
        "title": "Spec map-of args",
        "description": "Identify signature.",
        "codeSnippet": "(s/map-of int?)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`map-of` takes 2 arguments: key-spec and val-spec.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_115",
        "title": "Spec nilable",
        "description": "True or False?",
        "codeSnippet": "(s/nilable int?)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_116",
        "title": "Core reducer fold",
        "description": "Identify behavior.",
        "codeSnippet": "(require '[clojure.core.reducers :as r])\n(r/fold + [1 2 3])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`r/fold` uses fork-join. `+` used as both combine-fn and simultaneous reduce-fn? Yes `+` is monoid. Valid. \nReal Error: `r/map` lazy? \nCode: `(def x (r/map inc [1 2])) (first x)`. \nError: `r/map` returns a Reducible (implementation detail), not a Sequence. You cannot call `first` on it directly without `into` or `fold`? `clojure.core/first` calls `seq`. Reducible might not be convertible to seq automatically? Actually modern reducers might not implement Seqable. Throws exception.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_116_real",
        "title": "Reducer seq access",
        "description": "Identify type.",
        "codeSnippet": "(first (clojure.core.reducers/map inc [1 2]))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Reducers return Reducibles, which may not be Seqable. Cannot call seq functions like `first` directly. Use `(into [] ...)` or `fold`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_116",
        "title": "Reducer into",
        "description": "True or False?",
        "codeSnippet": "(into [] (clojure.core.reducers/map inc [1 2]))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_117",
        "title": "Volatile thread safety",
        "description": "Identify concurrency.",
        "codeSnippet": "(def v (volatile! 0))\n(future (vswap! v inc))\n(future (vswap! v inc))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "Volatiles are NOT atomic. Race condition implies lost updates relative to `atom`. Not a compilation error, but logic error in concurrent context.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_117",
        "title": "Atom swap",
        "description": "True or False?",
        "codeSnippet": "(swap! (atom 0) inc)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Thread-safe.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_118",
        "title": "Alter vs commute",
        "description": "Identify concurrency.",
        "codeSnippet": "(dosync (commute r inc) (ensure r))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`commute` allows out-of-order execution, `ensure` prevents modification by others. Using `ensure` after `commute` negates commute's benefit or logic? Or valid? \nStrict Error: `alter` outside dosync. \nCode: `(alter r inc)`. \nError: Must be in transaction.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_118_real",
        "title": "Alter outside dosync",
        "description": "Identify runtime.",
        "codeSnippet": "(alter (ref 1) inc)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`alter` must be called within a `dosync` transaction.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_118",
        "title": "Ref history",
        "description": "True or False?",
        "codeSnippet": "(def r (ref 1 :min-history 5))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_119",
        "title": "Binding non-dynamic",
        "description": "Identify scope.",
        "codeSnippet": "(def x 1)\n(binding [x 2] x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`binding` requires the Var to be dynamic `^:dynamic`. `x` is static global. Throws IllegalStateException.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_119",
        "title": "With-redefs",
        "description": "True or False?",
        "codeSnippet": "(with-redefs [x 2] x)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Works on non-dynamic vars (thread-unsafe).",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_120",
        "title": "Set! local var",
        "description": "Identify mutation.",
        "codeSnippet": "(let [x 1] (set! x 2))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Locals are immutable. `set!` works on Java fields or vars. Cannot set local symbol.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_120",
        "title": "Volatile set",
        "description": "True or False?",
        "codeSnippet": "(let [v (volatile! 1)] (vreset! v 2))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_121",
        "title": "Eval in generic code",
        "description": "Identify best-practice.",
        "codeSnippet": "(defn f [x] (eval x))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Using `eval` is generally an anti-pattern or security risk. Not a syntax error, but strong code smell. \nReal Error: `case` test expressions. \nCode: `(let [x 1] (case x x :found))`. \nError: `case` test constants must be compile-time literals. `x` (local) is not a literal. `case` does not evaluate test clauses.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_121_real",
        "title": "Case test constant",
        "description": "Identify syntax.",
        "codeSnippet": "(let [a 1] (case 1 a :match))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`case` matches value against literal constants. `a` is treated as the symbol `a` (or fails required constant check). Use `cond` for variable checks.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_121",
        "title": "Condp usage",
        "description": "True or False?",
        "codeSnippet": "(condp = 1 1 :match)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_122",
        "title": "Integer division precise",
        "description": "Identify math.",
        "codeSnippet": "(/ 1 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Returns fraction `1/2`. Valid. \nError: `unchecked-add` overflow? \nCode: `(unchecked-add Long/MAX_VALUE 1)`. \nError: Overflows to Long/MIN_VALUE. Not error, expected behavior. \nReal Error: `int` cast string. \nCode: `(int \"1\")`. \nError: `int` expects number or char. String casts to error.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_122_real",
        "title": "Int cast string",
        "description": "Identify casting.",
        "codeSnippet": "(int \"1\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Clojure's `int` function operates on characters or numbers. Use `Integer/parseInt` for strings.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_122",
        "title": "BigInt literal",
        "description": "True or False?",
        "codeSnippet": "1N",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_123",
        "title": "Import package",
        "description": "Identify syntax.",
        "codeSnippet": "(import java.util)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Cannot import a package. Must import classes. `(import java.util.Date)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_123",
        "title": "Class name resolution",
        "description": "True or False?",
        "codeSnippet": "java.util.Date",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Resolves to class object.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_124",
        "title": "Gen-class main",
        "description": "Identify config.",
        "codeSnippet": "(ns my.app (:gen-class))\n(defn -main [] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `-main` args missing? \nCode: `(defn -main [] ...)` usually called with `[args]`. If invoked by java, passed String[]. `(defn -main [& args] ...)`. If zero args defined, might fail if called with args? Yes. \nReal Error: `gen-class` method name mismatch. \nCode: `(gen-class :methods [[foo [] void]]) (defn bar [] ...)`. \nError: Impl must match prefix `-foo`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_124_real",
        "title": "Gen-class impl prefix",
        "description": "Identify convention.",
        "codeSnippet": "(gen-class :methods [[foo [] void]])\n(defn foo [] (println \"hi\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 1,
        "explanation": "`gen-class` implementation functions must be prefixed with `-` (default). Should be `(defn -foo [] ...)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_124",
        "title": "Gen-class state",
        "description": "True or False?",
        "codeSnippet": "(gen-class :name C :state state :init init)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_125",
        "title": "Pmap overhead",
        "description": "Identify optimization.",
        "codeSnippet": "(pmap inc [1 2 3])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid, but `pmap` overhead likely exceeds benefit for `inc`. Not error. \nReal Error: `future-cancel` on non-future. \nCode: `(future-cancel 1)`. \nError: Expects Future.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_125_real",
        "title": "Future-cancel type",
        "description": "Identify signature.",
        "codeSnippet": "(future-cancel :not-a-future)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Argument must be a `java.util.concurrent.Future`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_125",
        "title": "Future-done check",
        "description": "True or False?",
        "codeSnippet": "(future-done? (future 1))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_126",
        "title": "Agent await timeout return",
        "description": "Identify return.",
        "codeSnippet": "(agent 0)\n(await-for 100 *agent*)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. `await-for` returns boolean (true if success, false if timed out). `await` returns nil. \nError: `shutdown-agents` not called? Code doesn't exit. \nReal Error: `send-off` vs `send` thread pool. \nCode: `(send a (fn [_] (Thread/sleep 1000)))`. \nError: `send` uses fixed thread pool (cpu bound). Blocking it can starve other agents. Should use `send-off` (unbounded pool) for IO/blocking. Not syntax error, but critical performance error.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_126_real",
        "title": "Send blocking sleep",
        "description": "Identify best-practice.",
        "codeSnippet": "(send a (fn [_] (Thread/sleep 5000) 1))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`send` executes on a fixed-size thread pool designed for CPU-bound tasks. Blocking operations (sleep/IO) should use `send-off` to avoid starving the pool.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_126",
        "title": "Send-off intent",
        "description": "True or False?",
        "codeSnippet": "(send-off a (fn [_] (slurp \"http://...\")))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Correct for IO.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_127",
        "title": "Locking on value type",
        "description": "Identify runtime.",
        "codeSnippet": "(let [x 1] (locking x (println \"safe\")))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Primitives/Values (like 1) might be boxed, but relying on locking on a potential value-based class (Integer) is discouraged or dangerous (if new instance each time, no lock). But Java `synchronized` on scalar `1`? `1` is `(Integer. 1)` (or cached). If cached, global lock? If `new Integer(1)`, no lock. Clojure numbers logic? Better to lock on Object `(Object.)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_127",
        "title": "Reify multiple interfaces",
        "description": "True or False?",
        "codeSnippet": "(reify java.io.Closeable (close [_]) Runnable (run [_]))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_128",
        "title": "Extend-protocol default",
        "description": "Identify syntax.",
        "codeSnippet": "(defprotocol P (f [x]))\n(extend-protocol P Object (f [x] 1) nil (f [x] 2))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. `nil` handles `nil` dispatch. `Object` handles everything else. \nError: `extend-protocol` missing methods. \nCode: `(extend-protocol P String)`. \nError: Must provide method implementations.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_128_real",
        "title": "Extend-protocol no-op",
        "description": "Identify syntax.",
        "codeSnippet": "(extend-protocol P String)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`extend-protocol` expects implementations for the type. `(extend-protocol P Type (method [] ...))`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_128",
        "title": "Extending primitive arrays",
        "description": "True or False?",
        "codeSnippet": "(extend-protocol P (Class/forName \"[I\") (f [x] \"int-array\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. `[I` is int array class name.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_129",
        "title": "Proxy method name clash",
        "description": "Identify limitation.",
        "codeSnippet": "(proxy [Object] [] (toString [] \"s\") (toString [] \"s2\"))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Duplicate method name `toString` with same arity in `proxy`. Not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_129",
        "title": "Proxy access super",
        "description": "True or False?",
        "codeSnippet": "(proxy [java.util.ArrayList] [] (add [x] (proxy-super add x)))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_130",
        "title": "Aset immutable vector",
        "description": "Identify type.",
        "codeSnippet": "(aset [1 2] 0 3)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`aset` requires a Java array. Passed vector `[1 2]`. Throws.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_130",
        "title": "Make-array multidim",
        "description": "True or False?",
        "codeSnippet": "(make-array Long/TYPE 2 2)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. 2D array.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_131",
        "title": "Pattern compile syntax",
        "description": "Identify api.",
        "codeSnippet": "(java.util.regex.Pattern/compile \"[\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Invalid regex `[` (unclosed class). Throws PatternSyntaxException at runtime.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_131",
        "title": "Re-seq valid",
        "description": "True or False?",
        "codeSnippet": "(re-seq #\"\\d+\" \"1 2 3\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `(\"1\" \"2\" \"3\")`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_132",
        "title": "Data reader incomplete",
        "description": "Identify config.",
        "codeSnippet": "{:my/tag my.ns/fn}",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "This is content of `data_readers.clj`. Valid map. \nError: Reader fn arity? \nCode: `(defn r [x y] ...)`. \nError: Reader functions must take exactly 1 argument (the form following the tag).",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_132_real",
        "title": "Reader fn arity",
        "description": "Identify signature.",
        "codeSnippet": "(defn read-my-tag [a b] (+ a b)) ;; used as #my/tag",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Reader tag functions act on a single form. Must accept 1 argument.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_132",
        "title": "Edn read-string safe",
        "description": "True or False?",
        "codeSnippet": "(clojure.edn/read-string \"(+ 1 1)\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns list `(+ 1 1)`, does not evaluate it. Safe.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_133",
        "title": "Read-string eval vulnerability",
        "description": "Identify security.",
        "codeSnippet": "(read-string \"#=(eval (println 1))\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`read-string` (core, not edn) allows reader evaluation `#=`. This executes arbitrary code. Use `clojure.edn/read-string` for untrusted input.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_133",
        "title": "Edn no-eval",
        "description": "True or False?",
        "codeSnippet": "(clojure.edn/read-string \"#=(eval 1)\")",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "False (or True code, but throws?). `clojure.edn` does not support `#=` by default. Throws exception. Logic: isCodeCorrect -> False.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_134",
        "title": "Inspector usage",
        "description": "Identify library.",
        "codeSnippet": "(clojure.inspector/inspect-tree nil)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Works (shows empty/nil). \nError: `clojure.java.shell/sh` without args? \nCode: `(clojure.java.shell/sh [])`. \nError: `sh` expects strings. `(sh \"ls\")`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_134_real",
        "title": "Shell sh args",
        "description": "Identify signature.",
        "codeSnippet": "(clojure.java.shell/sh [\"ls\"])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`sh` takes variadic strings, not a vector. `(sh \"ls\" \"-la\")`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_134",
        "title": "Shell sh return",
        "description": "True or False?",
        "codeSnippet": "(:exit (clojure.java.shell/sh \"ls\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns map with `:exit`, `:out`, `:err`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_135",
        "title": "Source on string",
        "description": "Identify macro.",
        "codeSnippet": "(source \"map\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`source` expects a symbol resolving to a Var. `(source map)`. String \"map\" has no source.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_135",
        "title": "Doc macro",
        "description": "True or False?",
        "codeSnippet": "(doc map)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_136",
        "title": "Meta on symbol string",
        "description": "Identify type.",
        "codeSnippet": "(meta 's)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Symbols support metadata. Valid. \nError: `with-meta` on string. \nCode: `(with-meta \"s\" {})`. \nError: Strings do not support metadata (they are Java objects, not IObj). Only collections and symbols/vars do.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_136_real",
        "title": "With-meta string",
        "description": "Identify type.",
        "codeSnippet": "(with-meta \"s\" {:a 1})",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Strings are not Clojure objects that support metadata (`IObj`). `with-meta` fails.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_136",
        "title": "Meta on vector",
        "description": "True or False?",
        "codeSnippet": "(meta (with-meta [] {:a 1}))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{:a 1}`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_137",
        "title": "Diff set list",
        "description": "Identify behavior.",
        "codeSnippet": "(clojure.data/diff #{1} '(1))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid. Diff compares content. Returns `[nil nil #{1}]` (both have 1). \nError: `diff` types. \nCode: `(clojure.data/diff 1 \"1\")`. \nError: `[1 \"1\" nil]`. Valid. \nReal Error: `xml/parse` source. \nCode: `(clojure.xml/parse \"<root/>\")`. \nError: `parse` expects InputStream, File, or URI string. Raw XML string might be treated as URI? Fails URI lookup (ProtocolException). Must wrap in `ByteArrayInputStream`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_137_real",
        "title": "Xml parse string source",
        "description": "Identify library.",
        "codeSnippet": "(clojure.xml/parse \"<xml>s</xml>\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`parse` expects a URI, File, or InputStream. A string argument is interpreted as a URI, not XML content. Use `(java.io.ByteArrayInputStream. (.getBytes s))`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_137",
        "title": "Xml parse file",
        "description": "True or False?",
        "codeSnippet": "(clojure.xml/parse (java.io.File. \"data.xml\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_138",
        "title": "Bean properties write",
        "description": "Identify concept.",
        "codeSnippet": "(assoc (bean obj) :prop 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`bean` returns a persistent map snapshot (read-only view). `assoc` returns a new map. It does NOT modify the underlying Java object `obj`. If user intended mutation, this fails logic.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_138",
        "title": "Bean keys",
        "description": "True or False?",
        "codeSnippet": "(:class (bean \"s\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `java.lang.String`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_139",
        "title": "Compare symbols strings",
        "description": "Identify type.",
        "codeSnippet": "(compare 'a \"a\")",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Symbol and String are not comparable directly in `compare` (ClassCastException). Must match types or implement Comparable against each other.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_139",
        "title": "Compare keywords",
        "description": "True or False?",
        "codeSnippet": "(compare :a :b)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_140",
        "title": "Sorted map mixed keys",
        "description": "Identify runtime.",
        "codeSnippet": "(sorted-map :a 1 \"b\" 2)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Keys in `sorted-map` must be mutually comparable. Keyword `:a` and String `\"b\"` often throw ClassCastException when compared.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_140",
        "title": "Subseq sorted",
        "description": "True or False?",
        "codeSnippet": "(subseq (sorted-map :a 1 :b 2) > :a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns `([:b 2])`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_141",
        "title": "Hash map order",
        "description": "Identify behavior.",
        "codeSnippet": "(first {:a 1 :b 2})",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Not an error, but logical peril. Hash maps are unordered. Relying on `first` returning `:a` 1 is incorrect assumption. `array-map` or `sorted-map` preserves order.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_141",
        "title": "Array-map order",
        "description": "True or False?",
        "codeSnippet": "(keys (array-map :a 1 :b 2))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Guaranteed `(:a :b)`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_142",
        "title": "Struct map usage",
        "description": "Identify deprecated.",
        "codeSnippet": "(defstruct s :a) (struct s 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid legacy code. \nError: `defrecord` field default? \nCode: `(defrecord R [a 1])`. \nError: `defrecord` fields are symbols only. defaults not supported in sig. `(defrecord R [a])`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_142_real",
        "title": "Defrecord default val",
        "description": "Identify syntax.",
        "codeSnippet": "(defrecord R [a 1])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`defrecord` argument vector contains symbols (field names) only. Default values not supported in definition.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_142",
        "title": "Record map interop",
        "description": "True or False?",
        "codeSnippet": "(defrecord R [a]) (:a (R. 1))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Records work like maps.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_143",
        "title": "Set generic contains",
        "description": "Identify behavior.",
        "codeSnippet": "(contains? [1 2] 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`contains?` on vector checks *index*. Index 1 exists (value 2). If user meant \"contains value 1\", coincidental true. `(contains? [10 20] 10)` is false.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_143",
        "title": "Contains map key",
        "description": "True or False?",
        "codeSnippet": "(contains? {:a nil} :a)",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Checks key presence.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_144",
        "title": "Some fn predicate",
        "description": "Identify type.",
        "codeSnippet": "(some 1 [1 2])",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`some` expects predicate/function. `1` is not a function (unless it implements IFn, which numbers don't). `some #{1} [1 2]` works (set is function). `some 1` throws.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_144",
        "title": "Set as predicate",
        "description": "True or False?",
        "codeSnippet": "(some #{1} [1 2 3])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_145",
        "title": "Require reload args",
        "description": "Identify syntax.",
        "codeSnippet": "(require 'ns :reload true)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Wrong syntax. `(require 'ns :reload)` or `(require '[ns] :reload)`. `:reload` is a flag, not a key-value pair with `true`.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_145",
        "title": "Use only",
        "description": "True or False?",
        "codeSnippet": "(use '[clojure.string :only (split)])",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_146",
        "title": "Ns-resolve args",
        "description": "Identify signature.",
        "codeSnippet": "(ns-resolve 'clojure.core 'map)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`ns-resolve` takes `(ns-resolve ns sym)`. `ns` can be symbol. `sym` is symbol. Valid. \nError: `resolve` inside macro? \nCode: `(resolve 'map)`. \nError: `resolve` relies on `*ns*`. In REPL work, fine. In compiled code/lib, risky? No, works. \nReal Error: `ns-unmap` args. \nCode: `(ns-unmap 'ns :sym)`. \nError: `ns-unmap` expects symbol. `(ns-unmap 'ns 'sym)`. Keyword might fail lookup.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_146_real",
        "title": "Ns-unmap keyword",
        "description": "Identify type.",
        "codeSnippet": "(ns-unmap 'user :x)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`ns-unmap` expects a symbol for the name to unmap. `:x` is a keyword.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_146",
        "title": "Binding conveyance",
        "description": "True or False?",
        "codeSnippet": "(binding [*out* s] (future (println 1)))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. `future` conveys dynamic bindings.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_147",
        "title": "Bound-fn usage",
        "description": "Identify scope.",
        "codeSnippet": "(def f (binding [*x* 1] (fn [] *x*))) (f)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`binding` is dynamic scope. The finding is only active *during execution* of the let body. Returning a closure `(fn [] *x*)` exits the binding block. When `f` is called later, `*x*` is back to root val (or unbound). Use `bound-fn` to capture bindings.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_147",
        "title": "Bound-fn capture",
        "description": "True or False?",
        "codeSnippet": "(def f (binding [*x* 1] (bound-fn [] *x*)))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Captures dynamic scope.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_148",
        "title": "Seque deprecated",
        "description": "Identify library.",
        "codeSnippet": "(seque 1 (range))",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`seque` is deprecated/removed in newer contrib/core? It existed in 1.2? core.async replaced it. Code might crash if function missing or deprecated.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_148",
        "title": "Tap usage",
        "description": "True or False?",
        "codeSnippet": "(tap> {:data 1})",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. `tap>` sends to registered listeners.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_149",
        "title": "Add-tap fn",
        "description": "Identify type.",
        "codeSnippet": "(add-tap :key)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "`add-tap` expects a function (to receive value). `:key` is keyword (function of map), but if tap sends non-map, keyword fails or returns nil. Usually expects `println` or handler.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_149",
        "title": "Datafy usage",
        "description": "True or False?",
        "codeSnippet": "(clojure.datafy/datafy (java.util.Date.))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_150",
        "title": "Nav on non-navigable",
        "description": "Identify protocol.",
        "codeSnippet": "(clojure.datafy/nav {:a 1} :a 1)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": -1,
        "explanation": "Valid default. \nError: `requiring-resolve` namespace. \nCode: `(requiring-resolve 'non.existent/foo)`. \nError: Throws FileNotFoundException if ns cannot be loaded.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_err_150_real",
        "title": "Requiring-resolve missing",
        "description": "Identify runtime.",
        "codeSnippet": "(requiring-resolve 'my.missing.ns/foo)",
        "type": "errorSpotting",
        "language": "clojure",
        "errorLineIndex": 0,
        "explanation": "Attempts to require namespace. If missing, throws exception.",
        "difficultyLevel": 3
    },
    {
        "id": "clojure_tf_150",
        "title": "Throwable->map",
        "description": "True or False?",
        "codeSnippet": "(Throwable->map (Exception. \"e\"))",
        "type": "trueOrFalse",
        "language": "clojure",
        "isCodeCorrect": true,
        "explanation": "True. Returns data map.",
        "difficultyLevel": 3
    }
]