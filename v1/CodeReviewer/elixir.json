[
    {
        "id": "elixir_err_1",
        "title": "Match operator reassignment",
        "description": "Identify syntax/logic.",
        "codeSnippet": "x = 1\n^x = 2",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "The pin operator `^x` asserts that the value of `x` (which is 1) must match the right side (2). 1 does not equal 2, so this raises a match error.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_1",
        "title": "Atom Syntax",
        "description": "True or False?",
        "codeSnippet": ":ok",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. `:ok` is a valid atom.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_2",
        "title": "List consing syntax",
        "description": "Identify syntax error.",
        "codeSnippet": "list = [1, 2, 3]\nnew_list = list | 0",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "The cons operator `|` puts the head on the left and tail on the right: `[0 | list]`. Using `list | 0` creates an improper list `[1, 2, 3 | 0]`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_2",
        "title": "Tuple Declaration",
        "description": "True or False?",
        "codeSnippet": "t = {1, 2, 3}",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Tuples are defined with curly braces.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_3",
        "title": "String concatenation",
        "description": "Identify operator.",
        "codeSnippet": "s = \"Hello \" + \"World\"",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Elixir uses `<>` for binary/string concatenation. `\"Hello \" <> \"World\"`. `+` is for numbers.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_3",
        "title": "Anonymous function",
        "description": "True or False?",
        "codeSnippet": "add = fn a, b -> a + b end\nresult = add.(1, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Anonymous functions are called with a dot `.()`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_4",
        "title": "Keyword list keys",
        "description": "Identify syntax.",
        "codeSnippet": "opts = [key: value, 1: \"oops\"]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Keyword list keys must be atoms. `1` is an integer, so `1:` is invalid syntax for a keyword list key.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_4",
        "title": "Map Access",
        "description": "True or False?",
        "codeSnippet": "m = %{a: 1}\nv = m.a",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Atom keys in maps can be accessed with dot notation.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_5",
        "title": "Private function call",
        "description": "Identify scope.",
        "codeSnippet": "defmodule MyMod do\n  defp secret, do: :ssh\nend\nMyMod.secret()",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "`defp` defines a private function. It cannot be called from outside the module.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_5",
        "title": "Enum Map",
        "description": "True or False?",
        "codeSnippet": "Enum.map([1, 2], fn x -> x * 2 end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Basic list mapping.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_6",
        "title": "Charlist vs String",
        "description": "Identify type mismatch.",
        "codeSnippet": "s = 'hello' <> \"world\"",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`'hello'` is a charlist (list of integers). `\"world\"` is a binary string. `<>` is for binaries. Charlists use `++`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_6",
        "title": "Head Tail Pattern",
        "description": "True or False?",
        "codeSnippet": "[h | t] = [1, 2, 3]",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. `h` binds to 1, `t` to `[2, 3]`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_7",
        "title": "If return value",
        "description": "Identify return.",
        "codeSnippet": "x = if false do\n  1\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid? If `if` condition is false and no `else` block, it returns `nil`. Code is valid. \nReal Error: `case` missing clause. \nCode: `case 1 do 2 -> :ok end`. \nError: 1 does not match 2. `CaseClauseError` raised at runtime. \nReal Error: `def` without arguments in `do` block? \nCode: `def func do: 1`. Valid (one line). \nReal Error: `IO.puts` with charlist? \nCode: `IO.puts('abc')`. Valid (prints 'abc'). \nReal Error: `length` on tuple. \nCode: `length({1, 2})`. \nError: `length` works on lists. Use `tuple_size` for tuples.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_7_real",
        "title": "Length of Tuple",
        "description": "Identify function usage.",
        "codeSnippet": "t = {1, 2}\nl = length(t)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`length` works on lists. For tuples, use `tuple_size(t)`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_7",
        "title": "Module Attribute",
        "description": "True or False?",
        "codeSnippet": "defmodule M do\n  @attr 10\n  def val, do: @attr\nend",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Constant module attribute.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_8",
        "title": "Case clause error",
        "description": "Identify missing match.",
        "codeSnippet": "case :error do\n  :ok -> \"Good\"\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "No clause matches `:error`. Raises `CaseClauseError`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_8",
        "title": "String Interpolation",
        "description": "True or False?",
        "codeSnippet": "x = 1\ns = \"Value: #{x}\"",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. `#{}` syntax.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_9",
        "title": "Function default arg position",
        "description": "Identify warning/error.",
        "codeSnippet": "def foo(a \\\\ 1, b) do\n  a + b\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Defining a default argument `a \\\\ 1` before a required argument `b` causes ambiguity and warnings (and runtime issues if not careful). It is technically allowed but strongly discouraged or requires a wrapper head.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_9",
        "title": "Guard Clause",
        "description": "True or False?",
        "codeSnippet": "def zero?(x) when x == 0, do: true",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Basic guard usage.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_10",
        "title": "Map new syntax",
        "description": "Identify syntax.",
        "codeSnippet": "m = %{:a => 1}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Valid? Yes, `%{:a => 1}` is valid. But `%` alone? \nError: `defmodule` name. \nCode: `defmodule mymod do ... end`. \nError: Module names must be capitalized Atoms (Aliases). `MyMod`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_10_real",
        "title": "Module Naming",
        "description": "Identify naming convention.",
        "codeSnippet": "defmodule mymodule do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Module names must be aliases (start with uppercase). `defmodule Mymodule`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_10",
        "title": "Pipe Operator",
        "description": "True or False?",
        "codeSnippet": "\" hello \" |> String.trim() |> String.upcase()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Equivalent to `String.upcase(String.trim(\" hello \"))`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_11",
        "title": "Binary string invalid",
        "description": "Identify syntax.",
        "codeSnippet": "b = <<1, 2, \"string\">>",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "In a binary literal, strings must be explicitly converted to binary implementation or used alone? `<<1, 2, \"string\"::binary>>` is required to embed a string.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_11",
        "title": "Integer Division",
        "description": "True or False?",
        "codeSnippet": "val = div(10, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. `div` is for integer division.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_12",
        "title": "Pattern match tuples",
        "description": "Identify mismatch.",
        "codeSnippet": "{a, b} = {1, 2, 3}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Tuple sizes must match. Left has 2 elements, right has 3.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_12",
        "title": "Kernel Rem",
        "description": "True or False?",
        "codeSnippet": "r = rem(10, 3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Remainder.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_13",
        "title": "Cond bad usage",
        "description": "Identify logic.",
        "codeSnippet": "cond do\n  1 + 1 == 3 -> \"Wrong\"\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "If no condition matches in `cond`, it raises `CondClauseError`. Usually need a final validation `true -> ...` clause.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_13",
        "title": "Import Module",
        "description": "True or False?",
        "codeSnippet": "import List, only: [flatten: 1]\nf = flatten([[1]])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Imports specified function.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_14",
        "title": "Capture operator arity",
        "description": "Identify syntax.",
        "codeSnippet": "f = &String.length/0",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`String.length` expects 1 argument (the string). Capturing with arity 0 `/0` is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_14",
        "title": "Alias Directive",
        "description": "True or False?",
        "codeSnippet": "alias MyLongModule.SubModule, as: Sub\nSub.func()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_15",
        "title": "Map update syntax",
        "description": "Identify syntax.",
        "codeSnippet": "m = %{a: 1}\nm2 = %{m | b: 2}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "The update syntax `%{map | key: val}` can only update *existing* keys. Key `:b` does not exist in `m`, so this raises a KeyError. Use `Map.put` for new keys.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_15",
        "title": "List First",
        "description": "True or False?",
        "codeSnippet": "List.first([1, 2, 3])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_16",
        "title": "Require usage",
        "description": "Identify context.",
        "codeSnippet": "Integer.is_even(2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Integer.is_even` asks for a macro provided by `Integer` module (is_even is distinct as a macro requiring `require Integer` usually? using `Integer.is_even` directly works if already required or imported? Actually `is_even` is often an example macro. `Integer.even?/1` exists? No, `Integer.is_even` exists in `Integer` since 1.11. Before that, needed `require Integer`. Wait. `Integer.is_even/1` checks evenness. It is a macro. Must use `require Integer` before invoking. Or just `import Integer`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_16_real",
        "title": "Macro Requirement",
        "description": "Identify macro usage.",
        "codeSnippet": "Integer.is_odd(3)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`is_odd/1` is a macro in the `Integer` module. You must `require Integer` or `import Integer` before using it.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_16",
        "title": "Unless Macro",
        "description": "True or False?",
        "codeSnippet": "unless false do\n  :run\nend",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Specific inverse of `if`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_17",
        "title": "Struct fields",
        "description": "Identify definition.",
        "codeSnippet": "defmodule User do\n  defstruct [:name, :age]\nend\nu = %User{email: \"test\"}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "Struct `User` only has keys `:name` and `:age`. `:email` is not part of the struct definition, so it raises a CompileError or KeyError.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_17",
        "title": "Keyword Get",
        "description": "True or False?",
        "codeSnippet": "Keyword.get([a: 1], :a)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_18",
        "title": "For comprehension syntax",
        "description": "Identify generator.",
        "codeSnippet": "for x in [1, 2], do: x * 2",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`x in [1, 2]` syntax in `for` is `x <- [1, 2]`. The `in` keyword is for module attributes or guard clauses. Generator uses `<-`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_18",
        "title": "Stream Cycle",
        "description": "True or False?",
        "codeSnippet": "Stream.cycle([1, 2]) |> Enum.take(3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns [1, 2, 1].",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_19",
        "title": "With clause else",
        "description": "Identify logic.",
        "codeSnippet": "with {:ok, x} <- {:error, :fail} do\n  x\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. If match fails, `with` returns the non-matching value (`{:error, :fail}`). \nError: `with` syntax error. \nCode: `with {:ok, x} = func() do`. \nError: Generator in `with` uses `<-`. `=` works as bare match, raising error on mismatch. If we expect fail handling, `<-`. If `=` used, MatchError. \nCode: `x = 1; ^x = 2`. Already used. \nReal Error: `fn` missing `end`. \nCode: `f = fn x -> x`. \nError: Missing `end`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_19_real",
        "title": "Fn Missing End",
        "description": "Identify syntax literal.",
        "codeSnippet": "f = fn x -> x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Anonymous function definition must be terminated with `end`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_19",
        "title": "Range Operator",
        "description": "True or False?",
        "codeSnippet": "1..10",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Creates a Range.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_20",
        "title": "Inspection syntax",
        "description": "Identify typo.",
        "codeSnippet": "IO.inspect[1, 2]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Missing parentheses or space for function call? `IO.inspect[1, 2]` might be interpreted as accessing access protocol on `IO.inspect` function? No, `IO.inspect` is a function. `IO.inspect([1, 2])` or `IO.inspect [1, 2]`. Without space/parens, `IO.inspect[...]` looks like dynamic access?",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_20",
        "title": "Apply Function",
        "description": "True or False?",
        "codeSnippet": "apply(Enum, :reverse, [[1, 2]])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Calls `Enum.reverse([1, 2])`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_21",
        "title": "Sigil delimiters",
        "description": "Identify syntax.",
        "codeSnippet": "~s(hello]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Mismatched delimiters in sigil. Starts with `(`, must end with `)`. Ends with `]`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_21",
        "title": "Regex match",
        "description": "True or False?",
        "codeSnippet": "\"foo\" =~ ~r/foo/",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Regex match operator.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_22",
        "title": "Try catch vs rescue",
        "description": "Identify error handling.",
        "codeSnippet": "try do\n  raise \"Oops\"\ncatch\n  e -> IO.puts e\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "To catch raised exceptions, use `rescue`. `catch` is for `throw/catch` mechanism (non-error control flow).",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_22",
        "title": "Process Current",
        "description": "True or False?",
        "codeSnippet": "self()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns current PID.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_23",
        "title": "Spawn arg",
        "description": "Identify input.",
        "codeSnippet": "spawn(MyMod.func)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`spawn` takes a function (anonymous `fn -> ... end`) or module/func/args tuple. Passing the result of `MyMod.func` (unless it returns a fun) is wrong. If `MyMod.func` *is* the function call, it runs in main process, spawn gets result. Intention is `spawn(fn -> MyMod.func() end)`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_23",
        "title": "Send Receive",
        "description": "True or False?",
        "codeSnippet": "send(self(), :msg)\nreceive do\n  :msg -> :got_it\nend",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Basic message passing.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_24",
        "title": "IO.puts return",
        "description": "Identify return value.",
        "codeSnippet": "x = IO.puts(\"hi\")\nx + 1",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`IO.puts` returns `:ok`. Adding 1 to `:ok` raises internal error.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_24",
        "title": "Port Close",
        "description": "True or False?",
        "codeSnippet": "Port.close(port)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Closes a port.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_25",
        "title": "Task await timeout",
        "description": "Identify default.",
        "codeSnippet": "t = Task.async(fn -> :ok end)\nTask.await(t, :infinity)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. `:infinity` is allowed. \nError: `Agent` start. \nCode: `Agent.start(fn -> [] end)`. \nValid. \nReal Error: GenServer call without starting? \nCode: `GenServer.call(:myserver, :req)`. \nError: If process not registered, noproc exit. \nReal Error: `def` inside `def`. \nCode: `def outer do def inner do end end`. \nError: Nested function definitions are not allowed.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_25_real",
        "title": "Nested Def",
        "description": "Identify scope.",
        "codeSnippet": "def outer do\n  def inner do\n  end\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Cannot define a named function (`def inner`) inside another function.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_25",
        "title": "Agent Get",
        "description": "True or False?",
        "codeSnippet": "Agent.get(pid, fn state -> state end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Retrieves state.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_26",
        "title": "Bitstring syntax",
        "description": "Identify bits.",
        "codeSnippet": "<<x::3>> = <<7::4>>",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Size mismatch. Trying to match 3 bits against 4 bits literal in a strict context without remainder? Elixir bitstring matching often allows partial if `binary` at end, but here fixed sizes differ.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_26",
        "title": "System Halt",
        "description": "True or False?",
        "codeSnippet": "System.halt(0)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Halts VM.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_27",
        "title": "Nil arithmetic",
        "description": "Identify type.",
        "codeSnippet": "1 + nil",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Cannot perform arithmetic with `nil`. Raises ArithmeticError.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_27",
        "title": "Float specific",
        "description": "True or False?",
        "codeSnippet": "f = 1.0e-10",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Scientific notation.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_28",
        "title": "Unless else",
        "description": "Identify syntax.",
        "codeSnippet": "unless true do\n  :a\nelse\n  :b\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "`unless` does not support `else` blocks? Actually, it does support `else` in Elixir, mirroring `if`. Surprise! \nWait, strict check: \"Note: unless/2 does not support else blocks\" - some docs say avoid it, but does compiler allow? \nTesting: `unless false, do: 1, else: 2` works. \nLet's find a real error. \nCode: `lc = List.chars([1])`. \nError: `List.to_charlist` or `to_char_list`? `List.chars` is protocol? `List.to_string`? \nReal Error: `import` ambiguous. \nCode: `import String; length(\"s\")`. \nError: `length` is Kernel (list length), `String.length` is binary length. `String` does not export `length`. It exports `length/1`. Conflict with `Kernel.length/1`. Elixir warns/errors on ambiguity.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_28_real",
        "title": "Import Conflict",
        "description": "Identify ambiguity.",
        "codeSnippet": "import String\nlen = length(\"abc\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`import String` brings `String.length/1`. `Kernel.length/1` is default. Calling `length` is ambiguous and raises CompileError.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_28",
        "title": "Tuple Append",
        "description": "True or False?",
        "codeSnippet": "Tuple.append({1, 2}, 3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{1, 2, 3}`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_29",
        "title": "Module name atom",
        "description": "Identify syntax.",
        "codeSnippet": "defmodule :my_mod do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Module name cannot be a simple atom starting with colon in `defmodule`. Must be Alias (Capitalized) or `:\"MyMod\"` sometimes allowed technically but usually invalid syntax for definition? Convention is `defmodule MyMod`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_29",
        "title": "Macro Quote",
        "description": "True or False?",
        "codeSnippet": "quote do: 1 + 2",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns AST.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_30",
        "title": "Protocol impl",
        "description": "Identify syntax.",
        "codeSnippet": "defimpl MyProto, for: Integer do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `Access` macro on list? \nCode: `pop_in([a: 1], [:a])`. \nValid (Keyword list implements Access). \nError: `div` by zero. \nCode: `div(1, 0)`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_30_real",
        "title": "Division by Zero",
        "description": "Identify runtime error.",
        "codeSnippet": "val = div(10, 0)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Division by zero raises `ArithmeticError`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_30",
        "title": "Kernel Apply",
        "description": "True or False?",
        "codeSnippet": "apply(fn x -> x end, [1])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Anonymous function apply.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_31",
        "title": "Date literal",
        "description": "Identify syntax.",
        "codeSnippet": "d = ~D[2023-02-30]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "February 30th is an invalid date. Sigil validation happens at compile time (or runtime parse).",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_31",
        "title": "NaiveDateTime",
        "description": "True or False?",
        "codeSnippet": "dt = ~N[2023-01-01 12:00:00]",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_32",
        "title": "Time sigil error",
        "description": "Identify value.",
        "codeSnippet": "~T[25:00:00]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Hour 25 is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_32",
        "title": "URI Parse",
        "description": "True or False?",
        "codeSnippet": "uri = URI.parse(\"http://google.com\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_33",
        "title": "Function head match",
        "description": "Identify logic.",
        "codeSnippet": "def sum(a, a), do: a + a",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Re-binding argument `a` in function head `sum(a,a)` is valid in Erlang/Elixir to enforce equality? Yes, it means arguments must be equal. \nError is subtle? \nLet's try `def sum(a, 1) ...; def sum(a, b) ...`. Order matters. \nReal Error: `def` inside `cond`? \nCode: `cond do true -> def f, do: 1 end`. \nError: `def` cannot be dynamic.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_33_real",
        "title": "Dynamic Def",
        "description": "Identify context.",
        "codeSnippet": "if true do\n  def my_func, do: 1\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`def` cannot be conditional or nested in control flow (unless strictly inside module body at compile time, but `if` executes runtime logic? `if` at module level is valid for macros, but standard `if` assumes runtime). Actually, top-level `if` in class body is compile-time. \nBetter error: `1 = 2`. \nCode: `1 = 2`. \nError: MatchError.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_33",
        "title": "Path Join",
        "description": "True or False?",
        "codeSnippet": "p = Path.join(\"a\", \"b\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_34",
        "title": "File read non-existent",
        "description": "Identify result.",
        "codeSnippet": "{:ok, content} = File.read(\"noexist.txt\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "If file doesn't exist, `File.read` returns `{:error, :enoent}`. Matching against `{:ok, content}` raises MatchError.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_34",
        "title": "File Stream",
        "description": "True or False?",
        "codeSnippet": "File.stream!(\"file.txt\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns stream.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_35",
        "title": "Function name cap",
        "description": "Identify convention.",
        "codeSnippet": "def FunctionName do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Function names must be snake_case (start with lowercase). Capitalized names are for Modules constraints? Syntax error? Invalid function name.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_35",
        "title": "Code Eval",
        "description": "True or False?",
        "codeSnippet": "{res, _} = Code.eval_string(\"1+1\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_36",
        "title": "Struct update missing key",
        "description": "Identify syntax.",
        "codeSnippet": "defmodule S, do: defstruct [:a]\ns = %S{}\ns2 = %{s | b: 2}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Struct `S` does not have key `:b`. Update syntax checks keys. Error.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_36",
        "title": "Struct Access",
        "description": "True or False?",
        "codeSnippet": "defmodule S, do: defstruct a: 1\ns = %S{}\nval = s.a",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_37",
        "title": "Erlang module call",
        "description": "Identify syntax.",
        "codeSnippet": "lists.reverse([1, 2])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Erlang modules are atoms. Use `:lists.reverse(...)`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_37",
        "title": "Bitwise And",
        "description": "True or False?",
        "codeSnippet": "import Bitwise\nv = band(1, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_38",
        "title": "Float division",
        "description": "Identify operator.",
        "codeSnippet": "r = 10 / 0",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Division by zero.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_38",
        "title": "Float Div Result",
        "description": "True or False?",
        "codeSnippet": "val = 4 / 2\nis_float(val)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. `/` always returns float in Elixir.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_39",
        "title": "Keyword delete",
        "description": "Identify signature.",
        "codeSnippet": "kw = Keyword.delete([a: 1], :a, 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Keyword.delete` takes 2 arguments: list and key. No 3rd argument.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_39",
        "title": "List Last",
        "description": "True or False?",
        "codeSnippet": "l = List.last([1, 2])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_40",
        "title": "Registry start",
        "description": "Identify usage.",
        "codeSnippet": "Registry.start_link(:unique, MyReg)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Registry.start_link` arguments need to be a keyword list or map properly structured? `keys: :unique, name: MyReg`. Arguments position error.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_40",
        "title": "Process Alive",
        "description": "True or False?",
        "codeSnippet": "Process.alive?(self())",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_41",
        "title": "IO read",
        "description": "Identify atom.",
        "codeSnippet": "line = IO.gets(:standard_io)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`IO.gets` takes device or prompt? `IO.gets(:stdio, \"prompt\")`. If just one arg, assumed prompt? `IO.gets(:standard_io)`? Atom `:stdio` is alias for `:standard_io`. Wait. `IO.gets/1` takes prompt? Or device? \nUsage: `IO.gets(\"Prompt> \")` reads from stdio. `IO.gets(device, prompt)`. \nIf passed `:standard_io`, it treats it as prompt string? No, `:standard_io` is atom. Prompt must be string/binary. Error.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_41",
        "title": "String Split",
        "description": "True or False?",
        "codeSnippet": "parts = String.split(\"a,b\", \",\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_42",
        "title": "Module attribute accumulation",
        "description": "Identify missing config.",
        "codeSnippet": "@my_attr 1\n@my_attr 2\n# Expect list [2, 1]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "By default, attributes are not accumulating. The second definition overwrites the first. Need `Module.register_attribute __MODULE__, :my_attr, accumulate: true`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_42",
        "title": "Integer Parse",
        "description": "True or False?",
        "codeSnippet": "{num, _} = Integer.parse(\"123\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_43",
        "title": "Node self",
        "description": "Identify typo.",
        "codeSnippet": "n = Node.this()",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Correct function is `Node.self()`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_43",
        "title": "System Time",
        "description": "True or False?",
        "codeSnippet": "t = System.system_time(:second)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_44",
        "title": "Tuple to list typo",
        "description": "Identify name.",
        "codeSnippet": "l = Tuple.to_listtt({1})",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Typo `to_listtt`. Use `to_list`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_44",
        "title": "Base Encode64",
        "description": "True or False?",
        "codeSnippet": "b64 = Base.encode64(\"data\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_45",
        "title": "Enum reduce args",
        "description": "Identify signature.",
        "codeSnippet": "Enum.reduce([1, 2], fn x -> x end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`reduce/2` function expects `(element, acc) -> acc`. `fn x -> x end` has arity 1. `Enum.reduce` needs arity 2 function.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_45",
        "title": "Enum Filter",
        "description": "True or False?",
        "codeSnippet": "l = Enum.filter([1, 2], fn x -> x > 1 end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_46",
        "title": "Task start args",
        "description": "Identify syntax.",
        "codeSnippet": "Task.start(MyMod, :run)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Task.start(module, func, args)`. Missing `args` list. Use `Task.start(MyMod, :run, [])`.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_46",
        "title": "Kernel Max",
        "description": "True or False?",
        "codeSnippet": "m = max(1, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_47",
        "title": "String slice range",
        "description": "Identify type.",
        "codeSnippet": "s = String.slice(\"abc\", \"a\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`String.slice` second arg must be range or start/length. Key \"a\" is invalid.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_47",
        "title": "Kernel min",
        "description": "True or False?",
        "codeSnippet": "m = min(1, -1)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_48",
        "title": "List delete syntax",
        "description": "Identify usage.",
        "codeSnippet": "l = List.delete([1, 2], 1, 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`List.delete/2` takes (list, item). No 3rd arg.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_48",
        "title": "Map Keys",
        "description": "True or False?",
        "codeSnippet": "k = Map.keys(%{a: 1})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_49",
        "title": "Map merge conflict",
        "description": "Identify behavior.",
        "codeSnippet": "m = Map.merge(%{a: 1}, %{a: 2})",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Overwrites value. `%{a: 2}`. \nError: `defmodule` inside function? \nCode: `def func do defmodule M do end end`. \nError: Modules are top-level or nested modules, but defining inside function scope (runtime) is not standard (compilation scope). Warnings/Errors.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_49_real",
        "title": "Defmodule in Function",
        "description": "Identify scope.",
        "codeSnippet": "def my_func do\n  defmodule Inner do end\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Cannot define a module inside a function definition.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_49",
        "title": "Atom to String",
        "description": "True or False?",
        "codeSnippet": "s = Atom.to_string(:ok)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_50",
        "title": "Binary pattern match size",
        "description": "Identify parameter.",
        "codeSnippet": "<<x::size(8)>> = <<1>>",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. 8 bits match 1 byte. \nError: `Integer.parse` bad input. \nCode: `Integer.parse(123)`. \nError: Expected string argument.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_50_real",
        "title": "Integer Parse Arg",
        "description": "Identify type.",
        "codeSnippet": "Integer.parse(123)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Integer.parse` expects a binary (string) argument, not an integer.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_tf_50",
        "title": "Macro Expand",
        "description": "True or False?",
        "codeSnippet": "Macro.expand(quote(do: if(true, do: 1)), __ENV__)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 1
    },
    {
        "id": "elixir_err_51",
        "title": "GenServer handle_call return",
        "description": "Identify return tuple.",
        "codeSnippet": "def handle_call(:msg, _from, state) do\n  {:ok, state}\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`handle_call` usually returns `{:reply, reply, new_state}` (or `{:noreply, ...}`). Returning `{:ok, state}` is invalid for call (timeout or crash).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_51",
        "title": "GenServer Cast",
        "description": "True or False?",
        "codeSnippet": "GenServer.cast(pid, :msg)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Asynchronous message.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_52",
        "title": "Agent update logic",
        "description": "Identify return.",
        "codeSnippet": "Agent.update(pid, fn state -> :ok end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Agent.update` function must return the new state. Returning `:ok` sets the state to `:ok`. If state was a map/list expected elsewhere, this might be logic error usually. But strictly syntax valid. \nReal Error: `GenServer.call` timeout arg position. \nCode: `GenServer.call(:s, :req, :infinity)`. \nValid. \nReal Error: `Supervisor` spec tuple. \nCode: `children = [{MyWorker, []}]`. \nValid. \nReal Error: `ETS` table access (named table). \nCode: `:ets.insert(:nonexistent, {1, 2})`. \nError: ArgumentError if table not created.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_52_real",
        "title": "ETS Table Missing",
        "description": "Identify runtime precondition.",
        "codeSnippet": ":ets.insert(:missing_table, {key, val})",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Trying to insert into a named table that hasn't been created with `:ets.new` raises `ArgumentError`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_52",
        "title": "Supervisor Start",
        "description": "True or False?",
        "codeSnippet": "Supervisor.start_link([], strategy: :one_for_one)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Starts empty supervisor.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_53",
        "title": "Process link return",
        "description": "Identify signature.",
        "codeSnippet": "pid = Process.link(other_pid)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Process.link` returns `true` (always). It does not return a PID. If attempting to spawn_link, use `spawn_link`. Assigning result `pid` to `true` might confuse later code expecting PID.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_53",
        "title": "Process Monitor",
        "description": "True or False?",
        "codeSnippet": "ref = Process.monitor(pid)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns reference.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_54",
        "title": "Task.yield timeout",
        "description": "Identify type.",
        "codeSnippet": "res = Task.yield(task, \"5000\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Timeout must be integer or `:infinity`. String \"5000\" is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_54",
        "title": "Task Async Await",
        "description": "True or False?",
        "codeSnippet": "t = Task.async(fn -> 1 end); Task.await(t)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_55",
        "title": "DynamicSupervisor spec",
        "description": "Identify usage.",
        "codeSnippet": "DynamicSupervisor.start_child(Sup, {MyWorker, []})",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid child spec. \nError: `Registry` keys. \nCode: `Registry.lookup(Reg, \"key\")`. \nValid. \nError: `Process.flag` trap_exit. \nCode: `Process.flag(:trap_exit, 1)`. \nError: Must be boolean `true` or `false`. `1` is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_55_real",
        "title": "Process Flag Argument",
        "description": "Identify type.",
        "codeSnippet": "Process.flag(:trap_exit, 1)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`trap_exit` flag requires a boolean value (`true` or `false`).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_55",
        "title": "Application Get Env",
        "description": "True or False?",
        "codeSnippet": "val = Application.get_env(:my_app, :key)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_56",
        "title": "ETS new type",
        "description": "Identify option.",
        "codeSnippet": ":ets.new(:tab, [:set, :publik])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Typo `:publik`. Valid is `:public`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_56",
        "title": "ETS Insert",
        "description": "True or False?",
        "codeSnippet": ":ets.insert(tab, {:key, \"val\"})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Assuming `tab` exists.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_57",
        "title": "Macro hygiene variable",
        "description": "Identify scope.",
        "codeSnippet": "defmacro set_x(val) do\n  quote do\n    x = unquote(val)\n  end\nend\n# Usage:\nset_x(1)\nIO.puts x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 6,
        "explanation": "Macros are hygienic by default. Variable `x` defined inside quote is scoped to the macro expansion and not visible outside unless `var!(x)` is used. `IO.puts x` will fail (undefined variable).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_57",
        "title": "Function Capture",
        "description": "True or False?",
        "codeSnippet": "f = &Enum.map/2",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Captures `Enum.map` with arity 2.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_58",
        "title": "Quote unquote context",
        "description": "Identify context.",
        "codeSnippet": "def f(x), do: unquote(x)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`unquote` can only be used inside `quote`. Using it in a regular function definition is a syntax error.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_58",
        "title": "Macro Stringify",
        "description": "True or False?",
        "codeSnippet": "defmacro s(arg) do\n  Macro.to_string(arg)\nend",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns string representation of AST.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_59",
        "title": "Protocol definitions",
        "description": "Identify syntax.",
        "codeSnippet": "defprotocol MyProto do\n  def func(data)\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Protocol function definitions should not have a body (even empty?). Usually `def func(data)` is just signature. But in `defprotocol`, you specify specs usually or empty defs? \nCheck: `def func(data)` is valid signature. \nError: `defstruct` in protocol? No. \nReal Error: `defimpl` for non-existent implementation? \nCode: `defimpl MyProto, for: Atom do ... end`. \nValid if atom exists. \nReal Error: `use` loop. \nCode: `defmodule A do use A end`. \nError: Infinite compilation loop.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_59_real",
        "title": "Recursive Use",
        "description": "Identify compilation error.",
        "codeSnippet": "defmodule A do\n  use A\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "A module cannot `use` itself during its own definition. Causes deadlock/loop.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_59",
        "title": "Module Concatenation",
        "description": "True or False?",
        "codeSnippet": "mod = Module.concat([My, Mod])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Creates Alias `My.Mod`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_60",
        "title": "Stream resource cleanup argument",
        "description": "Identify signature.",
        "codeSnippet": "Stream.resource(start, next, fn -> :ok end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Cleanup function in `Stream.resource` takes one argument (the resource). `fn _ -> :ok end`. Zero-arity function causes runtime error on stream termination.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_60",
        "title": "Enum Reduce While",
        "description": "True or False?",
        "codeSnippet": "Enum.reduce_while([1], 0, fn x, acc -> {:halt, x} end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Halts reduction.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_61",
        "title": "DETS open file",
        "description": "Identify atom.",
        "codeSnippet": "{:ok, t} = :dets.open_file(\"file.dets\", [])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`dets.open_file` first argument must be table name (atom). Filename is option/defaults to name? \nUsage: `:dets.open_file(:name, [file: \"filename\"])`. \nCalling with string as first arg is invalid type (must be atom).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_61",
        "title": "IO Write",
        "description": "True or False?",
        "codeSnippet": "IO.write(:stderr, \"Error\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Writes to standard error.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_62",
        "title": "System cmd args",
        "description": "Identify format.",
        "codeSnippet": "System.cmd(\"ls\", \"-l\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Second argument to `System.cmd` must be a list of strings. `[\"-l\"]`. Passing string directly is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_62",
        "title": "System Env",
        "description": "True or False?",
        "codeSnippet": "map = System.get_env()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns all env vars.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_63",
        "title": "String to integer base",
        "description": "Identify value.",
        "codeSnippet": "i = String.to_integer(\"10\", 1)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Base must be between 2 and 36. Base 1 is impossible.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_63",
        "title": "String Graphemes",
        "description": "True or False?",
        "codeSnippet": "g = String.graphemes(\"a\u0301\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[\"a\u0301\"]` (single grapheme).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_64",
        "title": "Regex run option",
        "description": "Identify option.",
        "codeSnippet": "Regex.run(~r/a/, \"a\", capture: :all_but_first)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Valid options for `capture` are `:all`, `:first`, `:all_but_first`, `:none`. Code is valid. \nReal Error: `Process.exit` logic. \nCode: `Process.exit(self(), :kill)`. \nValid. \nReal Error: `Float.parse` result. \nCode: `f = Float.parse(\"abc\")`. \nError: Returns `:error` (atom) if no float found. If assigned to tuple `{f, _}` match error? No, `Float.parse` returns `{float, rem}` or `:error`. If code is `{f, _} = Float.parse(\"abc\")`, it raises MatchError.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_64_real",
        "title": "Float Parse Match",
        "description": "Identify match error.",
        "codeSnippet": "{f, _} = Float.parse(\"abc\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Float.parse(\"abc\")` returns `:error`. Matching against `{f, _}` fails.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_64",
        "title": "Term to Binary",
        "description": "True or False?",
        "codeSnippet": "b = :erlang.term_to_binary({1})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. ETF serialization.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_65",
        "title": "Binary to term unsafe",
        "description": "Identify safety.",
        "codeSnippet": "t = :erlang.binary_to_term(data, [:safe])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Safe decoding. \nError: `Kernel.exit` vs `Process.exit`. \nCode: `exit(:normal)`. \nValid. \nReal Error: `Struct` pattern match module. \nCode: `%Missing{}`. \nError: CompileError if `Missing` struct not defined.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_65_real",
        "title": "Undefined Struct",
        "description": "Identify compilation error.",
        "codeSnippet": "%UndefinedStruct{key: 1}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Using a struct that has not been defined (or aliased properly) raises a CompileError.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_65",
        "title": "Exception Normalization",
        "description": "True or False?",
        "codeSnippet": "e = Exception.normalize(:error, :undef)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_66",
        "title": "With clause leak",
        "description": "Identify scope.",
        "codeSnippet": "with x <- 1 do\n  y = x + 1\nend\nIO.puts y",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "Variables defined inside `with` block (`y`) are not scoped outside. `y` is undefined.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_66",
        "title": "List Foldl",
        "description": "True or False?",
        "codeSnippet": "List.foldl([1, 2], 0, &(&1 + &2))",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_67",
        "title": "Access impl",
        "description": "Identify behavior.",
        "codeSnippet": "Access.get(%{a: 1}, :a)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: access on struct? \nCode: `s = %User{}; s[:name]`. \nError: Structs do not implement Access behaviour by default (only Maps/Keyword lists). Must implement Access protocol to use `[]` syntax. By default, error/undefined behavior.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_67_real",
        "title": "Struct Access Syntax",
        "description": "Identify protocol support.",
        "codeSnippet": "defmodule S, do: defstruct [:a]\ns = %S{}\nval = s[:a]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Structs do not implement the `Access` behaviour by default, so bracket notation `s[:key]` raises UndefinedFunctionError (for Access.fetch) or similar unless explicitly implemented.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_67",
        "title": "Kernel Put In",
        "description": "True or False?",
        "codeSnippet": "m = put_in(%{a: 1}.a, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Macro syntax.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_68",
        "title": "Update in path",
        "description": "Identify syntax.",
        "codeSnippet": "m = update_in(%{a: 1}, [:b], &(&1 + 1))",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Path `[:b]` does not exist. `update_in` requires path existence unless using `Access.key`? No, simpler `update_in` fails on missing keys usually (KeyError or nil error).",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_68",
        "title": "Get In",
        "description": "True or False?",
        "codeSnippet": "val = get_in(%{a: %{b: 1}}, [:a, :b])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_69",
        "title": "Inspect opts",
        "description": "Identify option.",
        "codeSnippet": "inspect([1], limitt: 5)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Typo `limitt`. Use `limit`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_69",
        "title": "Macro To String",
        "description": "True or False?",
        "codeSnippet": "s = Macro.to_string(quote do: 1 + 2 end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_70",
        "title": "Stream cycle finite",
        "description": "Identify usage.",
        "codeSnippet": "s = Stream.cycle([])\nEnum.take(s, 1)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Cycling an empty list often raises error immediately or hangs? `Stream.cycle([])` is allowed but taking from it? It might raise function clause error or generic error.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_70",
        "title": "Enum Zip",
        "description": "True or False?",
        "codeSnippet": "Default zipping.",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_71",
        "title": "Map.pop default",
        "description": "Identify signature.",
        "codeSnippet": "{v, m} = Map.pop(%{a: 1}, :b)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Returns `{nil, %{a: 1}}`. \nError: `Keyword.pop` result. \nCode: `Keyword.pop([a: 1], :a)`. \nValid. \nReal Error: `Date.new` args. \nCode: `Date.new(2023, 2, 30)`. \nError: Returns `{:error, :invalid_date}`. If matching pattern `{:ok, d}`, fails.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_71_real",
        "title": "Date New Invalid",
        "description": "Identify result.",
        "codeSnippet": "{:ok, d} = Date.new(2023, 2, 30)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Feb 30 is invalid. Returns `{:error, :invalid_date}`. MatchError.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_71",
        "title": "Time Add",
        "description": "True or False?",
        "codeSnippet": "t = Time.add(~T[12:00:00], 60)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Adds seconds.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_72",
        "title": "DateTime compare",
        "description": "Identify operator.",
        "codeSnippet": "d1 = DateTime.utc_now()\nd2 = DateTime.utc_now()\nc = d1 < d2",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Comparing structs (`d1 < d2`) using `<` compares them map-wise (structural), not logically by time. Use `DateTime.compare`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_72",
        "title": "NaiveDateTime Compare",
        "description": "True or False?",
        "codeSnippet": "NaiveDateTime.compare(~N[2000-01-01 00:00:00], ~N[2000-01-01 00:00:01]) == :lt",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_73",
        "title": "URI encode query",
        "description": "Identify input.",
        "codeSnippet": "q = URI.encode_query(\"key=value\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`URI.encode_query` expects a map or keyword list. Passing a string is invalid.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_73",
        "title": "Base Decode",
        "description": "True or False?",
        "codeSnippet": "{:ok, val} = Base.decode64(\"SGVsbG8=\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_74",
        "title": "For reduce init",
        "description": "Identify missing.",
        "codeSnippet": "for x <- [1, 2], reduce: 0 do\n  acc -> acc + x\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid syntax. \nError: `Stream.run` missing. \nCode: `Stream.map([1], &IO.puts/1)`. \nError: Stream is lazy. Nothing happens without `Stream.run` or `Enum.to_list`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_74_real",
        "title": "Lazy Stream",
        "description": "Identify behavior.",
        "codeSnippet": "Stream.map([1, 2], &IO.puts/1)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Streams are lazy. This code creates a stream but does not execute it. Nothing is printed. Use `Stream.run` or `Enum` functions to trigger.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_74",
        "title": "Kernel Max",
        "description": "True or False?",
        "codeSnippet": "max(1, 2) == 2",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_75",
        "title": "Map put bad key",
        "description": "Identify constraint.",
        "codeSnippet": "Map.put(%{}, [1], 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Keys can be lists. \nError: `alias` inside `defprotocol`? \nCode: `defprotocol P do alias My.Long.Name end`. \nValid. \nReal Error: `defguard` not boolean. \nCode: `defguard is_my_type(x) when x + 1`. \nError: Guards must return boolean logic (and be safe). `x + 1` isn't boolean? Actually, function return is checked? Convention. \nReal Error: `defp` with default args. \nCode: `defp f(a \\\\ 1), do: a`. \nValid. \nReal Error: `import` inside function scoping? \nCode: `def f do import List; flatten([[1]]) end`. \nValid. \nReal Error: `Config` script `use Mix.Config` in modern Elixir. \nCode: `use Mix.Config`. \nError: Deprecated in favor of `import Config`. But not error.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_75_real",
        "title": "Invalid Guard Expression",
        "description": "Identify restriction.",
        "codeSnippet": "defguard my_guard(x) when tuple_size(x)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Guards must evaluate to true/false. `tuple_size` returns integer. Not a valid boolean guard expression usually used with operators like `tuple_size(x) > 1`.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_tf_75",
        "title": "Code String Convert",
        "description": "True or False?",
        "codeSnippet": "Code.string_to_quoted!(\"1+1\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 2
    },
    {
        "id": "elixir_err_76",
        "title": "Macro hygiene var",
        "description": "Identify scoping.",
        "codeSnippet": "defmacro my_macro do\n  quote do\n    a = 1\n  end\nend\n# in user code:\nmy_macro()\nIO.puts a",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 7,
        "explanation": "Elixir macros are hygienic. The variable `a` defined inside `quote` does not leak to the caller's context unless `var!(a)` is used. `IO.puts a` will raise CompileError (undefined variable).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_76",
        "title": "Application Get Env",
        "description": "True or False?",
        "codeSnippet": "Application.get_env(:my_app, :key, :default)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Retrieves config.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_77",
        "title": "Defdelegate missing to",
        "description": "Identify syntax details.",
        "codeSnippet": "defdelegate my_func(arg), as: :other_func",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`defdelegate` requires the `:to` option to specify the target module. `as:` is optional.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_77",
        "title": "Task Yield",
        "description": "True or False?",
        "codeSnippet": "t = Task.async(fn -> 1 end)\nTask.yield(t, 5000) || Task.shutdown(t)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Standard pattern.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_78",
        "title": "Case clause leak",
        "description": "Identify scope.",
        "codeSnippet": "case 1 do\n  x -> :ok\nend\nIO.puts x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "Variables bound inside `case` (like `x`) are scoped to the `case` block and are not available outside. `IO.puts x` fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_78",
        "title": "Supervisor Which Children",
        "description": "True or False?",
        "codeSnippet": "Supervisor.which_children(MySup)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_79",
        "title": "GenServer cast return",
        "description": "Identify return.",
        "codeSnippet": "ret = GenServer.cast(pid, :msg)\n# expect ret to be result of handle_cast",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`GenServer.cast` is asynchronous and always returns `:ok` immediately. It does not wait for the result.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_79",
        "title": "Process Monitor",
        "description": "True or False?",
        "codeSnippet": "Process.monitor(pid)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_80",
        "title": "Try Else Clause",
        "description": "Identify usage.",
        "codeSnippet": "try do\n  raise \"e\"\nelse\n  x -> x\nrescue\n  e -> :caught\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "`else` block in `try` is executed only if *no* error occurred in the `do` block. Since `raise` happens, `else` is skipped. If `do` block was safe, `else` would run. This snippet is syntactically valid but logic is specific. Wait. Syntax error? `else` must come after `rescue`/`catch`/`after`? No, `else` comes *before* `rescue` in `try`? \nStructure: `try ... rescue ... catch ... else ... after`. `else` is for success of `try` block. \nActually order is: `try`, `rescue`, `catch`, `else`, `after`. putting `else` before `rescue` is SyntaxError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_80",
        "title": "Enum Map Reduce",
        "description": "True or False?",
        "codeSnippet": "Enum.map_reduce([1, 2], 0, fn x, acc -> {x * 2, x + acc} end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{[2, 4], 3}`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_81",
        "title": "For into binary type",
        "description": "Identify types.",
        "codeSnippet": "for x <- [1, 2], into: \"\", do: x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "If collecting into a binary (`\"\"`), the block must return a string/binary/charlist (something convertible to string). `x` is integer (1, 2). Integers cannot be directly concatenated to binary unless they are code points? `<<1>>` vs `\"1\"`. `into: \"\"` expects binaries usually. If bytes, fine. But `1` is not a char `1` (which is 49). It collects bytes `<<1, 2>>`? \nActually, `Collectable` for binary expects bitstrings. `1` is integer. It fails Protocol `Collectable` implementation? \nWait, `for` uses `Collectable`. `Collectable` for binary appends. `<<acc::binary, item::binary>>`. Item must be binary. `1` is not binary.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_81",
        "title": "IO Iodata",
        "description": "True or False?",
        "codeSnippet": "IO.iodata_to_binary([\"a\", [\"b\", \"c\"]])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Deeply nested lists of strings.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_82",
        "title": "String to integer garbage",
        "description": "Identify runtime.",
        "codeSnippet": "String.to_integer(\"123a\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`String.to_integer` raises ArgumentError if the string is not fully an integer (unlike `Integer.parse`). \"123a\" fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_82",
        "title": "Function Exported",
        "description": "True or False?",
        "codeSnippet": "function_exported?(String, :length, 1)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_83",
        "title": "Alias lexical scope",
        "description": "Identify scoping.",
        "codeSnippet": "if true do\n  alias My.Long.Mod\nend\nMod.func()",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "`alias` is lexically scoped. The alias `Mod` exists only inside the `if` block. Outside, `Mod` is undefined.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_83",
        "title": "Macro To String",
        "description": "True or False?",
        "codeSnippet": "Macro.to_string(quote do: 1 + 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_84",
        "title": "Import inside match",
        "description": "Identify syntax.",
        "codeSnippet": "case x do\n  import MyMod -> :ok\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`import` cannot be used inside a match clause body? Actually it can be used in block, but lexical scope is tiny. \nBetter error: `defstruct` twice. \nCode: `defstruct a: 1; defstruct b: 2`. \nError: Only one `defstruct` allowed per module.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_84_real",
        "title": "Double Defstruct",
        "description": "Identify definition constraint.",
        "codeSnippet": "defmodule M do\n  defstruct [:a]\n  defstruct [:b]\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Defining `defstruct` multiple times in a module is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_84",
        "title": "Port Open",
        "description": "True or False?",
        "codeSnippet": "Port.open({:spawn, \"cat\"}, [:binary])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_85",
        "title": "Receive after bad timeout",
        "description": "Identify types.",
        "codeSnippet": "receive do\n  :msg -> :ok\nafter\n  :oops -> :timeout\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 3,
        "explanation": "The `after` clause expects an integer timeout value (milliseconds) or `:infinity`. `:oops` is an atom (not infinity), invalid timeout.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_85",
        "title": "System Schedulers",
        "description": "True or False?",
        "codeSnippet": "System.schedulers_online()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_86",
        "title": "Defimpl argument",
        "description": "Identify match.",
        "codeSnippet": "defimpl MyProto, for: User do\n  def func(x, y), do: x\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "The first argument of a protocol function implementation must be the struct/type being implemented (`User`). If the protocol definition `defprotocol` specifies arity 1 `func(t)`, then `defimpl` must match. Usually correct, but if protocol expects `func(data)`, implementation is `def func(user)`. If `defimpl` has `def func(x, y)` but protocol is `/1`, it's an error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_86",
        "title": "Tuple To List",
        "description": "True or False?",
        "codeSnippet": "Tuple.to_list({1, 2})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_87",
        "title": "Super without override",
        "description": "Identify context.",
        "codeSnippet": "defmodule M do\n  def func, do: super()\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`super` can only be called inside `defoverridable` functions or when overriding behaviour callbacks/macros where `super` makes sense? No, `super` is used in `use` macros (like `GenServer`) if they make functions overridable. In a plain module function `func`, `super` is undefined.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_87",
        "title": "Module Concat",
        "description": "True or False?",
        "codeSnippet": "Module.concat(My, Module)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `My.Module` atom.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_88",
        "title": "Behavior spelling",
        "description": "Identify typo.",
        "codeSnippet": "@behavior GenServer",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Elixir uses the British spelling `@behaviour`. `@behavior` is ignored (treated as arbitrary attribute) and does not enforce callbacks.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_88",
        "title": "Code Compile String",
        "description": "True or False?",
        "codeSnippet": "Code.compile_string(\"defmodule M, do: nil\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_89",
        "title": "Fn no arrow",
        "description": "Identify syntax.",
        "codeSnippet": "f = fn x do x end",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Anonymous functions use `->`. syntax is `fn x -> x end`. `do` is for blocks in named functions/macros.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_89",
        "title": "Map Pop",
        "description": "True or False?",
        "codeSnippet": "Map.pop(%{a: 1}, :a)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{1, %{}}`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_90",
        "title": "Cond nil clause",
        "description": "Identify flow.",
        "codeSnippet": "cond do\n  nil -> :a\n  false -> :b\n  # no true clause\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 4,
        "explanation": "`cond` searches for a truthy value (not nil or false). If all clauses return nil/false, `CondClauseError` is raised. Need a default `true -> ...`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_90",
        "title": "Keyword Merge",
        "description": "True or False?",
        "codeSnippet": "Keyword.merge([a: 1], [a: 2])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[a: 2]`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_91",
        "title": "Kernel put_elem range",
        "description": "Identify bounds.",
        "codeSnippet": "put_elem({1, 2}, 5, 3)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Index 5 is out of bounds for tuple of size 2. Raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_91",
        "title": "Process Sleep",
        "description": "True or False?",
        "codeSnippet": "Process.sleep(1000)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_92",
        "title": "Module attributes in function",
        "description": "Identify context.",
        "codeSnippet": "def f do\n  @attr 1\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Module attributes cannot be defined inside a function. They must be defined at the module level.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_92",
        "title": "URI Encode Query",
        "description": "True or False?",
        "codeSnippet": "URI.encode_query(%{q: \"foo bar\"})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `\"q=foo+bar\"`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_93",
        "title": "Date new bad invalid",
        "description": "Identify return.",
        "codeSnippet": "{:ok, d} = Date.new(2023, 2, 30)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Date.new` returns `{:error, :invalid_date}` for Feb 30. Match against `{:ok, d}` fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_93",
        "title": "Time Add",
        "description": "True or False?",
        "codeSnippet": "Time.add(~T[10:00:00], 60)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Adds seconds.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_94",
        "title": "Guard call remote",
        "description": "Identify restriction.",
        "codeSnippet": "def f(x) when MyMod.is_valid(x), do: x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Remote function calls (`MyMod.is_valid`) are not allowed in guards (unless `defguard` was used to define it as a macro). Assuming `is_valid` is a plain function, it fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_94",
        "title": "Path Wildcard",
        "description": "True or False?",
        "codeSnippet": "Path.wildcard(\"*.ex\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_95",
        "title": "Capture private function",
        "description": "Identify visibility.",
        "codeSnippet": "f = &MyMod.private_func/1",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Cannot capture a private function (`defp`) from outside the module. Raises UndefinedFunctionError/CompileError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_95",
        "title": "Ets New",
        "description": "True or False?",
        "codeSnippet": ":ets.new(:table, [:set, :public])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_96",
        "title": "Protocol not consolidated",
        "description": "Identify concept.",
        "codeSnippet": "# Assume protocol P\nP.impl_for([])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Checks implementation. \nError: `with` else clause match. \nCode: `with :ok <- :error, do: 1, else: (:fail -> 0)`. \nValid. \nReal Error: `def` with missing `do`. \nCode: `def func(x) x + 1`. \nError: Missing `do` keyword. `def func(x), do: x + 1`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_96_real",
        "title": "Def missing do",
        "description": "Identify syntax.",
        "codeSnippet": "def add(a, b) a + b",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Missing `do` block or keyword. Should be `def add(a, b) do ... end` or `, do: ...`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_96",
        "title": "GenServer Multi Call",
        "description": "True or False?",
        "codeSnippet": "GenServer.multi_call([n1, n2], :server, :req)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_97",
        "title": "Alias as atom",
        "description": "Identify syntax.",
        "codeSnippet": "alias MyMod, as: :mod",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "The `as:` option in `alias` expects an Alias (a module name like `Mod`), not a raw atom (`:mod`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_97",
        "title": "Process Link",
        "description": "True or False?",
        "codeSnippet": "Process.link(self())",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Link to self is weird but valid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_98",
        "title": "Struct default required",
        "description": "Identify syntax.",
        "codeSnippet": "defmodule S do\n  @enforce_keys [:a]\n  defstruct [:a, b: 2]\nend\ns = %S{}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 4,
        "explanation": "Key `:a` is enforced. Creating struct `%S{}` without `:a` raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_98",
        "title": "Access Key",
        "description": "True or False?",
        "codeSnippet": "get_in(%{a: %{b: 1}}, [:a, :b])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_99",
        "title": "Unquote outside quote",
        "description": "Identify context.",
        "codeSnippet": "def f(x) do\n  unquote(x)\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`unquote` can only be used inside `quote`. Using it in regular code is a CompileError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_99",
        "title": "Macro Expand",
        "description": "True or False?",
        "codeSnippet": "Macro.expand(quote(do: MyAlias), __ENV__)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_100",
        "title": "Map new args",
        "description": "Identify signature.",
        "codeSnippet": "Map.new([1, 2])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Map.new` expects a list of tuples `{key, val}` or an enumerable. `[1, 2]` is a list of integers. It cannot convert integers to key-value pairs. Raises ArgumentError/FunctionClauseError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_100",
        "title": "System Unique Integer",
        "description": "True or False?",
        "codeSnippet": "System.unique_integer([:positive, :monotonic])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_101",
        "title": "Def without module",
        "description": "Identify context.",
        "codeSnippet": "def my_func do\n  :ok\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Named functions `def` must be defined inside a module (`defmodule`). Top-level `def` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_101",
        "title": "System OS Time",
        "description": "True or False?",
        "codeSnippet": "System.os_time(:second)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_102",
        "title": "Import conflict local",
        "description": "Identify ambiguity.",
        "codeSnippet": "defmodule M do\n  import List, only: [flatten: 1]\n  def flatten(x), do: x\n  def run do\n    flatten([1])\n  end\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 5,
        "explanation": "Importing `flatten/1` and defining `flatten/1` locally creates a conflict. The local definition takes precedence, but usually this warns or requires explicit `List.flatten` to avoid ambiguity if that was intended, or prevents import.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_102",
        "title": "Date Add",
        "description": "True or False?",
        "codeSnippet": "Date.add(~D[2023-01-01], 1)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `~D[2023-01-02]`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_103",
        "title": "Stream unfold tuple",
        "description": "Identify return.",
        "codeSnippet": "Stream.unfold(5, fn n -> n - 1 end) |> Enum.take(5)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Stream.unfold` function must return `{value, next_acc}` or `nil`. Returning just `n-1` (an integer) causes a runtime error when stream is consumed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_103",
        "title": "IO Chardata",
        "description": "True or False?",
        "codeSnippet": "IO.chardata_to_string([97, 98, 99])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"abc\".",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_104",
        "title": "Bit size list",
        "description": "Identify type.",
        "codeSnippet": "bit_size([1, 2])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`bit_size` expects a bitstring. Passing a list raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_104",
        "title": "Map To List",
        "description": "True or False?",
        "codeSnippet": "Map.to_list(%{a: 1})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_105",
        "title": "Defp Overridable",
        "description": "Identify visibility.",
        "codeSnippet": "defmodule M do\n  defp f, do: 1\n  defoverridable [f: 0]\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Cannot make a private function (`defp`) overridable. `defoverridable` works with public functions.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_105",
        "title": "Process Flag Priority",
        "description": "True or False?",
        "codeSnippet": "Process.flag(:priority, :high)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_106",
        "title": "Struct Map Match",
        "description": "Identify match.",
        "codeSnippet": "%{:a => 1} = %User{a: 1}",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. A struct is a map, so matching `%{:a => 1}` (a map pattern) against a struct works. \nError: `defmodule` inside function. \nCode: `def f, do: defmodule M do end`. \nError: Modules are top-level. \nReal Error: `fn` multiple clauses arity mismatch. \nCode: `fn x -> 1; x, y -> 2 end`. \nError: All clauses in an anonymous function must have same arity.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_106_real",
        "title": "Fn Arity Mismatch",
        "description": "Identify syntax.",
        "codeSnippet": "f = fn\n  x -> x\n  x, y -> x + y\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "Functions cannot have clauses with different arities (1 vs 2 arguments).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_106",
        "title": "Code Ensure Loaded",
        "description": "True or False?",
        "codeSnippet": "Code.ensure_loaded?(String)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_107",
        "title": "Map key dot access missing",
        "description": "Identify runtime.",
        "codeSnippet": "m = %{a: 1}\nm.b",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Accessing missing key `b` via dot syntax `m.b` raises KeyError. Accessing via `m[:b]` returns `nil`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_107",
        "title": "Keyword Values",
        "description": "True or False?",
        "codeSnippet": "Keyword.values([a: 1, b: 2])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_108",
        "title": "IO write integer",
        "description": "Identify types.",
        "codeSnippet": "IO.write(123)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`IO.write` expects chardata (string, charlist). Passing an integer (unless it's a code point in a list) is invalid data for write? Actually raw integer 123 is not valid iodata. `IO.write` raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_108",
        "title": "List Keyfind",
        "description": "True or False?",
        "codeSnippet": "List.keyfind([{:a, 1}], :a, 0)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_109",
        "title": "System put env persistence",
        "description": "Identify scope.",
        "codeSnippet": "System.put_env(\"MY_VAR\", \"1\")\n# Restart app, check var",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Environment variables set by `System.put_env` are process-specific (or OS process specific). They do not persist after the BEAM process exits. \nReal Error: `Atom.to_string` on non-atom. \nCode: `Atom.to_string(\"s\")`. \nError: ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_109_real",
        "title": "Atom To String type",
        "description": "Identify type.",
        "codeSnippet": "Atom.to_string(\"already_string\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Argument must be an atom.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_109",
        "title": "Macro Var",
        "description": "True or False?",
        "codeSnippet": "Macro.var(:x, nil)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Generates AST for variable.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_110",
        "title": "Enum chunk_every step 0",
        "description": "Identify logic.",
        "codeSnippet": "Enum.chunk_every([1], 2, 0)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Step must be positive. Step 0 implies infinite loop/invalid chunking. Raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_110",
        "title": "Enum Chunk Every",
        "description": "True or False?",
        "codeSnippet": "Enum.chunk_every([1, 2, 3], 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_111",
        "title": "Agent cast return",
        "description": "Identify return.",
        "codeSnippet": "res = Agent.cast(pid, fn s -> s end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Agent.cast` returns `:ok`. It does not return the state. Use `Agent.get`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_111",
        "title": "MapSet Difference",
        "description": "True or False?",
        "codeSnippet": "MapSet.difference(MapSet.new([1]), MapSet.new([2]))",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_112",
        "title": "For reduce missing acc",
        "description": "Identify syntax.",
        "codeSnippet": "for x <- [1], reduce: 0 do\n  acc -> acc + x\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "The block in `reduce` expects `x, acc ->` (item, accumulator). `acc ->` only matches 1 arg. Arity mismatch.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_112",
        "title": "Float Round",
        "description": "True or False?",
        "codeSnippet": "Float.round(1.234, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_113",
        "title": "Process register bad name",
        "description": "Identify constraint.",
        "codeSnippet": "Process.register(self(), \"MyString\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Process name must be an atom. String is not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_113",
        "title": "String Jaro Distance",
        "description": "True or False?",
        "codeSnippet": "String.jaro_distance(\"foo\", \"bar\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_114",
        "title": "Struct pattern match keys",
        "description": "Identify match.",
        "codeSnippet": "%User{non_existent: v} = user",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Pattern matching on struct key that doesn't exist in definition `defstruct` raises CompileError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_114",
        "title": "System Version",
        "description": "True or False?",
        "codeSnippet": "System.version()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_115",
        "title": "Keyword list duplicate keys syntax",
        "description": "Identify syntax.",
        "codeSnippet": "[a: 1, a: 2]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. Keyword lists allow duplicate keys. \nError: `defmodule` alias conflict. \nCode: `defmodule List.Enum do end`. \nError: `List` is already a module. `List.Enum` is fine. \nReal Error: `def` defaults in two places. \nCode: `def f(x \\\\ 1); def f(x \\\\ 2) do x end`. \nError: Defaults should be defined in the function head (header) only once.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_115_real",
        "title": "Default args redeclared",
        "description": "Identify syntax.",
        "codeSnippet": "def f(x \\\\ 1)\ndef f(x \\\\ 2) do\n  x\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Default arguments `\\\\` should only be specified in the function header, and only once.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_115",
        "title": "Integer Digits",
        "description": "True or False?",
        "codeSnippet": "Integer.digits(123)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_116",
        "title": "Destructure mismatch",
        "description": "Identify behavior.",
        "codeSnippet": "destructure [a, b], [1]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`destructure` is robust. If list is short, remaining vars are nil. No error. \nReal Error: `Kernel` function override warning/error. \nCode: `def unquote(x), do: x`. \nError: `unquote` is special form? \nReal Error: `defmacro` name conflict. \nCode: `defmacro case(x), do: ...`. \nError: `case` is a special form, cannot be redefined.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_116_real",
        "title": "Redefine Special Form",
        "description": "Identify constraint.",
        "codeSnippet": "defmacro case(expr, opts) do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Cannot redefine special forms like `case`, `cond`, `if` (unless imported `Kernel` is excluded, but key forms are reserved).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_116",
        "title": "List Starts With",
        "description": "True or False?",
        "codeSnippet": "List.starts_with?([1, 2], [1])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_117",
        "title": "Guard variable unused",
        "description": "Identify warning.",
        "codeSnippet": "def f(x) when x > 0 do\n  :ok\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `def` with `fn`. \nCode: `def f = fn -> end`. \nError: `def f` requires `do` block. \nReal Error: `def` name is variable. \nCode: `name = :func; def unquote(name)(), do: ok`. \nValid metaprogramming. \nReal Error: `raise` without exception. \nCode: `raise :ok`. \nError: `raise` expects string (message) or Exception struct. `:ok` is atom.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_117_real",
        "title": "Raise atom",
        "description": "Identify types.",
        "codeSnippet": "raise :some_atom",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`raise/1` expects a string message or an exception module/struct. Raising a raw atom is ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_117",
        "title": "Macro Escape",
        "description": "True or False?",
        "codeSnippet": "Macro.escape(%{a: 1})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_118",
        "title": "Map drop bad keys",
        "description": "Identify type.",
        "codeSnippet": "Map.drop(%{a: 1}, :a)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Map.drop` second argument must be a list of keys. Passing single key `:a` raises error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_118",
        "title": "Regex Scan",
        "description": "True or False?",
        "codeSnippet": "Regex.scan(~r/a/, \"aa\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_119",
        "title": "Task await multiple",
        "description": "Identify limitation.",
        "codeSnippet": "t = Task.async(fn -> 1 end)\nTask.await(t)\nTask.await(t)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "A task can be awaited only once. Second await will timeout (caller is no longer monitoring the finished process) or exit because monitor linkage is gone.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_119",
        "title": "Tuple Duplicate",
        "description": "True or False?",
        "codeSnippet": "Tuple.duplicate(:a, 3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{:a, :a, :a}`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_120",
        "title": "String slice step",
        "description": "Identify args.",
        "codeSnippet": "String.slice(\"abc\", 0..2, 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`String.slice` takes 2 or 3 arguments? `String.slice(str, range)` or `String.slice(str, start, len)`. Range + len/step? No such signature.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_120",
        "title": "Process Group Leader",
        "description": "True or False?",
        "codeSnippet": "Process.group_leader(self(), self())",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Sets group leader.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_121",
        "title": "System cmd dir invalid",
        "description": "Identify option.",
        "codeSnippet": "System.cmd(\"ls\", [], cd: \"/nonexist\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "If `cd` directory does not exist, `System.cmd` raises Erlang error `:enoent`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_121",
        "title": "Enum Zip Reduce",
        "description": "True or False?",
        "codeSnippet": "Enum.zip_reduce([1], [2], 0, fn x, y, acc -> x+y+acc end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_122",
        "title": "Bitwise import conflict",
        "description": "Identify context.",
        "codeSnippet": "import Bitwise\nbor(1, 2) # valid\nband(1, 2) # valid\n# ...",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `defguard` name capitalization. \nCode: `defguard IsInteger(x) ...`. \nError: Macros/guards should be snake_case. Capitalized is for modules. Syntax error? Warning. \nReal Error: `defimpl` without `for`. \nCode: `defimpl MyProto do ... end`. \nError: `defimpl` requires `for:` option.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_122_real",
        "title": "Defimpl missing for",
        "description": "Identify syntax.",
        "codeSnippet": "defimpl MyProto do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`defimpl` requires the `for:` argument specifying types.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_122",
        "title": "System OTP Release",
        "description": "True or False?",
        "codeSnippet": "System.otp_release()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_123",
        "title": "IO inspect width string",
        "description": "Identify option.",
        "codeSnippet": "IO.inspect(1, width: \"80\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`width` option must be an integer. Passing string causes error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_123",
        "title": "Map Take",
        "description": "True or False?",
        "codeSnippet": "Map.take(%{a: 1}, [:a])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_124",
        "title": "Stream transform args",
        "description": "Identify signature.",
        "codeSnippet": "Stream.transform([1], 0, fn x -> x end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Stream.transform` callback expects `(item, acc) -> {list, acc}`. `fn x -> x end` is arity 1. Error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_124",
        "title": "Keyword Check",
        "description": "True or False?",
        "codeSnippet": "Keyword.keyword?([a: 1])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_125",
        "title": "GenServer call arg mismatch",
        "description": "Identify signature.",
        "codeSnippet": "GenServer.call(pid, :msg, :infinity, :extra)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`GenServer.call` takes up to 3 arguments (pid, request, timeout). 4 arguments passed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_125",
        "title": "Base URL Encode",
        "description": "True or False?",
        "codeSnippet": "Base.url_encode64(\"a\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_126",
        "title": "Module put attribute macro",
        "description": "Identify context.",
        "codeSnippet": "defmodule M do\n  def f do\n    Module.put_attribute(__MODULE__, :a, 1)\n  end\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid, but attributes are compile-time. Setting attribute inside a function definition might not do what user expects if used later in same function (attributes are for module body execution). But syntactically works. \nError: `defmodule` inside `if`. \nCode: `if true, do: defmodule M do end`. \nValid. \nReal Error: `def` clause body missing. \nCode: `def f(x)`. \nError: Definition must have a body or be a header (if subsequent clauses follow). If solitary, error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_126_real",
        "title": "Def bodiless",
        "description": "Identify syntax.",
        "codeSnippet": "defmodule M do\n  def f(x)\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "A function definition `def` must have a body (`do ... end` or `, do: ...`) unless it is a header for default arguments followed by other clauses. A solitary header is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_126",
        "title": "System User Home",
        "description": "True or False?",
        "codeSnippet": "System.user_home()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_127",
        "title": "Stream resource cleanup arity",
        "description": "Identify signature.",
        "codeSnippet": "Stream.resource(fn -> 1 end, fn acc -> {[], acc} end, fn acc -> :ok end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid signature: start/0, next/1, after/1. \nError: `def` visibility change. \nCode: `defp f, do: 1; def f, do: 2`. \nError: Cannot define function as private and public with same name/arity.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_127_real",
        "title": "Mix Private Public Def",
        "description": "Identify constraint.",
        "codeSnippet": "defp my_func(x), do: x\ndef my_func(x), do: x * 2",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Cannot define the same function (name/arity) as both private (`defp`) and public (`def`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_127",
        "title": "Map New Transform",
        "description": "True or False?",
        "codeSnippet": "Map.new([1, 2], fn x -> {x, x*2} end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_128",
        "title": "Try Catch pattern",
        "description": "Identify syntax.",
        "codeSnippet": "try do\n  throw :oops\ncatch\n  :throw, val -> val\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. `catch` matches `kind, value`. \nError: `import` conflict with Kernel. \nCode: `defmodule M do import Map; def new, do: 1 end`. \nValid. \nReal Error: `def` with `when` guard complex match. \nCode: `def f(x) when x = 1 do ...`. \nError: `=/2` operator not allowed in guards.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_128_real",
        "title": "Guard Assignment",
        "description": "Identify restriction.",
        "codeSnippet": "def f(x) when x = 1, do: x",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Assignment (`=`) is not allowed in guard clauses. Use `==` for comparison.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_128",
        "title": "Integer Mod",
        "description": "True or False?",
        "codeSnippet": "Integer.mod(5, 2)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_129",
        "title": "Keyword put non atom key",
        "description": "Identify type.",
        "codeSnippet": "Keyword.put([], \"key\", 1)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Keyword lists must have atom keys. `\"key\"` is a string. `Keyword.put` raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_129",
        "title": "List To String",
        "description": "True or False?",
        "codeSnippet": "List.to_string([65, 66])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"AB\".",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_130",
        "title": "Enum map integer",
        "description": "Identify protocol.",
        "codeSnippet": "Enum.map(123, &(&1 * 2))",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Integers are not Enumerable. `Enum.map` raises Protocol.UndefinedError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_130",
        "title": "Process Trap Exit",
        "description": "True or False?",
        "codeSnippet": "Process.flag(:trap_exit, true)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_131",
        "title": "List delete count",
        "description": "Identify signature.",
        "codeSnippet": "List.delete([1, 1], 1, 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`List.delete/2` deletes the *first* occurrence. It takes 2 arguments (list, item). There is no 3-argument version (unlike `List.delete_at`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_131",
        "title": "Module Split",
        "description": "True or False?",
        "codeSnippet": "Module.split(My.Module)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[\"My\", \"Module\"]`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_132",
        "title": "Date invalid range literal",
        "description": "Identify syntax.",
        "codeSnippet": "d = ~D[2023-02-31]",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "February 31 is invalid. Sigil fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_132",
        "title": "System Build Info",
        "description": "True or False?",
        "codeSnippet": "System.build_info()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_133",
        "title": "Spawn invalid func",
        "description": "Identify types.",
        "codeSnippet": "spawn(:not_a_func)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`spawn` expects a function (`fn -> ... end`). Passing an atom is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_133",
        "title": "Tuple To List Again",
        "description": "True or False?",
        "codeSnippet": "Tuple.to_list({:a, :b})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_134",
        "title": "GenServer init return",
        "description": "Identify return.",
        "codeSnippet": "def init(_), do: :ok",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`init` callback must return `{:ok, state}` (or other tuple variants). Returning raw `:ok` is invalid cause for shutdown/error.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_134",
        "title": "Macro Underscore",
        "description": "True or False?",
        "codeSnippet": "Macro.underscore(\"MyModule\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns \"my_module\".",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_135",
        "title": "Regex invalid modifiers",
        "description": "Identify syntax.",
        "codeSnippet": "~r/foo/z",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Modifier `z` is not a valid Regex modifier (valid ones: `u`, `i`, `m`, `s`, `x`, `r`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_135",
        "title": "Kernel Is Struct",
        "description": "True or False?",
        "codeSnippet": "is_struct(%User{})",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_136",
        "title": "IO binread bad device",
        "description": "Identify args.",
        "codeSnippet": "IO.binread(\"file.txt\", :all)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`IO.binread/2` expects first arg to be an IO device (pid/atom). Passing a filename string is common confusion with `File.read`. It fails unless \"file.txt\" is a process name (unlikely).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_136",
        "title": "Stream Iterate",
        "description": "True or False?",
        "codeSnippet": "Stream.iterate(0, &(&1 + 1)) |> Enum.take(3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `[0, 1, 2]`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_137",
        "title": "File ln_s args reversed?",
        "description": "Identify signature.",
        "codeSnippet": "File.ln_s(\"existing\", \"new_link\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. `ln_s(existing, new)`. \nError: `Kernel` binding conflict. \nCode: `quote do: var!(Unquote) = 1`. \nValid. \nReal Error: `def` guards side effects? \nCode: `def f(x) when IO.puts(x) do ...`. \nError: Guards cannot have side effects (like `IO.puts`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_137_real",
        "title": "Guard Side Effect",
        "description": "Identify restriction.",
        "codeSnippet": "def f(x) when IO.puts(x) do\n  :ok\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Guards must be pure/safe. `IO.puts` causes side effects and is not allowed in guards.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_137",
        "title": "System Monotonic Time",
        "description": "True or False?",
        "codeSnippet": "System.monotonic_time()",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_138",
        "title": "Keyword get_values missing arg",
        "description": "Identify signature.",
        "codeSnippet": "Keyword.get_values([a: 1])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Keyword.get_values` requires a key argument. `Keyword.get_values(list, key)`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_138",
        "title": "Exception Normalize",
        "description": "True or False?",
        "codeSnippet": "Exception.normalize(:error, :badarg)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_139",
        "title": "System halt string",
        "description": "Identify type.",
        "codeSnippet": "System.halt(\"error\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`System.halt` expects an integer status code (0-255) (or string in some Erlang versions? No, usually integer status). Passing raw string usually unsupported.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_139",
        "title": "Code Format String",
        "description": "True or False?",
        "codeSnippet": "Code.format_string!(\"[1, 2]\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_140",
        "title": "OptionParser invalid option format",
        "description": "Identify syntax.",
        "codeSnippet": "OptionParser.parse([\"--flag\"], strict: [flag: :boolean])",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": -1,
        "explanation": "Valid. \nError: `defmodule` interpolation? \nCode: `name = :M; defmodule name do end`. \nError: `defmodule` argument must be an atom/alias at *compile time*. Variable `name` is runtime (or context dependent). Usually invalid unless inside unquote/macro.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_140_real",
        "title": "Defmodule Variable Name",
        "description": "Identify context.",
        "codeSnippet": "mod_name = MyMod\ndefmodule mod_name do\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`defmodule` name must be an atom/alias literal or unquoted expression. Passing a variable `mod_name` directly raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_140",
        "title": "Map Split",
        "description": "True or False?",
        "codeSnippet": "Map.split(%{a: 1, b: 2}, [:a])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns `{%{a: 1}, %{b: 2}}`.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_141",
        "title": "Process exit normal",
        "description": "Identify behavior.",
        "codeSnippet": "Process.exit(self(), :normal)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Process.exit(self(), :normal)` exits immediately. Logic is valid, but calling it on `self` is same as `exit(:normal)`. Wait. Error? No. `Process.exit(pid, reason)` sends exit signal. \nReal Error: `File.read!` return. \nCode: `{:ok, content} = File.read!(\"file.txt\")`. \nError: `File.read!` returns the contents directly (binary), or raises error. It does not return `{:ok, content}` tuple.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_141_real",
        "title": "File Read Bang Return",
        "description": "Identify return.",
        "codeSnippet": "{:ok, content} = File.read!(\"existing.txt\")",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Bang functions like `File.read!` return the value directly on success. Matching against `{:ok, ...}` fails.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_141",
        "title": "Spawn Link",
        "description": "True or False?",
        "codeSnippet": "spawn_link(fn -> :ok end)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_142",
        "title": "Task await timeout boolean",
        "description": "Identify type.",
        "codeSnippet": "Task.await(t, true)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "Second argument to `Task.await` is timeout (integer or :infinity). Boolean `true` is invalid.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_142",
        "title": "String Myers Difference",
        "description": "True or False?",
        "codeSnippet": "String.myers_difference(\"ab\", \"ac\")",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_143",
        "title": "URI parse integer",
        "description": "Identify types.",
        "codeSnippet": "URI.parse(123)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`URI.parse` expects a string argument.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_143",
        "title": "Date Day of Week",
        "description": "True or False?",
        "codeSnippet": "Date.day_of_week(~D[2023-01-01])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_144",
        "title": "Enum count bad fun",
        "description": "Identify signature.",
        "codeSnippet": "Enum.count([1, 2], fn x -> x end)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Enum.count/2` expects function to return truthy/falsy check? Yes. But wait. `Enum.count` counts items where function is true. If `x` is integer `1` (truthy), it works. \nReal Error: `def` inside `fn`. \nCode: `fn -> def f, do: 1 end`. \nError: `def` inside anon func is not allowed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_144_real",
        "title": "Def inside Fn",
        "description": "Identify context.",
        "codeSnippet": "f = fn ->\n  def defined_here, do: :ok\nend",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "Cannot define named functions (`def`) inside an anonymous function.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_144",
        "title": "Function Capture",
        "description": "True or False?",
        "codeSnippet": "Function.capture(String, :length, 1)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_145",
        "title": "Stream uniq infinite",
        "description": "Identify memory.",
        "codeSnippet": "Stream.cycle([1, 2]) |> Stream.uniq() |> Enum.to_list()",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Stream.uniq` stores seen items indefinitely. On an infinite stream, it will eventually consume all memory or hang if trying to convert to list without limit. `Enum.to_list` never returns.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_145",
        "title": "Macro Prewalk",
        "description": "True or False?",
        "codeSnippet": "Macro.prewalk(quote(do: 1+1), &(&1))",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_146",
        "title": "Agent start link args",
        "description": "Identify signature.",
        "codeSnippet": "Agent.start_link(:initial_state)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`Agent.start_link` expects a function that returns initial state, not the state itself (`fn -> :initial_state end`).",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_146",
        "title": "Access Elem",
        "description": "True or False?",
        "codeSnippet": "get_in({1, 2}, [Access.elem(0)])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 1.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_147",
        "title": "Struct! missing keys",
        "description": "Identify runtime.",
        "codeSnippet": "defmodule S, do: defstruct [:a]\nstruct!(S, b: 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 1,
        "explanation": "`struct!` checks ensuring keys exist. `:b` is not in struct `S`, so it raises KeyError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_147",
        "title": "System Cmd",
        "description": "True or False?",
        "codeSnippet": "System.cmd(\"echo\", [\"hello\"])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_148",
        "title": "Registry duplicate key",
        "description": "Identify limit.",
        "codeSnippet": "Registry.start_link(keys: :unique, name: R)\nRegistry.register(R, \"key\", 1)\nRegistry.register(R, \"key\", 2)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 2,
        "explanation": "If `keys: :unique`, registering the same key twice causes the second call to fail (crash/error) or return `{:error, {:already_registered, _}}`. It won't succeed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_148",
        "title": "IO ANSI Format",
        "description": "True or False?",
        "codeSnippet": "IO.ANSI.format([:red, \"Error\"])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_149",
        "title": "File stream mode atom",
        "description": "Identify type.",
        "codeSnippet": "File.stream!(\"f.txt\", :read)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`File.stream!` modes argument should be a list `[:read]`. Passing atom directly raises ArgumentError.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_149",
        "title": "Enum Dedup",
        "description": "True or False?",
        "codeSnippet": "Enum.dedup([1, 1, 2])",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_err_150",
        "title": "Destructure arity",
        "description": "Identify usage.",
        "codeSnippet": "destructure([a], [1, 2], 3)",
        "type": "errorSpotting",
        "language": "elixir",
        "errorLineIndex": 0,
        "explanation": "`destructure` takes 2 arguments: variables and expression. 3 arguments passed.",
        "difficultyLevel": 3
    },
    {
        "id": "elixir_tf_150",
        "title": "Integer Pow",
        "description": "True or False?",
        "codeSnippet": "Integer.pow(2, 3)",
        "type": "trueOrFalse",
        "language": "elixir",
        "isCodeCorrect": true,
        "explanation": "True. Returns 8.",
        "difficultyLevel": 3
    }
]