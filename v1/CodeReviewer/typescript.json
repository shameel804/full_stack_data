[
    {
        "id": "typescript_err_1",
        "title": "Type mismatch",
        "description": "Find error.",
        "codeSnippet": "let x: number = 'hello';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type 'string' is not assignable to type 'number'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_1",
        "title": "Type inference",
        "description": "Inference.",
        "codeSnippet": "let x = 10;\n// x is inferred as number?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "TypeScript infers 'x' to be of type 'number' from the initializer.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_2",
        "title": "Const reassignment",
        "description": "Find error.",
        "codeSnippet": "const x: number = 10;\nx = 20;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Cannot assign to 'x' because it is a constant.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_2",
        "title": "Any type",
        "description": "Flexibility.",
        "codeSnippet": "let x: any = 10;\nx = 'hello';\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Variables of type 'any' can be assigned any value.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_3",
        "title": "Missing property",
        "description": "Find error.",
        "codeSnippet": "interface User { name: string; }\nconst u: User = { age: 20 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'name' is missing in type '{ age: number; }' but required in type 'User'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_3",
        "title": "Void return",
        "description": "Function type.",
        "codeSnippet": "function log(msg: string): void {\n  console.log(msg);\n}\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Functions that do not return a value have a return type of 'void'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_4",
        "title": "Extra property",
        "description": "Find error.",
        "codeSnippet": "interface Point { x: number; y: number; }\nconst p: Point = { x: 1, y: 2, z: 3 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Object literal may only specify known properties, and 'z' does not exist in type 'Point'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_4",
        "title": "Tuple type",
        "description": "Declaration.",
        "codeSnippet": "let x: [string, number];\nx = ['hello', 10];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Correct assignment to a tuple type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_5",
        "title": "Parameter type mismatch",
        "description": "Find error.",
        "codeSnippet": "function add(a: number, b: number) { return a + b; }\nadd(1, '2');",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Argument of type 'string' is not assignable to parameter of type 'number'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_5",
        "title": "Optional property",
        "description": "Interface.",
        "codeSnippet": "interface Config { verbose?: boolean; }\nconst c: Config = {};\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Optional properties (?) are not required.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_6",
        "title": "Readonly property assignment",
        "description": "Find error.",
        "codeSnippet": "interface Point { readonly x: number; }\nconst p: Point = { x: 10 };\np.x = 20;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Cannot assign to 'x' because it is a read-only property.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_6",
        "title": "Union type assignment",
        "description": "Validity.",
        "codeSnippet": "let id: number | string;\nid = 101;\nid = '202';\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Union type allows values of either specified type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_7",
        "title": "Union type operations",
        "description": "Find error.",
        "codeSnippet": "function printId(id: number | string) {\n  console.log(id.toUpperCase());\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'toUpperCase' does not exist on type 'number'. It only exists on 'string'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_7",
        "title": "Array type syntax",
        "description": "Notation.",
        "codeSnippet": "let list: number[] = [1, 2, 3];\n// Equivalent to Array<number>?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'number[]' and 'Array<number>' are equivalent.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_8",
        "title": "Enum value mismatch",
        "description": "Find error.",
        "codeSnippet": "enum Direction { Up, Down }\nlet d: Direction = 'Left';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type '\"Left\"' is not assignable to type 'Direction'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_8",
        "title": "Unknown type",
        "description": "Safety.",
        "codeSnippet": "let x: unknown = 10;\nlet y: number = x; // Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Type 'unknown' is not assignable to type 'number' without narrowing/assertion. 'isCodeCorrect' is false means the code has an error.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_9",
        "title": "Null assignment strict",
        "description": "Find error.",
        "codeSnippet": "// strictNullChecks: true\nlet x: number = null;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'null' is not assignable to type 'number' with strictNullChecks enabled.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_9",
        "title": "Literal type",
        "description": "Assignment.",
        "codeSnippet": "let x: 'hello' = 'hello';\nx = 'world'; // Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Type '\"world\"' is not assignable to type '\"hello\"'. Code has error.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_10",
        "title": "Private member access",
        "description": "Find error.",
        "codeSnippet": "class A { private x = 10; }\nconst a = new A();\nconsole.log(a.x);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' is private and only accessible within class 'A'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_10",
        "title": "Protected member subclass",
        "description": "Access.",
        "codeSnippet": "class A { protected x = 10; }\nclass B extends A {\n  m() { console.log(this.x); }\n}\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Protected members are accessible within subclasses.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_11",
        "title": "Abstract class instantiation",
        "description": "Find error.",
        "codeSnippet": "abstract class A {}\nconst a = new A();",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Cannot create an instance of an abstract class.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_11",
        "title": "Static member access",
        "description": "Class static.",
        "codeSnippet": "class A { static x = 10; }\nconsole.log(A.x);",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Static members are accessed on the class constructor itself, not instances.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_12",
        "title": "Interface method implementation mismatch",
        "description": "Find error.",
        "codeSnippet": "interface I { m(a: string): void; }\nclass C implements I {\n  m(a: number) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'm' in type 'C' is not assignable to the same property in base type 'I'. Type '(a: number) => void' is not assignable to type '(a: string) => void'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_12",
        "title": "Never type escape",
        "description": "Unreachable.",
        "codeSnippet": "function error(msg: string): never {\n  throw new Error(msg);\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Functions that always throw or loop indefinitely return 'never'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_13",
        "title": "Tuple length mismatch",
        "description": "Find error.",
        "codeSnippet": "let x: [number, number] = [1, 2, 3];",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type '[number, number, number]' is not assignable to type '[number, number]'. Source has 3 element(s) but target allows only 2.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_13",
        "title": "Intersection type",
        "description": "Merging.",
        "codeSnippet": "interface A { x: number; }\ninterface B { y: number; }\ntype C = A & B;\nlet c: C = { x: 1, y: 2 };",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Intersection types combine members of all constituent types.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_14",
        "title": "Readonly array mutation",
        "description": "Find error.",
        "codeSnippet": "const a: readonly number[] = [1, 2];\na.push(3);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'push' does not exist on type 'readonly number[]'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_14",
        "title": "Type alias union",
        "description": "Declaration.",
        "codeSnippet": "type ID = number | string;\nlet x: ID = '100';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid type alias usage.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_15",
        "title": "Constructor implementation",
        "description": "Find error.",
        "codeSnippet": "class A {\n  constructor(x: number);\n  constructor(x: string);\n  constructor(x: any) {\n    console.log(x);\n  }\n}\nnew A(true);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 7,
        "explanation": "Overload resolution failed. 'true' matches none of the allowed signatures (number or string).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_15",
        "title": "Optional parameter",
        "description": "Function declaration.",
        "codeSnippet": "function f(x?: number) {}\nf();\nf(10);\n// Valid calls?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Optional parameter can be omitted.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_16",
        "title": "Required param after optional",
        "description": "Find error.",
        "codeSnippet": "function f(a?: number, b: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A required parameter cannot follow an optional parameter.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_16",
        "title": "Function overloading",
        "description": "Implementation signature.",
        "codeSnippet": "function makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  return new Date(); // impl\n}\n// The implementation signature is not visible directly.",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Correct structure for function overloading.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_17",
        "title": "Generic constraint mismatch",
        "description": "Find error.",
        "codeSnippet": "function f<T extends { length: number }>(arg: T) {}\nf(10);",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 1,
        "explanation": "Argument of type 'number' is not assignable to parameter of type '{ length: number; }'. Numbers don't have a .length property.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_17",
        "title": "Type assertion",
        "description": "Usage.",
        "codeSnippet": "let someValue: unknown = \"this is a string\";\nlet strLength: number = (someValue as string).length;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Type assertion 'as string' allows accessing string properties.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_18",
        "title": "Invalid type guard",
        "description": "Find error.",
        "codeSnippet": "function isString(x: any): x is string {\n    return typeof x === 'number';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "The implementation returns true for numbers, but the type predicate says 'x is string'. This is logic error in the guard, but valid Typescript compilation? Actually it compiles but is effectively a bug. Wait. Instructions say 'Find error'. If it compiles, is it an error? It's a logic error. TS doesn't validate the body matches the predicate. \nBetter error: `x is string` where return type is `boolean` inferred? No. \nError: `function f(x: any): x is string { return 1; }` - Return must be boolean.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_18_fixed",
        "title": "Type predicate return",
        "description": "Find error.",
        "codeSnippet": "function isString(x: any): x is string {\n    return 1;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "A type predicate function must return a boolean value.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_18",
        "title": "Non-null assertion",
        "description": "Operator.",
        "codeSnippet": "function f(x: number | null) {\n  const y: number = x!;\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Post-fix '!' asserts that the operand is non-null and non-undefined.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_19",
        "title": "This parameter position",
        "description": "Find error.",
        "codeSnippet": "function f(x: number, this: void) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'this' parameter must be the first parameter in the list.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_19",
        "title": "Index signature",
        "description": "Interface.",
        "codeSnippet": "interface StringArray {\n  [index: number]: string;\n}\nconst myArray: StringArray = ['Bob', 'Fred'];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Array literal matches the index signature [number]: string.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_20",
        "title": "String literal assignment",
        "description": "Find error.",
        "codeSnippet": "let x: 'a' | 'b';\nx = 'c';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type '\"c\"' is not assignable to type '\"a\" | \"b\"'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_20",
        "title": "Keyof operator",
        "description": "Keys.",
        "codeSnippet": "interface Person { name: string; age: number; }\ntype P = keyof Person; // 'name' | 'age'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'keyof Person' yields the union of known public property names.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_21",
        "title": "Accessing private static",
        "description": "Find error.",
        "codeSnippet": "class C {\n  private static x = 10;\n}\nconsole.log(C.x);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 3,
        "explanation": "Property 'x' is private and only accessible within class 'C'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_21",
        "title": "Abstract method impl",
        "description": "Extends.",
        "codeSnippet": "abstract class A { abstract m(): void; }\nclass B extends A { m() {} }\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Concrete subclass must implement all abstract methods.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_22",
        "title": "Generic default invalid",
        "description": "Find error.",
        "codeSnippet": "function f<T = number>(x: T) { return x.toFixed(); }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Property 'toFixed' does not exist on type 'T'. The default type 'number' does not constrain usage; 'f<string>(\"\")' would be valid call where toFixed fails. T is unconstrained.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_22",
        "title": "Readonly tuple",
        "description": "Immutability.",
        "codeSnippet": "let x: readonly [string, number] = ['a', 1];\nx[0] = 'b'; // Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Cannot assign to '0' because it is a read-only property. Code has error.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_23",
        "title": "Class implements primitive",
        "description": "Find error.",
        "codeSnippet": "class C implements number {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A class can only implement an object type or intersection of object types with statically known members. It cannot implement a primitive like 'number'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_23",
        "title": "Discriminated union",
        "description": "Access.",
        "codeSnippet": "interface A { kind: 'a'; x: number; }\ninterface B { kind: 'b'; y: number; }\ntype U = A | B;\nfunction f(u: U) {\n  if (u.kind === 'a') {\n    console.log(u.x);\n  }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Narrowing via 'kind' works correctly for discriminated unions.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_24",
        "title": "Const enum computed member",
        "description": "Find error.",
        "codeSnippet": "const enum E {\n  A = Math.random()\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "In 'const' enums, member initializers must be constant expressions.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_24",
        "title": "Module export assignment",
        "description": "Syntax.",
        "codeSnippet": "export = 5; // In classic TS modules",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'export =' is valid TypeScript syntax for modeling CommonJS exports.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_25",
        "title": "Namespace merge conflict",
        "description": "Find error.",
        "codeSnippet": "const x = 1;\nnamespace x { export const y = 2; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Cannot merge namespace 'x' with a constant/variable 'x'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_25",
        "title": "Module augmentation",
        "description": "Declaration.",
        "codeSnippet": "declare module 'foo' {\n  export function bar(): void;\n}\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid syntax for ambient module declaration.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_26",
        "title": "Global module exports",
        "description": "Find error.",
        "codeSnippet": "export const x = 1;\ndeclare global {\n  interface Window { x: number; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'declare global' is only valid in modules (files with imports/exports). This file IS a module because of 'export const x', so it IS valid syntax. Wait. I need an error.\nError: `declare global` in script (no imports/exports)? TS treats everything as module in many configs, but strictly speaking scopes differ. Let's try `interface extends primitive`.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_26_fixed",
        "title": "Interface extends primitive",
        "description": "Find error.",
        "codeSnippet": "interface I extends string {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "An interface can only extend other object types (classes or interfaces), not primitives like 'string'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_26",
        "title": "Constructor signature",
        "description": "Interface.",
        "codeSnippet": "interface Ctor {\n  new (x: number): any;\n}\nfunction create(c: Ctor) {\n  return new c(10);\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Interface can describe a constructor signature.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_27",
        "title": "Import outside module",
        "description": "Find error.",
        "codeSnippet": "function f() {\n  import { x } from './mod';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'import' declarations can only be used at the top level of a module.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_27",
        "title": "Type alias recursive",
        "description": "Recursive types.",
        "codeSnippet": "type Tree = { val: string; left?: Tree; right?: Tree; };\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Type aliases can support recursion.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_28",
        "title": "Duplicate identifier",
        "description": "Find error.",
        "codeSnippet": "interface A { x: number; }\nclass A {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Duplicate identifier 'A'. Classes and interfaces share the type declaration space (though they merge, class must come before interface or follow rules? No. Class declares both instance type and value. Interface declares type. Merging is allowed if consistent. BUT class A {} creates value A. Interface does not. Is this an error? If class properties clash? No. Actually `class A {} interface A {}` is VALID merging. `x` is added to class A's interface? No, that's declaration merging. Wait. If I want error, I need `const A = 1; class A {}`.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_28_fixed",
        "title": "Duplicate let class",
        "description": "Find error.",
        "codeSnippet": "let A = 1;\nclass A {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Duplicate identifier 'A'. Class declaration creates a value named 'A', which conflicts with 'let A'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_28",
        "title": "Namespace merging",
        "description": "Merging.",
        "codeSnippet": "namespace N { export const x = 1; }\nnamespace N { export const y = 2; }\nconsole.log(N.x + N.y); // 3",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Namespaces with the same name merge their exported members.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_29",
        "title": "Private constructor instantiation",
        "description": "Find error.",
        "codeSnippet": "class A { private constructor() {} }\nconst a = new A();",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Constructor of class 'A' is private and only accessible within the class declaration.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_29",
        "title": "Readonly interface property",
        "description": "Check.",
        "codeSnippet": "interface I { readonly x: number; }\nconst i: I = { x: 1 };\n// i.x = 2; // Error",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Readonly property cannot be reassigned.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_30",
        "title": "Call signature mismatch",
        "description": "Find error.",
        "codeSnippet": "interface Call { (x: string): void; }\nconst c: Call = (x: number) => {};",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type '(x: number) => void' is not assignable to type 'Call'. Parameter 'x' types are incompatible.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_30",
        "title": "Literal narrowing",
        "description": "Control flow.",
        "codeSnippet": "function f(x: 'a' | 'b') {\n  if (x === 'a') {\n    // x is 'a' here\n  }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Control flow analysis narrows 'x' to literal type '\"a\"'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_31",
        "title": "Enum member access",
        "description": "Find error.",
        "codeSnippet": "enum E { A, B }\nconst e = E.C;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'C' does not exist on type 'typeof E'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_31",
        "title": "This type return",
        "description": "Fluent API.",
        "codeSnippet": "class Builder {\n  step(): this { return this; }\n}\nnew Builder().step().step();",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'this' type represents the polymorphic 'this' of the class.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_32",
        "title": "Super call missing",
        "description": "Find error.",
        "codeSnippet": "class B extends A {\n  constructor() {\n    this.x = 1;\n  }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "'super' must be called before accessing 'this' in the constructor of a derived class.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_32",
        "title": "Definite assignment assertion",
        "description": "Bang.",
        "codeSnippet": "class C {\n  x!: number;\n  constructor() { this.init(); }\n  init() { this.x = 10; }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'x!' tells TS compiler that 'x' will be assigned definitively.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_33",
        "title": "Getter setter type mismatch",
        "description": "Find error.",
        "codeSnippet": "class C {\n  get x(): number { return 1; }\n  set x(v: string) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "'get' and 'set' accessor must have the same type. 'number' vs 'string'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_33",
        "title": "Import type",
        "description": "Syntax.",
        "codeSnippet": "import type { A } from './mod';\n// A is only available as type",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'import type' imports only type declarations, erased at runtime.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_34",
        "title": "Export type mismatch",
        "description": "Find error.",
        "codeSnippet": "const x = 1;\nexport type { x };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'x' refers to a value, but is being exported as a type. Wait, `export type { x }` is valid if `x` can be interpreted as type (e.g. class)? No, `const x` is a value. You can import it as a type (typeof x)? No. `export type { x }` expects x to be a type alias/interface. Error: 'x' cannot be used as a type because it was referenced but is value.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_34",
        "title": "Unique symbol",
        "description": "New type.",
        "codeSnippet": "const s: unique symbol = Symbol();\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'unique symbol' is a subset of symbol type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_35",
        "title": "Rest tuple mismatch",
        "description": "Find error.",
        "codeSnippet": "type T = [number, ...string[]];\nconst t: T = [1, 2];",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'number' (the value 2) is not assignable to type 'string'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_35",
        "title": "Abstract properties",
        "description": "Class members.",
        "codeSnippet": "abstract class A { abstract x: number; }\nclass B extends A { x = 10; }\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Abstract properties must be implemented in concrete subclasses.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_36",
        "title": "Parameter property outside ctor",
        "description": "Find error.",
        "codeSnippet": "class C {\n  m(public x: number) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "A parameter property is only allowed in a constructor implementation.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_36",
        "title": "Tuple optional element",
        "description": "Syntax.",
        "codeSnippet": "let t: [number, number?];\nt = [1];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Tuple elements can be optional.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_37",
        "title": "Implementation signature visibility",
        "description": "Find error.",
        "codeSnippet": "function f(x: boolean): void;\nfunction f(x: any) {}\nf('string');",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "The implementation signature 'f(x: any)' is not visible relative to the overload signatures. 'f' expects 'boolean'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_37",
        "title": "Template literal types",
        "description": "String types.",
        "codeSnippet": "type Greeting = `Hello, ${string}!`;\nlet s: Greeting = 'Hello, World!';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid template literal type match.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_38",
        "title": "Readonly default assignment",
        "description": "Find error.",
        "codeSnippet": "function f(readonly x: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'readonly' modifier can only appear on a property declaration or index signature, not on function parameters (unless TS 5.6+ with some flags? No, standard TS doesn't allow 'readonly param').",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_38",
        "title": "Interface merging",
        "description": "Behavior.",
        "codeSnippet": "interface Box { h: number; }\ninterface Box { w: number; }\nconst b: Box = { h: 10, w: 20 };",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Interfaces with the same name merge their members.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_39",
        "title": "Excess property check cast",
        "description": "Find error.",
        "codeSnippet": "interface P { x: number; }\nconst p: P = { x: 1, y: 2 } as P;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Wait, `as P` bypasses excess property checks usually. `{ x: 1, y: 2 } as P` IS valid, because `{x:1, y:2}` is assignable to `P` via overlap? No. But double assertion works. Single assertion: 'conversion of type ... to P may be a mistake'. TS sometimes errors on this if no overlap. But here x overlaps. So it might succeed. \nBetter error: direct assignment with excess property.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_39_fixed",
        "title": "Excess property check",
        "description": "Find error.",
        "codeSnippet": "interface P { x: number; }\nconst p: P = { x: 1, y: 2 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Object literal may only specify known properties. 'y' does not exist in type 'P'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_39",
        "title": "Number to String assignment",
        "description": "Primitive.",
        "codeSnippet": "let x: string = 123;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Type 'number' is not assignable to type 'string'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_40",
        "title": "Type alias implements",
        "description": "Find error.",
        "codeSnippet": "type T = { x: number };\nclass C implements T { x: string; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Class 'C' incorrectly implements interface 'T'. Property 'x' is 'string' vs 'number'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_40",
        "title": "Void vs undefined",
        "description": "Fn return.",
        "codeSnippet": "function f(): void { return undefined; }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Returning undefined is valid for 'void' return type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_41",
        "title": "Invalid decorator position",
        "description": "Find error.",
        "codeSnippet": "class C {\n  @dec\n  constructor() {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Decorators are not valid on constructors (in experimental decorators). Standard decorators (Stage 3) also restrict. Generally constructors can be decorated via class decorators, but not directly unless param? Parameter decorators yes. Method decorator on constructor? No.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_41",
        "title": "Any assignment",
        "description": "Unsafe.",
        "codeSnippet": "const x: any = 1;\nconst y: string = x;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'any' disables type checking, so it is assignable to anything (except never).",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_42",
        "title": "Symbol as index key",
        "description": "Find error.",
        "codeSnippet": "const s = Symbol();\nconst o = { [s]: 1 };\no[Symbol()] = 2;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Valid in JS. In TS? `o` inferred as `{ [s]: number }`. Indexing with new symbol fails if index signature missing. 'Element implicitly has an 'any' type because expression of type 'symbol' cannot be used to index type...'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_42",
        "title": "Unknown assignment",
        "description": "Restriction.",
        "codeSnippet": "const u: unknown = 1;\nconst n: number = u;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "unknown is not assignable to number.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_43",
        "title": "Export default type",
        "description": "Find error.",
        "codeSnippet": "export default type T = string;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'export default' cannot be combined with 'type' declaration (syntax limitation, use export type T = ...; export default T; needed? No, `export default` expects expression or class/func declaration. Type alias declaration not allowed directly as default export in older TS versions. Recent? Still syntax error).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_43",
        "title": "Never assignment",
        "description": "Assignable.",
        "codeSnippet": "let x: never;\nlet y: number = x;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'never' is a subtype of every type and is assignable to number.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_44",
        "title": "Super in unrelated class",
        "description": "Find error.",
        "codeSnippet": "class A {\n  m() { super.toString(); }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'super' can only be referenced in a derived class.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_44",
        "title": "Object type narrow",
        "description": "In operator.",
        "codeSnippet": "function f(x: { a: number } | { b: number }) {\n  if ('a' in x) {\n    console.log(x.a);\n  }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'in' operator narrows the union type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_45",
        "title": "Enum reverse mapping const",
        "description": "Find error.",
        "codeSnippet": "const enum E { A }\nlet s = E[0];",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Const enums do not generate reverse mappings (E[val]) at runtime, so TS forbids access unless preserveConstEnums is on. But generally it's an error in standard usage. 'A const enum member can only be accessed using a string literal'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_45",
        "title": "Type alias generic",
        "description": "Generics.",
        "codeSnippet": "type Box<T> = { value: T; };\nlet b: Box<number> = { value: 10 };",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Generic type aliases are valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_46",
        "title": "Type keyword variable",
        "description": "Find error.",
        "codeSnippet": "let type = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'type' is not a reserved word in variable declaration position. Wait. It is valid! `let type = 1`. I need an error.\nError: `let interface = 1`.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_46_fixed",
        "title": "Interface reserved",
        "description": "Find error.",
        "codeSnippet": "let interface = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'interface' is a strict mode reserved word.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_46",
        "title": "Readonly array assignment",
        "description": "Reference.",
        "codeSnippet": "const a: readonly number[] = [1];\nconst b: number[] = a;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Type 'readonly number[]' is not assignable to type 'number[]' (mutable array). 'readonly' is a supertype of mutable.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_47",
        "title": "Invalid module name",
        "description": "Find error.",
        "codeSnippet": "declare module 123 {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Module name must be a string literal.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_47",
        "title": "Asserts signature",
        "description": "Functions.",
        "codeSnippet": "function assert(xv: any): asserts xv {\n  if (!xv) throw new Error();\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "asserts predicate syntax is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_48",
        "title": "Yield in non-generator",
        "description": "Find error.",
        "codeSnippet": "function f() { yield 1; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'yield' expression is only allowed in a generator function (function*).",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_48",
        "title": "Recursive interface",
        "description": "Definition.",
        "codeSnippet": "interface Node {\n  children: Node[];\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Interfaces can reference themselves.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_49",
        "title": "Triple slash reference path",
        "description": "Find error.",
        "codeSnippet": "/// <reference path='args' />",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Syntax is valid... if file exists. But if used inside a function block? No, they define imports. \nError: `/// <reference path` syntax error? No.\nRevised: `implements` on function?",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_49_fixed",
        "title": "Implements on function",
        "description": "Find error.",
        "codeSnippet": "function f() implements I {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'implements' clause is only allowed on class declarations.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_49",
        "title": "Rest element destructuring",
        "description": "Tuple.",
        "codeSnippet": "const [h, ...t] = [1, 2, 3];\n// t is number[]",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Correct rest element usage.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_50",
        "title": "Invalid big int type",
        "description": "Find error.",
        "codeSnippet": "let x: bigint = 100;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type 'number' is not assignable to type 'bigint'. Target requires '100n'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_50",
        "title": "Global augment",
        "description": "Declaration.",
        "codeSnippet": "declare global { var x: number; }\n// Valid in module?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "declare global adds properties to the global scope.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_51",
        "title": "Conditional type constraint",
        "description": "Find error.",
        "codeSnippet": "type IsString<T> = T extends string ? true : false;\ntype A = IsString<number>; // false\ntype B = IsString<string>; // true\nlet x: IsString<number> = true;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 3,
        "explanation": "IsString<number> resolves to 'false'. Cannot assign 'true' to it.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_51",
        "title": "Mapped type modifier",
        "description": "Readonly.",
        "codeSnippet": "type Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n// Valid definition?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Correct definition of Readonly utility type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_52",
        "title": "Index signature key type",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  [key: boolean]: string;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_52",
        "title": "Infer keyword",
        "description": "Conditional.",
        "codeSnippet": "type Return<T> = T extends (...args: any[]) => infer R ? R : any;\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'infer' keyword declares a type variable within a conditional type.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_53",
        "title": "Partial type mismatch",
        "description": "Find error.",
        "codeSnippet": "interface User { id: number; name: string; }\nfunction update(u: Partial<User>) {\n  u.id = '123';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Type 'string' is not assignable to type 'number | undefined'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_53",
        "title": "Omit utility",
        "description": "Usage.",
        "codeSnippet": "interface Todo { title: string; desc: string; }\ntype MiniTodo = Omit<Todo, 'desc'>;\n// MiniTodo has only 'title'.",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Omit constructs a type by picking all properties from T and then removing Keys.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_54",
        "title": "Required utility missing prop",
        "description": "Find error.",
        "codeSnippet": "interface Props { a?: number; b?: string; }\nconst p: Required<Props> = { a: 1 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_54",
        "title": "Key remapping",
        "description": "As clause.",
        "codeSnippet": "type Mapped<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid key remapping syntax.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_55",
        "title": "Record key mismatch",
        "description": "Find error.",
        "codeSnippet": "type R = Record<'a' | 'b', number>;\nconst r: R = { a: 1 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'b' is missing in type '{ a: number; }' but required in type 'Record<\"a\" | \"b\", number>'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_55",
        "title": "Distributive conditional types",
        "description": "Union.",
        "codeSnippet": "type ToArray<T> = T extends any ? T[] : never;\ntype StrNumArr = ToArray<string | number>;\n// Result: string[] | number[]",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Conditional types distribute over unions.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_56",
        "title": "Abstract class new",
        "description": "Find error.",
        "codeSnippet": "abstract class Base {}\nclass Derived extends Base {}\nconst b: Base = new Base();",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Cannot create an instance of an abstract class.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_56",
        "title": "Recursive type alias",
        "description": "Json.",
        "codeSnippet": "type Json = string | number | boolean | null | { [key: string]: Json } | Json[];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Recursion is allowed in type aliases.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_57",
        "title": "Const assertion mutation",
        "description": "Find error.",
        "codeSnippet": "const curr = { x: 10 } as const;\ncurr.x = 20;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Cannot assign to 'x' because it is a read-only property.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_57",
        "title": "Exclude utility",
        "description": "Union.",
        "codeSnippet": "type T = Exclude<'a' | 'b' | 'c', 'a'>;\n// T is 'b' | 'c'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Exclude removes types from a union.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_58",
        "title": "NonNullable usage",
        "description": "Find error.",
        "codeSnippet": "type T = NonNullable<string | null | undefined>;\nlet x: T = null;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'null' is not assignable to type 'string'. NonNullable removed null.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_58",
        "title": "ReturnType utility",
        "description": "Infer.",
        "codeSnippet": "function f() { return { x: 10, y: 3 }; }\ntype P = ReturnType<typeof f>;\n// P is { x: number; y: number; }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "ReturnType gets the return type of a function type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_59",
        "title": "Parameters tuple access",
        "description": "Find error.",
        "codeSnippet": "function f(s: string, n: number) {}\ntype P = Parameters<typeof f>;\nlet x: P[0] = 10;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Type 'number' is not assignable to type 'string'. P[0] is the first parameter type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_59",
        "title": "InstanceType utility",
        "description": "Class.",
        "codeSnippet": "class C { x = 0; }\ntype T = InstanceType<typeof C>;\n// T is C",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "InstanceType obtains the instance type of a constructor function type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_60",
        "title": "ThisParameterType mismatch",
        "description": "Find error.",
        "codeSnippet": "function f(this: number) {}\ntype T = ThisParameterType<typeof f>;\nlet x: T = 'string';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Type 'string' is not assignable to type 'number'. T is 'number'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_60",
        "title": "OmitArguments",
        "description": "No such utility.",
        "codeSnippet": "type T = OmitArguments<() => void, 'x'>;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "There is no built-in 'OmitArguments' utility type in TypeScript.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_61",
        "title": "ConstructorParameters usage",
        "description": "Find error.",
        "codeSnippet": "class C { constructor(public x: number) {} }\ntype P = ConstructorParameters<C>;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'C' does not satisfy the constraint 'abstract new (...args: any) => any'. 'C' is the instance type, 'typeof C' is the constructor.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_61",
        "title": "Extract utility",
        "description": "Intersection.",
        "codeSnippet": "type T = Extract<'a' | 'b' | 'c', 'a' | 'f'>;\n// T is 'a'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Extract selects types assignment to the second type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_62",
        "title": "Promise return async",
        "description": "Find error.",
        "codeSnippet": "async function f(): string {\n  return 'hello';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "The return type of an async function or method must be the global Promise<T> type. 'string' is not a valid return type annotation for async function.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_62",
        "title": "Awaited utility",
        "description": "Unwrap.",
        "codeSnippet": "type A = Awaited<Promise<string>>;\n// A is string",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Awaited recursively unwraps Promise types.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_63",
        "title": "String literal inferred",
        "description": "Find error.",
        "codeSnippet": "function f(x: 'foo') {}\nlet a = 'foo';\nf(a);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Argument of type 'string' (inferred for 'a') is not assignable to parameter of type '\"foo\"'. 'a' needs 'const' assertion or type annotation.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_63",
        "title": "Uppercase utility",
        "description": "Intrinsic.",
        "codeSnippet": "type T = Uppercase<'hello'>;\n// T is 'HELLO'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Uppercase<T> transforms string literal to uppercase.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_64",
        "title": "Private field check",
        "description": "Find error.",
        "codeSnippet": "class C { #x = 1; }\nconst c = new C();\nconsole.log(c.#x);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property '#x' is not accessible outside class 'C' because it has a private identifier.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_64",
        "title": "Import generic type",
        "description": "Syntax.",
        "codeSnippet": "import { A } from './mod';\nlet x: A<number>;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Imported types can be generic.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_65",
        "title": "Abstract constructor type",
        "description": "Find error.",
        "codeSnippet": "abstract class A {}\nlet C: new () => A = A;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'typeof A' is not assignable to type 'new () => A'. Cannot assign an abstract constructor type to a non-abstract constructor type.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_65",
        "title": "Tuple label",
        "description": "Syntax.",
        "codeSnippet": "type Range = [start: number, end: number];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Labeled tuple elements are valid documentation.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_66",
        "title": "Spread tuple",
        "description": "Find error.",
        "codeSnippet": "function f(...args: [number, string]) {}\nf(1);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Expected 2 arguments, but got 1. The spread tuple defines required arguments.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_66",
        "title": "Variadic tuple types",
        "description": "Concatenation.",
        "codeSnippet": "type T<U extends any[]> = [string, ...U];\ntype R = T<[number, boolean]>;\n// R is [string, number, boolean]",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Variadic tuple types allow spreading generic tuples.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_67",
        "title": "Class expression implements",
        "description": "Find error.",
        "codeSnippet": "interface I { x: number; }\nconst C = class implements I { x = 's'; };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'string' is not assignable to type 'number'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_67",
        "title": "Default export class",
        "description": "Syntax.",
        "codeSnippet": "export default class { x = 1; }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Anonymous class as default export is valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_68",
        "title": "Type only import value usage",
        "description": "Find error.",
        "codeSnippet": "import type { A } from './mod';\nnew A();",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'A' cannot be used as a value because it was imported using 'import type'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_68",
        "title": "Namespace internal access",
        "description": "Scope.",
        "codeSnippet": "namespace N {\n  const x = 1;\n  export const y = x;\n}\n// x is hidden, y is visible",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Non-exported members of a namespace are private to it.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_69",
        "title": "Function declaration merge",
        "description": "Find error.",
        "codeSnippet": "function f() {}\nfunction f(x: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Duplicate function implementation. Overloads must precede the implementation.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_69",
        "title": "Const enum preserve",
        "description": "Config.",
        "codeSnippet": "// --preserveConstEnums\nconst enum E { A }\n// E exists at runtime in this mode.",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "preserveConstEnums emits the enum object.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_70",
        "title": "Switch exhaustive check",
        "description": "Find error.",
        "codeSnippet": "type T = 'a' | 'b';\nfunction f(x: T) {\n  switch (x) {\n    case 'a': return;\n  }\n  const check: never = x;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 5,
        "explanation": "Type '\"b\"' is not assignable to type 'never'. Switch case is not exhaustive, 'x' can be 'b'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_70",
        "title": "Satisfies operator",
        "description": "Validation.",
        "codeSnippet": "const p = { x: 1, y: 2 } satisfies { x: number; y: number; };\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'satisfies' checks that the expression matches the type but preserves the specific type of the expression.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_71",
        "title": "Satisfies mismatch",
        "description": "Find error.",
        "codeSnippet": "const p = { x: 's' } satisfies { x: number };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type 'string' is not assignable to type 'number'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_71",
        "title": "Override keyword",
        "description": "Class method.",
        "codeSnippet": "class B extends A {\n  override m() {}\n}\n// Valid if A has m().",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'override' ensures that the method overrides a base class method.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_72",
        "title": "Override missing base",
        "description": "Find error.",
        "codeSnippet": "class A {}\nclass B extends A {\n  override m() {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "This member cannot have an 'override' modifier because it is not declared in the base class 'A'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_72",
        "title": "Declaration merging interface",
        "description": "Extend.",
        "codeSnippet": "interface Document {\n  myProp: string;\n}\ndocument.myProp = 's';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Augmenting existing global interfaces is common pattern.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_73",
        "title": "Let reassignment type",
        "description": "Find error.",
        "codeSnippet": "let x = 10;\nx = 's';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'string' is not assignable to type 'number'. 'x' inferred as number.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_73",
        "title": "Unknown unassigned",
        "description": "Declaration.",
        "codeSnippet": "let x: unknown;\nx = 10;\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Unknown can hold any value.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_74",
        "title": "Const unassigned",
        "description": "Find error.",
        "codeSnippet": "const x;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'const' declarations must be initialized.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_74",
        "title": "Never return end",
        "description": "Flow.",
        "codeSnippet": "function fail(): never {\n  throw new Error();\n}\n// Reaching end of function block is impossible.",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Function definition is valid for never return.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_75",
        "title": "Nullish coalescing right operand",
        "description": "Find error.",
        "codeSnippet": "let x = undefined ?? 'default';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "This is valid. 'undefined' is nullish. I need an error.\nError: `expression || expression ?? expression` without parens.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_75_fixed",
        "title": "Nullish mixing ops",
        "description": "Find error.",
        "codeSnippet": "let x = 1 || 2 ?? 3;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Cannot mix '||' and '??' without parentheses.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_76",
        "title": "Rest parameter must be array",
        "description": "Find error.",
        "codeSnippet": "function f(...args: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A rest parameter must be of an array type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_76",
        "title": "Abstract class properties",
        "description": "Modifiers.",
        "codeSnippet": "abstract class A {\n  abstract x: number;\n}\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Abstract properties are allowed in abstract classes.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_77",
        "title": "Duplicate class constructor",
        "description": "Find error.",
        "codeSnippet": "class C {\n  constructor(x: number) {}\n  constructor(x: string) {}\n  constructor(x: any) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Multiple constructor implementations are not allowed. Only one implementation signature is allowed.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_77",
        "title": "Interface generic defaults",
        "description": "Generics.",
        "codeSnippet": "interface Box<T = string> {\n  value: T;\n}\nlet b: Box = { value: 's' };",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Interfaces can have default generic type parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_78",
        "title": "Accessing protected from instance",
        "description": "Find error.",
        "codeSnippet": "class C { protected x = 1; }\nconst c = new C();\nc.x = 2;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' is protected and only accessible within class 'C' and its subclasses.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_78",
        "title": "Type predicate else",
        "description": "Narrowing.",
        "codeSnippet": "function isString(x: any): x is string {\n  return typeof x === 'string';\n}\nfunction f(x: any) {\n  if (!isString(x)) {\n    // x is NOT string here?\n    console.log(x);\n  }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Type predicates narrow the false branch as well (negation).",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_79",
        "title": "Type alias duplicate",
        "description": "Find error.",
        "codeSnippet": "type T = string;\ntype T = number;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Duplicate identifier 'T'. Type aliases do not merge.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_79",
        "title": "Conditional type distribution",
        "description": "Never.",
        "codeSnippet": "type T<U> = U extends any ? U[] : never;\ntype R = T<never>;\n// R is never",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Conditional types distributed over 'never' return 'never'.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_80",
        "title": "Readonly tuple push",
        "description": "Find error.",
        "codeSnippet": "let x: readonly [number] = [1];\nx.push(2);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'push' does not exist on type 'readonly [number]'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_80",
        "title": "Symbol keyof",
        "description": "Keys.",
        "codeSnippet": "const s = Symbol();\ninterface I { [s]: number; a: string; }\ntype K = keyof I;\n// K includes typeof s",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "keyof includes symbol keys.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_81",
        "title": "Constructor return type annotation",
        "description": "Find error.",
        "codeSnippet": "class C {\n  constructor(): void {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type annotation cannot appear on a constructor declaration.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_81",
        "title": "Template literal inference",
        "description": "String types.",
        "codeSnippet": "type Color = 'red' | 'blue';\ntype Quantity = 'one' | 'two';\ntype Item = `${Color}-${Quantity}`;\n// Item has 4 combinations",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Template literal types generate cross-product of unions.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_82",
        "title": "Static method overload implementation",
        "description": "Find error.",
        "codeSnippet": "class C {\n  static fn(x: string): void;\n  fn(x: any) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Function implementation is missing or not immediately following the declaration. The implementation 'fn' lacks 'static' modifier, so it's an instance method, leaving static overload unimplemented.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_82",
        "title": "Getter only readonly",
        "description": "Properties.",
        "codeSnippet": "class C {\n  get x() { return 1; }\n}\nconst c = new C();\n// c.x = 2; // Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "A property with a get accessor but no set accessor is automatically readonly.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_83",
        "title": "In operator primitive",
        "description": "Find error.",
        "codeSnippet": "if ('a' in 'string') {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "The right-hand side of an 'in' expression must be of type 'any', 'unknown', or an object type.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_83",
        "title": "BigInt literal type",
        "description": "Types.",
        "codeSnippet": "let x: 100n = 100n;\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "BigInt literals can be used as types.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_84",
        "title": "Function default param mismatch",
        "description": "Find error.",
        "codeSnippet": "function f(x: number = 's') {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type 'string' is not assignable to type 'number'. Default value must match type annotation.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_84",
        "title": "Mapped type as clause",
        "description": "Filtering.",
        "codeSnippet": "type Getters<T> = {\n  [K in keyof T as K extends `x` ? K : never]: T[K]\n};\n// Filters keys starting with x?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Using 'as ... never' filters the key out.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_85",
        "title": "Type guard mismatch",
        "description": "Find error.",
        "codeSnippet": "function isString(x: any): x is number {\n  return typeof x === 'string';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "The implementation returns true for strings, but the type predicate says 'x is number'. Logic error but technically valid TS? No, TS doesn't check body validity against predicate strictly in all versions but it IS an error in concept. \nWait. I used this before but changed it to 'return 1'. TS compiler typically allows `return typeof x === 'string'` even if predicate is `number`? No, usually not checked, you assert. But it IS a bug.\nLet's use a syntax error. `function f(x: any): asserts x is string { return 1; }` return type void.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_85_fixed",
        "title": "Asserts return value",
        "description": "Find error.",
        "codeSnippet": "function assert(x: any): asserts x {\n  return true;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "A function with an 'asserts' return type must not return a value (must be void).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_85",
        "title": "Decorator class",
        "description": "Experimental.",
        "codeSnippet": "@sealed\nclass C {}\nfunction sealed(ctor: Function) {}\n// Valid usage?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid class decorator usage.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_86",
        "title": "Optional method implementation",
        "description": "Find error.",
        "codeSnippet": "interface I { m?(): void; }\nclass C implements I {\n  m?() {} \n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "A class cannot implement an optional method with '?' in the class body. It must simply likely not implement it or implement it normally. '?' is not allowed in class method declaration.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_86",
        "title": "Tuple abstract assignment",
        "description": "Variadic.",
        "codeSnippet": "function f(...args: [n: number, s: string]) {}\nf(1, 's');",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Spreading a labeled tuple into rest args is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_87",
        "title": "Declare const init",
        "description": "Find error.",
        "codeSnippet": "declare const x = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Ambient constants cannot have an initializer.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_87",
        "title": "Const enum value",
        "description": "Inlining.",
        "codeSnippet": "const enum Direction { Up = 1 }\nconst d = Direction.Up;\n// Emits 'const d = 1;'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Const enum values are inlined.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_88",
        "title": "Interface extends void",
        "description": "Find error.",
        "codeSnippet": "interface I extends void {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "An interface can only extend other object types.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_88",
        "title": "Void expression",
        "description": "Arg.",
        "codeSnippet": "function f(v: void) {}\nf(undefined);",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'undefined' is assignable to 'void'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_89",
        "title": "Generic constraint mismatch 2",
        "description": "Find error.",
        "codeSnippet": "interface Box<T extends string> { x: T; }\nlet b: Box<number> = { x: 1 };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'number' does not satisfy the constraint 'string'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_89",
        "title": "Import all",
        "description": "Syntax.",
        "codeSnippet": "import * as ns from './mod';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Namespace import syntax is correct.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_90",
        "title": "Getter parameter",
        "description": "Find error.",
        "codeSnippet": "class C {\n  get x(v: number) { return v; }\n}",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 1,
        "explanation": "A 'get' accessor cannot have parameters.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_90",
        "title": "Setter return type",
        "description": "Void.",
        "codeSnippet": "class C {\n  set x(v: number): void { }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Setters cannot have a return type annotation.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_91",
        "title": "Generic default forward ref",
        "description": "Find error.",
        "codeSnippet": "type T<A = B, B = string> = { a: A, b: B };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type parameter 'B' has a circular constraint or is used before its declaration? 'A = B' uses B. Defaults are evaluated left to right? No, defaults can refer to previous params, not subsequent ones. 'B' is declared after 'A'.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_91",
        "title": "Triple slash amd-dependency",
        "description": "Directives.",
        "codeSnippet": "/// <amd-dependency path=\"x\" />",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid triple-slash directive (though deprecated/legacy).",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_92",
        "title": "Private static vs instance",
        "description": "Find error.",
        "codeSnippet": "class C {\n  private static x = 1;\n  m() { console.log(this.x); }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' is a static member of type 'C', and cannot be accessed via instance 'this'. Use 'C.x'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_92",
        "title": "Export assign",
        "description": "Legacy.",
        "codeSnippet": "export = class C {};",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "export = syntax for CJS interop.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_93",
        "title": "Readonly parameter reassignment",
        "description": "Find error.",
        "codeSnippet": "function f(a: ReadonlyArray<string>) {\n  a[0] = 's';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Index signature in type 'ReadonlyArray<string>' only permits reading.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_93",
        "title": "Type alias export",
        "description": "Syntax.",
        "codeSnippet": "type T = number;\nexport { T };",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Exporting a type alias via named export is valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_94",
        "title": "Delete operand",
        "description": "Find error.",
        "codeSnippet": "const x = { a: 1 };\ndelete x;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "The operand of a 'delete' operator must be a property access.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_94",
        "title": "Import equals",
        "description": "Syntax.",
        "codeSnippet": "import A = require('./mod');",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "import = require() syntax is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_95",
        "title": "Enum value expression",
        "description": "Find error.",
        "codeSnippet": "function f() { return 1; }\nenum E {\n  A = f()\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Enum member initializer must be constant? No, computed members are allowed in regular enums. BUT if it's computed, it must be last or all following must be initialized. Wait. Is f() allowed? Yes. \nError: `enum E { A = f(), B }`. 'B' needs init.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_95_fixed",
        "title": "Enum computed missing init",
        "description": "Find error.",
        "codeSnippet": "function f() { return 1; }\nenum E {\n  A = f(),\n  B\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 3,
        "explanation": "Enum member must have initializer if it follows a member with a computed value.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_95",
        "title": "Const enum string",
        "description": "Values.",
        "codeSnippet": "const enum E { A = 'A' }\nlet s = E.A;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "String const enums are valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_96",
        "title": "Yield star type",
        "description": "Find error.",
        "codeSnippet": "function* g(): Generator<string, void, unknown> {\n  yield* [1, 2];\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'number' is not assignable to type 'string'. 'yield*' delegates literal array of numbers, but generator expects strings.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_96",
        "title": "Ambient enum",
        "description": "Declaration.",
        "codeSnippet": "declare enum E { A = 1 }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Ambient enum declaration is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_97",
        "title": "Export default interface",
        "description": "Find error.",
        "codeSnippet": "export default interface I { method(): void; }",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 0,
        "explanation": "Actually this IS valid in TS. \nError: `export default interface I {}` is valid. \nLet's try `export default var x = 1`.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_97_fixed",
        "title": "Export default var",
        "description": "Find error.",
        "codeSnippet": "export default var x = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'export default' cannot be used with 'var' declaration. Use 'export default x' or 'export var x'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_97",
        "title": "CheckJs",
        "description": "Directive.",
        "codeSnippet": "// @ts-check\nlet x = 10;\nx = 's';",
        "type": "trueOrFalse",
        "language": "javascript",
        "isCodeCorrect": false,
        "explanation": "@ts-check enables checking in JS files. 10 is incompatible with 's'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_98",
        "title": "Super property access",
        "description": "Find error.",
        "codeSnippet": "class A { x = 1; }\nclass B extends A {\n  m() { return super.x; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Only public and protected methods of the base class are accessible via the 'super' keyword. Properties are accessed via 'this'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_98",
        "title": "Global this",
        "description": "Var.",
        "codeSnippet": "globalThis.console.log('hi');",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "globalThis is standard global scope accessor.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_99",
        "title": "Decorators on function",
        "description": "Find error.",
        "codeSnippet": "@dec\nfunction f() {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Decorators are not valid here. Only classes, methods, accessors, properties, and parameters.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_99",
        "title": "Optional catch binding",
        "description": "Syntax.",
        "codeSnippet": "try {} catch {\n  // no err variable\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Optional catch binding is valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_100",
        "title": "Invalid hexadecimal",
        "description": "Find error.",
        "codeSnippet": "let x = 0xG;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Invalid hexadecimal literal.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_100",
        "title": "Numeric separator",
        "description": "Syntax.",
        "codeSnippet": "let x = 1_000_000;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Numeric separators allowed.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_101",
        "title": "Exact optional property types",
        "description": "Find error.",
        "codeSnippet": "// exactOptionalPropertyTypes: true\ninterface I { x?: number; }\nconst i: I = { x: undefined };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "With 'exactOptionalPropertyTypes' enabled, 'undefined' is not assignable to optional property 'x' unless explicitly included in the union.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_101",
        "title": "Unchecked indexed access",
        "description": "Config.",
        "codeSnippet": "// noUncheckedIndexedAccess: true\nconst a: number[] = [1];\nconst x = a[0];\n// x is number | undefined",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Flag adds 'undefined' to indexed access results.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_102",
        "title": "Contravariance in function params",
        "description": "Find error.",
        "codeSnippet": "type F<T> = (x: T) => void;\nlet f1: F<string> = (x: string) => {};\nlet f2: F<number | string> = f1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Type 'F<string>' is not assignable to type 'F<string | number>'. Function parameters are contravariant. A function taking 'string' cannot handle 'number'.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_102",
        "title": "Covariance in return types",
        "description": "Variance.",
        "codeSnippet": "type F<T> = () => T;\nlet f1: F<string> = () => 's';\nlet f2: F<string | number> = f1;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Function return types are covariant.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_103",
        "title": "Class static side implements",
        "description": "Find error.",
        "codeSnippet": "interface I { new (): void; }\nclass C implements I {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Class 'C' incorrectly implements interface 'I'. 'I' describes the constructor signature (static side), but 'implements' checks the instance side.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_103",
        "title": "Class expression references self",
        "description": "Scope.",
        "codeSnippet": "const C = class Me {\n  m() { return new Me(); }\n};",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Class expressions can have a name visible inside the class body.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_104",
        "title": "Rest after optional",
        "description": "Find error.",
        "codeSnippet": "function f(a?: number, ...r: number[]) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A rest parameter cannot follow an optional parameter? Wait. This IS valid. \nError: `function f(...args: number[], x: number) {}` Rest must be last.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_104_fixed",
        "title": "Rest parameter position",
        "description": "Find error.",
        "codeSnippet": "function f(...args: number[], x: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A rest parameter must be last in a parameter list.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_104",
        "title": "Template literal split",
        "description": "Types.",
        "codeSnippet": "type S = Split<'a.b.c', '.'>;\n// S is ['a', 'b', 'c'] (if defined recursively)",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Recursive template literal types can parse strings.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_105",
        "title": "Importing implicit type",
        "description": "Find error.",
        "codeSnippet": "import { String } from 'global';",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Cannot import global types like 'String' from a module unless exported.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_105",
        "title": "Const enum computed property reference",
        "description": "Values.",
        "codeSnippet": "const enum E { A = 1, B = A * 2 }\n// B is 2",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Const enums can refer to other members.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_106",
        "title": "Weak type compatibility",
        "description": "Find error.",
        "codeSnippet": "interface Weak { a?: number; b?: string; }\nconst x = { c: 1 };\nconst w: Weak = x;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Type '{ c: number; }' has no properties in common with type 'Weak'.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_106",
        "title": "Intrinsic string manipulation",
        "description": "Types.",
        "codeSnippet": "type T = Capitalize<'hello'>;\n// T is 'Hello'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Capitalize is an intrinsic type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_107",
        "title": "Private method overwrite",
        "description": "Find error.",
        "codeSnippet": "class A { private m() {} }\nclass B extends A { m() {} }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Class 'B' defines 'm' which is private in base 'A'. Wait. If 'm' is private in A, it's not visible in B, so B can define its own 'm' without overriding. This IS valid.\nError: `class A { private x = 1; } class B extends A { x = 2; }`.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_107_fixed",
        "title": "Private prop collision",
        "description": "Find error.",
        "codeSnippet": "class A { private x = 1; }\nclass B extends A { x = 2; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'x' is private in type 'A' but not in type 'B'. Wait. They match? No, private names are scoped. But TS forbids declaring same name if it conflicts with private? 'Property x is private in type A but not in type B'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_107",
        "title": "Mapped type intersection",
        "description": "Resolution.",
        "codeSnippet": "type T = { a: number } & { b: string };\ntype K = keyof T;\n// K is 'a' | 'b'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Keys of intersection are union of keys.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_108",
        "title": "Readonly via alias",
        "description": "Find error.",
        "codeSnippet": "type ReadonlyPoint = { readonly x: number; };\nconst p: ReadonlyPoint = { x: 1 };\nconst q: { x: number } = p;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Wait. Readonly is assignable to mutable? Yes. It's safe to read. \nError: `const mutable: { x: number } = { x: 1 }; const readonly: { readonly x: number } = mutable; readonly.x = 2;` No. \nError: Assigning mutable to readonly is fine. Assigning readonly to mutable IS allowed in TS (unsafe). \nLet's try: `interface I { readonly x: number } class C implements I { x: number = 1; }` Valid? Yes. \nLet's try: `enum E { A }` `E.A = 2;`",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_108_fixed",
        "title": "Enum property assignment",
        "description": "Find error.",
        "codeSnippet": "enum E { A }\nE.A = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Cannot assign to 'A' because it is a read-only property.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_108",
        "title": "Import renamed",
        "description": "Syntax.",
        "codeSnippet": "import { A as B } from './mod';\n// B refers to A",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Renaming imports is valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_109",
        "title": "Export interface value usage",
        "description": "Find error.",
        "codeSnippet": "export interface I {}\nconsole.log(I);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'I' only refers to a type, but is being used as a value here.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_109",
        "title": "Tuple spread last",
        "description": "Generics.",
        "codeSnippet": "type T<U extends any[]> = [...U, string];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Rest elements can occur at start of tuple.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_110",
        "title": "Invalid numeric separator",
        "description": "Find error.",
        "codeSnippet": "let x = 100_;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Numeric separators are not allowed at the end of numeric literals.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_110",
        "title": "Null check assertion",
        "description": "Flow.",
        "codeSnippet": "function f(x: number | null) {\n  if (x == null) throw 1;\n  const y: number = x;\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Control flow analysis narrows type after throw.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_111",
        "title": "Class implements class private",
        "description": "Find error.",
        "codeSnippet": "class A { private x = 1; }\nclass B implements A {\n  private x = 1;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Class 'B' incorrectly implements class 'A'. Private properties originate from the same declaration. 'x' in 'B' is distinct from 'A'.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_111",
        "title": "Export enum merge",
        "description": "Declaration.",
        "codeSnippet": "export enum E { A }\nexport namespace E { export const B = 1; }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Enum and namespace merging is a valid pattern.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_112",
        "title": "Rest parameter optional",
        "description": "Find error.",
        "codeSnippet": "function f(...args?: number[]) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "A rest parameter cannot be optional.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_112",
        "title": "Empty interface",
        "description": "Type.",
        "codeSnippet": "interface Empty {}\nconst x: Empty = {};\nconst y: Empty = 's';\n// y is valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "An empty interface is compatible with anything except null/undefined (mostly). Primitives like string have Object properties, so often valid.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_113",
        "title": "Constructor type literal",
        "description": "Find error.",
        "codeSnippet": "let c: { new (x: string): void };\nc = class { constructor(x: number) {} };",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 1,
        "explanation": "Types of parameters 'x' and 'x' are incompatible. Type 'string' is not assignable to type 'number'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_113",
        "title": "Export * as",
        "description": "Syntax.",
        "codeSnippet": "export * as ns from './mod';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Export namespace syntax.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_114",
        "title": "Readonly property delete",
        "description": "Find error.",
        "codeSnippet": "interface I { readonly x?: number; }\nconst i: I = { x: 1 };\ndelete i.x;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "The operand of a 'delete' operator cannot be a read-only property.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_114",
        "title": "Module no exports",
        "description": "Script.",
        "codeSnippet": "const x = 1;\n// Is this a module or script?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Without imports or exports, it is treated as a script (global scope).",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_115",
        "title": "Type alias recursive circular",
        "description": "Find error.",
        "codeSnippet": "type T = T;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type alias 'T' circularly references itself.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_115",
        "title": "Unknown is not any",
        "description": "Usage.",
        "codeSnippet": "let u: unknown;\nu.foo; // Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Cannot access properties on 'unknown'. Code has error.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_116",
        "title": "Abstract method implementation vis",
        "description": "Find error.",
        "codeSnippet": "abstract class A { abstract m(): void; }\nclass B extends A { private m() {} }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Property 'm' in type 'B' is not assignable to the same property in base type 'A'. Visibility must be compatible (public vs private).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_116",
        "title": "Interface extend class",
        "description": "Inheritance.",
        "codeSnippet": "class C { x: number; }\ninterface I extends C {}\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Interfaces can extend classes (inherits members).",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_117",
        "title": "This type in static",
        "description": "Find error.",
        "codeSnippet": "class C {\n  static m() { let x: this; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "The 'this' type is not available in a static member.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_117",
        "title": "Keyof any",
        "description": "Type.",
        "codeSnippet": "type K = keyof any;\n// K is string | number | symbol",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "keyof any returns the union of valid key types.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_118",
        "title": "Generic default parameters order",
        "description": "Find error.",
        "codeSnippet": "type T<A = string, B> = { a: A, b: B };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Required type parameters may not follow optional type parameters.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_118",
        "title": "Branded types",
        "description": "Pattern.",
        "codeSnippet": "type USD = number & { _brand: 'USD' };\nlet money = 10 as USD;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Branded types simulate nominal typing.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_119",
        "title": "Optional property getter",
        "description": "Find error.",
        "codeSnippet": "class C {\n  get x?() { return 1; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "An accessor cannot be optional.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_119",
        "title": "Private constructor final",
        "description": "Pattern.",
        "codeSnippet": "class C {\n  private constructor() {}\n}\nclass D extends C {}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Cannot extend a class with a private constructor.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_120",
        "title": "Abstract static method",
        "description": "Find error.",
        "codeSnippet": "abstract class A {\n  abstract static m(): void;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'static' modifier cannot be used with 'abstract' modifier.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_120",
        "title": "Template literal keyof",
        "description": "Keys.",
        "codeSnippet": "interface I { a: number; b: string; }\ntype T = `get${Capitalize<keyof I>}`;\n// 'getA' | 'getB'",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Template literals distribute over unions.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_121",
        "title": "Const enum external module",
        "description": "Find error.",
        "codeSnippet": "// ambient declaration\ndeclare const enum E { A = 1 }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Wait. This is valid in .d.ts. In .ts file? declare allowed. \nError: `declare const enum E { A = Math.random() }` - init must be constant.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_121_fixed",
        "title": "Ambient const enum computed",
        "description": "Find error.",
        "codeSnippet": "declare const enum E { A = Math.random() }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Ambient const enum member initializers must be constant expressions.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_121",
        "title": "Type import from js",
        "description": "JSDoc.",
        "codeSnippet": "import { Type } from './file.js';\n// Valid if allowJs and checkJs?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Types can be imported from JS files if they have JSDoc type definitions.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_122",
        "title": "Duplicate signature",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  (a: number): void;\n  (a: number): void;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Duplicate signature (redundant but usually valid in interfaces? Actually TS allows duplicates in interfaces, they merge/shadow. Is it an error? No. \nError: `class C { m(x: any) {} m(y: any) {} }`.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_122_fixed",
        "title": "Duplicate method implementation",
        "description": "Find error.",
        "codeSnippet": "class C {\n  m() {}\n  m() {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Duplicate identifier 'm'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_122",
        "title": "Readonly property vs signature",
        "description": "Mismatch.",
        "codeSnippet": "interface A { readonly x: number; }\ninterface B { x: number; }\nconst b: B = { x: 1 };\nconst a: A = b;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Mutable is assignable to readonly.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_123",
        "title": "Invalid type assertion",
        "description": "Find error.",
        "codeSnippet": "let x = 's' as number;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. Use 'unknown' as intermediate.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_123",
        "title": "Unknown in arithmetic",
        "description": "Op.",
        "codeSnippet": "let u: unknown = 1;\nlet n = u + 1;",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Object is of type 'unknown'. Arithmetic ops forbid it.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_124",
        "title": "Non-existent generic type param",
        "description": "Find error.",
        "codeSnippet": "function f<T>() { let x: U; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Cannot find name 'U'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_124",
        "title": "No implicit any",
        "description": "Config.",
        "codeSnippet": "function f(x) { return x; }\n// Error with noImplicitAny",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Parameter 'x' implicitly has an 'any' type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_125",
        "title": "Invalid enum name",
        "description": "Find error.",
        "codeSnippet": "enum 123 {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Enum name must be an identifier.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_125",
        "title": "Object prototype property",
        "description": "Access.",
        "codeSnippet": "let o = {};\no.toString();",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Object prototype methods are available on empty object literals.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_126",
        "title": "Abstract constructor new",
        "description": "Find error.",
        "codeSnippet": "abstract class A {}\nfunction f(ctor: new () => A) {\n  return new ctor();\n}\nf(A);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 4,
        "explanation": "Argument of type 'typeof A' is not assignable to parameter of type 'new () => A'. Cannot assign an abstract constructor type to a non-abstract constructor type.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_126",
        "title": "Const type parameter",
        "description": "TS 5.0.",
        "codeSnippet": "function f<const T>(x: T) { return x; }\nconst x = f(['a']);\n// x is readonly ['a']",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'const' type parameter infers literals as const.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_127",
        "title": "Enum reverse map string",
        "description": "Find error.",
        "codeSnippet": "enum E { A = 'A' }\nlet x = E['A'];",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "String enums do not generate reverse mappings. 'E.A' works, but indexing with value isn't relevant here. 'E['A']' accesses property 'A', which is valid? Yes. But wait. \nError: `enum E { A = 'A' } let a = E.A; let b = E['A'];` is valid access by name. Reverse map: `let r = E['A']`? No, reverse map checks value. `let r = E['Value']`? No. `let r = E[E.A]` fails for string enums.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_127_fixed",
        "title": "String enum reverse mapping",
        "description": "Find error.",
        "codeSnippet": "enum E { A = 'A' }\nlet r = E['A' as any];",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "This compiles with any cast. \nError: `enum E { A = 'A' } let r = E['A']` is valid (access by name). \nError: `enum E { A = 'A' }; if (E.A === 0) {}`.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_127",
        "title": "Module augment global",
        "description": "Scope.",
        "codeSnippet": "export {};\ndeclare global {\n  interface Window { myProp: string; }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Correctly augments global scope from a module.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_128",
        "title": "Readonly vs setter",
        "description": "Find error.",
        "codeSnippet": "class C {\n  readonly x: number = 1;\n  set x(v: number) {}\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' cannot have both a 'readonly' modifier and an accessor.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_128",
        "title": "Optional tuple vs undefined",
        "description": "Assignment.",
        "codeSnippet": "let t: [number?] = [];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Optional tuple elements allow omitting them.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_129",
        "title": "Async generator return type",
        "description": "Find error.",
        "codeSnippet": "async function* g(): Generator<string> {\n  yield 's';\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Async generators must return 'AsyncGenerator', not 'Generator'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_129",
        "title": "Import type only default",
        "description": "Syntax.",
        "codeSnippet": "import type D from './mod';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Valid syntax for importing default export as type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_130",
        "title": "Duplicated parameter name",
        "description": "Find error.",
        "codeSnippet": "function f(x: number, x: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Duplicate identifier 'x'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_130",
        "title": "Object freeze inference",
        "description": "Readonly.",
        "codeSnippet": "const o = Object.freeze({ x: 1 });\n// o.x is readonly number",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "TypeScript infers readonly properties for Object.freeze().",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_131",
        "title": "New target outside constructor",
        "description": "Find error.",
        "codeSnippet": "function f() {\n  console.log(new.target);\n}",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 1,
        "explanation": "Wait. `new.target` IS allowed in functions (to detect if called with new). \nError: `const x = new.target;` at top level.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_131_fixed",
        "title": "New target top level",
        "description": "Find error.",
        "codeSnippet": "const t = new.target;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'new.target' is only allowed in the body of a function, method, or constructor.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_131",
        "title": "Decorator composition",
        "description": "Order.",
        "codeSnippet": "@f @g x\n// Applies g then f?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Decorators are evaluated top-to-bottom but applied bottom-up (g then f).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_132",
        "title": "Private identifier delete",
        "description": "Find error.",
        "codeSnippet": "class C { #x = 1; m() { delete this.#x; } }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "The operand of a 'delete' operator cannot be a private identifier.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_132",
        "title": "Infer conditional var",
        "description": "Scope.",
        "codeSnippet": "type T<U> = U extends (infer A)[] ? A : U;\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Infer introduces a type variable in the conditional extension.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_133",
        "title": "Yield star expression",
        "description": "Find error.",
        "codeSnippet": "function* f() { yield* 1; }",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "The expression of a 'yield*' must be an iterable/generator.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_133",
        "title": "Symbol as computed property",
        "description": "Syntax.",
        "codeSnippet": "const s = Symbol();\nclass C {\n  [s]() {}\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Symbols are valid computed property keys.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_134",
        "title": "Export default scalar",
        "description": "Find error.",
        "codeSnippet": "export default 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "This is valid. \nError: `export default const x = 1;`.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_134_fixed",
        "title": "Export default const declaration",
        "description": "Find error.",
        "codeSnippet": "export default const x = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "'export default' cannot be used with 'const' declaration. Use 'export default 1' or 'export const x = 1'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_134",
        "title": "Type alias intersection class",
        "description": "Hybrid.",
        "codeSnippet": "class C { x: number; }\ntype T = C & { y: string };\n// T is valid object type",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Intersection of class instance type and object literal type is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_135",
        "title": "Declare var init",
        "description": "Find error.",
        "codeSnippet": "declare var x = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Initializers are not allowed in ambient contexts.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_135",
        "title": "Recursive type alias implicit",
        "description": "Limit.",
        "codeSnippet": "type A = B;\ntype B = A;\n// Error?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Type alias circularly references itself.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_136",
        "title": "Invalid super call",
        "description": "Find error.",
        "codeSnippet": "class A {}\nclass B extends A {\n  m() { super(); }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Super calls are not permitted outside constructors or in nested functions inside constructors.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_136",
        "title": "Tuple variadic middle",
        "description": "Syntax.",
        "codeSnippet": "type T = [number, ...string[], boolean];\n// Valid in TS 4.0+?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Variadic tuple types can be in the middle.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_137",
        "title": "Generic constraint mismatch 3",
        "description": "Find error.",
        "codeSnippet": "function f<T extends { x: number }>(arg: T) {}\nf({ x: 's' });",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'string' is not assignable to type 'number'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_137",
        "title": "Optional property in class",
        "description": "Init.",
        "codeSnippet": "class C {\n  x?: number;\n  // No init needed\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Optional properties do not require initialization in constructor.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_138",
        "title": "Async method error",
        "description": "Find error.",
        "codeSnippet": "class C {\n  async m() { return 1; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "This works, infers Promise<number>. I need error.\nError: `abstract async m();` in abstract class.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_138_fixed",
        "title": "Abstract async method",
        "description": "Find error.",
        "codeSnippet": "abstract class C {\n  abstract async m(): Promise<void>;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "'async' modifier cannot be used with 'abstract' modifier.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_138",
        "title": "Unknown intersection",
        "description": "Type.",
        "codeSnippet": "type T = unknown & string;\n// T is string",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Intersection with 'unknown' absorbs it (identity element of intersection basically? No, 'any & unknown' => any. 'string & unknown' => string).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_139",
        "title": "Index signature prop conflict",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  [index: string]: number;\n  x: string;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' of type 'string' is not assignable to 'string' index type 'number'. All props must match index signature.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_139",
        "title": "Void param type",
        "description": "Check.",
        "codeSnippet": "function f(x: void) {}\nf();",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": false,
        "explanation": "Expected 1 argument, but got 0. 'void' parameter still requires an argument (undefined) unless optional.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_140",
        "title": "Super in static",
        "description": "Find error.",
        "codeSnippet": "class A {}\nclass B extends A {\n  static m() { super.x; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Property 'x' does not exist on type 'typeof A' (static side) unless defined there. 'super' in static context refers to constructor object of parent. If x is instance member, not found.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_140",
        "title": "Unused label",
        "description": "Clean.",
        "codeSnippet": "label: while(true) { break label; }",
        "type": "trueOrFalse",
        "language": "javascript",
        "isCodeCorrect": true,
        "explanation": "Labeled statements are valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_141",
        "title": "Type alias circular not function",
        "description": "Find error.",
        "codeSnippet": "type T = { x: T };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "This IS valid (recursive object type). \nError: `type T = Array<T>;` Valid. \nError: `type T = T[];` Valid. \nError: `type T = number | T;` Valid. \nError: `type T = keyof T;` Circular constraint?",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_141_fixed",
        "title": "Circular constraint",
        "description": "Find error.",
        "codeSnippet": "type T = keyof T;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type alias 'T' circularly references itself.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_141",
        "title": "Asserts in arrows",
        "description": "Syntax.",
        "codeSnippet": "const assert: (x: any) => asserts x = x => {};",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Arrow functions can have assertion signatures.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_142",
        "title": "Function impl in interface",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  m() { return 1; }\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Interfaces cannot contain option implementations. Only signatures.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_142",
        "title": "Readonly array destructure",
        "description": "Tuple.",
        "codeSnippet": "const a: readonly number[] = [1, 2];\nconst [x, y] = a;\n// x, y inferred as number",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Destructuring readonly arrays is valid.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_143",
        "title": "Null check strict",
        "description": "Find error.",
        "codeSnippet": "// strict: true\nfunction f(x: number) {}\nf(undefined);",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "Argument of type 'undefined' is not assignable to parameter of type 'number'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_143",
        "title": "Type import default",
        "description": "Import.",
        "codeSnippet": "import type { default as D } from './mod';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Type-only import of default export is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_144",
        "title": "Literal numeric separator",
        "description": "Find error.",
        "codeSnippet": "let x: 1_000 = 1000;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Numeric separators allowed in values but not in literal types (pre-TS 4.x)? No, allowed in types? Actually `type T = 1_000;` is valid in modern TS. \nError: `type T = 1.2.3;`.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_144_fixed",
        "title": "Private field in interface",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  #x: number;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Private identifiers are not allowed in interface declarations.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_144",
        "title": "In operator private",
        "description": "Narrow.",
        "codeSnippet": "class C { #x = 1; static check(o: any) { return #x in o; } }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'in' operator works with private identifiers.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_145",
        "title": "Object literal shorthand mismatch",
        "description": "Find error.",
        "codeSnippet": "let x: string = 's';\nlet o: { x: number } = { x };",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Type 'string' is not assignable to type 'number'. Sourced from variable 'x'.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_145",
        "title": "This type guard",
        "description": "Class.",
        "codeSnippet": "class FileSystem {\n  isFile(): this is FileRep { return this instanceof FileRep; }\n}\nclass FileRep extends FileSystem {}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'this is Type' valid type predicate for methods.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_146",
        "title": "Generic parameter used as constraint",
        "description": "Find error.",
        "codeSnippet": "function f<T, U extends T>() {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "This IS valid. T referenced in U. \nError: `function f<T extends U, U>() {}` - Circular constraint?",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_err_146_fixed",
        "title": "Circular generic constraint",
        "description": "Find error.",
        "codeSnippet": "function f<T extends U, U extends T>() {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Type parameter 'U' has a circular constraint.",
        "difficultyLevel": 3
    },
    {
        "id": "typescript_tf_146",
        "title": "Template literal validation",
        "description": "Pattern.",
        "codeSnippet": "type Hex = `#${string}`;\nlet color: Hex = '#FFF';",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Pattern matching 'start with #'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_147",
        "title": "Invalid module augmentation",
        "description": "Find error.",
        "codeSnippet": "declare module 'foo' {\n  export default function f(): void;\n  export default function g(): void;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "A module cannot have multiple default exports.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_147",
        "title": "Constructor private field",
        "description": "Init.",
        "codeSnippet": "class C {\n  #x;\n  constructor() { this.#x = 1; }\n}",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Private fields can be initialized in constructor.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_148",
        "title": "Abstract class method body",
        "description": "Find error.",
        "codeSnippet": "abstract class A {\n  abstract m() {};\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Method 'm' cannot have an implementation because it is marked abstract.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_148",
        "title": "Type alias union recursion",
        "description": "Type.",
        "codeSnippet": "type Json = string | number | Json[];\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Recursive union is valid.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_149",
        "title": "Decorator on var",
        "description": "Find error.",
        "codeSnippet": "@dec\nvar x = 1;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Decorators are not valid on variable declarations.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_149",
        "title": "Type symbol",
        "description": "Symbol.",
        "codeSnippet": "let s: symbol = Symbol();\n// Valid?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'symbol' is a primitive type.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_150",
        "title": "Undefined call",
        "description": "Find error.",
        "codeSnippet": "let x = undefined;\nx();",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Value of type 'undefined' is not callable.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_150",
        "title": "Object keys type",
        "description": "Runtime.",
        "codeSnippet": "let k = Object.keys({ a: 1 });\n// k is string[]",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Object.keys always returns string[].",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_151",
        "title": "Module augmentation export",
        "description": "Find error.",
        "codeSnippet": "declare module './mod' {\n  export const x: number;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Top-level declarations in .d.ts files must start with 'export' or 'declare'. Wait. In module augmentation, `export const x` IS correct. \nError: `declare module './mod' { const x: number; }` - 'x' is not exported.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_151_fixed",
        "title": "Module augmentation missing export",
        "description": "Find error.",
        "codeSnippet": "declare module './mod' {\n  const x: number;\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Declarations in ambient modules are not visible unless exported.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_151",
        "title": "Satisfies operator",
        "description": "TS 4.9.",
        "codeSnippet": "type Colors = 'red' | 'blue';\nconst p = { red: 'val' } satisfies Record<Colors, string>;\n// p.red is string",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'satisfies' validates type without widening (preserves literal types if possible).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_152",
        "title": "Non-null assertion in JS",
        "description": "Find error.",
        "codeSnippet": "// file.js\nlet x = y!;",
        "type": "errorSpotting",
        "language": "javascript",
        "errorLineIndex": 1,
        "explanation": "Non-null assertion operator '!' is not allowed in JavaScript files.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_152",
        "title": "Using declarations",
        "description": "Resource.",
        "codeSnippet": "function f() {\n  using x = new Disposable();\n}\n// x disposed at end of block",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'using' keyword (TS 5.2+) supports explicit resource management.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_153",
        "title": "Interface method body",
        "description": "Find error.",
        "codeSnippet": "interface I {\n  m() {};\n}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 1,
        "explanation": "Interface members cannot have implementations.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_tf_153",
        "title": "Template literal number",
        "description": "Type.",
        "codeSnippet": "type T = `${number}`;\n// Matches any stringified number?",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Template literal types can use 'number' generic to match stringified numbers.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_err_154",
        "title": "Readonly tuple assignment",
        "description": "Find error.",
        "codeSnippet": "let x: [number] = [1];\nlet y: readonly [number] = x;\nx = y;",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 2,
        "explanation": "The type 'readonly [number]' is 'readonly' and cannot be assigned to the mutable type '[number]'.",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_154",
        "title": "Override keyword",
        "description": "Class.",
        "codeSnippet": "class A { m() {} }\nclass B extends A { override m() {} }",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "'override' keyword ensures method overrides a base class method.",
        "difficultyLevel": 1
    },
    {
        "id": "typescript_err_155",
        "title": "Invalid decorator position",
        "description": "Find error.",
        "codeSnippet": "function f(@dec x: number) {}",
        "type": "errorSpotting",
        "language": "typescript",
        "errorLineIndex": 0,
        "explanation": "Decorators are not allowed on parameters of function declarations (only methods/constructors).",
        "difficultyLevel": 2
    },
    {
        "id": "typescript_tf_155",
        "title": "Import type naming",
        "description": "Syntax.",
        "codeSnippet": "import { type A, B } from './mod';\n// A is type-only, B is value",
        "type": "trueOrFalse",
        "language": "typescript",
        "isCodeCorrect": true,
        "explanation": "Inline 'type' modifier in named imports is valid.",
        "difficultyLevel": 1
    }
]