[
    {
        "q": "What is Nginx?",
        "type": "mcq",
        "o": [
            "A high-performance web server and reverse proxy",
            "A database management system",
            "A programming language",
            "An operating system"
        ]
    },
    {
        "q": "Nginx was created by ______.",
        "type": "fill_blank",
        "answers": [
            "Igor Sysoev"
        ],
        "other_options": [
            "Linus Torvalds",
            "Tim Berners-Lee",
            "Bill Gates"
        ]
    },
    {
        "q": "What is the main advantage of Nginx over Apache?",
        "type": "mcq",
        "o": [
            "Event-driven architecture handling many concurrent connections",
            "Better PHP support",
            "Easier configuration",
            "More modules available"
        ]
    },
    {
        "q": "Nginx uses an event-driven, asynchronous architecture.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the default Nginx configuration file location on Linux?",
        "type": "mcq",
        "o": [
            "/etc/nginx/nginx.conf",
            "/var/www/nginx.conf",
            "/usr/nginx/config",
            "/home/nginx/nginx.conf"
        ]
    },
    {
        "q": "The main Nginx process is called the ______ process.",
        "type": "fill_blank",
        "answers": [
            "master"
        ],
        "other_options": [
            "main",
            "parent",
            "root"
        ]
    },
    {
        "q": "What are worker processes in Nginx?",
        "type": "mcq",
        "o": [
            "Processes that handle actual client connections",
            "Processes that write logs",
            "Processes that manage configuration",
            "Background maintenance processes"
        ]
    },
    {
        "q": "The master process reads and validates configuration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What command tests Nginx configuration without starting the server?",
        "type": "mcq",
        "o": [
            "nginx -t",
            "nginx -test",
            "nginx -check",
            "nginx -verify"
        ]
    },
    {
        "q": "The nginx -s reload command reloads configuration without ______.",
        "type": "fill_blank",
        "answers": [
            "stopping the server"
        ],
        "other_options": [
            "reading logs",
            "checking config",
            "clearing cache"
        ]
    },
    {
        "q": "What does 'nginx -s stop' do?",
        "type": "mcq",
        "o": [
            "Immediately stops Nginx",
            "Gracefully stops Nginx",
            "Restarts Nginx",
            "Reloads configuration"
        ]
    },
    {
        "q": "The 'nginx -s quit' command waits for current connections to finish.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a directive in Nginx?",
        "type": "mcq",
        "o": [
            "A configuration instruction consisting of name and parameters",
            "A type of log entry",
            "A module function",
            "A server process"
        ]
    },
    {
        "q": "Nginx directives end with a ______.",
        "type": "fill_blank",
        "answers": [
            "semicolon"
        ],
        "other_options": [
            "colon",
            "period",
            "comma"
        ]
    },
    {
        "q": "What is a context in Nginx configuration?",
        "type": "mcq",
        "o": [
            "A block that groups related directives within curly braces",
            "A type of variable",
            "A log format",
            "A module type"
        ]
    },
    {
        "q": "The main context is also called the global context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the events context used for?",
        "type": "mcq",
        "o": [
            "Configuring connection processing settings",
            "Defining event logs",
            "Managing events scheduling",
            "Setting up webhooks"
        ]
    },
    {
        "q": "The http context contains directives for ______ traffic.",
        "type": "fill_blank",
        "answers": [
            "web"
        ],
        "other_options": [
            "mail",
            "stream",
            "core"
        ]
    },
    {
        "q": "What is the server context used for?",
        "type": "mcq",
        "o": [
            "Defining a virtual server configuration",
            "Configuring server hardware",
            "Managing server processes",
            "Setting server variables"
        ]
    },
    {
        "q": "Multiple server blocks can exist within an http context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the location context used for?",
        "type": "mcq",
        "o": [
            "Handling requests based on URI patterns",
            "Setting geographic locations",
            "Defining file locations",
            "Configuring GPS settings"
        ]
    },
    {
        "q": "The location context is nested inside the ______ context.",
        "type": "fill_blank",
        "answers": [
            "server"
        ],
        "other_options": [
            "http",
            "events",
            "main"
        ]
    },
    {
        "q": "What does the 'listen' directive specify?",
        "type": "mcq",
        "o": [
            "The port and IP address the server listens on",
            "Log listening settings",
            "Connection monitoring",
            "Event listeners"
        ]
    },
    {
        "q": "The default HTTP port is 80.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does 'server_name' directive specify?",
        "type": "mcq",
        "o": [
            "The domain names the server block responds to",
            "The server's hostname",
            "The administrator name",
            "The physical server name"
        ]
    },
    {
        "q": "The underscore (_) as server_name matches requests with no ______.",
        "type": "fill_blank",
        "answers": [
            "Host header"
        ],
        "other_options": [
            "port",
            "path",
            "method"
        ]
    },
    {
        "q": "What is the 'root' directive?",
        "type": "mcq",
        "o": [
            "Sets the document root directory for serving files",
            "Sets root user permissions",
            "Defines root path for logs",
            "Configures root access"
        ]
    },
    {
        "q": "The root directive can be placed in server, location, or http context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the 'index' directive?",
        "type": "mcq",
        "o": [
            "Specifies default files to serve for directory requests",
            "Creates search indexes",
            "Defines array indexes",
            "Sets database indexes"
        ]
    },
    {
        "q": "The default index file is usually ______.",
        "type": "fill_blank",
        "answers": [
            "index.html"
        ],
        "other_options": [
            "default.html",
            "home.html",
            "main.html"
        ]
    },
    {
        "q": "What does the 'include' directive do?",
        "type": "mcq",
        "o": [
            "Includes content from another configuration file",
            "Adds modules",
            "Imports variables",
            "Loads scripts"
        ]
    },
    {
        "q": "Include can use wildcards to include multiple files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the 'error_page' directive?",
        "type": "mcq",
        "o": [
            "Defines custom error pages for HTTP error codes",
            "Logs error pages",
            "Creates error reports",
            "Handles page errors"
        ]
    },
    {
        "q": "error_page 404 /404.html; shows a custom page for ______ errors.",
        "type": "fill_blank",
        "answers": [
            "Not Found"
        ],
        "other_options": [
            "Server Error",
            "Forbidden",
            "Bad Request"
        ]
    },
    {
        "q": "What does 'access_log' directive configure?",
        "type": "mcq",
        "o": [
            "The location and format of access logs",
            "Access control rules",
            "User access settings",
            "Login logging"
        ]
    },
    {
        "q": "Access logs can be disabled by setting access_log off.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does 'error_log' directive configure?",
        "type": "mcq",
        "o": [
            "The location and level of error logs",
            "Error handling behavior",
            "Error page locations",
            "Error notifications"
        ]
    },
    {
        "q": "Error log levels include debug, info, warn, and ______.",
        "type": "fill_blank",
        "answers": [
            "error"
        ],
        "other_options": [
            "critical",
            "fatal",
            "severe"
        ]
    },
    {
        "q": "What is worker_processes directive?",
        "type": "mcq",
        "o": [
            "Sets the number of worker processes Nginx spawns",
            "Configures background workers",
            "Sets maximum workers",
            "Defines worker types"
        ]
    },
    {
        "q": "Setting worker_processes to 'auto' sets it to the number of CPU cores.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is worker_connections directive?",
        "type": "mcq",
        "o": [
            "Maximum simultaneous connections per worker process",
            "Worker to worker connections",
            "Connection pooling settings",
            "Maximum total connections"
        ]
    },
    {
        "q": "The maximum concurrent connections is worker_processes times ______.",
        "type": "fill_blank",
        "answers": [
            "worker_connections"
        ],
        "other_options": [
            "max_connections",
            "total_connections",
            "connections"
        ]
    },
    {
        "q": "What is the 'use' directive in events context?",
        "type": "mcq",
        "o": [
            "Specifies the connection processing method like epoll or kqueue",
            "Uses specific modules",
            "Enables features",
            "Sets usage limits"
        ]
    },
    {
        "q": "epoll is the most efficient connection method for Linux.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is multi_accept directive?",
        "type": "mcq",
        "o": [
            "Allows worker to accept multiple connections at once",
            "Multi-threaded acceptance",
            "Multiple listener ports",
            "Accept from multiple sources"
        ]
    },
    {
        "q": "The ______ context is used for TCP/UDP load balancing.",
        "type": "fill_blank",
        "answers": [
            "stream"
        ],
        "other_options": [
            "tcp",
            "udp",
            "network"
        ]
    },
    {
        "q": "What is a server block in Nginx?",
        "type": "mcq",
        "o": [
            "Configuration for a virtual server/host",
            "Physical server configuration",
            "Server hardware block",
            "Block of server code"
        ]
    },
    {
        "q": "Server blocks are the Nginx equivalent of Apache's VirtualHost.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Where are site-specific server blocks typically stored?",
        "type": "mcq",
        "o": [
            "/etc/nginx/sites-available/ and sites-enabled/",
            "/var/www/sites/",
            "/usr/nginx/hosts/",
            "/etc/nginx/hosts/"
        ]
    },
    {
        "q": "Sites are enabled by creating a ______ link in sites-enabled.",
        "type": "fill_blank",
        "answers": [
            "symbolic"
        ],
        "other_options": [
            "hard",
            "soft",
            "direct"
        ]
    },
    {
        "q": "What is the default_server parameter?",
        "type": "mcq",
        "o": [
            "Makes a server block handle requests not matching other server_names",
            "The primary server",
            "Default configuration",
            "Fallback settings"
        ]
    },
    {
        "q": "Only one server block per IP:port can have default_server.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is location matching in Nginx?",
        "type": "mcq",
        "o": [
            "Selecting which location block handles a request based on URI",
            "Geographic location detection",
            "File location finding",
            "Server location settings"
        ]
    },
    {
        "q": "The prefix location matches URIs starting with ______.",
        "type": "fill_blank",
        "answers": [
            "the specified string"
        ],
        "other_options": [
            "exact match",
            "regex pattern",
            "wildcard"
        ]
    },
    {
        "q": "What does 'location = /path' mean?",
        "type": "mcq",
        "o": [
            "Exact match - only matches this exact URI",
            "Starts with /path",
            "Contains /path",
            "Ends with /path"
        ]
    },
    {
        "q": "Exact match (=) has the highest priority in location matching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the ~ modifier mean in location?",
        "type": "mcq",
        "o": [
            "Case-sensitive regular expression match",
            "Case-insensitive match",
            "Prefix match",
            "Longest match"
        ]
    },
    {
        "q": "The ~* modifier means ______ regular expression match.",
        "type": "fill_blank",
        "answers": [
            "case-insensitive"
        ],
        "other_options": [
            "case-sensitive",
            "exact",
            "prefix"
        ]
    },
    {
        "q": "What does ^~ modifier mean in location?",
        "type": "mcq",
        "o": [
            "Prefix match that stops if this is the longest match, skipping regex",
            "Start of string match",
            "Negative match",
            "Priority match"
        ]
    },
    {
        "q": "Match the location modifiers with their meanings:",
        "type": "match",
        "left": [
            "=",
            "~",
            "~*",
            "^~"
        ],
        "right": [
            "Exact match",
            "Case-sensitive regex",
            "Case-insensitive regex",
            "Prefix priority"
        ]
    },
    {
        "q": "Rearrange location matching priority from highest to lowest:",
        "type": "rearrange",
        "words": [
            "Exact =",
            "Priority prefix ^~",
            "Regex ~ or ~*",
            "Prefix match"
        ]
    },
    {
        "q": "What is the try_files directive?",
        "type": "mcq",
        "o": [
            "Checks for files in order and serves the first found",
            "Try different configurations",
            "Attempt file uploads",
            "Test file permissions"
        ]
    },
    {
        "q": "try_files $uri $uri/ =404 returns 404 if file not ______.",
        "type": "fill_blank",
        "answers": [
            "found"
        ],
        "other_options": [
            "valid",
            "readable",
            "accessible"
        ]
    },
    {
        "q": "What is the 'alias' directive?",
        "type": "mcq",
        "o": [
            "Replaces the matched location with a different path",
            "Creates hostname aliases",
            "Defines command aliases",
            "Sets variable aliases"
        ]
    },
    {
        "q": "alias replaces the location prefix while root appends it.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the 'return' directive?",
        "type": "mcq",
        "o": [
            "Returns a specified HTTP status code and optional text/URL",
            "Returns to previous location",
            "Returns error messages",
            "Returns function values"
        ]
    },
    {
        "q": "return 301 http://example.com performs a ______ redirect.",
        "type": "fill_blank",
        "answers": [
            "permanent"
        ],
        "other_options": [
            "temporary",
            "conditional",
            "internal"
        ]
    },
    {
        "q": "What is the 'rewrite' directive?",
        "type": "mcq",
        "o": [
            "Rewrites URIs using regular expressions",
            "Rewrites configuration files",
            "Rewrites log entries",
            "Rewrites response content"
        ]
    },
    {
        "q": "The 'last' flag in rewrite stops processing and restarts matching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the 'break' flag do in rewrite?",
        "type": "mcq",
        "o": [
            "Stops processing rewrites and continues in current location",
            "Breaks the connection",
            "Exits the server block",
            "Terminates the request"
        ]
    },
    {
        "q": "The 'permanent' flag returns status code ______.",
        "type": "fill_blank",
        "answers": [
            "301"
        ],
        "other_options": [
            "302",
            "303",
            "307"
        ]
    },
    {
        "q": "What does the 'redirect' flag in rewrite do?",
        "type": "mcq",
        "o": [
            "Returns a 302 temporary redirect",
            "Returns a 301 permanent redirect",
            "Internal redirect only",
            "Redirects to error page"
        ]
    },
    {
        "q": "What is 'proxy_pass' directive?",
        "type": "mcq",
        "o": [
            "Forwards requests to a proxied server",
            "Passes proxy authentication",
            "Enables proxy cache",
            "Sets proxy password"
        ]
    },
    {
        "q": "proxy_pass http://backend; forwards requests to the ______ server.",
        "type": "fill_blank",
        "answers": [
            "backend"
        ],
        "other_options": [
            "frontend",
            "primary",
            "main"
        ]
    },
    {
        "q": "What does 'proxy_set_header' do?",
        "type": "mcq",
        "o": [
            "Sets or modifies headers sent to proxied server",
            "Sets proxy response headers",
            "Configures header caching",
            "Defines header format"
        ]
    },
    {
        "q": "proxy_set_header Host $host; passes the original Host header.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the $remote_addr variable?",
        "type": "mcq",
        "o": [
            "The IP address of the client",
            "Remote server address",
            "Backend address",
            "Load balancer IP"
        ]
    },
    {
        "q": "The X-Real-IP header is commonly set to ______.",
        "type": "fill_blank",
        "answers": [
            "$remote_addr"
        ],
        "other_options": [
            "$host",
            "$uri",
            "$server_addr"
        ]
    },
    {
        "q": "What is X-Forwarded-For header used for?",
        "type": "mcq",
        "o": [
            "Tracking the original client IP through proxies",
            "Forwarding authentication",
            "Specifying forward destination",
            "Enabling request forwarding"
        ]
    },
    {
        "q": "X-Forwarded-Proto indicates whether original request was HTTP or HTTPS.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is 'upstream' block used for?",
        "type": "mcq",
        "o": [
            "Defining a group of backend servers for load balancing",
            "Upstream data processing",
            "Network upstream configuration",
            "Parent server settings"
        ]
    },
    {
        "q": "upstream backend { server 127.0.0.1:8080; } defines a ______ group.",
        "type": "fill_blank",
        "answers": [
            "server"
        ],
        "other_options": [
            "client",
            "proxy",
            "cache"
        ]
    },
    {
        "q": "What is the default load balancing method in Nginx?",
        "type": "mcq",
        "o": [
            "Round robin",
            "Least connections",
            "IP hash",
            "Random"
        ]
    },
    {
        "q": "The 'least_conn' directive uses least connections load balancing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does 'ip_hash' directive do in upstream?",
        "type": "mcq",
        "o": [
            "Routes requests from same IP to same server for session persistence",
            "Hashes IP for security",
            "Validates IP addresses",
            "Loads based on IP range"
        ]
    },
    {
        "q": "The 'weight' parameter adjusts the proportion of ______ a server receives.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "connections",
            "bandwidth",
            "resources"
        ]
    },
    {
        "q": "What does 'backup' server parameter mean?",
        "type": "mcq",
        "o": [
            "Server is only used when primary servers are unavailable",
            "Backs up server data",
            "Secondary server always running",
            "Configuration backup"
        ]
    },
    {
        "q": "The 'down' parameter marks a server as permanently unavailable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is 'max_fails' parameter?",
        "type": "mcq",
        "o": [
            "Number of failed attempts before marking server unavailable",
            "Maximum failure log entries",
            "Failure rate limit",
            "Maximum error pages"
        ]
    },
    {
        "q": "fail_timeout defines both failure period and server ______ time.",
        "type": "fill_blank",
        "answers": [
            "unavailable"
        ],
        "other_options": [
            "timeout",
            "recovery",
            "check"
        ]
    },
    {
        "q": "What is SSL/TLS in Nginx context?",
        "type": "mcq",
        "o": [
            "Protocols for encrypting HTTP traffic (HTTPS)",
            "Server-side logging",
            "Session storage layer",
            "Static site loading"
        ]
    },
    {
        "q": "HTTPS typically runs on port 443.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What directive enables SSL for a server block?",
        "type": "mcq",
        "o": [
            "listen 443 ssl;",
            "ssl enable;",
            "ssl on;",
            "use_ssl true;"
        ]
    },
    {
        "q": "ssl_certificate specifies the path to the ______ certificate file.",
        "type": "fill_blank",
        "answers": [
            "public"
        ],
        "other_options": [
            "private",
            "root",
            "intermediate"
        ]
    },
    {
        "q": "What is ssl_certificate_key directive?",
        "type": "mcq",
        "o": [
            "Path to the private key file",
            "Certificate encryption key",
            "Key rotation settings",
            "Public key location"
        ]
    },
    {
        "q": "The private key file should have restricted permissions (600).",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_protocols directive?",
        "type": "mcq",
        "o": [
            "Specifies which SSL/TLS versions to enable",
            "SSL protocol modes",
            "Protocol conversion settings",
            "Network protocols"
        ]
    },
    {
        "q": "TLSv1.2 and TLSv1.3 are recommended; TLSv1.0 and TLSv1.1 are ______.",
        "type": "fill_blank",
        "answers": [
            "deprecated"
        ],
        "other_options": [
            "required",
            "optional",
            "faster"
        ]
    },
    {
        "q": "What is ssl_ciphers directive?",
        "type": "mcq",
        "o": [
            "Specifies the cipher suites for SSL/TLS",
            "Encryption keys",
            "Certificate ciphers",
            "Password encryption"
        ]
    },
    {
        "q": "ssl_prefer_server_ciphers on; uses the server's cipher preference.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_session_cache?",
        "type": "mcq",
        "o": [
            "Caches SSL session parameters to speed up subsequent connections",
            "Stores certificates",
            "Caches encrypted data",
            "Session database"
        ]
    },
    {
        "q": "The shared cache type is recommended for ______ worker processes.",
        "type": "fill_blank",
        "answers": [
            "multiple"
        ],
        "other_options": [
            "single",
            "backup",
            "primary"
        ]
    },
    {
        "q": "What is ssl_session_timeout?",
        "type": "mcq",
        "o": [
            "How long cached SSL sessions remain valid",
            "Connection timeout",
            "Certificate validity",
            "Handshake timeout"
        ]
    },
    {
        "q": "ssl_session_tickets enables stateless session resumption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_stapling?",
        "type": "mcq",
        "o": [
            "OCSP stapling - server provides certificate validity proof",
            "Attaching certificates",
            "Stapling requests together",
            "Certificate pinning"
        ]
    },
    {
        "q": "ssl_stapling_verify on; verifies the ______ response.",
        "type": "fill_blank",
        "answers": [
            "OCSP"
        ],
        "other_options": [
            "SSL",
            "TLS",
            "certificate"
        ]
    },
    {
        "q": "What is ssl_trusted_certificate?",
        "type": "mcq",
        "o": [
            "Path to CA certificates for OCSP stapling verification",
            "Trusted client certificates",
            "Root certificate location",
            "Intermediate certificate file"
        ]
    },
    {
        "q": "Let's Encrypt certificates should include the full chain.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is resolver directive for OCSP stapling?",
        "type": "mcq",
        "o": [
            "DNS server to use for OCSP responder lookup",
            "Name resolution settings",
            "Domain resolver",
            "IP resolution"
        ]
    },
    {
        "q": "The resolver should typically point to a reliable DNS like ______.",
        "type": "fill_blank",
        "answers": [
            "8.8.8.8 or 1.1.1.1"
        ],
        "other_options": [
            "localhost",
            "127.0.0.1",
            "0.0.0.0"
        ]
    },
    {
        "q": "What is ssl_dhparam?",
        "type": "mcq",
        "o": [
            "Path to Diffie-Hellman parameters file for forward secrecy",
            "Dynamic HTTP parameters",
            "Delta compression settings",
            "Data handling parameters"
        ]
    },
    {
        "q": "DH parameters should be at least 2048 bits for security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is add_header directive?",
        "type": "mcq",
        "o": [
            "Adds custom headers to responses",
            "Adds request headers",
            "Adds log headers",
            "Adds configuration headers"
        ]
    },
    {
        "q": "add_header Strict-Transport-Security enables ______.",
        "type": "fill_blank",
        "answers": [
            "HSTS"
        ],
        "other_options": [
            "SSL",
            "TLS",
            "HTTPS"
        ]
    },
    {
        "q": "What does the 'always' parameter in add_header do?",
        "type": "mcq",
        "o": [
            "Adds header to all responses including error pages",
            "Always overwrite existing headers",
            "Permanent header addition",
            "Mandatory header"
        ]
    },
    {
        "q": "Headers added with add_header are inherited by nested blocks by default.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is gzip directive?",
        "type": "mcq",
        "o": [
            "Enables gzip compression for responses",
            "Compression level",
            "File compression",
            "Log compression"
        ]
    },
    {
        "q": "gzip_types specifies which MIME types to ______.",
        "type": "fill_blank",
        "answers": [
            "compress"
        ],
        "other_options": [
            "ignore",
            "cache",
            "log"
        ]
    },
    {
        "q": "What is gzip_vary directive?",
        "type": "mcq",
        "o": [
            "Adds Vary: Accept-Encoding header for proper caching",
            "Variable compression ratio",
            "Varying compression levels",
            "Compression variance"
        ]
    },
    {
        "q": "gzip_min_length sets minimum response size to compress.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is gzip_comp_level?",
        "type": "mcq",
        "o": [
            "Compression level from 1 (fastest) to 9 (best compression)",
            "Completion level",
            "Comparison level",
            "Component level"
        ]
    },
    {
        "q": "A gzip_comp_level of ______ provides a good balance of speed and compression.",
        "type": "fill_blank",
        "answers": [
            "5 or 6"
        ],
        "other_options": [
            "1",
            "9",
            "10"
        ]
    },
    {
        "q": "What is gzip_proxied directive?",
        "type": "mcq",
        "o": [
            "Controls compression for proxied requests based on headers",
            "Proxy compression settings",
            "Proxied gzip files",
            "Proxy-only compression"
        ]
    },
    {
        "q": "gzip_static on; serves pre-compressed .gz files if available.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is brotli compression in Nginx?",
        "type": "mcq",
        "o": [
            "A compression algorithm with better ratios than gzip",
            "Browser-specific encoding",
            "British encoding",
            "Byte rotation"
        ]
    },
    {
        "q": "Brotli requires a ______ module in Nginx.",
        "type": "fill_blank",
        "answers": [
            "third-party or compiled"
        ],
        "other_options": [
            "core",
            "standard",
            "built-in"
        ]
    },
    {
        "q": "What are Nginx modules?",
        "type": "mcq",
        "o": [
            "Extensions that add functionality to Nginx",
            "Configuration files",
            "Server processes",
            "Log handlers"
        ]
    },
    {
        "q": "Core modules are compiled into Nginx by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the http_ssl_module?",
        "type": "mcq",
        "o": [
            "Provides HTTPS support",
            "SSL logging",
            "Certificate management",
            "Key storage"
        ]
    },
    {
        "q": "Dynamic modules can be loaded at runtime using load_module ______.",
        "type": "fill_blank",
        "answers": [
            "directive"
        ],
        "other_options": [
            "command",
            "function",
            "script"
        ]
    },
    {
        "q": "What is http_v2_module?",
        "type": "mcq",
        "o": [
            "Provides HTTP/2 protocol support",
            "Version control",
            "HTTP validation",
            "Header version 2"
        ]
    },
    {
        "q": "HTTP/2 requires SSL/TLS in most browsers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_realip_module?",
        "type": "mcq",
        "o": [
            "Extracts real client IP from proxy headers",
            "Real-time IP logging",
            "IP validation",
            "IP masking"
        ]
    },
    {
        "q": "set_real_ip_from specifies trusted ______ addresses.",
        "type": "fill_blank",
        "answers": [
            "proxy"
        ],
        "other_options": [
            "client",
            "server",
            "backend"
        ]
    },
    {
        "q": "What is real_ip_header?",
        "type": "mcq",
        "o": [
            "Specifies which header contains the real client IP",
            "Header for real data",
            "IP header format",
            "Real-time header"
        ]
    },
    {
        "q": "X-Forwarded-For is commonly used as real_ip_header.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_stub_status_module?",
        "type": "mcq",
        "o": [
            "Provides basic Nginx status information",
            "Stub file serving",
            "Status page styling",
            "Static status"
        ]
    },
    {
        "q": "stub_status returns active connections and ______ counts.",
        "type": "fill_blank",
        "answers": [
            "request"
        ],
        "other_options": [
            "error",
            "log",
            "cache"
        ]
    },
    {
        "q": "What is http_geoip_module?",
        "type": "mcq",
        "o": [
            "Provides geographic location based on client IP",
            "GPS integration",
            "Map services",
            "Geographic logging"
        ]
    },
    {
        "q": "GeoIP requires MaxMind database files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_limit_req_module?",
        "type": "mcq",
        "o": [
            "Rate limits incoming requests",
            "Request logging limits",
            "Request size limits",
            "Connection limits"
        ]
    },
    {
        "q": "limit_req_zone defines the ______ for rate limiting.",
        "type": "fill_blank",
        "answers": [
            "shared memory zone"
        ],
        "other_options": [
            "request pool",
            "connection limit",
            "buffer size"
        ]
    },
    {
        "q": "What is the burst parameter in limit_req?",
        "type": "mcq",
        "o": [
            "Allows temporary excess requests to queue",
            "Maximum burst speed",
            "Burst error handling",
            "Packet bursting"
        ]
    },
    {
        "q": "The nodelay parameter processes burst requests immediately without queuing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_limit_conn_module?",
        "type": "mcq",
        "o": [
            "Limits concurrent connections per key like IP",
            "Connection logging",
            "Connection pooling",
            "Protocol limits"
        ]
    },
    {
        "q": "limit_conn_zone defines ______ for connection limiting.",
        "type": "fill_blank",
        "answers": [
            "shared memory zone"
        ],
        "other_options": [
            "connection pool",
            "limit parameters",
            "zone size"
        ]
    },
    {
        "q": "What is http_auth_basic_module?",
        "type": "mcq",
        "o": [
            "Provides HTTP Basic Authentication",
            "Basic authorization",
            "Base64 encoding",
            "Basic error handling"
        ]
    },
    {
        "q": "auth_basic_user_file points to the htpasswd file.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_access_module?",
        "type": "mcq",
        "o": [
            "Allows or denies access based on IP addresses",
            "Access logging",
            "File access control",
            "User access management"
        ]
    },
    {
        "q": "The order of allow and deny directives ______.",
        "type": "fill_blank",
        "answers": [
            "matters"
        ],
        "other_options": [
            "doesn't matter",
            "is alphabetical",
            "is automatic"
        ]
    },
    {
        "q": "What does 'deny all;' do?",
        "type": "mcq",
        "o": [
            "Blocks access from all IP addresses",
            "Denies all errors",
            "Rejects all methods",
            "Closes all connections"
        ]
    },
    {
        "q": "allow 192.168.1.0/24 allows an entire subnet.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_autoindex_module?",
        "type": "mcq",
        "o": [
            "Generates directory listings when no index file exists",
            "Auto-creates index files",
            "Indexes search content",
            "Automatic file indexing"
        ]
    },
    {
        "q": "autoindex on; enables directory ______.",
        "type": "fill_blank",
        "answers": [
            "listing"
        ],
        "other_options": [
            "creation",
            "sorting",
            "caching"
        ]
    },
    {
        "q": "What is http_map_module?",
        "type": "mcq",
        "o": [
            "Creates variables based on values of other variables",
            "Geographic mapping",
            "URL mapping",
            "Header mapping"
        ]
    },
    {
        "q": "map is useful for conditional variable assignment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_geo_module?",
        "type": "mcq",
        "o": [
            "Creates variables based on client IP address",
            "Geographic services",
            "GPS tracking",
            "Location logging"
        ]
    },
    {
        "q": "geo directive can assign values based on IP ______.",
        "type": "fill_blank",
        "answers": [
            "ranges"
        ],
        "other_options": [
            "addresses",
            "lists",
            "blocks"
        ]
    },
    {
        "q": "What is http_split_clients_module?",
        "type": "mcq",
        "o": [
            "Splits clients into groups for A/B testing",
            "Splits connections",
            "Divides bandwidth",
            "Separates requests"
        ]
    },
    {
        "q": "split_clients can route a percentage of traffic to different backends.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_referer_module?",
        "type": "mcq",
        "o": [
            "Validates requests based on Referer header",
            "Referral tracking",
            "Reference logging",
            "Referrer storage"
        ]
    },
    {
        "q": "valid_referers blocks hotlinking from ______ domains.",
        "type": "fill_blank",
        "answers": [
            "unauthorized"
        ],
        "other_options": [
            "all",
            "external",
            "internal"
        ]
    },
    {
        "q": "What is http_secure_link_module?",
        "type": "mcq",
        "o": [
            "Validates links with secret keys and expiration",
            "SSL link creation",
            "Secure connection",
            "Link encryption"
        ]
    },
    {
        "q": "secure_link_secret provides basic hotlink protection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_sub_module?",
        "type": "mcq",
        "o": [
            "Substitutes text in response bodies",
            "Subdomain handling",
            "Subscription management",
            "Subfile serving"
        ]
    },
    {
        "q": "sub_filter replaces ______ in responses.",
        "type": "fill_blank",
        "answers": [
            "strings"
        ],
        "other_options": [
            "headers",
            "cookies",
            "methods"
        ]
    },
    {
        "q": "What is http_addition_module?",
        "type": "mcq",
        "o": [
            "Adds content before or after response body",
            "Adds headers",
            "Adds connections",
            "Adds modules"
        ]
    },
    {
        "q": "add_before_body and add_after_body include content from subrequests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_image_filter_module?",
        "type": "mcq",
        "o": [
            "Transforms images on-the-fly (resize, rotate, crop)",
            "Image caching",
            "Image compression",
            "Image logging"
        ]
    },
    {
        "q": "image_filter resize 100 100; resizes images to 100x100 ______.",
        "type": "fill_blank",
        "answers": [
            "pixels"
        ],
        "other_options": [
            "percent",
            "bytes",
            "inches"
        ]
    },
    {
        "q": "What is http_xslt_module?",
        "type": "mcq",
        "o": [
            "Transforms XML responses using XSLT stylesheets",
            "Style transfer",
            "XML storage",
            "Template processing"
        ]
    },
    {
        "q": "XSLT module is useful for converting XML to HTML.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is http_flv_module?",
        "type": "mcq",
        "o": [
            "Provides streaming support for Flash Video files",
            "File validation",
            "Flash logging",
            "Video compression"
        ]
    },
    {
        "q": "http_mp4_module provides pseudo-streaming for ______ files.",
        "type": "fill_blank",
        "answers": [
            "MP4"
        ],
        "other_options": [
            "FLV",
            "AVI",
            "MOV"
        ]
    },
    {
        "q": "What is http_random_index_module?",
        "type": "mcq",
        "o": [
            "Serves a random file as the index from a directory",
            "Random file generation",
            "Index randomization",
            "Random ordering"
        ]
    },
    {
        "q": "random_index on; randomly selects an index file.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_cache directive?",
        "type": "mcq",
        "o": [
            "Specifies the cache zone to use for proxy caching",
            "Cache proxy settings",
            "Proxy cache path",
            "Cache configuration"
        ]
    },
    {
        "q": "proxy_cache_path defines cache location and ______.",
        "type": "fill_blank",
        "answers": [
            "parameters"
        ],
        "other_options": [
            "timeout",
            "size only",
            "format"
        ]
    },
    {
        "q": "What are keys_zone parameter?",
        "type": "mcq",
        "o": [
            "Shared memory zone for storing cache keys",
            "Encryption keys storage",
            "Zone key management",
            "Key validation zone"
        ]
    },
    {
        "q": "proxy_cache_valid sets cache duration for different status codes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_cache_key?",
        "type": "mcq",
        "o": [
            "Defines what parameters create unique cache entries",
            "Cache encryption key",
            "Key file path",
            "Cache key rotation"
        ]
    },
    {
        "q": "A typical proxy_cache_key includes $scheme, $host, and ______.",
        "type": "fill_blank",
        "answers": [
            "$request_uri"
        ],
        "other_options": [
            "$server_name",
            "$remote_addr",
            "$cookie_session"
        ]
    },
    {
        "q": "What is proxy_cache_bypass?",
        "type": "mcq",
        "o": [
            "Conditions under which to skip cache and fetch from upstream",
            "Cache bypass routing",
            "Proxy bypass settings",
            "Bypass cache zone"
        ]
    },
    {
        "q": "proxy_no_cache prevents caching when condition is true.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_cache_use_stale?",
        "type": "mcq",
        "o": [
            "Serves stale cache when upstream errors occur",
            "Stale cache cleanup",
            "Old cache usage",
            "Cache expiration"
        ]
    },
    {
        "q": "proxy_cache_use_stale error timeout updating; serves stale during ______.",
        "type": "fill_blank",
        "answers": [
            "upstream issues"
        ],
        "other_options": [
            "cache miss",
            "cold start",
            "maintenance"
        ]
    },
    {
        "q": "What is proxy_cache_lock?",
        "type": "mcq",
        "o": [
            "Prevents multiple requests from hitting upstream for same cache miss",
            "Locks cache files",
            "Exclusive cache access",
            "Cache write lock"
        ]
    },
    {
        "q": "proxy_cache_lock helps prevent cache stampede.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is fastcgi_pass directive?",
        "type": "mcq",
        "o": [
            "Forwards requests to a FastCGI server like PHP-FPM",
            "Fast proxy settings",
            "CGI script path",
            "Fast cache passing"
        ]
    },
    {
        "q": "PHP-FPM commonly listens on a Unix socket or port ______.",
        "type": "fill_blank",
        "answers": [
            "9000"
        ],
        "other_options": [
            "80",
            "443",
            "8080"
        ]
    },
    {
        "q": "What is fastcgi_param?",
        "type": "mcq",
        "o": [
            "Sets parameters passed to FastCGI server",
            "Fast parameter storage",
            "CGI configuration",
            "Script parameters"
        ]
    },
    {
        "q": "include fastcgi_params; includes common FastCGI parameters.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is SCRIPT_FILENAME in FastCGI?",
        "type": "mcq",
        "o": [
            "The full path to the script to execute",
            "Script name only",
            "File name pattern",
            "Script template"
        ]
    },
    {
        "q": "SCRIPT_FILENAME is typically set to $document_root$fastcgi_script_name.",
        "type": "fill_blank",
        "answers": [
            "True"
        ],
        "other_options": [
            "False",
            "Sometimes",
            "Never"
        ]
    },
    {
        "q": "What is uwsgi_pass directive?",
        "type": "mcq",
        "o": [
            "Forwards requests to a uWSGI server for Python apps",
            "Web socket passing",
            "Universal passing",
            "Upload passing"
        ]
    },
    {
        "q": "uwsgi is commonly used with Django and Flask applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is scgi_pass?",
        "type": "mcq",
        "o": [
            "Forwards requests to SCGI servers",
            "Script CGI handling",
            "Simple cache gateway",
            "Static CGI"
        ]
    },
    {
        "q": "Match Nginx proxy directives with backend types:",
        "type": "match",
        "left": [
            "proxy_pass",
            "fastcgi_pass",
            "uwsgi_pass",
            "scgi_pass"
        ],
        "right": [
            "HTTP backends",
            "PHP-FPM",
            "Python apps",
            "SCGI servers"
        ]
    },
    {
        "q": "Rearrange the steps to enable a new site in Nginx:",
        "type": "rearrange",
        "words": [
            "Create config in sites-available",
            "Symlink to sites-enabled",
            "Test configuration",
            "Reload Nginx"
        ]
    },
    {
        "q": "What is proxy_buffer_size?",
        "type": "mcq",
        "o": [
            "Size of buffer for first part of response from proxied server",
            "Total buffer memory",
            "Maximum request size",
            "Response buffer limit"
        ]
    },
    {
        "q": "proxy_buffers sets ______ and size of buffers for reading responses.",
        "type": "fill_blank",
        "answers": [
            "number"
        ],
        "other_options": [
            "type",
            "location",
            "timeout"
        ]
    },
    {
        "q": "What is proxy_busy_buffers_size?",
        "type": "mcq",
        "o": [
            "Maximum size of buffers that can be busy sending to client",
            "Buffer for busy servers",
            "Active connection buffer",
            "Busy timeout buffer"
        ]
    },
    {
        "q": "proxy_buffering off; disables response buffering for real-time responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_read_timeout?",
        "type": "mcq",
        "o": [
            "Maximum time to wait for response from proxied server",
            "Request read timeout",
            "Client read timeout",
            "Cache read timeout"
        ]
    },
    {
        "q": "proxy_connect_timeout sets the timeout for establishing connection to ______.",
        "type": "fill_blank",
        "answers": [
            "upstream"
        ],
        "other_options": [
            "client",
            "cache",
            "database"
        ]
    },
    {
        "q": "What is proxy_send_timeout?",
        "type": "mcq",
        "o": [
            "Maximum time for transmitting request to proxied server",
            "Response send timeout",
            "Client send timeout",
            "Cache send timeout"
        ]
    },
    {
        "q": "Timeouts are reset after each read or write operation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_next_upstream?",
        "type": "mcq",
        "o": [
            "Conditions for passing request to next upstream server",
            "Next proxy settings",
            "Upstream ordering",
            "Failover configuration"
        ]
    },
    {
        "q": "proxy_next_upstream error timeout invalid_header; retries on ______.",
        "type": "fill_blank",
        "answers": [
            "failures"
        ],
        "other_options": [
            "success",
            "redirect",
            "completion"
        ]
    },
    {
        "q": "What is proxy_intercept_errors?",
        "type": "mcq",
        "o": [
            "Enables processing error pages from upstream with error_page directive",
            "Intercepts error logs",
            "Captures error responses",
            "Blocks error messages"
        ]
    },
    {
        "q": "proxy_intercept_errors on; allows custom error pages for backend errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_hide_header?",
        "type": "mcq",
        "o": [
            "Prevents specific headers from being passed to client",
            "Hides request headers",
            "Encrypts headers",
            "Removes header logging"
        ]
    },
    {
        "q": "proxy_pass_header passes headers that are ______ hidden by default.",
        "type": "fill_blank",
        "answers": [
            "normally"
        ],
        "other_options": [
            "never",
            "always",
            "temporarily"
        ]
    },
    {
        "q": "What is keepalive in upstream?",
        "type": "mcq",
        "o": [
            "Maximum idle keepalive connections to upstream servers per worker",
            "Connection lifetime",
            "Alive check interval",
            "Health check setting"
        ]
    },
    {
        "q": "keepalive connections require proxy_http_version 1.1.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_http_version?",
        "type": "mcq",
        "o": [
            "HTTP protocol version for proxied connections",
            "Version control",
            "HTTP validation",
            "Protocol switching"
        ]
    },
    {
        "q": "For keepalive with HTTP/1.1, set Connection header to ______.",
        "type": "fill_blank",
        "answers": [
            "empty string"
        ],
        "other_options": [
            "close",
            "keep-alive",
            "upgrade"
        ]
    },
    {
        "q": "What is WebSocket proxying in Nginx?",
        "type": "mcq",
        "o": [
            "Passing WebSocket connections through Nginx to backend",
            "Socket configuration",
            "Network socket settings",
            "Socket storage"
        ]
    },
    {
        "q": "WebSocket requires Upgrade and Connection headers to be passed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What header values enable WebSocket upgrade?",
        "type": "mcq",
        "o": [
            "Upgrade: websocket and Connection: Upgrade",
            "WebSocket: enable",
            "Protocol: WS",
            "Socket: open"
        ]
    },
    {
        "q": "WebSocket connections are typically long-lived, requiring adjusted ______.",
        "type": "fill_blank",
        "answers": [
            "timeouts"
        ],
        "other_options": [
            "buffers",
            "workers",
            "ports"
        ]
    },
    {
        "q": "What is the stream module?",
        "type": "mcq",
        "o": [
            "Provides TCP/UDP load balancing and proxying",
            "Media streaming",
            "Stream logging",
            "Data streaming"
        ]
    },
    {
        "q": "stream context is separate from http context for TCP/UDP.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is stream proxy_pass?",
        "type": "mcq",
        "o": [
            "Forwards TCP/UDP connections to backend servers",
            "HTTP proxy in stream",
            "Streaming data pass",
            "Stream cache"
        ]
    },
    {
        "q": "Stream module can proxy ______ database connections.",
        "type": "fill_blank",
        "answers": [
            "MySQL or PostgreSQL"
        ],
        "other_options": [
            "only MySQL",
            "only PostgreSQL",
            "only MongoDB"
        ]
    },
    {
        "q": "What is stream ssl_preread?",
        "type": "mcq",
        "o": [
            "Reads SNI without decrypting to route based on hostname",
            "Pre-reads SSL certificates",
            "Early SSL validation",
            "SSL caching"
        ]
    },
    {
        "q": "ssl_preread enables routing HTTPS traffic without terminating SSL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is mail module in Nginx?",
        "type": "mcq",
        "o": [
            "Proxies IMAP, POP3, and SMTP protocols",
            "Email notifications",
            "Mail logging",
            "Message queuing"
        ]
    },
    {
        "q": "The mail module requires an ______ script for user authentication.",
        "type": "fill_blank",
        "answers": [
            "external or auth_http"
        ],
        "other_options": [
            "internal",
            "built-in",
            "default"
        ]
    },
    {
        "q": "What is Nginx Plus?",
        "type": "mcq",
        "o": [
            "Commercial version with advanced features and support",
            "Plugin system",
            "Plus subscription",
            "Premium configuration"
        ]
    },
    {
        "q": "Nginx Plus includes active health checks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is open source Nginx health checking?",
        "type": "mcq",
        "o": [
            "Passive health checks based on client request failures",
            "Active periodic checks",
            "Health check API",
            "Monitoring integration"
        ]
    },
    {
        "q": "Open source Nginx marks upstream as down after ______ failed requests.",
        "type": "fill_blank",
        "answers": [
            "max_fails"
        ],
        "other_options": [
            "1",
            "3",
            "timeout"
        ]
    },
    {
        "q": "What is slow_start in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Gradually increases traffic to recovering server",
            "Slow startup mode",
            "Delayed configuration",
            "Gradual boot"
        ]
    },
    {
        "q": "slow_start prevents overwhelming a recently recovered server.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is session persistence in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Advanced sticky session methods beyond ip_hash",
            "Session storage",
            "Session logging",
            "Persistent connections"
        ]
    },
    {
        "q": "sticky cookie inserts a cookie for session tracking.",
        "type": "fill_blank",
        "answers": [
            "True"
        ],
        "other_options": [
            "False",
            "Sometimes",
            "IP only"
        ]
    },
    {
        "q": "What is Nginx API in Plus?",
        "type": "mcq",
        "o": [
            "RESTful interface for dynamic configuration and monitoring",
            "Application programming",
            "API gateway only",
            "Development interface"
        ]
    },
    {
        "q": "Nginx Plus API allows dynamic upstream changes without reload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is key-value store in Nginx Plus?",
        "type": "mcq",
        "o": [
            "In-memory storage for dynamic variables",
            "Database storage",
            "File-based cache",
            "Configuration storage"
        ]
    },
    {
        "q": "Key-value stores can be clustered across Nginx Plus ______.",
        "type": "fill_blank",
        "answers": [
            "instances"
        ],
        "other_options": [
            "zones",
            "workers",
            "modules"
        ]
    },
    {
        "q": "What is debugging in Nginx?",
        "type": "mcq",
        "o": [
            "Configuring debug logging and error analysis",
            "Code debugging",
            "Module debugging",
            "Development mode"
        ]
    },
    {
        "q": "error_log with debug level requires Nginx compiled with --with-debug.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is debug_connection?",
        "type": "mcq",
        "o": [
            "Enables debug logging for specific client IPs",
            "Connection debugging mode",
            "Debug all connections",
            "Connection analysis"
        ]
    },
    {
        "q": "debug_connection limits debug logs to specific ______.",
        "type": "fill_blank",
        "answers": [
            "IP addresses"
        ],
        "other_options": [
            "ports",
            "domains",
            "paths"
        ]
    },
    {
        "q": "What is request_id variable?",
        "type": "mcq",
        "o": [
            "Unique identifier for request tracing",
            "Request number",
            "Session ID",
            "User ID"
        ]
    },
    {
        "q": "$request_id can be passed to backends for distributed tracing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is log_format directive?",
        "type": "mcq",
        "o": [
            "Defines custom log formats with variables",
            "Log file format",
            "Compression format",
            "Output format"
        ]
    },
    {
        "q": "Combined log format includes referer and ______ agent.",
        "type": "fill_blank",
        "answers": [
            "user"
        ],
        "other_options": [
            "server",
            "proxy",
            "cache"
        ]
    },
    {
        "q": "What is open_log_file_cache?",
        "type": "mcq",
        "o": [
            "Caches file descriptors for log files",
            "Opens log cache",
            "Cached log entries",
            "Log file buffer"
        ]
    },
    {
        "q": "open_log_file_cache improves performance with many log files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is if directive in Nginx?",
        "type": "mcq",
        "o": [
            "Conditional execution of directives (use with caution)",
            "Error handling",
            "Loop control",
            "Variable definition"
        ]
    },
    {
        "q": "The if directive in location context is considered ______.",
        "type": "fill_blank",
        "answers": [
            "evil or problematic"
        ],
        "other_options": [
            "best practice",
            "required",
            "efficient"
        ]
    },
    {
        "q": "What is set directive?",
        "type": "mcq",
        "o": [
            "Sets a variable to a value",
            "Configuration setting",
            "Environment setup",
            "Parameter definition"
        ]
    },
    {
        "q": "Variables set with set are available throughout the request processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is return vs rewrite?",
        "type": "mcq",
        "o": [
            "return is simpler and preferred for redirects; rewrite for complex patterns",
            "return is slower",
            "rewrite is deprecated",
            "No difference"
        ]
    },
    {
        "q": "return stops processing and sends response; rewrite continues ______.",
        "type": "fill_blank",
        "answers": [
            "processing"
        ],
        "other_options": [
            "logging",
            "proxying",
            "caching"
        ]
    },
    {
        "q": "What is internal location?",
        "type": "mcq",
        "o": [
            "Location only accessible through internal redirects",
            "Internal network only",
            "Private location",
            "Hidden path"
        ]
    },
    {
        "q": "The internal directive prevents external direct access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is named location?",
        "type": "mcq",
        "o": [
            "Location accessed by name rather than URI pattern",
            "Named virtual host",
            "Location alias",
            "Path naming"
        ]
    },
    {
        "q": "Named locations start with ______ symbol.",
        "type": "fill_blank",
        "answers": [
            "@"
        ],
        "other_options": [
            "#",
            "!",
            "&"
        ]
    },
    {
        "q": "What is error_page with named location?",
        "type": "mcq",
        "o": [
            "Routes errors to named location for processing",
            "Error naming",
            "Page errors",
            "Error templates"
        ]
    },
    {
        "q": "error_page 404 = @fallback; sends 404 errors to @fallback location.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is types directive?",
        "type": "mcq",
        "o": [
            "Maps file extensions to MIME types",
            "Variable types",
            "Configuration types",
            "Module types"
        ]
    },
    {
        "q": "include /etc/nginx/mime.types; loads standard MIME type ______.",
        "type": "fill_blank",
        "answers": [
            "mappings"
        ],
        "other_options": [
            "definitions",
            "rules",
            "schemas"
        ]
    },
    {
        "q": "What is default_type directive?",
        "type": "mcq",
        "o": [
            "MIME type for files without extension mapping",
            "Default configuration",
            "Primary type",
            "Base type"
        ]
    },
    {
        "q": "default_type application/octet-stream; uses binary MIME type as fallback.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is sendfile directive?",
        "type": "mcq",
        "o": [
            "Uses kernel sendfile() for efficient file transfer",
            "Send file path",
            "File sending mode",
            "Upload handling"
        ]
    },
    {
        "q": "sendfile on; is ______ for serving static files.",
        "type": "fill_blank",
        "answers": [
            "more efficient"
        ],
        "other_options": [
            "required",
            "slower",
            "identical"
        ]
    },
    {
        "q": "What is tcp_nopush?",
        "type": "mcq",
        "o": [
            "Sends response headers and beginning of file together",
            "Disables TCP push",
            "Network buffering",
            "Push notifications off"
        ]
    },
    {
        "q": "tcp_nopush works with sendfile for optimal performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is tcp_nodelay?",
        "type": "mcq",
        "o": [
            "Disables Nagle's algorithm for small packets",
            "TCP delay settings",
            "Network latency config",
            "Delay buffering"
        ]
    },
    {
        "q": "tcp_nodelay is useful for ______ connections.",
        "type": "fill_blank",
        "answers": [
            "keepalive"
        ],
        "other_options": [
            "short",
            "cached",
            "proxied"
        ]
    },
    {
        "q": "What is client_body_buffer_size?",
        "type": "mcq",
        "o": [
            "Buffer size for reading client request body",
            "Body size limit",
            "Maximum upload",
            "Request limit"
        ]
    },
    {
        "q": "client_max_body_size sets maximum allowed ______.",
        "type": "fill_blank",
        "answers": [
            "request body size"
        ],
        "other_options": [
            "header size",
            "response size",
            "file size"
        ]
    },
    {
        "q": "What is client_body_timeout?",
        "type": "mcq",
        "o": [
            "Timeout for reading client request body",
            "Response timeout",
            "Total request timeout",
            "Connection timeout"
        ]
    },
    {
        "q": "client_body_timeout is between successive read operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is keepalive_timeout?",
        "type": "mcq",
        "o": [
            "Time a keepalive connection stays open for additional requests",
            "Connection lifetime",
            "Request timeout",
            "Server uptime"
        ]
    },
    {
        "q": "keepalive_requests limits requests per keepalive ______.",
        "type": "fill_blank",
        "answers": [
            "connection"
        ],
        "other_options": [
            "worker",
            "server",
            "second"
        ]
    },
    {
        "q": "What is send_timeout?",
        "type": "mcq",
        "o": [
            "Timeout for transmitting response to client",
            "Request send timeout",
            "Proxy send timeout",
            "Total response time"
        ]
    },
    {
        "q": "send_timeout applies between successive write operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is reset_timedout_connection?",
        "type": "mcq",
        "o": [
            "Closes timed out connections with RST instead of FIN",
            "Resets all connections",
            "Connection retry",
            "Timeout reset"
        ]
    },
    {
        "q": "reset_timedout_connection frees socket resources ______.",
        "type": "fill_blank",
        "answers": [
            "immediately"
        ],
        "other_options": [
            "gradually",
            "on restart",
            "manually"
        ]
    },
    {
        "q": "Match timeout directives with their purposes:",
        "type": "match",
        "left": [
            "client_body_timeout",
            "send_timeout",
            "keepalive_timeout",
            "proxy_read_timeout"
        ],
        "right": [
            "Reading request body",
            "Sending response",
            "Keep connection open",
            "Waiting for upstream"
        ]
    },
    {
        "q": "Rearrange the buffer processing order:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Buffer in memory",
            "Proxy to upstream",
            "Buffer response",
            "Send to client"
        ]
    },
    {
        "q": "What is OpenResty?",
        "type": "mcq",
        "o": [
            "Nginx distribution bundled with LuaJIT and Lua modules",
            "REST API framework",
            "Open source REST",
            "API gateway"
        ]
    },
    {
        "q": "OpenResty enables writing Nginx modules in ______.",
        "type": "fill_blank",
        "answers": [
            "Lua"
        ],
        "other_options": [
            "Python",
            "JavaScript",
            "C"
        ]
    },
    {
        "q": "What is ngx_lua module?",
        "type": "mcq",
        "o": [
            "Embeds Lua scripting into Nginx",
            "Lua logging",
            "Language utility module",
            "Legacy upgrade module"
        ]
    },
    {
        "q": "content_by_lua_block executes Lua code to generate response.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is access_by_lua?",
        "type": "mcq",
        "o": [
            "Runs Lua during access phase for authentication/authorization",
            "Access logging in Lua",
            "Lua access control",
            "User access scripts"
        ]
    },
    {
        "q": "rewrite_by_lua runs during the ______ phase.",
        "type": "fill_blank",
        "answers": [
            "rewrite"
        ],
        "other_options": [
            "access",
            "content",
            "log"
        ]
    },
    {
        "q": "What is init_by_lua?",
        "type": "mcq",
        "o": [
            "Runs Lua code when Nginx starts or reloads",
            "Initial configuration",
            "Initialization logging",
            "Instance setup"
        ]
    },
    {
        "q": "init_worker_by_lua runs per worker process.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is lua_shared_dict?",
        "type": "mcq",
        "o": [
            "Shared memory dictionary accessible by all workers",
            "Lua dictionary type",
            "Shared configuration",
            "Dictionary logging"
        ]
    },
    {
        "q": "lua_shared_dict allows rate limiting across all ______.",
        "type": "fill_blank",
        "answers": [
            "worker processes"
        ],
        "other_options": [
            "servers",
            "locations",
            "requests"
        ]
    },
    {
        "q": "What is ngx.location.capture?",
        "type": "mcq",
        "o": [
            "Makes subrequests to other Nginx locations from Lua",
            "Request capture",
            "Location logging",
            "URL capture"
        ]
    },
    {
        "q": "ngx.location.capture enables composition of multiple backend calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is cosocket in ngx_lua?",
        "type": "mcq",
        "o": [
            "Non-blocking socket API for TCP/UDP in Lua",
            "Coroutine socket",
            "Connected socket",
            "Configuration socket"
        ]
    },
    {
        "q": "Cosockets allow non-blocking access to databases and external ______.",
        "type": "fill_blank",
        "answers": [
            "services"
        ],
        "other_options": [
            "files",
            "modules",
            "configurations"
        ]
    },
    {
        "q": "What is lua-resty-redis?",
        "type": "mcq",
        "o": [
            "Lua library for non-blocking Redis access",
            "Redis REST API",
            "Resty caching",
            "Redis logging"
        ]
    },
    {
        "q": "lua-resty-mysql provides non-blocking MySQL access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is lua-resty-http?",
        "type": "mcq",
        "o": [
            "HTTP client library for making requests from Lua",
            "HTTP server module",
            "Resty HTTP parsing",
            "HTTP logging"
        ]
    },
    {
        "q": "lua-resty-http supports ______ connections.",
        "type": "fill_blank",
        "answers": [
            "keepalive"
        ],
        "other_options": [
            "temporary",
            "cached",
            "proxied"
        ]
    },
    {
        "q": "What is body_filter_by_lua?",
        "type": "mcq",
        "o": [
            "Modifies response body chunks in Lua",
            "Body logging",
            "Request body filter",
            "Content filtering"
        ]
    },
    {
        "q": "header_filter_by_lua modifies response headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is log_by_lua?",
        "type": "mcq",
        "o": [
            "Runs Lua code during log phase for custom logging",
            "Lua logging library",
            "Log configuration",
            "Access logging"
        ]
    },
    {
        "q": "log_by_lua can send logs to external systems ______.",
        "type": "fill_blank",
        "answers": [
            "asynchronously"
        ],
        "other_options": [
            "synchronously",
            "immediately",
            "directly"
        ]
    },
    {
        "q": "What is balancer_by_lua?",
        "type": "mcq",
        "o": [
            "Implements custom load balancing logic in Lua",
            "Balance configuration",
            "Load logging",
            "Balancer statistics"
        ]
    },
    {
        "q": "balancer_by_lua enables dynamic upstream selection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_certificate_by_lua?",
        "type": "mcq",
        "o": [
            "Dynamically selects SSL certificates per request",
            "SSL logging",
            "Certificate validation",
            "Lua SSL client"
        ]
    },
    {
        "q": "ssl_certificate_by_lua enables SNI-based certificate ______.",
        "type": "fill_blank",
        "answers": [
            "selection"
        ],
        "other_options": [
            "validation",
            "generation",
            "logging"
        ]
    },
    {
        "q": "What is Nginx Unit?",
        "type": "mcq",
        "o": [
            "Dynamic application server supporting multiple languages",
            "Unit testing framework",
            "Nginx sizing",
            "Measurement module"
        ]
    },
    {
        "q": "Nginx Unit supports Python, PHP, Go, and Node.js applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Nginx Amplify?",
        "type": "mcq",
        "o": [
            "SaaS monitoring and analytics for Nginx",
            "Amplification attack prevention",
            "Signal booster",
            "Traffic amplifier"
        ]
    },
    {
        "q": "Amplify provides dashboards and ______ for Nginx performance.",
        "type": "fill_blank",
        "answers": [
            "alerts"
        ],
        "other_options": [
            "charts only",
            "logs",
            "reports"
        ]
    },
    {
        "q": "What is njs (Nginx JavaScript)?",
        "type": "mcq",
        "o": [
            "JavaScript scripting for Nginx configuration and request handling",
            "Node.js integration",
            "JSON processing",
            "JavaScript logging"
        ]
    },
    {
        "q": "njs is an alternative to Lua for extending Nginx.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is js_import directive?",
        "type": "mcq",
        "o": [
            "Imports JavaScript module for use in Nginx",
            "JavaScript include",
            "JSON import",
            "JS logging"
        ]
    },
    {
        "q": "js_content executes JavaScript to generate ______.",
        "type": "fill_blank",
        "answers": [
            "response content"
        ],
        "other_options": [
            "logs",
            "headers",
            "errors"
        ]
    },
    {
        "q": "What is Docker with Nginx?",
        "type": "mcq",
        "o": [
            "Running Nginx in containerized environments",
            "Docker logging",
            "Container networking",
            "Docker security"
        ]
    },
    {
        "q": "Official Nginx Docker images are available on Docker Hub.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Kubernetes Ingress with Nginx?",
        "type": "mcq",
        "o": [
            "Nginx-based ingress controller for Kubernetes",
            "Kubernetes logging",
            "Container proxy",
            "Pod networking"
        ]
    },
    {
        "q": "Nginx Ingress Controller routes external traffic to Kubernetes ______.",
        "type": "fill_blank",
        "answers": [
            "services"
        ],
        "other_options": [
            "pods",
            "nodes",
            "clusters"
        ]
    },
    {
        "q": "What is Ingress resource?",
        "type": "mcq",
        "o": [
            "Kubernetes API object defining routing rules for external traffic",
            "Import configuration",
            "Internal resource",
            "Infrastructure definition"
        ]
    },
    {
        "q": "Annotations customize Nginx Ingress behavior per Ingress resource.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is nginx.ingress.kubernetes.io/rewrite-target?",
        "type": "mcq",
        "o": [
            "Annotation for URL rewriting in Nginx Ingress",
            "Kubernetes rewrite",
            "Target configuration",
            "Rewrite logging"
        ]
    },
    {
        "q": "nginx.ingress.kubernetes.io/ssl-redirect forces HTTPS ______.",
        "type": "fill_blank",
        "answers": [
            "redirects"
        ],
        "other_options": [
            "connections",
            "responses",
            "requests"
        ]
    },
    {
        "q": "What is cert-manager with Nginx Ingress?",
        "type": "mcq",
        "o": [
            "Automates TLS certificate management in Kubernetes",
            "Certificate storage",
            "Manager logging",
            "Cert verification"
        ]
    },
    {
        "q": "cert-manager can automatically provision Let's Encrypt certificates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Nginx service mesh?",
        "type": "mcq",
        "o": [
            "Nginx-based service mesh for microservices communication",
            "Mesh networking",
            "Service discovery",
            "Mesh logging"
        ]
    },
    {
        "q": "Nginx Service Mesh uses sidecar ______ for traffic management.",
        "type": "fill_blank",
        "answers": [
            "proxies"
        ],
        "other_options": [
            "containers",
            "services",
            "pods"
        ]
    },
    {
        "q": "What is mTLS in service mesh?",
        "type": "mcq",
        "o": [
            "Mutual TLS where both client and server authenticate",
            "Multi-tenant TLS",
            "Management TLS",
            "Mesh TLS"
        ]
    },
    {
        "q": "mTLS encrypts all service-to-service communication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is NGINX App Protect?",
        "type": "mcq",
        "o": [
            "WAF solution integrated with Nginx",
            "Application monitoring",
            "Protection logging",
            "App security scanning"
        ]
    },
    {
        "q": "App Protect provides application-level ______ capabilities.",
        "type": "fill_blank",
        "answers": [
            "security"
        ],
        "other_options": [
            "logging",
            "caching",
            "routing"
        ]
    },
    {
        "q": "What is ModSecurity with Nginx?",
        "type": "mcq",
        "o": [
            "Open source WAF that can be integrated with Nginx",
            "Module security",
            "Modern security",
            "Modification security"
        ]
    },
    {
        "q": "ModSecurity uses OWASP Core Rule Set for protection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is rate limiting best practices?",
        "type": "mcq",
        "o": [
            "Use multiple zones for different rate limits per resource",
            "Single global limit",
            "Disable for performance",
            "Backend-only limiting"
        ]
    },
    {
        "q": "Rate limiting by $binary_remote_addr is more memory efficient than ______.",
        "type": "fill_blank",
        "answers": [
            "$remote_addr"
        ],
        "other_options": [
            "$host",
            "$uri",
            "$server_name"
        ]
    },
    {
        "q": "What is connection limiting for DDoS protection?",
        "type": "mcq",
        "o": [
            "Limiting concurrent connections per IP to prevent resource exhaustion",
            "Connection logging",
            "DDoS detection",
            "Connection pooling"
        ]
    },
    {
        "q": "limit_conn_status sets custom status code for rejected connections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is geo-blocking in Nginx?",
        "type": "mcq",
        "o": [
            "Blocking or allowing access based on geographic location",
            "Geographic logging",
            "Block-level caching",
            "Location blocking"
        ]
    },
    {
        "q": "GeoIP2 module supports modern ______ databases.",
        "type": "fill_blank",
        "answers": [
            "MaxMind"
        ],
        "other_options": [
            "MySQL",
            "Redis",
            "MongoDB"
        ]
    },
    {
        "q": "What is client certificate authentication?",
        "type": "mcq",
        "o": [
            "Verifying client identity using X.509 certificates",
            "Client password auth",
            "Certificate generation",
            "Auth logging"
        ]
    },
    {
        "q": "ssl_client_certificate specifies trusted CA for client certificates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_verify_client directive?",
        "type": "mcq",
        "o": [
            "Controls whether to verify client certificates",
            "Client SSL logging",
            "Verification mode",
            "SSL client info"
        ]
    },
    {
        "q": "ssl_verify_client optional allows but doesn't require client ______.",
        "type": "fill_blank",
        "answers": [
            "certificates"
        ],
        "other_options": [
            "authentication",
            "connection",
            "verification"
        ]
    },
    {
        "q": "What is $ssl_client_s_dn?",
        "type": "mcq",
        "o": [
            "Subject DN of client certificate",
            "Server DN",
            "SSL debug name",
            "Domain name"
        ]
    },
    {
        "q": "$ssl_client_verify contains the result of client certificate verification.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is HTTP Basic Authentication limitation?",
        "type": "mcq",
        "o": [
            "Credentials sent base64 encoded (not encrypted) in every request",
            "Too complex",
            "Slow performance",
            "No browser support"
        ]
    },
    {
        "q": "Basic auth should only be used over ______.",
        "type": "fill_blank",
        "answers": [
            "HTTPS"
        ],
        "other_options": [
            "HTTP",
            "TCP",
            "UDP"
        ]
    },
    {
        "q": "What is subrequest authentication?",
        "type": "mcq",
        "o": [
            "Delegating authentication to external service via auth_request",
            "Sub-user authentication",
            "Secondary auth",
            "Request logging"
        ]
    },
    {
        "q": "auth_request sends subrequest to verify user authentication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is auth_request_set?",
        "type": "mcq",
        "o": [
            "Sets variables based on auth subrequest response headers",
            "Auth configuration",
            "Request settings",
            "Auth logging"
        ]
    },
    {
        "q": "auth_request returns 401 or 403 to ______ access.",
        "type": "fill_blank",
        "answers": [
            "deny"
        ],
        "other_options": [
            "grant",
            "log",
            "redirect"
        ]
    },
    {
        "q": "What is JWT validation in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Validating JSON Web Tokens for authentication",
            "JWT generation",
            "Token logging",
            "JWT caching"
        ]
    },
    {
        "q": "auth_jwt validates tokens using configured key file.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is LDAP authentication with Nginx?",
        "type": "mcq",
        "o": [
            "Authenticating users against LDAP directory",
            "Lightweight auth",
            "Directory logging",
            "LDAP caching"
        ]
    },
    {
        "q": "LDAP authentication typically uses auth_request with external ______.",
        "type": "fill_blank",
        "answers": [
            "service"
        ],
        "other_options": [
            "module",
            "script",
            "database"
        ]
    },
    {
        "q": "What is fail2ban with Nginx?",
        "type": "mcq",
        "o": [
            "Intrusion prevention that bans IPs based on log patterns",
            "Failure logging",
            "Ban configuration",
            "Auto-blocking"
        ]
    },
    {
        "q": "fail2ban monitors Nginx access and error logs for suspicious activity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is security headers best practice?",
        "type": "mcq",
        "o": [
            "Adding headers like X-Frame-Options, CSP, X-Content-Type-Options",
            "Header encryption",
            "Security logging",
            "Header compression"
        ]
    },
    {
        "q": "X-Frame-Options DENY prevents ______ attacks.",
        "type": "fill_blank",
        "answers": [
            "clickjacking"
        ],
        "other_options": [
            "XSS",
            "CSRF",
            "SQL injection"
        ]
    },
    {
        "q": "What is Content-Security-Policy header?",
        "type": "mcq",
        "o": [
            "Defines allowed sources for content to prevent XSS",
            "Content type",
            "Security logging",
            "Policy configuration"
        ]
    },
    {
        "q": "CSP can prevent inline script execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Permissions-Policy header?",
        "type": "mcq",
        "o": [
            "Controls browser features like camera, microphone, geolocation",
            "User permissions",
            "Access control",
            "Policy logging"
        ]
    },
    {
        "q": "Permissions-Policy replaces the deprecated ______ header.",
        "type": "fill_blank",
        "answers": [
            "Feature-Policy"
        ],
        "other_options": [
            "X-Permissions",
            "Feature-Allow",
            "Allow-Features"
        ]
    },
    {
        "q": "What is high availability Nginx setup?",
        "type": "mcq",
        "o": [
            "Multiple Nginx instances with failover capability",
            "High performance mode",
            "Availability logging",
            "HA configuration"
        ]
    },
    {
        "q": "Keepalived provides virtual IP failover for Nginx HA.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is VRRP in Nginx HA?",
        "type": "mcq",
        "o": [
            "Virtual Router Redundancy Protocol for IP failover",
            "Virtual routing",
            "Redundancy logging",
            "VR configuration"
        ]
    },
    {
        "q": "VRRP allows multiple Nginx instances to share a ______.",
        "type": "fill_blank",
        "answers": [
            "virtual IP"
        ],
        "other_options": [
            "configuration",
            "cache",
            "worker"
        ]
    },
    {
        "q": "What is active-passive HA?",
        "type": "mcq",
        "o": [
            "One active node processes traffic while standby waits",
            "Both process traffic",
            "Round-robin processing",
            "Load balanced HA"
        ]
    },
    {
        "q": "Active-active HA has all nodes processing traffic simultaneously.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is configuration sync for HA?",
        "type": "mcq",
        "o": [
            "Keeping configuration consistent across all Nginx nodes",
            "Sync logging",
            "Configuration backup",
            "Sync monitoring"
        ]
    },
    {
        "q": "Configuration management tools like Ansible help sync Nginx ______.",
        "type": "fill_blank",
        "answers": [
            "configurations"
        ],
        "other_options": [
            "logs",
            "caches",
            "workers"
        ]
    },
    {
        "q": "What is shared cache for HA?",
        "type": "mcq",
        "o": [
            "Centralized cache accessible by multiple Nginx instances",
            "Worker cache sharing",
            "Cache logging",
            "Memory sharing"
        ]
    },
    {
        "q": "Redis or Memcached can serve as shared session store.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is zone sync in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Synchronizes shared memory zones across cluster nodes",
            "Time zone sync",
            "Zone logging",
            "Memory sync"
        ]
    },
    {
        "q": "zone_sync allows sharing rate limiting state across ______.",
        "type": "fill_blank",
        "answers": [
            "cluster"
        ],
        "other_options": [
            "workers",
            "locations",
            "servers"
        ]
    },
    {
        "q": "What is Nginx configuration automation?",
        "type": "mcq",
        "o": [
            "Using tools to generate and deploy configurations",
            "Auto-configuration",
            "Config logging",
            "Automation scripts"
        ]
    },
    {
        "q": "Terraform can provision Nginx configurations in cloud environments.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Nginx config templating?",
        "type": "mcq",
        "o": [
            "Generating configurations from templates with variables",
            "Template caching",
            "Config templates only",
            "Template logging"
        ]
    },
    {
        "q": "Tools like envsubst substitute environment variables in config ______.",
        "type": "fill_blank",
        "answers": [
            "templates"
        ],
        "other_options": [
            "files",
            "logs",
            "caches"
        ]
    },
    {
        "q": "What is Consul integration with Nginx?",
        "type": "mcq",
        "o": [
            "Service discovery and dynamic upstream configuration",
            "Consul logging",
            "Configuration storage",
            "Consul authentication"
        ]
    },
    {
        "q": "consul-template dynamically generates Nginx configurations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Prometheus monitoring for Nginx?",
        "type": "mcq",
        "o": [
            "Exposing Nginx metrics in Prometheus format",
            "Prometheus logging",
            "Metric configuration",
            "Prometheus caching"
        ]
    },
    {
        "q": "nginx-prometheus-exporter converts stub_status to Prometheus ______.",
        "type": "fill_blank",
        "answers": [
            "metrics"
        ],
        "other_options": [
            "logs",
            "alerts",
            "dashboards"
        ]
    },
    {
        "q": "What is Grafana with Nginx?",
        "type": "mcq",
        "o": [
            "Visualization dashboard for Nginx metrics",
            "Grafana logging",
            "Metric collection",
            "Grafana proxy"
        ]
    },
    {
        "q": "Grafana dashboards visualize request rates by status code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is structured logging in Nginx?",
        "type": "mcq",
        "o": [
            "JSON format logs for easy parsing and analysis",
            "Structured configuration",
            "Log compression",
            "Schema logging"
        ]
    },
    {
        "q": "JSON log format uses escape=______ parameter.",
        "type": "fill_blank",
        "answers": [
            "json"
        ],
        "other_options": [
            "none",
            "default",
            "text"
        ]
    },
    {
        "q": "What is ELK stack with Nginx?",
        "type": "mcq",
        "o": [
            "Elasticsearch, Logstash, Kibana for log analysis",
            "Error logging kit",
            "Extended logging",
            "Elastic logging"
        ]
    },
    {
        "q": "Filebeat can ship Nginx logs to Elasticsearch.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is syslog logging in Nginx?",
        "type": "mcq",
        "o": [
            "Sending logs to syslog daemon or remote server",
            "System logging only",
            "Syslog format",
            "Log synchronization"
        ]
    },
    {
        "q": "access_log syslog:server=127.0.0.1 sends logs to local ______.",
        "type": "fill_blank",
        "answers": [
            "syslog"
        ],
        "other_options": [
            "file",
            "stream",
            "socket"
        ]
    },
    {
        "q": "What is request tracing with Nginx?",
        "type": "mcq",
        "o": [
            "Following requests through distributed systems",
            "Request logging",
            "Trace configuration",
            "Debugging mode"
        ]
    },
    {
        "q": "OpenTelemetry can trace requests through Nginx.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is $upstream_response_time?",
        "type": "mcq",
        "o": [
            "Time taken by upstream server to respond",
            "Total request time",
            "Client response time",
            "Cache response time"
        ]
    },
    {
        "q": "$request_time measures total time from first byte received to ______.",
        "type": "fill_blank",
        "answers": [
            "last byte sent"
        ],
        "other_options": [
            "connection close",
            "first response",
            "proxy pass"
        ]
    },
    {
        "q": "What is $upstream_connect_time?",
        "type": "mcq",
        "o": [
            "Time to establish connection with upstream server",
            "Connection duration",
            "Total connect time",
            "Client connect time"
        ]
    },
    {
        "q": "$upstream_header_time measures time to receive response headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is $connection variable?",
        "type": "mcq",
        "o": [
            "Unique connection serial number",
            "Connection type",
            "Connection status",
            "Connection duration"
        ]
    },
    {
        "q": "$connection_requests shows number of requests made through ______.",
        "type": "fill_blank",
        "answers": [
            "current connection"
        ],
        "other_options": [
            "all workers",
            "all time",
            "per second"
        ]
    },
    {
        "q": "What is $pid variable?",
        "type": "mcq",
        "o": [
            "Process ID of worker process",
            "Parent ID",
            "Port ID",
            "Protocol ID"
        ]
    },
    {
        "q": "$msec provides current time in seconds with millisecond resolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is mirror module?",
        "type": "mcq",
        "o": [
            "Creates background mirror copies of requests to another location",
            "Response mirroring",
            "Cache mirroring",
            "Config mirroring"
        ]
    },
    {
        "q": "mirror directive is useful for traffic ______.",
        "type": "fill_blank",
        "answers": [
            "shadowing or testing"
        ],
        "other_options": [
            "logging",
            "caching",
            "compressing"
        ]
    },
    {
        "q": "What is graceful shutdown?",
        "type": "mcq",
        "o": [
            "Completing existing requests before stopping",
            "Immediate shutdown",
            "Shutdown logging",
            "Safe configuration"
        ]
    },
    {
        "q": "nginx -s quit performs graceful shutdown.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is binary upgrade?",
        "type": "mcq",
        "o": [
            "Upgrading Nginx without dropping connections",
            "Binary logging",
            "Upgrade configuration",
            "Version switching"
        ]
    },
    {
        "q": "kill -USR2 triggers binary upgrade to new Nginx ______.",
        "type": "fill_blank",
        "answers": [
            "executable"
        ],
        "other_options": [
            "configuration",
            "workers",
            "cache"
        ]
    },
    {
        "q": "What is worker_shutdown_timeout?",
        "type": "mcq",
        "o": [
            "Maximum time for worker to handle remaining requests",
            "Shutdown delay",
            "Worker timeout",
            "Graceful period"
        ]
    },
    {
        "q": "worker_shutdown_timeout ensures workers don't hang indefinitely.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is worker_cpu_affinity?",
        "type": "mcq",
        "o": [
            "Binds worker processes to specific CPU cores",
            "CPU priority",
            "Affinity logging",
            "CPU allocation"
        ]
    },
    {
        "q": "worker_cpu_affinity auto automatically binds workers to ______.",
        "type": "fill_blank",
        "answers": [
            "available CPUs"
        ],
        "other_options": [
            "first CPU",
            "last CPU",
            "random CPUs"
        ]
    },
    {
        "q": "What is worker_priority?",
        "type": "mcq",
        "o": [
            "Sets nice value for worker processes",
            "Priority logging",
            "Worker ordering",
            "Process priority only"
        ]
    },
    {
        "q": "Lower nice values give workers higher scheduling priority.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is worker_rlimit_nofile?",
        "type": "mcq",
        "o": [
            "Maximum number of open files per worker process",
            "File limit configuration",
            "No file limit",
            "Resource logging"
        ]
    },
    {
        "q": "worker_rlimit_nofile should be higher than ______.",
        "type": "fill_blank",
        "answers": [
            "worker_connections"
        ],
        "other_options": [
            "worker_processes",
            "events",
            "connections"
        ]
    },
    {
        "q": "What is accept_mutex?",
        "type": "mcq",
        "o": [
            "Controls whether workers accept connections one at a time",
            "Mutex logging",
            "Accept configuration",
            "Connection mutex"
        ]
    },
    {
        "q": "accept_mutex off allows multiple workers to accept connections simultaneously.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is accept_mutex_delay?",
        "type": "mcq",
        "o": [
            "Time worker waits before trying to accept new connections",
            "Delay configuration",
            "Mutex timeout",
            "Accept delay only"
        ]
    },
    {
        "q": "Default accept_mutex_delay is ______ milliseconds.",
        "type": "fill_blank",
        "answers": [
            "500"
        ],
        "other_options": [
            "100",
            "1000",
            "250"
        ]
    },
    {
        "q": "What is aio directive?",
        "type": "mcq",
        "o": [
            "Enables asynchronous I/O for file serving",
            "Async input only",
            "IO configuration",
            "Async logging"
        ]
    },
    {
        "q": "aio threads uses thread pool for asynchronous file operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is directio directive?",
        "type": "mcq",
        "o": [
            "Enables direct I/O bypassing OS cache for large files",
            "Directory IO",
            "Direct configuration",
            "IO logging"
        ]
    },
    {
        "q": "directio is useful for serving files larger than ______.",
        "type": "fill_blank",
        "answers": [
            "sendfile buffer"
        ],
        "other_options": [
            "1MB",
            "100KB",
            "10MB"
        ]
    },
    {
        "q": "What is open_file_cache?",
        "type": "mcq",
        "o": [
            "Caches file descriptors and metadata for static files",
            "Open files only",
            "Cache configuration",
            "File logging"
        ]
    },
    {
        "q": "open_file_cache reduces disk I/O for frequently accessed files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is output_buffers?",
        "type": "mcq",
        "o": [
            "Buffers for reading responses from disk",
            "Output logging",
            "Buffer configuration",
            "Response buffers only"
        ]
    },
    {
        "q": "Larger output_buffers can improve performance for ______ files.",
        "type": "fill_blank",
        "answers": [
            "large"
        ],
        "other_options": [
            "small",
            "cached",
            "compressed"
        ]
    },
    {
        "q": "Match Nginx performance directives with their functions:",
        "type": "match",
        "left": [
            "sendfile",
            "tcp_nopush",
            "aio",
            "open_file_cache"
        ],
        "right": [
            "Kernel file transfer",
            "Combine headers with data",
            "Async disk I/O",
            "Cache file descriptors"
        ]
    },
    {
        "q": "Rearrange the SSL handshake optimization order:",
        "type": "rearrange",
        "words": [
            "Enable ssl_session_cache",
            "Configure ssl_session_tickets",
            "Enable ssl_stapling",
            "Optimize ssl_buffer_size"
        ]
    },
    {
        "q": "Match Nginx HA technologies with their purposes:",
        "type": "match",
        "left": [
            "Keepalived",
            "zone_sync",
            "Redis",
            "Ansible"
        ],
        "right": [
            "Virtual IP failover",
            "Shared memory sync",
            "Session store",
            "Config management"
        ]
    },
    {
        "q": "Rearrange Nginx troubleshooting steps:",
        "type": "rearrange",
        "words": [
            "Check error logs",
            "Verify configuration syntax",
            "Test with curl",
            "Check upstream health",
            "Review access logs"
        ]
    },
    {
        "q": "What is HTTP/3 support in Nginx?",
        "type": "mcq",
        "o": [
            "QUIC-based protocol with reduced latency",
            "HTTP version 3 logging",
            "Third party HTTP module",
            "Enhanced HTTP/2"
        ]
    },
    {
        "q": "HTTP/3 uses ______ transport protocol instead of TCP.",
        "type": "fill_blank",
        "answers": [
            "QUIC"
        ],
        "other_options": [
            "UDP",
            "SCTP",
            "WebSocket"
        ]
    },
    {
        "q": "What is listen quic directive?",
        "type": "mcq",
        "o": [
            "Enables QUIC/HTTP/3 on specified port",
            "Quick listen mode",
            "Fast connection handling",
            "Queue-based listening"
        ]
    },
    {
        "q": "HTTP/3 requires the quic_retry directive for DDoS mitigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is Alt-Svc header for HTTP/3?",
        "type": "mcq",
        "o": [
            "Advertises HTTP/3 availability to browsers",
            "Alternative service location",
            "Service versioning",
            "Alt text for services"
        ]
    },
    {
        "q": "add_header Alt-Svc 'h3=\":443\"; ma=86400' advertises HTTP/3 on port ______.",
        "type": "fill_blank",
        "answers": [
            "443"
        ],
        "other_options": [
            "80",
            "8080",
            "8443"
        ]
    },
    {
        "q": "What is micro-caching?",
        "type": "mcq",
        "o": [
            "Caching responses for very short durations like 1 second",
            "Caching small files",
            "Microservice caching",
            "Memory micro-allocation"
        ]
    },
    {
        "q": "Micro-caching helps with high-traffic sites serving dynamic content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is cache lock for micro-caching?",
        "type": "mcq",
        "o": [
            "Prevents cache stampede by queuing identical requests",
            "File locking",
            "Exclusive cache access",
            "Lock timeout"
        ]
    },
    {
        "q": "proxy_cache_lock_timeout sets maximum wait time in ______.",
        "type": "fill_blank",
        "answers": [
            "queue"
        ],
        "other_options": [
            "cache",
            "memory",
            "disk"
        ]
    },
    {
        "q": "What is stale-while-revalidate?",
        "type": "mcq",
        "o": [
            "Serves stale content while fetching fresh content in background",
            "Stale cache cleanup",
            "Revalidation logging",
            "Cache refresh mode"
        ]
    },
    {
        "q": "proxy_cache_background_update enables stale-while-revalidate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is edge computing with Nginx?",
        "type": "mcq",
        "o": [
            "Running Nginx at edge locations close to users",
            "Edge case handling",
            "Border routing",
            "Network edge"
        ]
    },
    {
        "q": "Edge caching reduces latency by serving content from ______ locations.",
        "type": "fill_blank",
        "answers": [
            "geographically closer"
        ],
        "other_options": [
            "central",
            "primary",
            "backup"
        ]
    },
    {
        "q": "What is ESI (Edge Side Includes)?",
        "type": "mcq",
        "o": [
            "Assembling pages from cached fragments at edge",
            "External service integration",
            "Edge script injection",
            "Include files at edge"
        ]
    },
    {
        "q": "ssi module provides server-side includes functionality.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is fragment caching?",
        "type": "mcq",
        "o": [
            "Caching parts of pages with different TTLs",
            "Broken file caching",
            "Partial downloads",
            "Memory fragmentation"
        ]
    },
    {
        "q": "Fragment caching improves performance for pages with mixed static and ______ content.",
        "type": "fill_blank",
        "answers": [
            "dynamic"
        ],
        "other_options": [
            "cached",
            "compressed",
            "encrypted"
        ]
    },
    {
        "q": "What is slice module?",
        "type": "mcq",
        "o": [
            "Enables range request caching by splitting files into slices",
            "Slice logging",
            "File slicing",
            "Request splitting"
        ]
    },
    {
        "q": "slice module is useful for caching large files like videos.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_cache_revalidate?",
        "type": "mcq",
        "o": [
            "Revalidates expired cache using If-Modified-Since",
            "Cache validation",
            "Revalidation logging",
            "Force refresh"
        ]
    },
    {
        "q": "proxy_cache_revalidate reduces bandwidth by using conditional ______.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "headers",
            "caching",
            "responses"
        ]
    },
    {
        "q": "What is proxy_cache_min_uses?",
        "type": "mcq",
        "o": [
            "Number of requests before response is cached",
            "Minimum cache usage",
            "Cache threshold",
            "Use count logging"
        ]
    },
    {
        "q": "proxy_cache_min_uses 2 caches responses only after second request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_cache_convert_head?",
        "type": "mcq",
        "o": [
            "Converts HEAD requests to GET for caching purposes",
            "Header conversion",
            "Head request handling",
            "Convert logging"
        ]
    },
    {
        "q": "proxy_cache_convert_head off keeps HEAD requests as ______.",
        "type": "fill_blank",
        "answers": [
            "HEAD"
        ],
        "other_options": [
            "GET",
            "POST",
            "OPTIONS"
        ]
    },
    {
        "q": "What is proxy_cache_methods?",
        "type": "mcq",
        "o": [
            "Specifies which HTTP methods can be cached",
            "Method logging",
            "Cache method selection",
            "Request methods"
        ]
    },
    {
        "q": "By default only GET and HEAD requests are cached.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is $upstream_cache_status?",
        "type": "mcq",
        "o": [
            "Variable indicating cache hit, miss, or bypass",
            "Cache status logging",
            "Upstream status",
            "Cache health"
        ]
    },
    {
        "q": "$upstream_cache_status values include HIT, MISS, and ______.",
        "type": "fill_blank",
        "answers": [
            "BYPASS"
        ],
        "other_options": [
            "SKIP",
            "NONE",
            "FAIL"
        ]
    },
    {
        "q": "What is STALE cache status?",
        "type": "mcq",
        "o": [
            "Expired cache entry was served",
            "Invalid cache",
            "Old cache deleted",
            "Cache timeout"
        ]
    },
    {
        "q": "UPDATING status means fresh content is being fetched while serving stale.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is REVALIDATED cache status?",
        "type": "mcq",
        "o": [
            "Cache was confirmed still valid using conditional request",
            "Revalidation failed",
            "Cache refresh",
            "Validation logging"
        ]
    },
    {
        "q": "EXPIRED status means cache entry passed its ______ time.",
        "type": "fill_blank",
        "answers": [
            "valid"
        ],
        "other_options": [
            "creation",
            "modification",
            "access"
        ]
    },
    {
        "q": "What is split DNS?",
        "type": "mcq",
        "o": [
            "Different DNS responses for internal vs external clients",
            "DNS splitting",
            "Domain separation",
            "Split resolver"
        ]
    },
    {
        "q": "Internal clients might resolve to private IPs while external get public.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is canary deployment with Nginx?",
        "type": "mcq",
        "o": [
            "Gradually rolling out changes to subset of users",
            "Canary logging",
            "Bird-based routing",
            "Yellow deployment"
        ]
    },
    {
        "q": "split_clients can route percentage of traffic for ______ testing.",
        "type": "fill_blank",
        "answers": [
            "canary"
        ],
        "other_options": [
            "load",
            "stress",
            "security"
        ]
    },
    {
        "q": "What is blue-green deployment with Nginx?",
        "type": "mcq",
        "o": [
            "Switching traffic between two identical environments",
            "Color-based routing",
            "Environment coloring",
            "Blue-green logging"
        ]
    },
    {
        "q": "Blue-green enables instant rollback by switching upstream groups.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is feature flags with Nginx?",
        "type": "mcq",
        "o": [
            "Routing based on feature toggles in headers or cookies",
            "Flag configuration",
            "Feature logging",
            "Toggle switches"
        ]
    },
    {
        "q": "map directive can route based on cookie containing feature ______.",
        "type": "fill_blank",
        "answers": [
            "flag"
        ],
        "other_options": [
            "value",
            "name",
            "setting"
        ]
    },
    {
        "q": "What is request coalescing?",
        "type": "mcq",
        "o": [
            "Combining identical concurrent requests into single backend request",
            "Request merging",
            "Coalescing logging",
            "Request joining"
        ]
    },
    {
        "q": "proxy_cache_lock helps implement request coalescing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is connection pooling with upstream?",
        "type": "mcq",
        "o": [
            "Reusing connections to backend servers",
            "Pool configuration",
            "Connection logging",
            "Pool management"
        ]
    },
    {
        "q": "keepalive directive in upstream sets maximum ______ connections.",
        "type": "fill_blank",
        "answers": [
            "idle"
        ],
        "other_options": [
            "active",
            "total",
            "new"
        ]
    },
    {
        "q": "What is keepalive_requests in upstream?",
        "type": "mcq",
        "o": [
            "Maximum requests per keepalive connection to upstream",
            "Request counting",
            "Keepalive logging",
            "Request limits"
        ]
    },
    {
        "q": "keepalive_timeout in upstream sets idle connection timeout.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is resolver valid directive?",
        "type": "mcq",
        "o": [
            "Overrides TTL for DNS resolution caching",
            "Validation period",
            "Resolver logging",
            "Valid DNS"
        ]
    },
    {
        "q": "resolver 8.8.8.8 valid=30s; caches DNS for ______ seconds.",
        "type": "fill_blank",
        "answers": [
            "30"
        ],
        "other_options": [
            "60",
            "300",
            "3600"
        ]
    },
    {
        "q": "What is ipv6=off in resolver?",
        "type": "mcq",
        "o": [
            "Disables IPv6 address resolution",
            "IPv6 logging",
            "Disable IPv6 traffic",
            "IPv6 blocking"
        ]
    },
    {
        "q": "resolver with multiple addresses provides DNS failover.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_ssl_verify?",
        "type": "mcq",
        "o": [
            "Verifies SSL certificate of upstream server",
            "SSL logging",
            "Verify proxy",
            "SSL validation"
        ]
    },
    {
        "q": "proxy_ssl_trusted_certificate specifies CA for upstream ______.",
        "type": "fill_blank",
        "answers": [
            "verification"
        ],
        "other_options": [
            "encryption",
            "validation",
            "authentication"
        ]
    },
    {
        "q": "What is proxy_ssl_name?",
        "type": "mcq",
        "o": [
            "Sets server name for SNI when connecting to upstream",
            "SSL naming",
            "Name logging",
            "SSL server"
        ]
    },
    {
        "q": "proxy_ssl_server_name on enables SNI for upstream connections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is grpc_pass directive?",
        "type": "mcq",
        "o": [
            "Proxies gRPC requests to backend",
            "Graph passing",
            "RPC logging",
            "gRPC configuration"
        ]
    },
    {
        "q": "gRPC requires HTTP/2 which is enabled with ______ directive.",
        "type": "fill_blank",
        "answers": [
            "http2"
        ],
        "other_options": [
            "grpc",
            "h2",
            "http2c"
        ]
    },
    {
        "q": "What is grpc_set_header?",
        "type": "mcq",
        "o": [
            "Sets headers for gRPC upstream requests",
            "gRPC logging",
            "Header configuration",
            "gRPC metadata"
        ]
    },
    {
        "q": "gRPC trailers are supported in Nginx for extended metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is health_check directive in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Configures active health checks for upstream servers",
            "Health logging",
            "Check configuration",
            "Health monitoring"
        ]
    },
    {
        "q": "health_check interval=5s runs checks every ______ seconds.",
        "type": "fill_blank",
        "answers": [
            "5"
        ],
        "other_options": [
            "10",
            "30",
            "60"
        ]
    },
    {
        "q": "What is match directive for health checks?",
        "type": "mcq",
        "o": [
            "Defines conditions for successful health check",
            "Match logging",
            "Pattern matching",
            "Match configuration"
        ]
    },
    {
        "q": "match conditions can check status code, headers, and body.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is mandatory parameter in health_check?",
        "type": "mcq",
        "o": [
            "Requires health check to pass before serving traffic",
            "Mandatory logging",
            "Required checks",
            "Check requirement"
        ]
    },
    {
        "q": "mandatory persistent keeps servers starting as down until ______.",
        "type": "fill_blank",
        "answers": [
            "health check passes"
        ],
        "other_options": [
            "timeout",
            "restart",
            "configuration reload"
        ]
    },
    {
        "q": "What is queue directive in upstream?",
        "type": "mcq",
        "o": [
            "Queues requests when all servers are unavailable (Nginx Plus)",
            "Queue logging",
            "Request queue",
            "Queue configuration"
        ]
    },
    {
        "q": "queue directive prevents immediate 502 errors during server unavailability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is least_time in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Load balancing based on response time and active connections",
            "Minimum time",
            "Time logging",
            "Fast routing"
        ]
    },
    {
        "q": "least_time header bases selection on header response ______.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "size",
            "count",
            "type"
        ]
    },
    {
        "q": "What is random load balancing?",
        "type": "mcq",
        "o": [
            "Randomly selects upstream server for each request",
            "Random logging",
            "Random configuration",
            "Randomized routing"
        ]
    },
    {
        "q": "random two least_conn selects best from two random servers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is hash consistent?",
        "type": "mcq",
        "o": [
            "Minimizes redistribution when servers change",
            "Hash logging",
            "Consistent configuration",
            "Hash verification"
        ]
    },
    {
        "q": "hash $request_uri consistent uses consistent ______ algorithm.",
        "type": "fill_blank",
        "answers": [
            "hashing"
        ],
        "other_options": [
            "routing",
            "caching",
            "matching"
        ]
    },
    {
        "q": "What is sticky learn in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Learns session affinity from upstream response",
            "Learning mode",
            "Sticky logging",
            "Learn configuration"
        ]
    },
    {
        "q": "sticky learn creates session persistence from backend cookies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is sticky route?",
        "type": "mcq",
        "o": [
            "Routes requests based on route variable in request",
            "Route logging",
            "Route configuration",
            "Sticky configuration"
        ]
    },
    {
        "q": "sticky route allows session affinity based on ______ parameters.",
        "type": "fill_blank",
        "answers": [
            "request"
        ],
        "other_options": [
            "server",
            "upstream",
            "cache"
        ]
    },
    {
        "q": "What is NTLM support in Nginx Plus?",
        "type": "mcq",
        "o": [
            "Maintains connection for NTLM authentication handshake",
            "NT logging",
            "LM configuration",
            "NTLM encryption"
        ]
    },
    {
        "q": "ntlm directive keeps connection open for authentication sequence.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is service environment variable?",
        "type": "mcq",
        "o": [
            "Resolves service name in upstream using DNS SRV records",
            "Service logging",
            "Environment configuration",
            "Service discovery"
        ]
    },
    {
        "q": "server backend service=http resolve; uses SRV record ______.",
        "type": "fill_blank",
        "answers": [
            "resolution"
        ],
        "other_options": [
            "caching",
            "routing",
            "balancing"
        ]
    },
    {
        "q": "What is resolve parameter in upstream?",
        "type": "mcq",
        "o": [
            "Monitors DNS changes and updates upstream dynamically",
            "Resolve logging",
            "Resolution configuration",
            "DNS resolve"
        ]
    },
    {
        "q": "resolve parameter requires resolver directive for DNS lookups.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is state file in upstream?",
        "type": "mcq",
        "o": [
            "Persists dynamic upstream configuration across reloads",
            "State logging",
            "File configuration",
            "State storage"
        ]
    },
    {
        "q": "state /var/lib/nginx/state/upstreams.conf persists upstream ______.",
        "type": "fill_blank",
        "answers": [
            "modifications"
        ],
        "other_options": [
            "logs",
            "caches",
            "connections"
        ]
    },
    {
        "q": "What is zone directive in upstream?",
        "type": "mcq",
        "o": [
            "Defines shared memory zone for upstream state",
            "Zone logging",
            "Memory zone",
            "Zone configuration"
        ]
    },
    {
        "q": "Shared zones allow all workers to access upstream state.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is drain parameter?",
        "type": "mcq",
        "o": [
            "Stops sending new sessions while completing existing ones",
            "Drain logging",
            "Connection drain",
            "Drain configuration"
        ]
    },
    {
        "q": "drain allows graceful removal of server from ______.",
        "type": "fill_blank",
        "answers": [
            "rotation"
        ],
        "other_options": [
            "configuration",
            "memory",
            "cache"
        ]
    },
    {
        "q": "What is error_page with proxy_intercept_errors?",
        "type": "mcq",
        "o": [
            "Customizes error pages for backend errors",
            "Error logging",
            "Page interception",
            "Error configuration"
        ]
    },
    {
        "q": "proxy_intercept_errors on; enables custom error page handling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is post_action directive?",
        "type": "mcq",
        "o": [
            "Triggers subrequest after main request completes",
            "Post logging",
            "Action configuration",
            "Post processing"
        ]
    },
    {
        "q": "post_action can send analytics to tracking ______.",
        "type": "fill_blank",
        "answers": [
            "service"
        ],
        "other_options": [
            "log",
            "cache",
            "file"
        ]
    },
    {
        "q": "What is limit_except directive?",
        "type": "mcq",
        "o": [
            "Restricts access based on HTTP method",
            "Exception logging",
            "Limit configuration",
            "Method exception"
        ]
    },
    {
        "q": "limit_except GET POST { deny all; } blocks non-GET/POST methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is satisfy directive?",
        "type": "mcq",
        "o": [
            "Controls whether all or any access restrictions apply",
            "Satisfy logging",
            "Access configuration",
            "Satisfy requirement"
        ]
    },
    {
        "q": "satisfy any grants access if ______ restriction passes.",
        "type": "fill_blank",
        "answers": [
            "any"
        ],
        "other_options": [
            "all",
            "none",
            "first"
        ]
    },
    {
        "q": "What is internal redirect loop protection?",
        "type": "mcq",
        "o": [
            "Nginx limits internal redirects to prevent infinite loops",
            "Loop logging",
            "Redirect configuration",
            "Protection mode"
        ]
    },
    {
        "q": "Default internal redirect limit is 10 iterations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is subrequest depth limit?",
        "type": "mcq",
        "o": [
            "Maximum nested subrequests to prevent recursion",
            "Depth logging",
            "Subrequest configuration",
            "Depth control"
        ]
    },
    {
        "q": "Subrequest depth limit prevents memory exhaustion from ______.",
        "type": "fill_blank",
        "answers": [
            "recursion"
        ],
        "other_options": [
            "caching",
            "routing",
            "logging"
        ]
    },
    {
        "q": "What is lingering_close?",
        "type": "mcq",
        "o": [
            "Controls how to close connections with remaining data",
            "Close logging",
            "Lingering configuration",
            "Connection cleanup"
        ]
    },
    {
        "q": "lingering_close on reads remaining data before closing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is postpone_output?",
        "type": "mcq",
        "o": [
            "Delays sending response until minimum bytes available",
            "Output delay",
            "Postpone logging",
            "Output configuration"
        ]
    },
    {
        "q": "postpone_output 1460 waits for ______ bytes before sending.",
        "type": "fill_blank",
        "answers": [
            "1460"
        ],
        "other_options": [
            "0",
            "512",
            "4096"
        ]
    },
    {
        "q": "What is chunked_transfer_encoding?",
        "type": "mcq",
        "o": [
            "Enables HTTP chunked encoding for responses",
            "Chunked logging",
            "Transfer configuration",
            "Encoding mode"
        ]
    },
    {
        "q": "Chunked encoding allows streaming responses without Content-Length.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is msie_padding?",
        "type": "mcq",
        "o": [
            "Adds padding to error responses for old IE compatibility",
            "MSIE logging",
            "Padding configuration",
            "IE compatibility"
        ]
    },
    {
        "q": "msie_padding ensures error pages exceed ______ bytes for IE.",
        "type": "fill_blank",
        "answers": [
            "512"
        ],
        "other_options": [
            "256",
            "1024",
            "2048"
        ]
    },
    {
        "q": "What is port_in_redirect?",
        "type": "mcq",
        "o": [
            "Controls whether port appears in redirect URLs",
            "Port logging",
            "Redirect configuration",
            "Port control"
        ]
    },
    {
        "q": "port_in_redirect off hides port in redirects on standard ports.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is server_name_in_redirect?",
        "type": "mcq",
        "o": [
            "Uses server_name instead of Host header in redirects",
            "Name logging",
            "Redirect configuration",
            "Server naming"
        ]
    },
    {
        "q": "server_name_in_redirect on uses primary ______ in redirects.",
        "type": "fill_blank",
        "answers": [
            "server_name"
        ],
        "other_options": [
            "host",
            "domain",
            "address"
        ]
    },
    {
        "q": "What is absolute_redirect?",
        "type": "mcq",
        "o": [
            "Controls whether redirects use absolute or relative URLs",
            "Absolute logging",
            "Redirect configuration",
            "URL mode"
        ]
    },
    {
        "q": "absolute_redirect off sends relative redirects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is merge_slashes?",
        "type": "mcq",
        "o": [
            "Merges consecutive slashes in URI",
            "Slash logging",
            "URI configuration",
            "Slash control"
        ]
    },
    {
        "q": "merge_slashes on treats //path and /path as ______.",
        "type": "fill_blank",
        "answers": [
            "equivalent"
        ],
        "other_options": [
            "different",
            "invalid",
            "cached"
        ]
    },
    {
        "q": "What is underscores_in_headers?",
        "type": "mcq",
        "o": [
            "Allows headers with underscores instead of hyphens",
            "Header logging",
            "Underscore configuration",
            "Header control"
        ]
    },
    {
        "q": "By default, headers with underscores are ignored for security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ignore_invalid_headers?",
        "type": "mcq",
        "o": [
            "Silently drops malformed request headers",
            "Invalid logging",
            "Header configuration",
            "Error handling"
        ]
    },
    {
        "q": "ignore_invalid_headers on prevents errors from malformed ______.",
        "type": "fill_blank",
        "answers": [
            "headers"
        ],
        "other_options": [
            "requests",
            "responses",
            "URLs"
        ]
    },
    {
        "q": "What is large_client_header_buffers?",
        "type": "mcq",
        "o": [
            "Configures buffers for large request headers",
            "Large logging",
            "Buffer configuration",
            "Header storage"
        ]
    },
    {
        "q": "large_client_header_buffers handles headers larger than default buffer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is connection_pool_size?",
        "type": "mcq",
        "o": [
            "Memory allocation granularity for connections",
            "Pool logging",
            "Connection configuration",
            "Pool management"
        ]
    },
    {
        "q": "connection_pool_size affects ______ allocation efficiency.",
        "type": "fill_blank",
        "answers": [
            "memory"
        ],
        "other_options": [
            "connection",
            "request",
            "response"
        ]
    },
    {
        "q": "What is request_pool_size?",
        "type": "mcq",
        "o": [
            "Memory pool size for request processing",
            "Request logging",
            "Pool configuration",
            "Request management"
        ]
    },
    {
        "q": "Smaller pool sizes may increase memory allocations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is variables_hash_max_size?",
        "type": "mcq",
        "o": [
            "Maximum size of variables hash table",
            "Variable logging",
            "Hash configuration",
            "Size control"
        ]
    },
    {
        "q": "Increase variables_hash_max_size when there are many ______.",
        "type": "fill_blank",
        "answers": [
            "variables"
        ],
        "other_options": [
            "servers",
            "locations",
            "upstreams"
        ]
    },
    {
        "q": "What is server_names_hash_max_size?",
        "type": "mcq",
        "o": [
            "Maximum size of server names hash table",
            "Server logging",
            "Hash configuration",
            "Name storage"
        ]
    },
    {
        "q": "Increase for configurations with many virtual servers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is types_hash_max_size?",
        "type": "mcq",
        "o": [
            "Maximum size of MIME types hash table",
            "Type logging",
            "Hash configuration",
            "Type storage"
        ]
    },
    {
        "q": "types_hash_bucket_size affects hash table ______.",
        "type": "fill_blank",
        "answers": [
            "bucket size"
        ],
        "other_options": [
            "total size",
            "entry count",
            "memory"
        ]
    },
    {
        "q": "What is multi_accept directive?",
        "type": "mcq",
        "o": [
            "Worker accepts all pending connections at once",
            "Multiple accept",
            "Accept configuration",
            "Connection handling"
        ]
    },
    {
        "q": "multi_accept on can improve performance under high load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match configuration optimization techniques:",
        "type": "match",
        "left": [
            "worker_processes auto",
            "multi_accept on",
            "sendfile on",
            "tcp_nodelay on"
        ],
        "right": [
            "Match CPU cores",
            "Accept multiple connections",
            "Kernel file transfer",
            "Disable Nagle"
        ]
    },
    {
        "q": "Rearrange SSL optimization priority:",
        "type": "rearrange",
        "words": [
            "Use TLS 1.3",
            "Enable session resumption",
            "Enable OCSP stapling",
            "Tune buffer size"
        ]
    },
    {
        "q": "Match cache status values with meanings:",
        "type": "match",
        "left": [
            "HIT",
            "MISS",
            "BYPASS",
            "STALE"
        ],
        "right": [
            "Served from cache",
            "Fetched from upstream",
            "Skipped cache",
            "Served expired entry"
        ]
    },
    {
        "q": "Rearrange request lifecycle phases:",
        "type": "rearrange",
        "words": [
            "Accept connection",
            "Parse request",
            "Rewrite phase",
            "Access phase",
            "Content phase",
            "Log phase"
        ]
    },
    {
        "q": "What is Nginx debugging with strace?",
        "type": "mcq",
        "o": [
            "Tracing system calls made by Nginx processes",
            "Strace logging",
            "Debug configuration",
            "Trace analysis"
        ]
    },
    {
        "q": "strace -p <pid> attaches to running Nginx ______.",
        "type": "fill_blank",
        "answers": [
            "process"
        ],
        "other_options": [
            "worker",
            "master",
            "thread"
        ]
    },
    {
        "q": "What is GDB debugging for Nginx?",
        "type": "mcq",
        "o": [
            "Using GNU Debugger to analyze Nginx crash dumps",
            "GDB logging",
            "Debug mode",
            "Graph debugging"
        ]
    },
    {
        "q": "Core dumps require ulimit -c unlimited setting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is pcre_jit directive?",
        "type": "mcq",
        "o": [
            "Enables JIT compilation for PCRE regular expressions",
            "JIT logging",
            "JIT configuration",
            "PCRE mode"
        ]
    },
    {
        "q": "pcre_jit on improves ______ matching performance.",
        "type": "fill_blank",
        "answers": [
            "regex"
        ],
        "other_options": [
            "string",
            "location",
            "header"
        ]
    },
    {
        "q": "What is thread_pool directive?",
        "type": "mcq",
        "o": [
            "Defines pool of threads for asynchronous operations",
            "Thread logging",
            "Pool configuration",
            "Thread management"
        ]
    },
    {
        "q": "thread_pool default threads=32 creates pool with 32 threads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is env directive?",
        "type": "mcq",
        "o": [
            "Preserves environment variable for Nginx processes",
            "Environment logging",
            "Env configuration",
            "Variable storage"
        ]
    },
    {
        "q": "By default Nginx removes most environment ______.",
        "type": "fill_blank",
        "answers": [
            "variables"
        ],
        "other_options": [
            "files",
            "settings",
            "configurations"
        ]
    },
    {
        "q": "What is daemon directive?",
        "type": "mcq",
        "o": [
            "Controls whether Nginx runs as daemon or foreground",
            "Daemon logging",
            "Background mode",
            "Daemon configuration"
        ]
    },
    {
        "q": "daemon off; is commonly used in Docker containers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is master_process directive?",
        "type": "mcq",
        "o": [
            "Enables or disables master process mode",
            "Process logging",
            "Master configuration",
            "Process management"
        ]
    },
    {
        "q": "master_process off runs Nginx without master/worker ______.",
        "type": "fill_blank",
        "answers": [
            "separation"
        ],
        "other_options": [
            "processes",
            "configuration",
            "management"
        ]
    },
    {
        "q": "What is pid directive?",
        "type": "mcq",
        "o": [
            "Specifies file to store master process ID",
            "PID logging",
            "Process configuration",
            "ID storage"
        ]
    },
    {
        "q": "pid file is used by init scripts for process management.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is lock_file directive?",
        "type": "mcq",
        "o": [
            "File for accept_mutex synchronization",
            "Lock logging",
            "Lock configuration",
            "File locking"
        ]
    },
    {
        "q": "lock_file is needed on systems without atomic ______.",
        "type": "fill_blank",
        "answers": [
            "operations"
        ],
        "other_options": [
            "files",
            "locks",
            "memory"
        ]
    },
    {
        "q": "What is timer_resolution?",
        "type": "mcq",
        "o": [
            "Reduces timer syscalls by caching time",
            "Timer logging",
            "Resolution configuration",
            "Time management"
        ]
    },
    {
        "q": "timer_resolution 100ms caches time reducing gettimeofday calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is working_directory?",
        "type": "mcq",
        "o": [
            "Working directory for core dump files",
            "Directory logging",
            "Work configuration",
            "Directory management"
        ]
    },
    {
        "q": "working_directory must be writable by worker ______.",
        "type": "fill_blank",
        "answers": [
            "processes"
        ],
        "other_options": [
            "users",
            "threads",
            "modules"
        ]
    },
    {
        "q": "What is user directive?",
        "type": "mcq",
        "o": [
            "Sets user and group for worker processes",
            "User logging",
            "User configuration",
            "Account management"
        ]
    },
    {
        "q": "user nginx nginx; runs workers as nginx user and group.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_buffer_size?",
        "type": "mcq",
        "o": [
            "Buffer size for SSL records",
            "SSL logging",
            "Buffer configuration",
            "SSL management"
        ]
    },
    {
        "q": "Smaller ssl_buffer_size reduces latency but increases ______.",
        "type": "fill_blank",
        "answers": [
            "overhead"
        ],
        "other_options": [
            "security",
            "performance",
            "memory"
        ]
    },
    {
        "q": "What is ssl_ecdh_curve?",
        "type": "mcq",
        "o": [
            "Specifies curves for ECDHE key exchange",
            "Curve logging",
            "ECDH configuration",
            "Curve management"
        ]
    },
    {
        "q": "X25519 is a recommended curve for modern TLS.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is ssl_early_data?",
        "type": "mcq",
        "o": [
            "Enables TLS 1.3 0-RTT for reduced latency",
            "Early logging",
            "Data configuration",
            "Early management"
        ]
    },
    {
        "q": "0-RTT data is vulnerable to ______ attacks.",
        "type": "fill_blank",
        "answers": [
            "replay"
        ],
        "other_options": [
            "injection",
            "XSS",
            "CSRF"
        ]
    },
    {
        "q": "What is $ssl_early_data variable?",
        "type": "mcq",
        "o": [
            "Indicates if request used 0-RTT early data",
            "Early variable",
            "SSL data",
            "Data variable"
        ]
    },
    {
        "q": "Applications should use Early-Data header to detect 0-RTT.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is proxy_request_buffering?",
        "type": "mcq",
        "o": [
            "Controls whether to buffer complete request before proxying",
            "Request logging",
            "Buffering configuration",
            "Request management"
        ]
    },
    {
        "q": "proxy_request_buffering off enables streaming large ______.",
        "type": "fill_blank",
        "answers": [
            "uploads"
        ],
        "other_options": [
            "downloads",
            "responses",
            "headers"
        ]
    },
    {
        "q": "What is client_body_in_single_buffer?",
        "type": "mcq",
        "o": [
            "Stores entire request body in one buffer",
            "Single logging",
            "Buffer configuration",
            "Body management"
        ]
    },
    {
        "q": "Single buffer is useful when accessing body with $request_body.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is client_body_in_file_only?",
        "type": "mcq",
        "o": [
            "Forces request body to temporary file",
            "File logging",
            "Body configuration",
            "File management"
        ]
    },
    {
        "q": "client_body_in_file_only on always writes body to ______.",
        "type": "fill_blank",
        "answers": [
            "disk"
        ],
        "other_options": [
            "memory",
            "buffer",
            "cache"
        ]
    },
    {
        "q": "What is client_body_temp_path?",
        "type": "mcq",
        "o": [
            "Directory for temporary request body files",
            "Temp logging",
            "Path configuration",
            "Temp management"
        ]
    },
    {
        "q": "Levels in temp_path create directory hierarchy for performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is etag directive?",
        "type": "mcq",
        "o": [
            "Enables or disables ETag response header",
            "ETag logging",
            "Tag configuration",
            "ETag management"
        ]
    },
    {
        "q": "ETag helps with cache validation using ______.",
        "type": "fill_blank",
        "answers": [
            "If-None-Match"
        ],
        "other_options": [
            "If-Modified-Since",
            "Cache-Control",
            "Expires"
        ]
    },
    {
        "q": "What is if_modified_since directive?",
        "type": "mcq",
        "o": [
            "Controls response to If-Modified-Since header",
            "Modified logging",
            "Since configuration",
            "Time management"
        ]
    },
    {
        "q": "if_modified_since exact requires exact timestamp match.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is recursive_error_pages?",
        "type": "mcq",
        "o": [
            "Allows error_page directives in error pages",
            "Recursive logging",
            "Page configuration",
            "Error management"
        ]
    },
    {
        "q": "recursive_error_pages enables chained ______ handling.",
        "type": "fill_blank",
        "answers": [
            "error"
        ],
        "other_options": [
            "request",
            "response",
            "redirect"
        ]
    },
    {
        "q": "What is max_ranges directive?",
        "type": "mcq",
        "o": [
            "Limits number of ranges in byte-range requests",
            "Range logging",
            "Max configuration",
            "Range management"
        ]
    },
    {
        "q": "max_ranges 0 disables byte-range request support.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is types_hash_bucket_size?",
        "type": "mcq",
        "o": [
            "Sets hash bucket size for MIME types table",
            "Hash logging",
            "Bucket configuration",
            "Type management"
        ]
    },
    {
        "q": "Hash bucket size should be multiple of processor cache ______.",
        "type": "fill_blank",
        "answers": [
            "line size"
        ],
        "other_options": [
            "size",
            "count",
            "level"
        ]
    },
    {
        "q": "Match Nginx security headers with their purposes:",
        "type": "match",
        "left": [
            "X-Frame-Options",
            "X-Content-Type-Options",
            "X-XSS-Protection",
            "Referrer-Policy"
        ],
        "right": [
            "Prevent clickjacking",
            "Prevent MIME sniffing",
            "XSS filter",
            "Control referrer"
        ]
    },
    {
        "q": "Rearrange Nginx upgrade process:",
        "type": "rearrange",
        "words": [
            "Install new binary",
            "Send USR2 signal",
            "Test new workers",
            "Send WINCH to old master",
            "Send QUIT to old master"
        ]
    },
    {
        "q": "Match Nginx Plus features with their benefits:",
        "type": "match",
        "left": [
            "Active health checks",
            "Session persistence",
            "Live activity monitoring",
            "Dynamic configuration"
        ],
        "right": [
            "Proactive server monitoring",
            "Sticky sessions",
            "Real-time dashboards",
            "API-based changes"
        ]
    },
    {
        "q": "Rearrange cache purge workflow:",
        "type": "rearrange",
        "words": [
            "Receive purge request",
            "Validate authorization",
            "Locate cache file",
            "Delete from disk",
            "Clear from memory zone"
        ]
    }
]