[
    {
        "title": "Everything is a Widget üß±",
        "ques": "Flutter's core philosophy is \"Everything is a Widget\". How does this differ from the React Native approach using OEM widgets?",
        "answer": {
            "type": "text",
            "content": "React Native uses the OS's native widgets (views). \nFlutter **draws its own pixels** effectively acting as a game engine (Skia/Impeller). A Flutter button is just a drawing on a canvas, matching the OS style pixel-perfectly, but not using the native OS object."
        },
        "explanation": "This guarantees consistency. The app looks exactly the same on every OS version, avoiding fragmentation bugs."
    },
    {
        "title": "Hot Reload ‚ö°",
        "ques": "Flutter uses the **Dart** language. How does Dart support both fast development (JIT) and high performance (AOT)?",
        "answer": {
            "type": "text",
            "content": "*   **Debug Mode:** Uses **JIT** (Just-In-Time) compilation. This enables stateful Hot Reload (sub-second updates).\n*   **Release Mode:** Uses **AOT** (Ahead-Of-Time) compilation. This compiles Dart to native ARM machine code for maximum speed on the device."
        },
        "explanation": "Best of both worlds: dynamic dev experience, static production performance."
    },
    {
        "title": "State Management (Bloc/Provider) üóÉÔ∏è",
        "ques": "In Flutter, the `setState()` method rebuilds the widget. Why are advanced patterns like **BLoC** (Business Logic Component) or **Riverpod** preferred for large apps?",
        "answer": {
            "type": "text",
            "content": "Passing state down a deep widget tree is messy (Prop Drilling). \nBLoC separates business logic (Events/States) from the UI (Widgets). Streams allow widgets to listen to state changes independently, ensuring only the necessary parts of the screen rebuild."
        },
        "explanation": "Clean architecture separates 'What it looks like' from 'How it works'."
    },
    {
        "title": "Platform Channels üõ§Ô∏è",
        "ques": "How does Flutter code communicate with platform-specific APIs (like battery level or Bluetooth)?",
        "answer": {
            "type": "text",
            "content": "Via **Platform Channels**. \nFlutter sends an asynchronous message to the host (iOS/Android) code. The host listens, executes the native API, and sends the result back. It facilitates a binary messaging protocol."
        },
        "explanation": "Similar to React Native's Bridge, but strictly typed and binary-optimized."
    },
    {
        "title": "Material vs. Cupertino üé®",
        "ques": "Flutter ships with two big widget libraries: **Material** and **Cupertino**. What is the difference?",
        "answer": {
            "type": "text",
            "content": "*   **Material:** Implements Google's Material Design (Android standard).\n*   **Cupertino:** Implements Apple's iOS Human Interface Guidelines (buttons, pickers, transitions match iOS).\n\nYou can mix them or switch them dynamically to make the app feel native on both platforms."
        },
        "explanation": "Flutter gives you control over every pixel, including mimicking standard OS behaviors."
    }
]