[
  {
    "q": "What does real-time communication mean in web applications?",
    "o": [
      "Data is exchanged instantly between client and server",
      "Data is cached for faster loading",
      "Data is compressed before sending",
      "Data is encrypted during transmission"
    ]
  },
  {
    "q": "Which of the following is a characteristic of real-time features?",
    "o": [
      "Bi-directional data flow",
      "One-way data flow only",
      "Batch processing of requests",
      "Delayed response handling"
    ]
  },
  {
    "q": "What is a persistent connection?",
    "o": [
      "A connection that stays open for continuous communication",
      "A connection that closes after each request",
      "A connection that requires authentication",
      "A connection that uses encryption"
    ]
  },
  {
    "q": "Which use case benefits most from real-time features?",
    "o": [
      "Live chat applications",
      "Static blog websites",
      "Image galleries",
      "Contact forms"
    ]
  },
  {
    "q": "What is the main advantage of bi-directional communication?",
    "o": [
      "Both client and server can initiate data transfer",
      "Only the client can send data",
      "Only the server can send data",
      "Data is sent in batches"
    ]
  },
  {
    "q": "Which protocol is commonly used for real-time web communication?",
    "o": [
      "WebSocket",
      "FTP",
      "SMTP",
      "POP3"
    ]
  },
  {
    "q": "What is a key benefit of persistent connections?",
    "o": [
      "Reduced latency for data exchange",
      "Increased server memory usage",
      "Higher bandwidth consumption",
      "More complex error handling"
    ]
  },
  {
    "q": "Which application requires real-time updates?",
    "o": [
      "Stock trading platform",
      "Static documentation site",
      "Personal portfolio",
      "Company brochure"
    ]
  },
  {
    "q": "What does bi-directional mean in networking?",
    "o": [
      "Data can flow in both directions",
      "Data flows only from client to server",
      "Data flows only from server to client",
      "Data is encrypted in both directions"
    ]
  },
  {
    "q": "Which feature is essential for real-time collaboration tools?",
    "o": [
      "Instant synchronization of changes",
      "Delayed batch updates",
      "Manual refresh requirements",
      "Periodic polling intervals"
    ]
  },
  {
    "q": "What is the primary difference between real-time and traditional HTTP?",
    "o": [
      "Real-time maintains open connections",
      "Real-time uses more bandwidth",
      "Real-time is less secure",
      "Real-time requires more servers"
    ]
  },
  {
    "q": "Which scenario benefits from persistent connections?",
    "o": [
      "Multiplayer online games",
      "Reading blog posts",
      "Viewing static images",
      "Downloading PDF files"
    ]
  },
  {
    "q": "What is a common use case for real-time notifications?",
    "o": [
      "Social media updates",
      "Annual reports",
      "Static menus",
      "Privacy policies"
    ]
  },
  {
    "q": "How do persistent connections differ from regular HTTP requests?",
    "o": [
      "They remain open after the initial handshake",
      "They close immediately after response",
      "They require multiple handshakes",
      "They use different ports"
    ]
  },
  {
    "q": "Which technology enables server push in real-time apps?",
    "o": [
      "WebSocket or Server-Sent Events",
      "Regular HTTP GET requests",
      "FTP transfers",
      "Email protocols"
    ]
  },
  {
    "q": "What is the main challenge of implementing real-time features?",
    "o": [
      "Managing concurrent connections efficiently",
      "Creating static content",
      "Designing simple layouts",
      "Writing documentation"
    ]
  },
  {
    "q": "Which application type requires bi-directional communication?",
    "o": [
      "Video conferencing apps",
      "Static landing pages",
      "Image hosting sites",
      "PDF viewers"
    ]
  },
  {
    "q": "What does server push mean in real-time communication?",
    "o": [
      "Server sends data without client request",
      "Client requests data from server",
      "Server waits for client polling",
      "Server caches all responses"
    ]
  },
  {
    "q": "Which metric is most important for real-time applications?",
    "o": [
      "Low latency",
      "High storage capacity",
      "Large file size support",
      "Complex animations"
    ]
  },
  {
    "q": "What is a typical use case for real-time data streaming?",
    "o": [
      "Live sports scores",
      "Historical archives",
      "Static product catalogs",
      "Company history pages"
    ]
  },
  {
    "q": "Why are persistent connections important for chat apps?",
    "o": [
      "Messages appear instantly without refresh",
      "Messages are stored permanently",
      "Messages are encrypted automatically",
      "Messages use less bandwidth"
    ]
  },
  {
    "q": "Which protocol supports full-duplex communication?",
    "o": [
      "WebSocket",
      "HTTP/1.0",
      "FTP",
      "SMTP"
    ]
  },
  {
    "q": "What is full-duplex communication?",
    "o": [
      "Simultaneous two-way data transmission",
      "One-way data transmission only",
      "Alternating data transmission",
      "Batch data transmission"
    ]
  },
  {
    "q": "Which application benefits from real-time updates?",
    "o": [
      "Collaborative document editing",
      "Static FAQ pages",
      "Archived newsletters",
      "Terms of service"
    ]
  },
  {
    "q": "What is the main advantage of real-time features for users?",
    "o": [
      "Immediate feedback and updates",
      "Reduced data usage",
      "Simpler user interface",
      "Fewer security concerns"
    ]
  },
  {
    "q": "Which technology is NOT typically used for real-time communication?",
    "o": [
      "Traditional HTTP polling every 5 minutes",
      "WebSockets",
      "Server-Sent Events",
      "Long polling"
    ]
  },
  {
    "q": "What is a key characteristic of bi-directional protocols?",
    "o": [
      "Both parties can send messages anytime",
      "Only one party can send messages",
      "Messages are queued for later",
      "Messages require acknowledgment"
    ]
  },
  {
    "q": "Which use case requires persistent connections?",
    "o": [
      "Real-time dashboard monitoring",
      "Static image gallery",
      "Printable forms",
      "Downloadable resources"
    ]
  },
  {
    "q": "What does low latency mean in real-time systems?",
    "o": [
      "Minimal delay in data transmission",
      "Maximum data compression",
      "Reduced bandwidth usage",
      "Simplified error handling"
    ]
  },
  {
    "q": "Which feature is essential for real-time gaming?",
    "o": [
      "Instant player action synchronization",
      "Turn-based gameplay only",
      "Offline mode support",
      "Single-player campaigns"
    ]
  },
  {
    "q": "What is the purpose of maintaining open connections?",
    "o": [
      "Enable instant data exchange without reconnecting",
      "Reduce server load significantly",
      "Simplify authentication process",
      "Improve SEO rankings"
    ]
  },
  {
    "q": "Which application requires real-time data synchronization?",
    "o": [
      "Shared whiteboard applications",
      "Static recipe websites",
      "Personal blogs",
      "Digital brochures"
    ]
  },
  {
    "q": "What is a common challenge with persistent connections?",
    "o": [
      "Managing server resources for many connections",
      "Creating simple HTML pages",
      "Designing basic layouts",
      "Writing CSS styles"
    ]
  },
  {
    "q": "Which protocol allows server-initiated messages?",
    "o": [
      "WebSocket",
      "Standard HTTP GET",
      "FTP",
      "DNS"
    ]
  },
  {
    "q": "What is the benefit of real-time notifications?",
    "o": [
      "Users receive updates immediately",
      "Users must refresh manually",
      "Users receive daily summaries",
      "Users check periodically"
    ]
  },
  {
    "q": "Which scenario does NOT require real-time features?",
    "o": [
      "Displaying static company information",
      "Live auction bidding",
      "Instant messaging",
      "Real-time analytics"
    ]
  },
  {
    "q": "What is the main goal of bi-directional communication?",
    "o": [
      "Enable interactive two-way conversations",
      "Send data in one direction only",
      "Batch process all requests",
      "Cache responses locally"
    ]
  },
  {
    "q": "Which technology supports persistent connections?",
    "o": [
      "WebSocket protocol",
      "Basic HTML forms",
      "CSS animations",
      "Static file serving"
    ]
  },
  {
    "q": "What is a typical real-time use case in e-commerce?",
    "o": [
      "Live inventory updates",
      "Product descriptions",
      "Shipping policies",
      "Return instructions"
    ]
  },
  {
    "q": "Why is low latency important for real-time apps?",
    "o": [
      "Ensures responsive user experience",
      "Reduces development costs",
      "Simplifies code structure",
      "Improves SEO performance"
    ]
  },
  {
    "q": "Which application type needs instant updates?",
    "o": [
      "Live streaming platforms",
      "Static news archives",
      "Photo galleries",
      "Contact directories"
    ]
  },
  {
    "q": "What does real-time collaboration enable?",
    "o": [
      "Multiple users editing simultaneously",
      "Sequential user access only",
      "Offline editing mode",
      "Manual synchronization"
    ]
  },
  {
    "q": "Which protocol is designed for real-time communication?",
    "o": [
      "WebSocket",
      "SMTP",
      "POP3",
      "IMAP"
    ]
  },
  {
    "q": "What is a key feature of persistent connections?",
    "o": [
      "Connection stays alive between messages",
      "Connection closes after each message",
      "Connection requires constant authentication",
      "Connection uses multiple ports"
    ]
  },
  {
    "q": "Which use case benefits from server push?",
    "o": [
      "Breaking news alerts",
      "Static about pages",
      "Archived content",
      "Privacy statements"
    ]
  },
  {
    "q": "What is the primary benefit of real-time features?",
    "o": [
      "Immediate data synchronization",
      "Reduced code complexity",
      "Lower development time",
      "Simpler testing process"
    ]
  },
  {
    "q": "Which application requires bi-directional data flow?",
    "o": [
      "Online multiplayer games",
      "Static portfolios",
      "Image carousels",
      "Text documents"
    ]
  },
  {
    "q": "What is a common real-time feature in social media?",
    "o": [
      "Live comment updates",
      "Profile pictures",
      "User biographies",
      "Account settings"
    ]
  },
  {
    "q": "Why do chat applications use persistent connections?",
    "o": [
      "To deliver messages instantly",
      "To reduce server costs",
      "To simplify UI design",
      "To improve security"
    ]
  },
  {
    "q": "Which technology enables instant notifications?",
    "o": [
      "Real-time protocols like WebSocket",
      "Regular HTTP requests",
      "Email systems",
      "File downloads"
    ]
  },
  {
    "q": "What is the main characteristic of real-time systems?",
    "o": [
      "Immediate response to events",
      "Delayed batch processing",
      "Manual user refresh",
      "Scheduled updates"
    ]
  },
  {
    "q": "Which scenario requires persistent connections?",
    "o": [
      "Live customer support chat",
      "Static FAQ section",
      "Downloadable guides",
      "Contact information"
    ]
  },
  {
    "q": "What does bi-directional communication allow?",
    "o": [
      "Both client and server to send data freely",
      "Only client to send requests",
      "Only server to send responses",
      "Data to be cached locally"
    ]
  },
  {
    "q": "Which application needs real-time updates?",
    "o": [
      "Live traffic monitoring",
      "Historical data archives",
      "Static maps",
      "Printed directions"
    ]
  },
  {
    "q": "What is a benefit of maintaining open connections?",
    "o": [
      "Faster message delivery",
      "Reduced memory usage",
      "Simpler code structure",
      "Better SEO ranking"
    ]
  },
  {
    "q": "Which protocol supports two-way communication?",
    "o": [
      "WebSocket",
      "HTTP/1.0 only",
      "FTP",
      "DNS"
    ]
  },
  {
    "q": "What is a typical use case for real-time features?",
    "o": [
      "Collaborative coding platforms",
      "Static code examples",
      "Documentation sites",
      "Tutorial archives"
    ]
  },
  {
    "q": "Why is latency critical in real-time applications?",
    "o": [
      "High latency degrades user experience",
      "High latency improves security",
      "High latency reduces costs",
      "High latency simplifies code"
    ]
  },
  {
    "q": "Which feature characterizes real-time communication?",
    "o": [
      "Continuous data exchange",
      "Periodic batch updates",
      "Manual refresh required",
      "Scheduled synchronization"
    ]
  },
  {
    "q": "What is the purpose of server push technology?",
    "o": [
      "Send updates to clients proactively",
      "Wait for client requests only",
      "Cache all server responses",
      "Compress data before sending"
    ]
  },
  {
    "q": "Which application benefits from persistent connections?",
    "o": [
      "Real-time analytics dashboards",
      "Static report generators",
      "Archived data viewers",
      "Printable charts"
    ]
  },
  {
    "q": "What does real-time mean in web development?",
    "o": [
      "Data updates happen immediately",
      "Data updates happen daily",
      "Data updates happen weekly",
      "Data updates happen monthly"
    ]
  },
  {
    "q": "Which technology is fundamental for real-time apps?",
    "o": [
      "Persistent connection protocols",
      "Static file hosting",
      "Image optimization",
      "CSS frameworks"
    ]
  },
  {
    "q": "What is a key advantage of bi-directional protocols?",
    "o": [
      "Interactive communication between parties",
      "One-way data transmission only",
      "Reduced network traffic",
      "Simplified authentication"
    ]
  },
  {
    "q": "Which use case requires instant data updates?",
    "o": [
      "Live auction platforms",
      "Product catalogs",
      "Company directories",
      "Static pricing pages"
    ]
  },
  {
    "q": "What is the main benefit of real-time collaboration?",
    "o": [
      "Multiple users see changes instantly",
      "Users work in isolation",
      "Changes are batched daily",
      "Manual merging required"
    ]
  },
  {
    "q": "Which protocol enables real-time web communication?",
    "o": [
      "WebSocket",
      "SMTP",
      "FTP",
      "Telnet"
    ]
  },
  {
    "q": "What is a common challenge in real-time systems?",
    "o": [
      "Handling high concurrency",
      "Creating static pages",
      "Writing simple HTML",
      "Designing basic forms"
    ]
  },
  {
    "q": "Which application requires real-time synchronization?",
    "o": [
      "Shared task management tools",
      "Static to-do lists",
      "Printed schedules",
      "Offline planners"
    ]
  },
  {
    "q": "What is the purpose of maintaining persistent connections?",
    "o": [
      "Reduce overhead of repeated handshakes",
      "Increase server complexity",
      "Improve static content delivery",
      "Enhance image quality"
    ]
  },
  {
    "q": "Which feature is essential for real-time messaging?",
    "o": [
      "Instant message delivery",
      "Delayed message queuing",
      "Daily message batching",
      "Weekly message summaries"
    ]
  },
  {
    "q": "What does low latency enable in real-time apps?",
    "o": [
      "Quick response to user actions",
      "Slower data processing",
      "Batch data handling",
      "Delayed notifications"
    ]
  },
  {
    "q": "Which scenario benefits most from real-time features?",
    "o": [
      "Live video streaming",
      "Pre-recorded videos",
      "Downloaded content",
      "Cached media"
    ]
  },
  {
    "q": "What is a key characteristic of persistent connections?",
    "o": [
      "Long-lived network connections",
      "Short-lived request-response cycles",
      "Disconnected operations",
      "Offline-first approach"
    ]
  },
  {
    "q": "Which technology supports instant updates?",
    "o": [
      "Real-time communication protocols",
      "Static file serving",
      "Batch processing systems",
      "Scheduled cron jobs"
    ]
  },
  {
    "q": "What is the main goal of real-time applications?",
    "o": [
      "Provide immediate user feedback",
      "Reduce server costs",
      "Simplify development",
      "Minimize code size"
    ]
  },
  {
    "q": "Which application type needs bi-directional communication?",
    "o": [
      "Interactive whiteboards",
      "Static diagrams",
      "Printed charts",
      "Image galleries"
    ]
  },
  {
    "q": "What is a common use case for persistent connections?",
    "o": [
      "Live sports score updates",
      "Historical sports data",
      "Archived game results",
      "Printed statistics"
    ]
  },
  {
    "q": "Why are real-time features important for collaboration?",
    "o": [
      "Users see each other's changes immediately",
      "Users work independently offline",
      "Changes sync once daily",
      "Manual conflict resolution required"
    ]
  },
  {
    "q": "Which protocol is designed for persistent connections?",
    "o": [
      "WebSocket",
      "HTTP/1.0",
      "FTP",
      "SMTP"
    ]
  },
  {
    "q": "What is the benefit of server-initiated communication?",
    "o": [
      "Clients receive updates without polling",
      "Clients must request all data",
      "Servers wait for client requests",
      "Data is cached indefinitely"
    ]
  },
  {
    "q": "Which application requires instant synchronization?",
    "o": [
      "Multiplayer online games",
      "Single-player offline games",
      "Turn-based email games",
      "Saved game archives"
    ]
  },
  {
    "q": "What is a key feature of real-time systems?",
    "o": [
      "Minimal delay in data transmission",
      "Maximum data compression",
      "Batch processing mode",
      "Scheduled updates only"
    ]
  },
  {
    "q": "Which technology enables real-time notifications?",
    "o": [
      "Push-capable protocols",
      "Pull-only HTTP",
      "Email systems",
      "SMS gateways"
    ]
  },
  {
    "q": "What is the main advantage of persistent connections?",
    "o": [
      "Reduced connection overhead",
      "Increased bandwidth usage",
      "Complex error handling",
      "Higher memory consumption"
    ]
  },
  {
    "q": "Which use case benefits from real-time updates?",
    "o": [
      "Live weather monitoring",
      "Historical weather data",
      "Archived forecasts",
      "Printed almanacs"
    ]
  },
  {
    "q": "What does bi-directional communication enable?",
    "o": [
      "Interactive real-time conversations",
      "One-way broadcasts only",
      "Delayed message delivery",
      "Batch message processing"
    ]
  },
  {
    "q": "Which application needs real-time data flow?",
    "o": [
      "Live financial trading platforms",
      "Historical stock charts",
      "Archived market data",
      "Printed financial reports"
    ]
  },
  {
    "q": "What is the purpose of real-time protocols?",
    "o": [
      "Enable instant bidirectional communication",
      "Reduce network bandwidth",
      "Simplify server architecture",
      "Improve static content delivery"
    ]
  },
  {
    "q": "Which feature is critical for real-time applications?",
    "o": [
      "Low latency communication",
      "High storage capacity",
      "Complex algorithms",
      "Large file support"
    ]
  },
  {
    "q": "What is a typical real-time feature in web apps?",
    "o": [
      "Live user presence indicators",
      "Static user profiles",
      "Cached user data",
      "Archived user history"
    ]
  },
  {
    "q": "Why do real-time apps use persistent connections?",
    "o": [
      "To maintain continuous communication channel",
      "To reduce development complexity",
      "To improve SEO rankings",
      "To simplify authentication"
    ]
  },
  {
    "q": "Which scenario requires real-time communication?",
    "o": [
      "Live customer support",
      "Email support tickets",
      "Contact forms",
      "FAQ sections"
    ]
  },
  {
    "q": "What is the main benefit of instant updates?",
    "o": [
      "Enhanced user engagement",
      "Reduced server load",
      "Simpler codebase",
      "Lower bandwidth costs"
    ]
  },
  {
    "q": "Which protocol supports full-duplex real-time communication?",
    "o": [
      "WebSocket",
      "HTTP/1.1 only",
      "FTP",
      "DNS"
    ]
  },
  {
    "q": "What is a common real-time use case?",
    "o": [
      "Live collaborative editing",
      "Static document viewing",
      "Offline document storage",
      "Printed document archives"
    ]
  },
  {
    "q": "What is the typical handshake process for establishing a persistent connection?",
    "o": [
      "Client sends upgrade request, server accepts",
      "Server sends data first, client responds",
      "Both parties send data simultaneously",
      "Connection opens without negotiation"
    ]
  },
  {
    "q": "Which HTTP header is used to upgrade to WebSocket?",
    "o": [
      "Upgrade: websocket",
      "Connection: keep-alive",
      "Content-Type: websocket",
      "Protocol: real-time"
    ]
  },
  {
    "q": "How does a persistent connection reduce latency?",
    "o": [
      "Eliminates repeated TCP handshakes",
      "Compresses all data automatically",
      "Caches responses locally",
      "Uses faster network protocols"
    ]
  },
  {
    "q": "What is connection pooling in real-time systems?",
    "o": [
      "Reusing connections for multiple clients",
      "Creating new connection per request",
      "Closing connections after each message",
      "Encrypting all connection data"
    ]
  },
  {
    "q": "Which status code indicates a successful WebSocket upgrade?",
    "o": [
      "101 Switching Protocols",
      "200 OK",
      "201 Created",
      "204 No Content"
    ]
  },
  {
    "q": "What is the purpose of heartbeat messages in persistent connections?",
    "o": [
      "Keep connection alive and detect failures",
      "Send actual application data",
      "Authenticate users periodically",
      "Compress data before transmission"
    ]
  },
  {
    "q": "How do real-time systems handle connection failures?",
    "o": [
      "Automatic reconnection with exponential backoff",
      "Manual user intervention required",
      "Permanent connection termination",
      "Switch to email notifications"
    ]
  },
  {
    "q": "What is the role of the Sec-WebSocket-Key header?",
    "o": [
      "Security handshake validation",
      "Data encryption key",
      "User authentication token",
      "Session identifier"
    ]
  },
  {
    "q": "Which layer of the OSI model do WebSockets operate on?",
    "o": [
      "Application layer (Layer 7)",
      "Transport layer (Layer 4)",
      "Network layer (Layer 3)",
      "Data link layer (Layer 2)"
    ]
  },
  {
    "q": "What is message framing in WebSocket protocol?",
    "o": [
      "Structuring data into discrete packets",
      "Encrypting message content",
      "Compressing message size",
      "Routing messages to recipients"
    ]
  },
  {
    "q": "How do persistent connections affect server scalability?",
    "o": [
      "Require more memory per connection",
      "Reduce memory usage significantly",
      "Have no impact on resources",
      "Only affect CPU usage"
    ]
  },
  {
    "q": "What is the Connection header value for WebSocket upgrade?",
    "o": [
      "Upgrade",
      "Keep-Alive",
      "Close",
      "Persist"
    ]
  },
  {
    "q": "Which technique helps manage thousands of persistent connections?",
    "o": [
      "Event-driven architecture with async I/O",
      "Synchronous blocking I/O",
      "Thread-per-connection model",
      "Sequential request processing"
    ]
  },
  {
    "q": "What is the purpose of the Origin header in WebSocket?",
    "o": [
      "Prevent cross-site WebSocket hijacking",
      "Specify data compression method",
      "Define message encoding",
      "Set connection timeout"
    ]
  },
  {
    "q": "How does bi-directional communication improve chat applications?",
    "o": [
      "Both users can send messages simultaneously",
      "Messages are queued and sent in batches",
      "Only one user can type at a time",
      "Messages require manual refresh"
    ]
  },
  {
    "q": "What is a common pattern for handling disconnections?",
    "o": [
      "Exponential backoff with jitter",
      "Immediate reconnection attempts",
      "Wait for manual user action",
      "Switch to polling permanently"
    ]
  },
  {
    "q": "Which protocol feature enables server push?",
    "o": [
      "Persistent bidirectional connection",
      "HTTP request-response cycle",
      "Client polling mechanism",
      "Cookie-based sessions"
    ]
  },
  {
    "q": "What is the typical port for WebSocket connections?",
    "o": [
      "80 for ws:// and 443 for wss://",
      "8080 for all WebSocket connections",
      "3000 for development only",
      "9000 for production use"
    ]
  },
  {
    "q": "How do real-time systems handle message ordering?",
    "o": [
      "Sequence numbers or timestamps",
      "Random delivery order",
      "Alphabetical sorting",
      "Size-based prioritization"
    ]
  },
  {
    "q": "What is the benefit of using wss:// over ws://?",
    "o": [
      "Encrypted communication via TLS/SSL",
      "Faster data transmission",
      "Lower latency",
      "Reduced bandwidth usage"
    ]
  },
  {
    "q": "Which design pattern is common in real-time applications?",
    "o": [
      "Publish-Subscribe (Pub/Sub)",
      "Singleton pattern",
      "Factory pattern",
      "Adapter pattern"
    ]
  },
  {
    "q": "What is connection draining in real-time systems?",
    "o": [
      "Gracefully closing connections during shutdown",
      "Forcefully terminating all connections",
      "Transferring connections to another server",
      "Caching connection state"
    ]
  },
  {
    "q": "How do persistent connections handle network interruptions?",
    "o": [
      "Detect timeout and attempt reconnection",
      "Wait indefinitely for network recovery",
      "Immediately terminate the session",
      "Switch to email notifications"
    ]
  },
  {
    "q": "What is the purpose of ping/pong frames in WebSocket?",
    "o": [
      "Keep-alive and connection health check",
      "Send actual application data",
      "Authenticate the connection",
      "Compress message payloads"
    ]
  },
  {
    "q": "Which metric is critical for real-time system performance?",
    "o": [
      "Round-trip time (RTT)",
      "Disk I/O speed",
      "CPU clock speed",
      "RAM capacity"
    ]
  },
  {
    "q": "What is message acknowledgment in real-time systems?",
    "o": [
      "Confirming message receipt",
      "Encrypting message content",
      "Compressing message size",
      "Routing message to recipient"
    ]
  },
  {
    "q": "How do load balancers handle persistent connections?",
    "o": [
      "Sticky sessions or consistent hashing",
      "Random distribution only",
      "Round-robin for each message",
      "Close and reopen connections"
    ]
  },
  {
    "q": "What is the Sec-WebSocket-Accept header used for?",
    "o": [
      "Server's handshake response validation",
      "Client authentication token",
      "Message encryption key",
      "Connection timeout value"
    ]
  },
  {
    "q": "Which challenge is unique to persistent connections?",
    "o": [
      "Managing connection state across restarts",
      "Parsing HTTP headers",
      "Rendering HTML templates",
      "Compiling CSS stylesheets"
    ]
  },
  {
    "q": "What is connection multiplexing?",
    "o": [
      "Multiple logical streams over one connection",
      "One connection per message",
      "Separate connections for each user",
      "Closing connections after each request"
    ]
  },
  {
    "q": "How do real-time apps handle message delivery guarantees?",
    "o": [
      "At-least-once or exactly-once semantics",
      "No delivery guarantees",
      "Random delivery attempts",
      "Manual retry by users"
    ]
  },
  {
    "q": "What is the purpose of Sec-WebSocket-Version header?",
    "o": [
      "Specify WebSocket protocol version",
      "Application version number",
      "Browser version identifier",
      "Server software version"
    ]
  },
  {
    "q": "Which technique reduces latency in real-time systems?",
    "o": [
      "Edge servers and CDN placement",
      "Centralized data centers only",
      "Increased message buffering",
      "Delayed message processing"
    ]
  },
  {
    "q": "What is backpressure in real-time communication?",
    "o": [
      "Slowing sender when receiver is overwhelmed",
      "Increasing send rate automatically",
      "Dropping all excess messages",
      "Caching messages indefinitely"
    ]
  },
  {
    "q": "How do persistent connections handle authentication?",
    "o": [
      "Token-based auth during handshake",
      "Re-authenticate every message",
      "No authentication required",
      "Password sent with each frame"
    ]
  },
  {
    "q": "What is the benefit of binary frames in WebSocket?",
    "o": [
      "Efficient transmission of non-text data",
      "Better text compression",
      "Improved security",
      "Faster handshake process"
    ]
  },
  {
    "q": "Which pattern helps scale persistent connections?",
    "o": [
      "Horizontal scaling with message brokers",
      "Vertical scaling only",
      "Single server deployment",
      "Client-side caching"
    ]
  },
  {
    "q": "What is connection affinity in load balancing?",
    "o": [
      "Routing user to same server instance",
      "Random server selection",
      "Closing connections frequently",
      "Distributing evenly always"
    ]
  },
  {
    "q": "How do real-time systems handle message prioritization?",
    "o": [
      "Priority queues or weighted scheduling",
      "First-in-first-out only",
      "Random message selection",
      "Alphabetical ordering"
    ]
  },
  {
    "q": "What is the purpose of Sec-WebSocket-Extensions header?",
    "o": [
      "Negotiate protocol extensions like compression",
      "List browser extensions",
      "Specify file extensions",
      "Define data types"
    ]
  },
  {
    "q": "Which strategy handles connection storms?",
    "o": [
      "Rate limiting and connection throttling",
      "Accept all connections immediately",
      "Reject all new connections",
      "Queue connections indefinitely"
    ]
  },
  {
    "q": "What is message batching in real-time systems?",
    "o": [
      "Grouping multiple messages for efficiency",
      "Sending one message at a time",
      "Delaying all messages equally",
      "Dropping excess messages"
    ]
  },
  {
    "q": "How do persistent connections affect firewall traversal?",
    "o": [
      "May require special firewall rules",
      "No impact on firewalls",
      "Always blocked by firewalls",
      "Bypass all security measures"
    ]
  },
  {
    "q": "What is the close frame in WebSocket protocol?",
    "o": [
      "Graceful connection termination signal",
      "Error message indicator",
      "Data compression marker",
      "Authentication request"
    ]
  },
  {
    "q": "Which technique improves real-time data consistency?",
    "o": [
      "Operational transformation or CRDT",
      "Random conflict resolution",
      "Last-write-wins always",
      "Manual user intervention"
    ]
  },
  {
    "q": "What is connection pooling benefit for clients?",
    "o": [
      "Reuse connections for multiple requests",
      "Create new connection each time",
      "Close connections immediately",
      "Avoid all connection overhead"
    ]
  },
  {
    "q": "How do real-time apps handle time synchronization?",
    "o": [
      "NTP or server timestamps",
      "Client clocks only",
      "No synchronization needed",
      "Manual time adjustment"
    ]
  },
  {
    "q": "What is the purpose of continuation frames?",
    "o": [
      "Split large messages across frames",
      "Retry failed transmissions",
      "Authenticate connections",
      "Compress data payloads"
    ]
  },
  {
    "q": "Which monitoring metric is key for persistent connections?",
    "o": [
      "Active connection count",
      "Disk space usage",
      "CSS file size",
      "Image resolution"
    ]
  },
  {
    "q": "What is message deduplication?",
    "o": [
      "Preventing duplicate message processing",
      "Sending messages multiple times",
      "Copying messages to backups",
      "Compressing message content"
    ]
  },
  {
    "q": "How do real-time systems handle partial failures?",
    "o": [
      "Circuit breakers and fallback mechanisms",
      "Complete system shutdown",
      "Ignore all errors",
      "Manual intervention only"
    ]
  },
  {
    "q": "What is the benefit of message compression in WebSocket?",
    "o": [
      "Reduced bandwidth usage",
      "Improved security",
      "Faster handshake",
      "Better authentication"
    ]
  },
  {
    "q": "Which pattern handles real-time data conflicts?",
    "o": [
      "Conflict-free replicated data types",
      "Random winner selection",
      "Always reject changes",
      "Manual resolution only"
    ]
  },
  {
    "q": "What is connection timeout management?",
    "o": [
      "Closing idle connections after period",
      "Never closing connections",
      "Immediate connection closure",
      "Random timeout values"
    ]
  },
  {
    "q": "How do persistent connections handle proxy servers?",
    "o": [
      "CONNECT method for tunnel establishment",
      "Direct connection only",
      "Proxies block all WebSockets",
      "No special handling needed"
    ]
  },
  {
    "q": "What is the purpose of subprotocol negotiation?",
    "o": [
      "Agree on application-level protocol",
      "Select network protocol",
      "Choose encryption method",
      "Define port number"
    ]
  },
  {
    "q": "Which technique ensures message ordering?",
    "o": [
      "Sequence numbers and reordering buffers",
      "Random delivery order",
      "Timestamp-based sorting only",
      "No ordering guarantees"
    ]
  },
  {
    "q": "What is connection state management?",
    "o": [
      "Tracking connection lifecycle and metadata",
      "Ignoring connection status",
      "Random state updates",
      "Manual state tracking"
    ]
  },
  {
    "q": "How do real-time apps handle rate limiting?",
    "o": [
      "Token bucket or leaky bucket algorithms",
      "No rate limiting",
      "Block all traffic",
      "Random throttling"
    ]
  },
  {
    "q": "What is the purpose of message fragmentation?",
    "o": [
      "Send large messages in smaller chunks",
      "Encrypt message content",
      "Compress message size",
      "Route to multiple recipients"
    ]
  },
  {
    "q": "Which metric indicates connection health?",
    "o": [
      "Ping response time",
      "File size",
      "Color depth",
      "Font family"
    ]
  },
  {
    "q": "What is graceful degradation in real-time systems?",
    "o": [
      "Fallback to polling when WebSocket fails",
      "Complete feature removal",
      "System shutdown",
      "Error display only"
    ]
  },
  {
    "q": "How do persistent connections handle SSL/TLS?",
    "o": [
      "Encrypt entire connection after handshake",
      "Encrypt only handshake",
      "No encryption support",
      "Encrypt random messages"
    ]
  },
  {
    "q": "What is message routing in real-time systems?",
    "o": [
      "Directing messages to correct recipients",
      "Random message distribution",
      "Broadcasting to all clients",
      "Dropping all messages"
    ]
  },
  {
    "q": "Which pattern handles connection recovery?",
    "o": [
      "Resumable sessions with state sync",
      "Start fresh every time",
      "No recovery mechanism",
      "Manual data re-entry"
    ]
  },
  {
    "q": "What is the purpose of connection metadata?",
    "o": [
      "Store user info and session data",
      "Encrypt messages",
      "Compress data",
      "Route packets"
    ]
  },
  {
    "q": "How do real-time systems handle message expiration?",
    "o": [
      "TTL (Time To Live) values",
      "Never expire messages",
      "Immediate expiration",
      "Random expiration times"
    ]
  },
  {
    "q": "What is connection multiplexing benefit?",
    "o": [
      "Reduced connection overhead",
      "Increased latency",
      "More complex code",
      "Higher bandwidth usage"
    ]
  },
  {
    "q": "Which technique improves connection reliability?",
    "o": [
      "Automatic retry with backoff",
      "Single connection attempt",
      "No retry mechanism",
      "Manual reconnection only"
    ]
  },
  {
    "q": "What is the purpose of connection events?",
    "o": [
      "Notify application of state changes",
      "Send user data",
      "Encrypt messages",
      "Compress payloads"
    ]
  },
  {
    "q": "How do persistent connections handle bandwidth limits?",
    "o": [
      "Adaptive bitrate and throttling",
      "Fixed high bandwidth always",
      "No bandwidth management",
      "Random data rates"
    ]
  },
  {
    "q": "What is message queuing in real-time systems?",
    "o": [
      "Buffering messages for delivery",
      "Dropping all messages",
      "Immediate delivery only",
      "Random message selection"
    ]
  },
  {
    "q": "Which pattern handles distributed real-time systems?",
    "o": [
      "Message brokers and event buses",
      "Single server only",
      "No distribution support",
      "Manual data sync"
    ]
  },
  {
    "q": "What is connection health monitoring?",
    "o": [
      "Periodic checks for connection status",
      "No monitoring needed",
      "Manual status checks",
      "Random health checks"
    ]
  },
  {
    "q": "How do real-time apps handle message encryption?",
    "o": [
      "TLS for transport, optional app-level",
      "No encryption support",
      "Encrypt only metadata",
      "Random encryption"
    ]
  },
  {
    "q": "What is the purpose of connection pooling limits?",
    "o": [
      "Prevent resource exhaustion",
      "Allow unlimited connections",
      "Block all connections",
      "Random connection limits"
    ]
  },
  {
    "q": "Which technique handles message replay?",
    "o": [
      "Event sourcing and message logs",
      "No replay capability",
      "Random message selection",
      "Manual replay only"
    ]
  },
  {
    "q": "What is connection lifecycle management?",
    "o": [
      "Handling open, active, and close states",
      "Ignoring connection states",
      "Random state transitions",
      "Manual state control"
    ]
  },
  {
    "q": "How do persistent connections affect mobile networks?",
    "o": [
      "Battery drain and data usage concerns",
      "No impact on mobile",
      "Improved battery life",
      "Reduced data usage"
    ]
  },
  {
    "q": "What is the purpose of message serialization?",
    "o": [
      "Convert data to transmittable format",
      "Encrypt message content",
      "Compress message size",
      "Route to recipients"
    ]
  },
  {
    "q": "Which pattern handles real-time presence?",
    "o": [
      "Heartbeat with last-seen tracking",
      "No presence detection",
      "Manual status updates",
      "Random presence checks"
    ]
  },
  {
    "q": "What is connection resource management?",
    "o": [
      "Allocating and releasing connection resources",
      "Unlimited resource usage",
      "No resource tracking",
      "Random allocation"
    ]
  },
  {
    "q": "How do real-time systems handle message validation?",
    "o": [
      "Schema validation and sanitization",
      "No validation needed",
      "Accept all messages",
      "Random validation"
    ]
  },
  {
    "q": "What is the benefit of connection reuse?",
    "o": [
      "Reduced handshake overhead",
      "Increased latency",
      "More complex code",
      "Higher resource usage"
    ]
  },
  {
    "q": "Which technique ensures real-time data integrity?",
    "o": [
      "Checksums and message validation",
      "No integrity checks",
      "Random validation",
      "Manual verification"
    ]
  },
  {
    "q": "What is connection error handling?",
    "o": [
      "Detecting and recovering from failures",
      "Ignoring all errors",
      "System shutdown on error",
      "Manual error resolution"
    ]
  },
  {
    "q": "How do persistent connections handle protocol upgrades?",
    "o": [
      "Negotiation during handshake",
      "No upgrade support",
      "Forced protocol version",
      "Random protocol selection"
    ]
  },
  {
    "q": "What is the purpose of connection metrics?",
    "o": [
      "Monitor performance and health",
      "Encrypt data",
      "Compress messages",
      "Route packets"
    ]
  },
  {
    "q": "Which pattern handles real-time notifications?",
    "o": [
      "Push notifications via persistent channel",
      "Polling only",
      "Email notifications",
      "Manual refresh"
    ]
  },
  {
    "q": "What is connection security hardening?",
    "o": [
      "TLS, origin validation, and rate limiting",
      "No security measures",
      "Basic authentication only",
      "Random security checks"
    ]
  },
  {
    "q": "How do real-time apps handle message transformation?",
    "o": [
      "Data mapping and format conversion",
      "No transformation needed",
      "Random data changes",
      "Manual conversion"
    ]
  },
  {
    "q": "What is the benefit of persistent connection monitoring?",
    "o": [
      "Early detection of issues",
      "Increased complexity",
      "Higher costs",
      "Slower performance"
    ]
  },
  {
    "q": "Which technique handles connection scaling?",
    "o": [
      "Load balancing and clustering",
      "Single server only",
      "No scaling support",
      "Manual server addition"
    ]
  },
  {
    "q": "What is connection state synchronization?",
    "o": [
      "Keeping connection state consistent across servers",
      "No state tracking needed",
      "Random state updates",
      "Manual state management"
    ]
  },
  {
    "q": "How do real-time systems handle message filtering?",
    "o": [
      "Server-side or client-side filtering rules",
      "No filtering support",
      "Random message selection",
      "Manual filtering only"
    ]
  },
  {
    "q": "What is the purpose of connection diagnostics?",
    "o": [
      "Troubleshoot connection issues",
      "Encrypt messages",
      "Compress data",
      "Route packets"
    ]
  },
  {
    "q": "Which technique handles real-time data aggregation?",
    "o": [
      "Stream processing and windowing",
      "Batch processing only",
      "No aggregation support",
      "Manual calculation"
    ]
  },
  {
    "q": "What is connection failover?",
    "o": [
      "Switching to backup server on failure",
      "Permanent connection loss",
      "No failover mechanism",
      "Manual server switch"
    ]
  },
  {
    "q": "How do persistent connections handle version compatibility?",
    "o": [
      "Protocol version negotiation",
      "Force latest version only",
      "No version checking",
      "Random version selection"
    ]
  },
  {
    "q": "What is the benefit of connection observability?",
    "o": [
      "Visibility into system behavior",
      "Increased complexity",
      "Higher costs",
      "Slower performance"
    ]
  },
  {
    "q": "Which pattern handles real-time event processing?",
    "o": [
      "Event-driven architecture",
      "Batch processing only",
      "No event handling",
      "Manual processing"
    ]
  },
  {
    "q": "What is connection capacity planning?",
    "o": [
      "Estimating resource needs for connections",
      "Unlimited connections always",
      "No planning needed",
      "Random capacity allocation"
    ]
  },
  {
    "q": "How do real-time apps handle message transformation pipelines?",
    "o": [
      "Chained processors and middleware",
      "No transformation support",
      "Single transformation only",
      "Manual processing"
    ]
  },
  {
    "q": "What is the purpose of connection testing?",
    "o": [
      "Validate connection functionality",
      "Slow down connections",
      "Increase latency",
      "Reduce reliability"
    ]
  },
  {
    "q": "How does the WebSocket protocol handle frame masking?",
    "o": [
      "Client frames must be masked, server frames unmasked",
      "All frames must be masked",
      "No frames are masked",
      "Only error frames are masked"
    ]
  },
  {
    "q": "What is the maximum payload size for a WebSocket frame?",
    "o": [
      "2^63 bytes with extended payload length",
      "64 KB maximum",
      "1 MB maximum",
      "No size limit"
    ]
  },
  {
    "q": "Which opcode indicates a text frame in WebSocket?",
    "o": [
      "0x1",
      "0x0",
      "0x2",
      "0x8"
    ]
  },
  {
    "q": "What is the purpose of the FIN bit in WebSocket frames?",
    "o": [
      "Indicates final fragment of a message",
      "Marks frame for deletion",
      "Signals connection close",
      "Enables compression"
    ]
  },
  {
    "q": "How do real-time systems implement message idempotency?",
    "o": [
      "Unique message IDs and deduplication",
      "No idempotency support",
      "Random ID generation",
      "Manual tracking only"
    ]
  },
  {
    "q": "What is the RSV1 bit used for in WebSocket?",
    "o": [
      "Per-message compression extension",
      "Reserved for future use only",
      "Connection encryption",
      "Frame priority"
    ]
  },
  {
    "q": "Which technique prevents WebSocket connection hijacking?",
    "o": [
      "Origin header validation and CSRF tokens",
      "No security needed",
      "Basic authentication only",
      "IP whitelisting only"
    ]
  },
  {
    "q": "What is the purpose of the permessage-deflate extension?",
    "o": [
      "Compress WebSocket messages",
      "Encrypt messages",
      "Route messages",
      "Validate messages"
    ]
  },
  {
    "q": "How do persistent connections handle NAT traversal?",
    "o": [
      "Keep-alive messages and STUN/TURN",
      "No NAT support",
      "Direct connection only",
      "Manual configuration"
    ]
  },
  {
    "q": "What is the close code 1000 in WebSocket?",
    "o": [
      "Normal closure",
      "Protocol error",
      "Unsupported data",
      "Policy violation"
    ]
  },
  {
    "q": "Which pattern handles real-time data replication?",
    "o": [
      "Active-active or active-passive replication",
      "No replication support",
      "Manual data copying",
      "Random replication"
    ]
  },
  {
    "q": "What is connection draining timeout?",
    "o": [
      "Grace period for completing in-flight requests",
      "Immediate connection termination",
      "Infinite wait time",
      "Random timeout value"
    ]
  },
  {
    "q": "How do real-time apps handle schema evolution?",
    "o": [
      "Versioned messages and backward compatibility",
      "No schema changes allowed",
      "Break all clients on change",
      "Manual migration only"
    ]
  },
  {
    "q": "What is the purpose of Sec-WebSocket-Protocol header?",
    "o": [
      "Negotiate application subprotocol",
      "Specify WebSocket version",
      "Define encryption method",
      "Set timeout value"
    ]
  },
  {
    "q": "Which technique handles connection state recovery?",
    "o": [
      "Session resumption with sequence numbers",
      "No recovery possible",
      "Full state retransmission",
      "Manual state rebuild"
    ]
  },
  {
    "q": "What is the close code 1001 in WebSocket?",
    "o": [
      "Going away (server shutdown or browser navigation)",
      "Normal closure",
      "Protocol error",
      "Invalid data"
    ]
  },
  {
    "q": "How do real-time systems handle clock skew?",
    "o": [
      "Logical clocks or vector clocks",
      "Ignore time differences",
      "Force time synchronization",
      "Manual time adjustment"
    ]
  },
  {
    "q": "What is the purpose of connection prewarming?",
    "o": [
      "Establish connections before needed",
      "Close idle connections",
      "Encrypt connections",
      "Monitor connections"
    ]
  },
  {
    "q": "Which opcode indicates a binary frame in WebSocket?",
    "o": [
      "0x2",
      "0x1",
      "0x0",
      "0x8"
    ]
  },
  {
    "q": "What is message causality in distributed real-time systems?",
    "o": [
      "Ordering messages by cause-effect relationships",
      "Random message ordering",
      "Timestamp-based ordering only",
      "No ordering guarantees"
    ]
  },
  {
    "q": "How do persistent connections handle proxy timeouts?",
    "o": [
      "Periodic ping/pong to keep alive",
      "Accept timeout and reconnect",
      "No timeout handling",
      "Disable all proxies"
    ]
  },
  {
    "q": "What is the close code 1002 in WebSocket?",
    "o": [
      "Protocol error",
      "Normal closure",
      "Going away",
      "Invalid data type"
    ]
  },
  {
    "q": "Which technique ensures exactly-once message delivery?",
    "o": [
      "Idempotent operations with deduplication",
      "No delivery guarantees",
      "Send multiple times",
      "Hope for the best"
    ]
  },
  {
    "q": "What is connection affinity persistence?",
    "o": [
      "Maintaining user-server binding across requests",
      "Random server selection",
      "No affinity tracking",
      "Manual server selection"
    ]
  },
  {
    "q": "How do real-time apps handle message replay attacks?",
    "o": [
      "Nonces and timestamp validation",
      "No replay protection",
      "Accept all messages",
      "Random validation"
    ]
  },
  {
    "q": "What is the purpose of the MASK bit in WebSocket?",
    "o": [
      "Indicates if payload is masked",
      "Enables compression",
      "Signals encryption",
      "Marks priority"
    ]
  },
  {
    "q": "Which pattern handles real-time data partitioning?",
    "o": [
      "Sharding by user ID or topic",
      "No partitioning support",
      "Single partition only",
      "Random distribution"
    ]
  },
  {
    "q": "What is connection circuit breaking?",
    "o": [
      "Stop requests to failing service",
      "Break all connections",
      "No failure handling",
      "Random connection drops"
    ]
  },
  {
    "q": "How do persistent connections handle IPv6?",
    "o": [
      "Dual-stack support with fallback",
      "IPv4 only",
      "IPv6 only",
      "No IP version handling"
    ]
  },
  {
    "q": "What is the close code 1003 in WebSocket?",
    "o": [
      "Unsupported data type",
      "Normal closure",
      "Protocol error",
      "Policy violation"
    ]
  },
  {
    "q": "Which technique handles real-time data consistency?",
    "o": [
      "Eventual consistency with conflict resolution",
      "Strong consistency always",
      "No consistency guarantees",
      "Random consistency"
    ]
  },
  {
    "q": "What is connection health scoring?",
    "o": [
      "Metrics-based connection quality assessment",
      "Random health values",
      "Binary healthy/unhealthy",
      "No health tracking"
    ]
  },
  {
    "q": "How do real-time systems handle message ordering across partitions?",
    "o": [
      "Global sequence numbers or timestamps",
      "No cross-partition ordering",
      "Random ordering",
      "Manual sorting"
    ]
  },
  {
    "q": "What is the purpose of connection metadata enrichment?",
    "o": [
      "Add context information to connections",
      "Remove connection data",
      "Encrypt metadata",
      "Compress metadata"
    ]
  },
  {
    "q": "Which opcode indicates a close frame in WebSocket?",
    "o": [
      "0x8",
      "0x1",
      "0x2",
      "0x9"
    ]
  },
  {
    "q": "What is message windowing in real-time systems?",
    "o": [
      "Processing messages in time-based windows",
      "No windowing support",
      "Single message processing",
      "Random grouping"
    ]
  },
  {
    "q": "How do persistent connections handle DNS changes?",
    "o": [
      "Periodic DNS resolution and reconnection",
      "Cache DNS forever",
      "No DNS handling",
      "Manual DNS updates"
    ]
  },
  {
    "q": "What is the close code 1006 in WebSocket?",
    "o": [
      "Abnormal closure (no close frame received)",
      "Normal closure",
      "Protocol error",
      "Policy violation"
    ]
  },
  {
    "q": "Which technique handles real-time data sampling?",
    "o": [
      "Reservoir sampling or probabilistic sampling",
      "No sampling support",
      "Full data processing only",
      "Random selection"
    ]
  },
  {
    "q": "What is connection pooling strategy?",
    "o": [
      "Min/max pool size with idle timeout",
      "Unlimited connections",
      "Single connection only",
      "Random pool size"
    ]
  },
  {
    "q": "How do real-time apps handle message compression?",
    "o": [
      "Per-message or stream compression",
      "No compression support",
      "Compress all data always",
      "Random compression"
    ]
  },
  {
    "q": "What is the purpose of connection tagging?",
    "o": [
      "Label connections for routing and filtering",
      "Encrypt connection data",
      "Compress connection info",
      "Close connections"
    ]
  },
  {
    "q": "Which opcode indicates a ping frame in WebSocket?",
    "o": [
      "0x9",
      "0x8",
      "0xA",
      "0x1"
    ]
  },
  {
    "q": "What is message deduplication window?",
    "o": [
      "Time period for tracking duplicate messages",
      "No deduplication support",
      "Infinite tracking",
      "Random window size"
    ]
  },
  {
    "q": "How do persistent connections handle certificate rotation?",
    "o": [
      "Graceful reconnection with new certificates",
      "Connection failure on rotation",
      "No certificate support",
      "Manual reconnection"
    ]
  },
  {
    "q": "What is the close code 1007 in WebSocket?",
    "o": [
      "Invalid frame payload data",
      "Normal closure",
      "Protocol error",
      "Going away"
    ]
  },
  {
    "q": "Which technique handles real-time data enrichment?",
    "o": [
      "Stream joins and lookups",
      "No enrichment support",
      "Batch enrichment only",
      "Manual data addition"
    ]
  },
  {
    "q": "What is connection lifecycle hooks?",
    "o": [
      "Callbacks for connection events",
      "No event handling",
      "Random callbacks",
      "Manual event tracking"
    ]
  },
  {
    "q": "How do real-time systems handle message batching?",
    "o": [
      "Time-based or size-based batching",
      "No batching support",
      "Single message only",
      "Random batching"
    ]
  },
  {
    "q": "What is the purpose of connection warming?",
    "o": [
      "Pre-establish connections for performance",
      "Cool down connections",
      "Close connections",
      "Monitor connections"
    ]
  },
  {
    "q": "Which opcode indicates a pong frame in WebSocket?",
    "o": [
      "0xA",
      "0x9",
      "0x8",
      "0x1"
    ]
  },
  {
    "q": "What is message correlation in real-time systems?",
    "o": [
      "Linking related messages together",
      "No correlation support",
      "Random message grouping",
      "Manual correlation"
    ]
  },
  {
    "q": "How do persistent connections handle load shedding?",
    "o": [
      "Drop low-priority connections under load",
      "Accept all connections always",
      "Reject all new connections",
      "Random connection drops"
    ]
  },
  {
    "q": "What is the close code 1008 in WebSocket?",
    "o": [
      "Policy violation",
      "Normal closure",
      "Protocol error",
      "Invalid data"
    ]
  },
  {
    "q": "Which technique handles real-time data transformation?",
    "o": [
      "Stream processors and mappers",
      "No transformation support",
      "Batch transformation only",
      "Manual transformation"
    ]
  },
  {
    "q": "What is connection rate limiting strategy?",
    "o": [
      "Token bucket or sliding window",
      "No rate limiting",
      "Block all traffic",
      "Random throttling"
    ]
  },
  {
    "q": "How do real-time apps handle message prioritization?",
    "o": [
      "Priority queues with weighted fair queuing",
      "FIFO only",
      "Random ordering",
      "No prioritization"
    ]
  },
  {
    "q": "What is the purpose of connection observability metrics?",
    "o": [
      "Monitor connection performance and health",
      "Slow down connections",
      "Increase latency",
      "Reduce reliability"
    ]
  },
  {
    "q": "Which pattern handles real-time data aggregation?",
    "o": [
      "Tumbling or sliding windows",
      "No aggregation support",
      "Batch aggregation only",
      "Manual calculation"
    ]
  },
  {
    "q": "What is connection backpressure handling?",
    "o": [
      "Flow control to prevent overwhelming receiver",
      "Send data faster",
      "Drop all messages",
      "No flow control"
    ]
  },
  {
    "q": "How do persistent connections handle multi-region deployment?",
    "o": [
      "Regional routing with failover",
      "Single region only",
      "No multi-region support",
      "Random region selection"
    ]
  },
  {
    "q": "What is the close code 1009 in WebSocket?",
    "o": [
      "Message too big",
      "Normal closure",
      "Protocol error",
      "Policy violation"
    ]
  },
  {
    "q": "Which technique handles real-time data validation?",
    "o": [
      "Schema validation and business rules",
      "No validation needed",
      "Accept all data",
      "Random validation"
    ]
  },
  {
    "q": "What is connection session management?",
    "o": [
      "Tracking user sessions across connections",
      "No session tracking",
      "Random session IDs",
      "Manual session handling"
    ]
  },
  {
    "q": "How do real-time systems handle message expiry?",
    "o": [
      "TTL-based message expiration",
      "Messages never expire",
      "Immediate expiration",
      "Random expiry times"
    ]
  },
  {
    "q": "What is the purpose of connection health checks?",
    "o": [
      "Detect and remove unhealthy connections",
      "Slow down connections",
      "Increase latency",
      "Reduce throughput"
    ]
  },
  {
    "q": "Which pattern handles real-time event sourcing?",
    "o": [
      "Append-only event log with replay",
      "No event storage",
      "Delete events immediately",
      "Random event handling"
    ]
  },
  {
    "q": "What is connection resource quotas?",
    "o": [
      "Limits on connections per user or tenant",
      "Unlimited connections",
      "No quota system",
      "Random limits"
    ]
  },
  {
    "q": "How do persistent connections handle graceful shutdown?",
    "o": [
      "Drain connections and reject new ones",
      "Immediate termination",
      "No shutdown handling",
      "Random connection closure"
    ]
  },
  {
    "q": "What is the close code 1010 in WebSocket?",
    "o": [
      "Mandatory extension not negotiated",
      "Normal closure",
      "Protocol error",
      "Message too big"
    ]
  },
  {
    "q": "Which technique handles real-time data filtering?",
    "o": [
      "Predicate-based filtering",
      "No filtering support",
      "Accept all data",
      "Random filtering"
    ]
  },
  {
    "q": "What is connection authentication refresh?",
    "o": [
      "Periodic token renewal without reconnection",
      "No token refresh",
      "Reconnect for new token",
      "Manual refresh only"
    ]
  },
  {
    "q": "How do real-time apps handle message routing?",
    "o": [
      "Topic-based or content-based routing",
      "Broadcast to all clients",
      "Random routing",
      "No routing support"
    ]
  },
  {
    "q": "What is the purpose of connection tracing?",
    "o": [
      "Track request flow across services",
      "Slow down connections",
      "Increase latency",
      "Reduce performance"
    ]
  },
  {
    "q": "Which pattern handles real-time CQRS?",
    "o": [
      "Separate read and write models",
      "Single model only",
      "No separation",
      "Random model selection"
    ]
  },
  {
    "q": "What is connection retry policy?",
    "o": [
      "Exponential backoff with max retries",
      "Infinite retries",
      "No retry mechanism",
      "Single retry only"
    ]
  },
  {
    "q": "How do persistent connections handle message serialization?",
    "o": [
      "JSON, Protocol Buffers, or MessagePack",
      "Plain text only",
      "No serialization",
      "Random format"
    ]
  },
  {
    "q": "What is the close code 1011 in WebSocket?",
    "o": [
      "Internal server error",
      "Normal closure",
      "Protocol error",
      "Policy violation"
    ]
  },
  {
    "q": "Which technique handles real-time data deduplication?",
    "o": [
      "Hash-based or ID-based deduplication",
      "No deduplication support",
      "Accept duplicates",
      "Random deduplication"
    ]
  },
  {
    "q": "What is connection monitoring dashboards?",
    "o": [
      "Real-time visualization of connection metrics",
      "No monitoring needed",
      "Manual log checking",
      "Random metrics display"
    ]
  },
  {
    "q": "How do real-time systems handle message acknowledgment?",
    "o": [
      "Explicit ACK/NACK messages",
      "No acknowledgment",
      "Assume success always",
      "Random acknowledgment"
    ]
  },
  {
    "q": "What is the purpose of connection pooling optimization?",
    "o": [
      "Balance resource usage and performance",
      "Maximize connections always",
      "Minimize connections always",
      "Random pool size"
    ]
  },
  {
    "q": "Which pattern handles real-time saga orchestration?",
    "o": [
      "Coordinator-based saga pattern",
      "No saga support",
      "Manual orchestration",
      "Random execution"
    ]
  },
  {
    "q": "What is connection failure detection?",
    "o": [
      "Heartbeat timeout and error monitoring",
      "No failure detection",
      "Manual checking",
      "Random detection"
    ]
  },
  {
    "q": "How do persistent connections handle protocol negotiation?",
    "o": [
      "Capability exchange during handshake",
      "No negotiation needed",
      "Force specific protocol",
      "Random protocol selection"
    ]
  },
  {
    "q": "What is the close code 1015 in WebSocket?",
    "o": [
      "TLS handshake failure",
      "Normal closure",
      "Protocol error",
      "Internal error"
    ]
  },
  {
    "q": "Which technique handles real-time data projection?",
    "o": [
      "Materialized views and read models",
      "No projection support",
      "Query raw data only",
      "Random projections"
    ]
  },
  {
    "q": "What is connection security hardening best practices?",
    "o": [
      "TLS 1.3, origin validation, rate limiting",
      "No security needed",
      "Basic auth only",
      "Random security measures"
    ]
  },
  {
    "q": "How do real-time apps handle message fan-out?",
    "o": [
      "Pub/sub with topic subscriptions",
      "Point-to-point only",
      "No fan-out support",
      "Random distribution"
    ]
  },
  {
    "q": "What is the purpose of connection telemetry?",
    "o": [
      "Collect metrics for analysis and debugging",
      "Slow down connections",
      "Increase latency",
      "Reduce performance"
    ]
  },
  {
    "q": "Which pattern handles real-time state machines?",
    "o": [
      "Event-driven state transitions",
      "No state management",
      "Random state changes",
      "Manual state updates"
    ]
  },
  {
    "q": "What is connection capacity management?",
    "o": [
      "Auto-scaling based on connection load",
      "Fixed capacity always",
      "No capacity management",
      "Random scaling"
    ]
  },
  {
    "q": "How do persistent connections handle message encryption?",
    "o": [
      "TLS for transport, E2E for application",
      "No encryption support",
      "Plaintext only",
      "Random encryption"
    ]
  },
  {
    "q": "What is the purpose of connection anomaly detection?",
    "o": [
      "Identify unusual connection patterns",
      "Normal monitoring only",
      "No anomaly detection",
      "Random pattern checking"
    ]
  },
  {
    "q": "Which pattern handles real-time stream processing?",
    "o": [
      "Lambda or Kappa architecture",
      "Batch processing only",
      "No stream processing",
      "Random processing"
    ]
  },
  {
    "q": "What is connection quality of service (QoS)?",
    "o": [
      "Guaranteed delivery and latency levels",
      "No service guarantees",
      "Best-effort only",
      "Random service quality"
    ]
  },
  {
    "q": "How do real-time apps handle message transformation?",
    "o": [
      "Middleware pipelines and adapters",
      "No transformation support",
      "Manual transformation",
      "Random transformation"
    ]
  },
  {
    "q": "What is the purpose of connection audit logging?",
    "o": [
      "Track connection events for compliance",
      "No logging needed",
      "Random log entries",
      "Manual logging"
    ]
  },
  {
    "q": "Which technique handles real-time data lineage?",
    "o": [
      "Metadata tracking and provenance",
      "No lineage tracking",
      "Manual documentation",
      "Random tracking"
    ]
  },
  {
    "q": "What is connection service mesh integration?",
    "o": [
      "Sidecar proxies for connection management",
      "No mesh support",
      "Direct connections only",
      "Random proxy usage"
    ]
  },
  {
    "q": "How does WebSocket frame fragmentation affect performance?",
    "o": [
      "Allows streaming large messages without buffering",
      "Always degrades performance",
      "No performance impact",
      "Blocks all other messages"
    ]
  },
  {
    "q": "What is the purpose of RSV2 and RSV3 bits in WebSocket?",
    "o": [
      "Reserved for future extensions",
      "Compression flags",
      "Priority indicators",
      "Encryption markers"
    ]
  },
  {
    "q": "Which technique optimizes persistent connection memory usage?",
    "o": [
      "Connection pooling with object reuse",
      "Create new objects always",
      "No memory optimization",
      "Random object allocation"
    ]
  },
  {
    "q": "What is connection state machine complexity?",
    "o": [
      "Managing transitions between connection states",
      "No state management needed",
      "Single state only",
      "Random state changes"
    ]
  },
  {
    "q": "How do real-time systems handle distributed tracing?",
    "o": [
      "Trace IDs propagated across services",
      "No tracing support",
      "Local tracing only",
      "Random trace generation"
    ]
  },
  {
    "q": "What is the impact of TCP slow start on WebSocket?",
    "o": [
      "Initial throughput ramp-up period",
      "No impact on performance",
      "Immediate full speed",
      "Random speed changes"
    ]
  },
  {
    "q": "Which pattern handles real-time data reconciliation?",
    "o": [
      "Three-way merge with conflict detection",
      "No reconciliation needed",
      "Last-write-wins only",
      "Random conflict resolution"
    ]
  },
  {
    "q": "What is connection buffer management?",
    "o": [
      "Optimizing send and receive buffer sizes",
      "Unlimited buffer sizes",
      "No buffer management",
      "Random buffer allocation"
    ]
  },
  {
    "q": "How do persistent connections handle TCP keepalive?",
    "o": [
      "OS-level keepalive with custom intervals",
      "No keepalive support",
      "Application-level only",
      "Random keepalive timing"
    ]
  },
  {
    "q": "What is the purpose of connection context propagation?",
    "o": [
      "Pass metadata across service boundaries",
      "No context sharing",
      "Local context only",
      "Random context generation"
    ]
  },
  {
    "q": "Which technique handles real-time data skew?",
    "o": [
      "Watermarking and late data handling",
      "No skew handling",
      "Drop late data always",
      "Random data processing"
    ]
  },
  {
    "q": "What is connection multiplexing overhead?",
    "o": [
      "Frame header and demultiplexing costs",
      "No overhead exists",
      "Zero cost multiplexing",
      "Random overhead"
    ]
  },
  {
    "q": "How do real-time apps handle schema registry?",
    "o": [
      "Centralized schema versioning and validation",
      "No schema management",
      "Local schemas only",
      "Random schema selection"
    ]
  },
  {
    "q": "What is the impact of Nagle's algorithm on WebSocket?",
    "o": [
      "Can introduce latency, often disabled",
      "Always improves performance",
      "No impact on latency",
      "Random performance effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data archival?",
    "o": [
      "Hot-warm-cold tiered storage",
      "No archival support",
      "Delete all old data",
      "Random data retention"
    ]
  },
  {
    "q": "What is connection resource isolation?",
    "o": [
      "Prevent resource exhaustion from single connection",
      "No isolation needed",
      "Share all resources",
      "Random resource allocation"
    ]
  },
  {
    "q": "How do persistent connections handle HTTP/2 upgrade?",
    "o": [
      "Cannot upgrade, use separate connection",
      "Seamless upgrade always",
      "Force HTTP/2 only",
      "Random protocol selection"
    ]
  },
  {
    "q": "What is the purpose of connection admission control?",
    "o": [
      "Limit connections based on capacity",
      "Accept all connections",
      "Reject all connections",
      "Random admission"
    ]
  },
  {
    "q": "Which technique handles real-time data sampling?",
    "o": [
      "Stratified or systematic sampling",
      "No sampling support",
      "Process all data always",
      "Random sampling only"
    ]
  },
  {
    "q": "What is connection latency profiling?",
    "o": [
      "Measuring latency at different stages",
      "No latency tracking",
      "Single latency metric",
      "Random measurements"
    ]
  },
  {
    "q": "How do real-time systems handle clock drift?",
    "o": [
      "NTP synchronization and logical clocks",
      "Ignore clock differences",
      "Manual time adjustment",
      "Random time values"
    ]
  },
  {
    "q": "What is the purpose of connection flow control?",
    "o": [
      "Prevent sender from overwhelming receiver",
      "Send data as fast as possible",
      "No flow control needed",
      "Random data rates"
    ]
  },
  {
    "q": "Which pattern handles real-time data joins?",
    "o": [
      "Stream-stream or stream-table joins",
      "No join support",
      "Batch joins only",
      "Random data combination"
    ]
  },
  {
    "q": "What is connection error budget?",
    "o": [
      "Acceptable error rate for SLA",
      "Zero errors allowed",
      "Unlimited errors",
      "Random error tolerance"
    ]
  },
  {
    "q": "How do persistent connections handle SSL session resumption?",
    "o": [
      "Session tickets or session IDs",
      "Full handshake always",
      "No resumption support",
      "Random resumption"
    ]
  },
  {
    "q": "What is the impact of connection churn?",
    "o": [
      "Frequent connects/disconnects increase load",
      "No impact on system",
      "Improves performance",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data enrichment?",
    "o": [
      "Lookup tables and external API calls",
      "No enrichment support",
      "Static data only",
      "Random data addition"
    ]
  },
  {
    "q": "What is connection performance tuning?",
    "o": [
      "Optimizing buffer sizes and timeouts",
      "Use default settings always",
      "No tuning needed",
      "Random configuration"
    ]
  },
  {
    "q": "How do real-time apps handle message replay?",
    "o": [
      "Event log with offset tracking",
      "No replay capability",
      "Manual replay only",
      "Random message selection"
    ]
  },
  {
    "q": "What is the purpose of connection circuit breaker pattern?",
    "o": [
      "Prevent cascading failures",
      "Break all connections",
      "No failure handling",
      "Random connection drops"
    ]
  },
  {
    "q": "Which pattern handles real-time data partitioning?",
    "o": [
      "Hash-based or range-based partitioning",
      "No partitioning support",
      "Single partition only",
      "Random distribution"
    ]
  },
  {
    "q": "What is connection observability stack?",
    "o": [
      "Metrics, logs, and traces integration",
      "No observability needed",
      "Logs only",
      "Random monitoring"
    ]
  },
  {
    "q": "How do persistent connections handle zero-downtime deployment?",
    "o": [
      "Connection draining and blue-green deployment",
      "Accept downtime always",
      "No deployment strategy",
      "Random deployment"
    ]
  },
  {
    "q": "What is the impact of connection pooling on latency?",
    "o": [
      "Reduces connection establishment latency",
      "Increases latency always",
      "No latency impact",
      "Random latency effects"
    ]
  },
  {
    "q": "Which technique handles real-time data quality?",
    "o": [
      "Validation rules and anomaly detection",
      "No quality checks",
      "Accept all data",
      "Random validation"
    ]
  },
  {
    "q": "What is connection resource accounting?",
    "o": [
      "Track resource usage per connection",
      "No accounting needed",
      "Unlimited resources",
      "Random tracking"
    ]
  },
  {
    "q": "How do real-time systems handle event ordering?",
    "o": [
      "Lamport timestamps or vector clocks",
      "No ordering guarantees",
      "Random ordering",
      "Timestamp-based only"
    ]
  },
  {
    "q": "What is the purpose of connection health scoring?",
    "o": [
      "Prioritize healthy connections for routing",
      "Treat all connections equally",
      "No health tracking",
      "Random routing"
    ]
  },
  {
    "q": "Which pattern handles real-time data lineage?",
    "o": [
      "Metadata tracking through pipeline",
      "No lineage tracking",
      "Manual documentation",
      "Random tracking"
    ]
  },
  {
    "q": "What is connection SLA monitoring?",
    "o": [
      "Track uptime and performance metrics",
      "No SLA tracking",
      "Manual monitoring",
      "Random measurements"
    ]
  },
  {
    "q": "How do persistent connections handle connection migration?",
    "o": [
      "Session transfer to new connection",
      "No migration support",
      "Start fresh always",
      "Random migration"
    ]
  },
  {
    "q": "What is the impact of connection timeout tuning?",
    "o": [
      "Balance resource usage and user experience",
      "Use default always",
      "No timeout needed",
      "Random timeout values"
    ]
  },
  {
    "q": "Which technique handles real-time data aggregation?",
    "o": [
      "Incremental aggregation with state",
      "Recompute from scratch",
      "No aggregation support",
      "Random calculation"
    ]
  },
  {
    "q": "What is connection capacity forecasting?",
    "o": [
      "Predict future connection needs",
      "No forecasting needed",
      "React to issues only",
      "Random capacity planning"
    ]
  },
  {
    "q": "How do real-time apps handle message deduplication?",
    "o": [
      "Bloom filters or hash-based tracking",
      "No deduplication support",
      "Accept duplicates",
      "Random deduplication"
    ]
  },
  {
    "q": "What is the purpose of connection rate shaping?",
    "o": [
      "Smooth traffic bursts over time",
      "Allow all bursts",
      "Block all traffic",
      "Random shaping"
    ]
  },
  {
    "q": "Which pattern handles real-time CQRS?",
    "o": [
      "Separate command and query models",
      "Single model only",
      "No separation needed",
      "Random model selection"
    ]
  },
  {
    "q": "What is connection failover strategy?",
    "o": [
      "Active-passive with automatic failover",
      "No failover support",
      "Manual failover only",
      "Random failover"
    ]
  },
  {
    "q": "How do persistent connections handle protocol buffers?",
    "o": [
      "Binary serialization for efficiency",
      "JSON only",
      "No serialization",
      "Random format"
    ]
  },
  {
    "q": "What is the impact of connection keep-alive on mobile?",
    "o": [
      "Battery drain vs connection reliability tradeoff",
      "No impact on battery",
      "Always beneficial",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data validation?",
    "o": [
      "Schema validation and business rules",
      "No validation needed",
      "Accept all data",
      "Random validation"
    ]
  },
  {
    "q": "What is connection resource quotas enforcement?",
    "o": [
      "Limit connections per tenant or user",
      "Unlimited connections",
      "No quota system",
      "Random limits"
    ]
  },
  {
    "q": "How do real-time systems handle distributed consensus?",
    "o": [
      "Raft or Paxos algorithms",
      "No consensus needed",
      "Manual coordination",
      "Random agreement"
    ]
  },
  {
    "q": "What is the purpose of connection telemetry aggregation?",
    "o": [
      "Combine metrics from multiple sources",
      "No aggregation needed",
      "Single source only",
      "Random aggregation"
    ]
  },
  {
    "q": "Which pattern handles real-time event sourcing?",
    "o": [
      "Append-only log with event replay",
      "No event storage",
      "Delete events immediately",
      "Random event handling"
    ]
  },
  {
    "q": "What is connection security audit?",
    "o": [
      "Regular review of security configurations",
      "No security audits",
      "One-time audit only",
      "Random security checks"
    ]
  },
  {
    "q": "How do persistent connections handle message prioritization?",
    "o": [
      "Priority queues with preemption",
      "FIFO only",
      "Random ordering",
      "No prioritization"
    ]
  },
  {
    "q": "What is the impact of connection pooling on scalability?",
    "o": [
      "Enables handling more concurrent users",
      "Reduces scalability",
      "No scalability impact",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data transformation?",
    "o": [
      "Stream processors with UDFs",
      "No transformation support",
      "Batch transformation only",
      "Random transformation"
    ]
  },
  {
    "q": "What is connection chaos engineering?",
    "o": [
      "Inject failures to test resilience",
      "No failure testing",
      "Production testing only",
      "Random failures"
    ]
  },
  {
    "q": "How do real-time apps handle message routing?",
    "o": [
      "Content-based or topic-based routing",
      "Broadcast to all",
      "Random routing",
      "No routing support"
    ]
  },
  {
    "q": "What is the purpose of connection performance benchmarking?",
    "o": [
      "Establish baseline and track improvements",
      "No benchmarking needed",
      "One-time test only",
      "Random measurements"
    ]
  },
  {
    "q": "Which pattern handles real-time saga pattern?",
    "o": [
      "Choreography or orchestration",
      "No saga support",
      "Manual coordination",
      "Random execution"
    ]
  },
  {
    "q": "What is connection disaster recovery?",
    "o": [
      "Backup systems and failover procedures",
      "No recovery plan",
      "Manual recovery only",
      "Random recovery"
    ]
  },
  {
    "q": "How do persistent connections handle message batching?",
    "o": [
      "Time-based or size-based batching",
      "No batching support",
      "Single message only",
      "Random batching"
    ]
  },
  {
    "q": "What is the impact of connection latency on user experience?",
    "o": [
      "High latency reduces engagement",
      "No impact on users",
      "Always acceptable",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data governance?",
    "o": [
      "Access control and data lineage",
      "No governance needed",
      "Open access always",
      "Random policies"
    ]
  },
  {
    "q": "What is connection auto-scaling strategy?",
    "o": [
      "Scale based on connection count and CPU",
      "Fixed capacity always",
      "No auto-scaling",
      "Random scaling"
    ]
  },
  {
    "q": "How do real-time systems handle message compression?",
    "o": [
      "Per-message or stream compression",
      "No compression support",
      "Compress all data",
      "Random compression"
    ]
  },
  {
    "q": "What is the purpose of connection cost optimization?",
    "o": [
      "Reduce infrastructure and bandwidth costs",
      "Ignore costs",
      "Maximize spending",
      "Random cost management"
    ]
  },
  {
    "q": "Which pattern handles real-time data privacy?",
    "o": [
      "Encryption and data masking",
      "No privacy protection",
      "Plaintext only",
      "Random privacy"
    ]
  },
  {
    "q": "What is connection compliance monitoring?",
    "o": [
      "Ensure adherence to regulations",
      "No compliance needed",
      "Manual checks only",
      "Random monitoring"
    ]
  },
  {
    "q": "How do persistent connections handle message serialization?",
    "o": [
      "Protocol Buffers, Avro, or MessagePack",
      "JSON only",
      "No serialization",
      "Random format"
    ]
  },
  {
    "q": "What is the impact of connection overhead on throughput?",
    "o": [
      "Header overhead reduces effective bandwidth",
      "No impact on throughput",
      "Increases throughput",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data retention?",
    "o": [
      "Time-based or size-based retention policies",
      "Keep all data forever",
      "Delete all data immediately",
      "Random retention"
    ]
  },
  {
    "q": "What is connection service level objectives (SLO)?",
    "o": [
      "Target metrics for service quality",
      "No objectives needed",
      "Best-effort only",
      "Random targets"
    ]
  },
  {
    "q": "How do real-time apps handle message fan-in?",
    "o": [
      "Aggregation from multiple sources",
      "Single source only",
      "No fan-in support",
      "Random aggregation"
    ]
  },
  {
    "q": "What is the purpose of connection incident response?",
    "o": [
      "Rapid detection and resolution of issues",
      "No incident handling",
      "Manual response only",
      "Random response"
    ]
  },
  {
    "q": "Which pattern handles real-time data catalog?",
    "o": [
      "Metadata repository with search",
      "No catalog needed",
      "Manual documentation",
      "Random cataloging"
    ]
  },
  {
    "q": "What is connection capacity testing?",
    "o": [
      "Load testing to find limits",
      "No testing needed",
      "Production testing only",
      "Random testing"
    ]
  },
  {
    "q": "How do persistent connections handle message acknowledgment?",
    "o": [
      "Explicit ACK with retry on timeout",
      "No acknowledgment needed",
      "Assume success always",
      "Random acknowledgment"
    ]
  },
  {
    "q": "What is the impact of connection jitter on real-time apps?",
    "o": [
      "Variable latency affects user experience",
      "No impact on users",
      "Always beneficial",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data masking?",
    "o": [
      "Dynamic masking based on user role",
      "No masking support",
      "Show all data",
      "Random masking"
    ]
  },
  {
    "q": "What is connection change management?",
    "o": [
      "Controlled deployment of connection changes",
      "No change control",
      "Deploy anytime",
      "Random deployments"
    ]
  },
  {
    "q": "How do real-time systems handle message expiration?",
    "o": [
      "TTL with automatic cleanup",
      "Messages never expire",
      "Immediate expiration",
      "Random expiry"
    ]
  },
  {
    "q": "What is the purpose of connection documentation?",
    "o": [
      "Maintain architecture and API docs",
      "No documentation needed",
      "Code comments only",
      "Random documentation"
    ]
  },
  {
    "q": "Which pattern handles real-time data quality monitoring?",
    "o": [
      "Continuous validation and alerting",
      "No quality monitoring",
      "Manual checks only",
      "Random monitoring"
    ]
  },
  {
    "q": "What is connection knowledge base?",
    "o": [
      "Repository of troubleshooting guides",
      "No knowledge base",
      "Tribal knowledge only",
      "Random documentation"
    ]
  },
  {
    "q": "How do persistent connections handle message filtering?",
    "o": [
      "Server-side filtering with subscriptions",
      "No filtering support",
      "Client-side only",
      "Random filtering"
    ]
  },
  {
    "q": "What is the impact of connection security on performance?",
    "o": [
      "TLS adds latency and CPU overhead",
      "No performance impact",
      "Improves performance",
      "Random effects"
    ]
  },
  {
    "q": "Which technique handles real-time data anonymization?",
    "o": [
      "Hashing and pseudonymization",
      "No anonymization support",
      "Show all data",
      "Random anonymization"
    ]
  },
  {
    "q": "What is connection training and onboarding?",
    "o": [
      "Team education on connection management",
      "No training needed",
      "Learn on the job",
      "Random training"
    ]
  },
  {
    "q": "How do real-time apps handle message transformation pipelines?",
    "o": [
      "Chained processors with error handling",
      "No pipeline support",
      "Single transformation",
      "Random processing"
    ]
  },
  {
    "q": "What is the purpose of connection runbooks?",
    "o": [
      "Step-by-step operational procedures",
      "No runbooks needed",
      "Ad-hoc procedures",
      "Random procedures"
    ]
  },
  {
    "q": "Which pattern handles real-time data versioning?",
    "o": [
      "Schema evolution with compatibility checks",
      "No versioning support",
      "Break compatibility freely",
      "Random versioning"
    ]
  },
  {
    "q": "What is connection post-mortem analysis?",
    "o": [
      "Root cause analysis after incidents",
      "No analysis needed",
      "Blame individuals",
      "Random analysis"
    ]
  },
  {
    "q": "How do real-time systems handle distributed transactions?",
    "o": [
      "Two-phase commit or saga pattern",
      "No transaction support",
      "Local transactions only",
      "Random transaction handling"
    ]
  },
  {
    "q": "What is the purpose of connection performance regression testing?",
    "o": [
      "Detect performance degradation over time",
      "No regression testing",
      "One-time test only",
      "Random testing"
    ]
  },
  {
    "q": "Which technique handles real-time data provenance?",
    "o": [
      "Lineage tracking through transformations",
      "No provenance tracking",
      "Manual documentation",
      "Random tracking"
    ]
  },
  {
    "q": "What is connection blue-green deployment?",
    "o": [
      "Run two environments and switch traffic",
      "Single environment only",
      "No deployment strategy",
      "Random deployment"
    ]
  },
  {
    "q": "How do persistent connections handle message ordering guarantees?",
    "o": [
      "Sequence numbers with reordering buffers",
      "No ordering guarantees",
      "Random delivery order",
      "Timestamp-based only"
    ]
  },
  {
    "q": "What is the impact of connection pooling on resource utilization?",
    "o": [
      "Improves efficiency by reusing connections",
      "Wastes resources",
      "No impact on utilization",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data synchronization?",
    "o": [
      "Operational transformation or CRDT",
      "No synchronization support",
      "Manual sync only",
      "Random synchronization"
    ]
  },
  {
    "q": "What is connection canary deployment?",
    "o": [
      "Gradual rollout to subset of users",
      "Deploy to all users immediately",
      "No deployment strategy",
      "Random deployment"
    ]
  },
  {
    "q": "How do real-time apps handle message idempotency?",
    "o": [
      "Unique message IDs with deduplication",
      "No idempotency support",
      "Process duplicates always",
      "Random handling"
    ]
  },
  {
    "q": "What is the purpose of connection feature flags?",
    "o": [
      "Toggle features without deployment",
      "No feature control",
      "Deploy for every change",
      "Random feature activation"
    ]
  },
  {
    "q": "Which technique handles real-time data windowing?",
    "o": [
      "Tumbling, sliding, or session windows",
      "No windowing support",
      "Process all data at once",
      "Random windowing"
    ]
  },
  {
    "q": "What is connection A/B testing?",
    "o": [
      "Compare different connection strategies",
      "No testing needed",
      "Single strategy only",
      "Random testing"
    ]
  },
  {
    "q": "How do persistent connections handle message batching optimization?",
    "o": [
      "Dynamic batch size based on load",
      "Fixed batch size always",
      "No batching support",
      "Random batch sizes"
    ]
  },
  {
    "q": "What is the impact of connection latency on real-time gaming?",
    "o": [
      "High latency causes lag and poor experience",
      "No impact on gameplay",
      "Always acceptable",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data replication?",
    "o": [
      "Master-slave or multi-master replication",
      "No replication support",
      "Manual data copying",
      "Random replication"
    ]
  },
  {
    "q": "What is connection shadow deployment?",
    "o": [
      "Mirror traffic to new version without impact",
      "No shadow testing",
      "Production testing only",
      "Random deployment"
    ]
  },
  {
    "q": "How do real-time systems handle message transformation?",
    "o": [
      "Stream processors with UDFs and mappers",
      "No transformation support",
      "Batch transformation only",
      "Random transformation"
    ]
  },
  {
    "q": "What is the purpose of connection progressive delivery?",
    "o": [
      "Gradual feature rollout with monitoring",
      "Deploy everything at once",
      "No rollout strategy",
      "Random delivery"
    ]
  },
  {
    "q": "Which technique handles real-time data quality assurance?",
    "o": [
      "Continuous validation and monitoring",
      "No quality checks",
      "Manual validation only",
      "Random checking"
    ]
  },
  {
    "q": "What is connection traffic mirroring?",
    "o": [
      "Duplicate traffic for testing or analysis",
      "No traffic duplication",
      "Single traffic path",
      "Random mirroring"
    ]
  },
  {
    "q": "How do persistent connections handle message compression algorithms?",
    "o": [
      "LZ4, Snappy, or GZIP based on use case",
      "No compression support",
      "Single algorithm only",
      "Random compression"
    ]
  },
  {
    "q": "What is the impact of connection security hardening on complexity?",
    "o": [
      "Increases implementation and maintenance effort",
      "Simplifies system",
      "No impact on complexity",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data governance?",
    "o": [
      "Policy enforcement and audit trails",
      "No governance needed",
      "Manual oversight only",
      "Random policies"
    ]
  },
  {
    "q": "What is connection chaos testing?",
    "o": [
      "Inject failures to validate resilience",
      "No failure testing",
      "Production testing only",
      "Random failures"
    ]
  },
  {
    "q": "How do real-time apps handle message fan-out optimization?",
    "o": [
      "Hierarchical distribution or multicast",
      "Sequential delivery only",
      "No optimization",
      "Random distribution"
    ]
  },
  {
    "q": "What is the purpose of connection observability-driven development?",
    "o": [
      "Build with monitoring and debugging in mind",
      "Add observability later",
      "No observability needed",
      "Random monitoring"
    ]
  },
  {
    "q": "Which technique handles real-time data catalog management?",
    "o": [
      "Metadata repository with discovery",
      "No catalog needed",
      "Manual documentation",
      "Random cataloging"
    ]
  },
  {
    "q": "What is connection site reliability engineering (SRE)?",
    "o": [
      "Apply software engineering to operations",
      "Manual operations only",
      "No SRE practices",
      "Random operations"
    ]
  },
  {
    "q": "How do persistent connections handle message routing optimization?",
    "o": [
      "Intelligent routing based on metrics",
      "Random routing only",
      "Single route always",
      "No routing optimization"
    ]
  },
  {
    "q": "What is the impact of connection monitoring on system overhead?",
    "o": [
      "Adds CPU and memory overhead",
      "No overhead exists",
      "Improves performance",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data mesh architecture?",
    "o": [
      "Decentralized domain-oriented data ownership",
      "Centralized data only",
      "No mesh architecture",
      "Random architecture"
    ]
  },
  {
    "q": "What is connection DevOps integration?",
    "o": [
      "Automate deployment and operations",
      "Manual processes only",
      "No automation",
      "Random automation"
    ]
  },
  {
    "q": "How do real-time systems handle message priority inversion?",
    "o": [
      "Priority inheritance or ceiling protocols",
      "No priority handling",
      "FIFO only",
      "Random prioritization"
    ]
  },
  {
    "q": "What is the purpose of connection infrastructure as code?",
    "o": [
      "Version control and automate infrastructure",
      "Manual configuration only",
      "No automation",
      "Random configuration"
    ]
  },
  {
    "q": "Which technique handles real-time data lake integration?",
    "o": [
      "Stream data to lake with partitioning",
      "No lake integration",
      "Batch loading only",
      "Random integration"
    ]
  },
  {
    "q": "What is connection GitOps workflow?",
    "o": [
      "Git as single source of truth for deployment",
      "Manual deployment only",
      "No version control",
      "Random deployment"
    ]
  },
  {
    "q": "How do persistent connections handle message serialization optimization?",
    "o": [
      "Binary formats with schema evolution",
      "JSON only",
      "No optimization",
      "Random serialization"
    ]
  },
  {
    "q": "What is the impact of connection latency percentiles on SLA?",
    "o": [
      "P99 latency often defines user experience",
      "Average latency only matters",
      "No latency tracking",
      "Random metrics"
    ]
  },
  {
    "q": "Which pattern handles real-time data warehouse integration?",
    "o": [
      "Change data capture with streaming ETL",
      "No warehouse integration",
      "Batch loading only",
      "Random integration"
    ]
  },
  {
    "q": "What is connection continuous integration/deployment (CI/CD)?",
    "o": [
      "Automated testing and deployment pipeline",
      "Manual deployment only",
      "No automation",
      "Random deployment"
    ]
  },
  {
    "q": "How do real-time apps handle message deduplication at scale?",
    "o": [
      "Distributed deduplication with sharding",
      "No deduplication support",
      "Single-node deduplication",
      "Random deduplication"
    ]
  },
  {
    "q": "What is the purpose of connection platform engineering?",
    "o": [
      "Build internal developer platforms",
      "No platform needed",
      "Manual tooling only",
      "Random tools"
    ]
  },
  {
    "q": "Which technique handles real-time data observability?",
    "o": [
      "Metrics, logs, traces for data pipelines",
      "No observability needed",
      "Logs only",
      "Random monitoring"
    ]
  },
  {
    "q": "What is connection service mesh benefits?",
    "o": [
      "Traffic management, security, observability",
      "No benefits",
      "Adds complexity only",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message transformation at scale?",
    "o": [
      "Distributed stream processing frameworks",
      "Single-node processing",
      "No transformation support",
      "Random transformation"
    ]
  },
  {
    "q": "What is the impact of connection architecture on maintainability?",
    "o": [
      "Well-designed architecture reduces maintenance",
      "No impact on maintenance",
      "Increases maintenance always",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data quality monitoring?",
    "o": [
      "Continuous validation with alerting",
      "No quality monitoring",
      "Manual checks only",
      "Random monitoring"
    ]
  },
  {
    "q": "What is connection cloud-native architecture?",
    "o": [
      "Designed for cloud scalability and resilience",
      "On-premise only",
      "No cloud support",
      "Random architecture"
    ]
  },
  {
    "q": "How do real-time systems handle message ordering across partitions?",
    "o": [
      "Global ordering with coordination overhead",
      "No cross-partition ordering",
      "Random ordering",
      "Manual sorting"
    ]
  },
  {
    "q": "What is the purpose of connection serverless architecture?",
    "o": [
      "Auto-scaling without server management",
      "Manage servers manually",
      "No auto-scaling",
      "Random scaling"
    ]
  },
  {
    "q": "Which technique handles real-time data lineage tracking?",
    "o": [
      "Metadata propagation through pipeline",
      "No lineage tracking",
      "Manual documentation",
      "Random tracking"
    ]
  },
  {
    "q": "What is connection microservices architecture benefits?",
    "o": [
      "Independent scaling and deployment",
      "No benefits",
      "Monolith is better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message batching at scale?",
    "o": [
      "Distributed batching with coordination",
      "Single-node batching",
      "No batching support",
      "Random batching"
    ]
  },
  {
    "q": "What is the impact of connection design patterns on code quality?",
    "o": [
      "Patterns improve maintainability and clarity",
      "No impact on quality",
      "Reduces code quality",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data federation?",
    "o": [
      "Virtual integration across data sources",
      "No federation support",
      "Physical integration only",
      "Random integration"
    ]
  },
  {
    "q": "What is connection event-driven architecture benefits?",
    "o": [
      "Loose coupling and scalability",
      "No benefits",
      "Tight coupling better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time apps handle message compression at scale?",
    "o": [
      "Distributed compression with load balancing",
      "Single-node compression",
      "No compression support",
      "Random compression"
    ]
  },
  {
    "q": "What is the purpose of connection domain-driven design?",
    "o": [
      "Align architecture with business domains",
      "Technical focus only",
      "No domain modeling",
      "Random design"
    ]
  },
  {
    "q": "Which technique handles real-time data virtualization?",
    "o": [
      "Unified view across disparate sources",
      "No virtualization support",
      "Physical copies only",
      "Random virtualization"
    ]
  },
  {
    "q": "What is connection hexagonal architecture benefits?",
    "o": [
      "Testability and technology independence",
      "No benefits",
      "Tight coupling better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message routing at scale?",
    "o": [
      "Distributed routing with consistent hashing",
      "Single-node routing",
      "No routing support",
      "Random routing"
    ]
  },
  {
    "q": "What is the impact of connection testing strategies on quality?",
    "o": [
      "Comprehensive testing improves reliability",
      "No impact on quality",
      "Testing reduces quality",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data access control?",
    "o": [
      "Role-based or attribute-based access",
      "No access control",
      "Open access always",
      "Random access"
    ]
  },
  {
    "q": "What is connection clean architecture benefits?",
    "o": [
      "Independence and testability",
      "No benefits",
      "Complexity only",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time systems handle message prioritization at scale?",
    "o": [
      "Distributed priority queues",
      "Single-node queues",
      "No prioritization support",
      "Random prioritization"
    ]
  },
  {
    "q": "What is the purpose of connection twelve-factor app principles?",
    "o": [
      "Build portable and scalable applications",
      "No principles needed",
      "Monolithic approach better",
      "Random principles"
    ]
  },
  {
    "q": "Which technique handles real-time data encryption at rest?",
    "o": [
      "Transparent encryption with key management",
      "No encryption support",
      "Plaintext storage only",
      "Random encryption"
    ]
  },
  {
    "q": "What is connection reactive programming benefits?",
    "o": [
      "Handle asynchronous data streams efficiently",
      "No benefits",
      "Blocking I/O better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message filtering at scale?",
    "o": [
      "Distributed filtering with predicate pushdown",
      "Single-node filtering",
      "No filtering support",
      "Random filtering"
    ]
  },
  {
    "q": "What is the impact of connection architectural decisions on TCO?",
    "o": [
      "Architecture affects long-term costs significantly",
      "No impact on costs",
      "Short-term costs only matter",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data masking at scale?",
    "o": [
      "Dynamic masking with policy engine",
      "No masking support",
      "Static masking only",
      "Random masking"
    ]
  },
  {
    "q": "What is connection actor model benefits?",
    "o": [
      "Simplified concurrency and fault tolerance",
      "No benefits",
      "Threads better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time apps handle message aggregation at scale?",
    "o": [
      "Distributed aggregation with state management",
      "Single-node aggregation",
      "No aggregation support",
      "Random aggregation"
    ]
  },
  {
    "q": "What is the purpose of connection SOLID principles?",
    "o": [
      "Write maintainable and extensible code",
      "No principles needed",
      "Tight coupling better",
      "Random principles"
    ]
  },
  {
    "q": "Which technique handles real-time data anonymization at scale?",
    "o": [
      "Distributed anonymization with consistency",
      "Single-node anonymization",
      "No anonymization support",
      "Random anonymization"
    ]
  },
  {
    "q": "What is connection functional programming benefits?",
    "o": [
      "Immutability and easier testing",
      "No benefits",
      "Mutable state better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message transformation at scale?",
    "o": [
      "Distributed transformation with parallelism",
      "Single-node transformation",
      "No transformation support",
      "Random transformation"
    ]
  },
  {
    "q": "What is the impact of connection design on developer productivity?",
    "o": [
      "Good design accelerates development",
      "No impact on productivity",
      "Reduces productivity",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data validation at scale?",
    "o": [
      "Distributed validation with schema registry",
      "Single-node validation",
      "No validation support",
      "Random validation"
    ]
  },
  {
    "q": "What is connection strangler fig pattern benefits?",
    "o": [
      "Gradual migration from legacy systems",
      "No benefits",
      "Big bang migration better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time systems handle message deduplication at scale?",
    "o": [
      "Distributed deduplication with bloom filters",
      "Single-node deduplication",
      "No deduplication support",
      "Random deduplication"
    ]
  },
  {
    "q": "What is the purpose of connection anti-corruption layer?",
    "o": [
      "Isolate from external system changes",
      "Direct integration always",
      "No isolation needed",
      "Random isolation"
    ]
  },
  {
    "q": "Which technique handles real-time data enrichment at scale?",
    "o": [
      "Distributed enrichment with caching",
      "Single-node enrichment",
      "No enrichment support",
      "Random enrichment"
    ]
  },
  {
    "q": "What is connection bulkhead pattern benefits?",
    "o": [
      "Isolate failures to prevent cascading",
      "No benefits",
      "Shared resources better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message routing at scale?",
    "o": [
      "Distributed routing with service discovery",
      "Single-node routing",
      "No routing support",
      "Random routing"
    ]
  },
  {
    "q": "What is the impact of connection patterns on system evolution?",
    "o": [
      "Patterns enable easier system changes",
      "No impact on evolution",
      "Hinders evolution",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data quality at scale?",
    "o": [
      "Distributed quality checks with monitoring",
      "Single-node quality checks",
      "No quality support",
      "Random quality"
    ]
  },
  {
    "q": "What is connection sidecar pattern benefits?",
    "o": [
      "Extend functionality without code changes",
      "No benefits",
      "Direct integration better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time apps handle message fan-out at scale?",
    "o": [
      "Distributed fan-out with pub/sub",
      "Single-node fan-out",
      "No fan-out support",
      "Random fan-out"
    ]
  },
  {
    "q": "What is the purpose of connection ambassador pattern?",
    "o": [
      "Offload network communication concerns",
      "Direct communication always",
      "No offloading needed",
      "Random offloading"
    ]
  },
  {
    "q": "Which technique handles real-time data governance at scale?",
    "o": [
      "Distributed policy enforcement",
      "Single-node governance",
      "No governance support",
      "Random governance"
    ]
  },
  {
    "q": "What is connection adapter pattern benefits?",
    "o": [
      "Integrate incompatible interfaces",
      "No benefits",
      "Direct integration better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message batching optimization at scale?",
    "o": [
      "Adaptive batching based on load patterns",
      "Fixed batching always",
      "No batching support",
      "Random batching"
    ]
  },
  {
    "q": "What is the impact of connection architectural patterns on team productivity?",
    "o": [
      "Shared patterns improve collaboration",
      "No impact on productivity",
      "Reduces productivity",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data catalog at scale?",
    "o": [
      "Distributed metadata management",
      "Single-node catalog",
      "No catalog support",
      "Random cataloging"
    ]
  },
  {
    "q": "What is connection facade pattern benefits?",
    "o": [
      "Simplify complex subsystem interfaces",
      "No benefits",
      "Expose complexity better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time systems handle message compression optimization at scale?",
    "o": [
      "Adaptive compression based on data characteristics",
      "Fixed compression always",
      "No compression support",
      "Random compression"
    ]
  },
  {
    "q": "What is the purpose of connection proxy pattern?",
    "o": [
      "Control access to objects",
      "Direct access always",
      "No access control",
      "Random access"
    ]
  },
  {
    "q": "Which technique handles real-time data lineage at scale?",
    "o": [
      "Distributed lineage tracking with graph database",
      "Single-node lineage",
      "No lineage support",
      "Random lineage"
    ]
  },
  {
    "q": "What is connection decorator pattern benefits?",
    "o": [
      "Add functionality dynamically",
      "No benefits",
      "Static functionality better",
      "Random benefits"
    ]
  },
  {
    "q": "How do persistent connections handle message filtering optimization at scale?",
    "o": [
      "Predicate pushdown and early filtering",
      "Late filtering only",
      "No filtering support",
      "Random filtering"
    ]
  },
  {
    "q": "What is the impact of connection design patterns on code reusability?",
    "o": [
      "Patterns promote reusable components",
      "No impact on reusability",
      "Reduces reusability",
      "Random effects"
    ]
  },
  {
    "q": "Which pattern handles real-time data privacy at scale?",
    "o": [
      "Distributed encryption and access control",
      "Single-node privacy",
      "No privacy support",
      "Random privacy"
    ]
  },
  {
    "q": "What is connection composite pattern benefits?",
    "o": [
      "Treat individual and composite objects uniformly",
      "No benefits",
      "Separate treatment better",
      "Random benefits"
    ]
  },
  {
    "q": "How do real-time apps handle message aggregation optimization at scale?",
    "o": [
      "Incremental aggregation with state checkpointing",
      "Full recomputation always",
      "No aggregation support",
      "Random aggregation"
    ]
  },
  {
    "q": "What is the purpose of connection bridge pattern?",
    "o": [
      "Decouple abstraction from implementation",
      "Tight coupling always",
      "No decoupling needed",
      "Random coupling"
    ]
  }
]
