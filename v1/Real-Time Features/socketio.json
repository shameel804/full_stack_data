[
    {
        "q": "What is Socket.io primarily used for?",
        "o": [
            "Real-time bidirectional communication",
            "Static file hosting",
            "Database management",
            "Image processing"
        ]
    },
    {
        "q": "Which protocol does Socket.io use as its primary transport?",
        "o": [
            "WebSocket",
            "FTP",
            "SMTP",
            "POP3"
        ]
    },
    {
        "q": "What is a namespace in Socket.io?",
        "o": [
            "A communication channel for separating concerns",
            "A type of database",
            "A file storage system",
            "A user authentication method"
        ]
    },
    {
        "q": "What is a room in Socket.io?",
        "o": [
            "A subset of clients for targeted messaging",
            "A physical server location",
            "A type of encryption",
            "A database table"
        ]
    },
    {
        "q": "Which method connects a client to a Socket.io server?",
        "o": [
            "io.connect()",
            "io.start()",
            "io.begin()",
            "io.open()"
        ]
    },
    {
        "q": "What does the emit method do in Socket.io?",
        "o": [
            "Sends an event with data",
            "Closes a connection",
            "Creates a new room",
            "Deletes a namespace"
        ]
    },
    {
        "q": "How do you listen for events in Socket.io?",
        "o": [
            "socket.on()",
            "socket.listen()",
            "socket.hear()",
            "socket.receive()"
        ]
    },
    {
        "q": "What is broadcasting in Socket.io?",
        "o": [
            "Sending data to all connected clients except sender",
            "Sending data to only the sender",
            "Closing all connections",
            "Creating new namespaces"
        ]
    },
    {
        "q": "Which event fires when a client connects to Socket.io?",
        "o": [
            "connection",
            "start",
            "begin",
            "open"
        ]
    },
    {
        "q": "Which event fires when a client disconnects from Socket.io?",
        "o": [
            "disconnect",
            "close",
            "end",
            "stop"
        ]
    },
    {
        "q": "What is the default namespace in Socket.io?",
        "o": [
            "/",
            "*",
            "#",
            "@"
        ]
    },
    {
        "q": "How do you join a room in Socket.io?",
        "o": [
            "socket.join(roomName)",
            "socket.enter(roomName)",
            "socket.add(roomName)",
            "socket.connect(roomName)"
        ]
    },
    {
        "q": "How do you leave a room in Socket.io?",
        "o": [
            "socket.leave(roomName)",
            "socket.exit(roomName)",
            "socket.remove(roomName)",
            "socket.disconnect(roomName)"
        ]
    },
    {
        "q": "Which library is required on the server for Socket.io?",
        "o": [
            "socket.io",
            "socket-client",
            "websocket-server",
            "realtime-io"
        ]
    },
    {
        "q": "Which library is required on the client for Socket.io?",
        "o": [
            "socket.io-client",
            "socket-server",
            "websocket-client",
            "realtime-client"
        ]
    },
    {
        "q": "What does io.to(room) do in Socket.io?",
        "o": [
            "Targets a specific room for emission",
            "Creates a new room",
            "Deletes a room",
            "Lists room members"
        ]
    },
    {
        "q": "What transport does Socket.io fall back to if WebSocket fails?",
        "o": [
            "HTTP long polling",
            "FTP transfer",
            "Email delivery",
            "File upload"
        ]
    },
    {
        "q": "How do you send a message to all clients in Socket.io?",
        "o": [
            "io.emit()",
            "io.send()",
            "io.broadcast()",
            "io.push()"
        ]
    },
    {
        "q": "What is socket.id in Socket.io?",
        "o": [
            "A unique identifier for each connection",
            "The server IP address",
            "The room name",
            "The namespace path"
        ]
    },
    {
        "q": "Which method broadcasts to all except the sender?",
        "o": [
            "socket.broadcast.emit()",
            "socket.all.emit()",
            "socket.others.emit()",
            "socket.except.emit()"
        ]
    },
    {
        "q": "What format does Socket.io use to send data?",
        "o": [
            "JSON",
            "XML",
            "CSV",
            "YAML"
        ]
    },
    {
        "q": "Can Socket.io automatically reconnect after disconnection?",
        "o": [
            "Yes, by default",
            "No, never",
            "Only on mobile devices",
            "Only with paid version"
        ]
    },
    {
        "q": "What does socket.disconnect() do?",
        "o": [
            "Closes the connection",
            "Joins a room",
            "Creates a namespace",
            "Sends a message"
        ]
    },
    {
        "q": "How many namespaces can Socket.io have?",
        "o": [
            "Unlimited",
            "Only one",
            "Maximum five",
            "Maximum ten"
        ]
    },
    {
        "q": "How many rooms can Socket.io have?",
        "o": [
            "Unlimited",
            "Only one",
            "Maximum five",
            "Maximum ten"
        ]
    },
    {
        "q": "What is the purpose of acknowledgements in Socket.io?",
        "o": [
            "Confirm message receipt",
            "Encrypt messages",
            "Compress data",
            "Log errors"
        ]
    },
    {
        "q": "Which port does Socket.io typically use?",
        "o": [
            "Same as HTTP server",
            "Port 21",
            "Port 25",
            "Port 110"
        ]
    },
    {
        "q": "What does io.of() create in Socket.io?",
        "o": [
            "A new namespace",
            "A new room",
            "A new server",
            "A new client"
        ]
    },
    {
        "q": "Can a socket be in multiple rooms simultaneously?",
        "o": [
            "Yes",
            "No",
            "Only two rooms",
            "Only three rooms"
        ]
    },
    {
        "q": "What happens when you emit to a non-existent room?",
        "o": [
            "Nothing, no error thrown",
            "Server crashes",
            "Error is thrown",
            "Room is auto-created"
        ]
    },
    {
        "q": "Which company originally developed Socket.io?",
        "o": [
            "Automattic",
            "Google",
            "Facebook",
            "Microsoft"
        ]
    },
    {
        "q": "What language is Socket.io primarily written in?",
        "o": [
            "JavaScript",
            "Python",
            "Java",
            "C++"
        ]
    },
    {
        "q": "Which runtime is required for Socket.io server?",
        "o": [
            "Node.js",
            "Python",
            "Ruby",
            "PHP"
        ]
    },
    {
        "q": "What is the reserved event name for errors in Socket.io?",
        "o": [
            "error",
            "fail",
            "exception",
            "problem"
        ]
    },
    {
        "q": "Can Socket.io send binary data?",
        "o": [
            "Yes",
            "No",
            "Only text",
            "Only JSON"
        ]
    },
    {
        "q": "What does volatile emission mean in Socket.io?",
        "o": [
            "Message may be dropped if not deliverable",
            "Message is encrypted",
            "Message is compressed",
            "Message is logged"
        ]
    },
    {
        "q": "How do you create a volatile emit in Socket.io?",
        "o": [
            "socket.volatile.emit()",
            "socket.temp.emit()",
            "socket.fast.emit()",
            "socket.quick.emit()"
        ]
    },
    {
        "q": "What is the purpose of middleware in Socket.io?",
        "o": [
            "Intercept and process events",
            "Store data permanently",
            "Create databases",
            "Generate reports"
        ]
    },
    {
        "q": "How do you add middleware in Socket.io?",
        "o": [
            "io.use()",
            "io.add()",
            "io.insert()",
            "io.attach()"
        ]
    },
    {
        "q": "What does socket.handshake contain?",
        "o": [
            "Connection details and headers",
            "Message history",
            "Room list",
            "Error logs"
        ]
    },
    {
        "q": "Can Socket.io work behind a load balancer?",
        "o": [
            "Yes, with sticky sessions",
            "No, never",
            "Only with one server",
            "Only on localhost"
        ]
    },
    {
        "q": "What adapter does Socket.io use by default?",
        "o": [
            "In-memory adapter",
            "Redis adapter",
            "MongoDB adapter",
            "PostgreSQL adapter"
        ]
    },
    {
        "q": "Why would you use Redis adapter with Socket.io?",
        "o": [
            "For multi-server scaling",
            "For data encryption",
            "For logging",
            "For testing"
        ]
    },
    {
        "q": "What is the connect_error event used for?",
        "o": [
            "Handle connection failures",
            "Join rooms",
            "Send messages",
            "Create namespaces"
        ]
    },
    {
        "q": "How do you get all sockets in a room?",
        "o": [
            "io.in(room).fetchSockets()",
            "io.room(room).getSockets()",
            "io.get(room).sockets()",
            "io.find(room).list()"
        ]
    },
    {
        "q": "What does socket.rooms return?",
        "o": [
            "Set of rooms the socket is in",
            "Total room count",
            "Room configuration",
            "Room creation date"
        ]
    },
    {
        "q": "Can you send custom events in Socket.io?",
        "o": [
            "Yes, any event name",
            "No, only predefined events",
            "Only five custom events",
            "Only ten custom events"
        ]
    },
    {
        "q": "What is the reconnection option in Socket.io?",
        "o": [
            "Enable or disable auto-reconnect",
            "Set room limits",
            "Configure namespaces",
            "Define message format"
        ]
    },
    {
        "q": "What is reconnectionAttempts option?",
        "o": [
            "Number of reconnection tries",
            "Message retry count",
            "Room join attempts",
            "Namespace creation limit"
        ]
    },
    {
        "q": "What is reconnectionDelay option?",
        "o": [
            "Time between reconnection attempts",
            "Message send delay",
            "Room creation interval",
            "Namespace timeout"
        ]
    },
    {
        "q": "What does the timeout option control?",
        "o": [
            "Connection timeout duration",
            "Message size limit",
            "Room capacity",
            "Namespace count"
        ]
    },
    {
        "q": "How do you pass query parameters when connecting?",
        "o": [
            "io.connect(url, {query: params})",
            "io.connect(url, {data: params})",
            "io.connect(url, {body: params})",
            "io.connect(url, {form: params})"
        ]
    },
    {
        "q": "What is the auth option used for?",
        "o": [
            "Send authentication credentials",
            "Configure encryption",
            "Set room permissions",
            "Define namespace access"
        ]
    },
    {
        "q": "How do you access auth data on the server?",
        "o": [
            "socket.handshake.auth",
            "socket.credentials",
            "socket.login",
            "socket.user"
        ]
    },
    {
        "q": "What is the path option in Socket.io?",
        "o": [
            "URL path for Socket.io requests",
            "File storage location",
            "Database path",
            "Log file path"
        ]
    },
    {
        "q": "What is the default path for Socket.io?",
        "o": [
            "/socket.io/",
            "/ws/",
            "/realtime/",
            "/live/"
        ]
    },
    {
        "q": "Can you change the default path in Socket.io?",
        "o": [
            "Yes",
            "No",
            "Only on server",
            "Only on client"
        ]
    },
    {
        "q": "What does transports option specify?",
        "o": [
            "Communication methods to use",
            "Data encoding format",
            "Room configuration",
            "Namespace settings"
        ]
    },
    {
        "q": "What are the available transports in Socket.io?",
        "o": [
            "polling and websocket",
            "http and https",
            "tcp and udp",
            "ftp and sftp"
        ]
    },
    {
        "q": "How do you force WebSocket only transport?",
        "o": [
            "transports: ['websocket']",
            "transport: 'ws'",
            "mode: 'websocket'",
            "protocol: 'ws'"
        ]
    },
    {
        "q": "What is the upgrade option in Socket.io?",
        "o": [
            "Allow transport upgrade from polling",
            "Update Socket.io version",
            "Increase room capacity",
            "Expand namespace limit"
        ]
    },
    {
        "q": "What does rememberUpgrade option do?",
        "o": [
            "Skip polling for reconnections",
            "Save message history",
            "Store room data",
            "Cache namespace info"
        ]
    },
    {
        "q": "What is the forceNew option?",
        "o": [
            "Create new connection instead of reusing",
            "Force message delivery",
            "Create new room",
            "Generate new namespace"
        ]
    },
    {
        "q": "What is multiplex option used for?",
        "o": [
            "Share connection across namespaces",
            "Send multiple messages",
            "Join multiple rooms",
            "Connect multiple servers"
        ]
    },
    {
        "q": "How do you disconnect all sockets in a room?",
        "o": [
            "io.in(room).disconnectSockets()",
            "io.room(room).closeAll()",
            "io.get(room).end()",
            "io.find(room).stop()"
        ]
    },
    {
        "q": "What does socket.compress() do?",
        "o": [
            "Enable compression for the packet",
            "Reduce room size",
            "Minimize namespace count",
            "Shorten message length"
        ]
    },
    {
        "q": "What is the perMessageDeflate option?",
        "o": [
            "WebSocket compression setting",
            "Message rate limit",
            "Room capacity",
            "Namespace timeout"
        ]
    },
    {
        "q": "Can Socket.io work with Express.js?",
        "o": [
            "Yes",
            "No",
            "Only with older versions",
            "Only with paid license"
        ]
    },
    {
        "q": "How do you attach Socket.io to an Express server?",
        "o": [
            "Pass HTTP server to Socket.io",
            "Use middleware",
            "Add route handler",
            "Configure proxy"
        ]
    },
    {
        "q": "What is socket.data used for?",
        "o": [
            "Store custom data on socket",
            "Send message payload",
            "Configure connection",
            "Define room settings"
        ]
    },
    {
        "q": "Can you emit to a specific socket by ID?",
        "o": [
            "Yes, using io.to(id).emit()",
            "No, not possible",
            "Only in rooms",
            "Only in namespaces"
        ]
    },
    {
        "q": "What is the except method used for?",
        "o": [
            "Exclude sockets from broadcast",
            "Filter message content",
            "Remove room members",
            "Delete namespace"
        ]
    },
    {
        "q": "How do you emit to all except specific rooms?",
        "o": [
            "io.except(room).emit()",
            "io.without(room).emit()",
            "io.skip(room).emit()",
            "io.minus(room).emit()"
        ]
    },
    {
        "q": "What is socket.once() used for?",
        "o": [
            "Listen for event only once",
            "Send message once",
            "Join room once",
            "Connect once"
        ]
    },
    {
        "q": "How do you remove an event listener?",
        "o": [
            "socket.off(event)",
            "socket.remove(event)",
            "socket.delete(event)",
            "socket.clear(event)"
        ]
    },
    {
        "q": "What does socket.removeAllListeners() do?",
        "o": [
            "Remove all event handlers",
            "Disconnect all clients",
            "Delete all rooms",
            "Clear all namespaces"
        ]
    },
    {
        "q": "Can Socket.io work over HTTPS?",
        "o": [
            "Yes",
            "No",
            "Only HTTP",
            "Only WebSocket"
        ]
    },
    {
        "q": "What is the purpose of pingTimeout?",
        "o": [
            "Time to wait for pong response",
            "Message send timeout",
            "Room join timeout",
            "Namespace creation timeout"
        ]
    },
    {
        "q": "What is the purpose of pingInterval?",
        "o": [
            "Time between ping packets",
            "Message send interval",
            "Room cleanup interval",
            "Namespace check interval"
        ]
    },
    {
        "q": "What happens if pong is not received in time?",
        "o": [
            "Connection is closed",
            "Message is retried",
            "Room is deleted",
            "Namespace is reset"
        ]
    },
    {
        "q": "What is the maxHttpBufferSize option?",
        "o": [
            "Maximum packet size in bytes",
            "Maximum room count",
            "Maximum namespace count",
            "Maximum client count"
        ]
    },
    {
        "q": "What is the allowEIO3 option?",
        "o": [
            "Allow Engine.IO v3 clients",
            "Allow three connections",
            "Enable third namespace",
            "Allow three rooms"
        ]
    },
    {
        "q": "What is Engine.IO in Socket.io?",
        "o": [
            "Low-level transport layer",
            "Database engine",
            "Template engine",
            "Search engine"
        ]
    },
    {
        "q": "What does socket.connected property return?",
        "o": [
            "Boolean indicating connection status",
            "Connection timestamp",
            "Server address",
            "Client ID"
        ]
    },
    {
        "q": "What does socket.disconnected property return?",
        "o": [
            "Boolean indicating disconnection status",
            "Disconnection reason",
            "Time since disconnect",
            "Reconnection attempts"
        ]
    },
    {
        "q": "What is the purpose of socket.io-parser?",
        "o": [
            "Encode and decode Socket.io packets",
            "Parse JSON data",
            "Format messages",
            "Validate room names"
        ]
    },
    {
        "q": "Can you use TypeScript with Socket.io?",
        "o": [
            "Yes, it has type definitions",
            "No",
            "Only JavaScript",
            "Only CoffeeScript"
        ]
    },
    {
        "q": "What is the reconnecting event?",
        "o": [
            "Fired when attempting to reconnect",
            "Fired when connected",
            "Fired when message sent",
            "Fired when room joined"
        ]
    },
    {
        "q": "What is the reconnect event?",
        "o": [
            "Fired after successful reconnection",
            "Fired before reconnect attempt",
            "Fired on connection error",
            "Fired on message error"
        ]
    },
    {
        "q": "What is the reconnect_attempt event?",
        "o": [
            "Fired for each reconnection attempt",
            "Fired once on reconnection",
            "Fired on successful connect",
            "Fired on disconnect"
        ]
    },
    {
        "q": "What is the reconnect_error event?",
        "o": [
            "Fired when reconnection attempt fails",
            "Fired on successful reconnect",
            "Fired on initial connect",
            "Fired on message send"
        ]
    },
    {
        "q": "What is the reconnect_failed event?",
        "o": [
            "Fired when all reconnection attempts fail",
            "Fired on first failed attempt",
            "Fired on successful reconnect",
            "Fired on disconnect"
        ]
    },
    {
        "q": "What does the autoConnect option control?",
        "o": [
            "Whether to connect immediately",
            "Auto-join rooms",
            "Auto-create namespaces",
            "Auto-send messages"
        ]
    },
    {
        "q": "How do you manually connect with autoConnect false?",
        "o": [
            "socket.connect()",
            "socket.start()",
            "socket.begin()",
            "socket.open()"
        ]
    },
    {
        "q": "What is the serverSideEmit method?",
        "o": [
            "Emit to other server instances",
            "Emit to clients",
            "Emit to rooms",
            "Emit to namespaces"
        ]
    },
    {
        "q": "What is the fetchSockets method?",
        "o": [
            "Get matching sockets across servers",
            "Download socket data",
            "Load socket history",
            "Import socket config"
        ]
    },
    {
        "q": "What is the socketsJoin method?",
        "o": [
            "Make matching sockets join a room",
            "Connect sockets to server",
            "Link sockets together",
            "Merge socket data"
        ]
    },
    {
        "q": "What is the socketsLeave method?",
        "o": [
            "Make matching sockets leave a room",
            "Disconnect sockets",
            "Remove socket data",
            "Delete socket config"
        ]
    },
    {
        "q": "How do you handle authentication failure in Socket.io middleware?",
        "o": [
            "Call next with an error object",
            "Return false",
            "Throw an exception",
            "Call reject()"
        ]
    },
    {
        "q": "What does the catchAll listener do in Socket.io?",
        "o": [
            "Listens to all incoming events",
            "Catches all errors",
            "Intercepts all broadcasts",
            "Monitors all rooms"
        ]
    },
    {
        "q": "How do you register a catchAll listener?",
        "o": [
            "socket.onAny()",
            "socket.all()",
            "socket.every()",
            "socket.catch()"
        ]
    },
    {
        "q": "What does socket.prependAny() do?",
        "o": [
            "Adds catchAll listener at beginning",
            "Prepends data to messages",
            "Adds prefix to events",
            "Inserts room at start"
        ]
    },
    {
        "q": "How do you emit with acknowledgement in Socket.io?",
        "o": [
            "socket.emit(event, data, callback)",
            "socket.emitAck(event, data)",
            "socket.sendAck(event, data)",
            "socket.ack(event, data)"
        ]
    },
    {
        "q": "What is the timeout option for acknowledgements?",
        "o": [
            "Maximum wait time for response",
            "Retry interval",
            "Buffer duration",
            "Connection delay"
        ]
    },
    {
        "q": "How do you emit with timeout in Socket.io?",
        "o": [
            "socket.timeout(ms).emit()",
            "socket.emit().timeout(ms)",
            "socket.delay(ms).emit()",
            "socket.wait(ms).emit()"
        ]
    },
    {
        "q": "What happens when acknowledgement times out?",
        "o": [
            "Error callback is invoked",
            "Message is resent",
            "Connection is closed",
            "Server is notified"
        ]
    },
    {
        "q": "What is the local flag in broadcasting?",
        "o": [
            "Broadcast only to local node",
            "Use local storage",
            "Send to localhost",
            "Enable local cache"
        ]
    },
    {
        "q": "How do you use the local flag?",
        "o": [
            "io.local.emit()",
            "io.here.emit()",
            "io.this.emit()",
            "io.node.emit()"
        ]
    },
    {
        "q": "What is connection state recovery in Socket.io?",
        "o": [
            "Restore state after brief disconnection",
            "Recover from server crash",
            "Restore saved messages",
            "Rebuild room structure"
        ]
    },
    {
        "q": "Which option enables connection state recovery?",
        "o": [
            "connectionStateRecovery",
            "stateRecovery",
            "reconnectState",
            "persistState"
        ]
    },
    {
        "q": "What does socket.recovered property indicate?",
        "o": [
            "If previous state was restored",
            "If error was fixed",
            "If room was rejoined",
            "If namespace was found"
        ]
    },
    {
        "q": "What is the purpose of the adapter in Socket.io?",
        "o": [
            "Manage room and namespace data",
            "Convert data formats",
            "Handle authentication",
            "Compress messages"
        ]
    },
    {
        "q": "Which adapter is used for horizontal scaling?",
        "o": [
            "Redis adapter",
            "Memory adapter",
            "File adapter",
            "SQL adapter"
        ]
    },
    {
        "q": "How do you install the Redis adapter?",
        "o": [
            "npm install @socket.io/redis-adapter",
            "npm install socket.io-redis",
            "npm install redis-socket",
            "npm install io-redis"
        ]
    },
    {
        "q": "What is the MongoDB adapter used for?",
        "o": [
            "Multi-server synchronization",
            "Data storage",
            "User management",
            "Session handling"
        ]
    },
    {
        "q": "What is the Postgres adapter benefit?",
        "o": [
            "Use existing database for scaling",
            "SQL query support",
            "Transaction handling",
            "Schema validation"
        ]
    },
    {
        "q": "What is the cluster adapter?",
        "o": [
            "Sync between Node.js cluster workers",
            "Group servers together",
            "Create server clusters",
            "Manage room clusters"
        ]
    },
    {
        "q": "How do you implement a custom adapter?",
        "o": [
            "Extend the Adapter class",
            "Create adapter function",
            "Override io.adapter",
            "Plugin system"
        ]
    },
    {
        "q": "What method broadcasts to other servers only?",
        "o": [
            "serverSideEmit",
            "remoteEmit",
            "crossEmit",
            "clusterEmit"
        ]
    },
    {
        "q": "How do you listen for server events?",
        "o": [
            "io.on(event, callback)",
            "io.server(event)",
            "io.listen(event)",
            "io.receive(event)"
        ]
    },
    {
        "q": "What is the connectTimeout option?",
        "o": [
            "Max time to establish connection",
            "Message send timeout",
            "Room join delay",
            "Ping interval"
        ]
    },
    {
        "q": "What does the closeOnBeforeunload option do?",
        "o": [
            "Close connection when leaving page",
            "Save state before closing",
            "Send final message",
            "Clear local storage"
        ]
    },
    {
        "q": "What is withCredentials option for?",
        "o": [
            "Include cookies in requests",
            "Add authentication token",
            "Enable TLS",
            "Set API key"
        ]
    },
    {
        "q": "How do you configure extra headers?",
        "o": [
            "extraHeaders option",
            "headers option",
            "customHeaders option",
            "addHeaders option"
        ]
    },
    {
        "q": "What is the timestampRequests option?",
        "o": [
            "Add timestamp to polling requests",
            "Log request times",
            "Set message timestamps",
            "Record join times"
        ]
    },
    {
        "q": "What is the timestampParam option?",
        "o": [
            "Name of timestamp query parameter",
            "Timestamp format",
            "Time zone setting",
            "Date format string"
        ]
    },
    {
        "q": "What does io.engine refer to?",
        "o": [
            "Underlying Engine.IO server",
            "JavaScript engine",
            "Template engine",
            "Database engine"
        ]
    },
    {
        "q": "How do you access Engine.IO from client?",
        "o": [
            "socket.io.engine",
            "socket.engine",
            "socket.transport",
            "socket.connection"
        ]
    },
    {
        "q": "What event indicates transport upgrade?",
        "o": [
            "upgrade",
            "change",
            "switch",
            "transform"
        ]
    },
    {
        "q": "How do you check current transport?",
        "o": [
            "socket.io.engine.transport.name",
            "socket.transport",
            "socket.protocol",
            "socket.method"
        ]
    },
    {
        "q": "What is the serveClient option?",
        "o": [
            "Serve client library from server",
            "Create client connection",
            "Manage client state",
            "Handle client errors"
        ]
    },
    {
        "q": "How do you disable serving client code?",
        "o": [
            "serveClient: false",
            "noClient: true",
            "clientServe: false",
            "disableClient: true"
        ]
    },
    {
        "q": "What is the cors option for?",
        "o": [
            "Configure cross-origin requests",
            "Enable encryption",
            "Set up proxying",
            "Define routing"
        ]
    },
    {
        "q": "How do you allow all origins in Socket.io?",
        "o": [
            "cors: {origin: '*'}",
            "allowOrigin: 'all'",
            "origins: '*'",
            "access: 'any'"
        ]
    },
    {
        "q": "What does allowUpgrades option control?",
        "o": [
            "Transport upgrade permission",
            "Library version updates",
            "Room capacity increase",
            "Namespace expansion"
        ]
    },
    {
        "q": "What is httpCompression option?",
        "o": [
            "Compress HTTP polling responses",
            "Reduce HTTP header size",
            "Minimize request count",
            "Optimize URL length"
        ]
    },
    {
        "q": "What is the cookie option in Socket.io?",
        "o": [
            "HTTP cookie configuration",
            "Session storage",
            "Data persistence",
            "Cache settings"
        ]
    },
    {
        "q": "How do you disable cookies in Socket.io?",
        "o": [
            "cookie: false",
            "noCookie: true",
            "cookies: disabled",
            "disableCookies: true"
        ]
    },
    {
        "q": "What is the addTrailingSlash option?",
        "o": [
            "Append slash to namespace",
            "Add slash to room names",
            "Include slash in events",
            "Append slash to data"
        ]
    },
    {
        "q": "What does destroyUpgrade option do?",
        "o": [
            "Destroy upgrade requests not handled",
            "Remove transport after upgrade",
            "Delete old connections",
            "Clear upgrade cache"
        ]
    },
    {
        "q": "What is destroyUpgradeTimeout?",
        "o": [
            "Time before destroying upgrade",
            "Upgrade completion timeout",
            "Transport switch delay",
            "Connection change interval"
        ]
    },
    {
        "q": "How do you implement private messaging?",
        "o": [
            "Emit to specific socket ID",
            "Create private rooms only",
            "Use encrypted channels",
            "Enable private mode"
        ]
    },
    {
        "q": "What is a common pattern for user rooms?",
        "o": [
            "Room named after user ID",
            "Random room assignment",
            "Alphabetical grouping",
            "IP-based rooms"
        ]
    },
    {
        "q": "How do you implement typing indicators?",
        "o": [
            "Emit typing event to room",
            "Use polling for status",
            "Query server regularly",
            "Store in database"
        ]
    },
    {
        "q": "What is a good practice for chat rooms?",
        "o": [
            "Use room ID as room name",
            "Use random room names",
            "Number rooms sequentially",
            "Name rooms by time"
        ]
    },
    {
        "q": "How do you track online users?",
        "o": [
            "Maintain user list on server",
            "Use browser storage",
            "Query database each time",
            "Count room members only"
        ]
    },
    {
        "q": "What is a good disconnect handling pattern?",
        "o": [
            "Update status and notify others",
            "Immediately delete user data",
            "Ignore disconnect events",
            "Wait indefinitely for reconnect"
        ]
    },
    {
        "q": "How do you implement read receipts?",
        "o": [
            "Emit read event when message viewed",
            "Use acknowledgements only",
            "Poll server for status",
            "Store in local storage"
        ]
    },
    {
        "q": "What is a common emit error pattern?",
        "o": [
            "Use acknowledgement callbacks",
            "Ignore all errors",
            "Retry infinitely",
            "Close connection on error"
        ]
    },
    {
        "q": "How do you handle slow clients?",
        "o": [
            "Buffer messages temporarily",
            "Disconnect slow clients",
            "Ignore message queue",
            "Reduce message rate globally"
        ]
    },
    {
        "q": "What is event namespacing best practice?",
        "o": [
            "Use clear descriptive names",
            "Use single character events",
            "Use numbered events",
            "Use random event names"
        ]
    },
    {
        "q": "How do you structure event data?",
        "o": [
            "Use consistent object format",
            "Send primitive values only",
            "Use arrays exclusively",
            "Avoid structured data"
        ]
    },
    {
        "q": "What is a good reconnection strategy?",
        "o": [
            "Exponential backoff",
            "Constant interval",
            "Immediate retry flood",
            "Manual reconnect only"
        ]
    },
    {
        "q": "How do you test Socket.io connections?",
        "o": [
            "Use socket.io-client in tests",
            "Only manual testing",
            "Browser testing only",
            "No testing possible"
        ]
    },
    {
        "q": "What is a common authentication pattern?",
        "o": [
            "Token in auth handshake option",
            "Send password first",
            "Include in every message",
            "Authentication not possible"
        ]
    },
    {
        "q": "How do you handle token expiration?",
        "o": [
            "Disconnect and reconnect with new token",
            "Tokens never expire",
            "Send new token as message",
            "Wait for server to refresh"
        ]
    },
    {
        "q": "What is room-based authorization?",
        "o": [
            "Check permissions before joining room",
            "All rooms are public",
            "Rooms have passwords",
            "Only admin creates rooms"
        ]
    },
    {
        "q": "How do you implement rate limiting?",
        "o": [
            "Track events per socket in middleware",
            "Limit at transport level",
            "No rate limiting possible",
            "Use external service only"
        ]
    },
    {
        "q": "What is message validation best practice?",
        "o": [
            "Validate all incoming data",
            "Trust all client data",
            "Validate on client only",
            "Skip validation for speed"
        ]
    },
    {
        "q": "How do you prevent injection attacks?",
        "o": [
            "Sanitize all user input",
            "Block special characters",
            "Limit message length only",
            "Use encryption"
        ]
    },
    {
        "q": "What is a denial of service protection?",
        "o": [
            "Limit connections per IP",
            "Allow unlimited connections",
            "Ignore connection count",
            "Manual IP blocking only"
        ]
    },
    {
        "q": "How do you log Socket.io events?",
        "o": [
            "Add logging in middleware",
            "Logging not supported",
            "Only log errors",
            "Use console.log only"
        ]
    },
    {
        "q": "What is DEBUG environment variable?",
        "o": [
            "Enable Socket.io debug output",
            "Set debug mode",
            "Configure debugger",
            "Enable breakpoints"
        ]
    },
    {
        "q": "How do you enable debug logging?",
        "o": [
            "DEBUG=socket.io:* npm start",
            "LOG=true npm start",
            "VERBOSE=1 npm start",
            "--debug flag"
        ]
    },
    {
        "q": "What is socket.io-admin-ui?",
        "o": [
            "Admin dashboard for Socket.io",
            "User interface builder",
            "Admin user management",
            "UI testing tool"
        ]
    },
    {
        "q": "How do you monitor Socket.io performance?",
        "o": [
            "Use admin UI or custom metrics",
            "Not possible to monitor",
            "Check server logs only",
            "Count messages manually"
        ]
    },
    {
        "q": "What metrics should you track?",
        "o": [
            "Connection count and message rate",
            "CPU usage only",
            "Memory only",
            "Disk space only"
        ]
    },
    {
        "q": "How do you handle memory leaks?",
        "o": [
            "Clean up listeners on disconnect",
            "Restart server regularly",
            "Ignore memory issues",
            "Increase server RAM"
        ]
    },
    {
        "q": "What causes listener memory leaks?",
        "o": [
            "Not removing listeners on disconnect",
            "Too many rooms",
            "Large messages",
            "Long event names"
        ]
    },
    {
        "q": "How do you optimize for many rooms?",
        "o": [
            "Use Redis adapter",
            "Avoid rooms entirely",
            "Limit room count",
            "Use long polling"
        ]
    },
    {
        "q": "What is a good namespace strategy?",
        "o": [
            "Separate by feature or domain",
            "One namespace for all",
            "Namespace per user",
            "Random namespaces"
        ]
    },
    {
        "q": "How do you implement game lobbies?",
        "o": [
            "Use rooms for each game",
            "Use namespace per game",
            "Single room for all",
            "Separate servers per game"
        ]
    },
    {
        "q": "What is Socket.io for collaborative editing?",
        "o": [
            "Real-time document sync",
            "File storage",
            "Version control",
            "Spell checking"
        ]
    },
    {
        "q": "How do you handle large file transfers?",
        "o": [
            "Chunk data into smaller pieces",
            "Send entire file at once",
            "Use different protocol",
            "File transfer not supported"
        ]
    },
    {
        "q": "What is optimistic UI update?",
        "o": [
            "Update UI before server confirms",
            "Wait for server always",
            "Delay all updates",
            "Cache all data"
        ]
    },
    {
        "q": "How do you handle reconnection in chat?",
        "o": [
            "Fetch missed messages on reconnect",
            "Lose all missed messages",
            "Start new conversation",
            "Clear chat history"
        ]
    },
    {
        "q": "What is presence detection?",
        "o": [
            "Tracking user online status",
            "Detecting device type",
            "Finding user location",
            "Identifying browser"
        ]
    },
    {
        "q": "How do you implement presence?",
        "o": [
            "Track connect and disconnect events",
            "Poll server constantly",
            "Use browser API only",
            "Check database status"
        ]
    },
    {
        "q": "What is graceful shutdown?",
        "o": [
            "Close connections properly before exit",
            "Quick server termination",
            "Force close all sockets",
            "Ignore pending messages"
        ]
    },
    {
        "q": "How do you implement graceful shutdown?",
        "o": [
            "Disconnect sockets and close server",
            "Kill process immediately",
            "Let OS handle cleanup",
            "Restart server"
        ]
    },
    {
        "q": "What is the benefit of volatile messages?",
        "o": [
            "Reduced overhead for expendable data",
            "Guaranteed delivery",
            "Message encryption",
            "Priority handling"
        ]
    },
    {
        "q": "When to use volatile emit?",
        "o": [
            "For real-time position updates",
            "For critical messages",
            "For authentication",
            "For payments"
        ]
    },
    {
        "q": "What is broadcast.to() vs io.to()?",
        "o": [
            "Both target rooms similarly",
            "Completely different functions",
            "One is deprecated",
            "One is client-only"
        ]
    },
    {
        "q": "How do you emit to multiple rooms?",
        "o": [
            "Chain multiple to() calls",
            "Pass array to single to()",
            "Use multiRoom() method",
            "Not possible"
        ]
    },
    {
        "q": "What is the different between in() and to()?",
        "o": [
            "They are aliases",
            "Different functionality",
            "One is deprecated",
            "One is newer"
        ]
    },
    {
        "q": "How do you count clients in a room?",
        "o": [
            "Get room size from adapter",
            "Iterate all sockets",
            "Query database",
            "Not trackable"
        ]
    },
    {
        "q": "What is io.allSockets() used for?",
        "o": [
            "Get all connected socket IDs",
            "List all server sockets",
            "Count total connections",
            "Find specific socket"
        ]
    },
    {
        "q": "How do you implement message queuing in Socket.io?",
        "o": [
            "Buffer messages until client reconnects",
            "Use database for all messages",
            "Drop messages on disconnect",
            "Wait infinitely for delivery"
        ]
    },
    {
        "q": "What is the role of sticky sessions in Socket.io scaling?",
        "o": [
            "Ensure client connects to same server",
            "Persist message history",
            "Store user preferences",
            "Cache room data"
        ]
    },
    {
        "q": "How do you configure sticky sessions with Nginx?",
        "o": [
            "Use ip_hash or sticky module",
            "Configure in Socket.io options",
            "No configuration needed",
            "Use Redis adapter only"
        ]
    },
    {
        "q": "What is the purpose of the connection event on namespace?",
        "o": [
            "Handle new connections to namespace",
            "Create new namespace",
            "Initialize server",
            "Start listening"
        ]
    },
    {
        "q": "How do you implement namespace authentication?",
        "o": [
            "Use middleware on namespace",
            "Check in connection handler",
            "No authentication possible",
            "Use global middleware only"
        ]
    },
    {
        "q": "What happens when namespace middleware calls next with error?",
        "o": [
            "Connection is rejected",
            "Error is logged only",
            "Connection proceeds",
            "Retry is attempted"
        ]
    },
    {
        "q": "How do you handle CORS preflight requests?",
        "o": [
            "Socket.io handles automatically",
            "Manual OPTIONS handler needed",
            "CORS not applicable",
            "Use separate CORS middleware"
        ]
    },
    {
        "q": "What is the benefit of compression in Socket.io?",
        "o": [
            "Reduce bandwidth usage",
            "Increase message speed",
            "Improve security",
            "Enhance reliability"
        ]
    },
    {
        "q": "How do you disable compression for specific messages?",
        "o": [
            "socket.compress(false).emit()",
            "emit with noCompress option",
            "Compression per message not possible",
            "Use raw transport"
        ]
    },
    {
        "q": "What is binary acknowledgement?",
        "o": [
            "Confirm receipt of binary data",
            "Binary format for acks",
            "Two-state confirmation",
            "Encrypted acknowledgement"
        ]
    },
    {
        "q": "How do you handle ArrayBuffer in Socket.io?",
        "o": [
            "Send directly as emit argument",
            "Convert to base64 first",
            "Use special binary method",
            "ArrayBuffer not supported"
        ]
    },
    {
        "q": "What is the purpose of socket.io-stream?",
        "o": [
            "Stream large data efficiently",
            "Log event streams",
            "Create data pipelines",
            "Handle video streaming"
        ]
    },
    {
        "q": "How do you implement file upload with Socket.io?",
        "o": [
            "Chunk file and emit pieces",
            "Send entire file at once",
            "Use HTTP instead",
            "Not possible with Socket.io"
        ]
    },
    {
        "q": "What is the disconnecting event?",
        "o": [
            "Fires before socket leaves rooms",
            "Same as disconnect",
            "Fires after disconnect",
            "Manual disconnect only"
        ]
    },
    {
        "q": "How do you access room list during disconnecting?",
        "o": [
            "socket.rooms is still available",
            "Rooms already cleared",
            "Use adapter query",
            "Not accessible"
        ]
    },
    {
        "q": "What is the purpose of socket.recovered flag?",
        "o": [
            "Indicate successful state recovery",
            "Show reconnection status",
            "Mark error recovery",
            "Flag manual reconnect"
        ]
    },
    {
        "q": "How does connection state recovery handle rooms?",
        "o": [
            "Automatically rejoins previous rooms",
            "Rooms must be rejoined manually",
            "Creates new room set",
            "Uses default room only"
        ]
    },
    {
        "q": "What is maxDisconnectionDuration in recovery?",
        "o": [
            "Maximum offline time for recovery",
            "Time before forced disconnect",
            "Cache duration",
            "Retry timeout"
        ]
    },
    {
        "q": "How do you skip state recovery for specific connections?",
        "o": [
            "Set socket.recovered = false in middleware",
            "Disable globally only",
            "Not selectively disableable",
            "Use skipRecovery event"
        ]
    },
    {
        "q": "What is the impact of using multiple Socket.io servers?",
        "o": [
            "Need adapter for room sync",
            "No impact at all",
            "Automatic synchronization",
            "Only one server allowed"
        ]
    },
    {
        "q": "How do you broadcast across multiple servers?",
        "o": [
            "Adapter handles distribution",
            "Each server broadcasts locally",
            "Manual server-to-server calls",
            "Not possible"
        ]
    },
    {
        "q": "What is sharding in Socket.io context?",
        "o": [
            "Distribute connections across servers",
            "Split messages into parts",
            "Divide rooms into groups",
            "Partition namespaces"
        ]
    },
    {
        "q": "How do you implement connection sharding?",
        "o": [
            "Use load balancer with sticky sessions",
            "Configure in Socket.io",
            "Enable sharding option",
            "Use shard adapter"
        ]
    },
    {
        "q": "What is the challenge with rooms and multiple servers?",
        "o": [
            "Room membership sync across servers",
            "Room names conflict",
            "Too many rooms created",
            "Performance degradation"
        ]
    },
    {
        "q": "How does Redis adapter solve multi-server issues?",
        "o": [
            "Publishes events to all servers",
            "Stores all data in Redis",
            "Creates persistent connections",
            "Manages load balancing"
        ]
    },
    {
        "q": "What is redis pub/sub used for in adapter?",
        "o": [
            "Synchronize emissions across servers",
            "Store message history",
            "Cache user sessions",
            "Handle authentication"
        ]
    },
    {
        "q": "How do you handle Redis connection failure?",
        "o": [
            "Socket.io continues locally",
            "All connections drop",
            "Server crashes",
            "Auto-reconnect only"
        ]
    },
    {
        "q": "What is the socket.io/redis-streams-adapter?",
        "o": [
            "Uses Redis Streams instead of Pub/Sub",
            "Streaming data adapter",
            "Video streaming support",
            "Real-time audio adapter"
        ]
    },
    {
        "q": "What is the advantage of Redis Streams adapter?",
        "o": [
            "Message history and delivery guarantees",
            "Faster performance",
            "Less memory usage",
            "Simpler configuration"
        ]
    },
    {
        "q": "How do you implement custom emitter for Redis?",
        "o": [
            "Use socket.io-redis-emitter",
            "Extend Redis adapter",
            "Not possible",
            "Use raw Redis commands"
        ]
    },
    {
        "q": "What is the emitter pattern in Socket.io?",
        "o": [
            "Emit to clients from any process",
            "Event emission wrapper",
            "Broadcast helper",
            "Message queue"
        ]
    },
    {
        "q": "How do you emit from a worker process?",
        "o": [
            "Use emitter with same adapter",
            "Connect as regular client",
            "Not possible from workers",
            "Use IPC only"
        ]
    },
    {
        "q": "What is the purpose of adapter.serverCount()?",
        "o": [
            "Get number of connected servers",
            "Count total sockets",
            "List server addresses",
            "Check server health"
        ]
    },
    {
        "q": "How do you debug adapter synchronization?",
        "o": [
            "Enable DEBUG for adapter",
            "Check Redis directly",
            "Monitor network traffic",
            "Count room members"
        ]
    },
    {
        "q": "What is eventual consistency in Socket.io clusters?",
        "o": [
            "Brief sync delay between servers",
            "Guaranteed immediate consistency",
            "Data loss possibility",
            "Manual sync required"
        ]
    },
    {
        "q": "How do you test multi-server setups?",
        "o": [
            "Run multiple instances locally",
            "Only production testing",
            "Single instance tests suffice",
            "Use mock adapters"
        ]
    },
    {
        "q": "What is the challenge with acknowledgements across servers?",
        "o": [
            "Response must route back correctly",
            "Acknowledgements not supported",
            "Always times out",
            "Requires database"
        ]
    },
    {
        "q": "How does the adapter handle ack callbacks?",
        "o": [
            "Tracks callback origin server",
            "Stores in Redis",
            "Broadcasts response",
            "Uses HTTP fallback"
        ]
    },
    {
        "q": "What is requestsTimeout in adapter?",
        "o": [
            "Timeout for fetch operations",
            "Connection timeout",
            "Message send timeout",
            "Ack timeout"
        ]
    },
    {
        "q": "How do you handle adapter errors?",
        "o": [
            "Listen for error event on adapter",
            "Errors are silent",
            "Server crashes on error",
            "Check return values"
        ]
    },
    {
        "q": "What is the socket leaving a room internally?",
        "o": [
            "Entry removed from room Set",
            "Database update",
            "Redis key deletion",
            "File system change"
        ]
    },
    {
        "q": "How do you implement reconnection with room restoration?",
        "o": [
            "Store user rooms and rejoin on connect",
            "Automatic restoration always",
            "Rooms persist automatically",
            "No restoration needed"
        ]
    },
    {
        "q": "What is a dynamic room?",
        "o": [
            "Room created based on runtime data",
            "Room that changes size",
            "Temporary room",
            "Encrypted room"
        ]
    },
    {
        "q": "How do you clean up empty rooms?",
        "o": [
            "Socket.io removes automatically",
            "Manual cleanup required",
            "Empty rooms persist",
            "Use garbage collector"
        ]
    },
    {
        "q": "What is the overhead of having many rooms?",
        "o": [
            "Minimal, rooms are just Sets",
            "High memory usage",
            "CPU intensive",
            "Network bottleneck"
        ]
    },
    {
        "q": "How do you implement room expiration?",
        "o": [
            "Track creation time and cleanup",
            "Built-in TTL support",
            "Rooms never expire",
            "Use Redis TTL"
        ]
    },
    {
        "q": "What is a private room pattern?",
        "o": [
            "Room with single user ID",
            "Password protected room",
            "Encrypted room",
            "Admin only room"
        ]
    },
    {
        "q": "How do you implement group messaging?",
        "o": [
            "Create room per group",
            "Send to each user individually",
            "Use namespace per group",
            "Broadcast to all"
        ]
    },
    {
        "q": "What is fan-out in Socket.io?",
        "o": [
            "Send message to many clients",
            "Spread load across servers",
            "Distribute connections",
            "Split large messages"
        ]
    },
    {
        "q": "How do you optimize fan-out performance?",
        "o": [
            "Use rooms efficiently",
            "Send individually",
            "Delay messages",
            "Compress all data"
        ]
    },
    {
        "q": "What is the challenge with large broadcasts?",
        "o": [
            "CPU and bandwidth usage",
            "Message ordering",
            "Client buffer overflow",
            "Server memory"
        ]
    },
    {
        "q": "How do you handle broadcast failures?",
        "o": [
            "Track delivery with acknowledgements",
            "Retry all messages",
            "Ignore failures",
            "Log and continue"
        ]
    },
    {
        "q": "What is selective broadcasting?",
        "o": [
            "Send to subset based on criteria",
            "Broadcast at intervals",
            "Priority based sending",
            "Compressed broadcasting"
        ]
    },
    {
        "q": "How do you implement selective broadcast?",
        "o": [
            "Use rooms or filter sockets",
            "Built-in filter option",
            "Not possible",
            "Use multiple namespaces"
        ]
    },
    {
        "q": "What is message batching?",
        "o": [
            "Group multiple messages together",
            "Send messages in order",
            "Queue for later",
            "Batch acknowledgements"
        ]
    },
    {
        "q": "How do you implement message batching?",
        "o": [
            "Buffer and send as array",
            "Built-in batching option",
            "Use special method",
            "Enable in config"
        ]
    },
    {
        "q": "What is the benefit of message batching?",
        "o": [
            "Reduced network overhead",
            "Faster delivery",
            "Better reliability",
            "Lower memory usage"
        ]
    },
    {
        "q": "How do you handle message ordering?",
        "o": [
            "Messages are ordered per socket",
            "Use sequence numbers",
            "Ordering not guaranteed",
            "Sort on client"
        ]
    },
    {
        "q": "What affects message ordering across sockets?",
        "o": [
            "Network latency variations",
            "Server processing order",
            "Client handling",
            "All of these"
        ]
    },
    {
        "q": "How do you implement guaranteed ordering?",
        "o": [
            "Add sequence numbers to messages",
            "Use single socket only",
            "Built-in guarantee",
            "Not possible"
        ]
    },
    {
        "q": "What is message deduplication?",
        "o": [
            "Prevent duplicate message processing",
            "Remove repeated content",
            "Compress similar messages",
            "Filter spam"
        ]
    },
    {
        "q": "How do you implement message deduplication?",
        "o": [
            "Track message IDs on client",
            "Server handles automatically",
            "Use unique events only",
            "Not needed in Socket.io"
        ]
    },
    {
        "q": "What is idempotency in Socket.io handlers?",
        "o": [
            "Safe repeated processing",
            "Message uniqueness",
            "Event filtering",
            "Connection stability"
        ]
    },
    {
        "q": "How do you make handlers idempotent?",
        "o": [
            "Design operations to be repeatable",
            "Block repeated messages",
            "Use transactions",
            "Not applicable"
        ]
    },
    {
        "q": "What is back-pressure in Socket.io?",
        "o": [
            "Slow consumer overwhelming buffer",
            "Reverse message flow",
            "Server load pressure",
            "Network congestion"
        ]
    },
    {
        "q": "How do you handle back-pressure?",
        "o": [
            "Monitor buffer and throttle",
            "Increase buffer size",
            "Disconnect slow clients",
            "Ignore the issue"
        ]
    },
    {
        "q": "What is socket.conn.bufferedAmount?",
        "o": [
            "Bytes waiting to be sent",
            "Received message count",
            "Buffer size limit",
            "Connection quality"
        ]
    },
    {
        "q": "How do you detect slow clients?",
        "o": [
            "Monitor send buffer size",
            "Track acknowledgement time",
            "Check ping response",
            "Count dropped messages"
        ]
    },
    {
        "q": "What is the drain event?",
        "o": [
            "Buffer is emptied",
            "Connection closed",
            "Memory freed",
            "Room emptied"
        ]
    },
    {
        "q": "How do you implement flow control?",
        "o": [
            "Pause sending when buffer full",
            "Always send immediately",
            "Use priority queues",
            "Rate limit globally"
        ]
    },
    {
        "q": "What is a heartbeat in Socket.io?",
        "o": [
            "Ping/pong for connection health",
            "Message interval",
            "Server health check",
            "Client activity signal"
        ]
    },
    {
        "q": "How do you customize heartbeat interval?",
        "o": [
            "Set pingInterval option",
            "Configure heartbeat option",
            "Cannot customize",
            "Client-side only"
        ]
    },
    {
        "q": "What happens if heartbeat fails?",
        "o": [
            "Connection considered dead",
            "Warning is logged",
            "Retry is attempted",
            "Nothing happens"
        ]
    },
    {
        "q": "How do you detect network issues?",
        "o": [
            "Monitor ping/pong latency",
            "Count message failures",
            "Check transport state",
            "All of these"
        ]
    },
    {
        "q": "What is connection quality monitoring?",
        "o": [
            "Track latency and reliability",
            "Check bandwidth",
            "Monitor CPU usage",
            "Measure memory"
        ]
    },
    {
        "q": "How do you implement latency tracking?",
        "o": [
            "Measure round-trip time",
            "Use built-in metrics",
            "Not possible",
            "Server-side only"
        ]
    },
    {
        "q": "What is transport failover?",
        "o": [
            "Switch transport on failure",
            "Server failover",
            "Message retry",
            "Room transfer"
        ]
    },
    {
        "q": "How does Socket.io handle transport failures?",
        "o": [
            "Falls back to polling",
            "Connection drops",
            "Retry same transport",
            "Switch to HTTP"
        ]
    },
    {
        "q": "What is probing in Socket.io?",
        "o": [
            "Test transport before switching",
            "Check server health",
            "Validate messages",
            "Verify authentication"
        ]
    },
    {
        "q": "How do you disable transport probing?",
        "o": [
            "Set upgrade to false",
            "Configure probing option",
            "Cannot disable",
            "Remove transport"
        ]
    },
    {
        "q": "What is the benefit of starting with polling?",
        "o": [
            "Works behind firewalls",
            "Faster initial connection",
            "Lower resource usage",
            "Better security"
        ]
    },
    {
        "q": "When should you start with WebSocket?",
        "o": [
            "When polling adds latency",
            "Always prefer WebSocket first",
            "Never skip polling",
            "Only for mobile apps"
        ]
    },
    {
        "q": "What is the cost of transport upgrade?",
        "o": [
            "Brief connection overhead",
            "Message loss",
            "High CPU usage",
            "Network spike"
        ]
    },
    {
        "q": "How do you monitor transport usage?",
        "o": [
            "Track engine events",
            "Check server logs",
            "Use admin UI",
            "All of these"
        ]
    },
    {
        "q": "What is websocket-only mode benefit?",
        "o": [
            "Lower latency",
            "Better compatibility",
            "Simpler debugging",
            "Higher reliability"
        ]
    },
    {
        "q": "What is polling-only mode use case?",
        "o": [
            "Restricted network environments",
            "Better performance",
            "Lower bandwidth",
            "Improved security"
        ]
    },
    {
        "q": "How do you force specific transport?",
        "o": [
            "Set transports array",
            "Configure transport option",
            "Not configurable",
            "Server-side only"
        ]
    },
    {
        "q": "What is the difference between HTTP polling variants?",
        "o": [
            "GET for receiving, POST for sending",
            "Same method for both",
            "Only GET used",
            "Only POST used"
        ]
    },
    {
        "q": "How do you optimize polling performance?",
        "o": [
            "Minimize polling interval",
            "Upgrade to WebSocket",
            "Increase timeout",
            "All of these"
        ]
    },
    {
        "q": "What is XHR polling?",
        "o": [
            "XMLHttpRequest based polling",
            "External resource polling",
            "Cross-origin polling",
            "XML data polling"
        ]
    },
    {
        "q": "What is JSONP polling?",
        "o": [
            "Fallback for cross-origin",
            "JSON formatted polling",
            "JavaScript polling",
            "Padded response polling"
        ]
    },
    {
        "q": "How do you implement custom packet encoder?",
        "o": [
            "Extend Parser class",
            "Configure encoder option",
            "Not possible",
            "Use middleware"
        ]
    },
    {
        "q": "What is the binary event packet type?",
        "o": [
            "Special type for binary data",
            "Compressed event",
            "Encrypted event",
            "Priority event"
        ]
    },
    {
        "q": "How do you implement custom serialization?",
        "o": [
            "Provide custom parser",
            "Override JSON methods",
            "Not supported",
            "Use transform"
        ]
    },
    {
        "q": "What is msgpack support in Socket.io?",
        "o": [
            "Binary serialization format",
            "Message packaging",
            "Packet compression",
            "Data encryption"
        ]
    },
    {
        "q": "How do you use msgpack with Socket.io?",
        "o": [
            "Install socket.io-msgpack-parser",
            "Enable msgpack option",
            "Configure in transport",
            "Not supported"
        ]
    },
    {
        "q": "What is the benefit of msgpack over JSON?",
        "o": [
            "Smaller payload size",
            "Better readability",
            "Easier debugging",
            "Wider support"
        ]
    },
    {
        "q": "How do you handle circular references in data?",
        "o": [
            "Serialize with special handling",
            "Socket.io handles automatically",
            "Circular data not allowed",
            "Use flat objects only"
        ]
    },
    {
        "q": "What is the packet structure in Socket.io?",
        "o": [
            "Type, namespace, data, and ID",
            "Header and body only",
            "Single data field",
            "XML structure"
        ]
    },
    {
        "q": "How do you inspect Socket.io packets?",
        "o": [
            "Browser dev tools network tab",
            "Special debug mode",
            "Packet viewer tool",
            "Not inspectable"
        ]
    },
    {
        "q": "What is the CONNECT packet?",
        "o": [
            "Initial namespace connection",
            "Transport connect",
            "Room join request",
            "Handshake start"
        ]
    },
    {
        "q": "What is the DISCONNECT packet?",
        "o": [
            "Leave namespace",
            "Close transport",
            "Leave room",
            "End session"
        ]
    },
    {
        "q": "What is the EVENT packet?",
        "o": [
            "Standard event emission",
            "System event",
            "Error event",
            "Connect event"
        ]
    },
    {
        "q": "What is the ACK packet?",
        "o": [
            "Acknowledgement response",
            "Acknowledge connect",
            "Access control",
            "Activity check"
        ]
    },
    {
        "q": "What is the CONNECT_ERROR packet?",
        "o": [
            "Connection rejection reason",
            "Transport error",
            "Message error",
            "Room error"
        ]
    },
    {
        "q": "What is the BINARY_EVENT packet?",
        "o": [
            "Event with binary attachments",
            "Encoded event",
            "Compressed event",
            "Encrypted event"
        ]
    },
    {
        "q": "What is the BINARY_ACK packet?",
        "o": [
            "Ack with binary data",
            "Binary acknowledgement flag",
            "Compressed ack",
            "Encrypted ack"
        ]
    },
    {
        "q": "How do you handle protocol version mismatch?",
        "o": [
            "Enable EIO3 compatibility",
            "Version negotiation automatic",
            "Server rejects connection",
            "Not an issue"
        ]
    },
    {
        "q": "What is Socket.io protocol version 5?",
        "o": [
            "Latest protocol specification",
            "Fifth connection attempt",
            "Five message limit",
            "Five socket maximum"
        ]
    },
    {
        "q": "How is the protocol version communicated?",
        "o": [
            "In handshake query",
            "In first message",
            "In headers",
            "In cookies"
        ]
    },
    {
        "q": "What breaking changes exist between v2 and v3?",
        "o": [
            "Default namespace must be connected first",
            "No breaking changes",
            "Complete API rewrite",
            "Different transport"
        ]
    },
    {
        "q": "How do you migrate from Socket.io v2 to v4?",
        "o": [
            "Update package and fix breaking changes",
            "Complete rewrite required",
            "Automatic migration",
            "Version incompatible"
        ]
    },
    {
        "q": "What is new in Socket.io v4?",
        "o": [
            "TypeScript support and new features",
            "Different protocol",
            "New transport only",
            "Complete rewrite"
        ]
    },
    {
        "q": "How do you implement custom transport?",
        "o": [
            "Extend Transport class",
            "Configure transport option",
            "Not possible",
            "Use plugin system"
        ]
    },
    {
        "q": "What is the WebTransport support?",
        "o": [
            "Experimental HTTP/3 transport",
            "Web transfer protocol",
            "Transport viewer",
            "Legacy transport"
        ]
    },
    {
        "q": "How do you enable WebTransport?",
        "o": [
            "Add to transports array",
            "Enable in config",
            "Install adapter",
            "Not yet supported"
        ]
    },
    {
        "q": "What is server certificate requirement for WebTransport?",
        "o": [
            "Valid TLS certificate",
            "No certificate needed",
            "Self-signed works",
            "Special certificate type"
        ]
    },
    {
        "q": "What is the benefit of HTTP/3 for Socket.io?",
        "o": [
            "Improved performance and reliability",
            "Simpler implementation",
            "Better browser support",
            "Lower memory usage"
        ]
    },
    {
        "q": "How do you implement server-to-server communication?",
        "o": [
            "Use serverSideEmit method",
            "Connect as client",
            "Direct socket pipe",
            "Use HTTP calls"
        ]
    },
    {
        "q": "What is inter-server messaging pattern?",
        "o": [
            "Communication between cluster nodes",
            "Internal message routing",
            "Server health checks",
            "Load distribution"
        ]
    },
    {
        "q": "How do you handle inter-server acks?",
        "o": [
            "Callback in serverSideEmit",
            "Not supported",
            "Use separate channel",
            "HTTP fallback"
        ]
    },
    {
        "q": "What is the timeout for inter-server calls?",
        "o": [
            "Default 5 seconds",
            "No timeout",
            "1 second",
            "30 seconds"
        ]
    },
    {
        "q": "How do you implement leader election with Socket.io?",
        "o": [
            "Use external coordination service",
            "Built-in election",
            "First server is leader",
            "Random selection"
        ]
    },
    {
        "q": "What is distributed locking with Socket.io?",
        "o": [
            "Coordinate access using external store",
            "Socket-based locks",
            "Room-based locking",
            "Message queue lock"
        ]
    },
    {
        "q": "How do you implement rate limiting per user?",
        "o": [
            "Track user events in middleware",
            "Built-in rate limiter",
            "Socket limit option",
            "Transport level"
        ]
    },
    {
        "q": "What is token bucket algorithm for rate limiting?",
        "o": [
            "Allow bursts within limit",
            "Fixed rate only",
            "Token authentication",
            "Message encryption"
        ]
    },
    {
        "q": "How do you implement sliding window rate limit?",
        "o": [
            "Track timestamps in window",
            "Use fixed windows only",
            "Not applicable",
            "Built-in support"
        ]
    },
    {
        "q": "What is the challenge with distributed rate limiting?",
        "o": [
            "Synchronizing counts across servers",
            "Too strict limiting",
            "Performance overhead",
            "Memory usage"
        ]
    },
    {
        "q": "How do you sync rate limits across servers?",
        "o": [
            "Use shared storage like Redis",
            "Each server independent",
            "Load balancer handles",
            "Not possible"
        ]
    },
    {
        "q": "What is circuit breaker pattern?",
        "o": [
            "Stop calls to failing service",
            "Electrical protection",
            "Connection limiter",
            "Message filter"
        ]
    },
    {
        "q": "How do you implement circuit breaker in Socket.io?",
        "o": [
            "Track failures and open circuit",
            "Built-in circuit breaker",
            "Not applicable",
            "Use transport option"
        ]
    },
    {
        "q": "What is bulkhead pattern?",
        "o": [
            "Isolate failures to subsets",
            "Large message handling",
            "Bulk operations",
            "Message batching"
        ]
    },
    {
        "q": "How do you implement bulkhead isolation?",
        "o": [
            "Separate namespaces or servers",
            "Built-in support",
            "Room isolation only",
            "Not possible"
        ]
    },
    {
        "q": "What is graceful degradation strategy?",
        "o": [
            "Reduce features under load",
            "Slow message rate",
            "Increase timeout",
            "Add more servers"
        ]
    },
    {
        "q": "How do you implement feature flags per socket?",
        "o": [
            "Store flags in socket.data",
            "Use namespace per feature",
            "Built-in feature flags",
            "Not supported"
        ]
    },
    {
        "q": "What is A/B testing with Socket.io?",
        "o": [
            "Route users to different experiences",
            "Testing two protocols",
            "Load balancing",
            "Feature comparison"
        ]
    },
    {
        "q": "How do you implement canary releases?",
        "o": [
            "Route percentage to new version",
            "Release to all at once",
            "Sequential server update",
            "Not possible"
        ]
    },
    {
        "q": "What is blue-green deployment with Socket.io?",
        "o": [
            "Switch between environments",
            "Color-coded servers",
            "Testing environments",
            "Staging setup"
        ]
    },
    {
        "q": "What challenge exists in Socket.io blue-green?",
        "o": [
            "Active connections during switch",
            "Configuration sync",
            "Database migration",
            "No challenges"
        ]
    },
    {
        "q": "How do you handle zero-downtime deployment?",
        "o": [
            "Rolling update with connection draining",
            "Quick server restart",
            "Always some downtime",
            "Pause all messages"
        ]
    },
    {
        "q": "What is connection draining?",
        "o": [
            "Allow existing connections to complete",
            "Remove idle connections",
            "Clear message queue",
            "Reset connection state"
        ]
    },
    {
        "q": "How do you implement health checks?",
        "o": [
            "Expose health endpoint",
            "Socket.io tests automatically",
            "Check connection count",
            "Monitor CPU only"
        ]
    },
    {
        "q": "What should health checks verify?",
        "o": [
            "Server responsiveness and dependencies",
            "Only CPU usage",
            "Socket count only",
            "Memory only"
        ]
    },
    {
        "q": "How do you implement readiness probe?",
        "o": [
            "Check if ready to accept connections",
            "Same as health check",
            "Check memory",
            "Count sockets"
        ]
    },
    {
        "q": "What is liveness probe for Socket.io?",
        "o": [
            "Verify server is running",
            "Check message rate",
            "Monitor rooms",
            "Track events"
        ]
    },
    {
        "q": "How do you implement custom metrics?",
        "o": [
            "Track in middleware and export",
            "Use built-in metrics",
            "Not possible",
            "Third-party only"
        ]
    },
    {
        "q": "What metrics library works with Socket.io?",
        "o": [
            "Prometheus, StatsD, or custom",
            "Only Prometheus",
            "Built-in metrics only",
            "No metrics support"
        ]
    },
    {
        "q": "How do you export metrics to Prometheus?",
        "o": [
            "Use prom-client library",
            "Built-in Prometheus export",
            "Configure adapter",
            "Use plugin"
        ]
    },
    {
        "q": "What is distributed tracing?",
        "o": [
            "Track requests across services",
            "Log all messages",
            "Debug connections",
            "Monitor latency"
        ]
    },
    {
        "q": "How do you implement tracing with Socket.io?",
        "o": [
            "Add trace context to messages",
            "Built-in tracing",
            "Not applicable",
            "Use adapter only"
        ]
    },
    {
        "q": "What is correlation ID pattern?",
        "o": [
            "Track related messages together",
            "Match request response",
            "Correlate users",
            "Link rooms"
        ]
    },
    {
        "q": "How do you implement request correlation?",
        "o": [
            "Include ID in message payload",
            "Socket.io tracks automatically",
            "Use acknowledgements",
            "Not needed"
        ]
    },
    {
        "q": "What is observability for Socket.io?",
        "o": [
            "Logs, metrics, and traces together",
            "Connection monitoring only",
            "Message logging",
            "Error tracking"
        ]
    },
    {
        "q": "How do you implement structured logging?",
        "o": [
            "Use JSON format with context",
            "Plain text logs only",
            "Built-in structured logs",
            "Not supported"
        ]
    },
    {
        "q": "What should be logged for Socket.io events?",
        "o": [
            "Event name, socket ID, and data",
            "Everything always",
            "Nothing for privacy",
            "Errors only"
        ]
    },
    {
        "q": "How do you handle PII in Socket.io logs?",
        "o": [
            "Sanitize or mask sensitive data",
            "Log everything",
            "Disable logging",
            "Use encryption"
        ]
    },
    {
        "q": "What is log aggregation for Socket.io?",
        "o": [
            "Collect logs from all servers",
            "Combine log files",
            "Compress logs",
            "Summarize logs"
        ]
    },
    {
        "q": "What tools work for Socket.io log aggregation?",
        "o": [
            "ELK stack, Datadog, or cloud services",
            "Only file storage",
            "Built-in aggregation",
            "Socket.io dashboard"
        ]
    },
    {
        "q": "How do you implement alerting for Socket.io?",
        "o": [
            "Set thresholds on key metrics",
            "Manual monitoring only",
            "Built-in alerts",
            "Not possible"
        ]
    },
    {
        "q": "What metrics should trigger alerts?",
        "o": [
            "Connection drops, error rates, latency",
            "Message count only",
            "CPU usage only",
            "Room count only"
        ]
    },
    {
        "q": "How do you debug production Socket.io issues?",
        "o": [
            "Use logs, metrics, and tracing",
            "Enable debug mode",
            "Reproduce locally only",
            "Check error messages"
        ]
    },
    {
        "q": "What is the challenge debugging Socket.io in production?",
        "o": [
            "Distributed nature and state",
            "Too many logs",
            "Network issues",
            "Server access"
        ]
    },
    {
        "q": "How do you implement feature toggles?",
        "o": [
            "Check configuration before feature use",
            "Built-in toggle system",
            "Namespace per feature",
            "Room-based toggles"
        ]
    },
    {
        "q": "What is kill switch pattern?",
        "o": [
            "Disable feature instantly",
            "Disconnect all clients",
            "Stop server",
            "Block IP addresses"
        ]
    },
    {
        "q": "How do you implement load shedding?",
        "o": [
            "Reject requests when overloaded",
            "Accept all always",
            "Queue indefinitely",
            "Increase resources"
        ]
    },
    {
        "q": "What is priority-based load shedding?",
        "o": [
            "Reject low priority first",
            "Random rejection",
            "Oldest first",
            "Newest first"
        ]
    },
    {
        "q": "How do you implement user priority in Socket.io?",
        "o": [
            "Tag sockets with priority level",
            "Built-in priority",
            "Separate servers",
            "Not possible"
        ]
    },
    {
        "q": "What is connection pooling issue with Socket.io?",
        "o": [
            "File descriptor limits",
            "Memory pooling",
            "CPU pooling",
            "Bandwidth pooling"
        ]
    },
    {
        "q": "How do you increase file descriptor limits?",
        "o": [
            "OS-level configuration",
            "Socket.io option",
            "Node.js setting",
            "Not possible"
        ]
    },
    {
        "q": "What is the impact of many open sockets on memory?",
        "o": [
            "Each socket consumes memory",
            "No memory impact",
            "Fixed memory regardless",
            "Only affects CPU"
        ]
    },
    {
        "q": "How do you estimate Socket.io memory usage?",
        "o": [
            "Measure per-socket overhead",
            "Use fixed formula",
            "Not estimable",
            "Check documentation"
        ]
    },
    {
        "q": "What is the maximum sockets per server?",
        "o": [
            "Depends on resources",
            "Fixed at 10000",
            "Unlimited",
            "Fixed at 1000"
        ]
    },
    {
        "q": "How do you handle socket exhaustion?",
        "o": [
            "Add servers or optimize",
            "Increase limits only",
            "Nothing can be done",
            "Reduce message rate"
        ]
    },
    {
        "q": "What is keep-alive optimization?",
        "o": [
            "Reduce heartbeat overhead",
            "Maintain connections",
            "Cache messages",
            "Preserve state"
        ]
    },
    {
        "q": "How do you tune pingInterval?",
        "o": [
            "Balance detection speed and overhead",
            "Lower is always better",
            "Higher is always better",
            "Cannot tune"
        ]
    },
    {
        "q": "What is the trade-off with low pingTimeout?",
        "o": [
            "Faster detection vs false positives",
            "No trade-off",
            "Better performance",
            "More reliability"
        ]
    },
    {
        "q": "How do you handle mobile network variance?",
        "o": [
            "Increase timeouts for mobile",
            "Same settings for all",
            "Disable heartbeat",
            "Force polling"
        ]
    },
    {
        "q": "What is message coalescing?",
        "o": [
            "Combine multiple messages into one",
            "Split large messages",
            "Filter duplicates",
            "Order messages"
        ]
    },
    {
        "q": "How do you implement event throttling?",
        "o": [
            "Limit emission rate client-side",
            "Server-side only",
            "Built-in throttling",
            "Not possible"
        ]
    },
    {
        "q": "What is debouncing in Socket.io context?",
        "o": [
            "Wait for pause in events to emit",
            "Bounce messages back",
            "Reject duplicates",
            "Delay all messages"
        ]
    },
    {
        "q": "How do you implement server-side throttling?",
        "o": [
            "Track event rate per socket",
            "Use adapter",
            "Built-in throttle",
            "Transport level"
        ]
    },
    {
        "q": "What is adaptive rate limiting?",
        "o": [
            "Adjust limits based on load",
            "Fixed rate always",
            "User-specific limits",
            "Time-based limits"
        ]
    },
    {
        "q": "How do you implement backoff on client?",
        "o": [
            "Increase delay between retries",
            "Fixed retry interval",
            "No retry",
            "Server controls"
        ]
    },
    {
        "q": "What is jitter in reconnection strategy?",
        "o": [
            "Random variation to prevent thundering herd",
            "Connection quality metric",
            "Message delay variance",
            "Network instability measure"
        ]
    },
    {
        "q": "How do you implement jitter in backoff?",
        "o": [
            "Add random delay component",
            "Use fixed delay",
            "Built-in jitter",
            "Not needed"
        ]
    },
    {
        "q": "What is thundering herd problem?",
        "o": [
            "Many clients reconnecting simultaneously",
            "Server overload attack",
            "Message flood",
            "Room overflow"
        ]
    },
    {
        "q": "How do you prevent thundering herd?",
        "o": [
            "Randomize reconnection timing",
            "Sequential reconnection only",
            "Block reconnections",
            "Limit client count"
        ]
    },
    {
        "q": "What is connection storm mitigation?",
        "o": [
            "Spread reconnections over time",
            "Increase server capacity",
            "Block all connections",
            "Use polling only"
        ]
    },
    {
        "q": "How do you handle server restart gracefully?",
        "o": [
            "Drain connections before stopping",
            "Kill immediately",
            "Wait indefinitely",
            "Force disconnect all"
        ]
    },
    {
        "q": "What is the impact of GC pauses on Socket.io?",
        "o": [
            "Potential connection timeouts",
            "No impact",
            "Message ordering issues",
            "Room corruption"
        ]
    },
    {
        "q": "How do you minimize GC impact?",
        "o": [
            "Optimize memory usage patterns",
            "Disable garbage collection",
            "Increase heap size only",
            "Use polling"
        ]
    },
    {
        "q": "What is object pooling benefit for Socket.io?",
        "o": [
            "Reduce memory allocation overhead",
            "Share sockets between clients",
            "Pool connections",
            "Group messages"
        ]
    },
    {
        "q": "How do you implement message object pooling?",
        "o": [
            "Reuse message objects",
            "Create new each time",
            "Built-in pooling",
            "Use adapter"
        ]
    },
    {
        "q": "What is event loop blocking in Node.js?",
        "o": [
            "Long synchronous operations",
            "Event queue full",
            "Socket buffer overflow",
            "Message queue block"
        ]
    },
    {
        "q": "How do you prevent event loop blocking?",
        "o": [
            "Use async operations",
            "Increase worker threads",
            "Add more servers",
            "Reduce connections"
        ]
    },
    {
        "q": "What is the impact of CPU-bound tasks on Socket.io?",
        "o": [
            "Delayed message processing",
            "No impact",
            "Memory issues",
            "Network problems"
        ]
    },
    {
        "q": "How do you offload CPU-intensive work?",
        "o": [
            "Use worker threads or separate process",
            "Run in main thread",
            "Increase timeout",
            "Add more RAM"
        ]
    },
    {
        "q": "What is cluster module with Socket.io?",
        "o": [
            "Multiple workers sharing port",
            "Database clustering",
            "Room grouping",
            "Server federation"
        ]
    },
    {
        "q": "How do you use cluster with Socket.io?",
        "o": [
            "Use cluster adapter",
            "Standard cluster works",
            "Not compatible",
            "Use PM2 only"
        ]
    },
    {
        "q": "What is PM2 cluster mode advantage?",
        "o": [
            "Process management and scaling",
            "Message queue",
            "Room management",
            "Authentication"
        ]
    },
    {
        "q": "How do you configure PM2 for Socket.io?",
        "o": [
            "Use cluster adapter and instances",
            "No special configuration",
            "PM2 handles automatically",
            "Not compatible"
        ]
    },
    {
        "q": "What is horizontal pod autoscaling impact?",
        "o": [
            "Dynamic server count changes",
            "No impact",
            "Better performance always",
            "Room rebalancing"
        ]
    },
    {
        "q": "How do you handle autoscaling events?",
        "o": [
            "Ensure adapter syncs new pods",
            "Manual configuration",
            "Restart all pods",
            "Disable autoscaling"
        ]
    },
    {
        "q": "What is Kubernetes service mesh with Socket.io?",
        "o": [
            "Traffic management and observability",
            "Socket mesh network",
            "Room networking",
            "Namespace routing"
        ]
    },
    {
        "q": "How do sidecars affect Socket.io connections?",
        "o": [
            "May need WebSocket passthrough config",
            "No impact",
            "Block all connections",
            "Auto-configure"
        ]
    },
    {
        "q": "What is Istio configuration for Socket.io?",
        "o": [
            "WebSocket upgrade settings",
            "No configuration needed",
            "Disable Istio for Socket.io",
            "Special Socket.io rules"
        ]
    },
    {
        "q": "How do you configure ingress for Socket.io?",
        "o": [
            "Enable WebSocket support and stickiness",
            "Standard HTTP ingress",
            "No ingress needed",
            "Special Socket.io ingress"
        ]
    },
    {
        "q": "What is AWS ALB configuration for Socket.io?",
        "o": [
            "Enable stickiness and WebSocket",
            "No configuration needed",
            "Use NLB instead",
            "ALB not supported"
        ]
    },
    {
        "q": "How do you configure nginx for Socket.io?",
        "o": [
            "WebSocket proxy settings and sticky",
            "Standard reverse proxy",
            "No nginx needed",
            "Special Socket.io module"
        ]
    },
    {
        "q": "What nginx directive enables WebSocket?",
        "o": [
            "proxy_http_version 1.1 and Upgrade headers",
            "websocket on",
            "socket_io enable",
            "realtime true"
        ]
    },
    {
        "q": "How do you configure HAProxy for Socket.io?",
        "o": [
            "Use http mode with timeout tunnel",
            "Standard tcp mode",
            "No special configuration",
            "HAProxy not supported"
        ]
    },
    {
        "q": "What is timeout tunnel in HAProxy?",
        "o": [
            "Duration for WebSocket connections",
            "Connection queue timeout",
            "Message delay limit",
            "Room timeout"
        ]
    },
    {
        "q": "How do you implement CDN with Socket.io?",
        "o": [
            "CDN for static, origin for WebSocket",
            "CDN handles WebSocket",
            "No CDN possible",
            "CDN only mode"
        ]
    },
    {
        "q": "What is edge computing for Socket.io?",
        "o": [
            "Deploy servers closer to users",
            "Browser-side processing",
            "Client-side caching",
            "Message compression"
        ]
    },
    {
        "q": "How do you implement geographic routing?",
        "o": [
            "DNS-based or anycast routing",
            "Client determines server",
            "Random server selection",
            "Single region only"
        ]
    },
    {
        "q": "What is multi-region Socket.io architecture?",
        "o": [
            "Servers in multiple regions with sync",
            "Single region deployment",
            "Client-side replication",
            "Edge caching only"
        ]
    },
    {
        "q": "How do you sync state across regions?",
        "o": [
            "Use global adapter like Redis Cluster",
            "HTTP calls between regions",
            "No sync needed",
            "Client handles sync"
        ]
    },
    {
        "q": "What is latency challenge in multi-region?",
        "o": [
            "Cross-region message delay",
            "Same latency everywhere",
            "Better latency always",
            "No latency impact"
        ]
    },
    {
        "q": "How do you minimize cross-region latency?",
        "o": [
            "Route users to nearest region",
            "Faster network links",
            "Compress all messages",
            "Use polling"
        ]
    },
    {
        "q": "What is room affinity?",
        "o": [
            "Keep room members on same server",
            "Room preference settings",
            "User room preferences",
            "Room priority"
        ]
    },
    {
        "q": "How do you implement room affinity?",
        "o": [
            "Route by room ID to specific servers",
            "Built-in room affinity",
            "Not possible",
            "Use single server"
        ]
    },
    {
        "q": "What is session affinity vs room affinity?",
        "o": [
            "User to server vs room to server",
            "Same concept",
            "Session is user-based",
            "Room is connection-based"
        ]
    },
    {
        "q": "How do you handle cross-room messaging?",
        "o": [
            "Adapter coordinates across servers",
            "Direct server calls",
            "Not possible",
            "Client handles"
        ]
    },
    {
        "q": "What is message fan-in pattern?",
        "o": [
            "Collect messages from many sources",
            "Spread messages out",
            "Filter messages",
            "Order messages"
        ]
    },
    {
        "q": "How do you implement fan-in?",
        "o": [
            "Central handler collects events",
            "Automatic collection",
            "Not applicable",
            "Use rooms only"
        ]
    },
    {
        "q": "What is event sourcing with Socket.io?",
        "o": [
            "Store events as source of truth",
            "Event logging only",
            "Real-time events",
            "Event filtering"
        ]
    },
    {
        "q": "How do you implement event sourcing?",
        "o": [
            "Persist all events to store",
            "Socket.io handles",
            "Use message queue",
            "Not compatible"
        ]
    },
    {
        "q": "What is CQRS with Socket.io?",
        "o": [
            "Separate read and write paths",
            "Query response system",
            "Command queue",
            "Request routing"
        ]
    },
    {
        "q": "How do you implement CQRS pattern?",
        "o": [
            "Emit for writes, query for reads",
            "Single handler for both",
            "Automatic separation",
            "Not applicable"
        ]
    },
    {
        "q": "What is saga pattern in Socket.io context?",
        "o": [
            "Coordinate multi-step transactions",
            "Story-based events",
            "Long message chains",
            "Session history"
        ]
    },
    {
        "q": "How do you implement compensating transactions?",
        "o": [
            "Emit rollback events on failure",
            "Automatic rollback",
            "Database handles",
            "Not needed"
        ]
    },
    {
        "q": "What is eventual consistency handling?",
        "o": [
            "Accept temporary inconsistency",
            "Always consistent",
            "Force immediate sync",
            "Block until consistent"
        ]
    },
    {
        "q": "How do you handle conflicting updates?",
        "o": [
            "Last-write-wins or merge strategy",
            "Block conflicting writes",
            "First-write-wins only",
            "Ignore conflicts"
        ]
    },
    {
        "q": "What is optimistic concurrency control?",
        "o": [
            "Assume no conflict, handle if occurs",
            "Lock before update",
            "Queue all updates",
            "Single writer only"
        ]
    },
    {
        "q": "How do you implement versioning for updates?",
        "o": [
            "Include version in messages",
            "Automatic versioning",
            "Not needed",
            "Server tracks only"
        ]
    },
    {
        "q": "What is WebRTC signaling with Socket.io?",
        "o": [
            "Exchange connection info for peer-to-peer",
            "Video streaming",
            "Audio routing",
            "Direct messaging"
        ]
    },
    {
        "q": "How do you implement WebRTC signaling?",
        "o": [
            "Relay SDP and ICE candidates",
            "Socket.io handles WebRTC",
            "Built-in signaling",
            "Use separate server"
        ]
    },
    {
        "q": "What is mesh vs SFU architecture?",
        "o": [
            "Direct peers vs central media server",
            "Network types",
            "Room layouts",
            "Server configurations"
        ]
    },
    {
        "q": "How does Socket.io complement WebRTC?",
        "o": [
            "Signaling and control channel",
            "Replaces WebRTC",
            "Not compatible",
            "Video streaming"
        ]
    },
    {
        "q": "What is screen sharing signaling?",
        "o": [
            "Exchange screen stream info",
            "Share screen directly",
            "Screen capture only",
            "Window listing"
        ]
    },
    {
        "q": "How do you handle ICE candidate trickling?",
        "o": [
            "Send candidates as discovered",
            "Collect all then send",
            "Single candidate only",
            "No trickling needed"
        ]
    },
    {
        "q": "What is SDP renegotiation?",
        "o": [
            "Update connection parameters",
            "New session always",
            "Price negotiation",
            "Server discovery"
        ]
    },
    {
        "q": "How do you handle renegotiation with Socket.io?",
        "o": [
            "Send new offer/answer pair",
            "Automatic renegotiation",
            "Close and reopen",
            "Not supported"
        ]
    },
    {
        "q": "What is data channel vs Socket.io?",
        "o": [
            "Peer-to-peer vs server-mediated",
            "Same thing",
            "Data channel is faster",
            "Socket.io is newer"
        ]
    },
    {
        "q": "When to use data channels over Socket.io?",
        "o": [
            "Low-latency peer-to-peer needed",
            "Always prefer data channels",
            "Never use data channels",
            "Server required for security"
        ]
    },
    {
        "q": "What is hybrid Socket.io and WebRTC?",
        "o": [
            "Combine for different needs",
            "Replace Socket.io with WebRTC",
            "Not compatible",
            "Performance optimization"
        ]
    },
    {
        "q": "How do you implement presence with WebRTC?",
        "o": [
            "Socket.io for signaling, WebRTC for media",
            "WebRTC handles presence",
            "Socket.io only",
            "Separate presence server"
        ]
    },
    {
        "q": "What is TURN server role?",
        "o": [
            "Relay media when direct fails",
            "Turn on connections",
            "Rotate servers",
            "Switch transports"
        ]
    },
    {
        "q": "How do you configure TURN with Socket.io signaling?",
        "o": [
            "Include TURN in ICE servers",
            "Socket.io handles TURN",
            "No configuration needed",
            "Use Socket.io as TURN"
        ]
    },
    {
        "q": "What is STUN server purpose?",
        "o": [
            "Discover public address",
            "Store and forward",
            "Session tracking",
            "Server clustering"
        ]
    },
    {
        "q": "How do you handle NAT traversal?",
        "o": [
            "Use STUN/TURN servers",
            "Socket.io handles NAT",
            "Not an issue",
            "Direct connection always"
        ]
    },
    {
        "q": "What is perfect negotiation pattern?",
        "o": [
            "Handle collisions gracefully",
            "Always succeed negotiation",
            "Optimal parameters",
            "Best performance"
        ]
    },
    {
        "q": "How do you implement perfect negotiation?",
        "o": [
            "Use polite/impolite peer roles",
            "Automatic handling",
            "Not needed",
            "Single initiator only"
        ]
    },
    {
        "q": "What is glare in WebRTC?",
        "o": [
            "Simultaneous offer collision",
            "Screen glare issue",
            "Bright video",
            "Connection flash"
        ]
    },
    {
        "q": "How do you prevent glare?",
        "o": [
            "Implement rollback mechanism",
            "Serialize offers",
            "Not possible",
            "Ignore collisions"
        ]
    },
    {
        "q": "What is Socket.io for IoT applications?",
        "o": [
            "Device communication and control",
            "Not suitable for IoT",
            "Sensor data only",
            "Automation only"
        ]
    },
    {
        "q": "How do you handle low-bandwidth IoT devices?",
        "o": [
            "Optimize payload and use compression",
            "Standard configuration",
            "Not supported",
            "Use HTTP instead"
        ]
    },
    {
        "q": "What is device shadow pattern?",
        "o": [
            "Server-side device state copy",
            "Device backup",
            "Hidden device",
            "Phantom connection"
        ]
    },
    {
        "q": "How do you implement device shadow?",
        "o": [
            "Sync state between device and server",
            "Automatic shadow",
            "Not applicable",
            "Database only"
        ]
    },
    {
        "q": "What is command-response pattern for IoT?",
        "o": [
            "Send command, await response",
            "One-way commands",
            "Response only",
            "No pattern needed"
        ]
    },
    {
        "q": "How do you handle offline IoT devices?",
        "o": [
            "Queue commands for delivery",
            "Discard commands",
            "Block until online",
            "Not supported"
        ]
    },
    {
        "q": "What is telemetry ingestion with Socket.io?",
        "o": [
            "Collect sensor data in real-time",
            "One-time data fetch",
            "Historical data only",
            "Manual data entry"
        ]
    },
    {
        "q": "How do you handle high-frequency telemetry?",
        "o": [
            "Batch and aggregate data",
            "Send each reading",
            "Reduce sensor rate",
            "Not supported"
        ]
    },
    {
        "q": "What is edge processing for IoT?",
        "o": [
            "Process data near device",
            "Central processing",
            "Cloud processing",
            "Database processing"
        ]
    },
    {
        "q": "How do you implement edge aggregation?",
        "o": [
            "Aggregate at gateway before sending",
            "All data to server",
            "Not possible",
            "Built-in support"
        ]
    },
    {
        "q": "What is device fleet management?",
        "o": [
            "Manage many devices centrally",
            "Fleet of servers",
            "Multiple namespaces",
            "Room collections"
        ]
    },
    {
        "q": "How do you organize device rooms?",
        "o": [
            "Room per device type or location",
            "Single room for all",
            "No rooms for IoT",
            "Random assignment"
        ]
    },
    {
        "q": "What is firmware update via Socket.io?",
        "o": [
            "Push updates to connected devices",
            "Device downloads from URL",
            "Not supported",
            "Manual update only"
        ]
    },
    {
        "q": "How do you implement OTA updates?",
        "o": [
            "Chunk firmware and emit pieces",
            "Single large message",
            "HTTP download better",
            "Not possible"
        ]
    },
    {
        "q": "What is device authentication for IoT?",
        "o": [
            "Verify device identity on connect",
            "No authentication needed",
            "User login only",
            "Password per message"
        ]
    },
    {
        "q": "How do you implement device certificates?",
        "o": [
            "TLS client certificates",
            "Socket.io certificates",
            "Not supported",
            "Username password only"
        ]
    },
    {
        "q": "What is secure element integration?",
        "o": [
            "Hardware-backed key storage",
            "Element UI library",
            "Secure room",
            "Encrypted namespace"
        ]
    },
    {
        "q": "How do you handle device provisioning?",
        "o": [
            "Initial setup and credential exchange",
            "Pre-configured devices",
            "No provisioning needed",
            "Manual setup only"
        ]
    },
    {
        "q": "What is device twin synchronization?",
        "o": [
            "Keep device and shadow in sync",
            "Twin devices paired",
            "Duplicate connections",
            "Backup device"
        ]
    },
    {
        "q": "How do you handle sync conflicts?",
        "o": [
            "Timestamp-based resolution",
            "Server always wins",
            "Device always wins",
            "No conflicts possible"
        ]
    },
    {
        "q": "What is desired vs reported state?",
        "o": [
            "What should be vs what is",
            "Same thing",
            "Future vs past",
            "Server vs client"
        ]
    },
    {
        "q": "How do you reconcile state differences?",
        "o": [
            "Send delta to device",
            "Full state always",
            "Device pulls changes",
            "Ignore differences"
        ]
    },
    {
        "q": "What is Socket.io for gaming applications?",
        "o": [
            "Real-time multiplayer communication",
            "Not suitable for games",
            "Turn-based only",
            "Single player only"
        ]
    },
    {
        "q": "How do you handle game state synchronization?",
        "o": [
            "Server authoritative with client prediction",
            "Client authoritative",
            "No synchronization",
            "Database sync only"
        ]
    },
    {
        "q": "What is client-side prediction?",
        "o": [
            "Immediate local response before server confirms",
            "Predict network issues",
            "Forecast game outcome",
            "Client wins always"
        ]
    },
    {
        "q": "How do you implement rollback for games?",
        "o": [
            "Revert incorrect predictions",
            "No rollback needed",
            "Server restarts",
            "Freeze on conflict"
        ]
    },
    {
        "q": "What is input delay compensation?",
        "o": [
            "Account for network latency in inputs",
            "Reduce input frequency",
            "Buffer all inputs",
            "Ignore delay"
        ]
    },
    {
        "q": "How do you handle tick rate in games?",
        "o": [
            "Server updates at fixed intervals",
            "Update on every event",
            "Random intervals",
            "Client determines rate"
        ]
    },
    {
        "q": "What is lockstep synchronization?",
        "o": [
            "All clients process same inputs",
            "Lock game progress",
            "Synchronized saves",
            "Step-by-step movement"
        ]
    },
    {
        "q": "How do you implement lockstep with Socket.io?",
        "o": [
            "Broadcast inputs to all, execute together",
            "Server executes, sends state",
            "Not applicable",
            "Built-in lockstep"
        ]
    },
    {
        "q": "What is deterministic simulation?",
        "o": [
            "Same inputs produce same outputs",
            "Random game events",
            "Predictable outcomes",
            "Server decides results"
        ]
    },
    {
        "q": "How do you ensure determinism?",
        "o": [
            "Use seeded random and fixed math",
            "Automatic determinism",
            "Not possible in JS",
            "Use server state only"
        ]
    },
    {
        "q": "How do you implement spectator mode?",
        "o": [
            "Send game state with delay",
            "Live state always",
            "Different room",
            "Not supported"
        ]
    },
    {
        "q": "What is lag compensation in games?",
        "o": [
            "Adjust for network delay in hit detection",
            "Reduce visual lag",
            "Speed up rendering",
            "Increase tick rate"
        ]
    },
    {
        "q": "How do you implement matchmaking with Socket.io?",
        "o": [
            "Queue players and create game rooms",
            "Random room assignment",
            "First available room",
            "No matchmaking possible"
        ]
    },
    {
        "q": "What is skill-based matchmaking?",
        "o": [
            "Match players by similar skill level",
            "Skill-based room names",
            "Training mode only",
            "Expert rooms"
        ]
    },
    {
        "q": "How do you handle player disconnection in games?",
        "o": [
            "Grace period for reconnection",
            "Immediate removal",
            "Game pauses",
            "Replace with AI"
        ]
    },
    {
        "q": "What is host migration in peer-hosted games?",
        "o": [
            "Transfer hosting to another player",
            "Migrate to new server",
            "Change region",
            "Switch transport"
        ]
    },
    {
        "q": "How do you implement leaderboards with Socket.io?",
        "o": [
            "Real-time score updates via events",
            "Database only",
            "HTTP polling",
            "Static leaderboard"
        ]
    },
    {
        "q": "What is anti-cheat consideration for Socket.io games?",
        "o": [
            "Server authoritative validation",
            "Client-side only",
            "No cheating possible",
            "Trust client data"
        ]
    },
    {
        "q": "How do you validate game actions server-side?",
        "o": [
            "Check action validity before applying",
            "Accept all client actions",
            "Validation not needed",
            "Client validates only"
        ]
    },
    {
        "q": "What is physics synchronization challenge?",
        "o": [
            "Floating point differences across clients",
            "Gravity variations",
            "Collision bugs",
            "Frame rate issues"
        ]
    },
    {
        "q": "How do you sync physics in multiplayer?",
        "o": [
            "Deterministic physics library",
            "Server sends all positions",
            "No physics sync",
            "Client-side only"
        ]
    },
    {
        "q": "What is interest management?",
        "o": [
            "Send only relevant data to each player",
            "Track player interests",
            "Manage subscriptions",
            "Room preferences"
        ]
    },
    {
        "q": "How do you implement area of interest?",
        "o": [
            "Send updates for nearby entities only",
            "Send all updates always",
            "Built-in in Socket.io",
            "Not possible"
        ]
    },
    {
        "q": "What is delta compression for game state?",
        "o": [
            "Send only changed values",
            "Compress full state",
            "Reduce precision",
            "Short field names"
        ]
    },
    {
        "q": "How do you implement entity interpolation?",
        "o": [
            "Smooth movement between updates",
            "Instant position changes",
            "Delay all rendering",
            "Predict all movement"
        ]
    },
    {
        "q": "What is extrapolation in game networking?",
        "o": [
            "Predict future position from velocity",
            "Extend game session",
            "Extra data fields",
            "Additional validation"
        ]
    },
    {
        "q": "How do you handle cross-platform Socket.io clients?",
        "o": [
            "Use platform-specific client libraries",
            "Same library for all",
            "Web only",
            "Not possible"
        ]
    },
    {
        "q": "What Socket.io client exists for iOS?",
        "o": [
            "socket.io-client-swift",
            "socket.io-objc",
            "ios-socket",
            "apple-socket"
        ]
    },
    {
        "q": "What Socket.io client exists for Android?",
        "o": [
            "socket.io-client-java",
            "socket.io-android",
            "google-socket",
            "android-realtime"
        ]
    },
    {
        "q": "How do you handle background mode on mobile?",
        "o": [
            "Disconnect and reconnect on foreground",
            "Keep connection always",
            "No special handling",
            "Background not supported"
        ]
    },
    {
        "q": "What is battery optimization impact on mobile?",
        "o": [
            "OS may kill background connections",
            "No impact",
            "Better battery always",
            "Connection preserved"
        ]
    },
    {
        "q": "How do you handle network type changes on mobile?",
        "o": [
            "Detect change and reconnect",
            "Automatic handling",
            "No reconnection needed",
            "Force WiFi only"
        ]
    },
    {
        "q": "What is push notification complement to Socket.io?",
        "o": [
            "Alert when app is closed",
            "Replace Socket.io",
            "Same functionality",
            "Push not needed"
        ]
    },
    {
        "q": "How do you implement hybrid push and Socket.io?",
        "o": [
            "Socket.io when connected, push when not",
            "Use both always",
            "Push only",
            "Socket.io only"
        ]
    },
    {
        "q": "What is deep linking with Socket.io?",
        "o": [
            "Open app from link and connect",
            "Long links in messages",
            "Direct connections",
            "Link rooms together"
        ]
    },
    {
        "q": "How do you secure Socket.io on mobile?",
        "o": [
            "TLS, certificate pinning, token auth",
            "Default security sufficient",
            "No security needed",
            "Username password only"
        ]
    },
    {
        "q": "What is certificate pinning for Socket.io?",
        "o": [
            "Validate server certificate hash",
            "Pin connection to server",
            "Certificate storage",
            "Auto-renewal"
        ]
    },
    {
        "q": "How do you implement offline queue on mobile?",
        "o": [
            "Store messages locally, send on reconnect",
            "Discard offline messages",
            "Wait for connection",
            "Not possible"
        ]
    },
    {
        "q": "What is local-first architecture with Socket.io?",
        "o": [
            "Work offline, sync when connected",
            "Local server only",
            "No cloud connection",
            "Database first"
        ]
    },
    {
        "q": "How do you handle conflict resolution in local-first?",
        "o": [
            "CRDTs or timestamp-based merge",
            "Server always wins",
            "No conflicts possible",
            "Manual resolution only"
        ]
    }
]