[
  {
    "q": "What does WebSocket provide that HTTP does not?",
    "o": [
      "Full-duplex bidirectional communication",
      "One-way server to client communication",
      "Request-response only communication",
      "Stateless communication"
    ]
  },
  {
    "q": "Which protocol does WebSocket use for the initial handshake?",
    "o": [
      "HTTP",
      "TCP",
      "UDP",
      "FTP"
    ]
  },
  {
    "q": "What is the default port for WebSocket connections over HTTP?",
    "o": [
      "80",
      "443",
      "8080",
      "3000"
    ]
  },
  {
    "q": "What is the default port for secure WebSocket (wss://) connections?",
    "o": [
      "443",
      "80",
      "8443",
      "3000"
    ]
  },
  {
    "q": "Which header is used to upgrade an HTTP connection to WebSocket?",
    "o": [
      "Upgrade: websocket",
      "Connection: websocket",
      "Protocol: websocket",
      "Type: websocket"
    ]
  },
  {
    "q": "What does the 'ws://' prefix indicate in a WebSocket URL?",
    "o": [
      "Unsecured WebSocket connection",
      "Secured WebSocket connection",
      "Web service connection",
      "Web server connection"
    ]
  },
  {
    "q": "What does the 'wss://' prefix indicate in a WebSocket URL?",
    "o": [
      "Secured WebSocket over TLS/SSL",
      "Web socket service",
      "Unsecured WebSocket",
      "Web server socket"
    ]
  },
  {
    "q": "Which JavaScript API is used to create a WebSocket connection?",
    "o": [
      "new WebSocket(url)",
      "WebSocket.connect(url)",
      "createWebSocket(url)",
      "openWebSocket(url)"
    ]
  },
  {
    "q": "What event is triggered when a WebSocket connection is established?",
    "o": [
      "onopen",
      "onconnect",
      "onstart",
      "onready"
    ]
  },
  {
    "q": "What event is triggered when a message is received via WebSocket?",
    "o": [
      "onmessage",
      "onreceive",
      "ondata",
      "oninput"
    ]
  },
  {
    "q": "What event is triggered when a WebSocket connection is closed?",
    "o": [
      "onclose",
      "ondisconnect",
      "onend",
      "onterminate"
    ]
  },
  {
    "q": "What event is triggered when a WebSocket error occurs?",
    "o": [
      "onerror",
      "onfail",
      "onexception",
      "onproblem"
    ]
  },
  {
    "q": "Which method is used to send data through a WebSocket?",
    "o": [
      "send()",
      "write()",
      "transmit()",
      "push()"
    ]
  },
  {
    "q": "Which method is used to close a WebSocket connection?",
    "o": [
      "close()",
      "disconnect()",
      "terminate()",
      "end()"
    ]
  },
  {
    "q": "What is the readyState value when a WebSocket is connecting?",
    "o": [
      "0",
      "1",
      "2",
      "3"
    ]
  },
  {
    "q": "What is the readyState value when a WebSocket is open?",
    "o": [
      "1",
      "0",
      "2",
      "3"
    ]
  },
  {
    "q": "What is the readyState value when a WebSocket is closing?",
    "o": [
      "2",
      "0",
      "1",
      "3"
    ]
  },
  {
    "q": "What is the readyState value when a WebSocket is closed?",
    "o": [
      "3",
      "0",
      "1",
      "2"
    ]
  },
  {
    "q": "What type of data can be sent through a WebSocket?",
    "o": [
      "String, ArrayBuffer, Blob",
      "Only strings",
      "Only JSON objects",
      "Only binary data"
    ]
  },
  {
    "q": "What is a common use case for WebSockets?",
    "o": [
      "Real-time chat applications",
      "Static file serving",
      "Database queries",
      "Image compression"
    ]
  },
  {
    "q": "Which protocol does WebSocket run on top of?",
    "o": [
      "TCP",
      "UDP",
      "HTTP/2",
      "QUIC"
    ]
  },
  {
    "q": "What is the main advantage of WebSocket over HTTP polling?",
    "o": [
      "Lower latency and overhead",
      "Better security",
      "Easier implementation",
      "More browser support"
    ]
  },
  {
    "q": "What is the purpose of the WebSocket handshake?",
    "o": [
      "Upgrade HTTP to WebSocket protocol",
      "Authenticate the user",
      "Encrypt the connection",
      "Compress the data"
    ]
  },
  {
    "q": "Which HTTP status code indicates a successful WebSocket handshake?",
    "o": [
      "101 Switching Protocols",
      "200 OK",
      "201 Created",
      "204 No Content"
    ]
  },
  {
    "q": "What happens if a WebSocket connection is interrupted?",
    "o": [
      "The connection closes and must be re-established",
      "It automatically reconnects",
      "Messages are queued until reconnection",
      "The server maintains the session"
    ]
  },
  {
    "q": "Which header confirms the WebSocket handshake from the server?",
    "o": [
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Key",
      "WebSocket-Confirm",
      "Connection-Accept"
    ]
  },
  {
    "q": "What is the purpose of the Sec-WebSocket-Key header?",
    "o": [
      "Prevent caching proxies from interfering",
      "Encrypt the connection",
      "Authenticate the client",
      "Compress the data"
    ]
  },
  {
    "q": "Can WebSocket connections work through HTTP proxies?",
    "o": [
      "Yes, if the proxy supports CONNECT method",
      "No, never",
      "Only with special configuration",
      "Only over port 443"
    ]
  },
  {
    "q": "What is a WebSocket frame?",
    "o": [
      "The basic unit of WebSocket communication",
      "A security token",
      "A connection state",
      "A protocol version"
    ]
  },
  {
    "q": "What is the maximum size of a WebSocket message?",
    "o": [
      "No defined limit, depends on implementation",
      "64 KB",
      "1 MB",
      "10 MB"
    ]
  },
  {
    "q": "Which of the following is a WebSocket subprotocol?",
    "o": [
      "STOMP",
      "HTTP/2",
      "SMTP",
      "FTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket subprotocols?",
    "o": [
      "Define application-level protocols over WebSocket",
      "Improve security",
      "Increase speed",
      "Reduce bandwidth"
    ]
  },
  {
    "q": "How do you specify a subprotocol when creating a WebSocket?",
    "o": [
      "Pass it as the second parameter to WebSocket constructor",
      "Set it in the URL",
      "Use a special header",
      "Call setProtocol() method"
    ]
  },
  {
    "q": "What is a ping frame in WebSocket?",
    "o": [
      "A control frame to check connection liveness",
      "A data frame",
      "An error frame",
      "A handshake frame"
    ]
  },
  {
    "q": "What is a pong frame in WebSocket?",
    "o": [
      "A response to a ping frame",
      "A data frame",
      "An error frame",
      "A close frame"
    ]
  },
  {
    "q": "Are WebSocket messages guaranteed to arrive in order?",
    "o": [
      "Yes, TCP ensures ordering",
      "No, they can arrive out of order",
      "Only for text messages",
      "Only for binary messages"
    ]
  },
  {
    "q": "What is the purpose of the close frame in WebSocket?",
    "o": [
      "Gracefully terminate the connection",
      "Send final data",
      "Report errors",
      "Reset the connection"
    ]
  },
  {
    "q": "Can you send a close reason when closing a WebSocket?",
    "o": [
      "Yes, using close(code, reason)",
      "No, close() takes no parameters",
      "Only the code, not the reason",
      "Only the reason, not the code"
    ]
  },
  {
    "q": "What is the normal close code for WebSocket?",
    "o": [
      "1000",
      "200",
      "404",
      "500"
    ]
  },
  {
    "q": "What does close code 1001 indicate?",
    "o": [
      "Going away (browser navigating away)",
      "Normal closure",
      "Protocol error",
      "Invalid data"
    ]
  },
  {
    "q": "What does close code 1002 indicate?",
    "o": [
      "Protocol error",
      "Normal closure",
      "Going away",
      "Invalid data"
    ]
  },
  {
    "q": "What does close code 1003 indicate?",
    "o": [
      "Unsupported data type received",
      "Normal closure",
      "Protocol error",
      "Going away"
    ]
  },
  {
    "q": "Which property of the WebSocket object shows the current connection state?",
    "o": [
      "readyState",
      "status",
      "state",
      "connectionState"
    ]
  },
  {
    "q": "What is the bufferedAmount property in WebSocket?",
    "o": [
      "Number of bytes queued but not yet sent",
      "Number of messages received",
      "Size of the receive buffer",
      "Maximum message size"
    ]
  },
  {
    "q": "Can WebSocket be used for streaming video?",
    "o": [
      "Yes, but not ideal for large streams",
      "No, only for text data",
      "Yes, it's the best option",
      "No, only for audio"
    ]
  },
  {
    "q": "What is a common fallback for WebSocket when not supported?",
    "o": [
      "Long polling",
      "Short polling",
      "Server-sent events",
      "AJAX requests"
    ]
  },
  {
    "q": "Which browsers support WebSocket?",
    "o": [
      "All modern browsers",
      "Only Chrome and Firefox",
      "Only desktop browsers",
      "Only mobile browsers"
    ]
  },
  {
    "q": "What is the WebSocket protocol version currently in use?",
    "o": [
      "13",
      "1",
      "2",
      "10"
    ]
  },
  {
    "q": "Can WebSocket connections be load balanced?",
    "o": [
      "Yes, but requires sticky sessions",
      "No, not possible",
      "Yes, without any special configuration",
      "Only with HTTP/2"
    ]
  },
  {
    "q": "What is the origin header used for in WebSocket?",
    "o": [
      "Security to prevent cross-origin attacks",
      "Identify the client",
      "Specify the protocol",
      "Set the connection timeout"
    ]
  },
  {
    "q": "Can you use WebSocket with HTTPS pages?",
    "o": [
      "Yes, using wss:// protocol",
      "No, only with HTTP",
      "Yes, using ws:// protocol",
      "Only in development mode"
    ]
  },
  {
    "q": "What is the extensions header in WebSocket used for?",
    "o": [
      "Negotiate protocol extensions like compression",
      "List supported subprotocols",
      "Specify the WebSocket version",
      "Set the message format"
    ]
  },
  {
    "q": "What is permessage-deflate in WebSocket?",
    "o": [
      "A compression extension",
      "A security feature",
      "A subprotocol",
      "A frame type"
    ]
  },
  {
    "q": "Can WebSocket messages be encrypted?",
    "o": [
      "Yes, using wss:// (WebSocket Secure)",
      "No, encryption is not supported",
      "Only with special libraries",
      "Only on the server side"
    ]
  },
  {
    "q": "What is the main difference between ws:// and wss://?",
    "o": [
      "wss:// uses TLS/SSL encryption",
      "wss:// is faster",
      "wss:// supports more features",
      "wss:// uses a different port"
    ]
  },
  {
    "q": "How do you check if WebSocket is supported in a browser?",
    "o": [
      "Check if 'WebSocket' in window",
      "Try to create a connection",
      "Check navigator.websocket",
      "Use feature detection library only"
    ]
  },
  {
    "q": "What is the purpose of the binaryType property?",
    "o": [
      "Specify how binary data is received (blob or arraybuffer)",
      "Set the data encoding",
      "Enable binary mode",
      "Compress binary data"
    ]
  },
  {
    "q": "What are the two possible values for binaryType?",
    "o": [
      "blob and arraybuffer",
      "binary and text",
      "buffer and stream",
      "base64 and hex"
    ]
  },
  {
    "q": "Can you send JSON data through WebSocket?",
    "o": [
      "Yes, after converting to string with JSON.stringify()",
      "Yes, directly as objects",
      "No, only plain text",
      "No, only binary data"
    ]
  },
  {
    "q": "What is a common Node.js library for WebSocket servers?",
    "o": [
      "ws",
      "websocket-server",
      "socket",
      "net"
    ]
  },
  {
    "q": "What is the purpose of heartbeat messages in WebSocket?",
    "o": [
      "Keep the connection alive and detect failures",
      "Synchronize clocks",
      "Measure latency",
      "Authenticate users"
    ]
  },
  {
    "q": "Can WebSocket work with HTTP/2?",
    "o": [
      "Yes, but uses HTTP/1.1 for handshake",
      "No, incompatible",
      "Yes, fully integrated",
      "Only in specific browsers"
    ]
  },
  {
    "q": "What is the typical use of the url property in WebSocket?",
    "o": [
      "Get the URL used to create the connection",
      "Change the connection URL",
      "Set the server endpoint",
      "Configure the protocol"
    ]
  },
  {
    "q": "What is the protocol property in WebSocket?",
    "o": [
      "The subprotocol selected by the server",
      "The WebSocket version",
      "The transport protocol",
      "The security protocol"
    ]
  },
  {
    "q": "Can you reuse a closed WebSocket connection?",
    "o": [
      "No, must create a new WebSocket instance",
      "Yes, call open() again",
      "Yes, call reconnect()",
      "Yes, reset the state"
    ]
  },
  {
    "q": "What is a common security concern with WebSocket?",
    "o": [
      "Cross-site WebSocket hijacking",
      "SQL injection",
      "XSS attacks only",
      "CSRF tokens"
    ]
  },
  {
    "q": "How can you prevent WebSocket hijacking?",
    "o": [
      "Validate origin header and use authentication tokens",
      "Use only wss://",
      "Disable CORS",
      "Use HTTP-only cookies"
    ]
  },
  {
    "q": "What is the purpose of masking in WebSocket frames?",
    "o": [
      "Prevent cache poisoning by proxies",
      "Encrypt the data",
      "Compress the data",
      "Validate the data"
    ]
  },
  {
    "q": "Are client-to-server WebSocket frames masked?",
    "o": [
      "Yes, always",
      "No, never",
      "Only for binary data",
      "Only for text data"
    ]
  },
  {
    "q": "Are server-to-client WebSocket frames masked?",
    "o": [
      "No, never",
      "Yes, always",
      "Only for binary data",
      "Only for text data"
    ]
  },
  {
    "q": "What is the FIN bit in a WebSocket frame?",
    "o": [
      "Indicates if this is the final fragment",
      "Marks the frame as finished",
      "Signals connection close",
      "Enables compression"
    ]
  },
  {
    "q": "What is fragmentation in WebSocket?",
    "o": [
      "Splitting a message into multiple frames",
      "Compressing data",
      "Encrypting data",
      "Validating data"
    ]
  },
  {
    "q": "Why would you fragment a WebSocket message?",
    "o": [
      "Send large messages without blocking",
      "Improve security",
      "Reduce bandwidth",
      "Increase speed"
    ]
  },
  {
    "q": "What is the opcode in a WebSocket frame?",
    "o": [
      "Identifies the frame type (text, binary, close, etc.)",
      "The operation to perform",
      "The message ID",
      "The sequence number"
    ]
  },
  {
    "q": "What opcode value represents a text frame?",
    "o": [
      "1",
      "0",
      "2",
      "8"
    ]
  },
  {
    "q": "What opcode value represents a binary frame?",
    "o": [
      "2",
      "0",
      "1",
      "8"
    ]
  },
  {
    "q": "What opcode value represents a close frame?",
    "o": [
      "8",
      "0",
      "1",
      "2"
    ]
  },
  {
    "q": "What opcode value represents a ping frame?",
    "o": [
      "9",
      "0",
      "1",
      "8"
    ]
  },
  {
    "q": "What opcode value represents a pong frame?",
    "o": [
      "10",
      "0",
      "1",
      "9"
    ]
  },
  {
    "q": "What is a continuation frame in WebSocket?",
    "o": [
      "A frame that continues a fragmented message",
      "A retry frame",
      "A duplicate frame",
      "A control frame"
    ]
  },
  {
    "q": "Can control frames be fragmented in WebSocket?",
    "o": [
      "No, they must be single frames",
      "Yes, like data frames",
      "Only ping frames",
      "Only close frames"
    ]
  },
  {
    "q": "What is the maximum payload length for a control frame?",
    "o": [
      "125 bytes",
      "256 bytes",
      "1024 bytes",
      "Unlimited"
    ]
  },
  {
    "q": "What is the purpose of the RSV bits in WebSocket frames?",
    "o": [
      "Reserved for extensions",
      "Error checking",
      "Version control",
      "Security flags"
    ]
  },
  {
    "q": "What is a common pattern for reconnecting WebSocket?",
    "o": [
      "Exponential backoff with retry limit",
      "Immediate reconnection",
      "Fixed 1 second delay",
      "Never reconnect automatically"
    ]
  },
  {
    "q": "What is the difference between WebSocket and HTTP/2 Server Push?",
    "o": [
      "WebSocket is bidirectional, Server Push is one-way",
      "They are the same",
      "WebSocket is slower",
      "Server Push is bidirectional"
    ]
  },
  {
    "q": "Can you use cookies with WebSocket?",
    "o": [
      "Yes, sent during handshake",
      "No, not supported",
      "Only with wss://",
      "Only manually"
    ]
  },
  {
    "q": "What is a WebSocket gateway?",
    "o": [
      "A proxy that handles WebSocket connections",
      "A security firewall",
      "A load balancer",
      "A message broker"
    ]
  },
  {
    "q": "What is the typical latency of WebSocket compared to HTTP polling?",
    "o": [
      "Much lower",
      "About the same",
      "Slightly higher",
      "Much higher"
    ]
  },
  {
    "q": "Can WebSocket connections timeout?",
    "o": [
      "Yes, based on server/proxy configuration",
      "No, they last forever",
      "Only after 30 seconds",
      "Only if idle for 1 minute"
    ]
  },
  {
    "q": "What is a common way to authenticate WebSocket connections?",
    "o": [
      "Send token in first message or URL parameter",
      "Use HTTP headers only",
      "Use cookies only",
      "Authentication not possible"
    ]
  },
  {
    "q": "What is the purpose of the Sec-WebSocket-Version header?",
    "o": [
      "Specify the WebSocket protocol version",
      "Specify the application version",
      "Specify the server version",
      "Specify the client version"
    ]
  },
  {
    "q": "What is the main benefit of WebSocket for real-time applications?",
    "o": [
      "Low latency bidirectional communication",
      "Better security",
      "Easier to implement",
      "Better browser support"
    ]
  },
  {
    "q": "Can WebSocket be used for file uploads?",
    "o": [
      "Yes, but HTTP multipart is usually better",
      "No, not supported",
      "Yes, it's the best method",
      "Only for small files"
    ]
  },
  {
    "q": "What is the Connection header value during WebSocket handshake?",
    "o": [
      "Upgrade",
      "Keep-Alive",
      "Close",
      "WebSocket"
    ]
  },
  {
    "q": "What happens if the WebSocket handshake fails?",
    "o": [
      "Connection is closed and onerror is triggered",
      "It retries automatically",
      "Falls back to HTTP",
      "Switches to polling"
    ]
  },
  {
    "q": "What is the typical overhead of a WebSocket frame header?",
    "o": [
      "2-14 bytes",
      "50-100 bytes",
      "100-200 bytes",
      "Over 500 bytes"
    ]
  },
  {
    "q": "How do you implement automatic reconnection for WebSocket?",
    "o": [
      "Listen to onclose event and create new WebSocket instance",
      "Call reconnect() method",
      "Set autoReconnect property to true",
      "WebSocket reconnects automatically"
    ]
  },
  {
    "q": "What is the recommended way to handle WebSocket connection failures?",
    "o": [
      "Implement exponential backoff retry strategy",
      "Retry immediately without delay",
      "Give up after first failure",
      "Switch to HTTP permanently"
    ]
  },
  {
    "q": "How can you detect if a WebSocket connection is still alive?",
    "o": [
      "Send periodic ping/pong frames",
      "Check readyState continuously",
      "Monitor network status",
      "Use HTTP polling"
    ]
  },
  {
    "q": "What is the purpose of a WebSocket heartbeat mechanism?",
    "o": [
      "Detect dead connections and prevent timeout",
      "Synchronize data",
      "Measure bandwidth",
      "Encrypt messages"
    ]
  },
  {
    "q": "How do you implement a heartbeat in WebSocket?",
    "o": [
      "Send ping frames at regular intervals",
      "Use setInterval to send data",
      "Monitor connection state",
      "Use HTTP keep-alive"
    ]
  },
  {
    "q": "What is a common interval for WebSocket heartbeats?",
    "o": [
      "30-60 seconds",
      "1-5 seconds",
      "5-10 minutes",
      "1 millisecond"
    ]
  },
  {
    "q": "How do you handle large messages in WebSocket?",
    "o": [
      "Fragment into smaller chunks manually",
      "WebSocket handles it automatically",
      "Use compression only",
      "Switch to HTTP for large data"
    ]
  },
  {
    "q": "What is the best practice for sending binary data via WebSocket?",
    "o": [
      "Use ArrayBuffer or Blob",
      "Convert to Base64 string",
      "Use JSON encoding",
      "Binary data not supported"
    ]
  },
  {
    "q": "How do you enable compression for WebSocket messages?",
    "o": [
      "Negotiate permessage-deflate extension during handshake",
      "Set compression property to true",
      "Use gzip manually",
      "Compression is automatic"
    ]
  },
  {
    "q": "What is the benefit of permessage-deflate extension?",
    "o": [
      "Reduces bandwidth usage",
      "Improves security",
      "Increases speed",
      "Better compatibility"
    ]
  },
  {
    "q": "How do you validate the origin of a WebSocket connection on the server?",
    "o": [
      "Check the Origin header during handshake",
      "Use CORS headers",
      "Check IP address",
      "Use SSL certificates"
    ]
  },
  {
    "q": "What is the purpose of the Sec-WebSocket-Protocol header?",
    "o": [
      "Negotiate subprotocols between client and server",
      "Set the WebSocket version",
      "Enable encryption",
      "Configure compression"
    ]
  },
  {
    "q": "How do you implement authentication for WebSocket connections?",
    "o": [
      "Send token in URL, header, or first message",
      "Use HTTP Basic Auth only",
      "Authentication not possible",
      "Use cookies only"
    ]
  },
  {
    "q": "What is a common pattern for WebSocket authentication?",
    "o": [
      "Send JWT token after connection opens",
      "Use username/password in URL",
      "Rely on cookies only",
      "No authentication needed"
    ]
  },
  {
    "q": "How do you implement authorization in WebSocket?",
    "o": [
      "Validate permissions on server for each message",
      "Check once during handshake only",
      "Use HTTP headers",
      "Authorization not needed"
    ]
  },
  {
    "q": "What is the risk of not validating WebSocket messages on the server?",
    "o": [
      "Injection attacks and data corruption",
      "Slower performance",
      "Connection drops",
      "No risk"
    ]
  },
  {
    "q": "How do you implement rate limiting for WebSocket connections?",
    "o": [
      "Track message count per connection and reject excess",
      "Use HTTP rate limiting",
      "Not possible with WebSocket",
      "Built-in feature"
    ]
  },
  {
    "q": "What is a WebSocket room pattern?",
    "o": [
      "Grouping connections to broadcast to specific sets",
      "Physical server room",
      "Security zone",
      "Message queue"
    ]
  },
  {
    "q": "How do you broadcast a message to all connected WebSocket clients?",
    "o": [
      "Iterate through all connections and send to each",
      "Use broadcast() method",
      "Send to special broadcast address",
      "Not possible"
    ]
  },
  {
    "q": "What is the challenge of scaling WebSocket servers?",
    "o": [
      "Maintaining persistent connections across multiple servers",
      "Higher CPU usage",
      "Memory limitations",
      "Network bandwidth"
    ]
  },
  {
    "q": "How do you scale WebSocket servers horizontally?",
    "o": [
      "Use message broker like Redis for pub/sub",
      "Just add more servers",
      "Use round-robin DNS",
      "Cannot scale horizontally"
    ]
  },
  {
    "q": "What is sticky session in context of WebSocket load balancing?",
    "o": [
      "Routing client to same server for connection duration",
      "Session that persists after close",
      "Encrypted session",
      "Long-lasting session"
    ]
  },
  {
    "q": "Why are sticky sessions important for WebSocket?",
    "o": [
      "WebSocket is stateful and connection-based",
      "Better performance",
      "Security requirement",
      "Protocol requirement"
    ]
  },
  {
    "q": "What is a common tool for WebSocket load balancing?",
    "o": [
      "HAProxy or Nginx",
      "Apache only",
      "DNS round-robin",
      "No tools available"
    ]
  },
  {
    "q": "How do you configure Nginx for WebSocket proxying?",
    "o": [
      "Set Upgrade and Connection headers in proxy config",
      "Use default HTTP proxy",
      "Special WebSocket module required",
      "Not possible"
    ]
  },
  {
    "q": "What is the purpose of the Upgrade header in WebSocket?",
    "o": [
      "Request protocol upgrade from HTTP to WebSocket",
      "Upgrade the connection speed",
      "Upgrade security level",
      "Upgrade the server"
    ]
  },
  {
    "q": "What is a common debugging tool for WebSocket?",
    "o": [
      "Browser DevTools Network tab",
      "Postman only",
      "curl command",
      "ping command"
    ]
  },
  {
    "q": "How do you monitor WebSocket traffic in Chrome DevTools?",
    "o": [
      "Network tab, filter by WS, view frames",
      "Console tab only",
      "Performance tab",
      "Not possible"
    ]
  },
  {
    "q": "What information can you see in WebSocket frames in DevTools?",
    "o": [
      "Message content, length, opcode, and timestamp",
      "Only message content",
      "Only connection status",
      "Nothing useful"
    ]
  },
  {
    "q": "How do you test WebSocket connections programmatically?",
    "o": [
      "Use WebSocket client libraries in test frameworks",
      "Use HTTP testing tools",
      "Manual testing only",
      "Not possible to test"
    ]
  },
  {
    "q": "What is wscat used for?",
    "o": [
      "Command-line WebSocket client for testing",
      "WebSocket server",
      "WebSocket debugger",
      "WebSocket compiler"
    ]
  },
  {
    "q": "How do you handle WebSocket errors gracefully?",
    "o": [
      "Implement onerror handler with logging and retry logic",
      "Ignore errors",
      "Restart server",
      "Close all connections"
    ]
  },
  {
    "q": "What is the difference between close() and terminate() in ws library?",
    "o": [
      "close() is graceful, terminate() is immediate",
      "They are the same",
      "terminate() is graceful",
      "close() is immediate"
    ]
  },
  {
    "q": "How do you implement message queuing for WebSocket?",
    "o": [
      "Buffer messages when connection is not ready",
      "Use external queue service",
      "Not needed",
      "Built-in feature"
    ]
  },
  {
    "q": "What is the purpose of checking readyState before sending?",
    "o": [
      "Ensure connection is open to avoid errors",
      "Improve performance",
      "Security measure",
      "Not necessary"
    ]
  },
  {
    "q": "How do you handle backpressure in WebSocket?",
    "o": [
      "Monitor bufferedAmount and pause sending if too high",
      "Ignore it",
      "Increase buffer size",
      "Not an issue"
    ]
  },
  {
    "q": "What is bufferedAmount used for?",
    "o": [
      "Check how much data is queued but not sent",
      "Set buffer size",
      "Count received messages",
      "Measure latency"
    ]
  },
  {
    "q": "When should you check bufferedAmount?",
    "o": [
      "Before sending large amounts of data",
      "After receiving messages",
      "During handshake",
      "Never needed"
    ]
  },
  {
    "q": "How do you implement request-response pattern over WebSocket?",
    "o": [
      "Add message ID and match responses to requests",
      "Use HTTP instead",
      "Not possible",
      "Built-in feature"
    ]
  },
  {
    "q": "What is a correlation ID in WebSocket messaging?",
    "o": [
      "Unique identifier to match requests with responses",
      "Connection identifier",
      "User identifier",
      "Server identifier"
    ]
  },
  {
    "q": "How do you implement timeouts for WebSocket requests?",
    "o": [
      "Use setTimeout and reject promise if no response",
      "Built-in timeout feature",
      "Not possible",
      "Use HTTP timeout"
    ]
  },
  {
    "q": "What is the purpose of message acknowledgment in WebSocket?",
    "o": [
      "Confirm message was received and processed",
      "Encrypt messages",
      "Compress messages",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement message ordering guarantees?",
    "o": [
      "TCP ensures order, add sequence numbers for app-level",
      "Use special protocol",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the difference between WebSocket and Socket.IO?",
    "o": [
      "Socket.IO is a library with fallbacks, WebSocket is protocol",
      "They are the same",
      "WebSocket is newer",
      "Socket.IO is faster"
    ]
  },
  {
    "q": "When would you choose Socket.IO over raw WebSocket?",
    "o": [
      "Need automatic reconnection and fallback mechanisms",
      "Better performance needed",
      "Simpler implementation",
      "Never, WebSocket is always better"
    ]
  },
  {
    "q": "What is a WebSocket subprotocol example?",
    "o": [
      "STOMP, WAMP, MQTT",
      "HTTP, HTTPS",
      "TCP, UDP",
      "FTP, SMTP"
    ]
  },
  {
    "q": "What is STOMP in context of WebSocket?",
    "o": [
      "Simple Text Oriented Messaging Protocol",
      "Secure Transport Over Message Protocol",
      "Socket Transmission Optimization Method",
      "Server Time Optimization Protocol"
    ]
  },
  {
    "q": "What is WAMP protocol?",
    "o": [
      "Web Application Messaging Protocol",
      "WebSocket Advanced Messaging Protocol",
      "Wide Area Messaging Protocol",
      "Wireless Application Messaging Protocol"
    ]
  },
  {
    "q": "How do you handle connection state management in WebSocket?",
    "o": [
      "Track state on both client and server sides",
      "Server side only",
      "Client side only",
      "Not needed"
    ]
  },
  {
    "q": "What is a common pattern for WebSocket message format?",
    "o": [
      "JSON with type and payload fields",
      "Plain text only",
      "Binary only",
      "XML format"
    ]
  },
  {
    "q": "How do you version WebSocket API messages?",
    "o": [
      "Include version field in message structure",
      "Use different ports",
      "Use different URLs",
      "Not possible"
    ]
  },
  {
    "q": "What is the purpose of message typing in WebSocket?",
    "o": [
      "Identify message purpose for proper handling",
      "Improve performance",
      "Security measure",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement pub/sub pattern with WebSocket?",
    "o": [
      "Clients subscribe to topics, server routes messages",
      "Use external message broker only",
      "Not possible",
      "Built-in feature"
    ]
  },
  {
    "q": "What is a WebSocket namespace?",
    "o": [
      "Logical separation of connections for different purposes",
      "DNS namespace",
      "Variable scope",
      "Server cluster"
    ]
  },
  {
    "q": "How do you implement presence detection with WebSocket?",
    "o": [
      "Track connections and broadcast join/leave events",
      "Use HTTP polling",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is a typing indicator in WebSocket chat applications?",
    "o": [
      "Real-time notification when user is typing",
      "Text formatting tool",
      "Spell checker",
      "Message counter"
    ]
  },
  {
    "q": "How do you implement read receipts in WebSocket messaging?",
    "o": [
      "Send acknowledgment message when message is read",
      "Use HTTP callback",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the challenge of implementing file transfer over WebSocket?",
    "o": [
      "Large files can block other messages",
      "Not supported",
      "Security issues",
      "No challenges"
    ]
  },
  {
    "q": "How do you transfer files efficiently via WebSocket?",
    "o": [
      "Chunk file and send with progress updates",
      "Send entire file at once",
      "Use Base64 encoding",
      "Not recommended"
    ]
  },
  {
    "q": "What is a common use case for binary WebSocket messages?",
    "o": [
      "Streaming audio/video or game data",
      "Text chat only",
      "HTML content",
      "JSON data"
    ]
  },
  {
    "q": "How do you handle different message types in WebSocket?",
    "o": [
      "Use message type field and switch/case logic",
      "Separate connections for each type",
      "Not possible",
      "Automatic routing"
    ]
  },
  {
    "q": "What is the purpose of a WebSocket event emitter pattern?",
    "o": [
      "Decouple message handling from connection logic",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement middleware for WebSocket messages?",
    "o": [
      "Chain functions that process messages before handling",
      "Use HTTP middleware",
      "Not possible",
      "Built-in feature"
    ]
  },
  {
    "q": "What is connection pooling in WebSocket context?",
    "o": [
      "Reusing connections for multiple logical channels",
      "Database connection pool",
      "Thread pool",
      "Not applicable"
    ]
  },
  {
    "q": "How do you handle WebSocket connection limits?",
    "o": [
      "Implement connection throttling and rejection logic",
      "Unlimited connections allowed",
      "Use more servers",
      "Not an issue"
    ]
  },
  {
    "q": "What is a common memory issue with WebSocket servers?",
    "o": [
      "Memory leaks from not cleaning up closed connections",
      "Too much CPU usage",
      "Disk space",
      "No memory issues"
    ]
  },
  {
    "q": "How do you prevent memory leaks in WebSocket servers?",
    "o": [
      "Remove event listeners and clear references on close",
      "Restart server regularly",
      "Use more memory",
      "Not preventable"
    ]
  },
  {
    "q": "What is the purpose of connection metadata in WebSocket?",
    "o": [
      "Store user info, session data, and state",
      "Improve performance",
      "Security measure",
      "Not needed"
    ]
  },
  {
    "q": "How do you associate user sessions with WebSocket connections?",
    "o": [
      "Store session ID with connection object",
      "Use cookies only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the risk of not implementing connection timeouts?",
    "o": [
      "Dead connections consume server resources",
      "Security breach",
      "Data corruption",
      "No risk"
    ]
  },
  {
    "q": "How do you implement idle connection detection?",
    "o": [
      "Track last activity time and close if exceeded",
      "Use ping/pong only",
      "Not needed",
      "Automatic feature"
    ]
  },
  {
    "q": "What is a zombie connection in WebSocket?",
    "o": [
      "Connection that appears open but is actually dead",
      "Slow connection",
      "Unauthorized connection",
      "Encrypted connection"
    ]
  },
  {
    "q": "How do you detect zombie connections?",
    "o": [
      "Send ping and close if no pong received",
      "Check IP address",
      "Monitor bandwidth",
      "Not detectable"
    ]
  },
  {
    "q": "What is the purpose of graceful shutdown for WebSocket servers?",
    "o": [
      "Close connections properly before server stops",
      "Improve performance",
      "Security measure",
      "Not important"
    ]
  },
  {
    "q": "How do you implement graceful shutdown?",
    "o": [
      "Stop accepting new connections, close existing ones",
      "Kill process immediately",
      "Restart server",
      "Not possible"
    ]
  },
  {
    "q": "What is the challenge of debugging WebSocket applications?",
    "o": [
      "Asynchronous nature and stateful connections",
      "Lack of tools",
      "Security restrictions",
      "No challenges"
    ]
  },
  {
    "q": "How do you log WebSocket messages for debugging?",
    "o": [
      "Implement logging in onmessage and send handlers",
      "Use HTTP logs",
      "Not possible",
      "Automatic logging"
    ]
  },
  {
    "q": "What is a common performance bottleneck in WebSocket?",
    "o": [
      "Message serialization and deserialization",
      "Network latency only",
      "CPU usage",
      "No bottlenecks"
    ]
  },
  {
    "q": "How do you optimize WebSocket message parsing?",
    "o": [
      "Use efficient serialization formats like MessagePack",
      "Use larger messages",
      "Use compression only",
      "Not optimizable"
    ]
  },
  {
    "q": "What is MessagePack in context of WebSocket?",
    "o": [
      "Binary serialization format more efficient than JSON",
      "Message queue system",
      "Compression algorithm",
      "Security protocol"
    ]
  },
  {
    "q": "How do you handle WebSocket connection drops during deployment?",
    "o": [
      "Implement client-side reconnection logic",
      "Prevent deployments",
      "Use sticky sessions only",
      "Not possible"
    ]
  },
  {
    "q": "What is a blue-green deployment strategy for WebSocket?",
    "o": [
      "Run two environments, switch traffic after new version ready",
      "Use two different protocols",
      "Deploy to half servers at a time",
      "Not applicable"
    ]
  },
  {
    "q": "How do you migrate WebSocket connections during deployment?",
    "o": [
      "Drain connections from old servers before shutdown",
      "Force disconnect all clients",
      "Not possible",
      "Automatic migration"
    ]
  },
  {
    "q": "What is the purpose of WebSocket protocol negotiation?",
    "o": [
      "Agree on subprotocol and extensions to use",
      "Negotiate bandwidth",
      "Negotiate timeout",
      "Not needed"
    ]
  },
  {
    "q": "How do you handle protocol version mismatches?",
    "o": [
      "Reject connection with appropriate error code",
      "Use older version",
      "Use newer version",
      "Ignore version"
    ]
  },
  {
    "q": "What is the Sec-WebSocket-Extensions header used for?",
    "o": [
      "Negotiate optional protocol extensions like compression",
      "List required extensions",
      "Security settings",
      "Connection timeout"
    ]
  },
  {
    "q": "How do you implement custom WebSocket extensions?",
    "o": [
      "Define extension behavior and negotiate during handshake",
      "Modify protocol",
      "Not possible",
      "Use subprotocols instead"
    ]
  },
  {
    "q": "What is the difference between extension and subprotocol?",
    "o": [
      "Extensions modify protocol, subprotocols define message format",
      "They are the same",
      "Extensions are faster",
      "Subprotocols are more secure"
    ]
  },
  {
    "q": "How do you handle WebSocket in service workers?",
    "o": [
      "Service workers cannot directly use WebSocket",
      "Full WebSocket support",
      "Limited support",
      "Better than main thread"
    ]
  },
  {
    "q": "What is a workaround for WebSocket in service workers?",
    "o": [
      "Use postMessage to communicate with main thread",
      "Use HTTP instead",
      "Not possible",
      "Use Web Workers"
    ]
  },
  {
    "q": "How do you implement WebSocket in Web Workers?",
    "o": [
      "Create WebSocket instance directly in worker",
      "Not supported",
      "Use SharedWorker only",
      "Proxy through main thread"
    ]
  },
  {
    "q": "What is the benefit of using WebSocket in Web Workers?",
    "o": [
      "Offload message processing from main thread",
      "Better security",
      "Faster connection",
      "No benefits"
    ]
  },
  {
    "q": "How do you share WebSocket connection across browser tabs?",
    "o": [
      "Use SharedWorker to manage single connection",
      "Create connection in each tab",
      "Use localStorage",
      "Not possible"
    ]
  },
  {
    "q": "What is the challenge of using SharedWorker for WebSocket?",
    "o": [
      "Limited browser support and complexity",
      "Performance issues",
      "Security concerns",
      "No challenges"
    ]
  },
  {
    "q": "How do you handle WebSocket reconnection after browser sleep?",
    "o": [
      "Detect page visibility change and reconnect",
      "Automatic reconnection",
      "Not possible",
      "Use HTTP polling"
    ]
  },
  {
    "q": "What is the Page Visibility API used for with WebSocket?",
    "o": [
      "Detect when page is hidden to pause heartbeats",
      "Hide WebSocket traffic",
      "Improve security",
      "Not related"
    ]
  },
  {
    "q": "How do you optimize WebSocket for mobile networks?",
    "o": [
      "Use compression, reduce heartbeat frequency, handle reconnects",
      "Use HTTP instead",
      "Increase message size",
      "Not possible"
    ]
  },
  {
    "q": "What is the impact of mobile network switching on WebSocket?",
    "o": [
      "Connection drops when switching between WiFi and cellular",
      "No impact",
      "Faster connection",
      "Better stability"
    ]
  },
  {
    "q": "How do you implement a WebSocket proxy server?",
    "o": [
      "Forward frames between client and backend server",
      "Translate to HTTP",
      "Cache all messages",
      "Not possible"
    ]
  },
  {
    "q": "What is the purpose of WebSocket compression context takeover?",
    "o": [
      "Reuse compression context across messages for better ratio",
      "Take control of connection",
      "Security feature",
      "Error handling"
    ]
  },
  {
    "q": "How do you configure permessage-deflate window bits?",
    "o": [
      "Set server_max_window_bits and client_max_window_bits parameters",
      "Use default settings only",
      "Not configurable",
      "Set in URL"
    ]
  },
  {
    "q": "What is the trade-off of using WebSocket compression?",
    "o": [
      "Reduced bandwidth but increased CPU usage",
      "Slower speed",
      "Less security",
      "No trade-offs"
    ]
  },
  {
    "q": "How do you handle WebSocket message ordering across multiple connections?",
    "o": [
      "Use timestamps or sequence numbers at application level",
      "TCP handles it",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message batching?",
    "o": [
      "Reduce overhead by combining multiple messages",
      "Improve security",
      "Enable compression",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message batching in WebSocket?",
    "o": [
      "Collect messages and send as array at intervals",
      "Built-in feature",
      "Not possible",
      "Use fragmentation"
    ]
  },
  {
    "q": "What is the impact of message size on WebSocket performance?",
    "o": [
      "Very large messages can cause head-of-line blocking",
      "No impact",
      "Larger is always better",
      "Smaller is always better"
    ]
  },
  {
    "q": "How do you optimize WebSocket for high-frequency trading?",
    "o": [
      "Minimize serialization, use binary, reduce latency",
      "Use HTTP instead",
      "Increase message size",
      "Not suitable"
    ]
  },
  {
    "q": "What is the purpose of WebSocket flow control?",
    "o": [
      "Prevent overwhelming receiver with too much data",
      "Control message routing",
      "Security measure",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement application-level flow control?",
    "o": [
      "Send pause/resume messages based on buffer state",
      "Use TCP flow control only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message priorities?",
    "o": [
      "Ensure critical messages are processed first",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message priorities in WebSocket?",
    "o": [
      "Use multiple connections or priority queues",
      "Built-in feature",
      "Not possible",
      "Use different ports"
    ]
  },
  {
    "q": "What is multiplexing in WebSocket context?",
    "o": [
      "Multiple logical streams over single connection",
      "Multiple connections",
      "Message compression",
      "Load balancing"
    ]
  },
  {
    "q": "How do you implement WebSocket multiplexing?",
    "o": [
      "Add channel ID to messages and route accordingly",
      "Use HTTP/2",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the benefit of WebSocket multiplexing?",
    "o": [
      "Reduce connection overhead and resource usage",
      "Better security",
      "Faster speed",
      "No benefits"
    ]
  },
  {
    "q": "How do you handle WebSocket connection migration?",
    "o": [
      "Transfer state and reconnect to new server",
      "Not possible",
      "Automatic feature",
      "Use load balancer"
    ]
  },
  {
    "q": "What is session affinity in WebSocket load balancing?",
    "o": [
      "Routing requests from same client to same server",
      "Security feature",
      "Performance optimization",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket clustering?",
    "o": [
      "Use Redis pub/sub or message broker for inter-server communication",
      "Just add more servers",
      "Not possible",
      "Use DNS"
    ]
  },
  {
    "q": "What is the purpose of WebSocket health checks?",
    "o": [
      "Monitor server availability for load balancer",
      "Check client health",
      "Virus scanning",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement WebSocket health check endpoint?",
    "o": [
      "Provide HTTP endpoint that checks WebSocket server status",
      "Use ping/pong only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the challenge of WebSocket behind corporate firewalls?",
    "o": [
      "Firewalls may block or interfere with connections",
      "No challenges",
      "Better security",
      "Faster connection"
    ]
  },
  {
    "q": "How do you troubleshoot WebSocket firewall issues?",
    "o": [
      "Use wss:// on port 443, check proxy settings",
      "Use different protocol",
      "Not solvable",
      "Disable firewall"
    ]
  },
  {
    "q": "What is the purpose of WebSocket keep-alive probes?",
    "o": [
      "Prevent middleboxes from closing idle connections",
      "Measure latency",
      "Security check",
      "Not needed"
    ]
  },
  {
    "q": "How often should you send WebSocket keep-alive messages?",
    "o": [
      "Based on network timeout, typically 30-60 seconds",
      "Every second",
      "Every 10 minutes",
      "Not needed"
    ]
  },
  {
    "q": "What is the impact of WebSocket on server resources?",
    "o": [
      "Each connection consumes memory and file descriptor",
      "No impact",
      "Only CPU usage",
      "Only bandwidth"
    ]
  },
  {
    "q": "How do you optimize WebSocket server for many connections?",
    "o": [
      "Use efficient event loop, minimize per-connection memory",
      "Add more CPU",
      "Use HTTP instead",
      "Not optimizable"
    ]
  },
  {
    "q": "What is the C10K problem in context of WebSocket?",
    "o": [
      "Handling 10,000 concurrent connections efficiently",
      "10KB message limit",
      "10 second timeout",
      "Not related"
    ]
  },
  {
    "q": "How do you solve the C10K problem for WebSocket?",
    "o": [
      "Use non-blocking I/O and event-driven architecture",
      "Use more threads",
      "Limit connections",
      "Not solvable"
    ]
  },
  {
    "q": "What is epoll in context of WebSocket servers?",
    "o": [
      "Linux kernel mechanism for efficient I/O event notification",
      "Error polling",
      "Event protocol",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket rate limiting per user?",
    "o": [
      "Track message count per user ID and throttle",
      "Use HTTP rate limiting",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is token bucket algorithm for WebSocket rate limiting?",
    "o": [
      "Allow burst traffic while maintaining average rate",
      "Authentication method",
      "Message format",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket message validation?",
    "o": [
      "Define schema and validate each message on server",
      "Client-side only",
      "Not needed",
      "Automatic feature"
    ]
  },
  {
    "q": "What is JSON Schema used for in WebSocket?",
    "o": [
      "Validate message structure and data types",
      "Compress messages",
      "Encrypt messages",
      "Not related"
    ]
  },
  {
    "q": "How do you handle WebSocket message replay attacks?",
    "o": [
      "Use nonces or timestamps and reject duplicates",
      "Use HTTPS only",
      "Not possible",
      "Not a concern"
    ]
  },
  {
    "q": "What is a nonce in WebSocket security?",
    "o": [
      "Number used once to prevent replay attacks",
      "Connection ID",
      "Message ID",
      "User ID"
    ]
  },
  {
    "q": "How do you implement WebSocket message encryption?",
    "o": [
      "Use wss:// for transport, add application-level encryption if needed",
      "Use HTTP encryption",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is end-to-end encryption in WebSocket messaging?",
    "o": [
      "Encrypt messages so only sender and receiver can read",
      "Encrypt connection only",
      "Server-side encryption",
      "Not possible"
    ]
  },
  {
    "q": "How do you implement end-to-end encryption over WebSocket?",
    "o": [
      "Use libraries like libsodium or Web Crypto API",
      "Use wss:// only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message signing?",
    "o": [
      "Verify message authenticity and integrity",
      "Compress messages",
      "Route messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message signing in WebSocket?",
    "o": [
      "Use HMAC or digital signatures with shared/public keys",
      "Use HTTPS only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is HMAC used for in WebSocket security?",
    "o": [
      "Create message authentication codes",
      "Encrypt messages",
      "Compress messages",
      "Not related"
    ]
  },
  {
    "q": "How do you prevent WebSocket denial of service attacks?",
    "o": [
      "Implement rate limiting, connection limits, and validation",
      "Use firewall only",
      "Not preventable",
      "Use HTTPS"
    ]
  },
  {
    "q": "What is a slowloris attack on WebSocket?",
    "o": [
      "Slowly sending data to exhaust server resources",
      "Fast message flooding",
      "Encryption attack",
      "Not applicable"
    ]
  },
  {
    "q": "How do you protect against slowloris on WebSocket?",
    "o": [
      "Set timeouts for handshake and message completion",
      "Use faster server",
      "Not possible",
      "Use firewall"
    ]
  },
  {
    "q": "What is WebSocket message flooding?",
    "o": [
      "Sending excessive messages to overwhelm server",
      "Network flooding",
      "Data corruption",
      "Not a threat"
    ]
  },
  {
    "q": "How do you detect WebSocket message flooding?",
    "o": [
      "Monitor message rate per connection and flag anomalies",
      "Use firewall",
      "Not detectable",
      "Automatic detection"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection draining?",
    "o": [
      "Gracefully close connections before server shutdown",
      "Remove water from server",
      "Clear message queue",
      "Not a real term"
    ]
  },
  {
    "q": "How do you implement connection draining?",
    "o": [
      "Stop accepting new connections, wait for existing to close",
      "Force close all",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection pooling on client?",
    "o": [
      "Reuse connections for multiple requests",
      "Database pooling",
      "Thread pooling",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement WebSocket reconnection with exponential backoff?",
    "o": [
      "Double delay between retries up to maximum",
      "Fixed delay",
      "Random delay",
      "No delay"
    ]
  },
  {
    "q": "What is jitter in WebSocket reconnection?",
    "o": [
      "Random delay added to prevent thundering herd",
      "Network latency",
      "Message delay",
      "Not related"
    ]
  },
  {
    "q": "What is thundering herd problem in WebSocket?",
    "o": [
      "Many clients reconnecting simultaneously overwhelming server",
      "Too many messages",
      "Network congestion",
      "Not a problem"
    ]
  },
  {
    "q": "How do you prevent thundering herd on reconnection?",
    "o": [
      "Add random jitter to reconnection delays",
      "Use faster server",
      "Limit connections",
      "Not preventable"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message deduplication?",
    "o": [
      "Prevent processing same message multiple times",
      "Compress messages",
      "Validate messages",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement message deduplication?",
    "o": [
      "Track message IDs and ignore duplicates",
      "Use TCP only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is idempotency in WebSocket message handling?",
    "o": [
      "Processing same message multiple times has same effect",
      "Message uniqueness",
      "Message ordering",
      "Not related"
    ]
  },
  {
    "q": "How do you design idempotent WebSocket operations?",
    "o": [
      "Use unique IDs and check if operation already performed",
      "Not possible",
      "Automatic feature",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message acknowledgment?",
    "o": [
      "Confirm receipt and successful processing",
      "Compress messages",
      "Route messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement reliable message delivery over WebSocket?",
    "o": [
      "Use acknowledgments and retransmit unacknowledged messages",
      "TCP handles it",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is at-least-once delivery in WebSocket?",
    "o": [
      "Message delivered one or more times, may duplicate",
      "Exactly once delivery",
      "At most once delivery",
      "Not a pattern"
    ]
  },
  {
    "q": "What is at-most-once delivery in WebSocket?",
    "o": [
      "Message delivered zero or one time, may lose",
      "Exactly once delivery",
      "At least once delivery",
      "Not a pattern"
    ]
  },
  {
    "q": "What is exactly-once delivery in WebSocket?",
    "o": [
      "Message delivered exactly one time, no loss or duplication",
      "At least once delivery",
      "At most once delivery",
      "Not achievable"
    ]
  },
  {
    "q": "How do you achieve exactly-once delivery over WebSocket?",
    "o": [
      "Combine acknowledgments with deduplication",
      "Use TCP only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the challenge of exactly-once delivery?",
    "o": [
      "Requires distributed transaction or complex state management",
      "Too easy",
      "Not useful",
      "No challenges"
    ]
  },
  {
    "q": "How do you implement WebSocket message transactions?",
    "o": [
      "Group messages and commit/rollback as unit",
      "Use database transactions",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is two-phase commit in WebSocket messaging?",
    "o": [
      "Distributed transaction protocol for consistency",
      "Two-step authentication",
      "Message validation",
      "Not related"
    ]
  },
  {
    "q": "How do you handle WebSocket message ordering guarantees?",
    "o": [
      "TCP ensures order within connection, add sequence numbers for app-level",
      "Not possible",
      "Automatic feature",
      "Use timestamps"
    ]
  },
  {
    "q": "What is causal ordering in WebSocket messages?",
    "o": [
      "Messages delivered in cause-effect order",
      "Alphabetical ordering",
      "Time ordering",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement causal ordering?",
    "o": [
      "Use vector clocks or Lamport timestamps",
      "Use system time",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is a vector clock in distributed WebSocket systems?",
    "o": [
      "Data structure to track causality across nodes",
      "Time synchronization",
      "Message counter",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket message versioning?",
    "o": [
      "Include version field in message and handle multiple versions",
      "Use different URLs",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is backward compatibility in WebSocket messaging?",
    "o": [
      "New versions can communicate with old versions",
      "Old versions only",
      "New versions only",
      "Not important"
    ]
  },
  {
    "q": "How do you maintain backward compatibility?",
    "o": [
      "Add optional fields, never remove required fields",
      "Not possible",
      "Version everything",
      "Not needed"
    ]
  },
  {
    "q": "What is schema evolution in WebSocket?",
    "o": [
      "Changing message structure over time while maintaining compatibility",
      "Schema validation",
      "Schema compression",
      "Not a concept"
    ]
  },
  {
    "q": "How do you handle schema evolution?",
    "o": [
      "Use optional fields and default values",
      "Break compatibility",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket protocol buffers?",
    "o": [
      "Efficient binary serialization format",
      "Message buffering",
      "Connection buffering",
      "Not related"
    ]
  },
  {
    "q": "How do Protocol Buffers compare to JSON for WebSocket?",
    "o": [
      "Smaller size and faster parsing but less human-readable",
      "Same performance",
      "Slower than JSON",
      "Not compatible"
    ]
  },
  {
    "q": "What is Apache Avro in context of WebSocket?",
    "o": [
      "Binary serialization with schema evolution support",
      "Message broker",
      "WebSocket server",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket message routing?",
    "o": [
      "Examine message type/destination and forward to handler",
      "Use HTTP routing",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is content-based routing in WebSocket?",
    "o": [
      "Route messages based on message content",
      "Route by URL",
      "Route by IP",
      "Not a pattern"
    ]
  },
  {
    "q": "How do you implement WebSocket message filtering?",
    "o": [
      "Check message against criteria and drop if not matched",
      "Use firewall",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message transformation?",
    "o": [
      "Convert message format between different systems",
      "Compress messages",
      "Encrypt messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message transformation?",
    "o": [
      "Parse incoming format and serialize to outgoing format",
      "Not possible",
      "Automatic feature",
      "Use proxy"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message enrichment?",
    "o": [
      "Add additional data to messages",
      "Compress messages",
      "Validate messages",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement message enrichment?",
    "o": [
      "Fetch additional data and merge with message",
      "Not possible",
      "Automatic feature",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message aggregation?",
    "o": [
      "Combine multiple messages into summary",
      "Compress messages",
      "Route messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message aggregation?",
    "o": [
      "Collect messages over time window and compute aggregate",
      "Not possible",
      "Automatic feature",
      "Use database"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message splitting?",
    "o": [
      "Break large message into smaller parts",
      "Duplicate messages",
      "Route messages",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement message splitting?",
    "o": [
      "Divide message and send parts with sequence info",
      "Use fragmentation only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message correlation?",
    "o": [
      "Link related messages together",
      "Compress messages",
      "Validate messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message correlation?",
    "o": [
      "Use correlation ID shared across related messages",
      "Not possible",
      "Automatic feature",
      "Use timestamps"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message sequencing?",
    "o": [
      "Ensure messages are processed in correct order",
      "Compress messages",
      "Route messages",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement message sequencing?",
    "o": [
      "Add sequence number and reorder if needed",
      "TCP handles it",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message expiration?",
    "o": [
      "Discard old messages that are no longer relevant",
      "Compress messages",
      "Route messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message expiration?",
    "o": [
      "Add timestamp and check age before processing",
      "Not possible",
      "Automatic feature",
      "Use database"
    ]
  },
  {
    "q": "What is the purpose of WebSocket dead letter queue?",
    "o": [
      "Store messages that failed processing for analysis",
      "Delete messages",
      "Route messages",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement dead letter queue for WebSocket?",
    "o": [
      "Send failed messages to separate storage",
      "Not possible",
      "Automatic feature",
      "Delete failed messages"
    ]
  },
  {
    "q": "How do you implement WebSocket connection pooling on the server?",
    "o": [
      "Reuse worker threads or event loop for multiple connections",
      "Create new thread per connection",
      "Not applicable",
      "Use database pooling"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection metadata tracking?",
    "o": [
      "Monitor connection state, user info, and statistics",
      "Improve performance",
      "Security feature",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement WebSocket metrics collection?",
    "o": [
      "Track connection count, message rate, latency, errors",
      "Use HTTP metrics",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What metrics are important for WebSocket monitoring?",
    "o": [
      "Active connections, message throughput, error rate, latency",
      "CPU only",
      "Memory only",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement WebSocket distributed tracing?",
    "o": [
      "Propagate trace context in messages and log spans",
      "Use HTTP tracing",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is OpenTelemetry in context of WebSocket?",
    "o": [
      "Observability framework for tracing and metrics",
      "Security protocol",
      "Message format",
      "Not related"
    ]
  },
  {
    "q": "How do you implement WebSocket request tracing across services?",
    "o": [
      "Add trace ID to messages and propagate through system",
      "Use HTTP headers only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket correlation context?",
    "o": [
      "Pass contextual information across async operations",
      "Correlate users",
      "Match messages",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement WebSocket circuit breaker pattern?",
    "o": [
      "Detect failures and stop sending to failing service",
      "Break connections",
      "Not applicable",
      "Use HTTP circuit breaker"
    ]
  },
  {
    "q": "What is the purpose of circuit breaker in WebSocket?",
    "o": [
      "Prevent cascading failures in distributed systems",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement WebSocket bulkhead pattern?",
    "o": [
      "Isolate resources to prevent total system failure",
      "Separate connections",
      "Not applicable",
      "Use HTTP bulkhead"
    ]
  },
  {
    "q": "What is the bulkhead pattern in WebSocket context?",
    "o": [
      "Partition resources to limit blast radius of failures",
      "Security isolation",
      "Performance optimization",
      "Not a pattern"
    ]
  },
  {
    "q": "How do you implement WebSocket retry with backoff?",
    "o": [
      "Exponentially increase delay between retry attempts",
      "Fixed delay",
      "No delay",
      "Immediate retry"
    ]
  },
  {
    "q": "What is the purpose of WebSocket timeout configuration?",
    "o": [
      "Prevent hanging connections and operations",
      "Improve performance",
      "Security feature",
      "Not needed"
    ]
  },
  {
    "q": "How do you configure WebSocket handshake timeout?",
    "o": [
      "Set maximum time allowed for handshake completion",
      "Use default only",
      "Not configurable",
      "Use HTTP timeout"
    ]
  },
  {
    "q": "What is the purpose of WebSocket idle timeout?",
    "o": [
      "Close connections with no activity for specified time",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement WebSocket message timeout?",
    "o": [
      "Set maximum time to wait for message response",
      "Use default only",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the challenge of implementing timeouts in async WebSocket?",
    "o": [
      "Managing multiple concurrent timeout timers efficiently",
      "No challenges",
      "Too easy",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement WebSocket connection state machine?",
    "o": [
      "Define states and transitions for connection lifecycle",
      "Not needed",
      "Automatic feature",
      "Use HTTP state"
    ]
  },
  {
    "q": "What states should a WebSocket connection state machine have?",
    "o": [
      "Connecting, Open, Closing, Closed, Error",
      "Only Open and Closed",
      "Too many states",
      "Not applicable"
    ]
  },
  {
    "q": "How do you handle WebSocket state transitions?",
    "o": [
      "Validate transitions and execute appropriate actions",
      "Allow any transition",
      "Not needed",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection lifecycle hooks?",
    "o": [
      "Execute custom logic at connection events",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement connection lifecycle hooks?",
    "o": [
      "Register callbacks for connect, disconnect, error events",
      "Not possible",
      "Automatic feature",
      "Use HTTP hooks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket middleware chain?",
    "o": [
      "Process messages through series of handlers",
      "Improve performance",
      "Security feature",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement WebSocket middleware?",
    "o": [
      "Create functions that wrap message handlers",
      "Use HTTP middleware",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket message interceptors?",
    "o": [
      "Modify or inspect messages before processing",
      "Block messages",
      "Route messages",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement message interceptors?",
    "o": [
      "Wrap send/receive methods with interception logic",
      "Not possible",
      "Automatic feature",
      "Use proxy"
    ]
  },
  {
    "q": "What is the purpose of WebSocket error boundaries?",
    "o": [
      "Isolate and handle errors without crashing system",
      "Prevent errors",
      "Log errors only",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement error boundaries in WebSocket?",
    "o": [
      "Wrap handlers in try-catch and handle gracefully",
      "Let errors propagate",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket graceful degradation?",
    "o": [
      "Provide reduced functionality when features unavailable",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement graceful degradation for WebSocket?",
    "o": [
      "Detect feature support and fallback to alternatives",
      "Not possible",
      "Automatic feature",
      "Use HTTP only"
    ]
  },
  {
    "q": "What is progressive enhancement in WebSocket context?",
    "o": [
      "Start with basic features and add advanced if supported",
      "Improve performance",
      "Security feature",
      "Not a concept"
    ]
  },
  {
    "q": "How do you implement feature detection for WebSocket?",
    "o": [
      "Check for WebSocket support and extensions",
      "Assume support",
      "Not needed",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket capability negotiation?",
    "o": [
      "Agree on supported features between client and server",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement capability negotiation?",
    "o": [
      "Exchange capability lists during handshake or first message",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket version negotiation?",
    "o": [
      "Ensure client and server use compatible protocol version",
      "Improve performance",
      "Security feature",
      "Not needed"
    ]
  },
  {
    "q": "How do you handle WebSocket version incompatibility?",
    "o": [
      "Reject connection with supported versions in response",
      "Use any version",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket extension negotiation?",
    "o": [
      "Agree on optional protocol extensions to use",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you negotiate WebSocket extensions?",
    "o": [
      "Use Sec-WebSocket-Extensions header in handshake",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket subprotocol selection?",
    "o": [
      "Choose application protocol to use over WebSocket",
      "Improve performance",
      "Security feature",
      "Not needed"
    ]
  },
  {
    "q": "How do you select WebSocket subprotocol?",
    "o": [
      "Server chooses from client's list in Sec-WebSocket-Protocol",
      "Client chooses",
      "Random selection",
      "Not applicable"
    ]
  },
  {
    "q": "What happens if no subprotocol match is found?",
    "o": [
      "Connection can proceed without subprotocol or be rejected",
      "Connection fails always",
      "Use default",
      "Not applicable"
    ]
  },
  {
    "q": "What is the purpose of WebSocket custom headers?",
    "o": [
      "Pass additional information during handshake",
      "Improve performance",
      "Security feature",
      "Not allowed"
    ]
  },
  {
    "q": "How do you send custom headers in WebSocket handshake?",
    "o": [
      "Not possible in browser, use query params or first message",
      "Use standard HTTP headers",
      "Special WebSocket headers",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the limitation of WebSocket handshake headers in browser?",
    "o": [
      "Cannot set custom headers from JavaScript",
      "No limitations",
      "Can set any header",
      "Not applicable"
    ]
  },
  {
    "q": "How do you pass authentication info in browser WebSocket?",
    "o": [
      "Use URL parameters, cookies, or first message",
      "Use Authorization header",
      "Use custom headers",
      "Not possible"
    ]
  },
  {
    "q": "What is the purpose of WebSocket query parameters?",
    "o": [
      "Pass information when custom headers not available",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you access query parameters in WebSocket server?",
    "o": [
      "Parse URL during handshake request",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the security risk of using query parameters for tokens?",
    "o": [
      "May be logged in server logs and browser history",
      "No risk",
      "Very secure",
      "Not applicable"
    ]
  },
  {
    "q": "How do you mitigate query parameter security risks?",
    "o": [
      "Use short-lived tokens and secure logging",
      "Don't use query params",
      "Not possible",
      "No mitigation needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket cookie handling?",
    "o": [
      "Maintain session state and authentication",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you use cookies with WebSocket?",
    "o": [
      "Cookies sent automatically during handshake",
      "Set manually",
      "Not supported",
      "Use HTTP only"
    ]
  },
  {
    "q": "What is the limitation of cookies with WebSocket?",
    "o": [
      "Cannot set or modify cookies from WebSocket API",
      "No limitations",
      "Full cookie control",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement WebSocket session management?",
    "o": [
      "Use cookies or tokens to identify and track sessions",
      "Not needed",
      "Automatic feature",
      "Use HTTP sessions"
    ]
  },
  {
    "q": "What is the purpose of WebSocket session affinity?",
    "o": [
      "Route user to same server for session duration",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement session affinity for WebSocket?",
    "o": [
      "Use sticky sessions in load balancer",
      "Not needed",
      "Automatic feature",
      "Use cookies only"
    ]
  },
  {
    "q": "What is the challenge of session affinity?",
    "o": [
      "Uneven load distribution and server failures",
      "No challenges",
      "Too easy",
      "Not applicable"
    ]
  },
  {
    "q": "How do you handle server failure with session affinity?",
    "o": [
      "Implement session replication or reconnect to new server",
      "Not possible",
      "Automatic failover",
      "Restart client"
    ]
  },
  {
    "q": "What is the purpose of WebSocket session replication?",
    "o": [
      "Share session state across servers for failover",
      "Improve performance",
      "Security feature",
      "Not needed"
    ]
  },
  {
    "q": "How do you implement session replication?",
    "o": [
      "Use shared storage like Redis or database",
      "Not possible",
      "Automatic feature",
      "Use cookies"
    ]
  },
  {
    "q": "What is the purpose of WebSocket stateless design?",
    "o": [
      "Avoid server-side session state for scalability",
      "Improve performance",
      "Security feature",
      "Not possible"
    ]
  },
  {
    "q": "How do you implement stateless WebSocket?",
    "o": [
      "Include all necessary state in each message",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the trade-off of stateless WebSocket?",
    "o": [
      "Increased message size but better scalability",
      "No trade-offs",
      "Always better",
      "Always worse"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection migration?",
    "o": [
      "Move connection to different server without disconnect",
      "Improve performance",
      "Security feature",
      "Not possible"
    ]
  },
  {
    "q": "How do you implement connection migration?",
    "o": [
      "Transfer state and redirect client to new server",
      "Not possible",
      "Automatic feature",
      "Use load balancer"
    ]
  },
  {
    "q": "What is the challenge of connection migration?",
    "o": [
      "Maintaining state and avoiding message loss",
      "No challenges",
      "Too easy",
      "Not applicable"
    ]
  },
  {
    "q": "What is the purpose of WebSocket connection draining?",
    "o": [
      "Gracefully move connections before server shutdown",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement connection draining?",
    "o": [
      "Stop new connections, notify clients to reconnect elsewhere",
      "Force disconnect",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket blue-green deployment?",
    "o": [
      "Zero-downtime deployment by switching traffic",
      "Improve performance",
      "Security feature",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement blue-green deployment for WebSocket?",
    "o": [
      "Run two environments, drain old after new is ready",
      "Not possible",
      "Automatic feature",
      "Use HTTP only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket canary deployment?",
    "o": [
      "Gradually roll out changes to subset of users",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement canary deployment for WebSocket?",
    "o": [
      "Route percentage of connections to new version",
      "Not possible",
      "Automatic feature",
      "All or nothing"
    ]
  },
  {
    "q": "What is the purpose of WebSocket feature flags?",
    "o": [
      "Enable/disable features without deployment",
      "Improve performance",
      "Security feature",
      "Not useful"
    ]
  },
  {
    "q": "How do you implement feature flags for WebSocket?",
    "o": [
      "Check flag state and conditionally execute code",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket A/B testing?",
    "o": [
      "Compare different implementations with real users",
      "Improve performance",
      "Security feature",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement A/B testing for WebSocket?",
    "o": [
      "Assign users to variants and track metrics",
      "Not possible",
      "Automatic feature",
      "Use HTTP only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket performance profiling?",
    "o": [
      "Identify bottlenecks and optimization opportunities",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you profile WebSocket performance?",
    "o": [
      "Use profiling tools to measure CPU, memory, latency",
      "Not possible",
      "Automatic feature",
      "Use HTTP profiling"
    ]
  },
  {
    "q": "What is the purpose of WebSocket load testing?",
    "o": [
      "Verify system handles expected traffic volume",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you load test WebSocket applications?",
    "o": [
      "Use tools like Artillery, k6, or custom scripts",
      "Not possible",
      "Automatic feature",
      "Use HTTP load testing"
    ]
  },
  {
    "q": "What is the purpose of WebSocket stress testing?",
    "o": [
      "Find breaking point and failure modes",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you stress test WebSocket?",
    "o": [
      "Gradually increase load beyond normal capacity",
      "Not possible",
      "Automatic feature",
      "Use HTTP stress testing"
    ]
  },
  {
    "q": "What is the purpose of WebSocket chaos engineering?",
    "o": [
      "Test system resilience by injecting failures",
      "Break system",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement chaos engineering for WebSocket?",
    "o": [
      "Randomly kill connections, delay messages, etc.",
      "Not possible",
      "Automatic feature",
      "Too dangerous"
    ]
  },
  {
    "q": "What is the purpose of WebSocket synthetic monitoring?",
    "o": [
      "Continuously test availability from external locations",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement synthetic monitoring?",
    "o": [
      "Run automated tests from monitoring service",
      "Not possible",
      "Automatic feature",
      "Use HTTP monitoring"
    ]
  },
  {
    "q": "What is the purpose of WebSocket real user monitoring?",
    "o": [
      "Track actual user experience and performance",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement real user monitoring for WebSocket?",
    "o": [
      "Collect metrics from client and send to analytics",
      "Not possible",
      "Automatic feature",
      "Use HTTP RUM"
    ]
  },
  {
    "q": "What is the purpose of WebSocket error tracking?",
    "o": [
      "Collect and analyze errors for debugging",
      "Prevent errors",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement error tracking for WebSocket?",
    "o": [
      "Send errors to service like Sentry or Rollbar",
      "Not possible",
      "Automatic feature",
      "Use HTTP error tracking"
    ]
  },
  {
    "q": "What is the purpose of WebSocket alerting?",
    "o": [
      "Notify team of issues requiring attention",
      "Prevent issues",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement alerting for WebSocket?",
    "o": [
      "Set thresholds and send notifications when exceeded",
      "Not possible",
      "Automatic feature",
      "Use HTTP alerting"
    ]
  },
  {
    "q": "What is the purpose of WebSocket dashboards?",
    "o": [
      "Visualize metrics and system health",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you create WebSocket dashboards?",
    "o": [
      "Use tools like Grafana with metrics from Prometheus",
      "Not possible",
      "Automatic feature",
      "Use HTTP dashboards"
    ]
  },
  {
    "q": "What is the purpose of WebSocket log aggregation?",
    "o": [
      "Centralize logs from distributed system",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement log aggregation for WebSocket?",
    "o": [
      "Send logs to service like ELK or Splunk",
      "Not possible",
      "Automatic feature",
      "Use HTTP logging"
    ]
  },
  {
    "q": "What is the purpose of WebSocket structured logging?",
    "o": [
      "Make logs machine-readable for analysis",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement structured logging?",
    "o": [
      "Log as JSON with consistent fields",
      "Use plain text",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket log levels?",
    "o": [
      "Control verbosity and filter logs",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use log levels effectively?",
    "o": [
      "Use DEBUG for development, INFO for production, ERROR for issues",
      "Use DEBUG always",
      "Use ERROR only",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket request ID?",
    "o": [
      "Track request through distributed system",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement request ID for WebSocket?",
    "o": [
      "Generate unique ID and include in logs and messages",
      "Not possible",
      "Automatic feature",
      "Use HTTP request ID"
    ]
  },
  {
    "q": "What is the purpose of WebSocket distributed context?",
    "o": [
      "Pass contextual information across service boundaries",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you propagate context in WebSocket?",
    "o": [
      "Include context in message headers or metadata",
      "Not possible",
      "Automatic feature",
      "Use HTTP context"
    ]
  },
  {
    "q": "What is the purpose of WebSocket service mesh?",
    "o": [
      "Manage service-to-service communication",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How does service mesh work with WebSocket?",
    "o": [
      "Proxy handles routing, security, observability",
      "Not compatible",
      "Automatic feature",
      "Use HTTP only"
    ]
  },
  {
    "q": "What is Istio in context of WebSocket?",
    "o": [
      "Service mesh that can proxy WebSocket connections",
      "WebSocket server",
      "Message broker",
      "Not related"
    ]
  },
  {
    "q": "What is the purpose of WebSocket sidecar proxy?",
    "o": [
      "Handle cross-cutting concerns like security, monitoring",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement sidecar proxy for WebSocket?",
    "o": [
      "Deploy proxy container alongside application",
      "Not possible",
      "Automatic feature",
      "Use HTTP proxy"
    ]
  },
  {
    "q": "What is the purpose of WebSocket API gateway?",
    "o": [
      "Centralize routing, auth, rate limiting for WebSocket",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement WebSocket API gateway?",
    "o": [
      "Use gateway that supports WebSocket like Kong or AWS API Gateway",
      "Not possible",
      "Automatic feature",
      "Use HTTP gateway"
    ]
  },
  {
    "q": "What is the challenge of WebSocket with API gateway?",
    "o": [
      "Maintaining long-lived connections through gateway",
      "No challenges",
      "Too easy",
      "Not applicable"
    ]
  },
  {
    "q": "How do you implement WebSocket connection multiplexing at protocol level?",
    "o": [
      "Extend protocol with stream IDs and frame routing",
      "Use HTTP/2",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket frame masking key rotation?",
    "o": [
      "Each frame uses different random masking key",
      "Improve performance",
      "Not needed",
      "Security enhancement"
    ]
  },
  {
    "q": "How do you implement custom WebSocket frame types?",
    "o": [
      "Define new opcodes and handle in custom implementation",
      "Not allowed",
      "Automatic feature",
      "Use subprotocols"
    ]
  },
  {
    "q": "What is the purpose of WebSocket frame interleaving?",
    "o": [
      "Mix frames from different messages for multiplexing",
      "Improve performance",
      "Not useful",
      "Not allowed"
    ]
  },
  {
    "q": "How do you handle WebSocket frame interleaving?",
    "o": [
      "Track message state per stream and reassemble",
      "Not possible",
      "Automatic feature",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket priority scheduling?",
    "o": [
      "Send high-priority messages before low-priority",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement priority scheduling?",
    "o": [
      "Use priority queues and weighted fair queuing",
      "Not possible",
      "Automatic feature",
      "Use timestamps"
    ]
  },
  {
    "q": "What is weighted fair queuing in WebSocket?",
    "o": [
      "Allocate bandwidth proportionally to priority weights",
      "Equal distribution",
      "Not applicable",
      "Security feature"
    ]
  },
  {
    "q": "How do you implement WebSocket congestion control?",
    "o": [
      "Monitor network conditions and adjust send rate",
      "Not needed",
      "Automatic feature",
      "Use TCP only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket adaptive bitrate?",
    "o": [
      "Adjust quality based on network conditions",
      "Fixed bitrate",
      "Not applicable",
      "Security feature"
    ]
  },
  {
    "q": "How do you implement adaptive bitrate for WebSocket?",
    "o": [
      "Monitor latency and packet loss, adjust encoding",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket forward error correction?",
    "o": [
      "Recover from packet loss without retransmission",
      "Prevent errors",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement forward error correction?",
    "o": [
      "Send redundant data using erasure codes",
      "Not possible",
      "Automatic feature",
      "Use TCP only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket packet pacing?",
    "o": [
      "Control sending rate to avoid congestion",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement packet pacing?",
    "o": [
      "Add delays between sends based on rate limit",
      "Send as fast as possible",
      "Not possible",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket bandwidth estimation?",
    "o": [
      "Determine available bandwidth for rate control",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you estimate bandwidth for WebSocket?",
    "o": [
      "Measure throughput and adjust based on feedback",
      "Not possible",
      "Automatic feature",
      "Use fixed value"
    ]
  },
  {
    "q": "What is the purpose of WebSocket latency measurement?",
    "o": [
      "Monitor round-trip time for performance tuning",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you measure WebSocket latency?",
    "o": [
      "Send timestamped ping and calculate RTT from pong",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket jitter measurement?",
    "o": [
      "Detect variation in latency for quality assessment",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you calculate jitter for WebSocket?",
    "o": [
      "Measure variance in packet arrival times",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket packet loss detection?",
    "o": [
      "Identify network issues affecting reliability",
      "Prevent loss",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you detect packet loss in WebSocket?",
    "o": [
      "Use sequence numbers and detect gaps",
      "Not possible",
      "TCP handles it",
      "Automatic feature"
    ]
  },
  {
    "q": "What is the purpose of WebSocket quality of service?",
    "o": [
      "Guarantee performance characteristics for traffic",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement QoS for WebSocket?",
    "o": [
      "Use traffic shaping and priority queues",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket traffic shaping?",
    "o": [
      "Control bandwidth usage and burst patterns",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement traffic shaping?",
    "o": [
      "Use token bucket or leaky bucket algorithm",
      "Not possible",
      "Automatic feature",
      "Use firewall"
    ]
  },
  {
    "q": "What is token bucket algorithm for WebSocket?",
    "o": [
      "Allow bursts while maintaining average rate",
      "Security feature",
      "Not applicable",
      "Message format"
    ]
  },
  {
    "q": "What is leaky bucket algorithm for WebSocket?",
    "o": [
      "Smooth traffic by enforcing constant rate",
      "Security feature",
      "Not applicable",
      "Message format"
    ]
  },
  {
    "q": "How do you implement WebSocket resource quotas?",
    "o": [
      "Limit resources per user or connection",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket admission control?",
    "o": [
      "Reject new connections when at capacity",
      "Accept all connections",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement admission control?",
    "o": [
      "Check resource availability before accepting connection",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket backpressure propagation?",
    "o": [
      "Signal upstream to slow down when overwhelmed",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement backpressure propagation?",
    "o": [
      "Send flow control messages to upstream services",
      "Not possible",
      "Automatic feature",
      "Use TCP only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket reactive streams?",
    "o": [
      "Handle asynchronous data streams with backpressure",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement reactive streams for WebSocket?",
    "o": [
      "Use libraries like RxJS or Reactor",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket stream processing?",
    "o": [
      "Process continuous data streams in real-time",
      "Batch processing",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement stream processing?",
    "o": [
      "Use frameworks like Kafka Streams or Flink",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket event sourcing?",
    "o": [
      "Store state changes as sequence of events",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement event sourcing with WebSocket?",
    "o": [
      "Persist events and replay to rebuild state",
      "Not possible",
      "Automatic feature",
      "Use database only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket CQRS pattern?",
    "o": [
      "Separate read and write models for scalability",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement CQRS with WebSocket?",
    "o": [
      "Use separate connections or channels for commands and queries",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket saga pattern?",
    "o": [
      "Coordinate distributed transactions across services",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement saga pattern with WebSocket?",
    "o": [
      "Orchestrate compensating transactions via messages",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket eventual consistency?",
    "o": [
      "Accept temporary inconsistency for availability",
      "Immediate consistency",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you achieve eventual consistency with WebSocket?",
    "o": [
      "Propagate updates asynchronously and resolve conflicts",
      "Not possible",
      "Automatic feature",
      "Use locks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket conflict resolution?",
    "o": [
      "Resolve concurrent updates to same data",
      "Prevent conflicts",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement conflict resolution?",
    "o": [
      "Use last-write-wins, CRDTs, or custom logic",
      "Not possible",
      "Automatic feature",
      "Use locks only"
    ]
  },
  {
    "q": "What is CRDT in context of WebSocket?",
    "o": [
      "Conflict-free Replicated Data Type for eventual consistency",
      "Security feature",
      "Message format",
      "Not related"
    ]
  },
  {
    "q": "How do you use CRDTs with WebSocket?",
    "o": [
      "Sync CRDT operations via WebSocket messages",
      "Not possible",
      "Automatic feature",
      "Use HTTP"
    ]
  },
  {
    "q": "What is the purpose of WebSocket operational transformation?",
    "o": [
      "Enable concurrent editing with conflict resolution",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement operational transformation?",
    "o": [
      "Transform operations based on concurrent changes",
      "Not possible",
      "Automatic feature",
      "Use locks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket differential synchronization?",
    "o": [
      "Sync state by exchanging diffs instead of full state",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement differential synchronization?",
    "o": [
      "Compute and send state diffs, apply patches",
      "Not possible",
      "Automatic feature",
      "Send full state"
    ]
  },
  {
    "q": "What is the purpose of WebSocket snapshot and delta?",
    "o": [
      "Send full snapshot periodically, deltas in between",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement snapshot and delta pattern?",
    "o": [
      "Send full state at intervals, incremental updates otherwise",
      "Not possible",
      "Automatic feature",
      "Send full state always"
    ]
  },
  {
    "q": "What is the purpose of WebSocket state reconciliation?",
    "o": [
      "Ensure client and server state match",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement state reconciliation?",
    "o": [
      "Periodically compare checksums and resync if different",
      "Not possible",
      "Automatic feature",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket optimistic updates?",
    "o": [
      "Update UI immediately, rollback if server rejects",
      "Pessimistic updates",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement optimistic updates?",
    "o": [
      "Apply change locally, send to server, revert on error",
      "Not possible",
      "Automatic feature",
      "Wait for server"
    ]
  },
  {
    "q": "What is the purpose of WebSocket pessimistic locking?",
    "o": [
      "Lock resource before modification to prevent conflicts",
      "Optimistic locking",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement pessimistic locking with WebSocket?",
    "o": [
      "Send lock request, wait for grant, then modify",
      "Not possible",
      "Automatic feature",
      "Use database locks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket optimistic locking?",
    "o": [
      "Detect conflicts at commit time using version numbers",
      "Pessimistic locking",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement optimistic locking?",
    "o": [
      "Include version in update, reject if version changed",
      "Not possible",
      "Automatic feature",
      "Use database locks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket distributed locks?",
    "o": [
      "Coordinate access to shared resources across servers",
      "Local locks",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement distributed locks with WebSocket?",
    "o": [
      "Use Redis or ZooKeeper for lock coordination",
      "Not possible",
      "Automatic feature",
      "Use local locks"
    ]
  },
  {
    "q": "What is the purpose of WebSocket leader election?",
    "o": [
      "Choose single node to coordinate distributed system",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement leader election?",
    "o": [
      "Use consensus algorithm like Raft or Paxos",
      "Not possible",
      "Automatic feature",
      "Random selection"
    ]
  },
  {
    "q": "What is the purpose of WebSocket consensus protocol?",
    "o": [
      "Agree on state across distributed nodes",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement consensus with WebSocket?",
    "o": [
      "Use Raft, Paxos, or similar algorithm",
      "Not possible",
      "Automatic feature",
      "Majority vote"
    ]
  },
  {
    "q": "What is the purpose of WebSocket quorum?",
    "o": [
      "Require majority agreement for operations",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement quorum-based operations?",
    "o": [
      "Wait for responses from majority of nodes",
      "Not possible",
      "Automatic feature",
      "Use single node"
    ]
  },
  {
    "q": "What is the purpose of WebSocket vector clocks?",
    "o": [
      "Track causality in distributed system",
      "Time synchronization",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use vector clocks with WebSocket?",
    "o": [
      "Include vector clock in messages, update on send/receive",
      "Not possible",
      "Automatic feature",
      "Use system time"
    ]
  },
  {
    "q": "What is the purpose of WebSocket Lamport timestamps?",
    "o": [
      "Order events in distributed system",
      "Time synchronization",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use Lamport timestamps?",
    "o": [
      "Increment counter on events, include in messages",
      "Not possible",
      "Automatic feature",
      "Use system time"
    ]
  },
  {
    "q": "What is the purpose of WebSocket hybrid logical clocks?",
    "o": [
      "Combine physical and logical time for ordering",
      "Time synchronization",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement hybrid logical clocks?",
    "o": [
      "Track physical time and logical counter",
      "Not possible",
      "Automatic feature",
      "Use system time"
    ]
  },
  {
    "q": "What is the purpose of WebSocket time synchronization?",
    "o": [
      "Align clocks across distributed system",
      "Not needed",
      "Automatic feature",
      "Use NTP only"
    ]
  },
  {
    "q": "How do you synchronize time for WebSocket?",
    "o": [
      "Use NTP and account for clock drift",
      "Not possible",
      "Automatic feature",
      "Assume synchronized"
    ]
  },
  {
    "q": "What is the purpose of WebSocket clock skew detection?",
    "o": [
      "Identify when clocks are out of sync",
      "Not needed",
      "Automatic feature",
      "Prevent skew"
    ]
  },
  {
    "q": "How do you detect clock skew?",
    "o": [
      "Compare timestamps and flag large differences",
      "Not possible",
      "Automatic feature",
      "Assume no skew"
    ]
  },
  {
    "q": "What is the purpose of WebSocket Byzantine fault tolerance?",
    "o": [
      "Tolerate malicious or faulty nodes",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement Byzantine fault tolerance?",
    "o": [
      "Use BFT consensus algorithms like PBFT",
      "Not possible",
      "Automatic feature",
      "Trust all nodes"
    ]
  },
  {
    "q": "What is the purpose of WebSocket gossip protocol?",
    "o": [
      "Propagate information through peer-to-peer communication",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement gossip protocol with WebSocket?",
    "o": [
      "Randomly select peers and exchange state",
      "Not possible",
      "Automatic feature",
      "Broadcast to all"
    ]
  },
  {
    "q": "What is the purpose of WebSocket anti-entropy?",
    "o": [
      "Detect and repair inconsistencies",
      "Prevent entropy",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement anti-entropy?",
    "o": [
      "Periodically compare and sync state with peers",
      "Not possible",
      "Automatic feature",
      "Not needed"
    ]
  },
  {
    "q": "What is the purpose of WebSocket merkle trees?",
    "o": [
      "Efficiently detect differences in large datasets",
      "Improve performance",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use merkle trees with WebSocket?",
    "o": [
      "Exchange tree hashes to find differing subtrees",
      "Not possible",
      "Automatic feature",
      "Use full comparison"
    ]
  },
  {
    "q": "What is the purpose of WebSocket bloom filters?",
    "o": [
      "Probabilistically test set membership efficiently",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use bloom filters with WebSocket?",
    "o": [
      "Send bloom filter to check for common elements",
      "Not possible",
      "Automatic feature",
      "Use full set"
    ]
  },
  {
    "q": "What is the purpose of WebSocket consistent hashing?",
    "o": [
      "Distribute data evenly across nodes",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement consistent hashing?",
    "o": [
      "Hash keys to ring and assign to nearest node",
      "Not possible",
      "Automatic feature",
      "Use modulo"
    ]
  },
  {
    "q": "What is the purpose of WebSocket rendezvous hashing?",
    "o": [
      "Minimize redistribution when nodes change",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement rendezvous hashing?",
    "o": [
      "Hash key with each node, choose highest score",
      "Not possible",
      "Automatic feature",
      "Use consistent hashing"
    ]
  },
  {
    "q": "What is the purpose of WebSocket virtual nodes?",
    "o": [
      "Improve load distribution in consistent hashing",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you use virtual nodes?",
    "o": [
      "Map each physical node to multiple ring positions",
      "Not possible",
      "Automatic feature",
      "Use single position"
    ]
  },
  {
    "q": "What is the purpose of WebSocket shard rebalancing?",
    "o": [
      "Redistribute data when nodes added or removed",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement shard rebalancing?",
    "o": [
      "Move data to new nodes while maintaining availability",
      "Not possible",
      "Automatic feature",
      "Restart system"
    ]
  },
  {
    "q": "What is the purpose of WebSocket data partitioning?",
    "o": [
      "Divide data across multiple nodes for scalability",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you partition data for WebSocket?",
    "o": [
      "Use consistent hashing or range-based partitioning",
      "Not possible",
      "Automatic feature",
      "Single node"
    ]
  },
  {
    "q": "What is the purpose of WebSocket range partitioning?",
    "o": [
      "Assign contiguous key ranges to nodes",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement range partitioning?",
    "o": [
      "Define key ranges and route to appropriate node",
      "Not possible",
      "Automatic feature",
      "Use hash partitioning"
    ]
  },
  {
    "q": "What is the purpose of WebSocket hash partitioning?",
    "o": [
      "Distribute data evenly using hash function",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement hash partitioning?",
    "o": [
      "Hash key and use modulo or consistent hashing",
      "Not possible",
      "Automatic feature",
      "Use range partitioning"
    ]
  },
  {
    "q": "What is the purpose of WebSocket composite partitioning?",
    "o": [
      "Combine multiple partitioning strategies",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement composite partitioning?",
    "o": [
      "Apply multiple partition functions in sequence",
      "Not possible",
      "Automatic feature",
      "Use single strategy"
    ]
  },
  {
    "q": "What is the purpose of WebSocket secondary indexes?",
    "o": [
      "Enable efficient queries on non-partition keys",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement secondary indexes in distributed WebSocket?",
    "o": [
      "Maintain global or local indexes across partitions",
      "Not possible",
      "Automatic feature",
      "Use primary key only"
    ]
  },
  {
    "q": "What is the purpose of WebSocket global secondary index?",
    "o": [
      "Index all partitions for complete query results",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you maintain global secondary index?",
    "o": [
      "Update index on all nodes when data changes",
      "Not possible",
      "Automatic feature",
      "Use local index"
    ]
  },
  {
    "q": "What is the purpose of WebSocket local secondary index?",
    "o": [
      "Index within partition for faster local queries",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you query with local secondary index?",
    "o": [
      "Query all partitions and merge results",
      "Not possible",
      "Automatic feature",
      "Use global index"
    ]
  },
  {
    "q": "What is the purpose of WebSocket materialized views?",
    "o": [
      "Precompute and store query results",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you maintain materialized views with WebSocket?",
    "o": [
      "Update views when underlying data changes",
      "Not possible",
      "Automatic feature",
      "Compute on demand"
    ]
  },
  {
    "q": "What is the purpose of WebSocket change data capture?",
    "o": [
      "Track and propagate data changes",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement change data capture?",
    "o": [
      "Monitor database logs and stream changes via WebSocket",
      "Not possible",
      "Automatic feature",
      "Poll for changes"
    ]
  },
  {
    "q": "What is the purpose of WebSocket event streaming?",
    "o": [
      "Continuously deliver events to consumers",
      "Batch delivery",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement event streaming with WebSocket?",
    "o": [
      "Push events to WebSocket as they occur",
      "Not possible",
      "Automatic feature",
      "Use HTTP polling"
    ]
  },
  {
    "q": "What is the purpose of WebSocket stream joins?",
    "o": [
      "Combine multiple event streams",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement stream joins?",
    "o": [
      "Buffer events and match based on join criteria",
      "Not possible",
      "Automatic feature",
      "Use database joins"
    ]
  },
  {
    "q": "What is the purpose of WebSocket windowing?",
    "o": [
      "Group events into time or count-based windows",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement windowing for WebSocket streams?",
    "o": [
      "Define window boundaries and aggregate within windows",
      "Not possible",
      "Automatic feature",
      "Process all events"
    ]
  },
  {
    "q": "What is the purpose of WebSocket tumbling windows?",
    "o": [
      "Non-overlapping fixed-size time windows",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement tumbling windows?",
    "o": [
      "Group events by time intervals with no overlap",
      "Not possible",
      "Automatic feature",
      "Use sliding windows"
    ]
  },
  {
    "q": "What is the purpose of WebSocket sliding windows?",
    "o": [
      "Overlapping windows that slide over time",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement sliding windows?",
    "o": [
      "Maintain buffer and compute for each window position",
      "Not possible",
      "Automatic feature",
      "Use tumbling windows"
    ]
  },
  {
    "q": "What is the purpose of WebSocket session windows?",
    "o": [
      "Group events by periods of activity",
      "Improve security",
      "Not useful",
      "Automatic feature"
    ]
  },
  {
    "q": "How do you implement session windows?",
    "o": [
      "Close window after inactivity timeout",
      "Not possible",
      "Automatic feature",
      "Use fixed windows"
    ]
  }
]
