[
    {
        "q": "What is a 'Web Session'?",
        "type": "mcq",
        "o": [
            "A semi-permanent interactive information interchange (connection) between a Client and Server",
            "A database connection",
            "A wifi connection",
            "A file download"
        ]
    },
    {
        "q": "Why is HTTP considered 'stateless'?",
        "type": "mcq",
        "o": [
            "Each request is independent; Server doesn't remember previous requests by default",
            "It has no headers",
            "It has no body",
            "It is slow"
        ]
    },
    {
        "q": "What is a 'Session ID'?",
        "type": "mcq",
        "o": [
            "A unique token passed between Client and Server to identify the stateful session",
            "Login name",
            "Password",
            "User ID"
        ]
    },
    {
        "q": "Minimum entropy for a secure Session ID?",
        "type": "mcq",
        "o": [
            "128 bits (to prevent brute-force guessing)",
            "8 bits",
            "32 bits",
            "64 bits"
        ]
    },
    {
        "q": "What is 'Session Fixation'?",
        "type": "mcq",
        "o": [
            "Attacker sets a user's session ID to one known by the attacker (e.g. via URL link), user logs in, attacker uses same ID",
            "Fixing bugs",
            "Locking session",
            "Deleting session"
        ]
    },
    {
        "q": "Defense against Session Fixation?",
        "type": "mcq",
        "o": [
            "Regenerate Session ID immediately upon successful login (User gets new clean ID)",
            "Use short ID",
            "Use long ID",
            "Use static ID"
        ]
    },
    {
        "q": "What is 'Session Hijacking'?",
        "type": "mcq",
        "o": [
            "Stealing a valid Session ID (cookie) to impersonate the user (e.g. via XSS or Packet Sniffing)",
            "Server hijacking",
            "DNS hijacking",
            "IP hijacking"
        ]
    },
    {
        "q": "What is 'HttpOnly' flag?",
        "type": "mcq",
        "o": [
            "Cookie flag preventing client-side scripts (JS) from accessing the cookie (Mitigates XSS theft)",
            "HTTP only allowed",
            "HTTPS only allowed",
            "HTML only allowed"
        ]
    },
    {
        "q": "What is 'Secure' flag?",
        "type": "mcq",
        "o": [
            "Cookie flag ensuring it is ONLY sent over encrypted (HTTPS) connections (Migitates network sniffing)",
            "Password protected",
            "Admin only",
            "Server only"
        ]
    },
    {
        "q": "What is 'SameSite=Strict'?",
        "type": "mcq",
        "o": [
            "Cookie NOT sent on cross-site requests, even top-level navigations (e.g. clicking link from email)",
            "Blocks all sites",
            "Blocks all cookies",
            "Blocks all users"
        ]
    },
    {
        "q": "What is 'SameSite=Lax'?",
        "type": "mcq",
        "o": [
            "Cookie sent on top-level navigations (Safe methods like GET) but not on sub-requests (images/frames)",
            "Lax security",
            "No security",
            "Full access"
        ]
    },
    {
        "q": "Default 'SameSite' value in modern browsers?",
        "type": "mcq",
        "o": [
            "Lax",
            "Strict",
            "None",
            "Open"
        ]
    },
    {
        "q": "Requirement for 'SameSite=None'?",
        "type": "mcq",
        "o": [
            "Must also set 'Secure' flag (HTTPS required)",
            "No requirement",
            "HttpOnly required",
            "Domain required"
        ]
    },
    {
        "q": "What is 'Domain' attribute in Cookie?",
        "type": "mcq",
        "o": [
            "Specifies which hosts can receive the cookie (default is host-only, setting it allows subdomains)",
            "Web domain",
            "Admin domain",
            "User domain"
        ]
    },
    {
        "q": "What is 'Path' attribute in Cookie?",
        "type": "mcq",
        "o": [
            "Restricts cookie to specific URL path prefix (Weak isolation, not a security boundary)",
            "File path",
            "Disk path",
            "Server path"
        ]
    },
    {
        "q": "What is 'Session Cookie' vs 'Persistent Cookie'?",
        "type": "mcq",
        "o": [
            "Session = No expiry (deleted on browser close). Persistent = Has 'Expires'/'Max-Age' (survives restart).",
            "Session is faster",
            "Persistent is slower",
            "They are same"
        ]
    },
    {
        "q": "What is 'Absolute Session Timeout'?",
        "type": "mcq",
        "o": [
            "Hard limit on session duration (e.g. 24 hours) regardless of activity. Forces re-login.",
            "Short timeout",
            "Long timeout",
            "No timeout"
        ]
    },
    {
        "q": "What is 'Idle Session Timeout'?",
        "type": "mcq",
        "o": [
            "Timeout triggered after period of inactivity (e.g. 30 mins). Resets on user action.",
            "Lazy timeout",
            "Server timeout",
            "Browser timeout"
        ]
    },
    {
        "q": "What is 'Sliding Window' expiration?",
        "type": "mcq",
        "o": [
            "Extending session lifetime by N minutes on each valid request (Implementing Idle Timeout)",
            "Moving window",
            "Closing window",
            "Opening window"
        ]
    },
    {
        "q": "Best practice for Timeout?",
        "type": "mcq",
        "o": [
            "Implement BOTH Absolute (max-life) and Idle (inactivity) timeouts.",
            "Only Idle",
            "Only Absolute",
            "None"
        ]
    },
    {
        "q": "What is 'Concurrent Session Control'?",
        "type": "mcq",
        "o": [
            "Limiting how many active sessions a user can have (e.g. Netflix 'too many screens')",
            "Parallel sessions",
            "Fast sessions",
            "Slow sessions"
        ]
    },
    {
        "q": "Server-side Session Storage?",
        "type": "mcq",
        "o": [
            "Session data stored on server (Redis/DB); Cookie only contains ID reference (Opaque)",
            "Slow",
            "Unsafe",
            "Data in cookie"
        ]
    },
    {
        "q": "Client-side Session Storage (Stateless)?",
        "type": "mcq",
        "o": [
            "Session data serialized, encrypted/signed, and stored IN the cookie itself (no server state)",
            "Server database",
            "Server file",
            "Server memory"
        ]
    },
    {
        "q": "Risk of Client-side Session (Cookie Store)?",
        "type": "mcq",
        "o": [
            "Replay attacks (if not checking version), Size limit (4KB), Stale data, Hard revocation",
            "Too fast",
            "Too small",
            "Too easy"
        ]
    },
    {
        "q": "What is 'Signed Cookie'?",
        "type": "mcq",
        "o": [
            "Cookie containing a hash/HMAC of the content to prevent tampering by user",
            "Encrypted",
            "Hidden",
            "Compressed"
        ]
    },
    {
        "q": "What is 'Sticky Session'?",
        "type": "mcq",
        "o": [
            "Load Balancer routing all requests from one user to the SAME server node (so local RAM session works)",
            "Glue session",
            "Slow session",
            "Bad session"
        ]
    },
    {
        "q": "Downside of Sticky Sessions?",
        "type": "mcq",
        "o": [
            "Uneven load distribution, Session loss if node crashes (unless replicated)",
            "Too fast",
            "Too cheap",
            "Too simple"
        ]
    },
    {
        "q": "What is 'Clustered Session'?",
        "type": "mcq",
        "o": [
            "Session data replicated across server nodes or stored in central store (Redis) - Nodes are stateless-ish",
            "Group session",
            "Batch session",
            "Local session"
        ]
    },
    {
        "q": "What is CSRF?",
        "type": "mcq",
        "o": [
            "Cross-Site Request Forgery: Attacker forces user browser to send request to Service (using auth cookie) without user intent",
            "XSS",
            "SQL Injection",
            "Phishing"
        ]
    },
    {
        "q": "Why does CSRF work?",
        "type": "mcq",
        "o": [
            "Browsers automatically include cookies (even session cookies) in cross-site requests (unless SameSite prevents it)",
            "Cookies are bad",
            "Browsers are broken",
            "Servers are broken"
        ]
    },
    {
        "q": "What is 'Synchronizer Token Pattern'?",
        "type": "mcq",
        "o": [
            "Server sends random CSRF token in HTML form/Head; Client must submit it back; Cookie alone is not enough.",
            "Sync time",
            "Sync data",
            "Sync users"
        ]
    },
    {
        "q": "What is 'Double Submit Cookie'?",
        "type": "mcq",
        "o": [
            "Sending a random value in both a Cookie and a Request Parameter/Header. Server checks they match.",
            "Two cookies",
            "Two headers",
            "Two params"
        ]
    },
    {
        "q": "Why Double Submit Cookie works?",
        "type": "mcq",
        "o": [
            "Attacker can force sending the cookie, but cannot *read* it to copy value into the Header/Param (Same Origin Policy)",
            "It doesn't work",
            "Magic",
            "Encryption"
        ]
    },
    {
        "q": "Checking 'Origin'/'Referer' headers?",
        "type": "mcq",
        "o": [
            "Defense in Depth: Reject requests coming from unauthorized origins. (But Referer can be spoofed/omitted)",
            "Only defense",
            "Best defense",
            "Useless"
        ]
    },
    {
        "q": "What is 'Sudo Mode' / 'Re-authentication'?",
        "type": "mcq",
        "o": [
            "Asking for password again before sensitive actions (e.g. changing password) even if session is valid",
            "Admin mode",
            "Root mode",
            "User mode"
        ]
    },
    {
        "q": "What is 'Remember Me'?",
        "type": "mcq",
        "o": [
            "Long-lived persistent cookie (often a separate token) used to re-create session after browser restart",
            "Memory aid",
            "Note app",
            "Alarm"
        ]
    },
    {
        "q": "Secure 'Remember Me' implementation?",
        "type": "mcq",
        "o": [
            "Use a random, sufficiently long Token (hashed in DB). Rotate it on use. Don't store plain password.",
            "Store password",
            "Store username",
            "Store ID"
        ]
    },
    {
        "q": "What is 'Zombie Cookie'?",
        "type": "mcq",
        "o": [
            "Cookie that recreates itself after deletion (using LocalStorage, Flash, ETag, etc. to persist id)",
            "Dead cookie",
            "Scary cookie",
            "Halloween cookie"
        ]
    },
    {
        "q": "Binding Session to IP?",
        "type": "mcq",
        "o": [
            "Binding session to User's IP. Risk: Valid users changing IP (Mobile/Wifi switch) get logged out.",
            "Good for all",
            "Perfect security",
            "Standard"
        ]
    },
    {
        "q": "Binding Session to User-Agent?",
        "type": "mcq",
        "o": [
            "Binding to Browser string. Prevents session theft carrying over to different browser (Simple check)",
            "Binding to OS",
            "Binding to Hardware",
            "Binding to Time"
        ]
    },
    {
        "q": "What is 'Race Condition' in Session Renewal?",
        "type": "mcq",
        "o": [
            "Parallel requests during regeneration can cause one to fail auth if old ID is invalidated too quickly",
            "Car race",
            "Running fast",
            "Server timeout"
        ]
    },
    {
        "q": "What is 'RP-Initiated Logout'?",
        "type": "mcq",
        "o": [
            "Client (RP) asks IdP to log the user out (usually redirects user to IdP logout endpoint)",
            "Server logout",
            "Db logout",
            "Admin logout"
        ]
    },
    {
        "q": "What is 'Backchannel Logout'?",
        "type": "mcq",
        "o": [
            "IdP calls a webhook on the Client (server-to-server) to notify of logout event",
            "Front logout",
            "User logout",
            "Browser logout"
        ]
    },
    {
        "q": "What is 'Frontchannel Logout'?",
        "type": "mcq",
        "o": [
            "IdP loads a hidden iframe pointing to Client's logout URL in the user's browser",
            "Server logout",
            "API logout",
            "Socket logout"
        ]
    },
    {
        "q": "Session Serialization?",
        "type": "mcq",
        "o": [
            "Converting session object (User Profile) to bytes/string for storage (Redis/Cookie)",
            "Encryption",
            "Compression",
            "Hashing"
        ]
    },
    {
        "q": "Why Versioning in Session Data?",
        "type": "mcq",
        "o": [
            "To handle app updates where session structure changes (avoid crashing on deserializing old sessions)",
            "For fun",
            "For speed",
            "For logging"
        ]
    },
    {
        "q": "Garbage Collection of Sessions?",
        "type": "mcq",
        "o": [
            "Process of cleaning up expired session records from the backend store to free space",
            "Cleaning code",
            "Cleaning memory",
            "Cleaning disk"
        ]
    },
    {
        "q": "Least Privilege in Session?",
        "type": "mcq",
        "o": [
            "Store minimal data (User ID, Roles). Don't store massive objects. Fetch fresh data from DB when needed.",
            "Store everything",
            "Store nothing",
            "Store password"
        ]
    },
    {
        "q": "Audit Logging for Sessions?",
        "type": "mcq",
        "o": [
            "Log creation, termination, and failure of sessions (critical for forensics)",
            "Log nothing",
            "Log errors",
            "Log speed"
        ]
    },
    {
        "q": "What is 'Session Data Integrity'?",
        "type": "mcq",
        "o": [
            "Ensuring session data hasn't been tampered with by the client (HMAC signature)",
            "Encryption",
            "Speed",
            "Availability"
        ]
    },
    {
        "q": "What is 'Session Data Confidentiality'?",
        "type": "mcq",
        "o": [
            "Ensuring session data cannot be read by the client/network (Encryption)",
            "Signing",
            "Hashing",
            "Compression"
        ]
    },
    {
        "q": "Browser 'Session Storage' API?",
        "type": "mcq",
        "o": [
            "Client-side storage cleared when tab/window is closed (Not sent to server automatically)",
            "Persistent storage",
            "Database storage",
            "Cookie storage"
        ]
    },
    {
        "q": "Browser 'Local Storage' API?",
        "type": "mcq",
        "o": [
            "Persistent client-side storage (No expiry). Vulnerable to XSS. Not sent to server.",
            "Session storage",
            "Temp storage",
            "Secure storage"
        ]
    },
    {
        "q": "Is Local Storage secure for tokens?",
        "type": "mcq",
        "o": [
            "No, accessible by any JS on the page (XSS -> Token Theft). HttpOnly Cookies are safer.",
            "Yes very",
            "Yes always",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Session PInning'?",
        "type": "mcq",
        "o": [
            "Binding a session to a specific client certificate (Mutual TLS) - Very strong",
            "Pinning to IP",
            "Pinning to time",
            "Pinning to user"
        ]
    },
    {
        "q": "What is 'Ghost Session'?",
        "type": "mcq",
        "o": [
            "A session that exists on Server but Client has deleted cookie (orphaned data)",
            "Scary session",
            "Hidden session",
            "Fake session"
        ]
    },
    {
        "q": "Effect of 'Clearing Cookies'?",
        "type": "mcq",
        "o": [
            "Client loses the Session ID; Server session becomes a Ghost (until GC runs)",
            "Server deletes session",
            "User gets banned",
            "App crashes"
        ]
    },
    {
        "q": "What is 'Device Flow' session?",
        "type": "mcq",
        "o": [
            "Session on input-constrained device (TV), often long-lived refresh tokens",
            "Mobile session",
            "Web session",
            "Desktop session"
        ]
    },
    {
        "q": "What is 'Single Sign On' (SSO)?",
        "type": "mcq",
        "o": [
            "Auth schemes allowing a user to log in with a single ID to any of several related, yet independent, software systems",
            "One password",
            "One server",
            "One db"
        ]
    },
    {
        "q": "SSO Session vs Local Session?",
        "type": "mcq",
        "o": [
            "SSO Session is at IdP (Global). Local Session is at App (Local). Logout needs to handle both.",
            "Same",
            "No difference",
            "SSO is local"
        ]
    },
    {
        "q": "Global Logout?",
        "type": "mcq",
        "o": [
            "Terminating the Session at IdP AND triggering logout at all registered Service Providers (SPs)",
            "Local logout",
            "App logout",
            "Browser logout"
        ]
    },
    {
        "q": "Partial Logout?",
        "type": "mcq",
        "o": [
            "Logging out from one App but keeping IdP session (SSO) active (User might be confused if auto-login happens again)",
            "Full logout",
            "Error logout",
            "Force logout"
        ]
    },
    {
        "q": "Session Identifier vs User Identifier?",
        "type": "mcq",
        "o": [
            "Session ID is temporal/ephemeral. User ID is persistent (Database ID). Session maps to User.",
            "Same",
            "Reversed",
            "None"
        ]
    },
    {
        "q": "Best way to generate Session ID?",
        "type": "mcq",
        "o": [
            "Cryptographically secure pseudo-random number generator (CSPRNG) - /dev/urandom",
            "Random()",
            "Time()",
            "Name()"
        ]
    },
    {
        "q": "Can you use UUID for Session ID?",
        "type": "mcq",
        "o": [
            "Yes (v4 is random), but ensure entropy is sufficient and generator is secure. (122 bits random)",
            "No",
            "Maybe",
            "Only v1"
        ]
    },
    {
        "q": "Should Session ID be in URL?",
        "type": "mcq",
        "o": [
            "NO. URL leaks in History, Logs, Referer headers. (Session Fixation/Hijacking risk)",
            "Yes convenient",
            "Yes faster",
            "Yes standard"
        ]
    },
    {
        "q": "What is 'URL Rewriting' for Sessions?",
        "type": "mcq",
        "o": [
            "Legacy technique in Java/PHP to put jsessionid in path when cookies are disabled (Insecure practice)",
            "Modern tech",
            "Security feature",
            "Best practice"
        ]
    },
    {
        "q": "Session Management Lifecycle?",
        "type": "mcq",
        "o": [
            "Creation -> Usage (Validation/Renewal) -> Termination (Logout/Timeout) -> Cleanup",
            "Start -> Stop",
            "Login -> Logout",
            "Init -> Exit"
        ]
    },
    {
        "q": "Can sessions imply 'AuthZ' (Authorization)?",
        "type": "mcq",
        "o": [
            "Session proves Identity (AuthN). It *contains* references to roles/permissions for AuthZ.",
            "Yes always",
            "No never",
            "AuthN is AuthZ"
        ]
    },
    {
        "q": "Stateful vs Stateless Scalability?",
        "type": "mcq",
        "o": [
            "Stateless (JWT) scales easier (no shared DB). Stateful (Session) needs Sticky LB or Redis (Central Store).",
            "Stateful is faster",
            "Stateless is harder",
            "Same"
        ]
    },
    {
        "q": "Stateful vs Stateless Revocation?",
        "type": "mcq",
        "o": [
            "Stateful = Instant Revocation (delete row). Stateless = Hard (wait for expiry or blacklist).",
            "Stateless is instant",
            "Stateful is hard",
            "Same"
        ]
    },
    {
        "q": "Hybrid Approach?",
        "type": "mcq",
        "o": [
            "Short-lived JWT (Stateless check) + Reference Refresh Token (Stateful check on renewal). Best of both.",
            "None",
            "Bad",
            "Slow"
        ]
    },
    {
        "q": "Session 'Entropy' meaning?",
        "type": "mcq",
        "o": [
            "Measure of randomness/unpredictability of the Session ID generation",
            "Length",
            "Size",
            "Speed"
        ]
    },
    {
        "q": "Predictable Session ID vulnerability?",
        "type": "mcq",
        "o": [
            "Attacker can guess valid session IDs (e.g. sequential numbers, time-based) and hijack accounts",
            "None",
            "Minor",
            "Rare"
        ]
    },
    {
        "q": "What is 'Session Donation'?",
        "type": "mcq",
        "o": [
            "Attacker logs in, then tricks victim into using attacker's session (logging *the victim* acts on attacker's account)",
            "Giving money",
            "Giving time",
            "Giving data"
        ]
    },
    {
        "q": "Example of Session Donation risk?",
        "type": "mcq",
        "o": [
            "Victim searches for sensitive info, thinking it's their account, but it's saved in Attacker's history (privacy breach)",
            "None",
            "Fun",
            "Fast"
        ]
    },
    {
        "q": "Mitigation for Session Donation?",
        "type": "mcq",
        "o": [
            "Show current logged-in user clearly; Force re-auth on sensitive actions; Prevent fixation.",
            "Hide user",
            "HideUI",
            "Disable search"
        ]
    },
    {
        "q": "Does HTTPS protect Session ID?",
        "type": "mcq",
        "o": [
            "Yes, encryption prevents sniffing on the wire. But endpoint security (XSS, Malware) still matters.",
            "No",
            "Maybe",
            "Partially"
        ]
    },
    {
        "q": "What are 'Super Cookies'?",
        "type": "mcq",
        "o": [
            "Cookies set on top-level domains (e.g. .com, .co.uk) - usually blocked by browsers/Public Suffix List",
            "Big cookies",
            "Tasty cookies",
            "Admin cookies"
        ]
    },
    {
        "q": "Why block Super Cookies?",
        "type": "mcq",
        "o": [
            "To prevent a site (attacker.co.uk) from setting cookies for another site (google.co.uk)",
            "Save space",
            "Save time",
            "Reduce traffic"
        ]
    },
    {
        "q": "What is 'Cookie Tossing'?",
        "type": "mcq",
        "o": [
            "Attacker sets a cookie from a subdomain (evil.app.com) that gets sent to main domain (app.com), overwriting legit cookie",
            "Throwing cookies",
            "Eating cookies",
            "Deleting cookies"
        ]
    },
    {
        "q": "Defense against Cookie Tossing?",
        "type": "mcq",
        "o": [
            "Use __Host- prefix for cookie names (Forces Secure, Path=/, and no Domain attribute)",
            "Use __Secure- prefix",
            "Use random names",
            "Use short names"
        ]
    },
    {
        "q": "What is '__Host-' cookie prefix?",
        "type": "mcq",
        "o": [
            "Prefix ensuring cookie is locked to the specific host (not subdomains) and is Secure.",
            "Host only",
            "Name only",
            "Value only"
        ]
    },
    {
        "q": "What is '__Secure-' cookie prefix?",
        "type": "mcq",
        "o": [
            "Prefix ensuring cookie has Secure flag set (but can still have Domain set)",
            "Secure only",
            "Host only",
            "Path only"
        ]
    },
    {
        "q": "Session Management in REST APIs?",
        "type": "mcq",
        "o": [
            "Ideally Stateless (Token based). If Cookie used, it MUST be immune to CSRF (SameSite, Anti-CSRF tokens).",
            "Always stateful",
            "Always stateless",
            "No auth"
        ]
    },
    {
        "q": "What is 'Session Puzzling'?",
        "type": "mcq",
        "o": [
            "Application uses session variables for one purpose in a context, but reuses them confusingly in another (Logic flaw)",
            "Confusing user",
            "Confusing server",
            "Confusing db"
        ]
    },
    {
        "q": "Is 'User-Agent' spoofable?",
        "type": "mcq",
        "o": [
            "Yes, trivial to change. Not a strong security control by itself.",
            "No unique",
            "No hard",
            "Maybe"
        ]
    },
    {
        "q": "Is 'IP Address' spoofable for TCP session?",
        "type": "mcq",
        "o": [
            "Hard for full TCP connection (Blind spoofing), but easy if attacker is on same network path/MITM.",
            "Yes easy",
            "No impossible",
            "Maybe"
        ]
    },
    {
        "q": "Session Termination UX?",
        "type": "mcq",
        "o": [
            "Provide clear 'Logout' button. Show 'You have been logged out' message. Redirect to public home.",
            "Hide logout",
            "Error page",
            "Crash"
        ]
    },
    {
        "q": "Should Logout invalidate Refresh Token?",
        "type": "mcq",
        "o": [
            "YES. Logout implies user wants to kill session on this device. Revoke RT.",
            "No keep it",
            "Maybe",
            "Only AT"
        ]
    },
    {
        "q": "Does closing browser Log Out?",
        "type": "mcq",
        "o": [
            "Only if using 'Session Cookies' (no expiry). If Persistent, session remains.",
            "Yes always",
            "No never",
            "Depends on OS"
        ]
    },
    {
        "q": "Session handling on Public Computers?",
        "type": "mcq",
        "o": [
            "User MUST explicitly Logout. Browser should not save password. 'Session Cookie' preferred over Persistent.",
            "No checks",
            "Auto login",
            "Save password"
        ]
    },
    {
        "q": "What is 'Session Prediction'?",
        "type": "mcq",
        "o": [
            "Guessing the next session ID based on observing generated IDs (Low entropy/Seq generators)",
            "Future telling",
            "AI guess",
            "Random guess"
        ]
    },
    {
        "q": "Tools to test Session Strength?",
        "type": "mcq",
        "o": [
            "Burp Suite (Sequencer), OWASP ZAP (Session Management scripts)",
            "Notepad",
            "Calculator",
            "Paint"
        ]
    },
    {
        "q": "Burp Sequencer purpose?",
        "type": "mcq",
        "o": [
            "Analyzes randomness (entropy) of a sample of Session IDs to find patterns",
            "Sequences music",
            "Sequences DNA",
            "Sequences logs"
        ]
    },
    {
        "q": "Session Management vs Authentication?",
        "type": "mcq",
        "o": [
            "AuthN establishes identity (Login). Session Mgmt maintains that identity over time (Subsequent requests).",
            "Same",
            "AuthN is longer",
            "Session is shorter"
        ]
    },
    {
        "q": "In Java Servlet, what is 'JSESSIONID'?",
        "type": "mcq",
        "o": [
            "Default cookie name for Java Servlet container session identifier",
            "JS ID",
            "JSON ID",
            "Job ID"
        ]
    },
    {
        "q": "In PHP, what is 'PHPSESSID'?",
        "type": "mcq",
        "o": [
            "Default cookie name for PHP session identifier",
            "PHP ID",
            "Personal ID",
            "Phone ID"
        ]
    },
    {
        "q": "In ASP.NET, what is 'ASP.NET_SessionId'?",
        "type": "mcq",
        "o": [
            "Default cookie name for ASP.NET session",
            "ASP ID",
            "Net ID",
            "Web ID"
        ]
    },
    {
        "q": "Hiding Server Tech via Cookie Name?",
        "type": "mcq",
        "o": [
            "Security by Obscurity. Change default cookie names (e.g. use 'SID') to not reveal stack, but low impact.",
            "High impact",
            "Critical",
            "Required"
        ]
    },
    {
        "q": "What is 'Reverse Proxy' session handling?",
        "type": "mcq",
        "o": [
            "Proxy (Nginx) sits in front, handles SSL/routing, and passes Session ID to backend servers",
            "Proxy generates session",
            "Proxy stores session",
            "Proxy deletes session"
        ]
    },
    {
        "q": "What is 'Session Affinity' (Load Balancing)?",
        "type": "mcq",
        "o": [
            "Ensuring a user always connects to the same backend server (Sticky Session) to access local RAM session",
            "Random connection",
            "Round robin",
            "Failover"
        ]
    },
    {
        "q": "What is 'Cookie Insert' method for Affinity?",
        "type": "mcq",
        "o": [
            "Load Balancer inserts a cookie (e.g. 'SERVERID=A') to track which node handles the user",
            "Server inserts it",
            "Browser inserts it",
            "User inserts it"
        ]
    },
    {
        "q": "What is 'Distributed Cache' for Sessions?",
        "type": "mcq",
        "o": [
            "Using a shared store (Redis, Memcached) accessible by ALL server nodes. Eliminates need for Sticky Sessions.",
            "Local cache",
            "Browser cache",
            "CPU cache"
        ]
    },
    {
        "q": "CAP Theorem impact on Session Store?",
        "type": "mcq",
        "o": [
            "Usually choose AP (Availability) or CP (Consistency). For sessions, Availability is often prioritized (Redis), but Consistency needed for lockouts.",
            "Consistency only",
            "Availability only",
            "Partition only"
        ]
    },
    {
        "q": "Race Condition in Redis Session?",
        "type": "mcq",
        "o": [
            "Concurrent writes might overwrite each other. Use optimistic locking (WATCH/MULTI) or partial updates (HSET).",
            "No race",
            "Always safe",
            "Use file lock"
        ]
    },
    {
        "q": "Database (SQL) for Sessions?",
        "type": "mcq",
        "o": [
            "Reliable/Persistent, but slower than RAM/Redis. High write load (UPDATE last_active every click) can kill DB performance.",
            "Fastest",
            "Best choice",
            "Zero load"
        ]
    },
    {
        "q": "In-Memory Session (RAM) downside?",
        "type": "mcq",
        "o": [
            "Lost if server restarts/crashes. Not shared across scale-out nodes.",
            "Super fast",
            "Too secure",
            "Too big"
        ]
    },
    {
        "q": "Encrypting Sessions at Rest?",
        "type": "mcq",
        "o": [
            "Encrypting session data in Redis/DB so dump doesn't reveal PII or tokens",
            "Encrypting code",
            "Encrypting network",
            "Encrypting log"
        ]
    },
    {
        "q": "Logging Session IDs?",
        "type": "mcq",
        "o": [
            "DANGEROUS. Logs are often less secure. Attacker reading logs can hijack active sessions. Redact/Hash them.",
            "Always log",
            "Good for debug",
            "Required"
        ]
    },
    {
        "q": "PCI-DSS Session Requirement?",
        "type": "mcq",
        "o": [
            "Idle timeout of 15 minutes for access to cardholder data environments",
            "1 hour",
            "24 hours",
            "No timeout"
        ]
    },
    {
        "q": "NIST 800-63B Session Guideline?",
        "type": "mcq",
        "o": [
            "Re-authenticate for sensitive operations (IAL/AAL check). 30 min idle recommended.",
            "10 min",
            "60 min",
            "Forever"
        ]
    },
    {
        "q": "JWT as Session mechanism?",
        "type": "mcq",
        "o": [
            "Store state in client (Signed Token). Server doesn't remember. Hard to logout.",
            "Server state",
            "Better logout",
            "Worst choice"
        ]
    },
    {
        "q": "JWE (Encrypted JWT) usage?",
        "type": "mcq",
        "o": [
            "Hides the claims (payload) from the client/browser content. Protects PII inside cookie.",
            "Signs only",
            "Hashes only",
            "Plain text"
        ]
    },
    {
        "q": "BFF Pattern (Backend for Frontend)?",
        "type": "mcq",
        "o": [
            "Middleware that holds tokens (Session/Access) on server side, issues simple Cookie to browser. Improves Security.",
            "Browser logic",
            "Frontend logic",
            "Mobile logic"
        ]
    },
    {
        "q": "Cookie Security in BFF?",
        "type": "mcq",
        "o": [
            "BFF translates Secure-HttpOnly-SameSite Cookie <-> Access Token for APIs. Browser never sees Access Token.",
            "Browser sees all",
            "No cookies",
            "No tokens"
        ]
    },
    {
        "q": "Risk of simple Bearer Token in Browser?",
        "type": "mcq",
        "o": [
            "Token Sidejacking (XSS theft/Storage leakage). Cookie with HttpOnly is generally safer against XSS exfiltration.",
            "None",
            "Faster",
            "Easier"
        ]
    },
    {
        "q": "Service Worker intercepting Session?",
        "type": "mcq",
        "o": [
            "SW can act as proxy, adding Authorization header. Storage in SW or IndexedDB is still vulnerable to XSS.",
            "Invulnerable",
            "Magic",
            "Block XSS"
        ]
    },
    {
        "q": "TLS Session Ticket vs App Session?",
        "type": "mcq",
        "o": [
            "TLS Ticket is for resuming SSL connection (handshake performance). App Session is for User Identity.",
            "Same",
            "TLS is App",
            "App is TLS"
        ]
    },
    {
        "q": "Kerberos Ticket Lifetime?",
        "type": "mcq",
        "o": [
            "Typically 8-10 hours (TGT). Reduces load on KDC.",
            "1 hour",
            "1 minute",
            "Forever"
        ]
    },
    {
        "q": "Silent Refresh (iframe)?",
        "type": "mcq",
        "o": [
            "Using a hidden iframe to prompt IdP for new token (prompt=none). Works if 3rd party cookies allowed (dying tech).",
            "Silent mode",
            "Audio off",
            "Video off"
        ]
    },
    {
        "q": "Session Purging Strategy?",
        "type": "mcq",
        "o": [
            "Scheduled job (cron) to DELETE FROM sessions WHERE expires < NOW(). Keeps DB small.",
            "Manual delete",
            "Never delete",
            "Delete all"
        ]
    },
    {
        "q": "What are 'Flash Attributes'?",
        "type": "mcq",
        "o": [
            "Short-lived session data meant to survive one redirect (e.g. 'Saved Successfully' message)",
            "Adobe Flash",
            "Fast data",
            "Bright data"
        ]
    },
    {
        "q": "What is 'View State' (ASP.NET)?",
        "type": "mcq",
        "o": [
            "State serialized into a hidden form field (__VIEWSTATE) on the page. can be huge. Should be MAC'd/Encrypted.",
            "Server state",
            "DB state",
            "Ram state"
        ]
    },
    {
        "q": "Risk of 'Hidden Form Fields' for state?",
        "type": "mcq",
        "o": [
            "Client can tamper with them easily (HTML edit). MUST sign them if they control logic.",
            "Secure",
            "Invisible",
            "Safe"
        ]
    },
    {
        "q": "ETag as Session Tracker?",
        "type": "mcq",
        "o": [
            "Server sends ETag (ID). Browser sends If-None-Match (ID). Server tracks user via ID. (Tracking vector)",
            "Caching",
            "Speed",
            "Images"
        ]
    },
    {
        "q": "Canvas Fingerprinting?",
        "type": "mcq",
        "o": [
            "Rendering hidden text on canvas and reading pixel data. Variation due to GPU/Driver identifies device.",
            "Drawing",
            "Painting",
            "Art"
        ]
    },
    {
        "q": "Audio Fingerprinting?",
        "type": "mcq",
        "o": [
            "Analyzing audio stack rendering differences to identify device without cookies",
            "Listening",
            "Mic check",
            "Sound check"
        ]
    },
    {
        "q": "What is 'Evercookie'?",
        "type": "mcq",
        "o": [
            "JS API that produces extremely persistent cookies by storing data in 10+ storage mechanisms (Flash, Silverlight, PNGs, History...)",
            "Tasty",
            "Forever",
            "Never"
        ]
    },
    {
        "q": "HSTS impact on Cookies?",
        "type": "mcq",
        "o": [
            "Forces HTTPS. Good for Secure cookies. Prevents downgrades that could leak non-Secure cookies.",
            "None",
            "Breaks cookies",
            "Makes HTTP"
        ]
    },
    {
        "q": "Content Security Policy (CSP) 'connect-src'?",
        "type": "mcq",
        "o": [
            "Restricts domains the script can send data to (Mitigates exfiltration of stolen session tokens)",
            "Connect all",
            "Block all",
            "Allow all"
        ]
    },
    {
        "q": "XSS relationship to Session Hijacking?",
        "type": "mcq",
        "o": [
            "XSS is the #1 way to steal Session Cookies (document.cookie) if HttpOnly is missing.",
            "Unrelated",
            "XSS is server side",
            "Hijacking is client side"
        ]
    },
    {
        "q": "TRACE method vulnerability (XST)?",
        "type": "mcq",
        "o": [
            "TRACE echoes back request headers (including HttpOnly cookies). XSS can read response of TRACE to bypass HttpOnly.",
            "Trace route",
            "Debug",
            "Log"
        ]
    },
    {
        "q": "Disabling TRACE?",
        "type": "mcq",
        "o": [
            "Configure Web Server (Apache/Nginx/IIS) to disable TRACE method. Standard hardening.",
            "Enable it",
            "Ignore it",
            "Use it"
        ]
    },
    {
        "q": "Session Expiry UX?",
        "type": "mcq",
        "o": [
            "Show warning popup ('Session expiring in 60s') with 'Extend' button before actual timeout.",
            "Just close",
            "Delete account",
            "Crash"
        ]
    },
    {
        "q": "Lazy Session Creation?",
        "type": "mcq",
        "o": [
            "Do not create a session (and cookie) until the user actually Authenticates or adds item to Cart. Saves resources.",
            "Create always",
            "Create on hit",
            "Create on ping"
        ]
    },
    {
        "q": "Guest Session Risk?",
        "type": "mcq",
        "o": [
            "Creating full session for every crawler/visitor exhausts Server RAM/DB storage (DoS).",
            "None",
            "Good metric",
            "More users"
        ]
    },
    {
        "q": "Preventing Session Flooding?",
        "type": "mcq",
        "o": [
            "Rate limiting, Bot detection, Lazy creation (Don't give sessions to bots).",
            "More RAM",
            "More DB",
            "Allow all"
        ]
    },
    {
        "q": "Session Migration?",
        "type": "mcq",
        "o": [
            "Moving a session from Server A to Server B (requires shared storage or replication) transparently.",
            "Deleting session",
            "Copying file",
            "Moving user"
        ]
    },
    {
        "q": "Tomcat Session Replication?",
        "type": "mcq",
        "o": [
            "Clustering feature where Tomcat nodes copy session data to each other (DeltaManager/BackupManager).",
            "Copying code",
            "Copying logs",
            "Copying config"
        ]
    },
    {
        "q": "Delta Replication?",
        "type": "mcq",
        "o": [
            "Replicating only the *changes* to the session object, not the whole object every time (Performance).",
            "Full copy",
            "No copy",
            "Backup"
        ]
    },
    {
        "q": "Sticky Bit?",
        "type": "mcq",
        "o": [
            "Persistence method in LBs. Also file permission bit. Context matters.",
            "Glue",
            "Tape",
            "Magnet"
        ]
    },
    {
        "q": "LCG (Linear Congruential Generator) Weakness?",
        "type": "mcq",
        "o": [
            "Predictable PRNG. Values can be calculated if you know the formula/seed. BAD for Session IDs.",
            "Good",
            "Secure",
            "Random"
        ]
    },
    {
        "q": "/dev/random vs /dev/urandom?",
        "type": "mcq",
        "o": [
            "/dev/random blocks if entropy low (slow). /dev/urandom is non-blocking CSPRNG (preferred for web sessions).",
            "Random is faster",
            "Urandom is unsafe",
            "Same"
        ]
    },
    {
        "q": "Session Fixation via Subdomain?",
        "type": "mcq",
        "o": [
            "Attacker controls 'evil.example.com', sets cookie for '.example.com'. Main site uses it. (Fix: Strict host checking)",
            "None",
            "Secure",
            "Isolated"
        ]
    },
    {
        "q": "Cookie Jar Overflow?",
        "type": "mcq",
        "o": [
            "Browser limits cookies per domain (e.g. 50). Attacker floods with junk cookies, pushing out valid auth cookie (DoS/Logout).",
            "Too many sweets",
            "Full error",
            "Disk full"
        ]
    },
    {
        "q": "Cookie Bomb?",
        "type": "mcq",
        "o": [
            "Setting many large cookies to exceed Server Header Size limit (e.g. 8KB), causing 400/413 errors for victim.",
            "Explosion",
            "Fire",
            "Noise"
        ]
    },
    {
        "q": "Reducing Cookie Size?",
        "type": "mcq",
        "o": [
            "Store data server-side (Session ID only). Use compression/minification if strictly necessary (JWT).",
            "Zip",
            "Tar",
            "Rar"
        ]
    },
    {
        "q": "Birthday Paradox in Sessions?",
        "type": "mcq",
        "o": [
            "Probability of collision increases rapidly with number of sessions. Need sufficient bits (128+) to keep collision risk zero.",
            "Cake",
            "Party",
            "Gift"
        ]
    },
    {
        "q": "Why not 64-bit Session ID?",
        "type": "mcq",
        "o": [
            "Collision likely with high traffic (billions of requests). 128-bit is the safe standard.",
            "Enough",
            "Too big",
            "Too slow"
        ]
    },
    {
        "q": "UUID v4 suitability?",
        "type": "mcq",
        "o": [
            "Good for Session IDs. 122 bits of randomness. Collision probability negligible.",
            "Bad",
            "Weak",
            "Slow"
        ]
    },
    {
        "q": "Snowflake ID?",
        "type": "mcq",
        "o": [
            "Distributed ID generation (Time + Machine ID + Sequence). Sortable. Good for DB keys, okay for Sessions.",
            "Ice",
            "Cold",
            "White"
        ]
    },
    {
        "q": "Purpose of 'Nonce'?",
        "type": "mcq",
        "o": [
            "Number Used Once. Prevents Replay Attacks. Essential in Auth protocols (Digest, OIDC).",
            "Random",
            "Twice",
            "Three times"
        ]
    },
    {
        "q": "Purpose of 'State' param?",
        "type": "mcq",
        "o": [
            "Maintains state between request and callback (CSRF protection, Restoration of user context).",
            "Country",
            "City",
            "Region"
        ]
    },
    {
        "q": "PKCE code_verifier relationship to Session?",
        "type": "mcq",
        "o": [
            "code_verifier must be stored in Client's temporary session (browser/app) to verify the code_exchange callback.",
            "In url",
            "In db",
            "In logs"
        ]
    },
    {
        "q": "Session 'Locking'?",
        "type": "mcq",
        "o": [
            "Preventing concurrent requests for same session to avoid race conditions (Serialize access). Can slow down app.",
            "Deadlock",
            "Key lock",
            "Padlock"
        ]
    },
    {
        "q": "Sessionless (Stateless) Auth?",
        "type": "mcq",
        "o": [
            "No state on server. Every request carries all required info (JWT). Scales well, hard to revoke.",
            "Sessionfull",
            "Stateful",
            "Database"
        ]
    },
    {
        "q": "Session 'Toxicity'?",
        "type": "mcq",
        "o": [
            "When session data is corrupted or causes server errors, and persists because it's re-loaded. (Need mechanism to clear bad sessions)",
            "Poison",
            "Virus",
            "Acid"
        ]
    },
    {
        "q": "Clearing Bad Sessions?",
        "type": "mcq",
        "o": [
            "Provide a 'Clear Cookies' route or automatic detection of deserialization errors to nuke the session.",
            "Reboot server",
            "Delete db",
            "Format disk"
        ]
    },
    {
        "q": "Session 'Warming'?",
        "type": "mcq",
        "o": [
            "Pre-loading session data into cache from DB before user requests it (Predictive). Rare optimization.",
            "Heating",
            "Cooling",
            "Freezing"
        ]
    },
    {
        "q": "What is 'MFA Session Upgrade'?",
        "type": "mcq",
        "o": [
            "User has a valid 'Password-only' session, calls sensitive API, Server demands 'MFA' check, then upgrades session to 'MFA-verified'.",
            "Paying money",
            "Buying hardware",
            "Installing app"
        ]
    },
    {
        "q": "How to implement 'Remember MFA Device'?",
        "type": "mcq",
        "o": [
            "Set a long-lived persistent cookie (separate from session) that acts as a 'second factor' proof for future logins",
            "Save in DB",
            "Save password",
            "Save IP"
        ]
    },
    {
        "q": "Concurrent Login Limit implementation?",
        "type": "mcq",
        "o": [
            "Store active session count in DB/Redis. On login, if count > Max, delete oldest session (or block new one).",
            "Ask user",
            "Ban user",
            "Crash server"
        ]
    },
    {
        "q": "Force Remote Logout?",
        "type": "mcq",
        "o": [
            "Feature allowing user to click 'Sign out all other devices'. Deletes all session records except current one.",
            "Delete account",
            "Change password",
            "Reset browser"
        ]
    },
    {
        "q": "What is 'Session History'?",
        "type": "mcq",
        "o": [
            "Showing user a list of 'Active Sessions' with Device Name, IP Location, and Last Active time (Security feature).",
            "Browser history",
            "Search history",
            "Chat history"
        ]
    },
    {
        "q": "Geo-Location Alert?",
        "type": "mcq",
        "o": [
            "Emailing user 'New login from China' when previous was 'USA'. Calculated via IP-to-Geo DB.",
            "SMS spam",
            "Blocked",
            "Allowed"
        ]
    },
    {
        "q": "Exponential Backoff for Login?",
        "type": "mcq",
        "o": [
            "Delaying response time (1s, 2s, 4s...) after repeated failures to slow down Brute Force attacks",
            "Banning IP",
            "Deleting user",
            "Fast fail"
        ]
    },
    {
        "q": "Password Age Check in Session?",
        "type": "mcq",
        "o": [
            "Forcing logout/password-change if 'password_last_changed' timestamp > 90 days (Legacy policy, NIST advises against force-rotation unless compromised)",
            "Every day",
            "Every hour",
            "Never"
        ]
    },
    {
        "q": "Re-Auth Grace Period?",
        "type": "mcq",
        "o": [
            "Allowing sensitive actions without password prompt if user logged in (or re-authed) within last X minutes (e.g. 10m)",
            "Instant",
            "Forever",
            "1 second"
        ]
    },
    {
        "q": "Impersonation Audit Risk?",
        "type": "mcq",
        "o": [
            "If Admin impersonates User, logs MUST distinguish 'Admin acting as User' vs 'User'. Otherwise non-repudiation fails.",
            "No risk",
            "Admin is god",
            "User is blind"
        ]
    },
    {
        "q": "Canary Deployment Session Issue?",
        "type": "mcq",
        "o": [
            "If Version A and B have incompatible session structures, user hitting B then A might crash/logout. (Need serialization versioning)",
            "None",
            "Faster",
            "Better"
        ]
    },
    {
        "q": "Feature Flag in Session?",
        "type": "mcq",
        "o": [
            "Storing enabled features in session for performance. Problem: User doesn't see flag update until re-login/refresh.",
            "Good",
            "Realtime",
            "Fastest"
        ]
    },
    {
        "q": "Dark Mode Preference Storage?",
        "type": "mcq",
        "o": [
            "Local Storage (or Cookie) is best so it applies immediately before login. Sync to DB for cross-device.",
            "Session only",
            "Server memory",
            "Url param"
        ]
    },
    {
        "q": "Cart Data Merge?",
        "type": "mcq",
        "o": [
            "When Anonymous User adds items (Session A) then Logs In (Session B), merge items from A into B.",
            "Delete A",
            "Delete B",
            "Ignore A"
        ]
    },
    {
        "q": "Shopping Cart Abandonment?",
        "type": "mcq",
        "o": [
            "Keeping Cart items (Persistent Session/DB) even if user leaves, to email 'You forgot items' later.",
            "Deleting cart",
            "Clearing RAM",
            "Closing shop"
        ]
    },
    {
        "q": "Multi-Tab Syncing?",
        "type": "mcq",
        "o": [
            "Using BroadcastChannel API or 'storage' event listener to update state (e.g. Logout) across all open tabs instantly",
            "Reload all",
            "Close all",
            "Ignore"
        ]
    },
    {
        "q": "Tab-Specific Session?",
        "type": "mcq",
        "o": [
            "Using 'Session Storage' which is isolated per tab. Useful for multi-account login in same browser (but risky)",
            "Cookies",
            "Local Storage",
            "IndexedDB"
        ]
    },
    {
        "q": "Closing Tab vs Browser?",
        "type": "mcq",
        "o": [
            "Session Cookies are cleared on Browser Close (usually). Closing Tab does NOT clear Session Cookies.",
            "Same",
            "Tab clears cookie",
            "Browser keeps cookie"
        ]
    },
    {
        "q": "Restoring Tabs (Session Restore) Risk?",
        "type": "mcq",
        "o": [
            "Modern browsers restore Session Cookies (even non-persistent ones) when 'Continue where you left off' is used. (Security nuance)",
            "None",
            "Good",
            "Bad"
        ]
    },
    {
        "q": "Incognito Mode Isolation?",
        "type": "mcq",
        "o": [
            "Incognito creates a temporary empty Cookie Jar. Does not see Main Jar. Cleared on exit.",
            "Sees Main Jar",
            "Saves to disk",
            "Shares RAM"
        ]
    },
    {
        "q": "Client Hints (Sec-CH-UA)?",
        "type": "mcq",
        "o": [
            "New standard replacing User-Agent string to reduce fingerprinting surface while giving Version/Brand info",
            "Old standard",
            "Cookie",
            "Token"
        ]
    },
    {
        "q": "Fingerprinting protection?",
        "type": "mcq",
        "o": [
            "Browsers reducing precision of window.performance.now() and adding noise to Canvas readback to stop identification",
            "Allowing all",
            "Sending ID",
            "Sending MAC"
        ]
    },
    {
        "q": "Privacy Sandbox (Topics API)?",
        "type": "mcq",
        "o": [
            "Google's proposal to replace 3rd Party Cookies for ads with browser-calculated interest categories",
            "New cookie",
            "Super cookie",
            "Flash cookie"
        ]
    },
    {
        "q": "First-Party Sets (FPS)?",
        "type": "mcq",
        "o": [
            "Declaring related domains (google.com, youtube.com) so browser allows cross-site cookies within the Set",
            "Block all",
            "Allow all",
            "Hack"
        ]
    },
    {
        "q": "Partitioned Cookies (CHIPS)?",
        "type": "mcq",
        "o": [
            "Cookies Having Independent Partitioned State. Iframe cookie is keyed by (Top-Site, Frame-Site). Prevents cross-site tracking.",
            "Shared cookies",
            "Global cookies",
            "Open cookies"
        ]
    },
    {
        "q": "Bounce Tracking?",
        "type": "mcq",
        "o": [
            "Redirecting user through a tracker domain (tracker.com) momentarily to set a cookie before landing on destination",
            "Tennis",
            "Ping pong",
            "Jumping"
        ]
    },
    {
        "q": "Link Decoration Tracking?",
        "type": "mcq",
        "o": [
            "Adding unique ID to URL query params (site.com?click_id=xyz). Privacy browsers strip these.",
            "Decoration",
            "CSS",
            "Style"
        ]
    },
    {
        "q": "Session Propagation in Microservices?",
        "type": "mcq",
        "o": [
            "Passing Auth Token (Bearer) or Session ID in headers (Authorization / Cookie) to downstream services",
            "Query param",
            "Body",
            "File"
        ]
    },
    {
        "q": "Trace ID vs Session ID?",
        "type": "mcq",
        "o": [
            "Trace ID tracks a specific Request chain (for debugging). Session ID tracks a User Context (for auth).",
            "Same",
            "Trace is User",
            "Session is Request"
        ]
    },
    {
        "q": "Log Injection / CRLF Injection?",
        "type": "mcq",
        "o": [
            "Attacker puts newline characters (\\n) in Session ID or Headers to forge log entries or HTTP headers. (Sanitize inputs!)",
            "SQL Injection",
            "XSS",
            "CSRF"
        ]
    },
    {
        "q": "Session Puzzling / Mass Assignment?",
        "type": "mcq",
        "o": [
            "Attacker manipulates input (forms) to overwrite session variables (e.g. 'isAdmin=true') if framework auto-binds input to session",
            "Puzzle game",
            "Guessing",
            "Brute force"
        ]
    },
    {
        "q": "Timing Attack on Session Verification?",
        "type": "mcq",
        "o": [
            "If string comparison stops at first mismatch, attacker can guess ID byte-by-byte measuring time. (Use Constant Time Compare)",
            "Time travel",
            "Clock skew",
            "Timeout"
        ]
    },
    {
        "q": "Padding Oracle Attack (CBC)?",
        "type": "mcq",
        "o": [
            "Attacker decrypts cookie by observing error responses to modified ciphertext (padding errors). Use Authenticated Encryption (GCM).",
            "Padlock",
            "Buffer overflow",
            "Stack overflow"
        ]
    },
    {
        "q": "Authenticated Encryption (AE/AEAD)?",
        "type": "mcq",
        "o": [
            "Encryption that guarantees both Confidentiality and Integrity (GCM, CCM, Poly1305). Must use for Client-side Sessions.",
            "AES-CBC",
            "DES",
            "RC4"
        ]
    },
    {
        "q": "Key Rotation for Session Cookies?",
        "type": "mcq",
        "o": [
            "Periodically changing signing/encryption keys. App must support 'Old Key' for verify and 'New Key' for sign during transition.",
            "Never rotate",
            "Delete old",
            "Crash"
        ]
    },
    {
        "q": "Secrets Management?",
        "type": "mcq",
        "o": [
            "Don't hardcode keys in code. Use Environment Vars or Vault. Leaked key = All sessions compromised.",
            "Hardcode",
            "Commit to git",
            "Post verification"
        ]
    },
    {
        "q": "Websocket Auth?",
        "type": "mcq",
        "o": [
            "Initial HTTP Handshake sends Cookie/Header. WS connection stays open as 'Authenticated'.",
            "Auth every frame",
            "No auth",
            "Password in body"
        ]
    },
    {
        "q": "CSWSH (Cross-Site WebSocket Hijacking)?",
        "type": "mcq",
        "o": [
            "Like CSRF for WebSockets. Attacker site opens WS to your server. Check 'Origin' header during Handshake!",
            "XSS",
            "SQLi",
            "RCE"
        ]
    },
    {
        "q": "Server-Sent Events (SSE) Auth?",
        "type": "mcq",
        "o": [
            "Uses standard HTTP cookies/headers. Connection applies to one session.",
            "UDP",
            "TCP raw",
            "No auth"
        ]
    },
    {
        "q": "HTTP/2 Multiplexing impact?",
        "type": "mcq",
        "o": [
            "Multiple requests share one TCP connection. Head-of-Line blocking reduced. Session handling same (Headers/Cookies per stream).",
            "Breaks sessions",
            "One session per TCP",
            "No cookies"
        ]
    },
    {
        "q": "QUIC (HTTP/3) Connection Migration?",
        "type": "mcq",
        "o": [
            "Allows switching networks (Wifi->LTE) without breaking connection (Connection ID). Context survives IP change.",
            "Disconnects",
            "Resets",
            "Errors"
        ]
    },
    {
        "q": "0-RTT Replay Risk?",
        "type": "mcq",
        "o": [
            "Early data in TLS 1.3/QUIC can be replayed by attacker. Don't use 0-RTT for sensitive (non-idempotent) actions like POST.",
            "Safe",
            "Fast",
            "Best"
        ]
    },
    {
        "q": "Session vs Connection?",
        "type": "mcq",
        "o": [
            "Connection is transport (TCP/TLS). Session is application state (User). One session can span many connections.",
            "Same",
            "Inverted",
            "None"
        ]
    },
    {
        "q": "Are Query Parameters secure for Session ID?",
        "type": "mcq",
        "o": [
            "No. Logs, History, Referer headers capture them. Always use Cookies or Headers.",
            "Yes",
            "For mobile",
            "For API"
        ]
    },
    {
        "q": "Session Hijacking via Man-In-The-Middle?",
        "type": "mcq",
        "o": [
            "Attacker intercepts non-secure HTTP traffic to steal cookie. Defense: HSTS + Secure Cookie + VPN.",
            "Checking IP",
            "Checking MAC",
            "Checking Time"
        ]
    },
    {
        "q": "Is 'User-Agent' reliable for fraud detection?",
        "type": "mcq",
        "o": [
            "Weak signal. Easily spoofed. But useful for 'New Device' heuristics (if UA drastically changes).",
            "Strong signal",
            "Proof",
            "Signature"
        ]
    },
    {
        "q": "Cache-Control: private for Session pages?",
        "type": "mcq",
        "o": [
            "Authenticated pages MUST set 'Cache-Control: no-store, private' to prevent caching on shared proxies/disk.",
            "Public",
            "Max-age 1 year",
            "Allow all"
        ]
    },
    {
        "q": "Autocomplete=off on sensitive fields?",
        "type": "mcq",
        "o": [
            "Prevents browser from caching sensitive data (Credit Card, SSN) in session forms. (Browser support varies)",
            "Autocomplete=on",
            "No effect",
            "Required"
        ]
    },
    {
        "q": "Session Termination on Password Change?",
        "type": "mcq",
        "o": [
            "Best Practice: Invalidate ALL existing sessions (tokens) for that user when password changes. (Prevent stolen session persistence)",
            "Keep valid",
            "Notify only",
            "Ignore"
        ]
    },
    {
        "q": "Session Entropy calculation?",
        "type": "mcq",
        "o": [
            "Length * log2(Charset Size). e.g. 32 hex chars = 32 * 4 = 128 bits.",
            "Length + Size",
            "Length * Size",
            "Random"
        ]
    },
    {
        "q": "Why base64url encoding for tokens?",
        "type": "mcq",
        "o": [
            "URL-safe characters (A-Z, a-z, 0-9, -, _) allow passing in Header/URL without escaping issues.",
            "Compression",
            "Encryption",
            "Obfuscation"
        ]
    },
    {
        "q": "Session Injection via XSS?",
        "type": "mcq",
        "o": [
            "XSS can force a browser to send requests using the user's session (functionally CSRF but via JS).",
            "SQLi",
            "DoS",
            "RCE"
        ]
    },
    {
        "q": "Does 'HttpOnly' prevent CSRF?",
        "type": "mcq",
        "o": [
            "NO. HttpOnly prevents reading cookie via JS. CSRF doesn't need to read it (browser sends it automatically).",
            "Yes",
            "Maybe",
            "Mostly"
        ]
    },
    {
        "q": "Does 'SameSite' prevent XSS?",
        "type": "mcq",
        "o": [
            "NO. SameSite prevents CSRF. XSS runs *inside* the origin, so it bypasses SameSite.",
            "Yes",
            "Maybe",
            "Mostly"
        ]
    },
    {
        "q": "Defense in Depth: Session?",
        "type": "mcq",
        "o": [
            "Short Timeout + HttpOnly + Secure + SameSite + Rotation + CSP + Monitor.",
            "Long Timeout",
            "No Cookie",
            "No Auth"
        ]
    },
    {
        "q": "Session ID length recommnedation?",
        "type": "mcq",
        "o": [
            "At least 128 bits of entropy (e.g. 16 bytes raw, 22-24 chars Base64).",
            "8 chars",
            "10 chars",
            "5 chars"
        ]
    },
    {
        "q": "Why not use Client IP in Session ID hash?",
        "type": "mcq",
        "o": [
            "Breaks roaming (Mobile/Wifi switch). Breaks privacy (GDPR). NAT issues.",
            "It is good",
            "Required",
            "Standard"
        ]
    },
    {
        "q": "Session vs Cache?",
        "type": "mcq",
        "o": [
            "Session is per-user private state. Cache is often public/shared content. Don't cache session pages!",
            "Same",
            "Session is cache",
            "Cache is session"
        ]
    },
    {
        "q": "Private Browsing Session?",
        "type": "mcq",
        "o": [
            "Ephemeral storage. Cleared on close. No history saved. Protecting local privacy, not network privacy.",
            "VPN",
            "Tor",
            "Encryption"
        ]
    },
    {
        "q": "Session in multiple data centers?",
        "type": "mcq",
        "o": [
            "Requires Global Replication (Redis Active-Active/Geo-Replication) or Sticky 'Region' routing.",
            "Magic",
            "DNS",
            "Ping"
        ]
    },
    {
        "q": "What are 'Flash Cookies' (LSO)?",
        "type": "mcq",
        "o": [
            "Local Shared Objects in Adobe Flash. Old evasion tech to store data outside browser control. (Obsolete now)",
            "Fast cookies",
            "Light cookies",
            "Bright cookies"
        ]
    },
    {
        "q": "HbbTV Cookie Handling?",
        "type": "mcq",
        "o": [
            "Smart TVs often have limited cookie management. Privacy concerns with cross-channel tracking.",
            "Perfect",
            "Strict",
            "None"
        ]
    },
    {
        "q": "IoT Session Handling (MQTT)?",
        "type": "mcq",
        "o": [
            "Often uses Connect Packet with Username/Password. Session can be 'Persistent' (CleanSession=false) to queue messages.",
            "Cookies",
            "HTML",
            "Forms"
        ]
    },
    {
        "q": "CoAP DTLS Session Resumption?",
        "type": "mcq",
        "o": [
            "Critical for IoT battery life. Resuming encrypted UDP session without full Handshake.",
            "Full handshake",
            "No crypto",
            "Plain text"
        ]
    },
    {
        "q": "Smart Card (CAC/PIV) Session Init?",
        "type": "mcq",
        "o": [
            "Uses Mutual TLS (Client Cert). Web Server maps Cert Subject to User. Creates standard HTTP Session.",
            "Password",
            "OTP",
            "Magic link"
        ]
    },
    {
        "q": "Kerberos TGT to Web Session?",
        "type": "mcq",
        "o": [
            "SPNEGO/Negotiate protocol exchanges Ticket. Server validates, then issues standard HTTP Session Cookie (Avoids re-auth).",
            "Direct TGT",
            "Password",
            "Basic auth"
        ]
    },
    {
        "q": "NTLM Auth risk?",
        "type": "mcq",
        "o": [
            "Connection-based auth (not Request-based). Risky through Proxies (Connection Reuse can log in wrong user). Deprecated.",
            "Secure",
            "Modern",
            "Best"
        ]
    },
    {
        "q": "Basic Auth vs Session?",
        "type": "mcq",
        "o": [
            "Basic sends Credentials (Base64) on EVERY request. Session sends Creds ONCE, then uses Token. Session is more secure/performant.",
            "Basic is better",
            "Same",
            "Basic is newer"
        ]
    },
    {
        "q": "WCAG 2.1 Auto-Logout Requirement?",
        "type": "mcq",
        "o": [
            "Must warn user before timeout (e.g. 'Session expiring, continue?') and allow extending. (Unless security critical)",
            "Logout silently",
            "No warn",
            "Lockout"
        ]
    },
    {
        "q": "ASP.NET Core Session State?",
        "type": "mcq",
        "o": [
            "Middleware. Defaults to In-Memory. Needs IDistributedCache (Redis/SQL) for load balancing.",
            "File only",
            "Cookie only",
            "None"
        ]
    },
    {
        "q": "Express.js 'express-session'?",
        "type": "mcq",
        "o": [
            "Server-side session middleware. Stores ID in cookie. Needs 'store' adapter (Connect-Redis) for production.",
            "Client side",
            "Browser side",
            "No store"
        ]
    },
    {
        "q": "Express.js 'cookie-session'?",
        "type": "mcq",
        "o": [
            "Client-side session. Stores ALL data in cookie (Signed/Encrypted). Size limit 4KB.",
            "Server side",
            "Database",
            "Memory"
        ]
    },
    {
        "q": "Rails Cookie Store (Default)?",
        "type": "mcq",
        "o": [
            "Encrypts and Signs session data into cookie. Server holds no state. Easy to scale.",
            "Unsafe",
            "Plain text",
            "Memory only"
        ]
    },
    {
        "q": "Django Session Framework?",
        "type": "mcq",
        "o": [
            "Defaults to DB storage (django_session table). Secure by default.",
            "Memory",
            "File",
            "Cookie"
        ]
    },
    {
        "q": "What is 'Java Deserialization' vulnerability in Sessions?",
        "type": "mcq",
        "o": [
            "If session data contains serialized objects, attacker attacks logic during deserialization (RCE). Don't serialize generic objects.",
            "XSS",
            "SQLi",
            "CSRF"
        ]
    },
    {
        "q": "Gadget Chain Attack?",
        "type": "mcq",
        "o": [
            "Chaining valid class methods during deserialization to execute arbitrary code (e.g. Apache Commons Collections exploit)",
            "Chain link",
            "Blockchain",
            "Hardware"
        ]
    },
    {
        "q": "Integrity Check (HMAC) importance?",
        "type": "mcq",
        "o": [
            "Ensures Client hasn't modified Cookie content. Critical for Client-side storage.",
            "Confidentiality",
            "Speed",
            "Size"
        ]
    },
    {
        "q": "Encrypt-then-Mac (EtM)?",
        "type": "mcq",
        "o": [
            "The correct order: Encrypt data, THEN sign the ciphertext. Prevents Padding Oracle attacks.",
            "Mac then Encrypt",
            "Encrypt only",
            "Mac only"
        ]
    },
    {
        "q": "Cookie Scope: Ports?",
        "type": "mcq",
        "o": [
            "Cookies do NOT isolate ports. App running on localhost:8080 allows cookies for localhost:3000. (SOP checks ports, Cookies don't)",
            "Ports isolated",
            "Strict ports",
            "Secure ports"
        ]
    },
    {
        "q": "Public Suffix List (PSL)?",
        "type": "mcq",
        "o": [
            "List of domains where users can't set cookies (e.g. .com, .co.uk). Browsers use it to block supercookies.",
            "Whitelist",
            "Blacklist",
            "DNS"
        ]
    },
    {
        "q": "Cookie Shadowing?",
        "type": "mcq",
        "o": [
            "Attacker sets cookie with specific Path/Domain that 'shadows' (takes precedence over) the legit cookie.",
            "Hiding",
            "Darkness",
            "Deleting"
        ]
    },
    {
        "q": "Cookie Prefixes defense?",
        "type": "mcq",
        "o": [
            "Using __Host- prefix enforces strict attributes, preventing shadowing from subdomains.",
            "Encryption",
            "Signing",
            "Hashing"
        ]
    },
    {
        "q": "Cookie Priority Attribute?",
        "type": "mcq",
        "o": [
            "Tells browser which cookies to delete first when limit reached (Low/Medium/High). Chrome specific.",
            "Speed",
            "Order",
            "Rank"
        ]
    },
    {
        "q": "Cookie Count Limit?",
        "type": "mcq",
        "o": [
            "Browsers limit cookies per domain (e.g. 180 in Chrome, 50 in older). Oldest are evicted (Eviction attack).",
            "Unlimited",
            "1000",
            "10"
        ]
    },
    {
        "q": "Session Fixation in JSP?",
        "type": "mcq",
        "o": [
            "URL Rewriting (;jsessionid=...) allowed attacker to fixate session via link. (Disable URL rewriting!)",
            "Secure",
            "Good",
            "Fast"
        ]
    },
    {
        "q": "Open Wi-Fi Risk?",
        "type": "mcq",
        "o": [
            "If not HTTPS (and Secure flag), cookies travel plain-text. Sniffable by anyone on wifi (Firesheep).",
            "Safe",
            "Encrypted",
            "Fast"
        ]
    },
    {
        "q": "Session Replay Tools (FullStory/Hotjar) risk?",
        "type": "mcq",
        "o": [
            "They record DOM. If sensitive data (Password/Credit Card) not marked 'ignored', it's recorded on vendor servers.",
            "No risk",
            "Safe",
            "Private"
        ]
    },
    {
        "q": "GDPR and Session Replay?",
        "type": "mcq",
        "o": [
            "Must get explicit consent. High privacy impact. Personal Data recording must be prevented.",
            "Required",
            "Allowed",
            "Ignored"
        ]
    },
    {
        "q": "Session Fingerprint (JA3)?",
        "type": "mcq",
        "o": [
            "Fingerprinting the TLS Client Hello packets. Can identify bot vs browser even if UA is spoofed.",
            "Cookie print",
            "HTML print",
            "JS print"
        ]
    },
    {
        "q": "IDFA/UDID Deprecation?",
        "type": "mcq",
        "o": [
            "Apple removed persistent Device IDs to protect privacy. Apps shouldn't rely on them for Session stability.",
            "Enabled",
            "Good",
            "New"
        ]
    },
    {
        "q": "Vendor ID (IDFV)?",
        "type": "mcq",
        "o": [
            "Identifier valid for all apps from same Vendor. Changes if all vendor apps deleted. Better for privacy.",
            "Global ID",
            "Hardware ID",
            "Permanent ID"
        ]
    },
    {
        "q": "Root/Jailbreak Detection?",
        "type": "mcq",
        "o": [
            "Banking apps terminate session if Root detected (Security posture). Can be bypassed (Cat & Mouse game).",
            "Always works",
            "Never works",
            "Required"
        ]
    },
    {
        "q": "SSL Pinning?",
        "type": "mcq",
        "o": [
            "Hardcoding trusted Server Cert/PublicKey in App. Prevents MITM even if attacker installs fake Root CA on device.",
            "Pin code",
            "Password",
            "Login"
        ]
    },
    {
        "q": "DNS Rebinding Attack?",
        "type": "mcq",
        "o": [
            "Attacker domain resolves to internal IP (192.168.1.1) after TTL. Script accesses internal Router Session.",
            "DNS Sec",
            "DNS Fast",
            "DNS Cache"
        ]
    },
    {
        "q": "Host Header Injection?",
        "type": "mcq",
        "o": [
            "Attacker sends arbitrary Host header. If app uses it for Password Reset link generation, victim gets link to attacker site.",
            "Host check",
            "Host file",
            "Host route"
        ]
    },
    {
        "q": "Cache Poisoning?",
        "type": "mcq",
        "o": [
            "Tricking cache to store malicious response (e.g. XSS) for a URL that legitimate users will request.",
            "Food poison",
            "Memory poison",
            "Disk poison"
        ]
    },
    {
        "q": "HTTP Request Smuggling (Session Desync)?",
        "type": "mcq",
        "o": [
            "Discrepancy in Content-Length vs Transfer-Encoding between Frontend/Backend. Can hijack other users' requests/sessions.",
            "Importing",
            "Exporting",
            "Trading"
        ]
    },
    {
        "q": "CL.TE vs TE.CL?",
        "type": "mcq",
        "o": [
            "Types of Request Smuggling logic errors (Content-Length, Transfer-Encoding).",
            "Protocols",
            "Headers",
            "Methods"
        ]
    },
    {
        "q": "Race Condition in 'One-Time' Token?",
        "type": "mcq",
        "o": [
            "If parallel requests use the same 'One-Time' token before DB invalidates it, attacker might get a session.",
            "Safe",
            "Fast usage",
            "Single thread"
        ]
    },
    {
        "q": "Session Metadata?",
        "type": "mcq",
        "o": [
            "Information stored alongside ID: IP Address, User Agent, Created At, Last Active, Device Type. Used for Security Monitor.",
            "Data",
            "Content",
            "Files"
        ]
    },
    {
        "q": "What is 'Priority' in cookies used for?",
        "type": "mcq",
        "o": [
            "Influences retention policy when cookie jar is full (Low priority evicted first).",
            "Speed",
            "Security",
            "Color"
        ]
    },
    {
        "q": "What is 'Partitioned' attribute in cookies?",
        "type": "mcq",
        "o": [
            "Opt-in for CHIPS (Independent Partitioned State) used in cross-site iframes.",
            "Split",
            "Shared",
            "Global"
        ]
    },
    {
        "q": "Session fixation protection in Spring Security?",
        "type": "mcq",
        "o": [
            "Default: migrateSession (creates new session, copies attributes) or newSession (clean slate).",
            "None",
            "Weak",
            "Manual"
        ]
    },
    {
        "q": "Why is 'migrateSession' useful?",
        "type": "mcq",
        "o": [
            "Preserves pre-login data (Shopping Cart) while securing the ID against fixation.",
            "Copying",
            "Backup",
            "Restore"
        ]
    },
    {
        "q": "Tor 'New Circuit'?",
        "type": "mcq",
        "o": [
            "User requests new IP path. Session Cookies typically persist unless 'New Identity' (Restart) chosen.",
            "New Cookie",
            "New User",
            "New App"
        ]
    },
    {
        "q": "Session vs 'Remember Me' security?",
        "type": "mcq",
        "o": [
            "Remember Me token should be stronger/distinct. Compromise of Session = Current Access. Compromise of Remember Token = Persistent Access.",
            "Same",
            "Session stronger",
            "Remember weaker"
        ]
    },
    {
        "q": "Session Hijacking vs Session Spoofing?",
        "type": "mcq",
        "o": [
            "Hijacking = Stealing existing valid ID. Spoofing = Creating a new valid ID (needs key compromise or weak PRNG).",
            "Same",
            "Spoofing is theft",
            "Hijacking is creation"
        ]
    },
    {
        "q": "Session ID unpredictability?",
        "type": "mcq",
        "o": [
            "Must be resistant to brute force and prediction attacks. Use CSPRNG.",
            "Sequential",
            "Time based",
            "Name based"
        ]
    },
    {
        "q": "Does 'Secure' flag encrypt cookie?",
        "type": "mcq",
        "o": [
            "NO. It mandates transmission over HTTPS (Encrypted Channel). It does NOT encrypt the cookie content itself.",
            "Yes",
            "Maybe",
            "Double encrypt"
        ]
    },
    {
        "q": "Session Management in Serverless?",
        "type": "mcq",
        "o": [
            "Stateless functions favor JWT. If Session needed, use external store (Redis/DynamoDB) passed by ID.",
            "Local file",
            "Memory",
            "Global var"
        ]
    },
    {
        "q": "Cold Start impact on Sessions?",
        "type": "mcq",
        "o": [
            "In-Memory sessions lost on Lambda freeze/recycle. Must use external persistence.",
            "None",
            "Keeps data",
            "Saves to disk"
        ]
    },
    {
        "q": "What is 'Passkey' (WebAuthn) Session?",
        "type": "mcq",
        "o": [
            "FIDO2 standard. Public key interaction creating a high-assurance session. Phishing resistant.",
            "Password",
            "OTP",
            "Magic link"
        ]
    },
    {
        "q": "Deep Linking Session?",
        "type": "mcq",
        "o": [
            "Opening Mobile App from a URL. Session state must be handled securely (don't pass full token in URL).",
            "Deep web",
            "Dark web",
            "Tor"
        ]
    },
    {
        "q": "QR Login Flow (e.g. WhatsApp)?",
        "type": "mcq",
        "o": [
            "Desktop shows QR (Socket ID). Mobile (Auth'd) scans it. Mobile sends Auth Token to Server for Desktop Socket ID.",
            "Magic",
            "Bluetooth",
            "NFC"
        ]
    },
    {
        "q": "Magic Link to Session?",
        "type": "mcq",
        "o": [
            "User clicks Email Link (One-Time Token). Server verifies, invalidates token, sets Session Cookie.",
            "Permanent link",
            "Public link",
            "Slow link"
        ]
    },
    {
        "q": "Check Session Iframe (OIDC)?",
        "type": "mcq",
        "o": [
            "Mechanism for RP (Client) to poll IdP for session status change using a hidden iframe and postMessage.",
            "Polling",
            "Sockets",
            "Push"
        ]
    },
    {
        "q": "Back-Forward Cache (bfcache) Risk?",
        "type": "mcq",
        "o": [
            "Browser caching rendered page state in RAM for fast navigation. Logged-out user hitting 'Back' might see sensitive data.",
            "Disk cache",
            "Server cache",
            "Proxy cache"
        ]
    },
    {
        "q": "Pageshow Persistence Check?",
        "type": "mcq",
        "o": [
            "JS event (event.persisted). Use to detect if page loaded from bfcache and force reload/auth check.",
            "Onload",
            "Onclick",
            "Onsubmit"
        ]
    },
    {
        "q": "Beacon API for Logout?",
        "type": "mcq",
        "o": [
            "navigator.sendBeacon(). Sends logout request asynchronously on unload. Reliable even if tab closes.",
            "XHR",
            "Fetch",
            "Socket"
        ]
    },
    {
        "q": "Fetch Keepalive?",
        "type": "mcq",
        "o": [
            "fetch(url, {keepalive: true}). Alternative to Beacon for reliable 'fire and forget' requests on page unload.",
            "Keep open",
            "Wait",
            "Sleep"
        ]
    },
    {
        "q": "Clear-Site-Data Header?",
        "type": "mcq",
        "o": [
            "Server response header that forces browser to wipe Cookies, Storage, Cache for the origin. (Logout Nuke).",
            "Delete-All",
            "Wipe-Disk",
            "Format-C"
        ]
    },
    {
        "q": "Clear-Site-Data: 'executionContexts'?",
        "type": "mcq",
        "o": [
            "Reloads the page (killing memory). Ensures sensitive data in JS variables is wiped from RAM.",
            "Kills browser",
            "Kills server",
            "No effect"
        ]
    },
    {
        "q": "Request-ID Header?",
        "type": "mcq",
        "o": [
            "Unique ID generated by Load Balancer/Proxy (e.g. X-Request-ID). Helps trace a specific user request through logs.",
            "User ID",
            "Session ID",
            "App ID"
        ]
    },
    {
        "q": "Proxy Protocol (IP Preservation)?",
        "type": "mcq",
        "o": [
            "Protocol to pass Client IP info from LB to Backend (TCP level) so Session logs show real IP, not LB IP.",
            "HTTP header",
            "Cookie",
            "Body"
        ]
    },
    {
        "q": "Trusted Proxy Config?",
        "type": "mcq",
        "o": [
            "Configuring Web Server to ONLY trust X-Forwarded-For headers from known internal LBs. (Prevent spoofing)",
            "Trust all",
            "Trust none",
            "Trust users"
        ]
    },
    {
        "q": "PHP session.gc_maxlifetime?",
        "type": "mcq",
        "o": [
            "Setting controlling how many seconds session data stays on server before Garbage Collection candidates it.",
            "Cookie life",
            "Token life",
            "Request life"
        ]
    },
    {
        "q": "ASP.NET Cookieless Session?",
        "type": "mcq",
        "o": [
            "Insecure legacy mode putting SessionID in URL path. Easier to hijack/fixate. Avoid.",
            "Secure",
            "New",
            "Recommended"
        ]
    },
    {
        "q": "XS-Leaks (Cross-Site Leaks)?",
        "type": "mcq",
        "o": [
            "Side-channel attacks (timing, frame count) allowing an attacker to guess if victim is logged in to a site.",
            "XSS",
            "CSRF",
            "SQLi"
        ]
    },
    {
        "q": "COOP (Cross-Origin Opener Policy)?",
        "type": "mcq",
        "o": [
            "Security header isolating the browsing context. Prevents attackers opening your site in a window and accessing its object.",
            "CORS",
            "CSP",
            "HSTS"
        ]
    },
    {
        "q": "Spectre Mitigation & Sessions?",
        "type": "mcq",
        "o": [
            "Site Isolation (COOP+COEP) prevents speculative execution attacks from reading Session memory across origins.",
            "Encryption",
            "Hashing",
            "Signing"
        ]
    },
    {
        "q": "Sec-Fetch-Dest Header?",
        "type": "mcq",
        "o": [
            "Browser sends this to tell Server the destination (document, image, iframe). Helps Server block misuse.",
            "Server header",
            "Cookie",
            "Auth"
        ]
    },
    {
        "q": "Testing Session Fixation?",
        "type": "mcq",
        "o": [
            "Get a Session ID (as attacker), send link with that ID to victim, see if victim inherits it after login.",
            "Check length",
            "Check entropy",
            "Check time"
        ]
    },
    {
        "q": "Testing Concurrent Logic (Turbo Intruder)?",
        "type": "mcq",
        "o": [
            "Sending parallel requests to test Race Conditions (e.g. using 'One-Time' token twice).",
            "Slow requests",
            "One request",
            "Manual"
        ]
    },
    {
        "q": "BOLA (Broken Object Level Auth)?",
        "type": "mcq",
        "o": [
            "IDOR. Attacker changes ID in URL/API (user/123 -> user/456) and Server fails to check Session ownership.",
            "XSS",
            "CSRF",
            "RCE"
        ]
    },
    {
        "q": "Mocking Sessions in Tests?",
        "type": "mcq",
        "o": [
            "Injecting a fake session/cookie directly into the test client (bypass login UI) for speed.",
            "Using real UI",
            "Manual login",
            "Skip tests"
        ]
    },
    {
        "q": "Stateless CSRF Token?",
        "type": "mcq",
        "o": [
            "Encrypted Token (containing UserID + Timestamp) stored in Cookie. Server decrypts to verify. No DB state.",
            "Stateful",
            "Random string",
            "UUID"
        ]
    },
    {
        "q": "SameSite=None Bug (iOS 12)?",
        "type": "mcq",
        "o": [
            "Old WebKit treated 'SameSite=None' as 'SameSite=Strict' (blocking all cookies). Fix: User-Agent sniffing.",
            "No bug",
            "Feature",
            "Ignore"
        ]
    },
    {
        "q": "Cookie-Free Domains?",
        "type": "mcq",
        "o": [
            "Serving static assets (images/css) from a separate domain (static.site.com) so Browser doesn't send 4KB cookies on every image req.",
            "Security",
            "Complexity",
            "SEO"
        ]
    },
    {
        "q": "Service Worker Cache vs Session?",
        "type": "mcq",
        "o": [
            "SW caches Responses. Be careful caching HTML with sensitive Session data (e.g. 'Hello User'). Prefer App Shell + API.",
            "Same",
            "Cache is safe",
            "Session is safe"
        ]
    },
    {
        "q": "Web OTP API?",
        "type": "mcq",
        "o": [
            "JS API to programmatically read OTP from SMS (if formatted correctly) to streamline session verification.",
            "Read email",
            "Read file",
            "Read screen"
        ]
    },
    {
        "q": "Credential Management API?",
        "type": "mcq",
        "o": [
            "Browser API to store/retrieve credentials (password/federated). Enables 'Tap to Login'.",
            "Password manager",
            "File saver",
            "Log saver"
        ]
    },
    {
        "q": "Continuous Authentication?",
        "type": "mcq",
        "o": [
            "Constantly verifying user identity during session (via biometrics, behavior) not just at Login.",
            "One time",
            "Login only",
            "Never"
        ]
    },
    {
        "q": "Step-up Authentication?",
        "type": "mcq",
        "o": [
            "Triggering MFA only when accessing High-Value resources (e.g. Payments) within an existing session.",
            "Login again",
            "Logout",
            "Block"
        ]
    },
    {
        "q": "WebAuthn assertion signature?",
        "type": "mcq",
        "o": [
            "Private key signs the challenge during authentication. Server verifies with Public Key stored during registration.",
            "Hash",
            "Encrypt",
            "Compress"
        ]
    },
    {
        "q": "Behavioral Biometrics?",
        "type": "mcq",
        "o": [
            "Analyzing mouse movements, typing rhythm, touch pressure to detect if Session was hijacked by a different human/bot.",
            "Fingerprint",
            "Face ID",
            "Voice"
        ]
    },
    {
        "q": "Does 'Keep-Alive' header affect Session?",
        "type": "mcq",
        "o": [
            "No. Keep-Alive is for TCP connection reuse. Session is App level.",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Can you share Sessions between Subdomains?",
        "type": "mcq",
        "o": [
            "Yes, by setting Cookie Domain to '.example.com'. All subdomains (app.example.com, api.example.com) receive it.",
            "No",
            "Never",
            "Only with hacks"
        ]
    },
    {
        "q": "Risk of sharing Session across Subdomains?",
        "type": "mcq",
        "o": [
            "If one subdomain is compromised (XSS), the session cookie is stolen, affecting the main domain and all other subdomains.",
            "No risk",
            "Low risk",
            "High speed"
        ]
    },
    {
        "q": "Authorization Code Flow (OAuth) Session?",
        "type": "mcq",
        "o": [
            "Best for Web Apps. Code exchanged on back-channel. Tokens kept on Server. Browser gets Session Cookie.",
            "Implicit flow",
            "Password flow",
            "Client creds"
        ]
    },
    {
        "q": "Implicit Flow (OAuth) Session?",
        "type": "mcq",
        "o": [
            "Deprecated. Tokens returned in URL fragment. Vulnerable to leakage/access history. Don't use for sessions.",
            "Secure",
            "Best",
            "Fast"
        ]
    },
    {
        "q": "What is 'Session Suspension'?",
        "type": "mcq",
        "o": [
            "Temporarily disabling a session (e.g. for fraud investigation) without deleting it.",
            "Deleting",
            "Logging",
            "Creating"
        ]
    },
    {
        "q": "What is 'Force Password Change'?",
        "type": "mcq",
        "o": [
            "Flagging session/user so next request redirects to Password Change form. Block other access.",
            "Deleting account",
            "Banning IP",
            "Ignoring"
        ]
    },
    {
        "q": "Session Identifier vs Transaction Identifier?",
        "type": "mcq",
        "o": [
            "Session ID identifies the User Context. Transaction ID identifies a specific Action/Payment.",
            "Same",
            "Reversed",
            "None"
        ]
    },
    {
        "q": "Does 'Private Tab' hide IP?",
        "type": "mcq",
        "o": [
            "NO. It prevents local storage (history/cookies). Your IP is still visible to the Server/ISP.",
            "Yes",
            "Maybe",
            "Mostly"
        ]
    },
    {
        "q": "Correlation of Logs?",
        "type": "mcq",
        "o": [
            "Using Session ID (hashed) to link Web Logs, App Logs, and DB Logs for debugging user issues.",
            "Using IP",
            "Using Time",
            "Using Random"
        ]
    },
    {
        "q": "What is 'Session Riding'?",
        "type": "mcq",
        "o": [
            "Another name for CSRF. The attacker 'rides' the active session to perform actions.",
            "XSS",
            "SQLi",
            "Phishing"
        ]
    },
    {
        "q": "Is 'Referer' header sent on HTTPS -> HTTP downgrade?",
        "type": "mcq",
        "o": [
            "No. Browsers strip Referer to prevent leaking secure URL info to insecure sites.",
            "Yes",
            "Always",
            "Sometimes"
        ]
    },
    {
        "q": "Is 'Referer' header sent on HTTP -> HTTPS upgrade?",
        "type": "mcq",
        "o": [
            "Yes, usually sent (unless Referrer-Policy restriction applied).",
            "No",
            "Never",
            "Blocked"
        ]
    },
    {
        "q": "Referrer-Policy: 'strict-origin-when-cross-origin'?",
        "type": "mcq",
        "o": [
            "Default in modern browsers. Sends full URL same-origin, only Origin (domain) cross-origin. None on downgrade.",
            "No referer",
            "Full referer",
            "Unsafe"
        ]
    },
    {
        "q": "How to debug Session issues?",
        "type": "mcq",
        "o": [
            "Check Browser Cookies (DevTools), Check Server Logs, Verify Time (Clock Skew), Check Proxy/LB headers.",
            "Guessing",
            "Rebooting",
            "Coding"
        ]
    },
    {
        "q": "Why clock synchronization (NTP) matters?",
        "type": "mcq",
        "o": [
            "If Server clock is wrong, Cookies might be set as 'Already Expired' or 'Future', causing login loops.",
            "Speed",
            "Logging",
            "Sorting"
        ]
    },
    {
        "q": "Session Cookie 'Domain' dot prefix (.example.com)?",
        "type": "mcq",
        "o": [
            "Legacy requirement (RFC 2109). Modern browsers ignore leading dot, but treat it as including subdomains involved.",
            "Required",
            "Forbidden",
            "Standard"
        ]
    },
    {
        "q": "Maximum Cookie Size (per cookie)?",
        "type": "mcq",
        "o": [
            "4096 bytes (4KB). Includes name, value, and attributes.",
            "1MB",
            "10KB",
            "100 bytes"
        ]
    },
    {
        "q": "Maximum number of Cookies per domain?",
        "type": "mcq",
        "o": [
            "Varies (Chrome ~180). Exceeding it evicts old cookies.",
            "Unlimited",
            "20",
            "5"
        ]
    },
    {
        "q": "Can LocalStorage share data across subdomains?",
        "type": "mcq",
        "o": [
            "NO. LocalStorage is Same-Origin only (protocol + domain + port). app.site.com cannot read site.com.",
            "Yes",
            "Maybe",
            "Easily"
        ]
    },
    {
        "q": "Cross-Domain LocalStorage sharing?",
        "type": "mcq",
        "o": [
            "Requires postMessage communication between iframes hosted on each domain.",
            "Direct access",
            "Cookies",
            "Headers"
        ]
    },
    {
        "q": "IndexedDB scope?",
        "type": "mcq",
        "o": [
            "Same-Origin Policy applies. Large storage (hundreds of MB).",
            "Global",
            "Public",
            "Session"
        ]
    },
    {
        "q": "What is 'Session Data Residency'?",
        "type": "mcq",
        "o": [
            "Legal requirement to store Session Data (PII) in a specific country (GDPR, Russia, China).",
            "Resident Evil",
            "Housing",
            "Local"
        ]
    },
    {
        "q": "Hardcoded Bearer Token in code?",
        "type": "mcq",
        "o": [
            "Security vulnerability. Tokens expire, so code breaks. Tokens grant access, so leak is critical.",
            "Convenient",
            "Fast",
            "Standard"
        ]
    },
    {
        "q": "Can you revoke a specific JWT?",
        "type": "mcq",
        "o": [
            "Not easily without state. 'Blacklist' (stateful) or 'Short Expiry' are mitigations.",
            "Yes instantly",
            "Delete file",
            "Remote kill"
        ]
    },
    {
        "q": "Revoking a Reference Token?",
        "type": "mcq",
        "o": [
            "Easy. Delete the token mapping in the database. Next validation fails.",
            "Impossible",
            "Wait for expiry",
            "Hard"
        ]
    },
    {
        "q": "Choosing Session Store: Redis vs DB?",
        "type": "mcq",
        "o": [
            "Redis: Low latency, TTL support (auto-expiry). DB: Persistence, Relational queries. Redis preferred for high-traffic sessions.",
            "File",
            "Memory",
            "Log"
        ]
    },
    {
        "q": "Session Store: DynamoDB?",
        "type": "mcq",
        "o": [
            "Highly scalable, TTL support. Good serverless option.",
            "Slow",
            "Complex",
            "Legacy"
        ]
    },
    {
        "q": "Session Store: Postgres?",
        "type": "mcq",
        "o": [
            "Robust. Use UNLOGGED tables for speed? Clean up with cron. Good if you want strict consistency.",
            "Bad",
            "Slow",
            "No TTL"
        ]
    },
    {
        "q": "What is 'Session Concurrency'?",
        "type": "mcq",
        "o": [
            "Handling multiple requests from same session simultaneously. Frameworks may lock session (serialize) to prevent data corruption.",
            "Parallel users",
            "Fast login",
            "Async"
        ]
    },
    {
        "q": "Session 'Read-Only' Mode?",
        "type": "mcq",
        "o": [
            "Optimization: If request doesn't modify session, don't lock it. Allows parallel requests for same user (e.g. AJAX dashboards).",
            "Write only",
            "Locked",
            "Blocked"
        ]
    },
    {
        "q": "Where to store 'IsAuthenticated' state on Client?",
        "type": "mcq",
        "o": [
            "In Application State (Redux/Context). Initialized by check against Server (Example: /me endpoint).",
            "In variable",
            "In html",
            "In url"
        ]
    },
    {
        "q": "Session Management Summary?",
        "type": "mcq",
        "o": [
            "Balance between Security (Timeout, HttpOnly) and UX (Remember Me, SSO). Validating ID is trust anchor.",
            "Always easy",
            "Always hard",
            "Ignore it"
        ]
    },
    {
        "q": "Final Session Rule?",
        "type": "mcq",
        "o": [
            "Never trust the Client. Always validate Session ID on Server. Enforce HTTPS.",
            "Trust client",
            "HTTP ok",
            "No validation"
        ]
    },
    {
        "q": "Session ID Definition?",
        "type": "mcq",
        "o": [
            "A unique token/string identifying a specific user's interaction with the server during a time window.",
            "User password",
            "User email",
            "Server key"
        ]
    },
    {
        "q": "Where to store Session ID safely?",
        "type": "mcq",
        "o": [
            "HttpOnly, Secure, SameSite Cookie. Inaccessible to JS (XSS protected).",
            "LocalStorage",
            "SessionStorage",
            "URL"
        ]
    },
    {
        "q": "Why is LocalStorage unsafe for Session ID?",
        "type": "mcq",
        "o": [
            "Accessible by ANY JavaScript on the page. Vulnerable to XSS (Cross-Site Scripting).",
            "Too small",
            "Too slow",
            "Not persistent"
        ]
    },
    {
        "q": "HttpOnly Flag?",
        "type": "mcq",
        "o": [
            "Prevents client-side scripts (document.cookie) from accessing the cookie. Mitigates XSS token theft.",
            "Encrypts cookie",
            "Hides cookie",
            "Deletes cookie"
        ]
    },
    {
        "q": "Secure Flag?",
        "type": "mcq",
        "o": [
            "Ensures cookie is sent ONLY over HTTPS. Prevents leakage over unencrypted HTTP.",
            "Passwords",
            "Login",
            "Server"
        ]
    },
    {
        "q": "SameSite=Strict?",
        "type": "mcq",
        "o": [
            "Cookie NOT sent on cross-site requests (even top-level navigations). Max CSRF protection. UX impact (links from email require login).",
            "Lax",
            "None",
            "All"
        ]
    },
    {
        "q": "SameSite=Lax?",
        "type": "mcq",
        "o": [
            "Cookie sent on Top-Level Navigations (clicking link) but NOT on subresources (images/frames). Good balance of Security/UX. Default in modern browsers.",
            "Strict",
            "None",
            "Open"
        ]
    },
    {
        "q": "SameSite=None?",
        "type": "mcq",
        "o": [
            "Cookie sent on ALL cross-site requests (e.g. iframes, images). MUST be paired with Secure flag. Third-party context.",
            "Strict",
            "Lax",
            "Block"
        ]
    },
    {
        "q": "Session Fixation Attack?",
        "type": "mcq",
        "o": [
            "Attacker sets a valid Session ID for the victim (e.g. in URL/Cookie). Victim logs in. Attacker uses the known ID to hijack session.",
            "Hijacking",
            "Bruting",
            "Phishing"
        ]
    },
    {
        "q": "Mitigation for Session Fixation?",
        "type": "mcq",
        "o": [
            "Regenerate Session ID upon successful login (and privilege escalation). Old ID becomes invalid.",
            "Use GET",
            "Use header",
            "Short timeout"
        ]
    },
    {
        "q": "Session Hijacking (Sidejacking)?",
        "type": "mcq",
        "o": [
            "Attacker sniffs network (WiFi) to steal valid Session Cookie. Prevented by HTTPS.",
            "Fixation",
            "SQLi",
            "CSRF"
        ]
    },
    {
        "q": "Absolute Timeout?",
        "type": "mcq",
        "o": [
            "Session kills itself after fixed time (e.g. 8 hours) regardless of activity. Limits window of compromise.",
            "Idle timeout",
            "No timeout",
            "Forever"
        ]
    },
    {
        "q": "Idle Timeout?",
        "type": "mcq",
        "o": [
            "Session expires after X minutes of INACTIVITY. User action resets timer.",
            "Absolute",
            "Fixed",
            "Login time"
        ]
    },
    {
        "q": "Concurrent Session Control?",
        "type": "mcq",
        "o": [
            "Limiting user to X active sessions (e.g. 1). prevent account sharing/multiple logins. 'Kick out' old session on new login.",
            "Unlimited",
            "No limit",
            "Sharing ok"
        ]
    },
    {
        "q": "CSPRNG?",
        "type": "mcq",
        "o": [
            "Cryptographically Secure Pseudo-Random Number Generator. Examples: /dev/urandom, SecureRandom. ESSENTIAL for Session IDs.",
            "Math.random()",
            "Time()",
            "Rand()"
        ]
    },
    {
        "q": "Why Math.random() is bad for Session ID?",
        "type": "mcq",
        "o": [
            "Predictable. Attacker can guess future/past IDs if they know the seed or sequence.",
            "Too slow",
            "Too random",
            "Too huge"
        ]
    },
    {
        "q": "Session Entropy?",
        "type": "mcq",
        "o": [
            "Total randomness in the ID. Higher is better. 128-bit entropy recommended to prevent Brute Force guessing.",
            "Low entropy",
            "Zero",
            "Negative"
        ]
    },
    {
        "q": "Session Storage: In-Memory?",
        "type": "mcq",
        "o": [
            "Fastest. Lost on server restart. Not scalable (Sticky Sessions needed). Good for dev/small apps.",
            "Redis",
            "DB",
            "File"
        ]
    },
    {
        "q": "Session Storage: Redis/Memcached?",
        "type": "mcq",
        "o": [
            "Distributed In-Memory Cache. Scalable. Fast. Persists across server restarts. Best for production attributes.",
            "Local RAM",
            "Cookie",
            "Header"
        ]
    },
    {
        "q": "Session Storage: Database (SQL)?",
        "type": "mcq",
        "o": [
            "Persistent. Slower than Redis. Good for auditing or if Redis not available. High IO ops.",
            "Fastest",
            "Transient",
            "Volatile"
        ]
    },
    {
        "q": "Client-Side Session (Stateless)?",
        "type": "mcq",
        "o": [
            "Storing ALL session data (Claims) in the client (JWT/Encrypted Cookie). No server state. Hard to revoke.",
            "Server-side",
            "Stateful",
            "DB backed"
        ]
    },
    {
        "q": "Server-Side Session (Stateful)?",
        "type": "mcq",
        "o": [
            "Storing ID in client, Data on Server. Easy to revoke. Single source of truth. Larger overhead.",
            "Client-side",
            "Stateless",
            "JWT"
        ]
    },
    {
        "q": "Cookie Size Limit?",
        "type": "mcq",
        "o": [
            "Typically 4KB per domain. Large JWTs might exceed this (Split cookies needed?).",
            "Unlimited",
            "1MB",
            "20 bytes"
        ]
    },
    {
        "q": "Sticky Sessions (Session Affinity)?",
        "type": "mcq",
        "o": [
            "Load Balancer routes user to SAME server instance every time. Required for In-Memory sessions. Bad for auto-scaling.",
            "Round robin",
            "Random",
            "Stateless"
        ]
    },
    {
        "q": "Cross-Site Request Forgery (CSRF)?",
        "type": "mcq",
        "o": [
            "Attacker tricks user's browser into executing unwanted action (POST) on trusted site where user is logged in (Cookies sent auto).",
            "XSS",
            "SQLi",
            "RCE"
        ]
    },
    {
        "q": "CSRF Mitigation: Anti-CSRF Token?",
        "type": "mcq",
        "o": [
            "Random unique token (Synchronizer Token) in Form/Header. Attacker can't guess it. Browser SOP prevents reading it.",
            "Cookie",
            "Referer",
            "None"
        ]
    },
    {
        "q": "CSRF Mitigation: SameSite Cookie?",
        "type": "mcq",
        "o": [
            "Setting SameSite=Strict/Lax prevents Cookie sending on cross-origin POSTs. browser-level defense.",
            "Secure",
            "HttpOnly",
            "Domain"
        ]
    },
    {
        "q": "Double Submit Cookie?",
        "type": "mcq",
        "o": [
            "CSRF Defense. Send random value in Cookie AND Request Body. Server checks match. Stateless.",
            "Triple",
            "Single",
            "None"
        ]
    },
    {
        "q": "Origin Header Validation?",
        "type": "mcq",
        "o": [
            "Checking Origin/Referer headers on Server. Reject if not matching expected domain. Defense in Depth for CSRF.",
            "Accept all",
            "Ignore",
            "Log only"
        ]
    },
    {
        "q": "Logout implementation?",
        "type": "mcq",
        "o": [
            "Server: Invalidates Session ID. Client: Deletes Cookie. Both steps critical.",
            "Client only",
            "Server only",
            "Close tab"
        ]
    },
    {
        "q": "Race Condition in Session Refresh?",
        "type": "mcq",
        "o": [
            "Parallel requests during regeneration can cause one to fail auth if old ID invalidated instantly. Keep old valid for short grace period.",
            "Locking",
            "Blocking",
            "Delaying"
        ]
    },
    {
        "q": "Replay Attack (Session)?",
        "type": "mcq",
        "o": [
            "Attacker captures Token/Cookie and re-sends it. HTTPS + Secure Cookies prevent capture. Rotation prevents long-term use.",
            "Echo",
            "Delay",
            "Mirror"
        ]
    },
    {
        "q": "Session Puzzling?",
        "type": "mcq",
        "o": [
            "App uses same session variable for different purposes contextually. Attacker exploits to gain privilege.",
            "Puzzle game",
            "Context switch",
            "None"
        ]
    },
    {
        "q": "Session Donation?",
        "type": "mcq",
        "o": [
            "Attacker creates account, gives Session ID to victim. Victim uses it. Attacker spies on victim's actions.",
            "Fixation",
            "Gift",
            "Charity"
        ]
    },
    {
        "q": "URL Rewriting (jsessionid)?",
        "type": "mcq",
        "o": [
            "Putting Session ID in URL (path param). Bad practice. Leaks in Referer, history, logs. Disable it.",
            "Good",
            "Secure",
            "Standard"
        ]
    },
    {
        "q": "Cookie Prefix: __Host-?",
        "type": "mcq",
        "o": [
            "Prefix (__Host-Sess) forcing cookie to be Secure, Path=/, and Domain-less (Origin only). Higher security assurance.",
            "__Secure-",
            "__Auth-",
            "__Web-"
        ]
    },
    {
        "q": "Cookie Prefix: __Secure-?",
        "type": "mcq",
        "o": [
            "Prefix (__Secure-Sess) forcing cookie to have Secure flag set. Prevents HTTP overwriting.",
            "Host",
            "Auth",
            "None"
        ]
    },
    {
        "q": "Binding Session to IP?",
        "type": "mcq",
        "o": [
            "Security measure checking if Request IP matches Session creation IP. False positives with Mobile/Proxies.",
            "Always good",
            "Always bad",
            "Perfect"
        ]
    },
    {
        "q": "Binding Session to User-Agent?",
        "type": "mcq",
        "o": [
            "Checking Browser string. If it changes mid-session, flags potential hijack. Low friction risk.",
            "IP binding",
            "MAC binding",
            "DNS binding"
        ]
    },
    {
        "q": "What is a 'Zombie Cookie'?",
        "type": "mcq",
        "o": [
            "Cookie that recreates itself from other storage (Flash, ETag, LocalStorage) after deletion. Privacy Violation.",
            "Dead cookie",
            "Virus",
            "Malware"
        ]
    },
    {
        "q": "What is 'Supercookie'?",
        "type": "mcq",
        "o": [
            "Cookie set on Top-Level Domain (TLD) like .com or .co.uk. Blocked by browsers (Public Suffix List).",
            "Big cookie",
            "Admin cookie",
            "Root cookie"
        ]
    },
    {
        "q": "Public Suffix List?",
        "type": "mcq",
        "o": [
            "List of domains where users CANNOT set cookies (e.g. .com, .github.io). Prevents cross-site cookie tossing.",
            "Blacklist",
            "Whitelist",
            "DNS"
        ]
    },
    {
        "q": "Cookie Tossing?",
        "type": "mcq",
        "o": [
            "setting a malicious cookie for a parent domain (or sibling) to overwrite/confuse legitimate cookie.",
            "Throwing",
            "Deleting",
            "Eating"
        ]
    },
    {
        "q": "Cookie Path Attribute?",
        "type": "mcq",
        "o": [
            "Restricts cookie to subdirectory. Not a security boundary (iframes can access). Use for scope, not security.",
            "Security",
            "Isolation",
            "Firewall"
        ]
    },
    {
        "q": "Cookie Domain Attribute?",
        "type": "mcq",
        "o": [
            "Controls which domains receive cookie. If omitted (Host-Only), ONLY origin server gets it (Secure). If set, subdomains get it.",
            "Host only",
            "Public",
            "Global"
        ]
    },
    {
        "q": "Ephemeral vs Persistent Cookie?",
        "type": "mcq",
        "o": [
            "Ephemeral (Session): Deleted close browser. Persistent: Has 'Expires'/'Max-Age'. Survives restart.",
            "Same",
            "Transient",
            "Cached"
        ]
    },
    {
        "q": "Max-Age vs Expires?",
        "type": "mcq",
        "o": [
            "Max-Age (Seconds) is modern/preferred over Expires (Date). Solves clock skew issues.",
            "Same",
            "Expires is better",
            "None"
        ]
    },
    {
        "q": "Flash Cookie (LSO)?",
        "type": "mcq",
        "o": [
            "Legacy storage via Adobe Flash. Used for tracking/zombies. Obsolete.",
            "Fast cookie",
            "Bright cookie",
            "SSD"
        ]
    },
    {
        "q": "Evercookie?",
        "type": "mcq",
        "o": [
            "JS API aiming to produce extremely persistent cookies using every storage mechanism available. (Privacy risk).",
            "Nevercookie",
            "Shortcookie",
            "Session"
        ]
    },
    {
        "q": "Session prediction via Time?",
        "type": "mcq",
        "o": [
            "If ID based on timestamp, attacker can narrow search space significantly.",
            "Random",
            "Secure",
            "CSPRNG"
        ]
    },
    {
        "q": "Entropy calculation?",
        "type": "mcq",
        "o": [
            "Bits of uncertainty. 128 bits is standard. (Length * log2(Character Set size)).",
            "Length",
            "Size",
            "Count"
        ]
    },
    {
        "q": "Why 128 bit entropy?",
        "type": "mcq",
        "o": [
            "Makes brute force infeasible (billions of years).",
            "64 is enough",
            "32 is enough",
            "256 is slow"
        ]
    },
    {
        "q": "Authenticated Session Lifecycle?",
        "type": "mcq",
        "o": [
            "Login (Create) -> Active (Use) -> Idle/Timeout/Logout (Destroy).",
            "Create -> Destroy",
            "Forever",
            "Loop"
        ]
    },
    {
        "q": "Privilege Escalation during session?",
        "type": "mcq",
        "o": [
            "Should require re-authentication (sudo mode) to prevent unauthorized high-privilege actions.",
            "Auto grant",
            "Ignore",
            "Downgrade"
        ]
    },
    {
        "q": "Sudo Mode (GitHub style)?",
        "type": "mcq",
        "o": [
            "Asking for password again before sensitive action (WebAuthn/MFA better). Session gets 'sudo' flag for short time.",
            "Admin mode",
            "Root mode",
            "God mode"
        ]
    },
    {
        "q": "Ghost Session?",
        "type": "mcq",
        "o": [
            "Session that exists on Client (Cookie) but was deleted on Server (Redis flush). User gets 401/Login.",
            "Zombie",
            "Active",
            "Valid"
        ]
    },
    {
        "q": "Orphaned Session?",
        "type": "mcq",
        "o": [
            "Active on Server (takes RAM) but User deleted Cookie/Closed Browser. GC needed to clean up.",
            "Ghost",
            "Parent",
            "Child"
        ]
    },
    {
        "q": "Garbage Collection (Sessions)?",
        "type": "mcq",
        "o": [
            "Server process to delete expired sessions from storage to free up space.",
            "Recycling",
            "Hashing",
            "Sorting"
        ]
    },
    {
        "q": "Session ID Length?",
        "type": "mcq",
        "o": [
            "Should be long enough (e.g. 32+ chars hex) to ensure entropy and avoid collisions.",
            "Short",
            "4 chars",
            "8 chars"
        ]
    },
    {
        "q": "Collisions (Session ID)?",
        "type": "mcq",
        "o": [
            "Two users getting same ID. Disastrous (Account crossover). Probability must be negligible (use CSPRNG).",
            "Good",
            "Ok",
            "Feature"
        ]
    },
    {
        "q": "Environment variables for Session Secrets?",
        "type": "mcq",
        "o": [
            "Keys for signing/encrypting sessions MUST be stored in Env Vars/Secret Manager, NOT source code.",
            "Hardcoded",
            "Text file",
            "Public"
        ]
    },
    {
        "q": "Key Rotation (Session)?",
        "type": "mcq",
        "o": [
            "Rotated signing keys periodically. Support multiple keys (Current + Previous) to avoid logging out valid users.",
            "One key",
            "Delete all",
            "Static"
        ]
    },
    {
        "q": "Encrypted Cookie Pattern?",
        "type": "mcq",
        "o": [
            "Server encrypts session data (ID + Attributes) into cookie value. Client sees garbage. Stateless but secure.",
            "Plaintext",
            "Base64",
            "Hash"
        ]
    },
    {
        "q": "Signed Cookie Pattern?",
        "type": "mcq",
        "o": [
            "Cookie value is readable (Base64) but has HMAC signature. Client can read but not tamper.",
            "Encrypted",
            "Hidden",
            "Secret"
        ]
    },
    {
        "q": "Iron (Framework)?",
        "type": "mcq",
        "o": [
            "Node.js utility for sealing/unsealing JSON objects (Encrypted + Signed) used in sessions.",
            "Steel",
            "Gold",
            "Wood"
        ]
    },
    {
        "q": "Passport.js Session?",
        "type": "mcq",
        "o": [
            "Middleware for Node.js. Serializes User ID to Session. Deserializes on request (Database hit).",
            "Border",
            "Visa",
            "Travel"
        ]
    },
    {
        "q": "Express-Session?",
        "type": "mcq",
        "o": [
            "Popular Node.js session middleware. Stores ID in cookie, Data in Store (Memory/Redis).",
            "Fast session",
            "Slow session",
            "No session"
        ]
    },
    {
        "q": "Flask Session?",
        "type": "mcq",
        "o": [
            "By default, Client-Side Signed Cookie. Data stored in Cookie. limit 4KB.",
            "Server side",
            "File",
            "DB"
        ]
    },
    {
        "q": "Django Session?",
        "type": "mcq",
        "o": [
            "By default, Server-Side (DB backed). Cookie contains UUID Session ID.",
            "Client side",
            "Memory",
            "File"
        ]
    },
    {
        "q": "Spring Session?",
        "type": "mcq",
        "o": [
            "Java framework managing sessions independently of container (Tomcat). Supports Redis/JDBC clustering.",
            "Summer",
            "Winter",
            "Fall"
        ]
    },
    {
        "q": "Session Clustering?",
        "type": "mcq",
        "o": [
            "Replicating session data across multiple server nodes so users aren't logged out if one node fails.",
            "Isolation",
            "Single node",
            "Local"
        ]
    },
    {
        "q": "Sticky vs Clustered?",
        "type": "mcq",
        "o": [
            "Sticky: Pin user to node (Simple, Failover bad). Clustered: Replicate/Central Store (Complex, Failover good).",
            "Same",
            "Sticky better",
            "None"
        ]
    },
    {
        "q": "Session Drain?",
        "type": "mcq",
        "o": [
            "Allowing existing sessions to complete on a server before shutting it down (Graceful shutdown).",
            "Kill",
            "Delete",
            "Drop"
        ]
    },
    {
        "q": "JWT revocation: short expiry?",
        "type": "mcq",
        "o": [
            "Minimizes window of opportunity if stolen (~5 mins). Requires Refresh Token for UX.",
            "Long expiry",
            "No expiry",
            "1 year"
        ]
    },
    {
        "q": "Refresh Token vs Session Cookie?",
        "type": "mcq",
        "o": [
            "Refresh Token: Explicit re-auth flow. Cookie: Implicitly sent. Cookie easier for Web, Token for Mobile.",
            "Same",
            "Cookie for mobile",
            "Token for web"
        ]
    },
    {
        "q": "WebSockets Session?",
        "type": "mcq",
        "o": [
            "Initial Handshake sends Cookies/Headers. Connection stays open. Re-validate periodically or on messages.",
            "No auth",
            "Open",
            "One time"
        ]
    },
    {
        "q": "GraphQL Session?",
        "type": "mcq",
        "o": [
            "Usually context-based. Auth Middleware populates User in Context (from Header/Cookie). Resolvers check Context.",
            "Separate",
            "Internal",
            "None"
        ]
    },
    {
        "q": "Session Timeout vs UX?",
        "type": "mcq",
        "o": [
            "Short timeout = Secure but annoying. Long timeout = Convenient but risky. Balance based on App sensitivity.",
            "Always short",
            "Always long",
            "Ignore"
        ]
    },
    {
        "q": "Warning before Timeout?",
        "type": "mcq",
        "o": [
            "UX pattern: 'Session expiring in 2 mins. Continue?'. Prevents data loss on forms.",
            "Just logout",
            "Delete data",
            "Error"
        ]
    },
    {
        "q": "Heartbeat (Keep-alive) requests?",
        "type": "mcq",
        "o": [
            "Background pings to keep Idle timeout from triggering while tab is open. (Use carefully).",
            "Keep dead",
            "Kill",
            "Refresh"
        ]
    },
    {
        "q": "Captive Portal Detection?",
        "type": "mcq",
        "o": [
            "Wifi logins intercepting HTTPS can cause Session errors. Apps should handle this gracefully.",
            "Hacking",
            "Phishing",
            "Spoofing"
        ]
    },
    {
        "q": "Certificate Pinning Session impact?",
        "type": "mcq",
        "o": [
            "Prevents MitM. If Pin failure, Session shouldn't start (Connection dropped).",
            "None",
            "Allows MitM",
            "Slower"
        ]
    },
    {
        "q": "HSTS (Strict Transport Security) impact?",
        "type": "mcq",
        "o": [
            "Forces HTTPS. Protects Session Cookie from being sent over plain HTTP (stripping attacks).",
            "Forces HTTP",
            "None",
            "Block"
        ]
    },
    {
        "q": "CSP (Content Security Policy) impact?",
        "type": "mcq",
        "o": [
            "Mitigates XSS. Indirectly protects Session Tokens in LocalStorage (if used improperly).",
            "Mitigates SQLi",
            "Mitigates CSRF",
            "None"
        ]
    },
    {
        "q": "SRI (Subresource Integrity)?",
        "type": "mcq",
        "o": [
            "Ensures CDN scripts aren't tampered (backdoored) to steal Sessions.",
            "Speed",
            "Cache",
            "Size"
        ]
    },
    {
        "q": "Feature Policy / Permissions Policy?",
        "type": "mcq",
        "o": [
            "Controls browser features (mic, cam, usb). Reduces attack surface.",
            "Auth",
            "Login",
            "Session"
        ]
    },
    {
        "q": "Session Metadata?",
        "type": "mcq",
        "o": [
            "Information stored alongside ID: IP Address, User Agent, Created At, Last Active, Device Type. Used for Security Monitor.",
            "Data",
            "Content",
            "Files"
        ]
    },
    {
        "q": "What is 'Priority' in cookies used for?",
        "type": "mcq",
        "o": [
            "Influences retention policy when cookie jar is full (Low priority evicted first).",
            "Speed",
            "Security",
            "Color"
        ]
    },
    {
        "q": "What is 'Partitioned' attribute in cookies?",
        "type": "mcq",
        "o": [
            "Opt-in for CHIPS (Independent Partitioned State) used in cross-site iframes.",
            "Split",
            "Shared",
            "Global"
        ]
    },
    {
        "q": "Session fixation protection in Spring Security?",
        "type": "mcq",
        "o": [
            "Default: migrateSession (creates new session, copies attributes) or newSession (clean slate).",
            "None",
            "Weak",
            "Manual"
        ]
    },
    {
        "q": "Why is 'migrateSession' useful?",
        "type": "mcq",
        "o": [
            "Preserves pre-login data (Shopping Cart) while securing the ID against fixation.",
            "Copying",
            "Backup",
            "Restore"
        ]
    },
    {
        "q": "Tor 'New Circuit'?",
        "type": "mcq",
        "o": [
            "User requests new IP path. Session Cookies typically persist unless 'New Identity' (Restart) chosen.",
            "New Cookie",
            "New User",
            "New App"
        ]
    },
    {
        "q": "Session vs 'Remember Me' security?",
        "type": "mcq",
        "o": [
            "Remember Me token should be stronger/distinct. Compromise of Session = Current Access. Compromise of Remember Token = Persistent Access.",
            "Same",
            "Session stronger",
            "Remember weaker"
        ]
    },
    {
        "q": "Session Hijacking vs Session Spoofing?",
        "type": "mcq",
        "o": [
            "Hijacking = Stealing existing valid ID. Spoofing = Creating a new valid ID (needs key compromise or weak PRNG).",
            "Same",
            "Spoofing is theft",
            "Hijacking is creation"
        ]
    },
    {
        "q": "Session ID unpredictability?",
        "type": "mcq",
        "o": [
            "Must be resistant to brute force and prediction attacks. Use CSPRNG.",
            "Sequential",
            "Time based",
            "Name based"
        ]
    },
    {
        "q": "Session ID entropy requirement?",
        "type": "mcq",
        "o": [
            "At least 64 bits, preferably 128 bits of entropy to prevent brute-forcing.",
            "16 bits",
            "8 bits",
            "32 bits"
        ]
    },
    {
        "q": "Cookie 'Path' attribute scope?",
        "type": "mcq",
        "o": [
            "Determines which paths trigger cookie sending. Not a security boundary (leaks via frames/DOM).",
            "Security",
            "Firewall",
            "Block"
        ]
    },
    {
        "q": "Cookie 'Domain' attribute risk?",
        "type": "mcq",
        "o": [
            "Setting wide domain (example.com) allows all subdomains (even insecure dev ones) to read it.",
            "No risk",
            "Better",
            "Secure"
        ]
    },
    {
        "q": "SameSite=Strict vs Lax UX?",
        "type": "mcq",
        "o": [
            "Strict breaks links from external sites (users appear logged out). Lax allows top-level get (links work).",
            "Same",
            "Strict better ux",
            "Lax weaker"
        ]
    },
    {
        "q": "Session Termination types?",
        "type": "mcq",
        "o": [
            "Client-side (Clear cookie), Server-side (Delete record), Timeout (Expire).",
            "One way",
            "Delete only",
            "None"
        ]
    },
    {
        "q": "Why validate User-Agent?",
        "type": "mcq",
        "o": [
            "Drastic change in UA (e.g. Chrome to Firefox) mid-session indicates session theft.",
            "Tracking",
            "Ads",
            "Analytics"
        ]
    },
    {
        "q": "Why validate IP (with caution)?",
        "type": "mcq",
        "o": [
            "IP change might be legit (Mobile switch Cell/WiFi). Use Geo-IP change (Context) instead of strict match.",
            "Always strict",
            "Ban all",
            "Ignore"
        ]
    },
    {
        "q": "Session storage in URL?",
        "type": "mcq",
        "o": [
            "NEVER. Leaked in Referer, Proxy Logs, Browser History. (e.g. JSESSIONID in URL is bad).",
            "Good",
            "Fast",
            "Standard"
        ]
    },
    {
        "q": "Re-authentication (Sudo)?",
        "type": "mcq",
        "o": [
            "Require password verify before critical actions (Password change, Email change, Payment).",
            "Never",
            "Always",
            "Random"
        ]
    },
    {
        "q": "Session Management OWASP?",
        "type": "mcq",
        "o": [
            "Top critical area. Requires strong generation, secure transmission, secure storage, and proper destruction.",
            "Minor",
            "Easy",
            "Ignore"
        ]
    },
    {
        "q": "Session Loading State?",
        "type": "mcq",
        "o": [
            "UI state while validating session (Skeleton screens/Spinners). Critical for UX perception of speed.",
            "Blank",
            "Error",
            "Freeze"
        ]
    },
    {
        "q": "Optimistic UI for Session?",
        "type": "mcq",
        "o": [
            "Assume session valid, render content. If 401 occurs, redirect to login. Faster perceived load.",
            "Optimistic lock",
            "Always check",
            "Slow"
        ]
    },
    {
        "q": "Session vs Cache?",
        "type": "mcq",
        "o": [
            "Don't cache pages with User Session data (PII) on public CDNs. Use 'Cache-Control: private' or 'no-store'.",
            "Cache all",
            "Public cache",
            "Ignore"
        ]
    },
    {
        "q": "Vary Header (Cookie)?",
        "type": "mcq",
        "o": [
            "Tells caches that response varies based on Cookie. Prevents serving User A's page to User B.",
            "Vary IP",
            "Vary User",
            "None"
        ]
    },
    {
        "q": "Log: 'Session Created'?",
        "type": "mcq",
        "o": [
            "Event to log. Useful for tracking peak logins and detecting brute force campaigns.",
            "Ignore",
            "Delete",
            "Hide"
        ]
    },
    {
        "q": "Log: 'Session Failed'?",
        "type": "mcq",
        "o": [
            "Log invalid ID attempts. High volume = Session Scanning/Guessing attack.",
            "Ignore",
            "Debug",
            "Trace"
        ]
    },
    {
        "q": "Log: 'Session Expired'?",
        "type": "mcq",
        "o": [
            "Log natural expirations versus forced revocations. Analytics for session length tuning.",
            "Ignore",
            "Error",
            "Fatal"
        ]
    },
    {
        "q": "Audit Trail (Session)?",
        "type": "mcq",
        "o": [
            "Link every user action (Create, Update, Delete) to a Session ID and User ID.",
            "No logs",
            "Anon logs",
            "Random"
        ]
    },
    {
        "q": "Testing: Logout leads to?",
        "type": "mcq",
        "o": [
            "Login page. Session Cookie should be cleared/invalidated. Back button shouldn't show logged-in page.",
            "Home",
            "Dashboard",
            "Error"
        ]
    },
    {
        "q": "Testing: Parallel Sessions?",
        "type": "mcq",
        "o": [
            "Login in two browsers. If 'Max Sessions = 1', first should be invalidated or second rejected.",
            "Both work",
            "Sharing",
            "Sync"
        ]
    },
    {
        "q": "Testing: Timeout?",
        "type": "mcq",
        "o": [
            "Wait for X minutes. Action should trigger redirect to login/unlock screen.",
            "Keep working",
            "Crash",
            "Freeze"
        ]
    },
    {
        "q": "Testing: Invalid ID?",
        "type": "mcq",
        "o": [
            "Modify cookie to random string. Server should reject securely (Logout), not crash/expose stack trace.",
            "Accept",
            "Crash",
            "Log in"
        ]
    },
    {
        "q": "Session ID in Logs?",
        "type": "mcq",
        "o": [
            "Risk. Iflogs leaked, sessions hijacked. Mask/Hash Session ID in application logs.",
            "Cleartext",
            "Full",
            "Plain"
        ]
    },
    {
        "q": "Session ID in URL (Social Sharing)?",
        "type": "mcq",
        "o": [
            "User shares URL. If ID is in it, recipient gets logged in as user. Critical Vulnerability.",
            "Feature",
            "Good",
            "Easy"
        ]
    },
    {
        "q": "Why is 'Keep Me Logged In' risky?",
        "type": "mcq",
        "o": [
            "Sets persistent cookie. If device stolen/public computer, next user has access. Use mainly for private devices.",
            "Secure",
            "Safe",
            "Standard"
        ]
    },
    {
        "q": "Public Computer Hygiene?",
        "type": "mcq",
        "o": [
            "Always Logout. Clear Cookies. Don't save password. Incognito mode recommended.",
            "Close tab",
            "Minimize",
            "Leave"
        ]
    },
    {
        "q": "Session Hijacking via Cross-Site Scripting (XSS)?",
        "type": "mcq",
        "o": [
            "Most common vector. Script reads document.cookie and sends to attacker. HttpOnly prevents reading.",
            "SQLi",
            "CSRF",
            "RCE"
        ]
    },
    {
        "q": "Session Hijacking via Network Sniffing?",
        "type": "mcq",
        "o": [
            "Attacker on same WiFi reads HTTP packets. 'Secure' cookie flag + HTTPS prevents this.",
            "XSS",
            "Phishing",
            "Brute"
        ]
    },
    {
        "q": "Session Hijacking via Physical Access?",
        "type": "mcq",
        "o": [
            "Attacker walks up to unlocked computer. Copies cookie from DevTools. (Lock your screen!).",
            "Network",
            "Remote",
            "Cloud"
        ]
    },
    {
        "q": "Session ID Regeneration check?",
        "type": "mcq",
        "o": [
            "Verify ID changes after Login. Compare ID before submit and after/redirect. Must be different.",
            "Same ID",
            "Static",
            "Fixed"
        ]
    },
    {
        "q": "Session ID Length check?",
        "type": "mcq",
        "o": [
            "Verify length > 16 bytes (32 hex chars). Short IDs are guessable.",
            "Short",
            "4 bytes",
            "Numeric"
        ]
    },
    {
        "q": "Session ID Randomness check?",
        "type": "mcq",
        "o": [
            "Burp Sequencer / Statistical tests. Ensure no patterns/predictability.",
            "Visual check",
            "Guess",
            "None"
        ]
    },
    {
        "q": "Final Session Rule?",
        "type": "mcq",
        "o": [
            "Never trust the Client. Always validate Session ID on Server. Enforce HTTPS.",
            "Trust client",
            "HTTP ok",
            "No validation"
        ]
    }
]