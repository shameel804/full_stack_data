[
    {
        "q": "Django uses an ORM to interact with databases.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does ORM stand for?",
        "type": "mcq",
        "o": [
            "Object-Relational Mapping",
            "Object-Resource Management",
            "Ordered Record Model",
            "Online Resource Manager"
        ]
    },
    {
        "q": "Models are defined in the ______ file.",
        "type": "fill_blank",
        "answers": [
            "models.py"
        ],
        "other_options": [
            "views.py",
            "urls.py",
            "admin.py"
        ]
    },
    {
        "q": "Match ORM concepts with descriptions:",
        "type": "match",
        "left": [
            "Model",
            "Field",
            "QuerySet",
            "Manager"
        ],
        "right": [
            "Database table",
            "Table column",
            "Query results",
            "Query interface"
        ]
    },
    {
        "q": "Django models inherit from models.Model.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which base class do models inherit from?",
        "type": "mcq",
        "o": [
            "models.Model",
            "db.Model",
            "django.Model",
            "Model"
        ]
    },
    {
        "q": "Each model class represents a database ______.",
        "type": "fill_blank",
        "answers": [
            "table"
        ],
        "other_options": [
            "row",
            "column",
            "database"
        ]
    },
    {
        "q": "Rearrange model creation steps:",
        "type": "rearrange",
        "words": [
            "Define class",
            "Add fields",
            "Run migrations",
            "Use model"
        ]
    },
    {
        "q": "CharField stores short text strings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores short text?",
        "type": "mcq",
        "o": [
            "CharField",
            "TextField",
            "StringField",
            "VarCharField"
        ]
    },
    {
        "q": "CharField requires ______ argument.",
        "type": "fill_blank",
        "answers": [
            "max_length"
        ],
        "other_options": [
            "length",
            "size",
            "limit"
        ]
    },
    {
        "q": "Match field types with uses:",
        "type": "match",
        "left": [
            "CharField",
            "TextField",
            "IntegerField",
            "BooleanField"
        ],
        "right": [
            "Short text",
            "Long text",
            "Whole numbers",
            "True/False"
        ]
    },
    {
        "q": "IntegerField stores whole numbers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores decimal numbers?",
        "type": "mcq",
        "o": [
            "DecimalField",
            "IntegerField",
            "NumberField",
            "RealField"
        ]
    },
    {
        "q": "DecimalField requires max_digits and ______.",
        "type": "fill_blank",
        "answers": [
            "decimal_places"
        ],
        "other_options": [
            "precision",
            "scale",
            "decimals"
        ]
    },
    {
        "q": "Rearrange numeric field types:",
        "type": "rearrange",
        "words": [
            "IntegerField",
            "FloatField",
            "DecimalField"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Product(models.Model):\n    price = models.DecimalField(max_digits=10, decimal_places=2)",
        "o": [
            "Model with decimal price field",
            "Error",
            "Model with integer field",
            "Nothing"
        ]
    },
    {
        "q": "DateField stores date values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores date and time?",
        "type": "mcq",
        "o": [
            "DateTimeField",
            "DateField",
            "TimeField",
            "TimestampField"
        ]
    },
    {
        "q": "auto_now updates date on every ______.",
        "type": "fill_blank",
        "answers": [
            "save"
        ],
        "other_options": [
            "create",
            "delete",
            "read"
        ]
    },
    {
        "q": "Match date field options:",
        "type": "match",
        "left": [
            "auto_now",
            "auto_now_add",
            "default",
            "null"
        ],
        "right": [
            "Update on save",
            "Set on create",
            "Default value",
            "Allow null"
        ]
    },
    {
        "q": "auto_now_add sets date on creation only.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates automatic timestamps?",
        "type": "mcq",
        "o": [
            "auto_now and auto_now_add",
            "timestamp=True",
            "auto=True",
            "created_at field"
        ]
    },
    {
        "q": "TimeField stores ______ values.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "date",
            "datetime",
            "duration"
        ]
    },
    {
        "q": "Rearrange date/time fields:",
        "type": "rearrange",
        "words": [
            "DateField",
            "TimeField",
            "DateTimeField",
            "DurationField"
        ]
    },
    {
        "q": "BooleanField stores True or False.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores boolean values?",
        "type": "mcq",
        "o": [
            "BooleanField",
            "TrueFalseField",
            "BitField",
            "FlagField"
        ]
    },
    {
        "q": "NullBooleanField allows ______.",
        "type": "fill_blank",
        "answers": [
            "null",
            "None"
        ],
        "other_options": [
            "empty",
            "zero",
            "blank"
        ]
    },
    {
        "q": "Match boolean options:",
        "type": "match",
        "left": [
            "True",
            "False",
            "None",
            "default"
        ],
        "right": [
            "Positive",
            "Negative",
            "Unknown",
            "Initial value"
        ]
    },
    {
        "q": "EmailField validates email format.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field validates email addresses?",
        "type": "mcq",
        "o": [
            "EmailField",
            "CharField",
            "MailField",
            "AddressField"
        ]
    },
    {
        "q": "URLField validates ______ format.",
        "type": "fill_blank",
        "answers": [
            "URL"
        ],
        "other_options": [
            "email",
            "phone",
            "text"
        ]
    },
    {
        "q": "Rearrange specialized text fields:",
        "type": "rearrange",
        "words": [
            "EmailField",
            "URLField",
            "SlugField",
            "UUIDField"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class User(models.Model):\n    email = models.EmailField(unique=True)",
        "o": [
            "Model with unique email field",
            "Error",
            "Model with required email",
            "Nothing"
        ]
    },
    {
        "q": "SlugField stores URL-safe strings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field is for URL slugs?",
        "type": "mcq",
        "o": [
            "SlugField",
            "URLField",
            "CharField",
            "PathField"
        ]
    },
    {
        "q": "SlugField allows letters, numbers, and ______.",
        "type": "fill_blank",
        "answers": [
            "hyphens",
            "underscores"
        ],
        "other_options": [
            "spaces",
            "periods",
            "slashes"
        ]
    },
    {
        "q": "Match field validation types:",
        "type": "match",
        "left": [
            "EmailField",
            "URLField",
            "SlugField",
            "IPAddressField"
        ],
        "right": [
            "Email format",
            "URL format",
            "Slug format",
            "IP format"
        ]
    },
    {
        "q": "FileField stores uploaded files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field handles file uploads?",
        "type": "mcq",
        "o": [
            "FileField",
            "BinaryField",
            "UploadField",
            "DataField"
        ]
    },
    {
        "q": "upload_to specifies file ______.",
        "type": "fill_blank",
        "answers": [
            "directory",
            "path"
        ],
        "other_options": [
            "name",
            "size",
            "type"
        ]
    },
    {
        "q": "Rearrange file field setup:",
        "type": "rearrange",
        "words": [
            "Define FileField",
            "Set upload_to",
            "Configure MEDIA_ROOT",
            "Handle uploads"
        ]
    },
    {
        "q": "ImageField validates image files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field is for image uploads?",
        "type": "mcq",
        "o": [
            "ImageField",
            "FileField",
            "PictureField",
            "PhotoField"
        ]
    },
    {
        "q": "ImageField requires ______ library.",
        "type": "fill_blank",
        "answers": [
            "Pillow"
        ],
        "other_options": [
            "PIL",
            "imaging",
            "opencv"
        ]
    },
    {
        "q": "Match file field attributes:",
        "type": "match",
        "left": [
            "url",
            "path",
            "name",
            "size"
        ],
        "right": [
            "Web URL",
            "File path",
            "Filename",
            "Bytes"
        ]
    },
    {
        "q": "ForeignKey creates many-to-one relationships.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field creates many-to-one relation?",
        "type": "mcq",
        "o": [
            "ForeignKey",
            "OneToMany",
            "ManyToOne",
            "RelatedField"
        ]
    },
    {
        "q": "ForeignKey requires on_delete ______.",
        "type": "fill_blank",
        "answers": [
            "argument"
        ],
        "other_options": [
            "method",
            "value",
            "setting"
        ]
    },
    {
        "q": "Rearrange relationship types:",
        "type": "rearrange",
        "words": [
            "ForeignKey",
            "OneToOneField",
            "ManyToManyField"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Comment(models.Model):\n    post = models.ForeignKey(Post, on_delete=models.CASCADE)",
        "o": [
            "Comment linked to Post",
            "Error",
            "Post linked to Comment",
            "Nothing"
        ]
    },
    {
        "q": "CASCADE deletes related objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which on_delete option deletes related?",
        "type": "mcq",
        "o": [
            "CASCADE",
            "PROTECT",
            "SET_NULL",
            "DO_NOTHING"
        ]
    },
    {
        "q": "PROTECT prevents ______.",
        "type": "fill_blank",
        "answers": [
            "deletion"
        ],
        "other_options": [
            "creation",
            "update",
            "read"
        ]
    },
    {
        "q": "Match on_delete options:",
        "type": "match",
        "left": [
            "CASCADE",
            "PROTECT",
            "SET_NULL",
            "SET_DEFAULT"
        ],
        "right": [
            "Delete related",
            "Block deletion",
            "Set to null",
            "Set default"
        ]
    },
    {
        "q": "SET_NULL requires null=True.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which requires null=True on field?",
        "type": "mcq",
        "o": [
            "SET_NULL",
            "CASCADE",
            "PROTECT",
            "DO_NOTHING"
        ]
    },
    {
        "q": "DO_NOTHING takes no ______.",
        "type": "fill_blank",
        "answers": [
            "action"
        ],
        "other_options": [
            "value",
            "time",
            "space"
        ]
    },
    {
        "q": "Rearrange on_delete behavior:",
        "type": "rearrange",
        "words": [
            "CASCADE",
            "SET_NULL",
            "PROTECT",
            "DO_NOTHING"
        ]
    },
    {
        "q": "OneToOneField creates one-to-one relationship.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field creates one-to-one relation?",
        "type": "mcq",
        "o": [
            "OneToOneField",
            "ForeignKey(unique=True)",
            "SingleField",
            "UniqueFK"
        ]
    },
    {
        "q": "OneToOneField is like ForeignKey with ______.",
        "type": "fill_blank",
        "answers": [
            "unique=True"
        ],
        "other_options": [
            "primary_key=True",
            "single=True",
            "one=True"
        ]
    },
    {
        "q": "Match relationship fields:",
        "type": "match",
        "left": [
            "ForeignKey",
            "OneToOneField",
            "ManyToManyField",
            "GenericForeignKey"
        ],
        "right": [
            "Many-to-one",
            "One-to-one",
            "Many-to-many",
            "Generic relation"
        ]
    },
    {
        "q": "ManyToManyField creates junction table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field creates many-to-many relation?",
        "type": "mcq",
        "o": [
            "ManyToManyField",
            "M2MField",
            "MultiField",
            "JunctionField"
        ]
    },
    {
        "q": "ManyToManyField creates ______ table.",
        "type": "fill_blank",
        "answers": [
            "intermediate",
            "junction"
        ],
        "other_options": [
            "foreign",
            "primary",
            "index"
        ]
    },
    {
        "q": "Rearrange model relationship setup:",
        "type": "rearrange",
        "words": [
            "Define models",
            "Add relationship field",
            "Run migrations",
            "Access related objects"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Article(models.Model):\n    tags = models.ManyToManyField(Tag)",
        "o": [
            "Article with multiple tags",
            "Error",
            "Tag with multiple articles",
            "Nothing"
        ]
    },
    {
        "q": "related_name customizes reverse relations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which option sets reverse accessor name?",
        "type": "mcq",
        "o": [
            "related_name",
            "reverse_name",
            "accessor_name",
            "back_name"
        ]
    },
    {
        "q": "related_name allows ______ access.",
        "type": "fill_blank",
        "answers": [
            "reverse"
        ],
        "other_options": [
            "forward",
            "direct",
            "primary"
        ]
    },
    {
        "q": "Match relationship options:",
        "type": "match",
        "left": [
            "related_name",
            "related_query_name",
            "limit_choices_to",
            "through"
        ],
        "right": [
            "Reverse accessor",
            "Filter name",
            "Limit options",
            "Custom junction"
        ]
    },
    {
        "q": "through specifies custom junction model.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which option uses custom intermediate?",
        "type": "mcq",
        "o": [
            "through",
            "via",
            "using",
            "junction"
        ]
    },
    {
        "q": "Custom through model stores extra ______.",
        "type": "fill_blank",
        "answers": [
            "data",
            "fields"
        ],
        "other_options": [
            "keys",
            "relations",
            "models"
        ]
    },
    {
        "q": "Rearrange through model creation:",
        "type": "rearrange",
        "words": [
            "Create intermediate model",
            "Add ForeignKeys",
            "Use through option",
            "Access extra data"
        ]
    },
    {
        "q": "Meta class configures model options.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which inner class sets model options?",
        "type": "mcq",
        "o": [
            "Meta",
            "Options",
            "Config",
            "Settings"
        ]
    },
    {
        "q": "ordering sets default ______.",
        "type": "fill_blank",
        "answers": [
            "sort order"
        ],
        "other_options": [
            "filter",
            "limit",
            "display"
        ]
    },
    {
        "q": "Match Meta options:",
        "type": "match",
        "left": [
            "ordering",
            "verbose_name",
            "db_table",
            "unique_together"
        ],
        "right": [
            "Sort order",
            "Display name",
            "Table name",
            "Unique constraint"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Post(models.Model):\n    title = models.CharField(max_length=200)\n    class Meta:\n        ordering = ['-created_at']",
        "o": [
            "Posts ordered newest first",
            "Error",
            "Posts ordered oldest first",
            "No ordering"
        ]
    },
    {
        "q": "db_table overrides table name.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which Meta option changes table name?",
        "type": "mcq",
        "o": [
            "db_table",
            "table_name",
            "name",
            "table"
        ]
    },
    {
        "q": "verbose_name sets human-readable ______.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "table",
            "field",
            "app"
        ]
    },
    {
        "q": "Rearrange Meta class options:",
        "type": "rearrange",
        "words": [
            "db_table",
            "ordering",
            "verbose_name",
            "indexes"
        ]
    },
    {
        "q": "Migrations track database changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which command creates migrations?",
        "type": "mcq",
        "o": [
            "makemigrations",
            "migrate",
            "createmigration",
            "schema"
        ]
    },
    {
        "q": "makemigrations generates migration ______.",
        "type": "fill_blank",
        "answers": [
            "files"
        ],
        "other_options": [
            "tables",
            "schemas",
            "databases"
        ]
    },
    {
        "q": "Match migration commands:",
        "type": "match",
        "left": [
            "makemigrations",
            "migrate",
            "showmigrations",
            "sqlmigrate"
        ],
        "right": [
            "Create files",
            "Apply changes",
            "List status",
            "Show SQL"
        ]
    },
    {
        "q": "What is the output of this command?",
        "type": "mcq",
        "c": "python manage.py makemigrations app",
        "o": [
            "Creates migration file for app",
            "Applies migrations",
            "Shows migrations",
            "Error"
        ]
    },
    {
        "q": "migrate applies migrations to database.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which command applies migrations?",
        "type": "mcq",
        "o": [
            "migrate",
            "makemigrations",
            "apply",
            "update"
        ]
    },
    {
        "q": "Migrations are stored in ______ folder.",
        "type": "fill_blank",
        "answers": [
            "migrations"
        ],
        "other_options": [
            "db",
            "schema",
            "models"
        ]
    },
    {
        "q": "Rearrange migration workflow:",
        "type": "rearrange",
        "words": [
            "Edit models",
            "makemigrations",
            "migrate",
            "Verify"
        ]
    },
    {
        "q": "showmigrations lists migration status.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which command shows migration status?",
        "type": "mcq",
        "o": [
            "showmigrations",
            "listmigrations",
            "migrationstatus",
            "status"
        ]
    },
    {
        "q": "sqlmigrate shows generated ______.",
        "type": "fill_blank",
        "answers": [
            "SQL"
        ],
        "other_options": [
            "Python",
            "schema",
            "models"
        ]
    },
    {
        "q": "Match migration status symbols:",
        "type": "match",
        "left": [
            "[X]",
            "[ ]",
            "[?]",
            "--fake"
        ],
        "right": [
            "Applied",
            "Not applied",
            "Squashed",
            "Mark applied"
        ]
    },
    {
        "q": "QuerySet represents database query.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns all model instances?",
        "type": "mcq",
        "o": [
            "Model.objects.all()",
            "Model.all()",
            "Model.get_all()",
            "Model.list()"
        ]
    },
    {
        "q": "objects is the default ______.",
        "type": "fill_blank",
        "answers": [
            "manager"
        ],
        "other_options": [
            "queryset",
            "filter",
            "query"
        ]
    },
    {
        "q": "Rearrange QuerySet methods:",
        "type": "rearrange",
        "words": [
            "all()",
            "filter()",
            "exclude()",
            "order_by()"
        ]
    },
    {
        "q": "QuerySets are lazy-evaluated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which evaluates a QuerySet?",
        "type": "mcq",
        "o": [
            "list(queryset)",
            "queryset.lazy()",
            "queryset.eval()",
            "queryset.run()"
        ]
    },
    {
        "q": "Lazy evaluation delays ______.",
        "type": "fill_blank",
        "answers": [
            "database queries"
        ],
        "other_options": [
            "object creation",
            "filtering",
            "sorting"
        ]
    },
    {
        "q": "Match QuerySet evaluation triggers:",
        "type": "match",
        "left": [
            "Iteration",
            "len()",
            "list()",
            "bool()"
        ],
        "right": [
            "Loop through",
            "Get count",
            "To list",
            "Check exists"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "posts = Post.objects.all()\nprint(type(posts))",
        "o": [
            "<class 'QuerySet'>",
            "<class 'list'>",
            "<class 'tuple'>",
            "Error"
        ]
    },
    {
        "q": "filter() returns matching objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method filters results?",
        "type": "mcq",
        "o": [
            "filter()",
            "where()",
            "find()",
            "search()"
        ]
    },
    {
        "q": "filter() accepts keyword ______.",
        "type": "fill_blank",
        "answers": [
            "arguments"
        ],
        "other_options": [
            "functions",
            "classes",
            "objects"
        ]
    },
    {
        "q": "Rearrange filter operations:",
        "type": "rearrange",
        "words": [
            "Get QuerySet",
            "Apply filter",
            "Chain methods",
            "Evaluate"
        ]
    },
    {
        "q": "exclude() removes matching objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method excludes results?",
        "type": "mcq",
        "o": [
            "exclude()",
            "remove()",
            "delete()",
            "skip()"
        ]
    },
    {
        "q": "exclude() is opposite of ______.",
        "type": "fill_blank",
        "answers": [
            "filter()"
        ],
        "other_options": [
            "all()",
            "get()",
            "first()"
        ]
    },
    {
        "q": "Match filtering methods:",
        "type": "match",
        "left": [
            "filter()",
            "exclude()",
            "get()",
            "first()"
        ],
        "right": [
            "Include matches",
            "Exclude matches",
            "Single object",
            "First match"
        ]
    },
    {
        "q": "get() returns exactly one object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which raises error for no match?",
        "type": "mcq",
        "o": [
            "get()",
            "filter()",
            "first()",
            "last()"
        ]
    },
    {
        "q": "get() raises DoesNotExist if ______.",
        "type": "fill_blank",
        "answers": [
            "not found"
        ],
        "other_options": [
            "multiple found",
            "empty",
            "error"
        ]
    },
    {
        "q": "Rearrange get() behavior:",
        "type": "rearrange",
        "words": [
            "Query database",
            "Find match",
            "Return object",
            "Raise if not found"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "try:\n    post = Post.objects.get(pk=999)\nexcept Post.DoesNotExist:\n    print('Not found')",
        "o": [
            "Not found",
            "None",
            "Error",
            "Empty"
        ]
    },
    {
        "q": "first() returns first matching object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns None if empty?",
        "type": "mcq",
        "o": [
            "first()",
            "get()",
            "all()",
            "filter()"
        ]
    },
    {
        "q": "last() returns the ______ object.",
        "type": "fill_blank",
        "answers": [
            "last"
        ],
        "other_options": [
            "first",
            "random",
            "middle"
        ]
    },
    {
        "q": "Match retrieval methods:",
        "type": "match",
        "left": [
            "get()",
            "first()",
            "last()",
            "latest()"
        ],
        "right": [
            "Exact match",
            "First or None",
            "Last or None",
            "Latest by field"
        ]
    },
    {
        "q": "order_by() sorts results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field prefix reverses order?",
        "type": "mcq",
        "o": [
            "-",
            "!",
            "~",
            "^"
        ]
    },
    {
        "q": "order_by('-field') sorts ______.",
        "type": "fill_blank",
        "answers": [
            "descending"
        ],
        "other_options": [
            "ascending",
            "random",
            "alphabetically"
        ]
    },
    {
        "q": "Rearrange ordering options:",
        "type": "rearrange",
        "words": [
            "field",
            "-field",
            "?",
            "nulls_last"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.order_by('-created_at').first()",
        "o": [
            "Most recent post",
            "Oldest post",
            "Random post",
            "Error"
        ]
    },
    {
        "q": "distinct() removes duplicates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method removes duplicates?",
        "type": "mcq",
        "o": [
            "distinct()",
            "unique()",
            "dedupe()",
            "single()"
        ]
    },
    {
        "q": "distinct() uses SQL ______.",
        "type": "fill_blank",
        "answers": [
            "DISTINCT"
        ],
        "other_options": [
            "UNIQUE",
            "GROUP BY",
            "HAVING"
        ]
    },
    {
        "q": "Match QuerySet modifiers:",
        "type": "match",
        "left": [
            "distinct()",
            "reverse()",
            "none()",
            "all()"
        ],
        "right": [
            "Remove duplicates",
            "Flip order",
            "Empty set",
            "All objects"
        ]
    },
    {
        "q": "values() returns dictionaries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns dict per object?",
        "type": "mcq",
        "o": [
            "values()",
            "dict()",
            "as_dict()",
            "to_dict()"
        ]
    },
    {
        "q": "values_list() returns ______.",
        "type": "fill_blank",
        "answers": [
            "tuples"
        ],
        "other_options": [
            "dicts",
            "lists",
            "sets"
        ]
    },
    {
        "q": "Rearrange projection methods:",
        "type": "rearrange",
        "words": [
            "values()",
            "values_list()",
            "only()",
            "defer()"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.values_list('title', flat=True)",
        "o": [
            "List of titles",
            "List of tuples",
            "List of dicts",
            "Error"
        ]
    },
    {
        "q": "only() loads specified fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which limits loaded fields?",
        "type": "mcq",
        "o": [
            "only()",
            "select()",
            "fields()",
            "limit()"
        ]
    },
    {
        "q": "defer() delays loading of ______.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "objects",
            "queries",
            "results"
        ]
    },
    {
        "q": "Match field loading options:",
        "type": "match",
        "left": [
            "only()",
            "defer()",
            "select_related()",
            "prefetch_related()"
        ],
        "right": [
            "Load only",
            "Load later",
            "Join FK",
            "Separate query"
        ]
    },
    {
        "q": "select_related() reduces queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which uses SQL JOIN?",
        "type": "mcq",
        "o": [
            "select_related()",
            "prefetch_related()",
            "join()",
            "include()"
        ]
    },
    {
        "q": "select_related() works with ______.",
        "type": "fill_blank",
        "answers": [
            "ForeignKey"
        ],
        "other_options": [
            "ManyToMany",
            "reverse relations",
            "any field"
        ]
    },
    {
        "q": "Rearrange query optimization:",
        "type": "rearrange",
        "words": [
            "Identify N+1",
            "Add select_related",
            "Or prefetch_related",
            "Verify queries"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Comment.objects.select_related('post').first().post.title",
        "o": [
            "Post title (1 query)",
            "Post title (2 queries)",
            "Error",
            "None"
        ]
    },
    {
        "q": "prefetch_related() uses separate queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is best for ManyToMany?",
        "type": "mcq",
        "o": [
            "prefetch_related()",
            "select_related()",
            "join()",
            "include()"
        ]
    },
    {
        "q": "prefetch_related() caches in ______.",
        "type": "fill_blank",
        "answers": [
            "Python"
        ],
        "other_options": [
            "database",
            "cache",
            "session"
        ]
    },
    {
        "q": "Match optimization methods:",
        "type": "match",
        "left": [
            "select_related",
            "prefetch_related",
            "Prefetch",
            "only"
        ],
        "right": [
            "JOIN",
            "Separate query",
            "Custom prefetch",
            "Field subset"
        ]
    },
    {
        "q": "Field lookups filter with operators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup is exact match?",
        "type": "mcq",
        "o": [
            "__exact or =",
            "__like",
            "__match",
            "__eq"
        ]
    },
    {
        "q": "__iexact is case-______ exact.",
        "type": "fill_blank",
        "answers": [
            "insensitive"
        ],
        "other_options": [
            "sensitive",
            "specific",
            "strict"
        ]
    },
    {
        "q": "Rearrange string lookups:",
        "type": "rearrange",
        "words": [
            "__exact",
            "__iexact",
            "__contains",
            "__icontains"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.filter(title__icontains='django')",
        "o": [
            "Posts with 'django' (case-insensitive)",
            "Posts exactly 'django'",
            "Error",
            "Empty"
        ]
    },
    {
        "q": "__contains searches substrings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup uses LIKE?",
        "type": "mcq",
        "o": [
            "__contains",
            "__exact",
            "__in",
            "__equals"
        ]
    },
    {
        "q": "__startswith matches ______.",
        "type": "fill_blank",
        "answers": [
            "beginning"
        ],
        "other_options": [
            "end",
            "middle",
            "anywhere"
        ]
    },
    {
        "q": "Match string lookups:",
        "type": "match",
        "left": [
            "__contains",
            "__startswith",
            "__endswith",
            "__regex"
        ],
        "right": [
            "Substring",
            "Start",
            "End",
            "Pattern"
        ]
    },
    {
        "q": "__in filters by list.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup checks membership?",
        "type": "mcq",
        "o": [
            "__in",
            "__contains",
            "__has",
            "__includes"
        ]
    },
    {
        "q": "__in accepts list or ______.",
        "type": "fill_blank",
        "answers": [
            "QuerySet"
        ],
        "other_options": [
            "string",
            "dict",
            "set only"
        ]
    },
    {
        "q": "Rearrange comparison lookups:",
        "type": "rearrange",
        "words": [
            "__gt",
            "__gte",
            "__lt",
            "__lte"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.filter(id__in=[1, 2, 3])",
        "o": [
            "Posts with id 1, 2, or 3",
            "Post with id in range",
            "Error",
            "Single post"
        ]
    },
    {
        "q": "__gt means greater than.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup is 'greater or equal'?",
        "type": "mcq",
        "o": [
            "__gte",
            "__gt",
            "__ge",
            "__gteq"
        ]
    },
    {
        "q": "__lt means less ______.",
        "type": "fill_blank",
        "answers": [
            "than"
        ],
        "other_options": [
            "or equal",
            "only",
            "strict"
        ]
    },
    {
        "q": "Match numeric lookups:",
        "type": "match",
        "left": [
            "__gt",
            "__gte",
            "__lt",
            "__lte"
        ],
        "right": [
            ">",
            ">=",
            "<",
            "<="
        ]
    },
    {
        "q": "__range filters between values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup is inclusive range?",
        "type": "mcq",
        "o": [
            "__range",
            "__between",
            "__span",
            "__within"
        ]
    },
    {
        "q": "__range accepts ______ tuple.",
        "type": "fill_blank",
        "answers": [
            "two-value"
        ],
        "other_options": [
            "list",
            "single",
            "any"
        ]
    },
    {
        "q": "Rearrange range filter:",
        "type": "rearrange",
        "words": [
            "Define start",
            "Define end",
            "Create tuple",
            "Apply __range"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from datetime import date\nPost.objects.filter(created_at__range=(date(2024,1,1), date(2024,12,31)))",
        "o": [
            "Posts from 2024",
            "Error",
            "Posts before 2024",
            "Posts after 2024"
        ]
    },
    {
        "q": "__isnull checks for null values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which lookup finds null?",
        "type": "mcq",
        "o": [
            "__isnull=True",
            "__null=True",
            "__none=True",
            "__empty=True"
        ]
    },
    {
        "q": "__isnull=False finds ______ values.",
        "type": "fill_blank",
        "answers": [
            "non-null"
        ],
        "other_options": [
            "null",
            "empty",
            "zero"
        ]
    },
    {
        "q": "Match null handling:",
        "type": "match",
        "left": [
            "__isnull=True",
            "__isnull=False",
            "null=True",
            "blank=True"
        ],
        "right": [
            "IS NULL",
            "IS NOT NULL",
            "Allow DB null",
            "Allow empty form"
        ]
    },
    {
        "q": "Q objects enable complex queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which enables OR queries?",
        "type": "mcq",
        "o": [
            "Q objects",
            "| operator on filter",
            "or=True",
            "OR()"
        ]
    },
    {
        "q": "Q objects use | for ______.",
        "type": "fill_blank",
        "answers": [
            "OR"
        ],
        "other_options": [
            "AND",
            "NOT",
            "XOR"
        ]
    },
    {
        "q": "Rearrange Q object operators:",
        "type": "rearrange",
        "words": [
            "& (AND)",
            "| (OR)",
            "~ (NOT)"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import Q\nPost.objects.filter(Q(title='A') | Q(title='B'))",
        "o": [
            "Posts with title A or B",
            "Posts with title A and B",
            "Error",
            "No posts"
        ]
    },
    {
        "q": "~ negates Q expression.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which negates Q condition?",
        "type": "mcq",
        "o": [
            "~Q()",
            "not Q()",
            "Q().not()",
            "-Q()"
        ]
    },
    {
        "q": "Q() & Q() performs ______.",
        "type": "fill_blank",
        "answers": [
            "AND"
        ],
        "other_options": [
            "OR",
            "NOT",
            "XOR"
        ]
    },
    {
        "q": "Match Q operators:",
        "type": "match",
        "left": [
            "&",
            "|",
            "~",
            "Q()"
        ],
        "right": [
            "AND",
            "OR",
            "NOT",
            "Wrapper"
        ]
    },
    {
        "q": "F expressions reference fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which compares two fields?",
        "type": "mcq",
        "o": [
            "F()",
            "Ref()",
            "Field()",
            "Col()"
        ]
    },
    {
        "q": "F('field') references field ______.",
        "type": "fill_blank",
        "answers": [
            "value"
        ],
        "other_options": [
            "name",
            "type",
            "object"
        ]
    },
    {
        "q": "Rearrange F expression uses:",
        "type": "rearrange",
        "words": [
            "Field comparison",
            "Atomic update",
            "Annotation",
            "Ordering"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import F\nPost.objects.filter(views__gt=F('likes'))",
        "o": [
            "Posts with more views than likes",
            "Error",
            "All posts",
            "No posts"
        ]
    },
    {
        "q": "F() enables atomic updates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which avoids race conditions?",
        "type": "mcq",
        "o": [
            "F() in update",
            "get then save",
            "refresh_from_db",
            "lock table"
        ]
    },
    {
        "q": "update(views=F('views')+1) increments ______.",
        "type": "fill_blank",
        "answers": [
            "atomically"
        ],
        "other_options": [
            "sequentially",
            "randomly",
            "conditionally"
        ]
    },
    {
        "q": "Match F expression operations:",
        "type": "match",
        "left": [
            "F('a') + 1",
            "F('a') - F('b')",
            "F('a') * 2",
            "F('a') / F('b')"
        ],
        "right": [
            "Increment",
            "Difference",
            "Double",
            "Ratio"
        ]
    },
    {
        "q": "aggregate() returns dictionary.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which computes single aggregate?",
        "type": "mcq",
        "o": [
            "aggregate()",
            "annotate()",
            "sum()",
            "total()"
        ]
    },
    {
        "q": "aggregate() returns ______ result.",
        "type": "fill_blank",
        "answers": [
            "single"
        ],
        "other_options": [
            "multiple",
            "QuerySet",
            "list"
        ]
    },
    {
        "q": "Rearrange aggregation functions:",
        "type": "rearrange",
        "words": [
            "Count",
            "Sum",
            "Avg",
            "Max",
            "Min"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import Avg\nPost.objects.aggregate(Avg('views'))",
        "o": [
            "{'views__avg': value}",
            "Single number",
            "QuerySet",
            "Error"
        ]
    },
    {
        "q": "annotate() adds per-object values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which adds computed column?",
        "type": "mcq",
        "o": [
            "annotate()",
            "aggregate()",
            "add_column()",
            "compute()"
        ]
    },
    {
        "q": "annotate() returns ______.",
        "type": "fill_blank",
        "answers": [
            "QuerySet"
        ],
        "other_options": [
            "dict",
            "list",
            "value"
        ]
    },
    {
        "q": "Match aggregation types:",
        "type": "match",
        "left": [
            "aggregate",
            "annotate",
            "Count",
            "Sum"
        ],
        "right": [
            "Total result",
            "Per-object",
            "Count items",
            "Add values"
        ]
    },
    {
        "q": "Count counts objects or relations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which counts related objects?",
        "type": "mcq",
        "o": [
            "Count('relation')",
            "count()",
            "len()",
            "size()"
        ]
    },
    {
        "q": "Count(distinct=True) counts ______.",
        "type": "fill_blank",
        "answers": [
            "unique"
        ],
        "other_options": [
            "all",
            "null",
            "non-null"
        ]
    },
    {
        "q": "Rearrange annotation workflow:",
        "type": "rearrange",
        "words": [
            "Start QuerySet",
            "Add annotate",
            "Filter by annotation",
            "Get results"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import Count\nAuthor.objects.annotate(num_posts=Count('posts'))",
        "o": [
            "Authors with post count",
            "Post count only",
            "Error",
            "Empty"
        ]
    },
    {
        "q": "create() inserts new object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates and saves in one step?",
        "type": "mcq",
        "o": [
            "create()",
            "new()",
            "insert()",
            "add()"
        ]
    },
    {
        "q": "create() returns the ______ object.",
        "type": "fill_blank",
        "answers": [
            "created"
        ],
        "other_options": [
            "saved",
            "new",
            "first"
        ]
    },
    {
        "q": "Match creation methods:",
        "type": "match",
        "left": [
            "create()",
            "get_or_create()",
            "update_or_create()",
            "bulk_create()"
        ],
        "right": [
            "Create new",
            "Get or create",
            "Update or create",
            "Batch insert"
        ]
    },
    {
        "q": "get_or_create() avoids duplicates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns tuple (obj, created)?",
        "type": "mcq",
        "o": [
            "get_or_create()",
            "create()",
            "get()",
            "first_or_create()"
        ]
    },
    {
        "q": "created is True if object was ______.",
        "type": "fill_blank",
        "answers": [
            "created"
        ],
        "other_options": [
            "found",
            "updated",
            "deleted"
        ]
    },
    {
        "q": "Rearrange get_or_create usage:",
        "type": "rearrange",
        "words": [
            "Call method",
            "Check created",
            "Handle object",
            "Save if needed"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "user, created = User.objects.get_or_create(email='test@test.com')\nprint(created)",
        "o": [
            "True or False",
            "User object",
            "None",
            "Error"
        ]
    },
    {
        "q": "update() modifies multiple objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which updates without loading?",
        "type": "mcq",
        "o": [
            "queryset.update()",
            "obj.save()",
            "set()",
            "modify()"
        ]
    },
    {
        "q": "update() returns number of ______.",
        "type": "fill_blank",
        "answers": [
            "affected rows"
        ],
        "other_options": [
            "objects",
            "queries",
            "changes"
        ]
    },
    {
        "q": "Match modification methods:",
        "type": "match",
        "left": [
            "update()",
            "save()",
            "bulk_update()",
            "refresh_from_db()"
        ],
        "right": [
            "Batch modify",
            "Single save",
            "Batch save",
            "Reload object"
        ]
    },
    {
        "q": "delete() removes objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which deletes QuerySet objects?",
        "type": "mcq",
        "o": [
            "queryset.delete()",
            "queryset.remove()",
            "queryset.destroy()",
            "queryset.drop()"
        ]
    },
    {
        "q": "delete() respects on_delete ______.",
        "type": "fill_blank",
        "answers": [
            "rules"
        ],
        "other_options": [
            "settings",
            "options",
            "modes"
        ]
    },
    {
        "q": "Rearrange deletion workflow:",
        "type": "rearrange",
        "words": [
            "Select objects",
            "Confirm deletion",
            "Call delete()",
            "Handle cascades"
        ]
    },
    {
        "q": "Custom managers extend objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates custom manager?",
        "type": "mcq",
        "o": [
            "Inherit from models.Manager",
            "Inherit from QuerySet",
            "Decorate view",
            "Add function"
        ]
    },
    {
        "q": "Custom managers add new ______.",
        "type": "fill_blank",
        "answers": [
            "methods"
        ],
        "other_options": [
            "fields",
            "models",
            "tables"
        ]
    },
    {
        "q": "Match manager concepts:",
        "type": "match",
        "left": [
            "Manager",
            "QuerySet",
            "get_queryset",
            "custom method"
        ],
        "right": [
            "Interface",
            "Results",
            "Base query",
            "Business logic"
        ]
    },
    {
        "q": "get_queryset() defines base query.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method overrides default QuerySet?",
        "type": "mcq",
        "o": [
            "get_queryset()",
            "queryset()",
            "default()",
            "base()"
        ]
    },
    {
        "q": "Manager methods return ______.",
        "type": "fill_blank",
        "answers": [
            "QuerySet"
        ],
        "other_options": [
            "list",
            "objects",
            "dict"
        ]
    },
    {
        "q": "Rearrange custom manager creation:",
        "type": "rearrange",
        "words": [
            "Create Manager class",
            "Override get_queryset",
            "Add to model",
            "Use new manager"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class PublishedManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(status='published')",
        "o": [
            "Manager filtering published only",
            "Error",
            "All objects",
            "Nothing"
        ]
    },
    {
        "q": "Multiple managers are allowed on models.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is default manager?",
        "type": "mcq",
        "o": [
            "First defined manager",
            "objects",
            "default_manager",
            "primary_manager"
        ]
    },
    {
        "q": "default_manager_name sets ______.",
        "type": "fill_blank",
        "answers": [
            "default manager"
        ],
        "other_options": [
            "queryset",
            "filter",
            "method"
        ]
    },
    {
        "q": "Match manager attributes:",
        "type": "match",
        "left": [
            "objects",
            "published",
            "custom_manager",
            "_default_manager"
        ],
        "right": [
            "Default",
            "Custom",
            "Named",
            "Meta default"
        ]
    },
    {
        "q": "Validators enforce field constraints.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which runs before save?",
        "type": "mcq",
        "o": [
            "Validators",
            "Signals",
            "Managers",
            "Methods"
        ]
    },
    {
        "q": "validators option takes ______ list.",
        "type": "fill_blank",
        "answers": [
            "validator"
        ],
        "other_options": [
            "function",
            "class",
            "method"
        ]
    },
    {
        "q": "Rearrange validation flow:",
        "type": "rearrange",
        "words": [
            "Define validators",
            "Add to field",
            "Call full_clean",
            "Raise ValidationError"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.validators import MinValueValidator\nprice = models.DecimalField(validators=[MinValueValidator(0)])",
        "o": [
            "Field requiring non-negative values",
            "Error",
            "Any value allowed",
            "Nothing"
        ]
    },
    {
        "q": "MinValueValidator sets minimum.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which validates maximum length?",
        "type": "mcq",
        "o": [
            "MaxLengthValidator",
            "LengthValidator",
            "SizeValidator",
            "max_length"
        ]
    },
    {
        "q": "RegexValidator uses ______.",
        "type": "fill_blank",
        "answers": [
            "regular expressions"
        ],
        "other_options": [
            "functions",
            "classes",
            "strings"
        ]
    },
    {
        "q": "Match built-in validators:",
        "type": "match",
        "left": [
            "MinValueValidator",
            "MaxValueValidator",
            "RegexValidator",
            "EmailValidator"
        ],
        "right": [
            "Min value",
            "Max value",
            "Pattern",
            "Email format"
        ]
    },
    {
        "q": "Custom validators are functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which exception signals invalid data?",
        "type": "mcq",
        "o": [
            "ValidationError",
            "ValueError",
            "InvalidData",
            "ConstraintError"
        ]
    },
    {
        "q": "Custom validators raise ______.",
        "type": "fill_blank",
        "answers": [
            "ValidationError"
        ],
        "other_options": [
            "Exception",
            "Error",
            "Invalid"
        ]
    },
    {
        "q": "Rearrange custom validator:",
        "type": "rearrange",
        "words": [
            "Define function",
            "Check value",
            "Raise ValidationError",
            "Add to field"
        ]
    },
    {
        "q": "clean() validates model instance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which validates entire model?",
        "type": "mcq",
        "o": [
            "clean() method",
            "validate()",
            "check()",
            "full_clean()"
        ]
    },
    {
        "q": "full_clean() calls clean and ______.",
        "type": "fill_blank",
        "answers": [
            "field validation"
        ],
        "other_options": [
            "save",
            "delete",
            "update"
        ]
    },
    {
        "q": "Match validation methods:",
        "type": "match",
        "left": [
            "clean()",
            "clean_<field>()",
            "validate_unique()",
            "full_clean()"
        ],
        "right": [
            "Model validation",
            "Field validation",
            "Unique check",
            "All validation"
        ]
    },
    {
        "q": "Model inheritance reuses code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates no database table?",
        "type": "mcq",
        "o": [
            "Abstract base class",
            "Multi-table",
            "Proxy model",
            "All create tables"
        ]
    },
    {
        "q": "abstract=True creates ______ model.",
        "type": "fill_blank",
        "answers": [
            "abstract"
        ],
        "other_options": [
            "proxy",
            "concrete",
            "multi-table"
        ]
    },
    {
        "q": "Rearrange inheritance types:",
        "type": "rearrange",
        "words": [
            "Abstract base",
            "Multi-table",
            "Proxy model"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class TimeStamped(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    class Meta:\n        abstract = True",
        "o": [
            "Reusable abstract model",
            "Database table",
            "Error",
            "Proxy model"
        ]
    },
    {
        "q": "Multi-table creates parent table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which uses implicit OneToOne?",
        "type": "mcq",
        "o": [
            "Multi-table inheritance",
            "Abstract base",
            "Proxy model",
            "Mixin"
        ]
    },
    {
        "q": "Multi-table creates ______ link.",
        "type": "fill_blank",
        "answers": [
            "OneToOne"
        ],
        "other_options": [
            "ForeignKey",
            "ManyToMany",
            "Generic"
        ]
    },
    {
        "q": "Match inheritance behaviors:",
        "type": "match",
        "left": [
            "Abstract",
            "Multi-table",
            "Proxy",
            "Mixin"
        ],
        "right": [
            "No table",
            "Parent table",
            "Same table",
            "No models.Model"
        ]
    },
    {
        "q": "Proxy models share database table.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which adds methods without new table?",
        "type": "mcq",
        "o": [
            "Proxy model",
            "Abstract model",
            "Multi-table",
            "Subclass"
        ]
    },
    {
        "q": "proxy=True modifies ______.",
        "type": "fill_blank",
        "answers": [
            "behavior"
        ],
        "other_options": [
            "table",
            "fields",
            "database"
        ]
    },
    {
        "q": "Rearrange proxy model creation:",
        "type": "rearrange",
        "words": [
            "Inherit parent",
            "Set proxy=True",
            "Add methods",
            "Use proxy"
        ]
    },
    {
        "q": "Signals notify on model events.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which fires before save?",
        "type": "mcq",
        "o": [
            "pre_save",
            "post_save",
            "before_save",
            "saving"
        ]
    },
    {
        "q": "post_save fires after ______.",
        "type": "fill_blank",
        "answers": [
            "save"
        ],
        "other_options": [
            "delete",
            "create",
            "update"
        ]
    },
    {
        "q": "Match model signals:",
        "type": "match",
        "left": [
            "pre_save",
            "post_save",
            "pre_delete",
            "post_delete"
        ],
        "right": [
            "Before save",
            "After save",
            "Before delete",
            "After delete"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models.signals import post_save\nfrom django.dispatch import receiver\n@receiver(post_save, sender=User)\ndef notify(sender, instance, **kwargs):\n    print('Saved')",
        "o": [
            "'Saved' printed after User save",
            "Error",
            "Nothing",
            "'Saved' before save"
        ]
    },
    {
        "q": "@receiver decorator connects signals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which parameter specifies model?",
        "type": "mcq",
        "o": [
            "sender",
            "model",
            "target",
            "source"
        ]
    },
    {
        "q": "created kwarg indicates ______ object.",
        "type": "fill_blank",
        "answers": [
            "new"
        ],
        "other_options": [
            "updated",
            "deleted",
            "existing"
        ]
    },
    {
        "q": "Rearrange signal connection:",
        "type": "rearrange",
        "words": [
            "Import signal",
            "Define handler",
            "Connect with receiver",
            "Signal fires"
        ]
    },
    {
        "q": "m2m_changed fires on ManyToMany changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which signal for M2M?",
        "type": "mcq",
        "o": [
            "m2m_changed",
            "relation_changed",
            "many_changed",
            "link_changed"
        ]
    },
    {
        "q": "m2m_changed provides action ______.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "name",
            "model",
            "field"
        ]
    },
    {
        "q": "Match signal parameters:",
        "type": "match",
        "left": [
            "sender",
            "instance",
            "created",
            "raw"
        ],
        "right": [
            "Model class",
            "Object",
            "New or update",
            "Raw data load"
        ]
    },
    {
        "q": "Constraints enforce database rules.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which defines unique constraint?",
        "type": "mcq",
        "o": [
            "UniqueConstraint",
            "unique_together",
            "Unique()",
            "UniqueCombined"
        ]
    },
    {
        "q": "CheckConstraint validates ______.",
        "type": "fill_blank",
        "answers": [
            "conditions"
        ],
        "other_options": [
            "uniqueness",
            "references",
            "types"
        ]
    },
    {
        "q": "Rearrange constraint types:",
        "type": "rearrange",
        "words": [
            "UniqueConstraint",
            "CheckConstraint",
            "ExclusionConstraint"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Meta:\n    constraints = [models.UniqueConstraint(fields=['a', 'b'], name='unique_ab')]",
        "o": [
            "Unique combination of a and b",
            "Error",
            "Unique a only",
            "Unique b only"
        ]
    },
    {
        "q": "CheckConstraint uses Q objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which validates field values?",
        "type": "mcq",
        "o": [
            "CheckConstraint",
            "UniqueConstraint",
            "Validator",
            "Clean"
        ]
    },
    {
        "q": "check option defines ______.",
        "type": "fill_blank",
        "answers": [
            "condition"
        ],
        "other_options": [
            "value",
            "type",
            "field"
        ]
    },
    {
        "q": "Match constraint options:",
        "type": "match",
        "left": [
            "fields",
            "name",
            "check",
            "condition"
        ],
        "right": [
            "Columns",
            "Identifier",
            "Expression",
            "Filter"
        ]
    },
    {
        "q": "Indexes speed up queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which defines model index?",
        "type": "mcq",
        "o": [
            "models.Index",
            "db_index",
            "IndexField",
            "CreateIndex"
        ]
    },
    {
        "q": "db_index=True on field creates ______.",
        "type": "fill_blank",
        "answers": [
            "index"
        ],
        "other_options": [
            "constraint",
            "key",
            "reference"
        ]
    },
    {
        "q": "Rearrange index definition:",
        "type": "rearrange",
        "words": [
            "Add to Meta.indexes",
            "Specify fields",
            "Set name",
            "Run migrations"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Meta:\n    indexes = [models.Index(fields=['title'], name='title_idx')]",
        "o": [
            "Index on title field",
            "Error",
            "Unique constraint",
            "Nothing"
        ]
    },
    {
        "q": "Composite indexes cover multiple fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates covering index?",
        "type": "mcq",
        "o": [
            "Index with include",
            "CompositeIndex",
            "CoveringIndex",
            "MultiIndex"
        ]
    },
    {
        "q": "opclasses define index ______.",
        "type": "fill_blank",
        "answers": [
            "operators"
        ],
        "other_options": [
            "types",
            "fields",
            "methods"
        ]
    },
    {
        "q": "Match index options:",
        "type": "match",
        "left": [
            "fields",
            "name",
            "condition",
            "include"
        ],
        "right": [
            "Indexed columns",
            "Index name",
            "Partial index",
            "Covering"
        ]
    },
    {
        "q": "Transactions ensure atomicity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which decorator makes view atomic?",
        "type": "mcq",
        "o": [
            "@transaction.atomic",
            "@atomic",
            "@transactional",
            "@commit"
        ]
    },
    {
        "q": "atomic rolls back on ______.",
        "type": "fill_blank",
        "answers": [
            "exception"
        ],
        "other_options": [
            "success",
            "commit",
            "save"
        ]
    },
    {
        "q": "Rearrange transaction flow:",
        "type": "rearrange",
        "words": [
            "Begin transaction",
            "Execute queries",
            "Commit or rollback",
            "End transaction"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db import transaction\nwith transaction.atomic():\n    obj1.save()\n    obj2.save()",
        "o": [
            "Both saved or neither",
            "First saved always",
            "Error",
            "Second saved always"
        ]
    },
    {
        "q": "savepoint creates nested transaction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates savepoint?",
        "type": "mcq",
        "o": [
            "transaction.savepoint()",
            "transaction.nested()",
            "transaction.sub()",
            "transaction.point()"
        ]
    },
    {
        "q": "savepoint_rollback reverts to ______.",
        "type": "fill_blank",
        "answers": [
            "savepoint"
        ],
        "other_options": [
            "beginning",
            "commit",
            "end"
        ]
    },
    {
        "q": "Match transaction methods:",
        "type": "match",
        "left": [
            "atomic",
            "savepoint",
            "savepoint_commit",
            "savepoint_rollback"
        ],
        "right": [
            "Full transaction",
            "Create point",
            "Commit point",
            "Rollback point"
        ]
    },
    {
        "q": "bulk_create inserts multiple objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which efficiently inserts many?",
        "type": "mcq",
        "o": [
            "bulk_create()",
            "create_many()",
            "insert_all()",
            "mass_create()"
        ]
    },
    {
        "q": "bulk_create uses single ______.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "transaction",
            "connection",
            "cursor"
        ]
    },
    {
        "q": "Rearrange bulk operations:",
        "type": "rearrange",
        "words": [
            "bulk_create",
            "bulk_update",
            "in_bulk"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "objs = [Post(title=f'Post {i}') for i in range(100)]\nPost.objects.bulk_create(objs)",
        "o": [
            "100 posts created efficiently",
            "100 separate queries",
            "Error",
            "Nothing saved"
        ]
    },
    {
        "q": "bulk_update modifies multiple objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which requires fields parameter?",
        "type": "mcq",
        "o": [
            "bulk_update()",
            "bulk_create()",
            "update()",
            "save()"
        ]
    },
    {
        "q": "bulk_update needs object ______.",
        "type": "fill_blank",
        "answers": [
            "list"
        ],
        "other_options": [
            "queryset",
            "dict",
            "tuple"
        ]
    },
    {
        "q": "Match bulk methods:",
        "type": "match",
        "left": [
            "bulk_create",
            "bulk_update",
            "in_bulk",
            "update"
        ],
        "right": [
            "Insert many",
            "Update objects",
            "Dict by pk",
            "QuerySet update"
        ]
    },
    {
        "q": "in_bulk returns dictionary by pk.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns {pk: object}?",
        "type": "mcq",
        "o": [
            "in_bulk()",
            "as_dict()",
            "to_dict()",
            "dict()"
        ]
    },
    {
        "q": "in_bulk(id_list) fetches specific ______.",
        "type": "fill_blank",
        "answers": [
            "objects"
        ],
        "other_options": [
            "fields",
            "values",
            "keys"
        ]
    },
    {
        "q": "Rearrange efficient retrieval:",
        "type": "rearrange",
        "words": [
            "Get ID list",
            "Call in_bulk",
            "Access by key",
            "Use object"
        ]
    },
    {
        "q": "Raw SQL is available via raw().",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which executes raw SQL?",
        "type": "mcq",
        "o": [
            "Model.objects.raw()",
            "Model.sql()",
            "Model.query()",
            "Model.execute()"
        ]
    },
    {
        "q": "raw() returns RawQuerySet of ______.",
        "type": "fill_blank",
        "answers": [
            "model instances"
        ],
        "other_options": [
            "dictionaries",
            "tuples",
            "lists"
        ]
    },
    {
        "q": "Match SQL methods:",
        "type": "match",
        "left": [
            "raw()",
            "extra()",
            "connection.cursor()",
            "RawSQL()"
        ],
        "right": [
            "Model query",
            "Deprecated",
            "Direct cursor",
            "Expression"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.raw('SELECT * FROM myapp_post WHERE id = %s', [1])",
        "o": [
            "Post with id 1",
            "Error",
            "All posts",
            "Empty"
        ]
    },
    {
        "q": "connection.cursor() gives direct access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which bypasses ORM completely?",
        "type": "mcq",
        "o": [
            "connection.cursor()",
            "raw()",
            "extra()",
            "annotate()"
        ]
    },
    {
        "q": "cursor.execute() runs SQL ______.",
        "type": "fill_blank",
        "answers": [
            "directly"
        ],
        "other_options": [
            "indirectly",
            "safely",
            "slowly"
        ]
    },
    {
        "q": "Rearrange cursor usage:",
        "type": "rearrange",
        "words": [
            "Import connection",
            "Get cursor",
            "Execute SQL",
            "Fetch results"
        ]
    },
    {
        "q": "Case expressions enable conditional logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates SQL CASE?",
        "type": "mcq",
        "o": [
            "Case(When())",
            "If(Then())",
            "Switch(Case())",
            "Conditional()"
        ]
    },
    {
        "q": "When defines case ______.",
        "type": "fill_blank",
        "answers": [
            "condition"
        ],
        "other_options": [
            "value",
            "field",
            "result"
        ]
    },
    {
        "q": "Match conditional expressions:",
        "type": "match",
        "left": [
            "Case",
            "When",
            "then",
            "default"
        ],
        "right": [
            "Switch",
            "Condition",
            "Result",
            "Else"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import Case, When, Value\nPost.objects.annotate(status=Case(When(views__gt=100, then=Value('popular'))))",
        "o": [
            "Posts annotated with 'popular' status",
            "Error",
            "Filtered posts",
            "Nothing"
        ]
    },
    {
        "q": "Coalesce returns first non-null.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns first non-null value?",
        "type": "mcq",
        "o": [
            "Coalesce()",
            "FirstNonNull()",
            "NullIf()",
            "IfNull()"
        ]
    },
    {
        "q": "Coalesce accepts multiple ______.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "values",
            "conditions",
            "expressions"
        ]
    },
    {
        "q": "Rearrange database functions:",
        "type": "rearrange",
        "words": [
            "Coalesce",
            "Cast",
            "Concat",
            "Length"
        ]
    },
    {
        "q": "Subquery nests queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates nested query?",
        "type": "mcq",
        "o": [
            "Subquery()",
            "Nested()",
            "Inner()",
            "Sub()"
        ]
    },
    {
        "q": "OuterRef references outer ______.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "model",
            "table",
            "field"
        ]
    },
    {
        "q": "Match subquery components:",
        "type": "match",
        "left": [
            "Subquery",
            "OuterRef",
            "Exists",
            "In"
        ],
        "right": [
            "Nested query",
            "Outer reference",
            "Check exists",
            "Check membership"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models import Subquery, OuterRef\nnewest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created')\nPost.objects.annotate(newest_comment=Subquery(newest.values('text')[:1]))",
        "o": [
            "Posts with newest comment text",
            "Error",
            "All comments",
            "Nothing"
        ]
    },
    {
        "q": "Exists checks for related objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which checks if subquery has results?",
        "type": "mcq",
        "o": [
            "Exists()",
            "Any()",
            "Has()",
            "Contains()"
        ]
    },
    {
        "q": "Exists returns ______.",
        "type": "fill_blank",
        "answers": [
            "boolean"
        ],
        "other_options": [
            "count",
            "object",
            "list"
        ]
    },
    {
        "q": "Rearrange subquery usage:",
        "type": "rearrange",
        "words": [
            "Create inner query",
            "Use OuterRef",
            "Wrap in Subquery",
            "Add to annotate"
        ]
    },
    {
        "q": "Window functions compute over partitions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which enables window functions?",
        "type": "mcq",
        "o": [
            "Window()",
            "Over()",
            "Partition()",
            "Frame()"
        ]
    },
    {
        "q": "partition_by groups results by ______.",
        "type": "fill_blank",
        "answers": [
            "field"
        ],
        "other_options": [
            "value",
            "index",
            "order"
        ]
    },
    {
        "q": "Match window components:",
        "type": "match",
        "left": [
            "Window",
            "partition_by",
            "order_by",
            "frame"
        ],
        "right": [
            "Function wrapper",
            "Group by",
            "Sort within",
            "Range"
        ]
    },
    {
        "q": "RowNumber assigns sequential numbers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which assigns rank with gaps?",
        "type": "mcq",
        "o": [
            "Rank()",
            "RowNumber()",
            "DenseRank()",
            "Number()"
        ]
    },
    {
        "q": "DenseRank has no ______.",
        "type": "fill_blank",
        "answers": [
            "gaps"
        ],
        "other_options": [
            "numbers",
            "partitions",
            "orders"
        ]
    },
    {
        "q": "Rearrange window functions:",
        "type": "rearrange",
        "words": [
            "RowNumber",
            "Rank",
            "DenseRank",
            "NthValue"
        ]
    },
    {
        "q": "Expression allows custom SQL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which enables custom expressions?",
        "type": "mcq",
        "o": [
            "Func()",
            "Custom()",
            "SQL()",
            "Expr()"
        ]
    },
    {
        "q": "Func creates database ______.",
        "type": "fill_blank",
        "answers": [
            "function calls"
        ],
        "other_options": [
            "queries",
            "tables",
            "indexes"
        ]
    },
    {
        "q": "Match expression classes:",
        "type": "match",
        "left": [
            "F()",
            "Q()",
            "Func()",
            "Value()"
        ],
        "right": [
            "Field ref",
            "Filter",
            "Function",
            "Constant"
        ]
    },
    {
        "q": "Output field specifies result type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which sets expression output?",
        "type": "mcq",
        "o": [
            "output_field",
            "result_type",
            "return_type",
            "field_type"
        ]
    },
    {
        "q": "Value() wraps Python ______.",
        "type": "fill_blank",
        "answers": [
            "values"
        ],
        "other_options": [
            "functions",
            "classes",
            "methods"
        ]
    },
    {
        "q": "Rearrange expression usage:",
        "type": "rearrange",
        "words": [
            "Import expression",
            "Create instance",
            "Use in annotate",
            "Get results"
        ]
    },
    {
        "q": "JSONField stores JSON data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores JSON?",
        "type": "mcq",
        "o": [
            "JSONField",
            "DictField",
            "ObjectField",
            "MapField"
        ]
    },
    {
        "q": "JSONField supports ______ lookups.",
        "type": "fill_blank",
        "answers": [
            "key"
        ],
        "other_options": [
            "text",
            "index",
            "value"
        ]
    },
    {
        "q": "Match JSONField lookups:",
        "type": "match",
        "left": [
            "__contains",
            "__has_key",
            "__has_keys",
            "__has_any_keys"
        ],
        "right": [
            "Subset",
            "Single key",
            "All keys",
            "Any key"
        ]
    },
    {
        "q": "ArrayField stores lists.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which field stores arrays?",
        "type": "mcq",
        "o": [
            "ArrayField",
            "ListField",
            "CollectionField",
            "VectorField"
        ]
    },
    {
        "q": "ArrayField is PostgreSQL ______.",
        "type": "fill_blank",
        "answers": [
            "specific"
        ],
        "other_options": [
            "compatible",
            "generic",
            "standard"
        ]
    },
    {
        "q": "Rearrange PostgreSQL fields:",
        "type": "rearrange",
        "words": [
            "ArrayField",
            "HStoreField",
            "JSONField",
            "RangeField"
        ]
    },
    {
        "q": "Model testing uses TestCase.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates test database?",
        "type": "mcq",
        "o": [
            "TestCase",
            "SimpleTestCase",
            "LiveServerTestCase",
            "TransactionTestCase"
        ]
    },
    {
        "q": "TestCase wraps tests in ______.",
        "type": "fill_blank",
        "answers": [
            "transactions"
        ],
        "other_options": [
            "threads",
            "processes",
            "sessions"
        ]
    },
    {
        "q": "Match test case types:",
        "type": "match",
        "left": [
            "TestCase",
            "SimpleTestCase",
            "TransactionTestCase",
            "LiveServerTestCase"
        ],
        "right": [
            "DB with rollback",
            "No DB",
            "DB with commits",
            "Browser testing"
        ]
    },
    {
        "q": "setUp runs before each test.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which runs once per class?",
        "type": "mcq",
        "o": [
            "setUpClass",
            "setUp",
            "setUpModule",
            "setUpTest"
        ]
    },
    {
        "q": "tearDown runs after each ______.",
        "type": "fill_blank",
        "answers": [
            "test"
        ],
        "other_options": [
            "class",
            "module",
            "suite"
        ]
    },
    {
        "q": "Rearrange test lifecycle:",
        "type": "rearrange",
        "words": [
            "setUpClass",
            "setUp",
            "test_method",
            "tearDown",
            "tearDownClass"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class PostTest(TestCase):\n    def test_create(self):\n        post = Post.objects.create(title='Test')\n        self.assertEqual(post.title, 'Test')",
        "o": [
            "Test passes if title matches",
            "Error",
            "Test always fails",
            "Nothing"
        ]
    },
    {
        "q": "Fixtures load test data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which attribute loads fixtures?",
        "type": "mcq",
        "o": [
            "fixtures",
            "data",
            "initial_data",
            "test_data"
        ]
    },
    {
        "q": "Fixtures are ______ files.",
        "type": "fill_blank",
        "answers": [
            "JSON",
            "YAML"
        ],
        "other_options": [
            "CSV",
            "Python",
            "XML only"
        ]
    },
    {
        "q": "Match test data methods:",
        "type": "match",
        "left": [
            "fixtures",
            "setUpTestData",
            "setUp",
            "factory"
        ],
        "right": [
            "JSON/YAML files",
            "Class-level data",
            "Per-test data",
            "Object creation"
        ]
    },
    {
        "q": "setUpTestData() is class-level.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is faster for shared data?",
        "type": "mcq",
        "o": [
            "@classmethod setUpTestData",
            "setUp method",
            "fixtures",
            "factory"
        ]
    },
    {
        "q": "setUpTestData creates data ______.",
        "type": "fill_blank",
        "answers": [
            "once"
        ],
        "other_options": [
            "per test",
            "per module",
            "per suite"
        ]
    },
    {
        "q": "Rearrange test data setup:",
        "type": "rearrange",
        "words": [
            "setUpClass",
            "setUpTestData",
            "setUp",
            "run tests"
        ]
    },
    {
        "q": "assertQuerySetEqual compares querysets.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which asserts queryset content?",
        "type": "mcq",
        "o": [
            "assertQuerySetEqual",
            "assertEqual",
            "assertListEqual",
            "assertContains"
        ]
    },
    {
        "q": "assertNumQueries checks query ______.",
        "type": "fill_blank",
        "answers": [
            "count"
        ],
        "other_options": [
            "type",
            "time",
            "result"
        ]
    },
    {
        "q": "Match test assertions:",
        "type": "match",
        "left": [
            "assertQuerySetEqual",
            "assertNumQueries",
            "assertRaises",
            "assertContains"
        ],
        "right": [
            "Compare results",
            "Count queries",
            "Expect exception",
            "Check content"
        ]
    },
    {
        "q": "Multi-database uses DATABASE routers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which routes queries?",
        "type": "mcq",
        "o": [
            "Database router",
            "Query router",
            "Model router",
            "Connection router"
        ]
    },
    {
        "q": "db_for_read determines ______ database.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "write",
            "migrate",
            "sync"
        ]
    },
    {
        "q": "Rearrange router methods:",
        "type": "rearrange",
        "words": [
            "db_for_read",
            "db_for_write",
            "allow_relation",
            "allow_migrate"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "Post.objects.using('replica').all()",
        "o": [
            "Posts from replica database",
            "Error",
            "Posts from default",
            "Nothing"
        ]
    },
    {
        "q": "using() specifies database.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method specifies database?",
        "type": "mcq",
        "o": [
            "using()",
            "database()",
            "db()",
            "from_db()"
        ]
    },
    {
        "q": "save(using='db') saves to ______.",
        "type": "fill_blank",
        "answers": [
            "specific database"
        ],
        "other_options": [
            "default",
            "all databases",
            "cache"
        ]
    },
    {
        "q": "Match database routing:",
        "type": "match",
        "left": [
            "using()",
            "save(using=)",
            "db_for_read",
            "db_for_write"
        ],
        "right": [
            "Query database",
            "Save database",
            "Router read",
            "Router write"
        ]
    },
    {
        "q": "Migration operations modify schema.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which adds field?",
        "type": "mcq",
        "o": [
            "AddField",
            "CreateField",
            "InsertField",
            "NewField"
        ]
    },
    {
        "q": "RemoveField deletes ______.",
        "type": "fill_blank",
        "answers": [
            "column"
        ],
        "other_options": [
            "table",
            "index",
            "constraint"
        ]
    },
    {
        "q": "Rearrange migration operations:",
        "type": "rearrange",
        "words": [
            "CreateModel",
            "AddField",
            "AlterField",
            "RemoveField",
            "DeleteModel"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "operations = [migrations.AddField(model_name='post', name='views', field=models.IntegerField(default=0))]",
        "o": [
            "Adds views field to post",
            "Error",
            "Removes field",
            "Nothing"
        ]
    },
    {
        "q": "RunPython executes Python code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which runs custom migration code?",
        "type": "mcq",
        "o": [
            "RunPython",
            "ExecutePython",
            "CustomOperation",
            "PythonOp"
        ]
    },
    {
        "q": "RunPython takes forward and ______.",
        "type": "fill_blank",
        "answers": [
            "reverse"
        ],
        "other_options": [
            "backward",
            "undo",
            "rollback"
        ]
    },
    {
        "q": "Match migration operations:",
        "type": "match",
        "left": [
            "RunPython",
            "RunSQL",
            "SeparateDatabaseAndState",
            "AlterModelTable"
        ],
        "right": [
            "Python code",
            "Raw SQL",
            "Split state",
            "Rename table"
        ]
    },
    {
        "q": "Data migrations modify data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates data migration?",
        "type": "mcq",
        "o": [
            "makemigrations --empty",
            "migrate --data",
            "datamigration",
            "create_data_migration"
        ]
    },
    {
        "q": "apps.get_model() gets model in ______.",
        "type": "fill_blank",
        "answers": [
            "migration"
        ],
        "other_options": [
            "view",
            "test",
            "admin"
        ]
    },
    {
        "q": "Rearrange data migration:",
        "type": "rearrange",
        "words": [
            "Create empty migration",
            "Write forward function",
            "Write reverse function",
            "Test migration"
        ]
    },
    {
        "q": "squashmigrations combines migrations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which reduces migration count?",
        "type": "mcq",
        "o": [
            "squashmigrations",
            "merge",
            "combine",
            "compress"
        ]
    },
    {
        "q": "Squashed migration replaces ______.",
        "type": "fill_blank",
        "answers": [
            "multiple migrations"
        ],
        "other_options": [
            "tables",
            "models",
            "apps"
        ]
    },
    {
        "q": "Match migration commands:",
        "type": "match",
        "left": [
            "squashmigrations",
            "merge",
            "fake",
            "zero"
        ],
        "right": [
            "Combine",
            "Fix conflicts",
            "Mark applied",
            "Unapply all"
        ]
    },
    {
        "q": "Query optimization reduces database load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which identifies slow queries?",
        "type": "mcq",
        "o": [
            "django-debug-toolbar",
            "query_log",
            "slow_query",
            "db_monitor"
        ]
    },
    {
        "q": "N+1 problem causes extra ______.",
        "type": "fill_blank",
        "answers": [
            "queries"
        ],
        "other_options": [
            "tables",
            "joins",
            "indexes"
        ]
    },
    {
        "q": "Rearrange optimization steps:",
        "type": "rearrange",
        "words": [
            "Profile queries",
            "Identify N+1",
            "Add prefetch",
            "Verify improvement"
        ]
    },
    {
        "q": "iterator() reduces memory usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which avoids loading all at once?",
        "type": "mcq",
        "o": [
            "iterator()",
            "lazy()",
            "stream()",
            "chunk()"
        ]
    },
    {
        "q": "iterator() is for large ______.",
        "type": "fill_blank",
        "answers": [
            "querysets"
        ],
        "other_options": [
            "files",
            "responses",
            "sessions"
        ]
    },
    {
        "q": "Match memory optimization:",
        "type": "match",
        "left": [
            "iterator()",
            "values()",
            "only()",
            "defer()"
        ],
        "right": [
            "Stream results",
            "Dict output",
            "Load subset",
            "Delay load"
        ]
    },
    {
        "q": "explain() shows query plan.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which shows execution plan?",
        "type": "mcq",
        "o": [
            "queryset.explain()",
            "queryset.plan()",
            "queryset.analyze()",
            "queryset.describe()"
        ]
    },
    {
        "q": "explain() returns SQL ______.",
        "type": "fill_blank",
        "answers": [
            "plan"
        ],
        "other_options": [
            "statement",
            "result",
            "time"
        ]
    },
    {
        "q": "Rearrange query debugging:",
        "type": "rearrange",
        "words": [
            "Get explain output",
            "Analyze plan",
            "Add indexes",
            "Re-test"
        ]
    },
    {
        "q": "Full-text search uses SearchVector.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates search vector?",
        "type": "mcq",
        "o": [
            "SearchVector",
            "FullText",
            "TextSearch",
            "SearchField"
        ]
    },
    {
        "q": "SearchQuery parses search ______.",
        "type": "fill_blank",
        "answers": [
            "terms"
        ],
        "other_options": [
            "vectors",
            "results",
            "indexes"
        ]
    },
    {
        "q": "Match search components:",
        "type": "match",
        "left": [
            "SearchVector",
            "SearchQuery",
            "SearchRank",
            "SearchHeadline"
        ],
        "right": [
            "Field vector",
            "Query parser",
            "Relevance",
            "Highlighted text"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.contrib.postgres.search import SearchVector\nPost.objects.annotate(search=SearchVector('title', 'body'))",
        "o": [
            "Posts with search vector",
            "Error",
            "Filtered posts",
            "Nothing"
        ]
    },
    {
        "q": "GIN indexes speed up search.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which index type for full-text?",
        "type": "mcq",
        "o": [
            "GinIndex",
            "BTreeIndex",
            "HashIndex",
            "FullTextIndex"
        ]
    },
    {
        "q": "GIN is for ______ types.",
        "type": "fill_blank",
        "answers": [
            "composite"
        ],
        "other_options": [
            "simple",
            "numeric",
            "date"
        ]
    },
    {
        "q": "Rearrange search setup:",
        "type": "rearrange",
        "words": [
            "Add SearchVector",
            "Create GIN index",
            "Run migration",
            "Query with SearchQuery"
        ]
    },
    {
        "q": "Model methods add behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns string representation?",
        "type": "mcq",
        "o": [
            "__str__",
            "__repr__",
            "__name__",
            "__display__"
        ]
    },
    {
        "q": "get_absolute_url returns ______.",
        "type": "fill_blank",
        "answers": [
            "URL"
        ],
        "other_options": [
            "path",
            "view",
            "template"
        ]
    },
    {
        "q": "Match model methods:",
        "type": "match",
        "left": [
            "__str__",
            "save",
            "delete",
            "get_absolute_url"
        ],
        "right": [
            "String repr",
            "Persist",
            "Remove",
            "URL path"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Post(models.Model):\n    title = models.CharField(max_length=200)\n    def __str__(self):\n        return self.title",
        "o": [
            "Post object shows title",
            "Error",
            "Post object shows id",
            "Nothing"
        ]
    },
    {
        "q": "save() can be overridden.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which must be called in override?",
        "type": "mcq",
        "o": [
            "super().save()",
            "self.save()",
            "base.save()",
            "model.save()"
        ]
    },
    {
        "q": "Override save for custom ______.",
        "type": "fill_blank",
        "answers": [
            "logic"
        ],
        "other_options": [
            "fields",
            "tables",
            "queries"
        ]
    },
    {
        "q": "Rearrange save override:",
        "type": "rearrange",
        "words": [
            "Add custom logic",
            "Call super().save()",
            "Handle exceptions"
        ]
    },
    {
        "q": "Properties access computed values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which decorator creates property?",
        "type": "mcq",
        "o": [
            "@property",
            "@computed",
            "@field",
            "@method"
        ]
    },
    {
        "q": "Properties don't persist to ______.",
        "type": "fill_blank",
        "answers": [
            "database"
        ],
        "other_options": [
            "memory",
            "cache",
            "session"
        ]
    },
    {
        "q": "Match property patterns:",
        "type": "match",
        "left": [
            "@property",
            "@cached_property",
            "annotate",
            "F()"
        ],
        "right": [
            "Computed attr",
            "Cached attr",
            "DB computed",
            "Field reference"
        ]
    },
    {
        "q": "ContentType framework tracks models.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which stores model metadata?",
        "type": "mcq",
        "o": [
            "ContentType",
            "ModelInfo",
            "ModelMeta",
            "TypeInfo"
        ]
    },
    {
        "q": "ContentType enables ______ relations.",
        "type": "fill_blank",
        "answers": [
            "generic"
        ],
        "other_options": [
            "specific",
            "typed",
            "strict"
        ]
    },
    {
        "q": "Rearrange generic relation setup:",
        "type": "rearrange",
        "words": [
            "Add content_type FK",
            "Add object_id",
            "Create GenericForeignKey",
            "Use GenericRelation"
        ]
    },
    {
        "q": "GenericForeignKey links to any model.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates polymorphic relation?",
        "type": "mcq",
        "o": [
            "GenericForeignKey",
            "AnyForeignKey",
            "PolyForeignKey",
            "UniversalFK"
        ]
    },
    {
        "q": "GenericRelation enables ______ lookup.",
        "type": "fill_blank",
        "answers": [
            "reverse"
        ],
        "other_options": [
            "forward",
            "direct",
            "indirect"
        ]
    },
    {
        "q": "Match generic components:",
        "type": "match",
        "left": [
            "content_type",
            "object_id",
            "GenericForeignKey",
            "GenericRelation"
        ],
        "right": [
            "Model type",
            "Row id",
            "Forward link",
            "Reverse link"
        ]
    },
    {
        "q": "Natural keys enable fixture portability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which method defines natural key?",
        "type": "mcq",
        "o": [
            "natural_key()",
            "get_key()",
            "unique_key()",
            "primary_key()"
        ]
    },
    {
        "q": "get_by_natural_key retrieves by ______.",
        "type": "fill_blank",
        "answers": [
            "natural key"
        ],
        "other_options": [
            "primary key",
            "id",
            "slug"
        ]
    },
    {
        "q": "Rearrange natural key setup:",
        "type": "rearrange",
        "words": [
            "Define natural_key",
            "Add get_by_natural_key to manager",
            "Export fixture",
            "Import fixture"
        ]
    },
    {
        "q": "Model._meta accesses metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns model field list?",
        "type": "mcq",
        "o": [
            "_meta.get_fields()",
            "_meta.fields()",
            "_meta.list_fields()",
            "_meta.all_fields()"
        ]
    },
    {
        "q": "_meta.db_table returns table ______.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "schema",
            "columns",
            "indexes"
        ]
    },
    {
        "q": "Match _meta attributes:",
        "type": "match",
        "left": [
            "db_table",
            "app_label",
            "model_name",
            "verbose_name"
        ],
        "right": [
            "Table name",
            "App name",
            "Model name",
            "Display name"
        ]
    },
    {
        "q": "Deferred fields load on access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates deferred model?",
        "type": "mcq",
        "o": [
            "defer()",
            "lazy()",
            "delay()",
            "later()"
        ]
    },
    {
        "q": "Deferred fields trigger ______ query.",
        "type": "fill_blank",
        "answers": [
            "additional"
        ],
        "other_options": [
            "no",
            "batch",
            "cached"
        ]
    },
    {
        "q": "Rearrange deferred loading:",
        "type": "rearrange",
        "words": [
            "Use defer()",
            "Access field",
            "Query executes",
            "Value returned"
        ]
    },
    {
        "q": "refresh_from_db reloads object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which reloads from database?",
        "type": "mcq",
        "o": [
            "refresh_from_db()",
            "reload()",
            "update()",
            "fetch()"
        ]
    },
    {
        "q": "refresh_from_db(fields=[]) reloads ______.",
        "type": "fill_blank",
        "answers": [
            "specific fields"
        ],
        "other_options": [
            "all fields",
            "relations",
            "annotations"
        ]
    },
    {
        "q": "Match object state methods:",
        "type": "match",
        "left": [
            "refresh_from_db",
            "save",
            "delete",
            "pk"
        ],
        "right": [
            "Reload",
            "Persist",
            "Remove",
            "Primary key"
        ]
    },
    {
        "q": "Model state tracks modifications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which checks if newly created?",
        "type": "mcq",
        "o": [
            "_state.adding",
            "is_new",
            "created",
            "_new"
        ]
    },
    {
        "q": "_state.db indicates source ______.",
        "type": "fill_blank",
        "answers": [
            "database"
        ],
        "other_options": [
            "table",
            "query",
            "model"
        ]
    },
    {
        "q": "Rearrange model state checks:",
        "type": "rearrange",
        "words": [
            "Check _state.adding",
            "Check _state.db",
            "Check pk value"
        ]
    },
    {
        "q": "Lazy loading fetches on access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which avoids immediate loading?",
        "type": "mcq",
        "o": [
            "ForeignKey without select_related",
            "ForeignKey with select_related",
            "prefetch_related",
            "only()"
        ]
    },
    {
        "q": "Lazy FK access causes ______ query.",
        "type": "fill_blank",
        "answers": [
            "extra"
        ],
        "other_options": [
            "no",
            "batch",
            "cached"
        ]
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "Lazy",
            "Eager",
            "Deferred",
            "Immediate"
        ],
        "right": [
            "On access",
            "select_related",
            "defer()",
            "All at once"
        ]
    },
    {
        "q": "Database functions wrap SQL functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which computes string length?",
        "type": "mcq",
        "o": [
            "Length()",
            "Len()",
            "Size()",
            "Count()"
        ]
    },
    {
        "q": "Upper() converts to ______.",
        "type": "fill_blank",
        "answers": [
            "uppercase"
        ],
        "other_options": [
            "lowercase",
            "titlecase",
            "camelcase"
        ]
    },
    {
        "q": "Rearrange string functions:",
        "type": "rearrange",
        "words": [
            "Upper",
            "Lower",
            "Length",
            "Trim",
            "Replace"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models.functions import Lower\nPost.objects.annotate(lower_title=Lower('title'))",
        "o": [
            "Posts with lowercase title annotation",
            "Error",
            "Filtered posts",
            "Nothing"
        ]
    },
    {
        "q": "Concat joins strings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which concatenates fields?",
        "type": "mcq",
        "o": [
            "Concat()",
            "Join()",
            "Merge()",
            "Combine()"
        ]
    },
    {
        "q": "Concat uses Value() for ______.",
        "type": "fill_blank",
        "answers": [
            "literal strings"
        ],
        "other_options": [
            "fields",
            "numbers",
            "lists"
        ]
    },
    {
        "q": "Match string functions:",
        "type": "match",
        "left": [
            "Concat",
            "Substr",
            "Replace",
            "Reverse"
        ],
        "right": [
            "Join",
            "Substring",
            "Substitute",
            "Flip"
        ]
    },
    {
        "q": "TruncDate truncates to date.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which extracts date from datetime?",
        "type": "mcq",
        "o": [
            "TruncDate",
            "DatePart",
            "ExtractDate",
            "GetDate"
        ]
    },
    {
        "q": "ExtractYear gets year ______.",
        "type": "fill_blank",
        "answers": [
            "component"
        ],
        "other_options": [
            "string",
            "date",
            "time"
        ]
    },
    {
        "q": "Rearrange date functions:",
        "type": "rearrange",
        "words": [
            "TruncYear",
            "TruncMonth",
            "TruncDay",
            "TruncHour"
        ]
    },
    {
        "q": "Now() returns current timestamp.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which gets database current time?",
        "type": "mcq",
        "o": [
            "Now()",
            "Current()",
            "Today()",
            "Time()"
        ]
    },
    {
        "q": "Now() is evaluated at ______.",
        "type": "fill_blank",
        "answers": [
            "query time"
        ],
        "other_options": [
            "Python time",
            "save time",
            "load time"
        ]
    },
    {
        "q": "Match time functions:",
        "type": "match",
        "left": [
            "Now",
            "TruncDate",
            "ExtractHour",
            "TruncMinute"
        ],
        "right": [
            "Current time",
            "Date only",
            "Hour part",
            "Minute precision"
        ]
    },
    {
        "q": "Cast converts field types.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which changes field type?",
        "type": "mcq",
        "o": [
            "Cast()",
            "Convert()",
            "As()",
            "Type()"
        ]
    },
    {
        "q": "Cast(output_field=) sets target ______.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "value",
            "name",
            "field"
        ]
    },
    {
        "q": "Rearrange type conversion:",
        "type": "rearrange",
        "words": [
            "Import Cast",
            "Specify field",
            "Set output_field",
            "Use in annotate"
        ]
    },
    {
        "q": "Greatest returns maximum value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns largest of values?",
        "type": "mcq",
        "o": [
            "Greatest()",
            "Max()",
            "Largest()",
            "Top()"
        ]
    },
    {
        "q": "Least returns ______ value.",
        "type": "fill_blank",
        "answers": [
            "minimum"
        ],
        "other_options": [
            "maximum",
            "average",
            "first"
        ]
    },
    {
        "q": "Match comparison functions:",
        "type": "match",
        "left": [
            "Greatest",
            "Least",
            "Coalesce",
            "NullIf"
        ],
        "right": [
            "Max of",
            "Min of",
            "First non-null",
            "Null if equal"
        ]
    },
    {
        "q": "Conditional update uses Case/When.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which updates conditionally?",
        "type": "mcq",
        "o": [
            "update() with Case",
            "update_or_create",
            "filter().update()",
            "bulk_update"
        ]
    },
    {
        "q": "Case in update() returns different ______.",
        "type": "fill_blank",
        "answers": [
            "values"
        ],
        "other_options": [
            "queries",
            "fields",
            "models"
        ]
    },
    {
        "q": "Rearrange conditional update:",
        "type": "rearrange",
        "words": [
            "Define When clauses",
            "Create Case expression",
            "Use in update()",
            "Execute query"
        ]
    },
    {
        "q": "Model cloning copies instances.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates copy without pk?",
        "type": "mcq",
        "o": [
            "Set pk=None then save",
            "copy()",
            "clone()",
            "duplicate()"
        ]
    },
    {
        "q": "pk=None before save creates ______.",
        "type": "fill_blank",
        "answers": [
            "new record"
        ],
        "other_options": [
            "update",
            "error",
            "nothing"
        ]
    },
    {
        "q": "Match copy patterns:",
        "type": "match",
        "left": [
            "pk=None",
            "id=None",
            "deepcopy",
            "model_to_dict"
        ],
        "right": [
            "New primary key",
            "Same as pk=None",
            "Python copy",
            "Dict export"
        ]
    },
    {
        "q": "model_to_dict converts to dictionary.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which converts model to dict?",
        "type": "mcq",
        "o": [
            "model_to_dict()",
            "to_dict()",
            "as_dict()",
            "dict(model)"
        ]
    },
    {
        "q": "model_to_dict is in django.forms.______.",
        "type": "fill_blank",
        "answers": [
            "models"
        ],
        "other_options": [
            "utils",
            "forms",
            "db"
        ]
    },
    {
        "q": "Rearrange serialization options:",
        "type": "rearrange",
        "words": [
            "model_to_dict",
            "serializers.serialize",
            "values()",
            "JSONField"
        ]
    },
    {
        "q": "serializers.serialize exports data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which serializes to JSON?",
        "type": "mcq",
        "o": [
            "serializers.serialize('json', qs)",
            "json.dumps(qs)",
            "qs.to_json()",
            "JSONSerializer(qs)"
        ]
    },
    {
        "q": "deserialize restores model ______.",
        "type": "fill_blank",
        "answers": [
            "objects"
        ],
        "other_options": [
            "dicts",
            "tuples",
            "lists"
        ]
    },
    {
        "q": "Match serialization formats:",
        "type": "match",
        "left": [
            "json",
            "xml",
            "yaml",
            "python"
        ],
        "right": [
            "JSON string",
            "XML string",
            "YAML string",
            "Python dict"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core import serializers\ndata = serializers.serialize('json', Post.objects.all())",
        "o": [
            "JSON string of all posts",
            "Error",
            "List of posts",
            "Nothing"
        ]
    },
    {
        "q": "Permissions control model access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates default permissions?",
        "type": "mcq",
        "o": [
            "Django automatically",
            "Manual definition",
            "Fixtures",
            "Signals"
        ]
    },
    {
        "q": "Default permissions are add, change, delete, ______.",
        "type": "fill_blank",
        "answers": [
            "view"
        ],
        "other_options": [
            "read",
            "list",
            "get"
        ]
    },
    {
        "q": "Rearrange permission types:",
        "type": "rearrange",
        "words": [
            "add",
            "change",
            "delete",
            "view"
        ]
    },
    {
        "q": "Custom permissions use Meta.permissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which defines custom permissions?",
        "type": "mcq",
        "o": [
            "Meta.permissions",
            "Meta.perms",
            "permissions attribute",
            "Permission class"
        ]
    },
    {
        "q": "permissions is list of ______.",
        "type": "fill_blank",
        "answers": [
            "tuples"
        ],
        "other_options": [
            "strings",
            "dicts",
            "permissions"
        ]
    },
    {
        "q": "Match permission components:",
        "type": "match",
        "left": [
            "codename",
            "name",
            "content_type",
            "user.has_perm"
        ],
        "right": [
            "Permission string",
            "Display name",
            "Model link",
            "Check permission"
        ]
    },
    {
        "q": "has_perm checks user permissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which checks object-level permission?",
        "type": "mcq",
        "o": [
            "has_perm with object",
            "has_perm only",
            "user.permissions",
            "get_perm"
        ]
    },
    {
        "q": "Object permissions require ______.",
        "type": "fill_blank",
        "answers": [
            "backend"
        ],
        "other_options": [
            "model",
            "view",
            "template"
        ]
    },
    {
        "q": "Rearrange permission check:",
        "type": "rearrange",
        "words": [
            "Get user",
            "Call has_perm",
            "Pass permission string",
            "Handle result"
        ]
    },
    {
        "q": "Cached properties improve performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which caches computed property?",
        "type": "mcq",
        "o": [
            "@cached_property",
            "@property",
            "@cache",
            "@memo"
        ]
    },
    {
        "q": "cached_property stores result on ______.",
        "type": "fill_blank",
        "answers": [
            "instance"
        ],
        "other_options": [
            "class",
            "database",
            "cache"
        ]
    },
    {
        "q": "Match caching options:",
        "type": "match",
        "left": [
            "@cached_property",
            "@lru_cache",
            "prefetch_related",
            "cache.get"
        ],
        "right": [
            "Instance cache",
            "Function cache",
            "Prefetch cache",
            "Cache backend"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from functools import cached_property\nclass Post(models.Model):\n    @cached_property\n    def word_count(self):\n        return len(self.body.split())",
        "o": [
            "Cached word count on first access",
            "Error",
            "Computed every time",
            "Nothing"
        ]
    },
    {
        "q": "Querystring caching uses database cache.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which caches queryset results?",
        "type": "mcq",
        "o": [
            "cache.set() with list",
            "queryset.cache()",
            "cached_queryset",
            "QueryCache"
        ]
    },
    {
        "q": "Cache invalidation requires ______.",
        "type": "fill_blank",
        "answers": [
            "manual deletion"
        ],
        "other_options": [
            "automatic",
            "signal",
            "middleware"
        ]
    },
    {
        "q": "Rearrange cache workflow:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "Query if miss",
            "Store result",
            "Return data"
        ]
    },
    {
        "q": "Model signals can invalidate cache.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which signal clears cache on save?",
        "type": "mcq",
        "o": [
            "post_save with cache.delete",
            "pre_save automatic",
            "cache_invalidate signal",
            "auto_clear signal"
        ]
    },
    {
        "q": "Signal-based invalidation uses ______.",
        "type": "fill_blank",
        "answers": [
            "post_save"
        ],
        "other_options": [
            "pre_save",
            "post_init",
            "pre_init"
        ]
    },
    {
        "q": "Match cache strategies:",
        "type": "match",
        "left": [
            "Read-through",
            "Write-through",
            "Cache-aside",
            "TTL"
        ],
        "right": [
            "Auto-populate",
            "Write to both",
            "App manages",
            "Time expiry"
        ]
    },
    {
        "q": "Model best practices improve quality.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is a naming best practice?",
        "type": "mcq",
        "o": [
            "Singular model names",
            "Plural model names",
            "Uppercase names",
            "Abbreviated names"
        ]
    },
    {
        "q": "Models should be in ______ file.",
        "type": "fill_blank",
        "answers": [
            "models.py"
        ],
        "other_options": [
            "views.py",
            "db.py",
            "schema.py"
        ]
    },
    {
        "q": "Rearrange model best practices:",
        "type": "rearrange",
        "words": [
            "Use descriptive names",
            "Add docstrings",
            "Define __str__",
            "Add Meta"
        ]
    },
    {
        "q": "Fat models put logic in models.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which pattern encapsulates logic?",
        "type": "mcq",
        "o": [
            "Fat models thin views",
            "Fat views thin models",
            "Service layer",
            "Repository pattern"
        ]
    },
    {
        "q": "Fat models move logic from ______.",
        "type": "fill_blank",
        "answers": [
            "views"
        ],
        "other_options": [
            "templates",
            "urls",
            "admin"
        ]
    },
    {
        "q": "Match design patterns:",
        "type": "match",
        "left": [
            "Fat model",
            "Service layer",
            "Repository",
            "Unit of work"
        ],
        "right": [
            "Model logic",
            "Business logic",
            "Data access",
            "Transaction"
        ]
    },
    {
        "q": "DRY avoids code repetition.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which pattern reduces duplication?",
        "type": "mcq",
        "o": [
            "Abstract base class",
            "Concrete class",
            "Proxy model",
            "Multi-table"
        ]
    },
    {
        "q": "Mixins add reusable ______.",
        "type": "fill_blank",
        "answers": [
            "functionality"
        ],
        "other_options": [
            "fields",
            "tables",
            "indexes"
        ]
    },
    {
        "q": "Rearrange DRY techniques:",
        "type": "rearrange",
        "words": [
            "Identify duplication",
            "Create mixin/base",
            "Inherit in models",
            "Test behavior"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class TimestampMixin(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n    class Meta:\n        abstract = True",
        "o": [
            "Reusable timestamp fields",
            "Error",
            "Database table",
            "Nothing"
        ]
    },
    {
        "q": "Model tests verify behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which tests model creation?",
        "type": "mcq",
        "o": [
            "Model.objects.create in test",
            "Admin test",
            "Template test",
            "View test"
        ]
    },
    {
        "q": "Tests should cover ______ paths.",
        "type": "fill_blank",
        "answers": [
            "edge"
        ],
        "other_options": [
            "happy",
            "main",
            "single"
        ]
    },
    {
        "q": "Match test types:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "Functional",
            "Performance"
        ],
        "right": [
            "Single unit",
            "Multiple units",
            "User story",
            "Speed"
        ]
    },
    {
        "q": "Factory Boy creates test objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which library creates test data?",
        "type": "mcq",
        "o": [
            "factory_boy",
            "faker",
            "test_data",
            "fixtures"
        ]
    },
    {
        "q": "Factories replace ______.",
        "type": "fill_blank",
        "answers": [
            "fixtures"
        ],
        "other_options": [
            "tests",
            "models",
            "views"
        ]
    },
    {
        "q": "Rearrange factory usage:",
        "type": "rearrange",
        "words": [
            "Define factory",
            "Set model",
            "Add fields",
            "Use in tests"
        ]
    },
    {
        "q": "Model documentation improves maintainability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which documents models?",
        "type": "mcq",
        "o": [
            "Docstrings",
            "Comments only",
            "README only",
            "Wiki only"
        ]
    },
    {
        "q": "verbose_name improves ______.",
        "type": "fill_blank",
        "answers": [
            "admin display"
        ],
        "other_options": [
            "query speed",
            "index size",
            "table name"
        ]
    },
    {
        "q": "Match documentation types:",
        "type": "match",
        "left": [
            "Docstring",
            "Comment",
            "Help text",
            "Verbose name"
        ],
        "right": [
            "Class/method doc",
            "Code note",
            "Field description",
            "Display label"
        ]
    },
    {
        "q": "help_text describes fields to users.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which shows in forms?",
        "type": "mcq",
        "o": [
            "help_text",
            "verbose_name",
            "comment",
            "docstring"
        ]
    },
    {
        "q": "help_text appears below form ______.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "buttons",
            "titles",
            "errors"
        ]
    },
    {
        "q": "Rearrange field options:",
        "type": "rearrange",
        "words": [
            "verbose_name",
            "help_text",
            "blank",
            "null",
            "default"
        ]
    },
    {
        "q": "Verbose name uses sentence case.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which uses lowercase?",
        "type": "mcq",
        "o": [
            "verbose_name",
            "class name",
            "field name",
            "app name"
        ]
    },
    {
        "q": "verbose_name_plural handles ______.",
        "type": "fill_blank",
        "answers": [
            "pluralization"
        ],
        "other_options": [
            "translation",
            "display",
            "sorting"
        ]
    },
    {
        "q": "Match naming conventions:",
        "type": "match",
        "left": [
            "Model",
            "Field",
            "Verbose name",
            "Plural"
        ],
        "right": [
            "PascalCase",
            "snake_case",
            "Sentence case",
            "Custom plural"
        ]
    },
    {
        "q": "Choices define valid options.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which limits field values?",
        "type": "mcq",
        "o": [
            "choices",
            "validators",
            "constraints",
            "limits"
        ]
    },
    {
        "q": "choices is list of ______.",
        "type": "fill_blank",
        "answers": [
            "tuples"
        ],
        "other_options": [
            "strings",
            "dicts",
            "values"
        ]
    },
    {
        "q": "Rearrange choices definition:",
        "type": "rearrange",
        "words": [
            "Define choices list",
            "Add to field",
            "Use get_<field>_display",
            "Show in forms"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Post(models.Model):\n    STATUS_CHOICES = [('draft', 'Draft'), ('published', 'Published')]\n    status = models.CharField(choices=STATUS_CHOICES)",
        "o": [
            "Field with limited options",
            "Error",
            "Any string allowed",
            "Nothing"
        ]
    },
    {
        "q": "TextChoices simplifies string choices.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which provides enum-like choices?",
        "type": "mcq",
        "o": [
            "models.TextChoices",
            "Enum class",
            "ChoiceField",
            "StringChoices"
        ]
    },
    {
        "q": "IntegerChoices uses ______ values.",
        "type": "fill_blank",
        "answers": [
            "integer"
        ],
        "other_options": [
            "string",
            "float",
            "boolean"
        ]
    },
    {
        "q": "Match choice classes:",
        "type": "match",
        "left": [
            "TextChoices",
            "IntegerChoices",
            "Choices",
            "tuple list"
        ],
        "right": [
            "String enum",
            "Integer enum",
            "Generic",
            "Traditional"
        ]
    },
    {
        "q": "get_FOO_display shows choice label.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which returns display value?",
        "type": "mcq",
        "o": [
            "get_status_display()",
            "status_display",
            "display_status",
            "status.display"
        ]
    },
    {
        "q": "get_<field>_display returns human-readable ______.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "value",
            "key",
            "index"
        ]
    },
    {
        "q": "Rearrange choice usage:",
        "type": "rearrange",
        "words": [
            "Store db value",
            "Access with field",
            "Display with get_display",
            "Show in template"
        ]
    },
    {
        "q": "Editable=False hides from forms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which excludes field from forms?",
        "type": "mcq",
        "o": [
            "editable=False",
            "hidden=True",
            "form_exclude=True",
            "exclude=True"
        ]
    },
    {
        "q": "editable=False still allows ______ access.",
        "type": "fill_blank",
        "answers": [
            "programmatic"
        ],
        "other_options": [
            "form",
            "admin",
            "template"
        ]
    },
    {
        "q": "Match field options:",
        "type": "match",
        "left": [
            "editable",
            "blank",
            "null",
            "default"
        ],
        "right": [
            "Form inclusion",
            "Empty allowed",
            "DB null",
            "Initial value"
        ]
    },
    {
        "q": "Primary key is auto-created.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is default primary key?",
        "type": "mcq",
        "o": [
            "AutoField id",
            "BigAutoField id",
            "IntegerField pk",
            "UUIDField pk"
        ]
    },
    {
        "q": "DEFAULT_AUTO_FIELD sets default ______.",
        "type": "fill_blank",
        "answers": [
            "primary key type"
        ],
        "other_options": [
            "field type",
            "model type",
            "app type"
        ]
    },
    {
        "q": "Rearrange primary key options:",
        "type": "rearrange",
        "words": [
            "AutoField",
            "BigAutoField",
            "UUIDField",
            "custom pk"
        ]
    },
    {
        "q": "unique=True prevents duplicates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which enforces uniqueness?",
        "type": "mcq",
        "o": [
            "unique=True",
            "primary_key=True",
            "distinct=True",
            "single=True"
        ]
    },
    {
        "q": "unique_together is in ______.",
        "type": "fill_blank",
        "answers": [
            "Meta"
        ],
        "other_options": [
            "fields",
            "options",
            "config"
        ]
    },
    {
        "q": "Match uniqueness options:",
        "type": "match",
        "left": [
            "unique",
            "unique_together",
            "UniqueConstraint",
            "primary_key"
        ],
        "right": [
            "Single field",
            "Multiple fields",
            "Modern constraint",
            "Auto unique"
        ]
    },
    {
        "q": "null=True allows database NULL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which allows NULL in database?",
        "type": "mcq",
        "o": [
            "null=True",
            "blank=True",
            "empty=True",
            "none=True"
        ]
    },
    {
        "q": "blank=True allows empty ______.",
        "type": "fill_blank",
        "answers": [
            "form values"
        ],
        "other_options": [
            "database values",
            "queries",
            "templates"
        ]
    },
    {
        "q": "Rearrange null handling:",
        "type": "rearrange",
        "words": [
            "null=True for DB",
            "blank=True for forms",
            "default for value",
            "Use together"
        ]
    },
    {
        "q": "db_column customizes column name.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which changes database column?",
        "type": "mcq",
        "o": [
            "db_column",
            "column_name",
            "name",
            "db_name"
        ]
    },
    {
        "q": "db_column differs from field ______.",
        "type": "fill_blank",
        "answers": [
            "name"
        ],
        "other_options": [
            "type",
            "value",
            "index"
        ]
    },
    {
        "q": "Match database options:",
        "type": "match",
        "left": [
            "db_column",
            "db_index",
            "db_tablespace",
            "db_table"
        ],
        "right": [
            "Column name",
            "Index",
            "Tablespace",
            "Table name"
        ]
    },
    {
        "q": "primary_key=True removes auto id.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which replaces auto primary key?",
        "type": "mcq",
        "o": [
            "Custom field with primary_key=True",
            "Remove id field",
            "Set id=None",
            "Meta.no_id"
        ]
    },
    {
        "q": "Custom pk field is ______.",
        "type": "fill_blank",
        "answers": [
            "unique"
        ],
        "other_options": [
            "indexed",
            "nullable",
            "editable"
        ]
    },
    {
        "q": "Rearrange field attribute priority:",
        "type": "rearrange",
        "words": [
            "primary_key",
            "unique",
            "db_index",
            "null"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "class Book(models.Model):\n    isbn = models.CharField(max_length=13, primary_key=True)",
        "o": [
            "Book with ISBN as primary key",
            "Error",
            "Book with auto id and isbn",
            "Nothing"
        ]
    },
    {
        "q": "error_messages customizes validation messages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which customizes error text?",
        "type": "mcq",
        "o": [
            "error_messages",
            "messages",
            "errors",
            "validation_messages"
        ]
    },
    {
        "q": "error_messages is ______.",
        "type": "fill_blank",
        "answers": [
            "dictionary"
        ],
        "other_options": [
            "list",
            "string",
            "tuple"
        ]
    },
    {
        "q": "Match error message keys:",
        "type": "match",
        "left": [
            "null",
            "blank",
            "unique",
            "invalid"
        ],
        "right": [
            "Null error",
            "Empty error",
            "Duplicate error",
            "Format error"
        ]
    }
]