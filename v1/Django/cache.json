[
    {
        "q": "Django supports caching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Caching improves?",
        "type": "mcq",
        "o": [
            "Performance",
            "Security",
            "Database size",
            "Code quality"
        ]
    },
    {
        "q": "Cache stores ______ data.",
        "type": "fill_blank",
        "answers": [
            "frequently accessed"
        ],
        "other_options": [
            "old",
            "deleted",
            "corrupted"
        ]
    },
    {
        "q": "Match cache concepts:",
        "type": "match",
        "left": [
            "Cache",
            "Hit",
            "Miss",
            "TTL"
        ],
        "right": [
            "Storage",
            "Found",
            "Not found",
            "Expiry"
        ]
    },
    {
        "q": "Rearrange cache flow:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "If hit return",
            "If miss compute",
            "Store in cache"
        ]
    },
    {
        "q": "Django has built-in cache framework.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache framework in?",
        "type": "mcq",
        "o": [
            "django.core.cache",
            "django.cache",
            "django.utils.cache",
            "django.contrib.cache"
        ]
    },
    {
        "q": "Cache backend in ______.",
        "type": "fill_blank",
        "answers": [
            "settings.py"
        ],
        "other_options": [
            "urls.py",
            "views.py",
            "models.py"
        ]
    },
    {
        "q": "Match cache settings:",
        "type": "match",
        "left": [
            "CACHES",
            "BACKEND",
            "LOCATION",
            "TIMEOUT"
        ],
        "right": [
            "Setting name",
            "Type",
            "Address",
            "Expiry"
        ]
    },
    {
        "q": "Rearrange cache setup:",
        "type": "rearrange",
        "words": [
            "Define CACHES",
            "Set BACKEND",
            "Set LOCATION",
            "Set TIMEOUT"
        ]
    },
    {
        "q": "Memcached is a cache backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Most performant backend?",
        "type": "mcq",
        "o": [
            "Memcached or Redis",
            "File-based",
            "Database",
            "Local memory"
        ]
    },
    {
        "q": "Memcached is ______ cache.",
        "type": "fill_blank",
        "answers": [
            "memory-based"
        ],
        "other_options": [
            "file-based",
            "database",
            "session"
        ]
    },
    {
        "q": "Match backends:",
        "type": "match",
        "left": [
            "MemcachedCache",
            "RedisCache",
            "FileBasedCache",
            "LocMemCache"
        ],
        "right": [
            "Memcached",
            "Redis",
            "File system",
            "Local memory"
        ]
    },
    {
        "q": "Redis is a cache backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Redis added natively in Django?",
        "type": "mcq",
        "o": [
            "Django 4.0",
            "Django 3.0",
            "Django 2.0",
            "Django 1.0"
        ]
    },
    {
        "q": "Redis is ______ data store.",
        "type": "fill_blank",
        "answers": [
            "in-memory"
        ],
        "other_options": [
            "disk",
            "cloud",
            "remote"
        ]
    },
    {
        "q": "Match Redis features:",
        "type": "match",
        "left": [
            "Persistence",
            "Pub/Sub",
            "Clusters",
            "Data types"
        ],
        "right": [
            "Save to disk",
            "Messaging",
            "Distributed",
            "Strings, lists, sets"
        ]
    },
    {
        "q": "Rearrange Redis setup:",
        "type": "rearrange",
        "words": [
            "Install Redis",
            "Configure CACHES",
            "Set BACKEND to RedisCache",
            "Set LOCATION"
        ]
    },
    {
        "q": "Database caching stores in DB.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Database cache backend?",
        "type": "mcq",
        "o": [
            "DatabaseCache",
            "DBCache",
            "SQLCache",
            "TableCache"
        ]
    },
    {
        "q": "Database cache needs ______.",
        "type": "fill_blank",
        "answers": [
            "createcachetable command"
        ],
        "other_options": [
            "migrate",
            "syncdb",
            "makemigrations"
        ]
    },
    {
        "q": "Match database cache:",
        "type": "match",
        "left": [
            "DatabaseCache",
            "createcachetable",
            "cache_table",
            "slow"
        ],
        "right": [
            "Backend",
            "Command",
            "Table name",
            "Performance"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "CACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',\n        'LOCATION': 'my_cache_table',\n    }\n}",
        "o": [
            "Configures database cache",
            "Error",
            "Configures file cache",
            "Nothing"
        ]
    },
    {
        "q": "File-based cache uses filesystem.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "File cache backend?",
        "type": "mcq",
        "o": [
            "FileBasedCache",
            "FilesystemCache",
            "DiskCache",
            "StorageCache"
        ]
    },
    {
        "q": "File cache LOCATION is ______.",
        "type": "fill_blank",
        "answers": [
            "directory path"
        ],
        "other_options": [
            "file name",
            "URL",
            "database"
        ]
    },
    {
        "q": "Match file cache:",
        "type": "match",
        "left": [
            "FileBasedCache",
            "LOCATION",
            "directory",
            "serialization"
        ],
        "right": [
            "Backend",
            "Path",
            "Storage",
            "Pickle"
        ]
    },
    {
        "q": "Rearrange file cache setup:",
        "type": "rearrange",
        "words": [
            "Set BACKEND",
            "Set LOCATION to directory",
            "Ensure directory exists",
            "Has write permission"
        ]
    },
    {
        "q": "Local memory cache is per-process.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Local memory backend?",
        "type": "mcq",
        "o": [
            "LocMemCache",
            "LocalCache",
            "MemoryCache",
            "RAMCache"
        ]
    },
    {
        "q": "LocMemCache not shared between ______.",
        "type": "fill_blank",
        "answers": [
            "processes"
        ],
        "other_options": [
            "threads",
            "views",
            "requests"
        ]
    },
    {
        "q": "Match local memory cache:",
        "type": "match",
        "left": [
            "LocMemCache",
            "per-process",
            "development",
            "fast"
        ],
        "right": [
            "Backend",
            "Limitation",
            "Use case",
            "Speed"
        ]
    },
    {
        "q": "Dummy cache doesn't cache.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Dummy cache for?",
        "type": "mcq",
        "o": [
            "Development without caching",
            "Production",
            "Testing",
            "Staging"
        ]
    },
    {
        "q": "DummyCache is ______.",
        "type": "fill_blank",
        "answers": [
            "no-op cache"
        ],
        "other_options": [
            "real cache",
            "fast cache",
            "distributed cache"
        ]
    },
    {
        "q": "Match dummy cache:",
        "type": "match",
        "left": [
            "DummyCache",
            "no-op",
            "development",
            "testing"
        ],
        "right": [
            "Backend",
            "Does nothing",
            "Use case",
            "Use case"
        ]
    },
    {
        "q": "cache.set() stores value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "cache.set() arguments?",
        "type": "mcq",
        "o": [
            "key, value, timeout",
            "value, key",
            "name, data",
            "id, content"
        ]
    },
    {
        "q": "cache.set('key', 'value', ______).",
        "type": "fill_blank",
        "answers": [
            "timeout"
        ],
        "other_options": [
            "expire",
            "ttl",
            "age"
        ]
    },
    {
        "q": "Match cache operations:",
        "type": "match",
        "left": [
            "set()",
            "get()",
            "delete()",
            "clear()"
        ],
        "right": [
            "Store",
            "Retrieve",
            "Remove",
            "Remove all"
        ]
    },
    {
        "q": "Rearrange cache usage:",
        "type": "rearrange",
        "words": [
            "Import cache",
            "Call cache.set()",
            "Call cache.get()",
            "Use cached value"
        ]
    },
    {
        "q": "cache.get() retrieves value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "cache.get() returns what if miss?",
        "type": "mcq",
        "o": [
            "None",
            "Error",
            "Empty string",
            "False"
        ]
    },
    {
        "q": "cache.get('key', ______) for default.",
        "type": "fill_blank",
        "answers": [
            "default"
        ],
        "other_options": [
            "fallback",
            "backup",
            "else"
        ]
    },
    {
        "q": "Match get variations:",
        "type": "match",
        "left": [
            "get()",
            "get_or_set()",
            "get_many()",
            "default"
        ],
        "right": [
            "Single",
            "Set if miss",
            "Multiple",
            "Fallback"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\n\nvalue = cache.get('missing_key', 'default_value')\nprint(value)",
        "o": [
            "default_value",
            "None",
            "Error",
            "missing_key"
        ]
    },
    {
        "q": "cache.delete() removes key.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "cache.delete() returns?",
        "type": "mcq",
        "o": [
            "True/False",
            "Value",
            "None",
            "Nothing"
        ]
    },
    {
        "q": "cache.clear() removes ______.",
        "type": "fill_blank",
        "answers": [
            "all keys"
        ],
        "other_options": [
            "one key",
            "expired keys",
            "nothing"
        ]
    },
    {
        "q": "Match delete operations:",
        "type": "match",
        "left": [
            "delete()",
            "delete_many()",
            "clear()",
            "True"
        ],
        "right": [
            "Single",
            "Multiple",
            "All",
            "Success"
        ]
    },
    {
        "q": "cache.get_or_set() sets if miss.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "get_or_set() atomic?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Depends",
            "Sometimes"
        ]
    },
    {
        "q": "get_or_set() prevents ______.",
        "type": "fill_blank",
        "answers": [
            "race conditions"
        ],
        "other_options": [
            "caching",
            "deletion",
            "updates"
        ]
    },
    {
        "q": "Match atomic operations:",
        "type": "match",
        "left": [
            "get_or_set()",
            "incr()",
            "decr()",
            "add()"
        ],
        "right": [
            "Get or create",
            "Increment",
            "Decrement",
            "Add if not exists"
        ]
    },
    {
        "q": "Rearrange get_or_set:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "If miss set value",
            "Return value",
            "Thread safe"
        ]
    },
    {
        "q": "cache.incr() increments value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "incr() works on?",
        "type": "mcq",
        "o": [
            "Integers",
            "Strings",
            "Lists",
            "Dicts"
        ]
    },
    {
        "q": "cache.incr('key', ______) increments by delta.",
        "type": "fill_blank",
        "answers": [
            "delta"
        ],
        "other_options": [
            "amount",
            "value",
            "number"
        ]
    },
    {
        "q": "Match increment/decrement:",
        "type": "match",
        "left": [
            "incr()",
            "decr()",
            "delta",
            "ValueError"
        ],
        "right": [
            "Add",
            "Subtract",
            "Amount",
            "Non-integer"
        ]
    },
    {
        "q": "cache.add() only sets if key missing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "add() returns?",
        "type": "mcq",
        "o": [
            "True if added, False if exists",
            "Value",
            "None",
            "Key"
        ]
    },
    {
        "q": "add() vs set(): add() is ______.",
        "type": "fill_blank",
        "answers": [
            "conditional"
        ],
        "other_options": [
            "faster",
            "slower",
            "atomic"
        ]
    },
    {
        "q": "Match conditional operations:",
        "type": "match",
        "left": [
            "add()",
            "set()",
            "get_or_set()",
            "touch()"
        ],
        "right": [
            "Add if missing",
            "Always set",
            "Get or create",
            "Update expiry"
        ]
    },
    {
        "q": "Rearrange add flow:",
        "type": "rearrange",
        "words": [
            "Check if key exists",
            "If not exists set",
            "Return True",
            "If exists return False"
        ]
    },
    {
        "q": "cache.touch() updates expiry.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "touch() resets?",
        "type": "mcq",
        "o": [
            "Timeout",
            "Value",
            "Key",
            "All"
        ]
    },
    {
        "q": "touch() extends cache ______.",
        "type": "fill_blank",
        "answers": [
            "TTL"
        ],
        "other_options": [
            "value",
            "key",
            "size"
        ]
    },
    {
        "q": "Match touch:",
        "type": "match",
        "left": [
            "touch()",
            "timeout",
            "True",
            "False"
        ],
        "right": [
            "Update expiry",
            "New value",
            "Success",
            "Key not found"
        ]
    },
    {
        "q": "cache.set_many() sets multiple keys.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "set_many() takes?",
        "type": "mcq",
        "o": [
            "Dictionary",
            "List",
            "Tuple",
            "String"
        ]
    },
    {
        "q": "set_many({'a': 1, 'b': 2}, ______).",
        "type": "fill_blank",
        "answers": [
            "timeout"
        ],
        "other_options": [
            "expire",
            "ttl",
            "age"
        ]
    },
    {
        "q": "Match batch operations:",
        "type": "match",
        "left": [
            "set_many()",
            "get_many()",
            "delete_many()",
            "dictionary"
        ],
        "right": [
            "Set multiple",
            "Get multiple",
            "Delete multiple",
            "Input format"
        ]
    },
    {
        "q": "Rearrange batch set:",
        "type": "rearrange",
        "words": [
            "Create dictionary",
            "Call set_many()",
            "Values stored",
            "More efficient"
        ]
    },
    {
        "q": "Cache timeout in seconds.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Default timeout from?",
        "type": "mcq",
        "o": [
            "CACHES setting",
            "Each call",
            "Environment",
            "Database"
        ]
    },
    {
        "q": "timeout=None means ______.",
        "type": "fill_blank",
        "answers": [
            "default timeout"
        ],
        "other_options": [
            "never expire",
            "0 seconds",
            "immediate"
        ]
    },
    {
        "q": "Match timeout values:",
        "type": "match",
        "left": [
            "None",
            "0",
            "300",
            "negative"
        ],
        "right": [
            "Default",
            "Don't cache",
            "5 minutes",
            "Never expire"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\n\ncache.set('key', 'value', 0)",
        "o": [
            "Doesn't cache",
            "Caches forever",
            "Caches for 0 seconds",
            "Error"
        ]
    },
    {
        "q": "Cache keys should be unique.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Key max length?",
        "type": "mcq",
        "o": [
            "250 characters",
            "100 characters",
            "500 characters",
            "Unlimited"
        ]
    },
    {
        "q": "Keys should avoid ______.",
        "type": "fill_blank",
        "answers": [
            "special characters"
        ],
        "other_options": [
            "numbers",
            "letters",
            "underscores"
        ]
    },
    {
        "q": "Match key best practices:",
        "type": "match",
        "left": [
            "unique",
            "predictable",
            "short",
            "namespaced"
        ],
        "right": [
            "Avoid collision",
            "Easy to find",
            "Performance",
            "Organization"
        ]
    },
    {
        "q": "Rearrange key design:",
        "type": "rearrange",
        "words": [
            "Choose namespace",
            "Add unique identifier",
            "Keep under 250 chars",
            "Avoid special chars"
        ]
    },
    {
        "q": "KEY_PREFIX adds prefix to keys.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "KEY_PREFIX in?",
        "type": "mcq",
        "o": [
            "CACHES setting",
            "Each call",
            "Environment",
            "URL"
        ]
    },
    {
        "q": "KEY_PREFIX helps with ______.",
        "type": "fill_blank",
        "answers": [
            "namespacing"
        ],
        "other_options": [
            "speed",
            "size",
            "security"
        ]
    },
    {
        "q": "Match key settings:",
        "type": "match",
        "left": [
            "KEY_PREFIX",
            "KEY_FUNCTION",
            "VERSION",
            "namespace"
        ],
        "right": [
            "Prefix string",
            "Custom function",
            "Cache version",
            "Organization"
        ]
    },
    {
        "q": "Cache versioning helps invalidation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "VERSION in CACHES?",
        "type": "mcq",
        "o": [
            "Integer",
            "String",
            "Float",
            "Boolean"
        ]
    },
    {
        "q": "Increment VERSION to ______.",
        "type": "fill_blank",
        "answers": [
            "invalidate all"
        ],
        "other_options": [
            "speed up",
            "slow down",
            "add keys"
        ]
    },
    {
        "q": "Match versioning:",
        "type": "match",
        "left": [
            "VERSION",
            "increment",
            "invalidate",
            "deploy"
        ],
        "right": [
            "Setting",
            "Update",
            "Clear cache",
            "Use case"
        ]
    },
    {
        "q": "Rearrange version update:",
        "type": "rearrange",
        "words": [
            "Deploy new code",
            "Increment VERSION",
            "Old cache ignored",
            "New values cached"
        ]
    },
    {
        "q": "Per-view caching uses decorator.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "View cache decorator?",
        "type": "mcq",
        "o": [
            "@cache_page",
            "@cache_view",
            "@cached",
            "@cache"
        ]
    },
    {
        "q": "@cache_page(______).",
        "type": "fill_blank",
        "answers": [
            "timeout_seconds"
        ],
        "other_options": [
            "view",
            "name",
            "key"
        ]
    },
    {
        "q": "Match view caching:",
        "type": "match",
        "left": [
            "@cache_page",
            "timeout",
            "cache_control",
            "vary_on_headers"
        ],
        "right": [
            "Decorator",
            "Duration",
            "HTTP headers",
            "Key variation"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.views.decorators.cache import cache_page\n\n@cache_page(60 * 15)\ndef my_view(request):\n    return HttpResponse('Hello')",
        "o": [
            "Caches view for 15 minutes",
            "Error",
            "Caches for 60 minutes",
            "Nothing"
        ]
    },
    {
        "q": "Template fragment caching possible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Template cache tag?",
        "type": "mcq",
        "o": [
            "{% cache %}",
            "{% cached %}",
            "{% store %}",
            "{% save %}"
        ]
    },
    {
        "q": "{% cache timeout ______ %}.",
        "type": "fill_blank",
        "answers": [
            "fragment_name"
        ],
        "other_options": [
            "key",
            "value",
            "id"
        ]
    },
    {
        "q": "Match template caching:",
        "type": "match",
        "left": [
            "{% cache %}",
            "{% endcache %}",
            "timeout",
            "fragment_name"
        ],
        "right": [
            "Start",
            "End",
            "Duration",
            "Identifier"
        ]
    },
    {
        "q": "Rearrange template cache:",
        "type": "rearrange",
        "words": [
            "{% load cache %}",
            "{% cache timeout name %}",
            "Content",
            "{% endcache %}"
        ]
    },
    {
        "q": "Cache tag needs {% load cache %}.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Template cache from?",
        "type": "mcq",
        "o": [
            "django.templatetags.cache",
            "django.cache",
            "django.template.cache",
            "django.core.cache"
        ]
    },
    {
        "q": "{% load cache %} loads ______.",
        "type": "fill_blank",
        "answers": [
            "template tags"
        ],
        "other_options": [
            "views",
            "models",
            "forms"
        ]
    },
    {
        "q": "Match template loading:",
        "type": "match",
        "left": [
            "{% load %}",
            "cache",
            "tags",
            "library"
        ],
        "right": [
            "Directive",
            "Module",
            "Functions",
            "Collection"
        ]
    },
    {
        "q": "Cache can vary by user.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Vary by user uses?",
        "type": "mcq",
        "o": [
            "request.user in cache key",
            "Cookie",
            "Session",
            "IP"
        ]
    },
    {
        "q": "Per-user cache key includes ______.",
        "type": "fill_blank",
        "answers": [
            "user.id"
        ],
        "other_options": [
            "IP",
            "session",
            "cookie"
        ]
    },
    {
        "q": "Match cache variation:",
        "type": "match",
        "left": [
            "user",
            "language",
            "cookie",
            "header"
        ],
        "right": [
            "Per user",
            "i18n",
            "State",
            "Request"
        ]
    },
    {
        "q": "Rearrange user-specific cache:",
        "type": "rearrange",
        "words": [
            "Get user ID",
            "Include in cache key",
            "Set cache",
            "Get cached value"
        ]
    },
    {
        "q": "Vary header affects cache key.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Vary header for?",
        "type": "mcq",
        "o": [
            "Cache key variation",
            "Security",
            "Compression",
            "Encoding"
        ]
    },
    {
        "q": "Vary: Accept-Language varies by ______.",
        "type": "fill_blank",
        "answers": [
            "language"
        ],
        "other_options": [
            "user",
            "cookie",
            "session"
        ]
    },
    {
        "q": "Match Vary header:",
        "type": "match",
        "left": [
            "Vary",
            "Accept-Language",
            "Cookie",
            "User-Agent"
        ],
        "right": [
            "Header",
            "Language",
            "Session",
            "Browser"
        ]
    },
    {
        "q": "cache_control decorator sets headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "cache_control from?",
        "type": "mcq",
        "o": [
            "django.views.decorators.cache",
            "django.cache",
            "django.core.cache",
            "django.http"
        ]
    },
    {
        "q": "@cache_control(max_age=______)",
        "type": "fill_blank",
        "answers": [
            "seconds"
        ],
        "other_options": [
            "minutes",
            "hours",
            "days"
        ]
    },
    {
        "q": "Match cache_control:",
        "type": "match",
        "left": [
            "max_age",
            "no_cache",
            "no_store",
            "public"
        ],
        "right": [
            "Duration",
            "Validate",
            "Don't store",
            "Shared cache"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.views.decorators.cache import cache_control\n\n@cache_control(max_age=3600, public=True)\ndef my_view(request):\n    return HttpResponse('Hello')",
        "o": [
            "Sets Cache-Control header",
            "Error",
            "Caches in Django",
            "Nothing"
        ]
    },
    {
        "q": "never_cache prevents caching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "never_cache sets?",
        "type": "mcq",
        "o": [
            "Cache-Control: max-age=0",
            "No header",
            "Expires: 0",
            "Pragma: no-cache"
        ]
    },
    {
        "q": "@never_cache from ______.",
        "type": "fill_blank",
        "answers": [
            "django.views.decorators.cache"
        ],
        "other_options": [
            "django.cache",
            "django.core.cache",
            "django.http"
        ]
    },
    {
        "q": "Match never_cache:",
        "type": "match",
        "left": [
            "@never_cache",
            "max-age=0",
            "no-cache",
            "sensitive data"
        ],
        "right": [
            "Decorator",
            "Header value",
            "Directive",
            "Use case"
        ]
    },
    {
        "q": "Rearrange never_cache usage:",
        "type": "rearrange",
        "words": [
            "Import never_cache",
            "Apply to view",
            "Sets headers",
            "Browser doesn't cache"
        ]
    },
    {
        "q": "Site-wide caching uses middleware.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which middlewares for site cache?",
        "type": "mcq",
        "o": [
            "UpdateCacheMiddleware and FetchFromCacheMiddleware",
            "CacheMiddleware",
            "SiteCacheMiddleware",
            "GlobalCacheMiddleware"
        ]
    },
    {
        "q": "UpdateCacheMiddleware goes ______.",
        "type": "fill_blank",
        "answers": [
            "first"
        ],
        "other_options": [
            "last",
            "middle",
            "anywhere"
        ]
    },
    {
        "q": "Match site cache middleware:",
        "type": "match",
        "left": [
            "UpdateCacheMiddleware",
            "FetchFromCacheMiddleware",
            "first",
            "last"
        ],
        "right": [
            "Write cache",
            "Read cache",
            "Position",
            "Position"
        ]
    },
    {
        "q": "Rearrange site cache setup:",
        "type": "rearrange",
        "words": [
            "UpdateCache first",
            "Other middleware",
            "FetchFromCache last",
            "CACHE_MIDDLEWARE_SECONDS"
        ]
    },
    {
        "q": "CACHE_MIDDLEWARE_SECONDS sets timeout.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "CACHE_MIDDLEWARE_ALIAS specifies?",
        "type": "mcq",
        "o": [
            "Which cache to use",
            "Cache key",
            "Timeout",
            "Prefix"
        ]
    },
    {
        "q": "CACHE_MIDDLEWARE_KEY_PREFIX is ______.",
        "type": "fill_blank",
        "answers": [
            "key prefix"
        ],
        "other_options": [
            "timeout",
            "backend",
            "alias"
        ]
    },
    {
        "q": "Match middleware settings:",
        "type": "match",
        "left": [
            "CACHE_MIDDLEWARE_SECONDS",
            "CACHE_MIDDLEWARE_ALIAS",
            "CACHE_MIDDLEWARE_KEY_PREFIX",
            "600"
        ],
        "right": [
            "Timeout",
            "Cache name",
            "Key prefix",
            "10 minutes"
        ]
    },
    {
        "q": "Conditional caching uses ETag.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "ETag is?",
        "type": "mcq",
        "o": [
            "Content hash",
            "Timestamp",
            "Version number",
            "User ID"
        ]
    },
    {
        "q": "ETag for ______ validation.",
        "type": "fill_blank",
        "answers": [
            "cache"
        ],
        "other_options": [
            "user",
            "form",
            "session"
        ]
    },
    {
        "q": "Match conditional caching:",
        "type": "match",
        "left": [
            "ETag",
            "Last-Modified",
            "If-None-Match",
            "304"
        ],
        "right": [
            "Hash",
            "Timestamp",
            "Check",
            "Not Modified"
        ]
    },
    {
        "q": "Rearrange ETag flow:",
        "type": "rearrange",
        "words": [
            "Server generates ETag",
            "Client stores ETag",
            "Client sends If-None-Match",
            "Server returns 304 if match"
        ]
    },
    {
        "q": "condition decorator adds ETag.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "@condition from?",
        "type": "mcq",
        "o": [
            "django.views.decorators.http",
            "django.views.decorators.cache",
            "django.http",
            "django.core"
        ]
    },
    {
        "q": "@condition(etag_func=______)",
        "type": "fill_blank",
        "answers": [
            "function"
        ],
        "other_options": [
            "string",
            "value",
            "hash"
        ]
    },
    {
        "q": "Match condition decorator:",
        "type": "match",
        "left": [
            "@condition",
            "etag_func",
            "last_modified_func",
            "304"
        ],
        "right": [
            "Decorator",
            "Hash function",
            "Timestamp function",
            "Response"
        ]
    },
    {
        "q": "Low-level cache is most flexible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Low-level cache accessed via?",
        "type": "mcq",
        "o": [
            "from django.core.cache import cache",
            "from django.cache import cache",
            "import cache",
            "from cache import django"
        ]
    },
    {
        "q": "Low-level gives ______ control.",
        "type": "fill_blank",
        "answers": [
            "fine-grained"
        ],
        "other_options": [
            "no",
            "limited",
            "automatic"
        ]
    },
    {
        "q": "Match low-level cache:",
        "type": "match",
        "left": [
            "cache.set()",
            "cache.get()",
            "cache.delete()",
            "full control"
        ],
        "right": [
            "Store",
            "Retrieve",
            "Remove",
            "Benefit"
        ]
    },
    {
        "q": "Rearrange low-level usage:",
        "type": "rearrange",
        "words": [
            "Import cache",
            "Check cache.get()",
            "If miss compute",
            "cache.set() result"
        ]
    },
    {
        "q": "Multiple cache backends possible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Multiple caches defined in?",
        "type": "mcq",
        "o": [
            "CACHES dictionary",
            "Separate settings",
            "Environment",
            "Database"
        ]
    },
    {
        "q": "Access non-default cache via ______.",
        "type": "fill_blank",
        "answers": [
            "caches['name']"
        ],
        "other_options": [
            "cache.name",
            "get_cache()",
            "Cache()"
        ]
    },
    {
        "q": "Match multiple caches:",
        "type": "match",
        "left": [
            "default",
            "sessions",
            "thumbnails",
            "caches"
        ],
        "right": [
            "Main cache",
            "Session cache",
            "Image cache",
            "Access function"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import caches\n\nsession_cache = caches['sessions']\nsession_cache.set('key', 'value')",
        "o": [
            "Uses sessions cache",
            "Error",
            "Uses default cache",
            "Nothing"
        ]
    },
    {
        "q": "Session can use cache backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Session cache backend?",
        "type": "mcq",
        "o": [
            "django.contrib.sessions.backends.cache",
            "django.contrib.sessions.backends.cached_db",
            "django.sessions.cache",
            "django.cache.sessions"
        ]
    },
    {
        "q": "Cache-only sessions are ______.",
        "type": "fill_blank",
        "answers": [
            "not persistent"
        ],
        "other_options": [
            "slow",
            "secure",
            "complex"
        ]
    },
    {
        "q": "Match session cache backends:",
        "type": "match",
        "left": [
            "cache",
            "cached_db",
            "db",
            "file"
        ],
        "right": [
            "Fast only",
            "Fast + DB",
            "DB only",
            "Filesystem"
        ]
    },
    {
        "q": "Rearrange session cache setup:",
        "type": "rearrange",
        "words": [
            "Set SESSION_ENGINE",
            "Configure CACHES",
            "Sessions use cache",
            "Fast session access"
        ]
    },
    {
        "q": "QuerySet caching improves performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "QuerySet evaluated when?",
        "type": "mcq",
        "o": [
            "When iterated or sliced",
            "Immediately",
            "Never",
            "On save"
        ]
    },
    {
        "q": "Cache QuerySet result to avoid ______.",
        "type": "fill_blank",
        "answers": [
            "repeated queries"
        ],
        "other_options": [
            "errors",
            "security issues",
            "memory"
        ]
    },
    {
        "q": "Match QuerySet caching:",
        "type": "match",
        "left": [
            "list()",
            "cache.set()",
            "pickle",
            "invalidate"
        ],
        "right": [
            "Evaluate",
            "Store",
            "Serialize",
            "Refresh"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\nfrom myapp.models import Article\n\narticles = cache.get('articles_list')\nif articles is None:\n    articles = list(Article.objects.all())\n    cache.set('articles_list', articles, 300)",
        "o": [
            "Caches QuerySet result",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache invalidation is hard.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Invalidation means?",
        "type": "mcq",
        "o": [
            "Clearing stale cache",
            "Setting cache",
            "Getting cache",
            "Extending cache"
        ]
    },
    {
        "q": "Stale cache shows ______ data.",
        "type": "fill_blank",
        "answers": [
            "outdated"
        ],
        "other_options": [
            "correct",
            "new",
            "secure"
        ]
    },
    {
        "q": "Match invalidation strategies:",
        "type": "match",
        "left": [
            "delete key",
            "TTL",
            "versioning",
            "signals"
        ],
        "right": [
            "Manual",
            "Automatic",
            "Bulk",
            "On change"
        ]
    },
    {
        "q": "Rearrange invalidation flow:",
        "type": "rearrange",
        "words": [
            "Data changes",
            "Identify cache key",
            "Delete from cache",
            "Next request fetches fresh"
        ]
    },
    {
        "q": "Django signals help with invalidation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "post_save signal for?",
        "type": "mcq",
        "o": [
            "After model save",
            "Before save",
            "On delete",
            "On create only"
        ]
    },
    {
        "q": "Signal invalidates cache on ______.",
        "type": "fill_blank",
        "answers": [
            "model change"
        ],
        "other_options": [
            "view access",
            "template render",
            "request"
        ]
    },
    {
        "q": "Match signals:",
        "type": "match",
        "left": [
            "post_save",
            "post_delete",
            "pre_save",
            "receiver"
        ],
        "right": [
            "After save",
            "After delete",
            "Before save",
            "Decorator"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django.core.cache import cache\n\n@receiver(post_save, sender=Article)\ndef clear_article_cache(sender, **kwargs):\n    cache.delete('articles_list')",
        "o": [
            "Clears cache on save",
            "Error",
            "Sets cache",
            "Nothing"
        ]
    },
    {
        "q": "Dogpile effect is cache stampede.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Dogpile happens when?",
        "type": "mcq",
        "o": [
            "Cache expires with many requests",
            "Cache is set",
            "Cache is deleted",
            "Always"
        ]
    },
    {
        "q": "Dogpile causes ______ load.",
        "type": "fill_blank",
        "answers": [
            "high"
        ],
        "other_options": [
            "low",
            "no",
            "normal"
        ]
    },
    {
        "q": "Match dogpile solutions:",
        "type": "match",
        "left": [
            "lock",
            "probabilistic",
            "stale-while-revalidate",
            "queue"
        ],
        "right": [
            "Serialize updates",
            "Random refresh",
            "Serve stale",
            "Background update"
        ]
    },
    {
        "q": "Rearrange dogpile prevention:",
        "type": "rearrange",
        "words": [
            "Acquire lock",
            "Check if still miss",
            "Compute value",
            "Release lock and set"
        ]
    },
    {
        "q": "Redis supports data structures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Redis supports?",
        "type": "mcq",
        "o": [
            "Strings, lists, sets, hashes",
            "Strings only",
            "JSON only",
            "Binary only"
        ]
    },
    {
        "q": "Redis list for ______.",
        "type": "fill_blank",
        "answers": [
            "queues"
        ],
        "other_options": [
            "authentication",
            "templates",
            "URLs"
        ]
    },
    {
        "q": "Match Redis data types:",
        "type": "match",
        "left": [
            "string",
            "list",
            "set",
            "hash"
        ],
        "right": [
            "Simple value",
            "Queue",
            "Unique items",
            "Object fields"
        ]
    },
    {
        "q": "Memcached is simpler than Redis.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Memcached stores?",
        "type": "mcq",
        "o": [
            "Key-value pairs only",
            "Data structures",
            "Files",
            "Sessions only"
        ]
    },
    {
        "q": "Memcached is ______ in memory.",
        "type": "fill_blank",
        "answers": [
            "purely"
        ],
        "other_options": [
            "partially",
            "not",
            "sometimes"
        ]
    },
    {
        "q": "Match Memcached vs Redis:",
        "type": "match",
        "left": [
            "Memcached",
            "Redis",
            "simple",
            "features"
        ],
        "right": [
            "Key-value",
            "Data structures",
            "Memcached",
            "Redis"
        ]
    },
    {
        "q": "Rearrange cache choice:",
        "type": "rearrange",
        "words": [
            "Evaluate needs",
            "Simple = Memcached",
            "Complex = Redis",
            "Configure CACHES"
        ]
    },
    {
        "q": "django-redis provides Redis features.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "django-redis from?",
        "type": "mcq",
        "o": [
            "Third party package",
            "Django core",
            "Python standard library",
            "Redis itself"
        ]
    },
    {
        "q": "django-redis adds ______ operations.",
        "type": "fill_blank",
        "answers": [
            "Redis-specific"
        ],
        "other_options": [
            "basic",
            "slow",
            "database"
        ]
    },
    {
        "q": "Match django-redis features:",
        "type": "match",
        "left": [
            "get_client()",
            "lock()",
            "scan_iter()",
            "pipelining"
        ],
        "right": [
            "Raw Redis",
            "Distributed lock",
            "Key iteration",
            "Batch commands"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django_redis import get_redis_connection\n\nredis_conn = get_redis_connection('default')\nredis_conn.lpush('mylist', 'value')",
        "o": [
            "Direct Redis command",
            "Error",
            "Django cache set",
            "Nothing"
        ]
    },
    {
        "q": "Cache timeout can be infinite.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Infinite timeout value?",
        "type": "mcq",
        "o": [
            "None with specific backends",
            "0",
            "-1",
            "Infinity"
        ]
    },
    {
        "q": "Infinite cache for ______ data.",
        "type": "fill_blank",
        "answers": [
            "static"
        ],
        "other_options": [
            "dynamic",
            "user",
            "session"
        ]
    },
    {
        "q": "Match timeout values:",
        "type": "match",
        "left": [
            "0",
            "None",
            "300",
            "negative"
        ],
        "right": [
            "Don't cache",
            "Default",
            "5 minutes",
            "May mean forever"
        ]
    },
    {
        "q": "Cache can store serialized objects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Default serialization?",
        "type": "mcq",
        "o": [
            "Pickle",
            "JSON",
            "YAML",
            "XML"
        ]
    },
    {
        "q": "Pickle can serialize ______.",
        "type": "fill_blank",
        "answers": [
            "Python objects"
        ],
        "other_options": [
            "HTML",
            "URLs",
            "templates"
        ]
    },
    {
        "q": "Match serialization:",
        "type": "match",
        "left": [
            "pickle",
            "json",
            "msgpack",
            "fast"
        ],
        "right": [
            "Default",
            "Alternative",
            "Efficient",
            "Priority"
        ]
    },
    {
        "q": "Rearrange object caching:",
        "type": "rearrange",
        "words": [
            "Get Python object",
            "Serialize",
            "Store in cache",
            "Deserialize on get"
        ]
    },
    {
        "q": "Cache can use compression.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Compression reduces?",
        "type": "mcq",
        "o": [
            "Memory usage",
            "CPU usage",
            "Key length",
            "Timeout"
        ]
    },
    {
        "q": "Compression trades memory for ______.",
        "type": "fill_blank",
        "answers": [
            "CPU"
        ],
        "other_options": [
            "disk",
            "network",
            "security"
        ]
    },
    {
        "q": "Match compression:",
        "type": "match",
        "left": [
            "zlib",
            "lz4",
            "smaller",
            "slower"
        ],
        "right": [
            "Standard",
            "Fast",
            "Benefit",
            "Tradeoff"
        ]
    },
    {
        "q": "Cache key should be deterministic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Deterministic means?",
        "type": "mcq",
        "o": [
            "Same input = same key",
            "Random",
            "Unique always",
            "Short"
        ]
    },
    {
        "q": "Key from request ______ and params.",
        "type": "fill_blank",
        "answers": [
            "path"
        ],
        "other_options": [
            "time",
            "random",
            "session"
        ]
    },
    {
        "q": "Match key generation:",
        "type": "match",
        "left": [
            "path",
            "query params",
            "user",
            "hash"
        ],
        "right": [
            "URL",
            "GET params",
            "Identity",
            "Combine"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def get_cache_key(request):\n    return f\"page_{request.path}_{request.GET.urlencode()}\"",
        "o": [
            "Generates unique key",
            "Error",
            "Returns None",
            "Nothing"
        ]
    },
    {
        "q": "Template cache can include variables.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Variable in {% cache %}?",
        "type": "mcq",
        "o": [
            "After fragment name",
            "Before timeout",
            "In endcache",
            "Not allowed"
        ]
    },
    {
        "q": "{% cache 300 name ______ %}.",
        "type": "fill_blank",
        "answers": [
            "vary_variable"
        ],
        "other_options": [
            "value",
            "key",
            "id"
        ]
    },
    {
        "q": "Match template cache vars:",
        "type": "match",
        "left": [
            "user.id",
            "language",
            "request.path",
            "dynamic key"
        ],
        "right": [
            "Per user",
            "Per language",
            "Per URL",
            "Purpose"
        ]
    },
    {
        "q": "Rearrange template cache with var:",
        "type": "rearrange",
        "words": [
            "{% load cache %}",
            "{% cache 300 sidebar user.id %}",
            "Content",
            "{% endcache %}"
        ]
    },
    {
        "q": "Cache can use make_template_fragment_key.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "make_template_fragment_key from?",
        "type": "mcq",
        "o": [
            "django.core.cache.utils",
            "django.template.cache",
            "django.cache",
            "django.utils.cache"
        ]
    },
    {
        "q": "Used to ______ template cache.",
        "type": "fill_blank",
        "answers": [
            "invalidate"
        ],
        "other_options": [
            "set",
            "get",
            "extend"
        ]
    },
    {
        "q": "Match template cache utils:",
        "type": "match",
        "left": [
            "make_template_fragment_key",
            "fragment_name",
            "vary_on",
            "cache.delete"
        ],
        "right": [
            "Function",
            "First arg",
            "Variable list",
            "Clear"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\nfrom django.core.cache.utils import make_template_fragment_key\n\nkey = make_template_fragment_key('sidebar', [user.id])\ncache.delete(key)",
        "o": [
            "Deletes template cache fragment",
            "Error",
            "Sets cache",
            "Nothing"
        ]
    },
    {
        "q": "@vary_on_headers affects cache key.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "@vary_on_headers from?",
        "type": "mcq",
        "o": [
            "django.views.decorators.vary",
            "django.views.decorators.cache",
            "django.http",
            "django.core"
        ]
    },
    {
        "q": "Vary on User-Agent for ______ devices.",
        "type": "fill_blank",
        "answers": [
            "different"
        ],
        "other_options": [
            "same",
            "all",
            "no"
        ]
    },
    {
        "q": "Match vary decorators:",
        "type": "match",
        "left": [
            "@vary_on_headers",
            "@vary_on_cookie",
            "Vary header",
            "cache key"
        ],
        "right": [
            "Headers",
            "Cookie",
            "HTTP response",
            "Affected"
        ]
    },
    {
        "q": "Rearrange vary setup:",
        "type": "rearrange",
        "words": [
            "Import vary_on_headers",
            "Apply decorator",
            "Cache varies by header",
            "Different cached versions"
        ]
    },
    {
        "q": "Cache backends can be clustered.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cluster for?",
        "type": "mcq",
        "o": [
            "High availability and scale",
            "Security",
            "Simplicity",
            "Cost reduction"
        ]
    },
    {
        "q": "Redis Cluster uses ______.",
        "type": "fill_blank",
        "answers": [
            "sharding"
        ],
        "other_options": [
            "replication only",
            "backup",
            "compression"
        ]
    },
    {
        "q": "Match clustering:",
        "type": "match",
        "left": [
            "sharding",
            "replication",
            "failover",
            "consistency"
        ],
        "right": [
            "Distribute data",
            "Copy data",
            "Handle failure",
            "Data agreement"
        ]
    },
    {
        "q": "Cache can be monitored.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Monitor what?",
        "type": "mcq",
        "o": [
            "Hit rate, memory, keys",
            "User count",
            "Template count",
            "URL count"
        ]
    },
    {
        "q": "Hit rate shows cache ______.",
        "type": "fill_blank",
        "answers": [
            "effectiveness"
        ],
        "other_options": [
            "size",
            "speed",
            "cost"
        ]
    },
    {
        "q": "Match monitoring:",
        "type": "match",
        "left": [
            "hit rate",
            "miss rate",
            "memory",
            "keys"
        ],
        "right": [
            "Found",
            "Not found",
            "Usage",
            "Count"
        ]
    },
    {
        "q": "Rearrange cache monitoring:",
        "type": "rearrange",
        "words": [
            "Enable stats",
            "Collect metrics",
            "Analyze hit rate",
            "Optimize if needed"
        ]
    },
    {
        "q": "Cache warming improves startup.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Warming means?",
        "type": "mcq",
        "o": [
            "Pre-populating cache",
            "Clearing cache",
            "Extending timeout",
            "Compressing"
        ]
    },
    {
        "q": "Warm cache before ______.",
        "type": "fill_blank",
        "answers": [
            "traffic"
        ],
        "other_options": [
            "shutdown",
            "backup",
            "deploy"
        ]
    },
    {
        "q": "Match warming:",
        "type": "match",
        "left": [
            "warm",
            "cold",
            "populate",
            "script"
        ],
        "right": [
            "Ready",
            "Empty",
            "Fill",
            "Automate"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\nfrom myapp.models import Article\n\ndef warm_cache():\n    for article in Article.objects.all():\n        cache.set(f'article_{article.id}', article, 3600)",
        "o": [
            "Warms article cache",
            "Error",
            "Clears cache",
            "Nothing"
        ]
    },
    {
        "q": "Cache aside pattern is common.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache aside flow?",
        "type": "mcq",
        "o": [
            "Check cache, if miss query DB, set cache",
            "Always query DB",
            "Always use cache",
            "Never cache"
        ]
    },
    {
        "q": "Cache aside is ______ pattern.",
        "type": "fill_blank",
        "answers": [
            "read-through"
        ],
        "other_options": [
            "write-through",
            "write-behind",
            "refresh-ahead"
        ]
    },
    {
        "q": "Match caching patterns:",
        "type": "match",
        "left": [
            "cache aside",
            "write through",
            "write behind",
            "refresh ahead"
        ],
        "right": [
            "Lazy load",
            "Write to both",
            "Async write",
            "Preemptive refresh"
        ]
    },
    {
        "q": "Rearrange cache aside:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "If miss query database",
            "Store in cache",
            "Return data"
        ]
    },
    {
        "q": "Write-through updates cache on write.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Write-through updates?",
        "type": "mcq",
        "o": [
            "Cache and DB together",
            "Cache only",
            "DB only",
            "Neither"
        ]
    },
    {
        "q": "Write-through ensures ______.",
        "type": "fill_blank",
        "answers": [
            "consistency"
        ],
        "other_options": [
            "speed",
            "size",
            "simplicity"
        ]
    },
    {
        "q": "Match write patterns:",
        "type": "match",
        "left": [
            "write through",
            "write behind",
            "consistent",
            "fast writes"
        ],
        "right": [
            "Sync",
            "Async",
            "Write through",
            "Write behind"
        ]
    },
    {
        "q": "Cache can use LRU eviction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "LRU stands for?",
        "type": "mcq",
        "o": [
            "Least Recently Used",
            "Last Recently Updated",
            "Lowest Resource Usage",
            "Limited Resource Use"
        ]
    },
    {
        "q": "LRU evicts ______ used items.",
        "type": "fill_blank",
        "answers": [
            "least recently"
        ],
        "other_options": [
            "most",
            "randomly",
            "oldest"
        ]
    },
    {
        "q": "Match eviction policies:",
        "type": "match",
        "left": [
            "LRU",
            "LFU",
            "FIFO",
            "Random"
        ],
        "right": [
            "Recency",
            "Frequency",
            "Order",
            "Chance"
        ]
    },
    {
        "q": "Rearrange LRU operation:",
        "type": "rearrange",
        "words": [
            "Cache full",
            "Find LRU item",
            "Evict LRU item",
            "Add new item"
        ]
    },
    {
        "q": "Cache MAX_ENTRIES limits items.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "MAX_ENTRIES default?",
        "type": "mcq",
        "o": [
            "300",
            "100",
            "500",
            "1000"
        ]
    },
    {
        "q": "MAX_ENTRIES for ______ backends.",
        "type": "fill_blank",
        "answers": [
            "local memory and file"
        ],
        "other_options": [
            "Redis",
            "Memcached",
            "database"
        ]
    },
    {
        "q": "Match cache limits:",
        "type": "match",
        "left": [
            "MAX_ENTRIES",
            "CULL_FREQUENCY",
            "300",
            "2"
        ],
        "right": [
            "Max items",
            "Eviction fraction",
            "Default entries",
            "Default cull"
        ]
    },
    {
        "q": "Cache CULL_FREQUENCY sets eviction rate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "CULL_FREQUENCY=2 means?",
        "type": "mcq",
        "o": [
            "Evict 1/2 when full",
            "Evict all",
            "Evict 1/4",
            "Never evict"
        ]
    },
    {
        "q": "CULL_FREQUENCY=0 means evict ______.",
        "type": "fill_blank",
        "answers": [
            "all"
        ],
        "other_options": [
            "none",
            "half",
            "quarter"
        ]
    },
    {
        "q": "Match cull settings:",
        "type": "match",
        "left": [
            "0",
            "2",
            "3",
            "4"
        ],
        "right": [
            "All",
            "Half",
            "Third",
            "Quarter"
        ]
    },
    {
        "q": "Cache works with AJAX.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache AJAX responses?",
        "type": "mcq",
        "o": [
            "Yes, like any response",
            "No, never",
            "Only GET",
            "Only POST"
        ]
    },
    {
        "q": "AJAX cache uses same ______.",
        "type": "fill_blank",
        "answers": [
            "decorators"
        ],
        "other_options": [
            "templates",
            "models",
            "forms"
        ]
    },
    {
        "q": "Match AJAX caching:",
        "type": "match",
        "left": [
            "@cache_page",
            "JsonResponse",
            "GET",
            "POST"
        ],
        "right": [
            "Decorator",
            "Response type",
            "Cacheable",
            "Not cached"
        ]
    },
    {
        "q": "Rearrange AJAX caching:",
        "type": "rearrange",
        "words": [
            "Create AJAX view",
            "Apply @cache_page",
            "Return JsonResponse",
            "Response cached"
        ]
    },
    {
        "q": "Cache HTTP headers inform browser.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Browser respects?",
        "type": "mcq",
        "o": [
            "Cache-Control header",
            "Django cache",
            "Server settings",
            "Database"
        ]
    },
    {
        "q": "Browser cache is ______.",
        "type": "fill_blank",
        "answers": [
            "client-side"
        ],
        "other_options": [
            "server-side",
            "database",
            "CDN"
        ]
    },
    {
        "q": "Match cache locations:",
        "type": "match",
        "left": [
            "Browser",
            "CDN",
            "Server",
            "Database"
        ],
        "right": [
            "Client",
            "Edge",
            "Backend",
            "Persistence"
        ]
    },
    {
        "q": "CDN caches static content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "CDN stands for?",
        "type": "mcq",
        "o": [
            "Content Delivery Network",
            "Cache Distribution Network",
            "Content Data Network",
            "Cached Delivery Node"
        ]
    },
    {
        "q": "CDN caches at ______.",
        "type": "fill_blank",
        "answers": [
            "edge locations"
        ],
        "other_options": [
            "origin",
            "database",
            "server"
        ]
    },
    {
        "q": "Match CDN:",
        "type": "match",
        "left": [
            "edge",
            "origin",
            "static",
            "dynamic"
        ],
        "right": [
            "Near user",
            "Source server",
            "Cacheable",
            "Not cached"
        ]
    },
    {
        "q": "Rearrange CDN flow:",
        "type": "rearrange",
        "words": [
            "User requests",
            "CDN checks cache",
            "If miss fetches origin",
            "Returns to user"
        ]
    },
    {
        "q": "Cache debug shows cache info.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Debug Toolbar shows?",
        "type": "mcq",
        "o": [
            "Cache operations",
            "Templates only",
            "SQL only",
            "Nothing"
        ]
    },
    {
        "q": "Debug Toolbar from ______.",
        "type": "fill_blank",
        "answers": [
            "django-debug-toolbar"
        ],
        "other_options": [
            "django.debug",
            "django.toolbar",
            "debug"
        ]
    },
    {
        "q": "Match debug tools:",
        "type": "match",
        "left": [
            "Django Debug Toolbar",
            "cache panel",
            "hits",
            "misses"
        ],
        "right": [
            "Package",
            "Feature",
            "Found",
            "Not found"
        ]
    },
    {
        "q": "Cache can have fallback.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Fallback when?",
        "type": "mcq",
        "o": [
            "Primary cache fails",
            "Always",
            "Never",
            "On every request"
        ]
    },
    {
        "q": "Fallback to ______ cache.",
        "type": "fill_blank",
        "answers": [
            "secondary"
        ],
        "other_options": [
            "same",
            "no",
            "database"
        ]
    },
    {
        "q": "Match fallback:",
        "type": "match",
        "left": [
            "primary",
            "fallback",
            "error handling",
            "graceful"
        ],
        "right": [
            "Main",
            "Backup",
            "Exception",
            "Degradation"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import caches\n\ntry:\n    value = caches['default'].get('key')\nexcept Exception:\n    value = caches['fallback'].get('key')",
        "o": [
            "Uses fallback on error",
            "Always uses default",
            "Error",
            "Nothing"
        ]
    },
    {
        "q": "Cache can be distributed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Distributed cache means?",
        "type": "mcq",
        "o": [
            "Shared across servers",
            "On one server",
            "In database",
            "In files"
        ]
    },
    {
        "q": "Distributed cache for ______.",
        "type": "fill_blank",
        "answers": [
            "multi-server deployments"
        ],
        "other_options": [
            "single server",
            "development",
            "testing"
        ]
    },
    {
        "q": "Match distributed cache:",
        "type": "match",
        "left": [
            "Memcached",
            "Redis",
            "shared",
            "consistent hashing"
        ],
        "right": [
            "Backend",
            "Backend",
            "Benefit",
            "Distribution"
        ]
    },
    {
        "q": "Rearrange distributed setup:",
        "type": "rearrange",
        "words": [
            "Deploy cache server",
            "Configure LOCATION",
            "All app servers connect",
            "Shared cache"
        ]
    },
    {
        "q": "Cache helps with database load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Reduce database load by?",
        "type": "mcq",
        "o": [
            "Caching query results",
            "More queries",
            "Bigger database",
            "More connections"
        ]
    },
    {
        "q": "Cached queries avoid ______.",
        "type": "fill_blank",
        "answers": [
            "database hits"
        ],
        "other_options": [
            "cache hits",
            "template renders",
            "URL dispatching"
        ]
    },
    {
        "q": "Match database optimization:",
        "type": "match",
        "left": [
            "cache QuerySet",
            "select_related",
            "prefetch_related",
            "indexes"
        ],
        "right": [
            "Avoid queries",
            "Join",
            "Separate queries",
            "Fast lookup"
        ]
    },
    {
        "q": "Cache can store computed values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Computed values like?",
        "type": "mcq",
        "o": [
            "Aggregates, counts, sums",
            "Raw data only",
            "User input",
            "Form data"
        ]
    },
    {
        "q": "Cache expensive ______.",
        "type": "fill_blank",
        "answers": [
            "computations"
        ],
        "other_options": [
            "templates",
            "URLs",
            "forms"
        ]
    },
    {
        "q": "Match computed caching:",
        "type": "match",
        "left": [
            "count",
            "sum",
            "average",
            "expensive"
        ],
        "right": [
            "Aggregate",
            "Aggregate",
            "Aggregate",
            "Worth caching"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.core.cache import cache\nfrom myapp.models import Order\n\ndef get_total_sales():\n    total = cache.get('total_sales')\n    if total is None:\n        total = Order.objects.aggregate(total=Sum('amount'))['total']\n        cache.set('total_sales', total, 3600)\n    return total",
        "o": [
            "Caches aggregate result",
            "Error",
            "Always queries",
            "Nothing"
        ]
    },
    {
        "q": "Cache helps with API responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "API cache reduces?",
        "type": "mcq",
        "o": [
            "Response time",
            "Security",
            "Features",
            "Data accuracy"
        ]
    },
    {
        "q": "API cache for ______ endpoints.",
        "type": "fill_blank",
        "answers": [
            "read-heavy"
        ],
        "other_options": [
            "write-only",
            "delete",
            "update"
        ]
    },
    {
        "q": "Match API caching:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Cacheable",
            "Not cached",
            "Not cached",
            "Not cached"
        ]
    },
    {
        "q": "Rearrange API caching:",
        "type": "rearrange",
        "words": [
            "Identify cacheable endpoints",
            "Apply @cache_page",
            "Set appropriate TTL",
            "Monitor hit rate"
        ]
    },
    {
        "q": "Cache helps with slow external APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "External API cache?",
        "type": "mcq",
        "o": [
            "Store response locally",
            "Call every time",
            "Never cache",
            "Use database"
        ]
    },
    {
        "q": "External API cache reduces ______.",
        "type": "fill_blank",
        "answers": [
            "latency and costs"
        ],
        "other_options": [
            "security",
            "features",
            "accuracy"
        ]
    },
    {
        "q": "Match external API caching:",
        "type": "match",
        "left": [
            "rate limits",
            "latency",
            "cost",
            "reliability"
        ],
        "right": [
            "API restriction",
            "Time delay",
            "Money",
            "Uptime"
        ]
    },
    {
        "q": "Cache versioning handles schema changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Schema change invalidates?",
        "type": "mcq",
        "o": [
            "Old cached data",
            "New data",
            "All databases",
            "Nothing"
        ]
    },
    {
        "q": "Version bump clears ______ cache.",
        "type": "fill_blank",
        "answers": [
            "old"
        ],
        "other_options": [
            "new",
            "all",
            "no"
        ]
    },
    {
        "q": "Match versioning:",
        "type": "match",
        "left": [
            "VERSION",
            "KEY_PREFIX",
            "invalidate",
            "deploy"
        ],
        "right": [
            "Number",
            "String",
            "Clear",
            "Trigger"
        ]
    },
    {
        "q": "Rearrange version update:",
        "type": "rearrange",
        "words": [
            "Change data schema",
            "Increment VERSION",
            "Old cache ignored",
            "Fresh data cached"
        ]
    },
    {
        "q": "Cache can be tested.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Test cache with?",
        "type": "mcq",
        "o": [
            "LocMemCache or DummyCache",
            "Production cache",
            "No testing",
            "Database"
        ]
    },
    {
        "q": "Test isolation needs ______.",
        "type": "fill_blank",
        "answers": [
            "separate cache"
        ],
        "other_options": [
            "same cache",
            "no cache",
            "production cache"
        ]
    },
    {
        "q": "Match test caching:",
        "type": "match",
        "left": [
            "LocMemCache",
            "DummyCache",
            "isolation",
            "clear between tests"
        ],
        "right": [
            "Works",
            "No-op",
            "Requirement",
            "Best practice"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.test import TestCase, override_settings\nfrom django.core.cache import cache\n\n@override_settings(CACHES={'default': {'BACKEND': 'django.core.cache.backends.locmem.LocMemCache'}})\nclass CacheTest(TestCase):\n    def test_cache(self):\n        cache.set('key', 'value')\n        self.assertEqual(cache.get('key'), 'value')",
        "o": [
            "Tests with local memory cache",
            "Error",
            "Uses production cache",
            "Nothing"
        ]
    },
    {
        "q": "Cache clear between tests important.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Clear cache in?",
        "type": "mcq",
        "o": [
            "setUp or tearDown",
            "Test method only",
            "settings.py",
            "Never"
        ]
    },
    {
        "q": "cache.clear() in ______ method.",
        "type": "fill_blank",
        "answers": [
            "setUp"
        ],
        "other_options": [
            "test",
            "main",
            "run"
        ]
    },
    {
        "q": "Match test setup:",
        "type": "match",
        "left": [
            "setUp",
            "tearDown",
            "cache.clear()",
            "isolation"
        ],
        "right": [
            "Before test",
            "After test",
            "Clear cache",
            "Goal"
        ]
    },
    {
        "q": "Cache security is important.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache security concern?",
        "type": "mcq",
        "o": [
            "Sensitive data exposure",
            "Performance",
            "Memory usage",
            "Key length"
        ]
    },
    {
        "q": "Never cache ______ data.",
        "type": "fill_blank",
        "answers": [
            "sensitive"
        ],
        "other_options": [
            "public",
            "static",
            "common"
        ]
    },
    {
        "q": "Match cache security:",
        "type": "match",
        "left": [
            "passwords",
            "tokens",
            "PII",
            "public data"
        ],
        "right": [
            "Never cache",
            "Never cache",
            "Careful",
            "OK to cache"
        ]
    },
    {
        "q": "Rearrange security review:",
        "type": "rearrange",
        "words": [
            "Identify cached data",
            "Check for sensitive info",
            "Remove if present",
            "Use secure storage"
        ]
    },
    {
        "q": "Cache connection pooling improves performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Connection pooling for?",
        "type": "mcq",
        "o": [
            "Reusing connections",
            "New connection each time",
            "Single connection",
            "No connections"
        ]
    },
    {
        "q": "Pooling reduces ______ overhead.",
        "type": "fill_blank",
        "answers": [
            "connection"
        ],
        "other_options": [
            "cache",
            "data",
            "key"
        ]
    },
    {
        "q": "Match pooling:",
        "type": "match",
        "left": [
            "pool",
            "reuse",
            "overhead",
            "performance"
        ],
        "right": [
            "Collection",
            "Benefit",
            "Cost",
            "Improvement"
        ]
    },
    {
        "q": "Cache locality improves performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache locality means?",
        "type": "mcq",
        "o": [
            "Cache near the app",
            "Cache far away",
            "No cache",
            "Database cache"
        ]
    },
    {
        "q": "Local cache is ______.",
        "type": "fill_blank",
        "answers": [
            "faster"
        ],
        "other_options": [
            "slower",
            "same",
            "worse"
        ]
    },
    {
        "q": "Match cache locality:",
        "type": "match",
        "left": [
            "local",
            "remote",
            "network",
            "latency"
        ],
        "right": [
            "Same machine",
            "Different machine",
            "Connection",
            "Delay"
        ]
    },
    {
        "q": "Rearrange cache deployment:",
        "type": "rearrange",
        "words": [
            "Choose cache type",
            "Deploy cache server",
            "Configure Django",
            "Test performance"
        ]
    },
    {
        "q": "Cache can use async operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Async cache in Django?",
        "type": "mcq",
        "o": [
            "Django 4.1+",
            "Django 3.0",
            "Django 2.0",
            "Never"
        ]
    },
    {
        "q": "Async cache uses ______.",
        "type": "fill_blank",
        "answers": [
            "aset() and aget()"
        ],
        "other_options": [
            "set() and get()",
            "async_set()",
            "async_get()"
        ]
    },
    {
        "q": "Match async cache:",
        "type": "match",
        "left": [
            "aget()",
            "aset()",
            "adelete()",
            "await"
        ],
        "right": [
            "Async get",
            "Async set",
            "Async delete",
            "Required"
        ]
    },
    {
        "q": "Rearrange async cache usage:",
        "type": "rearrange",
        "words": [
            "Define async view",
            "await cache.aget()",
            "await cache.aset()",
            "Return response"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "async def my_view(request):\n    value = await cache.aget('key')\n    if value is None:\n        value = 'computed'\n        await cache.aset('key', value, 300)\n    return HttpResponse(value)",
        "o": [
            "Async cache usage",
            "Error",
            "Sync cache",
            "Nothing"
        ]
    },
    {
        "q": "Cache can store model instances.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Model caching uses?",
        "type": "mcq",
        "o": [
            "Pickle serialization",
            "JSON",
            "XML",
            "YAML"
        ]
    },
    {
        "q": "Model cache key includes ______.",
        "type": "fill_blank",
        "answers": [
            "model name and pk"
        ],
        "other_options": [
            "timestamp",
            "random",
            "session"
        ]
    },
    {
        "q": "Match model caching:",
        "type": "match",
        "left": [
            "pk",
            "serialization",
            "invalidation",
            "post_save"
        ],
        "right": [
            "Primary key",
            "Store",
            "Clear",
            "Signal"
        ]
    },
    {
        "q": "Cache can store function results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Function caching pattern?",
        "type": "mcq",
        "o": [
            "Memoization",
            "Iteration",
            "Recursion",
            "Iteration"
        ]
    },
    {
        "q": "Memoize means ______.",
        "type": "fill_blank",
        "answers": [
            "cache return values"
        ],
        "other_options": [
            "log calls",
            "track time",
            "count calls"
        ]
    },
    {
        "q": "Match memoization:",
        "type": "match",
        "left": [
            "function args",
            "cache key",
            "return value",
            "cached"
        ],
        "right": [
            "Input",
            "Identifier",
            "Stored",
            "Result"
        ]
    },
    {
        "q": "Rearrange memoization:",
        "type": "rearrange",
        "words": [
            "Generate key from args",
            "Check cache",
            "If miss compute",
            "Store result"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def cached_function(func):\n    def wrapper(*args):\n        key = f\"{func.__name__}_{args}\"\n        result = cache.get(key)\n        if result is None:\n            result = func(*args)\n            cache.set(key, result, 3600)\n        return result\n    return wrapper",
        "o": [
            "Memoization decorator",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache decorators can be combined.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Order matters for decorators?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Sometimes",
            "Depends"
        ]
    },
    {
        "q": "Decorators applied from ______.",
        "type": "fill_blank",
        "answers": [
            "bottom to top"
        ],
        "other_options": [
            "top to bottom",
            "random",
            "alphabetical"
        ]
    },
    {
        "q": "Match decorator order:",
        "type": "match",
        "left": [
            "bottom",
            "top",
            "inner",
            "outer"
        ],
        "right": [
            "First applied",
            "Last applied",
            "Closer to func",
            "Farther from func"
        ]
    },
    {
        "q": "Cache works with class-based views.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "CBV caching uses?",
        "type": "mcq",
        "o": [
            "method_decorator",
            "Direct @cache_page",
            "Mixin only",
            "Cannot cache"
        ]
    },
    {
        "q": "method_decorator from ______.",
        "type": "fill_blank",
        "answers": [
            "django.utils.decorators"
        ],
        "other_options": [
            "django.decorators",
            "django.views",
            "django.cache"
        ]
    },
    {
        "q": "Match CBV caching:",
        "type": "match",
        "left": [
            "method_decorator",
            "dispatch",
            "@cache_page",
            "CacheMixin"
        ],
        "right": [
            "Adapter",
            "Method",
            "Decorator",
            "Alternative"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "from django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import cache_page\n\n@method_decorator(cache_page(60 * 15), name='dispatch')\nclass MyView(View):\n    def get(self, request):\n        return HttpResponse('Hello')",
        "o": [
            "Caches CBV for 15 min",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Rearrange CBV caching:",
        "type": "rearrange",
        "words": [
            "Import method_decorator",
            "Apply to dispatch",
            "Set cache timeout",
            "View is cached"
        ]
    },
    {
        "q": "Cache can use custom serializers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Custom serializer for?",
        "type": "mcq",
        "o": [
            "Non-picklable objects",
            "Performance only",
            "Security only",
            "Compression only"
        ]
    },
    {
        "q": "JSON serializer is ______.",
        "type": "fill_blank",
        "answers": [
            "more secure"
        ],
        "other_options": [
            "faster",
            "bigger",
            "complex"
        ]
    },
    {
        "q": "Match serializers:",
        "type": "match",
        "left": [
            "pickle",
            "json",
            "msgpack",
            "security"
        ],
        "right": [
            "Default",
            "Safe",
            "Fast",
            "Concern"
        ]
    },
    {
        "q": "Cache key can use hash.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Hash for long keys?",
        "type": "mcq",
        "o": [
            "Yes, shortens key",
            "No, not needed",
            "Sometimes",
            "Never"
        ]
    },
    {
        "q": "MD5 hash creates ______ char key.",
        "type": "fill_blank",
        "answers": [
            "32"
        ],
        "other_options": [
            "16",
            "64",
            "128"
        ]
    },
    {
        "q": "Match hashing:",
        "type": "match",
        "left": [
            "md5",
            "sha256",
            "short",
            "collision"
        ],
        "right": [
            "32 chars",
            "64 chars",
            "Benefit",
            "Risk"
        ]
    },
    {
        "q": "Rearrange key hashing:",
        "type": "rearrange",
        "words": [
            "Combine key parts",
            "Hash long string",
            "Use hash as key",
            "Store in cache"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "import hashlib\n\ndef make_cache_key(*parts):\n    key = ':'.join(str(p) for p in parts)\n    return hashlib.md5(key.encode()).hexdigest()",
        "o": [
            "Creates short hash key",
            "Error",
            "Returns long key",
            "Nothing"
        ]
    },
    {
        "q": "Cache can track statistics.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Stats include?",
        "type": "mcq",
        "o": [
            "Hits, misses, size",
            "Users only",
            "URLs only",
            "Templates only"
        ]
    },
    {
        "q": "Hit ratio = hits / ______.",
        "type": "fill_blank",
        "answers": [
            "total requests"
        ],
        "other_options": [
            "misses",
            "keys",
            "time"
        ]
    },
    {
        "q": "Match cache stats:",
        "type": "match",
        "left": [
            "hits",
            "misses",
            "ratio",
            "memory"
        ],
        "right": [
            "Found",
            "Not found",
            "Percentage",
            "Usage"
        ]
    },
    {
        "q": "Cache can be wrapped with logging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Logging cache helps with?",
        "type": "mcq",
        "o": [
            "Debugging",
            "Security",
            "Speed",
            "Size"
        ]
    },
    {
        "q": "Log cache ______ and misses.",
        "type": "fill_blank",
        "answers": [
            "hits"
        ],
        "other_options": [
            "size",
            "time",
            "keys"
        ]
    },
    {
        "q": "Match logging:",
        "type": "match",
        "left": [
            "DEBUG",
            "INFO",
            "WARNING",
            "cache miss"
        ],
        "right": [
            "Detailed",
            "Normal",
            "Issue",
            "Logged event"
        ]
    },
    {
        "q": "Rearrange cache logging:",
        "type": "rearrange",
        "words": [
            "Wrap cache operations",
            "Log before get",
            "Log hit or miss",
            "Log after set"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "import logging\nfrom django.core.cache import cache as django_cache\n\nlogger = logging.getLogger(__name__)\n\ndef get_with_logging(key):\n    value = django_cache.get(key)\n    if value is None:\n        logger.debug(f'Cache miss: {key}')\n    else:\n        logger.debug(f'Cache hit: {key}')\n    return value",
        "o": [
            "Logs cache operations",
            "Error",
            "No logging",
            "Nothing"
        ]
    },
    {
        "q": "Cache can use tags for grouping.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache tags for?",
        "type": "mcq",
        "o": [
            "Group invalidation",
            "Performance",
            "Security",
            "Keys only"
        ]
    },
    {
        "q": "Tags require ______ backend.",
        "type": "fill_blank",
        "answers": [
            "supporting"
        ],
        "other_options": [
            "any",
            "file",
            "database"
        ]
    },
    {
        "q": "Match cache tags:",
        "type": "match",
        "left": [
            "tag",
            "group",
            "invalidate",
            "django-cache-machine"
        ],
        "right": [
            "Identifier",
            "Collection",
            "Clear",
            "Package"
        ]
    },
    {
        "q": "Cache can be mocked in tests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Mock cache for?",
        "type": "mcq",
        "o": [
            "Unit test isolation",
            "Performance",
            "Production",
            "Never"
        ]
    },
    {
        "q": "Mock prevents ______ side effects.",
        "type": "fill_blank",
        "answers": [
            "cache"
        ],
        "other_options": [
            "all",
            "database",
            "network"
        ]
    },
    {
        "q": "Match mocking:",
        "type": "match",
        "left": [
            "mock",
            "patch",
            "MagicMock",
            "isolation"
        ],
        "right": [
            "Fake",
            "Replace",
            "Auto mock",
            "Goal"
        ]
    },
    {
        "q": "Rearrange cache mocking:",
        "type": "rearrange",
        "words": [
            "Import mock",
            "Patch cache",
            "Run test",
            "Verify behavior"
        ]
    },
    {
        "q": "Cache improves page load time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Page load faster by?",
        "type": "mcq",
        "o": [
            "Avoiding computation",
            "More queries",
            "Larger responses",
            "More middleware"
        ]
    },
    {
        "q": "Response time measured in ______.",
        "type": "fill_blank",
        "answers": [
            "milliseconds"
        ],
        "other_options": [
            "seconds",
            "minutes",
            "hours"
        ]
    },
    {
        "q": "Match performance:",
        "type": "match",
        "left": [
            "TTFB",
            "cache hit",
            "faster",
            "user experience"
        ],
        "right": [
            "Time To First Byte",
            "Success",
            "Goal",
            "Improved"
        ]
    },
    {
        "q": "Cache reduces server load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Server load reduced by?",
        "type": "mcq",
        "o": [
            "Fewer computations",
            "More RAM",
            "More CPU",
            "More storage"
        ]
    },
    {
        "q": "High cache hit rate means ______ load.",
        "type": "fill_blank",
        "answers": [
            "lower"
        ],
        "other_options": [
            "higher",
            "same",
            "variable"
        ]
    },
    {
        "q": "Match load reduction:",
        "type": "match",
        "left": [
            "CPU",
            "database",
            "network",
            "cache"
        ],
        "right": [
            "Processing",
            "Queries",
            "Bandwidth",
            "Solution"
        ]
    },
    {
        "q": "Rearrange performance optimization:",
        "type": "rearrange",
        "words": [
            "Identify bottlenecks",
            "Implement caching",
            "Monitor improvement",
            "Adjust TTL"
        ]
    },
    {
        "q": "Cache can use multiple locations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Multiple LOCATION for?",
        "type": "mcq",
        "o": [
            "Distributed cache",
            "Single server only",
            "Backup",
            "Testing"
        ]
    },
    {
        "q": "Memcached LOCATION uses ______.",
        "type": "fill_blank",
        "answers": [
            "list of servers"
        ],
        "other_options": [
            "single server",
            "file path",
            "URL"
        ]
    },
    {
        "q": "Match multiple locations:",
        "type": "match",
        "left": [
            "LOCATION",
            "list",
            "distributed",
            "failover"
        ],
        "right": [
            "Setting",
            "Format",
            "Benefit",
            "Reliability"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "CACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',\n        'LOCATION': [\n            '127.0.0.1:11211',\n            '127.0.0.2:11211',\n        ],\n    }\n}",
        "o": [
            "Configures distributed Memcached",
            "Error",
            "Single server",
            "Nothing"
        ]
    },
    {
        "q": "Cache OPTIONS configure backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "OPTIONS include?",
        "type": "mcq",
        "o": [
            "MAX_ENTRIES, CULL_FREQUENCY",
            "URL only",
            "Key only",
            "Timeout only"
        ]
    },
    {
        "q": "OPTIONS is ______ in CACHES.",
        "type": "fill_blank",
        "answers": [
            "dictionary"
        ],
        "other_options": [
            "list",
            "string",
            "number"
        ]
    },
    {
        "q": "Match OPTIONS:",
        "type": "match",
        "left": [
            "MAX_ENTRIES",
            "CULL_FREQUENCY",
            "CLIENT_CLASS",
            "PICKLE_VERSION"
        ],
        "right": [
            "Max items",
            "Eviction",
            "Client",
            "Serialization"
        ]
    },
    {
        "q": "Rearrange cache configuration:",
        "type": "rearrange",
        "words": [
            "Set BACKEND",
            "Set LOCATION",
            "Configure OPTIONS",
            "Test connection"
        ]
    },
    {
        "q": "Cache can use socket connection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Unix socket for?",
        "type": "mcq",
        "o": [
            "Local connections",
            "Remote only",
            "Network only",
            "Never"
        ]
    },
    {
        "q": "Socket faster than ______.",
        "type": "fill_blank",
        "answers": [
            "TCP"
        ],
        "other_options": [
            "UDP",
            "HTTP",
            "FTP"
        ]
    },
    {
        "q": "Match socket:",
        "type": "match",
        "left": [
            "unix://.sock",
            "127.0.0.1:11211",
            "local",
            "network"
        ],
        "right": [
            "Socket",
            "TCP",
            "Fast",
            "Distributed"
        ]
    },
    {
        "q": "Cache can handle binary data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Binary data examples?",
        "type": "mcq",
        "o": [
            "Images, files, bytes",
            "Text only",
            "JSON only",
            "HTML only"
        ]
    },
    {
        "q": "Binary serialization via ______.",
        "type": "fill_blank",
        "answers": [
            "pickle"
        ],
        "other_options": [
            "json",
            "xml",
            "yaml"
        ]
    },
    {
        "q": "Match binary handling:",
        "type": "match",
        "left": [
            "bytes",
            "pickle",
            "base64",
            "encoding"
        ],
        "right": [
            "Type",
            "Serialize",
            "Text safe",
            "Convert"
        ]
    },
    {
        "q": "Rearrange binary caching:",
        "type": "rearrange",
        "words": [
            "Read binary data",
            "Serialize if needed",
            "Store in cache",
            "Deserialize on get"
        ]
    },
    {
        "q": "Cache can use connection pools.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Connection pool benefit?",
        "type": "mcq",
        "o": [
            "Reuse connections",
            "New connection each time",
            "Slower",
            "More memory"
        ]
    },
    {
        "q": "Pooling reduces ______ overhead.",
        "type": "fill_blank",
        "answers": [
            "connection establishment"
        ],
        "other_options": [
            "data",
            "key",
            "value"
        ]
    },
    {
        "q": "Match pooling:",
        "type": "match",
        "left": [
            "pool size",
            "reuse",
            "connection",
            "performance"
        ],
        "right": [
            "Limit",
            "Benefit",
            "Resource",
            "Goal"
        ]
    },
    {
        "q": "Cache helps with flash sales.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Flash sale challenge?",
        "type": "mcq",
        "o": [
            "High traffic spike",
            "Low traffic",
            "No traffic",
            "Consistent traffic"
        ]
    },
    {
        "q": "Pre-warm cache before ______.",
        "type": "fill_blank",
        "answers": [
            "sale starts"
        ],
        "other_options": [
            "sale ends",
            "deployment",
            "never"
        ]
    },
    {
        "q": "Match flash sale handling:",
        "type": "match",
        "left": [
            "warm",
            "scale",
            "distribute",
            "monitor"
        ],
        "right": [
            "Pre-populate",
            "Add capacity",
            "Use CDN",
            "Watch metrics"
        ]
    },
    {
        "q": "Rearrange flash sale prep:",
        "type": "rearrange",
        "words": [
            "Warm cache",
            "Scale infrastructure",
            "Monitor closely",
            "Handle gracefully"
        ]
    },
    {
        "q": "Cache helps with personalization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Personalized cache key?",
        "type": "mcq",
        "o": [
            "Includes user ID",
            "Same for all",
            "Random",
            "Timestamp only"
        ]
    },
    {
        "q": "Per-user cache uses ______.",
        "type": "fill_blank",
        "answers": [
            "user.id in key"
        ],
        "other_options": [
            "same key",
            "timestamp",
            "random"
        ]
    },
    {
        "q": "Match personalization:",
        "type": "match",
        "left": [
            "user.id",
            "preferences",
            "recommendations",
            "per-user"
        ],
        "right": [
            "Identifier",
            "Settings",
            "Suggestions",
            "Cache type"
        ]
    },
    {
        "q": "Cache helps with search results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Search cache key includes?",
        "type": "mcq",
        "o": [
            "Query string",
            "User only",
            "Timestamp only",
            "Random"
        ]
    },
    {
        "q": "Cache popular search ______.",
        "type": "fill_blank",
        "answers": [
            "queries"
        ],
        "other_options": [
            "users",
            "pages",
            "errors"
        ]
    },
    {
        "q": "Match search caching:",
        "type": "match",
        "left": [
            "query",
            "results",
            "TTL",
            "invalidate"
        ],
        "right": [
            "Key",
            "Value",
            "Expiry",
            "On change"
        ]
    },
    {
        "q": "Rearrange search caching:",
        "type": "rearrange",
        "words": [
            "Hash search query",
            "Check cache",
            "If miss query search",
            "Store results"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def cached_search(query):\n    key = f'search_{hashlib.md5(query.encode()).hexdigest()}'\n    results = cache.get(key)\n    if results is None:\n        results = SearchEngine.search(query)\n        cache.set(key, results, 3600)\n    return results",
        "o": [
            "Caches search results",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache helps with reports.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Report caching for?",
        "type": "mcq",
        "o": [
            "Expensive aggregations",
            "Simple queries",
            "User data",
            "Forms"
        ]
    },
    {
        "q": "Report cache TTL often ______.",
        "type": "fill_blank",
        "answers": [
            "longer"
        ],
        "other_options": [
            "shorter",
            "instant",
            "never"
        ]
    },
    {
        "q": "Match report caching:",
        "type": "match",
        "left": [
            "aggregate",
            "expensive",
            "schedule",
            "background"
        ],
        "right": [
            "Computation",
            "Worth caching",
            "Refresh",
            "Task"
        ]
    },
    {
        "q": "Cache can be refreshed in background.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Background refresh uses?",
        "type": "mcq",
        "o": [
            "Celery task",
            "View",
            "Template",
            "Never"
        ]
    },
    {
        "q": "Background refresh avoids ______.",
        "type": "fill_blank",
        "answers": [
            "user wait"
        ],
        "other_options": [
            "caching",
            "serving",
            "all"
        ]
    },
    {
        "q": "Match background refresh:",
        "type": "match",
        "left": [
            "Celery",
            "periodic",
            "async",
            "user"
        ],
        "right": [
            "Task queue",
            "Schedule",
            "Non-blocking",
            "Not waiting"
        ]
    },
    {
        "q": "Rearrange background refresh:",
        "type": "rearrange",
        "words": [
            "Schedule Celery task",
            "Compute new value",
            "Update cache",
            "Next request gets fresh"
        ]
    },
    {
        "q": "Cache helps with menu/navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Menu cache benefit?",
        "type": "mcq",
        "o": [
            "Avoids DB query per request",
            "Slower",
            "More queries",
            "No benefit"
        ]
    },
    {
        "q": "Menu rarely changes so ______ TTL.",
        "type": "fill_blank",
        "answers": [
            "long"
        ],
        "other_options": [
            "short",
            "no",
            "instant"
        ]
    },
    {
        "q": "Match menu caching:",
        "type": "match",
        "left": [
            "navigation",
            "categories",
            "links",
            "static"
        ],
        "right": [
            "Menu",
            "Hierarchy",
            "URLs",
            "Good for cache"
        ]
    },
    {
        "q": "Cache helps with configuration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Config cache for?",
        "type": "mcq",
        "o": [
            "Infrequently changing settings",
            "User input",
            "Forms",
            "Sessions"
        ]
    },
    {
        "q": "Config cache avoids ______ every request.",
        "type": "fill_blank",
        "answers": [
            "database lookup"
        ],
        "other_options": [
            "caching",
            "rendering",
            "routing"
        ]
    },
    {
        "q": "Match config caching:",
        "type": "match",
        "left": [
            "settings",
            "features",
            "toggles",
            "database"
        ],
        "right": [
            "Config",
            "Flags",
            "On/off",
            "Source"
        ]
    },
    {
        "q": "Rearrange config caching:",
        "type": "rearrange",
        "words": [
            "Load config from DB",
            "Cache with long TTL",
            "Access from cache",
            "Invalidate on change"
        ]
    },
    {
        "q": "Cache can use prefix for app isolation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "App isolation via?",
        "type": "mcq",
        "o": [
            "KEY_PREFIX",
            "Different backends",
            "No isolation",
            "Timestamps"
        ]
    },
    {
        "q": "Each app uses unique ______.",
        "type": "fill_blank",
        "answers": [
            "prefix"
        ],
        "other_options": [
            "backend",
            "server",
            "timeout"
        ]
    },
    {
        "q": "Match isolation:",
        "type": "match",
        "left": [
            "prefix",
            "namespace",
            "collision",
            "unique"
        ],
        "right": [
            "Start",
            "Grouping",
            "Avoid",
            "Goal"
        ]
    },
    {
        "q": "Cache helps with i18n content.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "i18n cache varies by?",
        "type": "mcq",
        "o": [
            "Language code",
            "User only",
            "IP only",
            "Random"
        ]
    },
    {
        "q": "Cache key includes ______.",
        "type": "fill_blank",
        "answers": [
            "language code"
        ],
        "other_options": [
            "user only",
            "IP",
            "timestamp"
        ]
    },
    {
        "q": "Match i18n caching:",
        "type": "match",
        "left": [
            "language",
            "translation",
            "vary",
            "Accept-Language"
        ],
        "right": [
            "Key part",
            "Content",
            "Decorator",
            "Header"
        ]
    },
    {
        "q": "Rearrange i18n caching:",
        "type": "rearrange",
        "words": [
            "Get language code",
            "Include in cache key",
            "Store translated content",
            "Serve correct language"
        ]
    },
    {
        "q": "Cache can use Read-Through pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Read-Through means?",
        "type": "mcq",
        "o": [
            "Cache automatically fetches on miss",
            "Always query database",
            "Never cache",
            "Random"
        ]
    },
    {
        "q": "Read-Through simplifies ______.",
        "type": "fill_blank",
        "answers": [
            "application code"
        ],
        "other_options": [
            "database",
            "caching",
            "all"
        ]
    },
    {
        "q": "Match Read-Through:",
        "type": "match",
        "left": [
            "miss",
            "fetch",
            "store",
            "return"
        ],
        "right": [
            "Not found",
            "Get from source",
            "Cache",
            "To caller"
        ]
    },
    {
        "q": "Cache can use Write-Behind pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Write-Behind means?",
        "type": "mcq",
        "o": [
            "Async write to database",
            "Sync write",
            "No write",
            "Random"
        ]
    },
    {
        "q": "Write-Behind improves ______ speed.",
        "type": "fill_blank",
        "answers": [
            "write"
        ],
        "other_options": [
            "read",
            "both",
            "neither"
        ]
    },
    {
        "q": "Match Write-Behind:",
        "type": "match",
        "left": [
            "cache first",
            "async",
            "queue",
            "database later"
        ],
        "right": [
            "Write to",
            "Style",
            "Batch",
            "Persistence"
        ]
    },
    {
        "q": "Rearrange Write-Behind:",
        "type": "rearrange",
        "words": [
            "Write to cache",
            "Queue database write",
            "Process async",
            "Data persisted"
        ]
    },
    {
        "q": "Django caching is powerful.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Best cache strategy depends on?",
        "type": "mcq",
        "o": [
            "Use case",
            "Always Redis",
            "Always Memcached",
            "Always file"
        ]
    },
    {
        "q": "Choose cache based on ______.",
        "type": "fill_blank",
        "answers": [
            "requirements"
        ],
        "other_options": [
            "random",
            "default",
            "price"
        ]
    },
    {
        "q": "Match cache choice factors:",
        "type": "match",
        "left": [
            "performance",
            "persistence",
            "features",
            "cost"
        ],
        "right": [
            "Speed",
            "Data safety",
            "Capabilities",
            "Budget"
        ]
    },
    {
        "q": "Rearrange cache implementation:",
        "type": "rearrange",
        "words": [
            "Analyze requirements",
            "Choose backend",
            "Implement caching",
            "Monitor and optimize"
        ]
    },
    {
        "q": "Probabilistic early expiration prevents stampedes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Early expiration means?",
        "type": "mcq",
        "o": [
            "Refresh before actual expiry",
            "Never expire",
            "Expire immediately",
            "Random expiry"
        ]
    },
    {
        "q": "Refresh at ______ before TTL ends.",
        "type": "fill_blank",
        "answers": [
            "random time"
        ],
        "other_options": [
            "exact time",
            "fixed time",
            "never"
        ]
    },
    {
        "q": "Match stampede prevention:",
        "type": "match",
        "left": [
            "probabilistic",
            "locking",
            "stale-while-revalidate",
            "background"
        ],
        "right": [
            "Random",
            "Serialize",
            "Serve old",
            "Async"
        ]
    },
    {
        "q": "Rearrange early expiration:",
        "type": "rearrange",
        "words": [
            "Check remaining TTL",
            "Calculate probability",
            "Maybe refresh early",
            "Prevent all at once"
        ]
    },
    {
        "q": "Cache can store null values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Null caching prevents?",
        "type": "mcq",
        "o": [
            "Negative caching attacks",
            "Positive caching",
            "All caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache None to avoid repeated ______.",
        "type": "fill_blank",
        "answers": [
            "lookups for missing keys"
        ],
        "other_options": [
            "hits",
            "connections",
            "timeouts"
        ]
    },
    {
        "q": "Match null caching:",
        "type": "match",
        "left": [
            "None",
            "sentinel",
            "distinguish",
            "short TTL"
        ],
        "right": [
            "Cached value",
            "Special marker",
            "From miss",
            "For nulls"
        ]
    },
    {
        "q": "Cache can implement sliding expiration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Sliding expiration means?",
        "type": "mcq",
        "o": [
            "Reset TTL on access",
            "Fixed TTL",
            "No expiry",
            "Random expiry"
        ]
    },
    {
        "q": "Sliding keeps ______ items longer.",
        "type": "fill_blank",
        "answers": [
            "frequently accessed"
        ],
        "other_options": [
            "old",
            "random",
            "all"
        ]
    },
    {
        "q": "Match expiration types:",
        "type": "match",
        "left": [
            "absolute",
            "sliding",
            "hybrid",
            "touch()"
        ],
        "right": [
            "Fixed",
            "Reset",
            "Both",
            "Django method"
        ]
    },
    {
        "q": "Rearrange sliding expiration:",
        "type": "rearrange",
        "words": [
            "Get from cache",
            "If hit touch()",
            "Extends TTL",
            "Stays cached longer"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def get_with_sliding(key):\n    value = cache.get(key)\n    if value is not None:\n        cache.touch(key, 300)\n    return value",
        "o": [
            "Implements sliding expiration",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache can use priority eviction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Priority eviction keeps?",
        "type": "mcq",
        "o": [
            "Important items longer",
            "All items same",
            "Random items",
            "Nothing"
        ]
    },
    {
        "q": "High priority items have ______ TTL.",
        "type": "fill_blank",
        "answers": [
            "longer"
        ],
        "other_options": [
            "shorter",
            "same",
            "no"
        ]
    },
    {
        "q": "Match priority:",
        "type": "match",
        "left": [
            "high",
            "normal",
            "low",
            "TTL"
        ],
        "right": [
            "Long",
            "Medium",
            "Short",
            "Varies"
        ]
    },
    {
        "q": "Lazy loading is cache-aside pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Lazy loading loads?",
        "type": "mcq",
        "o": [
            "On demand",
            "Upfront",
            "Never",
            "Random"
        ]
    },
    {
        "q": "Lazy means ______ until needed.",
        "type": "fill_blank",
        "answers": [
            "defer"
        ],
        "other_options": [
            "never",
            "always",
            "sometimes"
        ]
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "lazy",
            "eager",
            "on-demand",
            "pre-load"
        ],
        "right": [
            "Cache-aside",
            "Warming",
            "Lazy",
            "Eager"
        ]
    },
    {
        "q": "Eager loading pre-populates cache.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Eager loading benefit?",
        "type": "mcq",
        "o": [
            "No cold start",
            "Less memory",
            "Simpler code",
            "No benefit"
        ]
    },
    {
        "q": "Eager loads during ______.",
        "type": "fill_blank",
        "answers": [
            "startup or deployment"
        ],
        "other_options": [
            "runtime",
            "never",
            "random"
        ]
    },
    {
        "q": "Match eager loading:",
        "type": "match",
        "left": [
            "startup",
            "deployment",
            "warm",
            "ready"
        ],
        "right": [
            "When",
            "When",
            "Action",
            "State"
        ]
    },
    {
        "q": "Rearrange eager loading:",
        "type": "rearrange",
        "words": [
            "Deploy app",
            "Run warmup script",
            "Cache populated",
            "Ready for traffic"
        ]
    },
    {
        "q": "Cache metrics include latency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Latency measures?",
        "type": "mcq",
        "o": [
            "Response time",
            "Hit rate",
            "Memory",
            "Keys"
        ]
    },
    {
        "q": "Low latency means ______ response.",
        "type": "fill_blank",
        "answers": [
            "fast"
        ],
        "other_options": [
            "slow",
            "same",
            "no"
        ]
    },
    {
        "q": "Match metrics:",
        "type": "match",
        "left": [
            "latency",
            "throughput",
            "hit rate",
            "memory"
        ],
        "right": [
            "Speed",
            "Volume",
            "Success",
            "Usage"
        ]
    },
    {
        "q": "Cache should be resilient.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Resilience means?",
        "type": "mcq",
        "o": [
            "Handle failures gracefully",
            "Never fail",
            "Ignore errors",
            "Restart always"
        ]
    },
    {
        "q": "If cache fails use ______.",
        "type": "fill_blank",
        "answers": [
            "fallback"
        ],
        "other_options": [
            "nothing",
            "error",
            "crash"
        ]
    },
    {
        "q": "Match resilience:",
        "type": "match",
        "left": [
            "fallback",
            "retry",
            "circuit breaker",
            "timeout"
        ],
        "right": [
            "Backup",
            "Again",
            "Limit",
            "Boundary"
        ]
    },
    {
        "q": "Rearrange resilient caching:",
        "type": "rearrange",
        "words": [
            "Try cache operation",
            "If fails use fallback",
            "Log error",
            "Continue working"
        ]
    },
    {
        "q": "Cache can be sized appropriately.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Cache size based on?",
        "type": "mcq",
        "o": [
            "Working set and memory",
            "Random",
            "Always maximum",
            "Minimum"
        ]
    },
    {
        "q": "Right size prevents ______ and waste.",
        "type": "fill_blank",
        "answers": [
            "thrashing"
        ],
        "other_options": [
            "caching",
            "hits",
            "misses"
        ]
    },
    {
        "q": "Match sizing:",
        "type": "match",
        "left": [
            "working set",
            "memory",
            "eviction",
            "monitoring"
        ],
        "right": [
            "Active data",
            "Resource",
            "When full",
            "Track"
        ]
    },
    {
        "q": "Cache keys should be URL-safe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "URL-safe means?",
        "type": "mcq",
        "o": [
            "No special characters",
            "Any characters",
            "Only numbers",
            "Only letters"
        ]
    },
    {
        "q": "Avoid spaces and ______ in keys.",
        "type": "fill_blank",
        "answers": [
            "special characters"
        ],
        "other_options": [
            "letters",
            "numbers",
            "underscores"
        ]
    },
    {
        "q": "Match key characters:",
        "type": "match",
        "left": [
            "alphanumeric",
            "underscore",
            "colon",
            "avoid"
        ],
        "right": [
            "Safe",
            "Safe",
            "Safe",
            "Spaces/specials"
        ]
    },
    {
        "q": "Rearrange key creation:",
        "type": "rearrange",
        "words": [
            "Identify components",
            "Join with safe delimiter",
            "Hash if too long",
            "Use as cache key"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def safe_key(prefix, *parts):\n    safe_parts = [str(p).replace(' ', '_') for p in parts]\n    return f\"{prefix}:{'_'.join(safe_parts)}\"",
        "o": [
            "Creates URL-safe key",
            "Error",
            "Unsafe key",
            "Nothing"
        ]
    },
    {
        "q": "Cache can implement tiered storage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Tiered storage means?",
        "type": "mcq",
        "o": [
            "Multiple cache levels",
            "Single cache",
            "No cache",
            "Database only"
        ]
    },
    {
        "q": "L1 cache is ______ than L2.",
        "type": "fill_blank",
        "answers": [
            "faster"
        ],
        "other_options": [
            "slower",
            "same",
            "larger"
        ]
    },
    {
        "q": "Match tiers:",
        "type": "match",
        "left": [
            "L1",
            "L2",
            "local",
            "distributed"
        ],
        "right": [
            "Fastest",
            "Slower",
            "Process",
            "Shared"
        ]
    },
    {
        "q": "Cache documentation is important.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Document what?",
        "type": "mcq",
        "o": [
            "Keys, TTL, invalidation",
            "Nothing",
            "Code only",
            "Tests only"
        ]
    },
    {
        "q": "Document cache ______.",
        "type": "fill_blank",
        "answers": [
            "strategy"
        ],
        "other_options": [
            "location",
            "size",
            "type"
        ]
    },
    {
        "q": "Match documentation:",
        "type": "match",
        "left": [
            "key format",
            "TTL",
            "invalidation",
            "dependencies"
        ],
        "right": [
            "Structure",
            "Duration",
            "When to clear",
            "What affects"
        ]
    },
    {
        "q": "Rearrange cache documentation:",
        "type": "rearrange",
        "words": [
            "Describe key format",
            "Note TTL values",
            "Explain invalidation",
            "List dependencies"
        ]
    },
    {
        "q": "Cache affects consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Consistency challenge?",
        "type": "mcq",
        "o": [
            "Stale data",
            "Fast response",
            "Less load",
            "More memory"
        ]
    },
    {
        "q": "Trade consistency for ______.",
        "type": "fill_blank",
        "answers": [
            "performance"
        ],
        "other_options": [
            "security",
            "simplicity",
            "nothing"
        ]
    },
    {
        "q": "Match consistency:",
        "type": "match",
        "left": [
            "eventual",
            "strong",
            "stale",
            "fresh"
        ],
        "right": [
            "Later",
            "Immediate",
            "Old",
            "New"
        ]
    },
    {
        "q": "Eventually consistent caching is common.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Eventually consistent means?",
        "type": "mcq",
        "o": [
            "Update propagates over time",
            "Always fresh",
            "Never fresh",
            "Random"
        ]
    },
    {
        "q": "Accept eventual consistency for ______.",
        "type": "fill_blank",
        "answers": [
            "better performance"
        ],
        "other_options": [
            "security",
            "consistency",
            "nothing"
        ]
    },
    {
        "q": "Match consistency models:",
        "type": "match",
        "left": [
            "strong",
            "eventual",
            "causal",
            "read-your-writes"
        ],
        "right": [
            "Always fresh",
            "Eventually",
            "Order",
            "Own updates"
        ]
    },
    {
        "q": "Rearrange consistency decision:",
        "type": "rearrange",
        "words": [
            "Analyze requirements",
            "Choose consistency level",
            "Accept tradeoff",
            "Implement caching"
        ]
    },
    {
        "q": "Cache helps with rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rate limiting with cache stores?",
        "type": "mcq",
        "o": [
            "Request counts",
            "User data",
            "Templates",
            "Forms"
        ]
    },
    {
        "q": "Rate limit by ______ or IP.",
        "type": "fill_blank",
        "answers": [
            "user"
        ],
        "other_options": [
            "URL",
            "path",
            "template"
        ]
    },
    {
        "q": "Match rate limiting:",
        "type": "match",
        "left": [
            "counter",
            "window",
            "limit",
            "429"
        ],
        "right": [
            "Count",
            "Time period",
            "Threshold",
            "Status code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def check_rate_limit(user_id, limit=100):\n    key = f'rate_limit_{user_id}'\n    count = cache.get(key, 0)\n    if count >= limit:\n        return False\n    cache.set(key, count + 1, 60)\n    return True",
        "o": [
            "Implements rate limiting",
            "Error",
            "No limiting",
            "Nothing"
        ]
    },
    {
        "q": "Cache helps with locking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Distributed locking with?",
        "type": "mcq",
        "o": [
            "Redis or Memcached",
            "Database only",
            "Files only",
            "Never"
        ]
    },
    {
        "q": "Lock prevents ______ access.",
        "type": "fill_blank",
        "answers": [
            "concurrent"
        ],
        "other_options": [
            "all",
            "single",
            "no"
        ]
    },
    {
        "q": "Match locking:",
        "type": "match",
        "left": [
            "lock",
            "unlock",
            "timeout",
            "deadlock"
        ],
        "right": [
            "Acquire",
            "Release",
            "Safety",
            "Problem"
        ]
    },
    {
        "q": "Rearrange distributed locking:",
        "type": "rearrange",
        "words": [
            "Try acquire lock",
            "If success do work",
            "Release when done",
            "If fail retry or skip"
        ]
    },
    {
        "q": "Cache helps with counters.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Atomic counter operations?",
        "type": "mcq",
        "o": [
            "incr() and decr()",
            "set() only",
            "get() only",
            "None"
        ]
    },
    {
        "q": "Counters are ______.",
        "type": "fill_blank",
        "answers": [
            "atomic"
        ],
        "other_options": [
            "slow",
            "complex",
            "unsafe"
        ]
    },
    {
        "q": "Match counters:",
        "type": "match",
        "left": [
            "incr()",
            "decr()",
            "atomic",
            "race condition"
        ],
        "right": [
            "Add",
            "Subtract",
            "Safe",
            "Avoided"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def increment_page_views(page_id):\n    key = f'views_{page_id}'\n    try:\n        return cache.incr(key)\n    except ValueError:\n        cache.set(key, 1)\n        return 1",
        "o": [
            "Atomic page view counter",
            "Error",
            "No counting",
            "Nothing"
        ]
    },
    {
        "q": "Cache helps with feature flags.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Feature flags store?",
        "type": "mcq",
        "o": [
            "Boolean settings",
            "User data",
            "Templates",
            "Forms"
        ]
    },
    {
        "q": "Feature flags control ______.",
        "type": "fill_blank",
        "answers": [
            "feature visibility"
        ],
        "other_options": [
            "performance",
            "security",
            "data"
        ]
    },
    {
        "q": "Match feature flags:",
        "type": "match",
        "left": [
            "enabled",
            "disabled",
            "percentage",
            "rollout"
        ],
        "right": [
            "On",
            "Off",
            "Partial",
            "Gradual"
        ]
    },
    {
        "q": "Rearrange feature flag caching:",
        "type": "rearrange",
        "words": [
            "Check cache for flag",
            "If miss check database",
            "Cache flag value",
            "Use in code"
        ]
    },
    {
        "q": "Cache can use pub/sub.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Pub/sub for?",
        "type": "mcq",
        "o": [
            "Cache invalidation broadcasts",
            "Data storage",
            "Key generation",
            "TTL"
        ]
    },
    {
        "q": "Pub/sub notifies ______.",
        "type": "fill_blank",
        "answers": [
            "multiple subscribers"
        ],
        "other_options": [
            "one client",
            "database",
            "nothing"
        ]
    },
    {
        "q": "Match pub/sub:",
        "type": "match",
        "left": [
            "publish",
            "subscribe",
            "channel",
            "message"
        ],
        "right": [
            "Send",
            "Listen",
            "Topic",
            "Data"
        ]
    },
    {
        "q": "Cache complexity should match needs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Start with?",
        "type": "mcq",
        "o": [
            "Simple caching",
            "Complex patterns",
            "No caching",
            "Maximum features"
        ]
    },
    {
        "q": "Add complexity only when ______.",
        "type": "fill_blank",
        "answers": [
            "needed"
        ],
        "other_options": [
            "always",
            "never",
            "randomly"
        ]
    },
    {
        "q": "Match complexity:",
        "type": "match",
        "left": [
            "simple",
            "medium",
            "complex",
            "YAGNI"
        ],
        "right": [
            "Start here",
            "Grow to",
            "If needed",
            "Don't over-engineer"
        ]
    },
    {
        "q": "Rearrange caching evolution:",
        "type": "rearrange",
        "words": [
            "Start simple",
            "Monitor performance",
            "Add complexity if needed",
            "Keep iterating"
        ]
    },
    {
        "q": "Cache is essential for scale.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Scale means?",
        "type": "mcq",
        "o": [
            "Handle more traffic",
            "Less traffic",
            "Smaller app",
            "No users"
        ]
    },
    {
        "q": "Caching enables ______ scale.",
        "type": "fill_blank",
        "answers": [
            "horizontal"
        ],
        "other_options": [
            "vertical",
            "no",
            "limited"
        ]
    },
    {
        "q": "Match scaling:",
        "type": "match",
        "left": [
            "horizontal",
            "vertical",
            "distributed",
            "stateless"
        ],
        "right": [
            "Add servers",
            "Bigger server",
            "Shared cache",
            "No local state"
        ]
    },
    {
        "q": "Django cache framework is flexible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Flexibility from?",
        "type": "mcq",
        "o": [
            "Multiple backends and options",
            "Single backend",
            "No options",
            "Fixed settings"
        ]
    },
    {
        "q": "Choose backend based on ______.",
        "type": "fill_blank",
        "answers": [
            "requirements"
        ],
        "other_options": [
            "random",
            "default",
            "none"
        ]
    },
    {
        "q": "Match flexibility:",
        "type": "match",
        "left": [
            "backends",
            "options",
            "decorators",
            "low-level"
        ],
        "right": [
            "Types",
            "Configuration",
            "Views",
            "Fine control"
        ]
    },
    {
        "q": "Rearrange cache best practices:",
        "type": "rearrange",
        "words": [
            "Understand data access patterns",
            "Choose right strategy",
            "Implement correctly",
            "Monitor and adjust"
        ]
    },
    {
        "q": "request.session uses cache backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Session cache engine?",
        "type": "mcq",
        "o": [
            "django.contrib.sessions.backends.cache",
            "django.sessions.cache",
            "django.cache.sessions",
            "django.core.sessions"
        ]
    },
    {
        "q": "Session location set by ______.",
        "type": "fill_blank",
        "answers": [
            "SESSION_CACHE_ALIAS"
        ],
        "other_options": [
            "SESSION_ENGINE",
            "CACHE_ALIAS",
            "SESSION_KEY"
        ]
    },
    {
        "q": "Match session caching:",
        "type": "match",
        "left": [
            "cache",
            "cached_db",
            "fast",
            "persistent"
        ],
        "right": [
            "Memory only",
            "With DB backup",
            "Benefit",
            "cached_db benefit"
        ]
    },
    {
        "q": "Rearrange session setup:",
        "type": "rearrange",
        "words": [
            "Set SESSION_ENGINE",
            "Set SESSION_CACHE_ALIAS",
            "Sessions use cache",
            "Fast access"
        ]
    },
    {
        "q": "Cache key function customizable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "KEY_FUNCTION accepts?",
        "type": "mcq",
        "o": [
            "Callable",
            "String only",
            "Integer",
            "List"
        ]
    },
    {
        "q": "KEY_FUNCTION receives key, ______, version.",
        "type": "fill_blank",
        "answers": [
            "key_prefix"
        ],
        "other_options": [
            "timeout",
            "backend",
            "location"
        ]
    },
    {
        "q": "Match key function:",
        "type": "match",
        "left": [
            "key",
            "key_prefix",
            "version",
            "return"
        ],
        "right": [
            "Original",
            "Prefix",
            "Number",
            "Final key"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def custom_key_func(key, key_prefix, version):\n    return f\"{key_prefix}:{version}:{key}\"",
        "o": [
            "Custom key format",
            "Error",
            "Default format",
            "Nothing"
        ]
    },
    {
        "q": "Cache can handle connection errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Connection error handling?",
        "type": "mcq",
        "o": [
            "Try/except with fallback",
            "Ignore",
            "Crash",
            "Restart"
        ]
    },
    {
        "q": "Graceful degradation on ______.",
        "type": "fill_blank",
        "answers": [
            "cache failure"
        ],
        "other_options": [
            "success",
            "hit",
            "get"
        ]
    },
    {
        "q": "Match error handling:",
        "type": "match",
        "left": [
            "try",
            "except",
            "fallback",
            "log"
        ],
        "right": [
            "Attempt",
            "Catch",
            "Alternative",
            "Record"
        ]
    },
    {
        "q": "Rearrange error handling:",
        "type": "rearrange",
        "words": [
            "Try cache operation",
            "Catch exception",
            "Use fallback",
            "Log error"
        ]
    },
    {
        "q": "Cache prefixes avoid collisions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Collision means?",
        "type": "mcq",
        "o": [
            "Same key for different data",
            "Different keys",
            "No caching",
            "Fast access"
        ]
    },
    {
        "q": "Prefix with app name or ______.",
        "type": "fill_blank",
        "answers": [
            "module"
        ],
        "other_options": [
            "random",
            "timestamp",
            "user"
        ]
    },
    {
        "q": "Match prefix benefits:",
        "type": "match",
        "left": [
            "unique",
            "organized",
            "clear",
            "avoid"
        ],
        "right": [
            "No collision",
            "Structure",
            "Purpose",
            "Conflicts"
        ]
    },
    {
        "q": "Cache can store paginated results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Pagination cache key includes?",
        "type": "mcq",
        "o": [
            "Page number",
            "User only",
            "Random",
            "Timestamp only"
        ]
    },
    {
        "q": "Cache page 1, page 2 with ______ key.",
        "type": "fill_blank",
        "answers": [
            "different"
        ],
        "other_options": [
            "same",
            "random",
            "no"
        ]
    },
    {
        "q": "Match pagination caching:",
        "type": "match",
        "left": [
            "page",
            "per_page",
            "key",
            "TTL"
        ],
        "right": [
            "Number",
            "Size",
            "Unique",
            "Expiry"
        ]
    },
    {
        "q": "Rearrange pagination caching:",
        "type": "rearrange",
        "words": [
            "Get page number",
            "Include in cache key",
            "Check cache",
            "Store if miss"
        ]
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "def get_articles_page(page_num):\n    key = f'articles_page_{page_num}'\n    data = cache.get(key)\n    if data is None:\n        data = list(Article.objects.all()[page_num*10:(page_num+1)*10])\n        cache.set(key, data, 300)\n    return data",
        "o": [
            "Caches paginated results",
            "Error",
            "No caching",
            "Nothing"
        ]
    },
    {
        "q": "Cache can use read replicas.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Read replica for?",
        "type": "mcq",
        "o": [
            "Scaling reads",
            "Scaling writes",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "Replicas help with ______ load.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "write",
            "both",
            "no"
        ]
    },
    {
        "q": "Match replicas:",
        "type": "match",
        "left": [
            "primary",
            "replica",
            "read",
            "write"
        ],
        "right": [
            "Master",
            "Copy",
            "Replica",
            "Primary"
        ]
    },
    {
        "q": "Cache helps with user preferences.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "User prefs cache key?",
        "type": "mcq",
        "o": [
            "Includes user ID",
            "Same for all",
            "Random",
            "Timestamp"
        ]
    },
    {
        "q": "Per-user preferences use ______ key.",
        "type": "fill_blank",
        "answers": [
            "user-specific"
        ],
        "other_options": [
            "global",
            "shared",
            "random"
        ]
    },
    {
        "q": "Match user caching:",
        "type": "match",
        "left": [
            "user.id",
            "preferences",
            "settings",
            "profile"
        ],
        "right": [
            "Key part",
            "Data",
            "Data",
            "Data"
        ]
    },
    {
        "q": "Rearrange user preference caching:",
        "type": "rearrange",
        "words": [
            "Get user ID",
            "Build cache key",
            "Check cache",
            "Load preferences"
        ]
    },
    {
        "q": "Cache helps with permissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Permission caching speeds up?",
        "type": "mcq",
        "o": [
            "Authorization checks",
            "Authentication",
            "Templates",
            "Forms"
        ]
    },
    {
        "q": "Cache user permissions to avoid ______.",
        "type": "fill_blank",
        "answers": [
            "database queries"
        ],
        "other_options": [
            "caching",
            "rendering",
            "routing"
        ]
    },
    {
        "q": "Match permission caching:",
        "type": "match",
        "left": [
            "permissions",
            "groups",
            "invalidate",
            "on change"
        ],
        "right": [
            "Data",
            "Data",
            "Clear",
            "When"
        ]
    },
    {
        "q": "Cache can implement request coalescing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Coalescing means?",
        "type": "mcq",
        "o": [
            "Combine duplicate requests",
            "Separate requests",
            "Ignore requests",
            "Queue all"
        ]
    },
    {
        "q": "Coalescing prevents ______ computation.",
        "type": "fill_blank",
        "answers": [
            "duplicate"
        ],
        "other_options": [
            "all",
            "no",
            "single"
        ]
    },
    {
        "q": "Match coalescing:",
        "type": "match",
        "left": [
            "lock",
            "wait",
            "result",
            "share"
        ],
        "right": [
            "First gets",
            "Others wait",
            "Computed once",
            "Among all"
        ]
    },
    {
        "q": "Rearrange request coalescing:",
        "type": "rearrange",
        "words": [
            "First request gets lock",
            "Others wait",
            "First computes",
            "All get result"
        ]
    },
    {
        "q": "Cache improves user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "UX improvement from?",
        "type": "mcq",
        "o": [
            "Faster responses",
            "More features",
            "Better design",
            "More data"
        ]
    },
    {
        "q": "Fast pages keep users ______.",
        "type": "fill_blank",
        "answers": [
            "engaged"
        ],
        "other_options": [
            "waiting",
            "leaving",
            "frustrated"
        ]
    },
    {
        "q": "Match UX benefits:",
        "type": "match",
        "left": [
            "fast",
            "responsive",
            "smooth",
            "happy"
        ],
        "right": [
            "Load time",
            "Interaction",
            "Navigation",
            "User"
        ]
    },
    {
        "q": "All Django topics completed.",
        "type": "true_false",
        "correct": "True"
    }
]