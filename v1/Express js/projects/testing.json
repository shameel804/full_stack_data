[
    {
        "title": "Frameworks",
        "ques": "Which **Testing Framework** is most commonly used with Express.js?",
        "answer": {
            "type": "text",
            "content": "**Mocha** (test runner) and **Chai** (assertion library).\n\nAnother specific tool is **Supertest**."
        },
        "explanation": "Jest is also popular."
    },
    {
        "title": "Supertest",
        "ques": "What does **Supertest** allow you to do?",
        "answer": {
            "type": "text",
            "content": "It allows you to test HTTP endpoints without actually starting the server on a port.\n\n`request(app).get('/user').expect(200)`\n\nIt mocks the server request/response cycle for fast integration testing."
        },
        "explanation": "Crucial for API testing."
    },
    {
        "title": "Unit vs Integration",
        "ques": "In the context of Express, what is an **Integration Test**?",
        "answer": {
            "type": "text",
            "content": "A test that checks a full route flow: Request -> Middleware -> Controller -> Database -> Response.\n\nA **Unit Test** would only check a single function (e.g., a utility function) in isolation."
        },
        "explanation": "Integration tests give more confidence."
    },
    {
        "title": "Setup/Teardown",
        "ques": "Why is `beforeEach()` often used in Express tests involving a database?",
        "answer": {
            "type": "text",
            "content": "To **clean** or **seed** the database before every test run.\n\nThis ensures tests are independent and don't fail because of left-over data from a previous test."
        },
        "explanation": "Reliable tests must be isolated."
    }
]