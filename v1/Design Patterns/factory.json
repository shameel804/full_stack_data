[
    {
        "q": "What is the primary intent of the Factory Method pattern?",
        "o": [
            "Define an interface for creating an object, but let subclasses decide which class to instantiate",
            "Ensure a class has only one instance",
            "Convert the interface of a class into another interface",
            "Separate the construction of a complex object from its representation"
        ]
    },
    {
        "q": "Which type of pattern is Factory Method?",
        "o": [
            "Creational",
            "Structural",
            "Behavioral",
            "Architectural"
        ]
    },
    {
        "q": "In Factory Method, who decides which concrete class to instantiate?",
        "o": [
            "The subclass (Concrete Creator)",
            "The client",
            "The superclass",
            "The operating system"
        ]
    },
    {
        "q": "What is the 'Product' in Factory Method pattern?",
        "o": [
            "The interface/abstract class of objects the factory creates",
            "The creator class",
            "The client class",
            "The factory class"
        ]
    },
    {
        "q": "What is the 'Creator' in Factory Method pattern?",
        "o": [
            "The class that declares the factory method",
            "The class that implements the product",
            "The class that uses the product",
            "The class that deletes the product"
        ]
    },
    {
        "q": "What is the 'ConcreteCreator'?",
        "o": [
            "The subclass that overrides the factory method to return an instance of a ConcreteProduct",
            "The interface",
            "The client",
            "The abstract class"
        ]
    },
    {
        "q": "Can the Factory Method be abstract?",
        "o": [
            "Yes, forcing subclasses to implement it",
            "No, never",
            "Only in C++",
            "Only in Java"
        ]
    },
    {
        "q": "Can the Created class provided a default implementation of Factory Method?",
        "o": [
            "Yes, returning a default ConcreteProduct",
            "No",
            "Only if final",
            "Only if static"
        ]
    },
    {
        "q": "Factory Method promotes:",
        "o": [
            "Loose coupling between Creator and Concrete Products",
            "Tight coupling",
            "Inheritance abuse",
            "Global state"
        ]
    },
    {
        "q": "How does Factory Method differ from Simple Factory?",
        "o": [
            "Simple Factory is usually a static method/class; Factory Method uses inheritance and polymorphism",
            "Simple Factory is more complex",
            "Factory Method is static",
            "They are the same"
        ]
    },
    {
        "q": "What is the 'Parameterized Factory Method'?",
        "o": [
            "A factory method that takes an argument to create different kinds of products",
            "A factory with many methods",
            "A generic factory",
            "A template factory"
        ]
    },
    {
        "q": "Which pattern is often used with Factory Method?",
        "o": [
            "Template Method (Factory Method is often a step in a Template Method)",
            "Singleton",
            "Observer",
            "Strategy"
        ]
    },
    {
        "q": "Can a Singleton be a Factory?",
        "o": [
            "Yes, often the Creator or Simple Factory is implemented as a Singleton",
            "No",
            "Rarely",
            "Never"
        ]
    },
    {
        "q": "What is 'Abstract Factory'?",
        "o": [
            "An interface for creating families of related or dependent objects without specifying their concrete classes",
            "A factory for abstracts",
            "A factory that is abstract",
            "A simple factory"
        ]
    },
    {
        "q": "Difference between Factory Method and Abstract Factory?",
        "o": [
            "Factory Method uses inheritance (class-based); Abstract Factory uses composition (object-based)",
            "Factory Method creates families; Abstract Factory creates one product",
            "Abstract Factory is simpler",
            "No difference"
        ]
    },
    {
        "q": "Does Abstract Factory typically use Factory methods?",
        "o": [
            "Yes, the methods declared in the interface are effectively factory methods",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "When should you use Factory Method?",
        "o": [
            "When a class doesn't know beforehand the exact class of objects it needs to create",
            "When you have only one class",
            "When using primitives",
            "When performance is critical"
        ]
    },
    {
        "q": "When should you use Abstract Factory?",
        "o": [
            "When a system should be independent of how its products are created, composed, and represented, and configured with one of multiple families of products",
            "When creating a single simple object",
            "When using int and float",
            "When using a single singleton"
        ]
    },
    {
        "q": "Which Principle is heavily supported by Factory patterns?",
        "o": [
            "Dependency Inversion Principle (depend on abstractions, not concretions)",
            "Single Responsibility Principle",
            "Interface Segregation Principle",
            "Liskov Substitution Principle"
        ]
    },
    {
        "q": "Does Factory Method violate Open/Closed Principle?",
        "o": [
            "No, it supports it (add new product = add new creator subclass, no existing code change)",
            "Yes, heavily",
            "Maybe",
            "Depends"
        ]
    },
    {
        "q": "Does Simple Factory violate Open/Closed Principle?",
        "o": [
            "Yes, often need to modify the switch/if-else logic to add new products",
            "No",
            "Maybe",
            "Depends"
        ]
    },
    {
        "q": "What is a 'Static Factory Method'?",
        "o": [
            "A static method that returns an instance of the class (like Integer.valueOf)",
            "A factory method in a static class",
            "A singleton",
            "A builder"
        ]
    },
    {
        "q": "Is Static Factory Method the same as GOF Factory Method?",
        "o": [
            "No, GOF pattern relies on subclassing; static factory is just a convenience method",
            "Yes",
            "Maybe",
            "Depends"
        ]
    },
    {
        "q": "Advantage of Static Factory Method over Constructor?",
        "o": [
            "Wait, they have names, valid for same signature but different types, can cache instances",
            "None",
            "Slower",
            "Harder to read"
        ]
    },
    {
        "q": "Example of Static Factory Method in Java?",
        "o": [
            "Boolean.valueOf(boolean)",
            "new Boolean()",
            "Boolean.TRUE",
            "Boolean.class"
        ]
    },
    {
        "q": "In Abstract Factory, if you add a new product type (e.g. Window, Button, NEW_Scrollbar), what happens?",
        "o": [
            "You must change the Abstract Factory interface and all concrete factories (breaks OCP)",
            "Nothing, it is automatic",
            "You only change one file",
            "It is easy"
        ]
    },
    {
        "q": "Which pattern isolates the client from the 'new' operator?",
        "o": [
            "Factory (all variants)",
            "Singleton (instantiation is hidden but specific)",
            "Strategy",
            "Observer"
        ]
    },
    {
        "q": "Is 'Collection.iterator()' a Factory Method?",
        "o": [
            "Yes, it returns an Iterator implementation chosen by the collection",
            "No",
            "It is a Strategy",
            "It is a State"
        ]
    },
    {
        "q": "What is the return type of a Factory Method?",
        "o": [
            "An interface or abstract class (Product)",
            "void",
            "Concrete class",
            "Object"
        ]
    },
    {
        "q": "Abstract Factory is often implemented with?",
        "o": [
            "Factory Methods (for each product)",
            "Builder",
            "Prototype",
            "Singleton"
        ]
    },
    {
        "q": "Can Abstract Factory be implemented using Prototypes?",
        "o": [
            "Yes, the factory stores prototypes and clones them",
            "No",
            "Only in Javascript",
            "Only in Python"
        ]
    },
    {
        "q": "Major drawback of Abstract Factory?",
        "o": [
            "Difficulty in extending the product families (adding new product types)",
            "Too many singletons",
            "Slow execution",
            "Memory leaks"
        ]
    },
    {
        "q": "Major drawback of Factory Method?",
        "o": [
            "Can lead to parallel class hierarchies (one for products, one for creators)",
            "Too simple",
            "Not flexible",
            "Global state"
        ]
    },
    {
        "q": "In Java JDBC, 'DriverManager.getConnection()' relies on:",
        "o": [
            "Factory pattern (drivers register themselves, manager creates connection)",
            "Singleton",
            "Prototype",
            "Builder"
        ]
    },
    {
        "q": "In Java XML parsing, 'DocumentBuilderFactory' is:",
        "o": [
            "An Abstract Factory",
            "A Singleton",
            "A Builder",
            "A Prototype"
        ]
    },
    {
        "q": "Before Java 8, interfaces could not have static methods. Where were Static Factories placed?",
        "o": [
            "In a separate utility class (e.g. Collections for Collection factory methods)",
            "In the interface",
            "Nowhere",
            "In abstract class"
        ]
    },
    {
        "q": "Does Factory Pattern help with Unit Testing?",
        "o": [
            "Yes, allows injecting mock factories that return mock products",
            "No, makes it harder",
            "Neutral",
            "Depends"
        ]
    },
    {
        "q": "What is a 'Virtual Constructor'?",
        "o": [
            "Another name for Factory Method (since it lets you override creation behavior)",
            "A constructor in C++",
            "A virtual machine",
            "A static constructor"
        ]
    },
    {
        "q": "Which pattern allows 'Pluggable' Look-and-Feel in Swing?",
        "o": [
            "Abstract Factory (creating UI controls for specific OS)",
            "Singleton",
            "Command",
            "Observer"
        ]
    },
    {
        "q": "If 'ConcreteCreator' has no other logic than creating product, it might be better as:",
        "o": [
            "A Simple Factory or Prototype registry",
            "A Singleton",
            "A Strategy",
            "A null object"
        ]
    },
    {
        "q": "Factory Method is defined in:",
        "o": [
            "An interface or an abstract class",
            "A static block",
            "A constructor",
            "A enum"
        ]
    },
    {
        "q": "Do you always need a new class for a new Product in Factory Method?",
        "o": [
            "Typically yes (ConcreteProduct), and often a new ConcreteCreator",
            "No",
            "Only in Java",
            "Only in C#"
        ]
    },
    {
        "q": "How does Spring 'BeanFactory' relate to this?",
        "o": [
            "It is a complex Factory implementation (IoC container)",
            "It is a Singleton",
            "It is a Proxy",
            "It is a Builder"
        ]
    },
    {
        "q": "What is 'Registry' pattern often used with Factory?",
        "o": [
            "To map names/IDs to Factory instances or Prototypes",
            "To delete objects",
            "To verify objects",
            "To test objects"
        ]
    },
    {
        "q": "Can you use Reflection in a Factory?",
        "o": [
            "Yes, to reduce code (instantiate class by name)",
            "No",
            "Only in C++",
            "Only in Python"
        ]
    },
    {
        "q": "Is 'Reflection' based Factory type-safe?",
        "o": [
            "Not at compile time",
            "Yes",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is a 'Guice' Module?",
        "o": [
            "Configuration for dependency injection (essentially configuring the Factory)",
            "A singleton",
            "A builder",
            "A proxy"
        ]
    },
    {
        "q": "In GUI toolkits, creating a 'Button' often involves:",
        "o": [
            "Factory (to abstract OS differences: WindowsButton vs MacButton)",
            "Singleton",
            "Strategy",
            "State"
        ]
    },
    {
        "q": "Which is more flexible: Constructor or Factory Method?",
        "o": [
            "Factory Method (polymorphism, naming, caching)",
            "Constructor",
            "Both equal",
            "Neither"
        ]
    },
    {
        "q": "Constructor limitations:",
        "o": [
            "Name must match class, cannot return subtype, always creates new object",
            "None",
            "Too fast",
            "Too simple"
        ]
    },
    {
        "q": "Can a factory return an existing instance?",
        "o": [
            "Yes (caching/flyweight)",
            "No",
            "Only if static",
            "Only if void"
        ]
    },
    {
        "q": "Is 'java.nio.channels.Channels' a factory?",
        "o": [
            "Yes, utility class with static factory methods",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "In Effective Java, Item 1 says:",
        "o": [
            "Consider static factory methods instead of constructors",
            "Use constructors always",
            "Use reflection",
            "Use singletons"
        ]
    },
    {
        "q": "When using 'Dependency Injection', do you write Factories manually?",
        "o": [
            "Ideally no, the container is the factory (but 'FactoryBeans' exist for complex logic)",
            "Yes, always",
            "No, never",
            "Sometimes"
        ]
    },
    {
        "q": "What is a 'Factory Bean' in Spring?",
        "o": [
            "A bean that creates other beans (implements FactoryBean interface)",
            "A bean made in a factory",
            "A singleton bean",
            "A prototype bean"
        ]
    },
    {
        "q": "Why use 'FactoryBean' in Spring?",
        "o": [
            "To encapsulate complex initialization logic that can't be handled by simple XML/Annotation config",
            "To be slow",
            "To be verbose",
            "To be complex"
        ]
    },
    {
        "q": "Can a Factory Method take parameters?",
        "o": [
            "Yes, to specify criteria for creation",
            "No",
            "Only one",
            "Only string"
        ]
    },
    {
        "q": "If Factory Method takes a type parameter (String type), it often contains:",
        "o": [
            "Switch-case or If-else chain",
            "Loop",
            "Recursion",
            "Nothing"
        ]
    },
    {
        "q": "Is 'Switch-case' in Factory bad?",
        "o": [
            "It violates OCP if new types are added frequentl (Paramaterized Factory)",
            "It is classic",
            "It is fast",
            "It is good"
        ]
    },
    {
        "q": "How to avoid Switch-Case in Factory?",
        "o": [
            "Use a Map<String, Supplier> or Map<String, Class> registry",
            "Use more if-else",
            "Use loops",
            "Use recursion"
        ]
    },
    {
        "q": "Which pattern is 'java.util.EnumSet.of()'?",
        "o": [
            "Static Factory Method",
            "Singleton",
            "Builder",
            "Prototype"
        ]
    },
    {
        "q": "Why does 'EnumSet' use factory methods?",
        "o": [
            "To return different subclasses (RegularEnumSet vs JumboEnumSet) based on enum size transparently",
            "To be slow",
            "To be complex",
            "To enforce singleton"
        ]
    },
    {
        "q": "Is 'logging' library usually a Factory?",
        "o": [
            "Yes, LoggerFactory.getLogger()",
            "No",
            "It is a Singleton",
            "It is a Strategy"
        ]
    },
    {
        "q": "What does 'LoggerFactory.getLogger()' returns?",
        "o": [
            "A Logger implementation (Product)",
            "A String",
            "null",
            "A Factory"
        ]
    },
    {
        "q": "Can you use Factory Pattern for testing DB connections?",
        "o": [
            "Yes, factory can return a 'MockConnection' for tests",
            "No",
            "Maybe",
            "Depends"
        ]
    },
    {
        "q": "Does Factory Pattern add complexity?",
        "o": [
            "Yes, more classes/interfaces",
            "No",
            "Removes complexity",
            "Neutral"
        ]
    },
    {
        "q": "When is Factory pattern overkill?",
        "o": [
            "When product creation is simple and unlikely to change/vary",
            "Always",
            "Never",
            "For Singletons"
        ]
    },
    {
        "q": "What is 'Smart Constructor' in Haskell?",
        "o": [
            "A function that returns a value only if it is valid (Factory-like validation)",
            "A smart class",
            "A genius function",
            "A AI"
        ]
    },
    {
        "q": "Python 'classmethod' can be used as:",
        "o": [
            "Alternative constructor / Factory method",
            "Destructor",
            "Instance method",
            "Property"
        ]
    },
    {
        "q": "In Python, '__init__' is:",
        "o": [
            "Initializer (not constructor strictly, as object handles creation)",
            "Constructor",
            "Factory",
            "Singleton"
        ]
    },
    {
        "q": "In Python, '__new__' is:",
        "o": [
            "The actual Constructor (Allocator), acts like a Factory",
            "Initializer",
            "Destructor",
            "ToString"
        ]
    },
    {
        "q": "Can you implement Factory using C++ Templates?",
        "o": [
            "Yes, highly flexible",
            "No",
            "Only in C++20",
            "Only in C++98"
        ]
    },
    {
        "q": "What is 'Object Mother'?",
        "o": [
            "A factory used in testing to create test objects",
            "A pattern parent",
            "A singleton",
            "A builder"
        ]
    },
    {
        "q": "Difference between Object Mother and Builder?",
        "o": [
            "Object Mother provides canned objects; Builder allows step-by-step customization",
            "No difference",
            "Object Mother is for production",
            "Builder is for testing"
        ]
    },
    {
        "q": "Example of Abstract Factory in .NET?",
        "o": [
            "DbProviderFactory (creates Connection, Command, Adapter)",
            "Console",
            "Math",
            "String"
        ]
    },
    {
        "q": "In DDD (Domain Driven Design), Factories are used to:",
        "o": [
            "Handle complex object creation (Aggregates) ensuring invariants",
            "Create DTOs",
            "Create Views",
            "Create Controllers"
        ]
    },
    {
        "q": "Should a Repository be a Factory?",
        "o": [
            "Repositories often use Factories to reconstitute objects from DB",
            "No",
            "Yes, always",
            "Maybe"
        ]
    },
    {
        "q": "Can a Factory be passed as an argument?",
        "o": [
            "Yes (Abstract Factory pattern behavior)",
            "No",
            "Only in Java",
            "Only in C#"
        ]
    },
    {
        "q": "What is a 'Supplier' in Java 8?",
        "o": [
            "A functional interface that acts as a simple factory (takes nothing, returns T)",
            "A consumer",
            "A predicate",
            "A function"
        ]
    },
    {
        "q": "Can 'Supplier<T>' replace Factory types?",
        "o": [
            "Yes, for simple no-arg creation",
            "No",
            "Only for Strings",
            "Only for Integers"
        ]
    },
    {
        "q": "Does Factory Pattern encapsulate instantiation logic?",
        "o": [
            "Yes",
            "No",
            "Sometimes",
            "Maybe"
        ]
    },
    {
        "q": "Which pattern provides 'delayed instantiation'?",
        "o": [
            "Virtual Proxy / Lazy Initialization (can be inside Factory)",
            "Global",
            "Static",
            "Constant"
        ]
    },
    {
        "q": "If Factory caches instances, it becomes similar to:",
        "o": [
            "Flyweight pattern manager / Pool",
            "Singleton",
            "Prototype",
            "Builder"
        ]
    },
    {
        "q": "Can a Factory create immutable objects?",
        "o": [
            "Yes",
            "No",
            "Only mutable",
            "Only nulls"
        ]
    },
    {
        "q": "What is 'Named Constructor' idiom (C++)?",
        "o": [
            "Static methods with descriptive names returning instances (Static Factories)",
            "Constructors with names",
            "Friends",
            "Templates"
        ]
    },
    {
        "q": "Is 'Clone' a factory method?",
        "o": [
            "Technically yes, it creates a new object (Prototype pattern)",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Which pattern relies on cloning to create new objects?",
        "o": [
            "Prototype",
            "Factory Method",
            "Builder",
            "Singleton"
        ]
    },
    {
        "q": "Are 'Test Data Builders' related to Factory?",
        "o": [
            "Yes, specialized factories for tests",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Does Factory Method allow changing product class at runtime?",
        "o": [
            "Yes, by using different ConcreteCreator or parameters",
            "No",
            "Only compile time",
            "Only link time"
        ]
    },
    {
        "q": "Is Factory Method Class-Scope or Object-Scope?",
        "o": [
            "Class-Scope (inheritance)",
            "Object-Scope",
            "Global-Scope",
            "No-Scope"
        ]
    },
    {
        "q": "Is Abstract Factory Class-Scope or Object-Scope?",
        "o": [
            "Object-Scope (delegation to factory object)",
            "Class-Scope",
            "Global-Scope",
            "No-Scope"
        ]
    },
    {
        "q": "Which is more dynamic: Abstract Factory or Factory Method?",
        "o": [
            "Abstract Factory (can switch factory object at runtime easily)",
            "Factory Method",
            "Both equal",
            "Neither"
        ]
    },
    {
        "q": "Does Factory Pattern increase code volume?",
        "o": [
            "Yes",
            "No",
            "Decreases it",
            "Neutral"
        ]
    },
    {
        "q": "The core spirit of Factory is:",
        "o": [
            "Programming to an interface, not an implementation",
            "Code reuse",
            "Performance",
            "Security"
        ]
    },
    {
        "q": "Can an Abstract Factory produces singletons?",
        "o": [
            "Yes, if the products are meant to be singletons",
            "No, never",
            "Only in Java",
            "Only in C#"
        ]
    }
,
{
    "q": "What is the key benefit of Factory pattern regarding 'recompilation'?",
    "o": [
        "Client code doesn't need recompilation if ConcreteProduct changes (if usage is via interface)",
        "Client code recompiles faster",
        "Factory code recompiles faster",
        "No benefit"
    ]
},
{
    "q": "How does Factory Pattern aid in 'Configuration Management'?",
    "o": [
        "Factory can read config files to decide which class to instantiate",
        "Factory manages database",
        "Factory manages memory",
        "Factory manages threads"
    ]
},
{
    "q": "Can you use Factory to implement a 'Product Pool'?",
    "o": [
        "Yes, Factory can check a pool before creating new instance",
        "No",
        "Only in C++",
        "Only in Java"
    ]
},
{
    "q": "What is 'Lazy Initialization' in Factory context?",
    "o": [
        "Factory delays creation of heavy objects until requested",
        "Factory works lazily",
        "Factory sleeps",
        "Factory fails"
    ]
},
{
    "q": "Which pattern is best for creating Complex Compounded Objects?",
    "o": [
        "Builder (better than Factory for step-by-step)",
        "Factory Method",
        "Abstract Factory",
        "Prototype"
    ]
},
{
    "q": "Can Factory Method be used to create Singleton?",
    "o": [
        "Yes, the factory method can return the static instance",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "In a plugin architecture, Factory is used to:",
    "o": [
        "Instantiate plugin classes loaded dynamically",
        "Delete plugins",
        "Archive plugins",
        "Compile plugins"
    ]
},
{
    "q": "Does Factory Pattern enforce a specific object structure?",
    "o": [
        "No, only creation interface; Builder enforces structure",
        "Yes",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Which is more suitable for 'family of objects': Factory Method or Abstract Factory?",
    "o": [
        "Abstract Factory",
        "Factory Method",
        "Builder",
        "Prototype"
    ]
},
{
    "q": "Example of family of objects?",
    "o": [
        "LightButton, LightWindow vs DarkButton, DarkWindow",
        "String, Integer",
        "Car, Truck",
        "Dog, Cat"
    ]
},
{
    "q": "In Clean Architecture, where does the Factory belong?",
    "o": [
        "Use Case / Interactor layer (interface) or Interface Adapters, usually needed to create Entities",
        "Database layer",
        "UI layer",
        "External layer"
    ]
},
{
    "q": "What is 'Factory Method' in C#?",
    "o": [
        "Same as Java, but C# properties can also act as factories",
        "Delegate",
        "Event",
        "Attribute"
    ]
},
{
    "q": "What is 'Activator.CreateInstance' in C#?",
    "o": [
        "Reflection-based factory method provided by framework",
        "A builder",
        "A singleton",
        "A prototype"
    ]
},
{
    "q": "Is 'Activator.CreateInstance' slow?",
    "o": [
        "Yes, compared to 'new' or compiled expression trees",
        "No",
        "It is fastest",
        "It is instant"
    ]
},
{
    "q": "What is 'Constructor Reference' in Java 8?",
    "o": [
        "Product::new (can be used as a factory supplier)",
        "Product.new",
        "new Product",
        "create Product"
    ]
},
{
    "q": "Can you pass a 'Constructor Reference' to a method?",
    "o": [
        "Yes, as a Supplier or Function interface",
        "No",
        "Only in Java 10",
        "Only in C++"
    ]
},
{
    "q": "Which pattern avoids 'switch' statements in object creation?",
    "o": [
        "Polymorphic Factory (Registration-based)",
        "Simple Factory",
        "Command",
        "Observer"
    ]
},
{
    "q": "How does Registration-based Factory work?",
    "o": [
        "Classes register themselves (or their factory) with a central map using a key",
        "Using magic",
        "Using switch",
        "Using if-else"
    ]
},
{
    "q": "What is a 'Self-Registering Class'?",
    "o": [
        "A class that adds itself to a factory registry static block/constructor",
        "A singleton",
        "A visitor",
        "A proxy"
    ]
},
{
    "q": "Risk of Registration-based Factory?",
    "o": [
        "If class is never loaded (lazy loading), static block won't run -> not registered",
        "Too fast",
        "Too memory intensive",
        "Circular dependency"
    ]
},
{
    "q": "How to force class loading for Registration?",
    "o": [
        "Use Class.forName() explicitly or config file or Annotation scanning",
        "Use new",
        "Use print",
        "Use delete"
    ]
},
{
    "q": "Is 'Annotation Processing' a way to generate Factories?",
    "o": [
        "Yes, widely used in Dagger/Hilt",
        "No",
        "Maybe",
        "Rarely"
    ]
},
{
    "q": "What is 'Dagger' in Android?",
    "o": [
        "Dependency Injection framework (generates factories at compile time)",
        "A weapon",
        "A game",
        "A database"
    ]
},
{
    "q": "Does Dagger use Reflection?",
    "o": [
        "No (mostly), relies on generated factory code",
        "Yes, heavily",
        "Only for print",
        "Only for debug"
    ]
},
{
    "q": "Benefit of compile-time factory generation (Dagger)?",
    "o": [
        "Performance (no reflection overhead), compile-time safety",
        "Smaller code",
        "Prettier code",
        "Faster compilation"
    ]
},
{
    "q": "Is 'ServiceLoader' in Java a Factory?",
    "o": [
        "Yes, a factory for service providers (SPI)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What does SPI stand for?",
    "o": [
        "Service Provider Interface",
        "Serial Port Interface",
        "Simple Programming Interface",
        "Standard Public Interface"
    ]
},
{
    "q": "How does 'ServiceLoader' find implementations?",
    "o": [
        "Looks in META-INF/services/ files",
        "Looks in database",
        "Looks in registry",
        "Looks in bin folder"
    ]
},
{
    "q": "Which pattern is used to encapsulate 'Object Creation'?",
    "o": [
        "Factory",
        "Facade",
        "Decorator",
        "Adapter"
    ]
},
{
    "q": "Can a factory return null?",
    "o": [
        "Yes, if creation fails or criteria not met (but Optional is better)",
        "No, must throw exception",
        "No, must return object",
        "Depends"
    ]
},
{
    "q": "What is 'Null Object' pattern useful for with Factory?",
    "o": [
        "Returning a NullObject implementation instead of null to avoid NPE",
        "Nothing",
        "Saving memory",
        "Deleting data"
    ]
},
{
    "q": "Factory Pattern vs 'New' Operator coupling?",
    "o": [
        "Factory couples to the Factory interface; 'New' couples to Concrete class",
        "Factory couples to concrete",
        "New couples to interface",
        "Same"
    ]
},
{
    "q": "Can 'Factory' be generic?",
    "o": [
        "Yes, taking Class<T> as argument",
        "No",
        "Only in C#",
        "Only in C++"
    ]
},
{
    "q": "What is 'Prototype Factory'?",
    "o": [
        "Factory that holds a prototype and clones it to create new instances",
        "Generic factory",
        "Simple factory",
        "Static factory"
    ]
},
{
    "q": "Is 'Prototype Factory' dynamic?",
    "o": [
        "Yes, you can swap the prototype at runtime to change created objects",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Which is faster: 'new' or 'Factory'?",
    "o": [
        "Inline 'new' is slightly faster (no method call overhead), but negligible usually",
        "Factory",
        "Same",
        "Depends"
    ]
},
{
    "q": "Does JIT optimization remove Factory overhead?",
    "o": [
        "Yes, often inlines the factory method",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Which pattern manages 'Entity Life Cycle' in JPA?",
    "o": [
        "EntityManager (Factory for queries, Manager for entities)",
        "Singleton",
        "Builder",
        "Prototype"
    ]
},
{
    "q": "Is 'EntityManagerFactory' a Factory?",
    "o": [
        "Yes, creates EntityManager",
        "No",
        "It is a Singleton",
        "It is a Builder"
    ]
},
{
    "q": "Is 'EntityManagerFactory' a heavyweight object?",
    "o": [
        "Yes, usually one per DB/Unit (Singleton scoped usually)",
        "No, lightweight",
        "Medium",
        "Tiny"
    ]
},
{
    "q": "Is 'EntityManager' heavyweight?",
    "o": [
        "No, lightweight, create one per request/transaction",
        "Yes, very heavy",
        "Singleton",
        "Global"
    ]
},
{
    "q": "What is 'SessionFactory' in Hibernate?",
    "o": [
        "Equivalent to EntityManagerFactory (Heavyweight)",
        "Lightweight",
        "Singleton",
        "Prototype"
    ]
},
{
    "q": "What is 'Session' in Hibernate?",
    "o": [
        "Equivalent to EntityManager (Lightweight)",
        "Heavyweight",
        "Global",
        "Static"
    ]
},
{
    "q": "Which pattern is used to abstract File System creation?",
    "o": [
        "FileSystemFactory",
        "Files singleton",
        "File builder",
        "File prototype"
    ]
},
{
    "q": "Why mock a FileSystem Factory?",
    "o": [
        "To test without touching real disk (using MemoryFileSystem)",
        "To be fast",
        "To be slow",
        "To format disk"
    ]
},
{
    "q": "What is 'Inversion of Control' (IoC)?",
    "o": [
        "Principle where control flow is inverted (Framework calls you, or Container creates objects)",
        "You control everything",
        "Static calls",
        "Global calls"
    ]
},
{
    "q": "Is Factory Pattern a form of IoC?",
    "o": [
        "Yes, it inverts the control of creation from Client to Factory",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Dependency Injection vs Factory Pattern?",
    "o": [
        "DI passes objects in (Push); Factory pulls objects (Pull)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "When is Factory preferred over DI?",
    "o": [
        "When used to create many short-lived objects dynamically based on runtime args",
        "Always",
        "Never",
        "For singletons"
    ]
},
{
    "q": "When is DI preferred over Factory?",
    "o": [
        "For wiring up long-lived service dependencies (Structural composition)",
        "For dynamic creation",
        "For loops",
        "For arrays"
    ]
},
{
    "q": "Can DI container use Factories internally?",
    "o": [
        "Yes, it uses factories (providers) to create the beans",
        "No",
        "Maybe",
        "Sometimes"
    ]
},
{
    "q": "What is 'Assisted Injection'?",
    "o": [
        "Combining DI (for service deps) + Factory (for runtime args)",
        "Manual injection",
        "Auto injection",
        "No injection"
    ]
},
{
    "q": "Why use Assisted Injection?",
    "o": [
        "To inject services into an object that also needs runtime constructor parameters",
        "To be cool",
        "To be fast",
        "To be simple"
    ]
},
{
    "q": "Which Google library supports Assisted Injection?",
    "o": [
        "Guice (AssistedInject) and Dagger",
        "Gson",
        "Guava",
        "Protobuf"
    ]
},
{
    "q": "What is 'AutoFactory'?",
    "o": [
        "Code generator that generates Factory implementation from interface",
        "A car factory",
        "A automatic machine",
        "A robot"
    ]
},
{
    "q": "Does Factory Pattern help with 'Feature Toggles'?",
    "o": [
        "Yes, Factory can decide to return 'NewFeatureImpl' or 'OldFeatureImpl' based on toggle",
        "No",
        "Maybe",
        "Rarely"
    ]
},
{
    "q": "What is 'A/B Testing' with Factory?",
    "o": [
        "Factory returns Variant A or B randomly/based on user ID",
        "Testing factory",
        "Testing alphabet",
        "Testing numbers"
    ]
},
{
    "q": "Can logic inside Factory be complex?",
    "o": [
        "Yes, it can involve DB lookups, checks, etc.",
        "No, must be one line",
        "No, must be static",
        "No, must be void"
    ]
},
{
    "q": "If Factory logic is too complex, what should you do?",
    "o": [
        "Refactor, maybe use Chain of Responsibility or Builder",
        "Keep it",
        "Delete it",
        "Ignore it"
    ]
},
{
    "q": "What is 'Static Factory' in Effective Java?",
    "o": [
        "A public static factory method",
        "A class",
        "A variable",
        "A constant"
    ]
},
{
    "q": "Benefits of Static Factory naming?",
    "o": [
        "Can describe intent (e.g. fromCoordinate vs fromPolar)",
        "None",
        "Shorter",
        "Longer"
    ]
},
{
    "q": "Can Static Factory return subtypes?",
    "o": [
        "Yes, unlike constructor",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Static Factory require new object creation?",
    "o": [
        "No, can return cached instance",
        "Yes, always",
        "Usually",
        "Depends"
    ]
},
{
    "q": "Which standard Java class uses Static Factory heavily?",
    "o": [
        "java.time.LocalDate (of, now, parse)",
        "java.util.ArrayList",
        "java.lang.Object",
        "java.io.File"
    ]
},
{
    "q": "What is 'Flyweight Factory'?",
    "o": [
        "A factory that manages flyweights (caches and returns shared instances)",
        "A flying factory",
        "A light factory",
        "A plane factory"
    ]
},
{
    "q": "Is 'Interning' a form of Factory?",
    "o": [
        "Yes, creates/retrieves unique instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Which pattern is used to migrate from 'Simple Factory' to flexible design?",
    "o": [
        "Factory Method",
        "Singleton",
        "Observer",
        "Decorator"
    ]
},
{
    "q": "Can Factory Pattern be used in Functional Programming?",
    "o": [
        "Yes, as higher-order functions returning functions",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "In JavaScript, a function returning an object literal is:",
    "o": [
        "A factory function",
        "A class",
        "A constructor",
        "A prototype"
    ]
},
{
    "q": "Is binding 'this' an issue in JS Factory Functions?",
    "o": [
        "No, usually avoids 'this' issues compared to 'new'/'class'",
        "Yes",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Factory vs Class Constructor in JS?",
    "o": [
        "Factory allows privacy (closures), no new keyword; Class is standard OOP",
        "Factory is slower",
        "Class is slower",
        "Same"
    ]
},
{
    "q": "What is 'Mixin' creation via Factory?",
    "o": [
        "Factory composes object with multiple mixins before returning",
        "Mixing paint",
        "Mixing drinks",
        "Mixing dough"
    ]
},
{
    "q": "Can Factory Pattern hide the use of 'Proxy'?",
    "o": [
        "Yes, factory can return a Proxy wrapping the real object transparently",
        "No",
        "Maybe",
        "Rarely"
    ]
},
{
    "q": "Example of Factory hiding Proxy?",
    "o": [
        "Hibernate loading entities (returns proxy for lazy loading)",
        "New operator",
        "Static call",
        "Direct access"
    ]
},
{
    "q": "Is 'Spring AOP' proxying handled by a factory?",
    "o": [
        "Yes, ProxyFactory (creates AOP proxies)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Which pattern is 'java.net.URL.openConnection()'?",
    "o": [
        "Factory Method (returns URLConnection subclass depending on protocol)",
        "Builder",
        "Singleton",
        "Strategy"
    ]
},
{
    "q": "Is 'java.util.UUID.randomUUID()' a factory?",
    "o": [
        "Static Factory Method",
        "Singleton",
        "Constructor",
        "Builder"
    ]
},
{
    "q": "Why is 'randomUUID()' a factory?",
    "o": [
        "It encapsulates the logic of generating version 4 UUID",
        "It is random",
        "It is unique",
        "It is static"
    ]
},
{
    "q": "What is 'Factory' in AngularJS (v1)?",
    "o": [
        "A provider recipe",
        "A class",
        "A directive",
        "A filter"
    ]
},
{
    "q": "Difference between 'Service' and 'Factory' in Angular 1?",
    "o": [
        "Service: constructor function (new called); Factory: function that returns the value",
        "No difference",
        "Service is singleton",
        "Factory is prototype"
    ]
},
{
    "q": "In React, is 'createElement' a factory?",
    "o": [
        "Yes, creates Virtual DOM elements",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'JSX' compiled to factory calls?",
    "o": [
        "Yes (React.createElement)",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "What is 'creational pattern'?",
    "o": [
        "Pattern dealing with object creation mechanisms",
        "Pattern dealing with structure",
        "Pattern dealing with communication",
        "Pattern dealing with architecture"
    ]
},
{
    "q": "Which pattern is creating a maze in GOF book example?",
    "o": [
        "Abstract Factory / Builder / Factory Method",
        "Singleton",
        "Observer",
        "State"
    ]
},
{
    "q": "Why use Factory for Maze example?",
    "o": [
        "To switch between 'EnchantedMaze' and 'BombedMaze' easily",
        "To make it hard",
        "To make it slow",
        "To make it big"
    ]
},
{
    "q": "Does Factory Pattern improve memory usage?",
    "o": [
        "Not directly, but enables Flyweight which does",
        "Yes, always",
        "No, increases it",
        "Neutral"
    ]
},
{
    "q": "Does Factory Pattern improve speed?",
    "o": [
        "No, usually slight overhead, but enables optimization (pooling)",
        "Yes",
        "Neutral",
        "Maybe"
    ]
},
{
    "q": "Which pattern is 'Unsafe.allocateInstance'?",
    "o": [
        "Not a pattern, a backdoor allocator (Magic factory)",
        "Factory",
        "Builder",
        "Singleton"
    ]
},
{
    "q": "Can you define a Factory in an Interface in Java 8?",
    "o": [
        "Yes, distinct static method or default method",
        "No",
        "Only in Java 9",
        "Only in Java 10"
    ]
},
{
    "q": "What is the 'Convention over Configuration' Factory?",
    "o": [
        "Factory infers class to create based on name (e.g. 'User' -> 'UserValidator')",
        "Magic",
        "Hardcoding",
        "XML"
    ]
},
{
    "q": "Is 'Convention over Configuration' fragile?",
    "o": [
        "Can be, if naming conventions break or refactoring misses string names",
        "No, very robust",
        "Yes, always broken",
        "Maybe"
    ]
},
{
    "q": "Which framework heavily uses Convention factories?",
    "o": [
        "Ruby on Rails",
        "Spring",
        "Django",
        "Laravel"
    ]
},
{
    "q": "Can Factory Pattern simplify upgrades?",
    "o": [
        "Yes, return new version of class from factory, old clients don't know",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Versioning' in Factory?",
    "o": [
        "Returning 'V1Product' or 'V2Product' based on context",
        "Git",
        "SVN",
        "Mercurial"
    ]
}
,
{
    "q": "Which pattern is best for testing legacy code with 'new' operators?",
    "o": [
        "Extract Method to Factory (replace 'new' with method call that can be overridden)",
        "Singleton",
        "Observer",
        "State"
    ]
},
{
    "q": "What is 'Seam' in legacy code testing?",
    "o": [
        "A place where you can alter behavior without editing code (e.g. factory method)",
        "A line of code",
        "A bug",
        "A comment"
    ]
},
{
    "q": "Is 'Factory' needed in dynamic languages (Python/Ruby) as much as Java?",
    "o": [
        "Less so, because classes are objects and can be passed around/invoked directly (class is a factory)",
        "Yes, same amount",
        "More",
        "Never"
    ]
},
{
    "q": "In Ruby, 'MyClass.new' is technically:",
    "o": [
        "A call to the 'new' method on the class object (which acts as a factory)",
        "A keyword",
        "A variable",
        "A macro"
    ]
},
{
    "q": "What is 'Abstract Factory' in Python?",
    "o": [
        "Often just a dictionary or class with methods returning classes",
        "No such thing",
        "Strict interface",
        "Compiler error"
    ]
},
{
    "q": "Can you implement Abstract Factory with 'Enums'?",
    "o": [
        "Yes, enum constants can override methods to return specific products",
        "No",
        "Maybe",
        "Only in C++"
    ]
},
{
    "q": "Is 'Enum Factory' thread-safe?",
    "o": [
        "Yes, enums are inherently thread-safe and singleton-like",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "What is 'Registry Pattern' often confused with?",
    "o": [
        "Factory (Registry often acts as a Factory locator)",
        "Singleton",
        "Observer",
        "Command"
    ]
},
{
    "q": "Does Factory Pattern improve compile time?",
    "o": [
        "Can improve it by decoupling implementations (Interface-based), reducing header dependencies in C++",
        "No, slows it",
        "Same",
        "Depends"
    ]
},
{
    "q": "What is 'Pimpl' idiom in C++?",
    "o": [
        "Pointer to Implementation (often used with Factory to hide impl details)",
        "Simple implementation",
        "Public implementation",
        "Private implementation"
    ]
},
{
    "q": "Can Factory create 'Structs'?",
    "o": [
        "Yes, if they implement the interface/base type",
        "No",
        "Only classes",
        "Only pointers"
    ]
},
{
    "q": "Is 'Factory' a bad name for a class?",
    "o": [
        "Not bad, but 'Builder' or 'Provider' or 'Repository' might be more specific",
        "Yes, terrible",
        "No, perfect",
        "Neutral"
    ]
},
{
    "q": "What does 'Provider' usually imply?",
    "o": [
        "A Factory that might return existing instance or new one (scoped)",
        "A Builder",
        "A Singleton",
        "A Strategy"
    ]
},
{
    "q": "In Guice, 'Provider<T>' is:",
    "o": [
        "The standard factory interface",
        "A singleton",
        "A proxy",
        "A scope"
    ]
},
{
    "q": "In JSR-330 (Java standard DI), what is 'Provider'?",
    "o": [
        "javax.inject.Provider (get() method)",
        "java.util.Provider",
        "com.google.Provider",
        "org.spring.Provider"
    ]
},
{
    "q": "Is 'java.sql.DriverManager' a Factory?",
    "o": [
        "Yes, static factory getConnection()",
        "No",
        "Maybe",
        "Unknown"
    ]
},
{
    "q": "Is 'java.nio.file.Files' a Factory?",
    "o": [
        "Utility class with factory methods (newInputStream, etc.)",
        "No",
        "Yes, Abstract Factory",
        "Yes, Builder"
    ]
},
{
    "q": "What is 'FileSystems.getDefault()'?",
    "o": [
        "Static Factory returning default FileSystem",
        "Singleton",
        "Builder",
        "Prototype"
    ]
},
{
    "q": "What is 'SecurityManager' checks in Factory?",
    "o": [
        "Factory might check permissions before creating sensitive objects",
        "Nothing",
        "Check disk space",
        "Check memory"
    ]
},
{
    "q": "Can a Factory be 'Remote'?",
    "o": [
        "Yes, RMI/Corba factories creating remote objects",
        "No",
        "Only in Java",
        "Only in C#"
    ]
},
{
    "q": "What is 'EJB Home Interface'?",
    "o": [
        "A Factory interface for EJB components (create methods)",
        "A home page",
        "A website",
        "A singleton"
    ]
},
{
    "q": "Is 'EJB Home' deprecated?",
    "o": [
        "Largely superseded by modern EJB/DI/CDI annotations",
        "No, mostly used",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Local Home' vs 'Remote Home'?",
    "o": [
        "Factory for local invocation vs remote invocation",
        "House vs Apartment",
        "Internal vs External",
        "Public vs Private"
    ]
},
{
    "q": "Does Factory Pattern help with 'Polymorphism'?",
    "o": [
        "Yes, it's the standard way to create polymorphic objects dynamically",
        "No",
        "Hinders it",
        "Neutral"
    ]
},
{
    "q": "Can Factory return an 'Anonymous Inner Class'?",
    "o": [
        "Yes",
        "No",
        "Only in Java 8",
        "Only in Java 9"
    ]
},
{
    "q": "Can Factory return a 'Lambda'?",
    "o": [
        "Yes, if the return type is a functional interface",
        "No",
        "Only in Java",
        "Only in Python"
    ]
},
{
    "q": "Factory Pattern vs 'Template Method'?",
    "o": [
        "Template Method might call a Factory Method as one of its steps",
        "Opposite",
        "Same",
        "Competing"
    ]
},
{
    "q": "Factory Pattern vs 'Prototype'?",
    "o": [
        "Factory creates new via 'new'; Prototype creates new via 'clone'",
        "Same",
        "Opposite",
        "Competing"
    ]
},
{
    "q": "Factory Pattern vs 'Builder'?",
    "o": [
        "Factory creates in one shot; Builder creates step-by-step",
        "Same",
        "Opposite",
        "Competing"
    ]
},
{
    "q": "When is Builder better than Factory?",
    "o": [
        "When object has many optional parameters or complex construction rules",
        "Always",
        "Never",
        "For singletons"
    ]
},
{
    "q": "What is 'Telescoping Constructor'?",
    "o": [
        "Anti-pattern with many constructors (arg1, arg1+2, arg1+2+3...)",
        "A telescope",
        "A pattern",
        "A factory"
    ]
},
{
    "q": "Does Factory solve 'Telescoping Constructor'?",
    "o": [
        "Partially (via named static factories), but Builder is better",
        "Yes, completely",
        "No",
        "Makes it worse"
    ]
},
{
    "q": "Can Factory accept a 'Configuration Object'?",
    "o": [
        "Yes, passes config to the product",
        "No",
        "Only strings",
        "Only ints"
    ]
},
{
    "q": "What is 'Recursive Factory'?",
    "o": [
        "Factory that creates objects which might use the same factory to create sub-objects (Composite)",
        "Infinite loop",
        "Stack overflow",
        "Bad code"
    ]
},
{
    "q": "Is 'Composite' often built by Factory?",
    "o": [
        "Yes, useful for building trees",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can you serialization a Factory?",
    "o": [
        "Yes, if it holds state (like registry) and implements Serializable",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why serialize a Factory?",
    "o": [
        "To simplify saving the state of which 'creator' logic is currently active",
        "To save products",
        "To save memory",
        "To save time"
    ]
},
{
    "q": "What is 'Abstract Document' pattern?",
    "o": [
        "Uses a map of properties and dynamic proxies/factories to present typed views",
        "A document factory",
        "A pdf factory",
        "A word factory"
    ]
},
{
    "q": "Is 'Dependency Injection' just a big Factory?",
    "o": [
        "Conceptually yes, a 'Universal Factory'",
        "No",
        "Maybe",
        "Philosophical"
    ]
},
{
    "q": "What is 'Hardcoded Factory'?",
    "o": [
        "Factory that uses 'new' directly with fixed class names",
        "Good factory",
        "Bad factory",
        "Fast factory"
    ]
},
{
    "q": "What is 'Dynamic Factory'?",
    "o": [
        "Factory that loads class names from string/config (Reflection)",
        "Hardcoded",
        "Static",
        "Final"
    ]
},
{
    "q": "Which is safer refactoring-wise: Hardcoded or Dynamic Factory?",
    "o": [
        "Hardcoded (compiler checks existence), Dynamic is prone to runtime errors",
        "Dynamic",
        "Same",
        "Unsure"
    ]
},
{
    "q": "Does 'Class.newInstance()' use Factory?",
    "o": [
        "It IS a reflexive factory method (deprecated in Java 9)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why is 'Class.newInstance()' deprecated?",
    "o": [
        "It propagates checked exceptions unsafely; use Constructor.newInstance()",
        "It is slow",
        "It is old",
        "It is unsafe"
    ]
},
{
    "q": "Can Factory Pattern allow creating 'Mock' objects?",
    "o": [
        "Yes, essential for testing interactions",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Mockito.mock()' a factory?",
    "o": [
        "Yes, creates a proxy instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Shadow Factory'?",
    "o": [
        "A term not commonly used (maybe standard factory masking valid/invalid creation)",
        "A dark factory",
        "A ghost factory",
        "A light factory"
    ]
},
{
    "q": "Can you use Factory for 'pooling'?",
    "o": [
        "Yes, object pool pattern often uses a factory to populate the pool",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What represents the 'Pool' in 'Object Pool'?",
    "o": [
        "The manager (often Singleton) holding the collection",
        "The factory",
        "The object",
        "The client"
    ]
},
{
    "q": "Does Factory deal with object destruction?",
    "o": [
        "Usually no (GC does), but sometimes provides 'dispose()' or 'release()' for pooled objects",
        "Yes, always",
        "No, never",
        "Depends"
    ]
},
{
    "q": "What is 'RAII' relation to Factory?",
    "o": [
        "Factory creates resource; RAII object ensures it is cleaned up (C++)",
        "Same thing",
        "Opposite",
        "Unrelated"
    ]
},
{
    "q": "Can Java use RAII?",
    "o": [
        "Simulated via try-with-resources (AutoCloseable)",
        "Yes, natively",
        "No, never",
        "Only in Java 1.0"
    ]
},
{
    "q": "Is 'AutoCloseable' a factory?",
    "o": [
        "No, it's an interface for cleanup",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory' in domain of 'Game Development'?",
    "o": [
        "EntityFactory (spawns enemies, items, etc.)",
        "LevelFactory",
        "AssetFactory",
        "All of above"
    ]
},
{
    "q": "Why use Factory in Game Dev?",
    "o": [
        "To manage complex initialization involved in spawning (loading assets, setting position)",
        "To be slow",
        "To be fast",
        "To be random"
    ]
},
{
    "q": "Does 'Prototype' pattern work well in Game Dev?",
    "o": [
        "Yes, 'Prefabs' are essentially prototypes cloned by a factory",
        "No",
        "Maybe",
        "Rarely"
    ]
},
{
    "q": "What is a 'Prefab' in Unity?",
    "o": [
        "A pre-configured GameObject stored as asset (Prototype)",
        "A factory",
        "A builder",
        "A singleton"
    ]
},
{
    "q": "Is 'Instantiate()' in Unity a Factory method?",
    "o": [
        "Yes, creates instance from Prefab (Prototype)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Monostate' vs 'Factory'?",
    "o": [
        "Monostate creates objects sharing state; Factory creates distinct objects (usually)",
        "Same",
        "Opposite",
        "Unrelated"
    ]
},
{
    "q": "Can Factory return Monostate objects?",
    "o": [
        "Yes",
        "No",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "What is 'Dependency Inversion' relation to Factory?",
    "o": [
        "Factory allows High-level modules to not depend on Low-level concrete classes",
        "Factory violates it",
        "Factory ignores it",
        "Factory is it"
    ]
},
{
    "q": "Without Factory, 'new Concrete()' violates DIP because:",
    "o": [
        "High-level code mentions Low-level concrete class directly",
        "It is slow",
        "It is fast",
        "It is old"
    ]
},
{
    "q": "Is Factory Pattern 'Creational'?",
    "o": [
        "Yes",
        "No (Structural)",
        "No (Behavioral)",
        "No (J2EE)"
    ]
},
{
    "q": "Who invokes the Factory?",
    "o": [
        "The Client code (Consumer)",
        "The Product",
        "The OS",
        "The Database"
    ]
},
{
    "q": "Can Factory be 'stateful'?",
    "o": [
        "Yes, e.g. keeping count of created objects or IDs",
        "No, must be stateless",
        "No, must be singleton",
        "No, must be void"
    ]
},
{
    "q": "Is 'ID Generator' a factory?",
    "o": [
        "Yes, produces unique IDs (Value Objects)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Snowflake ID'?",
    "o": [
        "Distributed unique ID generator (Twitter)",
        "A snowflake",
        "A ice",
        "A cold"
    ]
},
{
    "q": "Is 'Snowflake' a Singleton Factory?",
    "o": [
        "Conceptually, the generator per node is a Singleton Factory",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is the 'Abstract' in Abstract Factory?",
    "o": [
        "The Factory Interface (and typically the Products are interfaces too)",
        "The class keyword",
        "The method",
        "The variable"
    ]
},
{
    "q": "Can you mix Abstract Factory and Prototype?",
    "o": [
        "Yes, concrete factory can use cloning",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Which pattern is used to switch databases (MySQL vs PostgreSQL) entire layer?",
    "o": [
        "Abstract Factory (createConnection, createCommand specific to DB)",
        "Singleton",
        "Observer",
        "Decorator"
    ]
},
{
    "q": "Does Abstract Factory hide 'new'?",
    "o": [
        "Yes",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Abstract Factory is also known as:",
    "o": [
        "Kit",
        "Tool",
        "Set",
        "Collection"
    ]
},
{
    "q": "Is 'java.awt.Toolkit' an Abstract Factory?",
    "o": [
        "Yes, creates peers for components (ButtonPeer, WindowPeer)",
        "No",
        "Singleton",
        "Strategy"
    ]
},
{
    "q": "Why is 'Toolkit' Abstract Factory?",
    "o": [
        "To support different OS implementations (Windows vs Unix) transparently",
        "To be cool",
        "To be slow",
        "To be fast"
    ]
},
{
    "q": "Is 'BorderFactory' in Swing a Factory?",
    "o": [
        "Yes, creates Border objects (static factory methods)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why use 'BorderFactory' instead of new?",
    "o": [
        "Shared instances (Flyweight) of common borders, convenient syntax",
        "Security",
        "Performance only",
        "Memory only"
    ]
},
{
    "q": "Can Factory Method be private?",
    "o": [
        "No, usually protected (for subclasses) or public; private makes it unusable unless called internally",
        "Yes, always",
        "No, never",
        "Maybe"
    ]
},
{
    "q": "If Factory Method is private, who uses it?",
    "o": [
        "The class itself (e.g. valid for managing internal creation logic)",
        "The client",
        "The subclass",
        "The world"
    ]
},
{
    "q": "What is 'Inner Factory'?",
    "o": [
        "A factory class defined inside the product class (to access private constructor)",
        "A factory inside factory",
        "A private factory",
        "A local factory"
    ]
},
{
    "q": "Why use Inner Factory?",
    "o": [
        "To enforce that only the Factory can create the Product (Product constructor private)",
        "To hide factory",
        "To hide product",
        "To be fast"
    ]
},
{
    "q": "Which pattern creates objects based on a String key?",
    "o": [
        "Parameterized Factory",
        "Abstract Factory",
        "Factory Method",
        "None"
    ]
},
{
    "q": "Is 'Deserialization' a Factory?",
    "o": [
        "Yes, reconstituing objects from stream",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Deserialization call constructor?",
    "o": [
        "No (uses Unsafe or specific JVM hooks), usually first non-serializable parent constructor",
        "Yes, always",
        "No, never",
        "Depends"
    ]
},
{
    "q": "Can Factory Pattern handle versioning of data?",
    "o": [
        "Yes, can return different objects based on version input",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Map.of()' a factory?",
    "o": [
        "Yes, static factory for immutable maps",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can factories be async?",
    "o": [
        "Yes, returning Promise<T> or Future<T>",
        "No",
        "Only in JS",
        "Only in C#"
    ]
},
{
    "q": "When is Async Factory needed?",
    "o": [
        "When creation involves IO (db, network)",
        "Always",
        "Never",
        "For simple objects"
    ]
},
{
    "q": "Is 'java.util.concurrent.ThreadFactory' a Factory?",
    "o": [
        "Yes, interface for creating threads",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why use 'ThreadFactory'?",
    "o": [
        "To parse custom names, priorities, daemon status to threads",
        "To start threads",
        "To stop threads",
        "To count threads"
    ]
},
{
    "q": "Default ThreadFactory name format?",
    "o": [
        "pool-N-thread-M",
        "thread-N",
        "async-N",
        "worker-N"
    ]
},
{
    "q": "Can you use Factory to limit instantiation count?",
    "o": [
        "Yes, factory can track count and throw exception or block",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Multiton' implementation?",
    "o": [
        "A Factory returning instances from a map (keyed access)",
        "Many singletons",
        "A list",
        "A set"
    ]
},
{
    "q": "Is 'Multiton' a Map?",
    "o": [
        "Basically yes, managed by a static method",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern work with 'Immutable' objects?",
    "o": [
        "Yes, perfectly (Factory constructs, then returns read-only)",
        "No",
        "Maybe",
        "Unsure"
    ]
}
,
{
    "q": "What is the 'Curiously Recurring Template Pattern' (CRTP) in C++ used for?",
    "o": [
        "Static polymorphism (compile-time factory logic)",
        "Dynamic polymorphism",
        "Singleton",
        "Builder"
    ]
},
{
    "q": "Can CRTP implement a static factory method in base class that returns derived type?",
    "o": [
        "Yes, avoiding virtual calls",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Factory' primarily about Object Lifecycles?",
    "o": [
        "Yes, typically creation (start of lifecycle)",
        "No, destruction",
        "No, usage",
        "No"
    ]
},
{
    "q": "If Factories manage lifecycle, should they also handle 'disposal'?",
    "o": [
        "Ideally yes (symmetric responsibility), like 'releaseInstance()'",
        "No, never",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "Which framework enforces disposal via Factory?",
    "o": [
        "Microsoft COM (Component Object Model) - IClassFactory",
        "Spring",
        "Hibernate",
        "React"
    ]
},
{
    "q": "What is 'IClassFactory' in COM?",
    "o": [
        "Standard interface for creating COM objects",
        "A java class",
        "A python function",
        "A URL"
    ]
},
{
    "q": "Is 'CORBA' Object Factory standard?",
    "o": [
        "Yes, using Factory Finder",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern aid in 'Dependency Cycles'?",
    "o": [
        "Yes, by using an Abstract Factory interface, you can break cycles (Dependency Inversion)",
        "No, makes it worse",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Circular Dependency' in basic Factory?",
    "o": [
        "Product A needs Product B, Factory creates both, but they need each other in constructor",
        "Simple dependency",
        "No dependency",
        "Linear dependency"
    ]
},
{
    "q": "Solution to Circular Dependency in Factory?",
    "o": [
        "Setter injection (create both raw, then set references) or Lazy property",
        "Use global variables",
        "Crash",
        "Use magic"
    ]
},
{
    "q": "What is 'Lazy Factory'?",
    "o": [
        "A factory that returns a proxy which creates the real object only when methods are called",
        "A slow factory",
        "A stopped factory",
        "A null factory"
    ]
},
{
    "q": "Why use Lazy Factory?",
    "o": [
        "Performance (avoid heavy startup if object not used)",
        "Complexity",
        "Memory usage",
        "Disk space"
    ]
},
{
    "q": "Is 'java.lang.Package.getPackages()' a factory?",
    "o": [
        "Yes, static factory returning array of Packages",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'java.util.regex.Pattern.compile()' a factory?",
    "o": [
        "Yes, static factory creating immutable Pattern object",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why is 'Pattern.compile()' preferred over 'new Pattern()'?",
    "o": [
        "Constructor is private; forces caching/compilation logic through factory",
        "It is slower",
        "It is faster",
        "It is readable"
    ]
},
{
    "q": "Can Factory Pattern be generic in Java?",
    "o": [
        "Yes, Factory<T> { T create(); }",
        "No",
        "Only on Lists",
        "Only on Maps"
    ]
},
{
    "q": "Issue with 'new T()' in Java Generics?",
    "o": [
        "Type erasure prevents it; must use Factory or Class<T> token",
        "It works fine",
        "It is slow",
        "It is unsafe"
    ]
},
{
    "q": "How to implement 'new T()' equivalent in Java?",
    "o": [
        "Pass Class<T> and call reflection, or pass Supplier<T>",
        "Use magic",
        "Use C++",
        "Use Python"
    ]
},
{
    "q": "Which is better: passing Class<T> or Supplier<T>?",
    "o": [
        "Supplier<T> (more flexible, no reflection needed, cleaner in Java 8+)",
        "Class<T>",
        "Both same",
        "None"
    ]
},
{
    "q": "If you pass 'Supplier<T>', is it a Factory?",
    "o": [
        "Yes, a functional interface factory",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Abstract Method' in Factory Method pattern?",
    "o": [
        "The method declared in Creator that subclasses must implement",
        "The product",
        "The client",
        "The main"
    ]
},
{
    "q": "Can Factory Method be defined in an Interface (Java 8)?",
    "o": [
        "Yes, as a default method calling an abstract method, or static method",
        "No",
        "Only Java 9",
        "Only Java 10"
    ]
},
{
    "q": "What is 'Extension Method' factory (C#)?",
    "o": [
        "Static method adding factory capability to existing type syntax",
        "Inheritance",
        "Polymorphism",
        "Encapsulation"
    ]
},
{
    "q": "Can you use Factory to hide non-standard constructors?",
    "o": [
        "Yes, wrap complex constructors with simple factory APIs",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern help with 'Immutable' collections?",
    "o": [
        "Yes, e.g. List.of() returns internal immutable implementations",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'List.of()' introduced in Java 9?",
    "o": [
        "Static Factory Method for immutable lists",
        "Constructor",
        "Builder",
        "Prototype"
    ]
},
{
    "q": "Is 'List.of()' better than 'Arrays.asList()'?",
    "o": [
        "Yes, returns truly immutable list, doesn't allow nulls",
        "No",
        "Same",
        "Worse"
    ]
},
{
    "q": "What is 'Flyweight' often initialized by?",
    "o": [
        "Factory (ensures sharing)",
        "Constructor",
        "Main",
        "Client"
    ]
},
{
    "q": "What is 'Identity Map'?",
    "o": [
        "Pattern ensuring each object is loaded only once per session (Factory caching)",
        "A map of ids",
        "A list of users",
        "A login form"
    ]
},
{
    "q": "Identity Map + Factory = ?",
    "o": [
        "Ensures referential integrity (a.b == a.b)",
        "Nothing",
        "Chaos",
        "Slow app"
    ]
},
{
    "q": "What is 'Domain Factory'?",
    "o": [
        "Factory creating domain objects (Aggregates) enforcing invariants",
        "Website factory",
        "Network factory",
        "Disk factory"
    ]
},
{
    "q": "Should 'Domain Factory' have access to DB?",
    "o": [
        "Ideally no (Repositories do that); Factories just assemble objects",
        "Yes, always",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "If Factory needs data from DB to create object, who calls it?",
    "o": [
        "Repository calls DB, gets data, passes to Factory/Mapper",
        "Factory calls DB",
        "Client calls DB",
        "View calls DB"
    ]
},
{
    "q": "What is 'Data Mapper'?",
    "o": [
        "Layer that moves data between objects and a database (uses factories to build objects)",
        "A map",
        "A list",
        "A graph"
    ]
},
{
    "q": "Is 'Hibernate' a Data Mapper?",
    "o": [
        "Yes (mostly, though implements JPA which is container-managed)",
        "No, Active Record",
        "No, Table Module",
        "No, Transaction Script"
    ]
},
{
    "q": "Is 'Active Record' a Factory?",
    "o": [
        "Objects wrap row data and have save/load methods; static finders act as factories",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Which is more testable: Active Record or Data Mapper (with Factories)?",
    "o": [
        "Data Mapper (decouples domain from DB)",
        "Active Record",
        "Both same",
        "Neither"
    ]
},
{
    "q": "Does Factory Pattern improve 'readability'?",
    "o": [
        "Yes, 'Time.now()' is clearer than 'new Time(System.currentTimeMillis())'",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory Method' in refactoring?",
    "o": [
        "Replace Constructor with Factory Method",
        "Rename Method",
        "Extract Class",
        "Move Field"
    ]
},
{
    "q": "When refactoring to Factory, what do you do with Constructor?",
    "o": [
        "Make it private or protected",
        "Delete it",
        "Make it public",
        "Make it static"
    ]
},
{
    "q": "Can Factory be 'Lazy'?",
    "o": [
        "Yes, delay initialization of factory itself or products",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "How to implement 'Lazy Factory'?",
    "o": [
        "Use Supplier<T> with memoization, or Double Checked Locking",
        "Use sleep",
        "Use wait",
        "Use recursion"
    ]
},
{
    "q": "Is 'Singleton' a special case of 'Factory'?",
    "o": [
        "Yes, a factory that always returns the same instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Service Locator' a Factory?",
    "o": [
        "Yes, a global factory for finding services (Anti-pattern often)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why is 'Service Locator' considered anti-pattern?",
    "o": [
        "Hides dependencies (uses global lookup inside code instead of explicit injection)",
        "It is slow",
        "It is fast",
        "It is complex"
    ]
},
{
    "q": "When is 'Service Locator' acceptable?",
    "o": [
        "In infrastructure code or when DI is impossible",
        "Always",
        "Never",
        "For simple apps"
    ]
},
{
    "q": "What is 'Plugin Factory'?",
    "o": [
        "Factory that discovers and loads plugins at runtime",
        "A plugin",
        "A browser",
        "A tool"
    ]
},
{
    "q": "Can you use 'osgi' as a Factory system?",
    "o": [
        "Yes, OSGi service registry acts as a dynamic factory/locator",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'BundleContext' in OSGi?",
    "o": [
        "Context to retrieve service references (Factory-like access)",
        "A bundle",
        "A jar",
        "A zip"
    ]
},
{
    "q": "What is 'Eclipse Extension Point'?",
    "o": [
        "XML definition of where extensions (factories) can be plugged in",
        "A point",
        "A line",
        "A circle"
    ]
},
{
    "q": "Does Factory Pattern work with 'Module System' (JPMS)?",
    "o": [
        "Yes, module-info.java uses 'provides ... with ...' for ServiceLoader factories",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What does 'provides' keyword do in Java 9?",
    "o": [
        "Declares a service implementation factory",
        "Imports",
        "Exports",
        "Requires"
    ]
},
{
    "q": "What does 'uses' keyword do in Java 9?",
    "o": [
        "Declares usage of a service (via ServiceLoader factory)",
        "Imports",
        "Exports",
        "Provides"
    ]
},
{
    "q": "Can Factory Pattern be used in 'scripting'?",
    "o": [
        "Yes, factory can load script engine",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'ScriptEngineManager' a Factory?",
    "o": [
        "Yes, creates ScriptEngines (getEngineByName)",
        "No",
        "Singleton",
        "Observer"
    ]
},
{
    "q": "Can Factory return 'Future'?",
    "o": [
        "Yes, for async creation",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'CompletableFuture.supplyAsync'?",
    "o": [
        "A static factory method creating an async future",
        "A singleton",
        "A builder",
        "A prototype"
    ]
},
{
    "q": "Can Factory return 'Stream'?",
    "o": [
        "Yes, Stream.of(), Arrays.stream() are factories",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Stream.generate()' a Factory?",
    "o": [
        "Yes, creates an infinite stream using a Supplier factory",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Stream.iterate()'?",
    "o": [
        "Factory for sequential stream",
        "Loop",
        "Recursion",
        "Map"
    ]
},
{
    "q": "Does Factory Pattern support 'Dependency Hierarchy'?",
    "o": [
        "Yes, factories can depend on other factories",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Hierarchical BeanFactory' in Spring?",
    "o": [
        "A factory that can have a parent factory (for scoping)",
        "A tree",
        "A graph",
        "A list"
    ]
},
{
    "q": "Can Factory Pattern allow hot-swapping?",
    "o": [
        "Yes, factory can start returning new implementation classes at runtime",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "How to implement Hot-Swapping Factory?",
    "o": [
        "Use custom ClassLoader or Proxy that delegates to swappable target",
        "Restart app",
        "Recompile",
        "Cannot"
    ]
},
{
    "q": "Is 'JRebel' related to Factory?",
    "o": [
        "It hot-swaps classes, arguably patching frame-level factories/loaders",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory Pattern mask 'Remote Exception'?",
    "o": [
        "Yes, catch RemoteException and wrap in RuntimeException during creation",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Should Factory throw Checked Exceptions?",
    "o": [
        "Generally avoid if possible (use Runtime), or define CreationException",
        "Yes, always",
        "No, never",
        "Depends"
    ]
},
{
    "q": "What is 'Factory Method' in UML?",
    "o": [
        "Operation in a class returning object of another class",
        "A box",
        "A line",
        "A circle"
    ]
},
{
    "q": "Is 'Driver' in 'DriverManager' a Factory?",
    "o": [
        "The Driver interface has method 'connect' which is a factory method",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Are 'Iterators' Factories?",
    "o": [
        "No, 'iterator()' is the factory method; Iterator is the product (cursor)",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What checks should a Factory perform?",
    "o": [
        "Validation of arguments, permissions, resource availability",
        "None",
        "Print logs",
        "Sleep"
    ]
},
{
    "q": "Can Factory return 'Optional'?",
    "o": [
        "Yes, if creation might logically fail without exception",
        "No",
        "Only Java 8",
        "Only Java 9"
    ]
},
{
    "q": "When to return Optional from Factory?",
    "o": [
        "When 'not found' or 'cannot create' is a valid business state",
        "Always",
        "Never",
        "On error"
    ]
},
{
    "q": "Can Factory use 'varargs'?",
    "o": [
        "Yes, useful for flexible product constructors",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Arrays.asList' a varargs factory?",
    "o": [
        "Yes",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does 'Arrays.asList' return new ArrayList?",
    "o": [
        "No, returns a fixed-size list backed by the array (View)",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'new ArrayList<>(Arrays.asList())' a copy?",
    "o": [
        "Yes, enables resizing (Copy Constructor pattern)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Copy Factory'?",
    "o": [
        "Static factory method 'copy(Original)'",
        "Clone",
        "New",
        "Duplicate"
    ]
},
{
    "q": "Is 'Instant.from(TemporalAccessor)' a copy factory?",
    "o": [
        "Yes, creates Instant from another temporal object",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Conversion Factory'?",
    "o": [
        "Factory converting Type A to Type B (Adapter-like)",
        "Converter",
        "Transformer",
        "Mapper"
    ]
},
{
    "q": "Is 'String.valueOf()' a conversion factory?",
    "o": [
        "Yes, converts primitives/objects to String instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern improve encapsulation?",
    "o": [
        "Yes, hides concrete classes and construction logic",
        "No",
        "Reduces it",
        "Neutral"
    ]
},
{
    "q": "Can Factory reduce JAR size?",
    "o": [
        "Technically no, allows code splitting if reflective factories used",
        "Yes",
        "No",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern work with 'Serialization'?",
    "o": [
        "Use Serialization Proxy pattern (writeReplace) to use factory/constructor on read",
        "No",
        "Automatically",
        "Magic"
    ]
},
{
    "q": "What is 'readResolve' relation to Factory?",
    "o": [
        "Can call a factory to ensure singleton property or canonical instance",
        "Nothing",
        "Delete",
        "Create"
    ]
}
,
{
    "q": "What is 'Factory Method' in context of 'Virtual Constructors' in C++?",
    "o": [
        "It simulates virtual constructor using a virtual 'clone' or 'create' method",
        "It is native",
        "It is magic",
        "It is forbidden"
    ]
},
{
    "q": "Is 'Prototype Pattern' relying on 'Factory Method'?",
    "o": [
        "Yes, the 'clone()' method is a factory method",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can you use Factory to implement 'Polymorphic Deserialization'?",
    "o": [
        "Yes, read type tag -> lookup factory -> create instance",
        "No",
        "Only in XML",
        "Only in JSON"
    ]
},
{
    "q": "What is 'Factory' in 'Domain-Driven Design' (DDD)?",
    "o": [
        "An element of the domain model layer, responsible for creating Aggregates",
        "A fast class",
        "A view component",
        "A database table"
    ]
},
{
    "q": "DDD Factory vs Repository?",
    "o": [
        "Factory works on creation (new lifecycle start); Repository works on retrieval (usually reconstituting)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Should a DDD Factory generate IDs?",
    "o": [
        "Yes, often ensures identity uniqueness upon creation",
        "No, never",
        "Maybe",
        "Depends"
    ]
},
{
    "q": "What is 'Entity Factory'?",
    "o": [
        "Factory creating entities (mutable, have identity)",
        "Factory creating values",
        "Factory creating services",
        "Factory creating nulls"
    ]
},
{
    "q": "What is 'Value Object Factory'?",
    "o": [
        "Factory creating value objects (immutable, equality by value)",
        "Factory creating entities",
        "Factory creating services",
        "Factory creating nulls"
    ]
},
{
    "q": "Does Factory work with 'Event Sourcing'?",
    "o": [
        "Yes, factory can reconstitute state from history of events",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern aid in 'Migration'?",
    "o": [
        "Yes, factories can redirect creation to new classes during migration",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory be a 'Closure'?",
    "o": [
        "Yes, especially in functional languages (JS, Scala, etc.)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Closure factory benefit?",
    "o": [
        "Can capture context (config) without explicit class fields",
        "Faster",
        "Slower",
        "Cleaner"
    ]
},
{
    "q": "Is 'Factory' applicable in a 'Serverless' environment?",
    "o": [
        "Yes, creating handler instances or connections",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Are 'AWS Lambda' handlers Factories?",
    "o": [
        "The runtime uses a factory mechanism to instantiate the handler class",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory' in 'Google Guava'?",
    "o": [
        "Utility classes like Lists.newArrayList() (Static factories)",
        "Abstract Factory",
        "Singleton",
        "Builder"
    ]
},
{
    "q": "Why did Guava use static factories before Java 7?",
    "o": [
        "Type Inference (generic methods could infer type T, constructors could not)",
        "Performance",
        "Style",
        "Security"
    ]
},
{
    "q": "Does Java 7 'Diamond Operator' reduce need for Guava factories?",
    "o": [
        "Yes, 'new ArrayList<>()' mostly replaced 'Lists.newArrayList()'",
        "No, meaningless",
        "Makes it worse",
        "Unsure"
    ]
},
{
    "q": "Is 'CompletableFuture.completedFuture()' a factory?",
    "o": [
        "Yes, static factory returning completed future",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern help in 'Localization'?",
    "o": [
        "Yes, factory can return localized versions of components",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'ResourceBundle.getBundle()'?",
    "o": [
        "Factory Method loading correct bundle for locale",
        "Singleton",
        "Builder",
        "Strategy"
    ]
},
{
    "q": "Can Factory Pattern be used to enforce 'Single Threaded' usage?",
    "o": [
        "Yes, factory can check current thread ID",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'ThreadLocal.withInitial()' a factory?",
    "o": [
        "Yes, takes a Supplier factory for initial value",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can you combine 'Factory' and 'Decorator'?",
    "o": [
        "Yes, Factory can wrap the Created product in Decorators before returning",
        "No",
        "Impossible",
        "Useless"
    ]
},
{
    "q": "Example of Factory + Decorator?",
    "o": [
        "Collections.synchronizedList() (Factory method wrapping list in Synchronized wrapper)",
        "System.out",
        "String.toString",
        "Math.abs"
    ]
},
{
    "q": "Is 'Collections.unmodifiableList()' a factory?",
    "o": [
        "Yes, creates a View (wrapper) object",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory Pattern hide 'Lazy Loading' implementation?",
    "o": [
        "Yes, transparently returns a proxy that loads data later",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory' in 'Redux'?",
    "o": [
        "Action Creators (Factories for action objects)",
        "Reducers",
        "Store",
        "Middleware"
    ]
},
{
    "q": "Why use Action Creators in Redux?",
    "o": [
        "Encapsulate creation logic, consistent action structure",
        "Complexity",
        "Slowness",
        "Verbosity"
    ]
},
{
    "q": "What is 'Thunk' in Redux?",
    "o": [
        "A factory function returning another function (for async logic)",
        "A value",
        "A state",
        "A store"
    ]
},
{
    "q": "Is 'Promise.resolve()' a factory?",
    "o": [
        "Yes, creates a resolved Promise",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Promise.reject()' a factory?",
    "o": [
        "Yes, creates a rejected Promise",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory' in 'Apache Commons Collections'?",
    "o": [
        "Factory interface (create() method) used for generating collection elements",
        "A list",
        "A map",
        "A set"
    ]
},
{
    "q": "What is 'LazyList' in Apache Commons?",
    "o": [
        "List that populates itself on demand using a Factory",
        "Slow list",
        "Empty list",
        "Full list"
    ]
},
{
    "q": "Does Factory Pattern work with 'Generics' type inference?",
    "o": [
        "Yes, static factories are good for this (pre-diamond operator)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory Pattern be 'Context Aware'?",
    "o": [
        "Yes, create(Context) passing context info",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Android ViewModelProvider' a factory?",
    "o": [
        "Yes, creates ViewModels, ensuring retention across config changes",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why 'ViewModelProvider.Factory' interface exists?",
    "o": [
        "To instantiate ViewModels that have constructor dependencies",
        "To confuse devs",
        "To be slow",
        "To be complex"
    ]
},
{
    "q": "Default ViewModel factory creates classes using:",
    "o": [
        "Reflection (newInstance)",
        "Magic",
        "Code Gen",
        "Static calls"
    ]
},
{
    "q": "What is 'FragmentFactory' in Android?",
    "o": [
        "Class to control Fragment instantiation (allows constructor injection)",
        "Fragment manager",
        "Fragment view",
        "Fragment holder"
    ]
},
{
    "q": "Why was FragmentFactory introduced?",
    "o": [
        "To solve the empty constructor requirement for Fragments (enabling DI)",
        "To be slower",
        "To be complex",
        "To break apps"
    ]
},
{
    "q": "Can Factory Pattern help 'Feature Flagging'?",
    "o": [
        "Yes, factory decides which impl to return based on flag",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Factory' in 'Log4j2'?",
    "o": [
        "LogManager (Factory) returning Logger",
        "Appender",
        "Layout",
        "Filter"
    ]
},
{
    "q": "Can Factory Pattern be 'Recursive'?",
    "o": [
        "Yes, factory calling itself (e.g. creating node children)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What prevents infinite recursion in Recursive Factory?",
    "o": [
        "Base case / Termination condition",
        "Nothing",
        "StackOverflowError",
        "Memory"
    ]
},
{
    "q": "Is 'Class.forName' a factory?",
    "o": [
        "Factory that returns Class object",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Proxy.newProxyInstance'?",
    "o": [
        "Static Factory for dynamic proxies",
        "Constructor",
        "Singleton",
        "Builder"
    ]
},
{
    "q": "Can Factory Pattern ease 'Mocking' of final classes?",
    "o": [
        "Yes, by wrapping creation in an interface-based Factory, you mock the factory",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'URL.setURLStreamHandlerFactory' used for?",
    "o": [
        "Injecting custom protocol handlers (http, ftp, custom)",
        "Security",
        "Performance",
        "Logging"
    ]
},
{
    "q": "Is 'SocketFactory' in Java generic?",
    "o": [
        "No, javax.net.SocketFactory is an abstract class",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'SSLSocketFactory'?",
    "o": [
        "Factory for secure sockets",
        "Factory for text",
        "Factory for file",
        "Factory for zip"
    ]
},
{
    "q": "How to get default SSLSocketFactory?",
    "o": [
        "SSLSocketFactory.getDefault() (Static Factory)",
        "new SSLSocketFactory()",
        "Magic",
        "Network"
    ]
},
{
    "q": "Is 'Charset.forName()' a factory?",
    "o": [
        "Yes, returns Charset instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory return 'Singleton'?",
    "o": [
        "Yes, factory can be configured to cache and return same instance",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Spring Context' a giant Factory?",
    "o": [
        "Yes (Bean Factory), managing lifecycles",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'ApplicationContext' vs 'BeanFactory'?",
    "o": [
        "ApplicationContext extends BeanFactory with enterprise features (events, i18n)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Which is preferred in Spring?",
    "o": [
        "ApplicationContext",
        "BeanFactory",
        "Neither",
        "Both"
    ]
},
{
    "q": "Why prefer ApplicationContext?",
    "o": [
        "Integration with AOP, message resources, event propagation",
        "Speed",
        "Memory",
        "Simplicity"
    ]
},
{
    "q": "When to use plain BeanFactory?",
    "o": [
        "Memory constrained environments (rare nowadays)",
        "Always",
        "Never",
        "For web apps"
    ]
},
{
    "q": "What is 'ObjectProvider' in Spring 5?",
    "o": [
        "A variant of ObjectFactory with stream/optional support",
        "A singleton",
        "A builder",
        "A prototype"
    ]
},
{
    "q": "Is 'Lookup Method Injection' using Factory underneath?",
    "o": [
        "Yes, CGLIB generates a subclass overriding the method to return new bean",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern support 'Open-Closed Principle'?",
    "o": [
        "Yes, new products can be added without modifying existing client code (if using factory interface)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does Factory Pattern support 'Single Responsibility Principle'?",
    "o": [
        "Yes, separates creation logic from business logic",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is Factory Pattern 'GoF'?",
    "o": [
        "Yes (Factory Method & Abstract Factory)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Where is Factory Pattern defined?",
    "o": [
        "Design Patterns: Elements of Reusable Object-Oriented Software",
        "Clean Code",
        "Refactoring",
        "Code Complete"
    ]
},
{
    "q": "Who are the 'Gang of Four'?",
    "o": [
        "Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides",
        "Beatles",
        "Rolling Stones",
        "Pink Floyd"
    ]
},
{
    "q": "Is 'Simple Factory' a formal GoF pattern?",
    "o": [
        "No, it's a programming idiom, simpler than Factory Method",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Factory Pattern be abused?",
    "o": [
        "Yes, creating factories for everything (Lasagna Code)",
        "No",
        "Never",
        "Only by juniors"
    ]
},
{
    "q": "What is 'Lasagna Code'?",
    "o": [
        "Too many layers of abstraction (Factories calling Factories)",
        "Spaghetti code",
        "Ravioli code",
        "Pizza code"
    ]
},
{
    "q": "What is 'Ravioli Code'?",
    "o": [
        "Many small classes (good decoupling, but can be hard to navigate)",
        "Big classes",
        "Messy code",
        "Clean code"
    ]
},
{
    "q": "Does Factory Pattern contribute to Ravioli Code?",
    "o": [
        "Yes, tends to create many small classes",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "When to stop using Factory?",
    "o": [
        "When 'new' is sufficient and flexibility is not needed yet (YAGNI)",
        "Never",
        "Always",
        "On Tuesday"
    ]
},
{
    "q": "Is 'YAGNI' relevant to Factory?",
    "o": [
        "Yes, don't build a factory until you need the abstraction",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'KISS' principle?",
    "o": [
        "Keep It Simple, Stupid",
        "Keep It Super Safe",
        "Keep It So Slow",
        "Keep It Static"
    ]
},
{
    "q": "Does Factory violate KISS?",
    "o": [
        "Can violate if over-engineered for simple problems",
        "Yes, always",
        "No, never",
        "Depends"
    ]
},
{
    "q": "What is 'DRY' principle?",
    "o": [
        "Don't Repeat Yourself",
        "Don't Run Yet",
        "Do Repeat Yourself",
        "Do Run Yet"
    ]
},
{
    "q": "Does Factory help DRY?",
    "o": [
        "Yes, centralizes 'new' logic in one place",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Service Factory' pattern?",
    "o": [
        "Factory that produces Service instances",
        "Factory that produces Data",
        "Factory that produces UI",
        "Factory that produces CSS"
    ]
},
{
    "q": "Can Factory Pattern create 'Value Types' in C#?",
    "o": [
        "Yes, though they are structs (stack allocated usually), boxing might occur if return type is interface",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Boxing overhead with Factory returning interface?",
    "o": [
        "Yes, if factory creates struct but returns interface, struct is boxed to heap",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Is 'Task.Run()' a factory?",
    "o": [
        "Yes, creates and starts a Task",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Task.Factory.StartNew'?",
    "o": [
        "Another factory method for Tasks (more low level options)",
        "Constructor",
        "Destructor",
        "Singleton"
    ]
},
{
    "q": "Which is preferred: Task.Run or Task.Factory.StartNew?",
    "o": [
        "Task.Run (simpler, safer defaults)",
        "Task.Factory.StartNew",
        "Neither",
        "Both"
    ]
},
{
    "q": "Can Factory manage 'Tenant' context in SaaS?",
    "o": [
        "Yes, returning tenant-specific implementations or configured objects",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Multi-Tenant Factory'?",
    "o": [
        "Factory using TenantID to decide what to create",
        "Single factory",
        "Global factory",
        "Static factory"
    ]
},
{
    "q": "Is 'DriverFactory' in Selenium?",
    "o": [
        "Common pattern to create WebDriver (Chrome, Firefox) based on config",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Why use Factory in Selenium tests?",
    "o": [
        "To run same tests on different browsers easily",
        "To be fast",
        "To be slow",
        "To use memory"
    ]
},
{
    "q": "Can Factory Pattern be 'Cloud Native'?",
    "o": [
        "Yes, abstracting cloud provider services (AWS vs Azure impls)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Cloud Abstraction Layer'?",
    "o": [
        "Interfaces + Factories to switch cloud providers",
        "A cloud",
        "A sky",
        "A storm"
    ]
},
{
    "q": "Is 'BucketFactory'?",
    "o": [
        "Example name for S3/Blob storage factory",
        "A bucket",
        "A pail",
        "A cup"
    ]
},
{
    "q": "Does Factory Pattern help with 'Mock Data'?",
    "o": [
        "Yes, factory can read JSON/CSV and produce objects for testing",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Fixture Factory'?",
    "o": [
        "Factory creating test fixtures (consistent test data)",
        "A light",
        "A lamp",
        "A bulb"
    ]
}
]