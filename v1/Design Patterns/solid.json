[
    {
        "q": "What does SOLID stand for?",
        "o": [
            "SRP, OCP, LSP, ISP, DIP",
            "Simple, Open, Large, Interface, Data",
            "Single, Open, Liskov, Interface, Dependency",
            "Secure, Open, Light, Integrated, Distributed"
        ]
    },
    {
        "q": "What is 'SRP'?",
        "o": [
            "Single Responsibility Principle (A class should have one reason to change)",
            "Single Role Protocol",
            "Simple Request Process",
            "Static Reference Pointer"
        ]
    },
    {
        "q": "What is 'OCP'?",
        "o": [
            "Open/Closed Principle (Open for extension, closed for modification)",
            "Object Control Protocol",
            "Optimized Code Practice",
            "Optional Class Parameter"
        ]
    },
    {
        "q": "What is 'LSP'?",
        "o": [
            "Liskov Substitution Principle (Subtypes must be substitutable for base types)",
            "Late Static Polarity",
            "List Service Provider",
            "Logic State Pattern"
        ]
    },
    {
        "q": "What is 'ISP'?",
        "o": [
            "Interface Segregation Principle (Clients shouldn't depend on unused methods)",
            "Internet Service Provider",
            "Integrated System Protocol",
            "Internal State Property"
        ]
    },
    {
        "q": "What is 'DIP'?",
        "o": [
            "Dependency Inversion Principle (Depend on abstractions, not concretions)",
            "Direct Injection Protocol",
            "Data Input Property",
            "Dynamic Invocation Pattern"
        ]
    },
    {
        "q": "Who introduced SOLID?",
        "o": [
            "Robert C. Martin (Uncle Bob)",
            "Martin Fowler",
            "Kent Beck",
            "Erich Gamma"
        ]
    },
    {
        "q": "Does SRP mean 'do one thing'?",
        "o": [
            "Not exactly 'one function', but 'one responsibility' (one actor requesting changes)",
            "Yes, literally",
            "No, it means do many things",
            "It means one file"
        ]
    },
    {
        "q": "Example of SRP violation?",
        "o": [
            "User class handling both Authentication and Database Saving",
            "User class having name and email",
            "User class having getters",
            "User class implementing Serializable"
        ]
    },
    {
        "q": "How to fix SRP violation?",
        "o": [
            "Extract Class / Delegate responsibilities (e.g. UserRepository, AuthService)",
            "Make methods private",
            "Add comments",
            "Use static methods"
        ]
    },
    {
        "q": "Example of OCP violation?",
        "o": [
            "Switch statement checking type of object to determine logic (modifying switch for new types)",
            "Using an interface",
            "Using polymorphism",
            "Using inheritance"
        ]
    },
    {
        "q": "How to fix OCP violation?",
        "o": [
            "Use Polymerphism (Strategy Pattern) so new types add new classes without touching client",
            "Use bigger switch",
            "Use if-else",
            "Use Reflection"
        ]
    },
    {
        "q": "LSP violation example?",
        "o": [
            "Rectangle/Square problem (Square extending Rectangle and breaking setWidth/setHeight contract)",
            "Cat extends Animal",
            "Dog extends Pet",
            "Car extends Vehicle"
        ]
    },
    {
        "q": "What happens if LSP is violated?",
        "o": [
            "Polymorphism breaks; client code crashes or behaves incorrectly when using subclass",
            "Code is faster",
            "Code is smaller",
            "Nothing"
        ]
    },
    {
        "q": "ISP violation example?",
        "o": [
            "Fat Interface (God Interface) forcing implementers to implement throw new UnsupportedOperationException()",
            "Small interface",
            "Single method interface",
            "Marker interface"
        ]
    },
    {
        "q": "How to fix ISP violation?",
        "o": [
            "Split Fat Interface into smaller, specific interfaces (Role Interfaces)",
            "Implement all methods",
            "Return null",
            "Ignore"
        ]
    },
    {
        "q": "DIP violation example?",
        "o": [
            "High-level Business Logic class instantiating Low-level Database class directly (new SQLDatabase())",
            "Service calling Repository Interface",
            "Controller calling Service Interface",
            "Bean injection"
        ]
    },
    {
        "q": "How to fix DIP violation?",
        "o": [
            "Invert dependency: Both should depend on Abstraction (Interface), injected via Constructor",
            "Use static",
            "Use singleton",
            "Use global"
        ]
    },
    {
        "q": "Is Dependency Injection (DI) same as DIP?",
        "o": [
            "DI is a technique to implement DIP",
            "Yes, identical",
            "No, unrelated",
            "Opposite"
        ]
    },
    {
        "q": "What is 'Coupling'?",
        "o": [
            "Degree of interdependence between software modules (SOLID aims for Low Coupling)",
            "High Coupling",
            "No Coupling",
            "Tight Coupling"
        ]
    },
    {
        "q": "What is 'Cohesion'?",
        "o": [
            "Degree to which elements inside a module belong together (SOLID aims for High Cohesion)",
            "Low Cohesion",
            "No Cohesion",
            "Loose Cohesion"
        ]
    },
    {
        "q": "Does SRP increase Cohesion?",
        "o": [
            "Yes, by grouping related things and separating unrelated things",
            "No",
            "Decreases it",
            "Neutral"
        ]
    },
    {
        "q": "Does DIP decrease Coupling?",
        "o": [
            "Yes, by decoupling implementations via abstractions",
            "No",
            "Increases it",
            "Neutral"
        ]
    },
    {
        "q": "Rigidity (Code Smell)?",
        "o": [
            "Hard to change because every change affects many other parts (Fixed by OCP/DIP)",
            "Flexible",
            "Soft",
            "Liquid"
        ]
    },
    {
        "q": "Fragility (Code Smell)?",
        "o": [
            "Changes cause breaks in conceptually unrelated parts",
            "Strong",
            "Robust",
            "Hard"
        ]
    },
    {
        "q": "Immobility (Code Smell)?",
        "o": [
            "Hard to reuse code because it has too much baggage (Fixed by ISP/SRP)",
            "Portable",
            "Mobile",
            "Fast"
        ]
    },
    {
        "q": "Viscosity (Code Smell)?",
        "o": [
            "Easier to do the wrong thing (hack) than the right thing",
            "Fluidity",
            "Smoothness",
            "Speed"
        ]
    },
    {
        "q": "Is Interface Segregation about 'Interfaces' keyword only?",
        "o": [
            "No, applies to abstract base classes or any public API surface",
            "Yes",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Composition over Inheritance?",
        "o": [
            "Favor holding a reference to a class (Composition) over extending it (Inheritance) - related to LSP/OCP",
            "Inheritance is better",
            "Neither",
            "Both"
        ]
    },
    {
        "q": "Why Composition is often better?",
        "o": [
            "More flexible (change behavior at runtime), less rigid coupling than 'is-a'",
            "Less typing",
            "More performance",
            "More memory"
        ]
    },
    {
        "q": "What is 'Code Rot'?",
        "o": [
            "Accumulation of technical debt and violation of design principles",
            "Good code",
            "Fresh code",
            "Clean code"
        ]
    },
    {
        "q": "Does SOLID prevent bugs?",
        "o": [
            "Indirectly, by making code easier to understand, test, and maintain",
            "Yes, strictly",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Is SOLID only for OOP?",
        "o": [
            "Originally OOP, but principles apply to modules/functions (SFP) often",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Can you over-engineer with SOLID?",
        "o": [
            "Yes, creating too many tiny classes/interfaces (Fragmentation)",
            "No",
            "Impossible",
            "Never"
        ]
    },
    {
        "q": "YAGNI vs SOLID?",
        "o": [
            "Balance needed; don't create OCP abstractions for things that never change (YAGNI)",
            "Ignore SOLID",
            "Ignore YAGNI",
            "Conflict"
        ]
    },
    {
        "q": "KISS vs SOLID?",
        "o": [
            "Start Simple (KISS), refactor to SOLID when complexity warrants it",
            "Conflict",
            "Opposite",
            "Same"
        ]
    },
    {
        "q": "What is 'Programming to an Interface'?",
        "o": [
            "Declaring variables/parameters using Interface types (List vs ArrayList) - supports DIP/LSP",
            "Using classes",
            "Using static",
            "Using void"
        ]
    },
    {
        "q": "Which Pattern heavily uses OCP?",
        "o": [
            "Strategy Pattern, Observer Pattern, Decorator Pattern",
            "Singleton",
            "Monolith",
            "Spaghetti"
        ]
    },
    {
        "q": "Which Principle helps Unit Testing most?",
        "o": [
            "DIP (allows mocking dependencies) and SRP (smaller units)",
            "None",
            "ISP",
            "LSP"
        ]
    },
    {
        "q": "Can a class implement multiple interfaces?",
        "o": [
            "Yes, this is key to ISP (implementing only what applies)",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Does Abstract Class help OCP?",
        "o": [
            "Yes, allows defining template methods and open hooks for extensions",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Are static methods good for SOLID?",
        "o": [
            "Often bad; hard to mock/inject (DIP violation), tight coupling",
            "Good",
            "Best",
            "Fast"
        ]
    },
    {
        "q": "Is 'Singleton' SOLID?",
        "o": [
            "Often violates SRP (manages own instance) and makes DIP hard (global state)",
            "Yes, very SOLID",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "What is 'Inversion of Control' container?",
        "o": [
            "Tool managing dependency injection (Spring, Guice)",
            "Box",
            "Bag",
            "Bin"
        ]
    },
    {
        "q": "Manual Dependency Injection?",
        "o": [
            "Pure DI (passing dependencies in constructor manually without framework)",
            "Impossible",
            "Hard",
            "Wrong"
        ]
    },
    {
        "q": "Service Locator Pattern vs DI?",
        "o": [
            "Service Locator hides dependencies (asking for them); DI makes them explicit",
            "Same",
            "Opposite",
            "Unknown"
        ]
    },
    {
        "q": "Is Service Locator an Anti-pattern?",
        "o": [
            "Often considered so, because it obscures dependencies and coupling",
            "No",
            "Best practice",
            "Required"
        ]
    },
    {
        "q": "Law of Demeter (LoD)?",
        "o": [
            "Principle of Least Knowledge (talk only to immediate friends, don't chain calls a.getB().getC().action())",
            "Talk to everyone",
            "Chain everything",
            "Global access"
        ]
    },
    {
        "q": "Does LoD relate to SOLID?",
        "o": [
            "Supports Low Coupling (similar goal to DIP/SRP)",
            "No",
            "Opposite",
            "Maybe"
        ]
    },
    {
        "q": "Fluent Interface vs LoD?",
        "o": [
            "Fluent Interface (Builder) mimics chaining but usually stays within same context (Internal DSL), so often acceptable violation",
            "Violation always",
            "Bad",
            "Good"
        ]
    },
    {
        "q": "Active Record Pattern vs SRP?",
        "o": [
            "Violates SRP (Mixing Domain Logic + DB Access)",
            "Follows SRP",
            "Neutral",
            "Best"
        ]
    },
    {
        "q": "Repository Pattern vs SRP?",
        "o": [
            "Promotes SRP (Separates Data Access from Domain Logic)",
            "Violates SRP",
            "Neutral",
            "Worst"
        ]
    },
    {
        "q": "Private methods and SRP?",
        "o": [
            "Private methods are implementation details; if they grow too disjointed, extract class",
            "Always bad",
            "Always good",
            "Ignore"
        ]
    },
    {
        "q": "Does 'Refactoring' aim for SOLID?",
        "o": [
            "Yes, many refactorings (Extract Method, Pull Up Field) align with SOLID goals",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "What is 'Technical Debt'?",
        "o": [
            "Cost of additional rework caused by choosing an easy solution now instead of a better one later",
            "Money",
            "Loan",
            "Credit"
        ]
    },
    {
        "q": "What is 'Clean Code'?",
        "o": [
            "Code that is easy to understand and easy to change (often following SOLID)",
            "Short code",
            "Fast code",
            "Commented code"
        ]
    },
    {
        "q": "What is 'Code Smell'?",
        "o": [
            "Surface indication that usually corresponds to a deeper problem in the system",
            "Bad smell",
            "Bug",
            "Error"
        ]
    },
    {
        "q": "Is 'Long Method' a smell?",
        "o": [
            "Yes, suggest SRP violation",
            "No",
            "Good",
            "Fast"
        ]
    },
    {
        "q": "Is 'Large Class' a smell?",
        "o": [
            "Yes, suggests SRP violation (God Class)",
            "No",
            "Good",
            "Powerful"
        ]
    },
    {
        "q": "Is 'Primitive Obsession' a smell?",
        "o": [
            "Using primitives instead of small objects (e.g. String for Phone Number) - Missed opportunity for logic/validation",
            "No",
            "Good",
            "Fast"
        ]
    },
    {
        "q": "Is 'Data Clumps' a smell?",
        "o": [
            "Fields that always appear together (start/end date) - should be extracted to Class",
            "No",
            "Good",
            "Fast"
        ]
    },
    {
        "q": "Is 'Switch Statements' a smell?",
        "o": [
            "Ideally replaced by Polymorphism (OCP)",
            "No",
            "Good",
            "Fast"
        ]
    },
    {
        "q": "Is 'Shotgun Surgery' a smell?",
        "o": [
            "Making many small changes in many classes for one requirement (High Coupling/Low Cohesion)",
            "Gun",
            "Medical",
            "Fast"
        ]
    },
    {
        "q": "Is 'Divergent Change' a smell?",
        "o": [
            "One class changed in different ways for different reasons (SRP violation)",
            "Good",
            "Fast",
            "Stable"
        ]
    },
    {
        "q": "What is 'Refused Bequest'?",
        "o": [
            "Subclass uses only some of parent behavior (LSP/ISP smell)",
            "Inheritance",
            "Gift",
            "Money"
        ]
    },
    {
        "q": "What if LSP is broken?",
        "o": [
            "You might need `if (obj instanceof SubClass)` checks - bad OCP",
            "It is fine",
            "It is fast",
            "It works"
        ]
    },
    {
        "q": "Covariance in return types?",
        "o": [
            "Subclass overridden method can return a subtype of parent return type (LSP compliant)",
            "No",
            "Contravariance",
            "Invariant"
        ]
    },
    {
        "q": "Contravariance in arguments?",
        "o": [
            "Subclass method could theoretically accept supertype of parent arguments (LSP), but rarely supported",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Checked Exceptions and OCP?",
        "o": [
            "Adding a checked exception to method signature breaks existing clients (OCP violation usually)",
            "Good practice",
            "Safe",
            "Required"
        ]
    },
    {
        "q": "What is 'Feature Envy'?",
        "o": [
            "Method in one class uses data/methods of another class more than its own (Move Method)",
            "Jealousy",
            "Love",
            "Hate"
        ]
    },
    {
        "q": "Tell, Don't Ask?",
        "o": [
            "Tell objects what to do, don't ask for their state and decide yourself (Encapsulation)",
            "Ask always",
            "Query",
            "Search"
        ]
    },
    {
        "q": "Anemic Domain Model vs Tell Don't Ask?",
        "o": [
            "Anemic Model violates Tell Don't Ask (it's all getters/setters)",
            "Follows it",
            "Same",
            "Unknown"
        ]
    },
    {
        "q": "Can you verify OCP automatically?",
        "o": [
            "Hard; usually requires code review and seeing if new features require modifying existing classes",
            "Yes",
            "Always",
            "Never"
        ]
    },
    {
        "q": "Can you verify LSP automatically?",
        "o": [
            "Contract tests (Base class tests run against Subclasses) can help",
            "Yes",
            "No",
            "Never"
        ]
    },
    {
        "q": "Does 'Design Patterns' book use SOLID?",
        "o": [
            "Yes, most patterns are solutions to violations of these principles (e.g. Strategy -> OCP)",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Is MVC SOLID?",
        "o": [
            "Ideally yes (SRP separation), but Controllers often become 'God Classes' violating SRP",
            "Always",
            "Never",
            "Maybe"
        ]
    },
    {
        "q": "DTOs and SRP?",
        "o": [
            "DTOs separate transfer structure from domain logic (SRP support)",
            "Violate SRP",
            "Neutral",
            "Bad"
        ]
    },
    {
        "q": "Is 'Final' keyword good for OCP?",
        "o": [
            "Prevents inheritance (Modification via overriding), forcing Composition/Extension points elsewhere",
            "Bad",
            "Neutral",
            "Good"
        ]
    },
    {
        "q": "Open for Extension meaning?",
        "o": [
            "You can add new behavior",
            "You can change source",
            "You can delete code",
            "You can copy paste"
        ]
    },
    {
        "q": "Closed for Modification meaning?",
        "o": [
            "You don't need to change existing source code used by others",
            "Code is encrypted",
            "Code is private",
            "Code is deleted"
        ]
    },
    {
        "q": "When to ignore OCP?",
        "o": [
            "Bug fixes (must modify); or rapid prototyping where abstraction cost is too high",
            "Always",
            "Never",
            "Randomly"
        ]
    },
    {
        "q": "Is 'Mocking' related to DIP?",
        "o": [
            "Yes, DIP allows injecting Mocks (abstractions) instead of Real objects during test",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "TDD Cycle?",
        "o": [
            "Red (Fail), Green (Pass), Refactor (Clean/SOLID)",
            "Code, Test, Deploy",
            "Design, Code, Test",
            "Test, Code, Test"
        ]
    },
    {
        "q": "Why Refactor phase is critical?",
        "o": [
            "It's where you apply SOLID (removing duplication, extracting classes) without breaking tests",
            "It is fast",
            "It is easy",
            "It is fun"
        ]
    },
    {
        "q": "Is 'Global State' compatible with DIP?",
        "o": [
            "No, global state (static) is a hidden dependency, hard to invert/mock",
            "Yes",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Is 'New' keyword enemy of DIP?",
        "o": [
            "Yes, 'new' creates concrete dependency; use Factories or DI",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "Factory Pattern and DIP?",
        "o": [
            "Factories help implement DIP by centralizing object creation (concretion) out of business logic",
            "Unrelated",
            "Opposite",
            "Same"
        ]
    },
    {
        "q": "Abstract Factory and DIP?",
        "o": [
            "Allows creating families of related objects depending only on interfaces",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "What is 'Legacy Code'?",
        "o": [
            "Code without tests (Michael Feathers definition)",
            "Old code",
            "Bad code",
            "Slow code"
        ]
    },
    {
        "q": "How to refactor Legacy Code with SOLID?",
        "o": [
            "Identify Seams (Extension points), break dependencies (DIP), add tests, then refactor (SRP)",
            "Rewrite all",
            "Delete all",
            "Ignore"
        ]
    },
    {
        "q": "What is a 'Seam'?",
        "o": [
            "Place where you can alter behavior without editing that place (e.g. subclassing, interface injection)",
            "Line",
            "Thread",
            "Crack"
        ]
    },
    {
        "q": "Sprout Method/Class?",
        "o": [
            "Technique to add feature to legacy code: create new method/class and call it (minimizing risk)",
            "Plant",
            "Tree",
            "Grow"
        ]
    },
    {
        "q": "Wrap Method/Class?",
        "o": [
            "Decorate existing method/class to add behavior (OCP style) in legacy code",
            "Gift",
            "Paper",
            "Cover"
        ]
    },
    {
        "q": "Golden Rule of Refactoring?",
        "o": [
            "Tests must remain passing",
            "Code must get smaller",
            "Code must get faster",
            "Code must get cleaner"
        ]
    },
    {
        "q": "Is 'Static Analysis' useful for SOLID?",
        "o": [
            "Yes, tools can detect High Coupling, Long Methods, Cyclomatic Complexity",
            "No",
            "Maybe",
            "Unsure"
        ]
    },
    {
        "q": "What is 'Cyclomatic Complexity'?",
        "o": [
            "Metric of independent paths through code (branching); high complexity often violates SRP",
            "Cycle",
            "Circle",
            "Loop"
        ]
    }
,
{
    "q": "What is 'Coincidental Cohesion'?",
    "o": [
        "Worst cohesion: Parts of a module are grouped arbitrarily (e.g. Utils class with math and string methods)",
        "Best cohesion",
        "Good structure",
        "SRP compliant"
    ]
},
{
    "q": "What is 'Logical Cohesion'?",
    "o": [
        "Grouping by category (e.g. all Input routines), even if logic differs significantly (Switch statements often)",
        "Grouping by flow",
        "Grouping by data",
        "Grouping by time"
    ]
},
{
    "q": "What is 'Temporal Cohesion'?",
    "o": [
        "Grouping by execution time (e.g. Init() calls A, B, C which are unrelated but happen at startup)",
        "Grouping by logic",
        "Grouping by function",
        "Grouping by space"
    ]
},
{
    "q": "What is 'Procedural Cohesion'?",
    "o": [
        "Grouping based on sequence of execution (A runs, then B runs, then C runs)",
        "Best cohesion",
        "Worst cohesion",
        "Random"
    ]
},
{
    "q": "What is 'Communicational Cohesion'?",
    "o": [
        "Grouping elements that operate on the same data (better than Procedural)",
        "Networking",
        "Messaging",
        "Chatting"
    ]
},
{
    "q": "What is 'Functional Cohesion'?",
    "o": [
        "Best cohesion: Elements contribute to a single, well-defined task (SRP)",
        "Worst cohesion",
        "Random",
        "Loose"
    ]
},
{
    "q": "Content Coupling?",
    "o": [
        "Worst coupling: One module modifies internal data of another (no encapsulation)",
        "Best coupling",
        "Message coupling",
        "Data coupling"
    ]
},
{
    "q": "Common Coupling?",
    "o": [
        "Modules share global data (Global variables)",
        "Shared code",
        "Inheritance",
        "Friends"
    ]
},
{
    "q": "Control Coupling?",
    "o": [
        "One module passes a flag to another to control its logic (Violates Tell Don't Ask)",
        "Data only",
        "No coupling",
        "Strong cohesion"
    ]
},
{
    "q": "Stamp Coupling (Data-Structured)?",
    "o": [
        "Passing a large data structure (Record/Object) when only part of it is used (ISP violation potential)",
        "Mailing",
        "Printing",
        "Stamping"
    ]
},
{
    "q": "Data Coupling?",
    "o": [
        "Best coupling: Modules share only necessary data (simple parameters)",
        "No data",
        "All data",
        "Global data"
    ]
},
{
    "q": "Message Coupling?",
    "o": [
        "Decoupled communication via messages/events (Observer pattern)",
        "Direct call",
        "Static call",
        "Friend call"
    ]
},
{
    "q": "What is 'Precondition' (LSP)?",
    "o": [
        "Condition that must be true before a method runs (Subclass cannot strengthen this - demand more)",
        "Postcondition",
        "Invariant",
        "Constructor"
    ]
},
{
    "q": "Can a subclass weaken Preconditions?",
    "o": [
        "Yes, it can accept a wider range of inputs than parent (LSP safe)",
        "No, must be same",
        "No, must be stronger",
        "Unsure"
    ]
},
{
    "q": "What is 'Postcondition' (LSP)?",
    "o": [
        "Condition guaranteed to be true after method runs (Subclass cannot weaken this - promise less)",
        "Precondition",
        "Input",
        "Setup"
    ]
},
{
    "q": "Can a subclass strengthen Postconditions?",
    "o": [
        "Yes, it can promise more than the parent (LSP safe)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Invariant' (LSP)?",
    "o": [
        "Condition that must be true at all times (start and end of method)",
        "Variable",
        "Constant",
        "Loop"
    ]
},
{
    "q": "LSP and Exceptions?",
    "o": [
        "Subclass should not throw new checked exceptions not declared in parent (Java specific OCP/LSP)",
        "Any exception is fine",
        "No exceptions allowed",
        "Only Runtime exceptions"
    ]
},
{
    "q": "What is 'Hyrum's Law'?",
    "o": [
        "With a sufficient number of users, all observable behaviors of your system will be depended on (making changes hard - anti-OCP)",
        "Moore's Law",
        "Murphy's Law",
        "Cole's Law"
    ]
},
{
    "q": "What is 'GRASP'?",
    "o": [
        "General Responsibility Assignment Software Patterns (Guidelines for assigning responsibility - correlates with SOLID)",
        "Hold",
        "Grip",
        "Clutch"
    ]
},
{
    "q": "GRASP: Information Expert?",
    "o": [
        "Assign responsibility to the class that has the information necessary to fulfill it (High Cohesion)",
        "Controller",
        "Creator",
        "View"
    ]
},
{
    "q": "GRASP: Creator?",
    "o": [
        "Class A should create Class B if A contains, records, or closely uses B (Factory logic)",
        "God class",
        "Main method",
        "User"
    ]
},
{
    "q": "GRASP: Controller?",
    "o": [
        "First object beyond UI layer that receives and coordinates a system operation (Facade/Mediator)",
        "Model",
        "View",
        "Database"
    ]
},
{
    "q": "GRASP: Low Coupling?",
    "o": [
        "Assign responsibilities to keep dependency low (Direct SOLID alignment)",
        "High coupling",
        "Tight coupling",
        "No coupling"
    ]
},
{
    "q": "GRASP: High Cohesion?",
    "o": [
        "Assign responsibilities so that elements are strongly related (SRP)",
        "Low cohesion",
        "Weak cohesion",
        "Messy"
    ]
},
{
    "q": "GRASP: Polymorphism?",
    "o": [
        "Handle alternatives based on type using operations (OCP/LSP)",
        "If statements",
        "Switch",
        "Case"
    ]
},
{
    "q": "GRASP: Pure Fabrication?",
    "o": [
        "Artificial class (not in Domain) created to achieve Low Coupling/High Cohesion (e.g. Service, DAO)",
        "Real object",
        "Entity",
        "Value Object"
    ]
},
{
    "q": "GRASP: Indirection?",
    "o": [
        "Assign responsibility to intermediate object to decouple (Mediator/Adapter/DIP)",
        "Direction",
        "Pointer",
        "Reference"
    ]
},
{
    "q": "GRASP: Protected Variations?",
    "o": [
        "Identify points of predicted variation and create stable interface around them (OCP)",
        "Public",
        "Private",
        "Static"
    ]
},
{
    "q": "Does 'Composition' violate encapsulation?",
    "o": [
        "No, if done via interfaces (DIP), it preserves it better than Inheritance (white-box reuse)",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "White-box reuse?",
    "o": [
        "Inheritance (Subclass sees internals of Parent)",
        "Black-box",
        "Composition",
        "Interface"
    ]
},
{
    "q": "Black-box reuse?",
    "o": [
        "Composition (Client sees only public interface of component)",
        "Inheritance",
        "White-box",
        "Friend"
    ]
},
{
    "q": "Is 'Utility Class' (all static) SOLID?",
    "o": [
        "Often implies procedural code; hard to Swap/Mock (DIP issue), but common for pure functions",
        "Perfect SOLID",
        "Always bad",
        "Required"
    ]
},
{
    "q": "Extension Methods (C#/Kotlin) and OCP?",
    "o": [
        "Great way to extend functionality of closed classes without inheritance (OCP compliant)",
        "Violates OCP",
        "Bad practice",
        "Slow"
    ]
},
{
    "q": "Default Methods (Java Interface) and ISP?",
    "o": [
        "Can help evolve interfaces without breaking implementations, but can lead to 'Fat Interfaces' if abused",
        "No relation",
        "Violates LSP",
        "Violates SRP"
    ]
},
{
    "q": "What is 'Role Interface'?",
    "o": [
        "Small interface defining a specific role/behavior (ISP goal)",
        "Header Interface",
        "God Interface",
        "Class Interface"
    ]
},
{
    "q": "What is 'Header Interface'?",
    "o": [
        "Interface that just mirrors all public methods of a class (1-to-1); usually low value",
        "Role Interface",
        "Client Specific",
        "DIP compliant"
    ]
},
{
    "q": "Interface naming convention (Java vs C#)?",
    "o": [
        "Java: Service (Impl implements Service); C#: IService (Service implements IService)",
        "Same",
        "Opposite",
        "Random"
    ]
},
{
    "q": "Is 'Base Class' better than Interface for DIP?",
    "o": [
        "Interface is usually preferred (Multiple inheritance of type, cleaner contract); Base class forces hierarchy",
        "Base class is better",
        "Same",
        "Neither"
    ]
},
{
    "q": "When to use Abstract Class over Interface?",
    "o": [
        "When sharing state or implementation code (Template Method), or strict 'is-a' hierarchy",
        "Always",
        "Never",
        "For constants"
    ]
},
{
    "q": "What is 'Mix-in' vs Inheritance?",
    "o": [
        "Mix-in allows horizontal composition of behavior (avoiding diamond problem of multiple inheritance)",
        "Vertical",
        "Same",
        "Opposite"
    ]
},
{
    "q": "Does Java support Mix-ins?",
    "o": [
        "Simulated via Default Methods in Interfaces (since Java 8)",
        "Yes, natively",
        "No",
        "Maybe"
    ]
},
{
    "q": "What is 'Multiple Inheritance'?",
    "o": [
        "Class inheriting from more than one class (C++ supports, Java/C# do not)",
        "Single",
        "Interface",
        "Mix-in"
    ]
},
{
    "q": "Why avoid Multiple Inheritance?",
    "o": [
        "Diamond Problem (ambiguity), complexity, tight coupling",
        "Too easy",
        "Too fast",
        "No reason"
    ]
},
{
    "q": "How to solve Diamond Problem in Java?",
    "o": [
        "Interfaces allows multiple inheritance of Type; Default methods require explicit override if conflict exists",
        "Virtual inheritance",
        "Pointers",
        "Magic"
    ]
},
{
    "q": "What is 'Package Cohesion'?",
    "o": [
        "Principles for organizing classes into packages (REP, CCP, CRP)",
        "Loose",
        "Tight",
        "None"
    ]
},
{
    "q": "REP (Release Reuse Equivalency Principle)?",
    "o": [
        "Granule of reuse is the granule of release (Package/Module)",
        "Reuse code",
        "Release often",
        "No release"
    ]
},
{
    "q": "CCP (Common Closure Principle)?",
    "o": [
        "Classes that change together should be packaged together (Package level SRP)",
        "Close together",
        "Common code",
        "Closure"
    ]
},
{
    "q": "CRP (Common Reuse Principle)?",
    "o": [
        "Don't force users of a package to depend on things they don't need (Package level ISP)",
        "Reuse all",
        "Common code",
        "Recycle"
    ]
},
{
    "q": "Tension between CCP and CRP?",
    "o": [
        "CCP makes packages larger (grouping changes); CRP makes them smaller (splitting unused). Architect must balance.",
        "Same goal",
        "No tension",
        "Ignore both"
    ]
},
{
    "q": "What is 'Package Coupling'?",
    "o": [
        "Principles for relationships between packages (ADP, SDP, SAP)",
        "Loose",
        "Tight",
        "None"
    ]
},
{
    "q": "ADP (Acyclic Dependencies Principle)?",
    "o": [
        "Dependencies between packages must not form a cycle",
        "Cycles allowed",
        "All cyclic",
        "Ignore"
    ]
},
{
    "q": "How to break a Package Cycle?",
    "o": [
        "Create a new package (DIP) or Merge packages",
        "Delete code",
        "Ignore",
        "Use reflection"
    ]
},
{
    "q": "SDP (Stable Dependencies Principle)?",
    "o": [
        "Depend in the direction of stability (Depend on things less likely to change)",
        "Depend on unstable",
        "Random",
        "No dependency"
    ]
},
{
    "q": "What makes a package 'Stable'?",
    "o": [
        "Hard to change (many incoming dependencies, few outgoing)",
        "Easy to change",
        "Old",
        "New"
    ]
},
{
    "q": "SAP (Stable Abstractions Principle)?",
    "o": [
        "Stable packages should be Abstract (Interfaces); Unstable packages should be Concrete",
        "Stable = Concrete",
        "Abstract = Unstable",
        "Ignore"
    ]
},
{
    "q": "Zone of Pain (SAP)?",
    "o": [
        "Highly Stable and Concrete (Hard to extend, hard to change) - e.g. String, Utils, DB Schema",
        "Zone of uselessness",
        "Zone of fun",
        "Zone of errors"
    ]
},
{
    "q": "Zone of Uselessness (SAP)?",
    "o": [
        "Highly Abstract and Unstable (Interfaces nobody uses)",
        "Zone of pain",
        "Zone of fun",
        "Zone of errors"
    ]
},
{
    "q": "Where is the 'Main Sequence' (SAP)?",
    "o": [
        "Balance between Abstraction and Stability (Diagonal line)",
        "Start",
        "End",
        "Corner"
    ]
},
{
    "q": "What is 'Connascence'?",
    "o": [
        "Metric of coupling (Degree to which change in A requires change in B)",
        "Connection",
        "Cohesion",
        "Code"
    ]
},
{
    "q": "Connascence of Name?",
    "o": [
        "Weakest coupling: Items must agree on name (method name)",
        "Strongest",
        "Medium",
        "None"
    ]
},
{
    "q": "Connascence of Type?",
    "o": [
        "Items must agree on type",
        "Name",
        "Value",
        "Position"
    ]
},
{
    "q": "Connascence of Position?",
    "o": [
        "Items must agree on order (e.g. parameter list order)",
        "Name",
        "Type",
        "Value"
    ]
},
{
    "q": "Connascence of Algorithm?",
    "o": [
        "Items must agree on algorithm (e.g. hash checksum on both sides)",
        "Name",
        "Type",
        "Value"
    ]
},
{
    "q": "Connascence of Meaning?",
    "o": [
        "Items must agree on meaning of value (e.g. magic numbers, 1=Admin)",
        "Name",
        "Type",
        "Algorithm"
    ]
},
{
    "q": "How to improve Connascence?",
    "o": [
        "Refactor to weaker forms (Meaning -> Name) and reduce locality (Keep strong connascence local)",
        "Increase it",
        "Ignore it",
        "Break it"
    ]
},
{
    "q": "What is 'Orthogonality'?",
    "o": [
        "Changes in one thing do not affect others (Decoupled/Independent)",
        "Geometry",
        "Math",
        "Parallel"
    ]
},
{
    "q": " DRY (Don't Repeat Yourself)?",
    "o": [
        "Every piece of knowledge must have a single, unambiguous representation",
        "Copy paste",
        "Wet",
        "Repeat"
    ]
},
{
    "q": "Does DRY mean 'No Duplicate Code'?",
    "o": [
        "Not just code; it means 'No Duplicate Knowledge/Logic'. Two similar blocks might not violate DRY if they represent different concepts.",
        "Yes, strictly",
        "No",
        "Maybe"
    ]
},
{
    "q": "WET (Write Everything Twice)?",
    "o": [
        "Opposite of DRY (or We Enjoy Typing)",
        "Water",
        "Liquid",
        "Rain"
    ]
},
{
    "q": "Rule of Three (Refactoring)?",
    "o": [
        "Wait until code is duplicated three times before abstracting (avoid premature abstraction)",
        "Rule of thumb",
        "Rule of law",
        "Rule of code"
    ]
},
{
    "q": "Command Query Separation (CQS)?",
    "o": [
        "Method should be Command (Change state, return void) OR Query (Return value, no side effect), not both",
        "CQRS",
        "MVC",
        "Solid"
    ]
},
{
    "q": "Example of CQS violation?",
    "o": [
        "Stack.pop() (Removes item and returns it) - though accepted pragmatic violation",
        "Getter",
        "Setter",
        "Print"
    ]
},
{
    "q": "Does CQS help correctness?",
    "o": [
        "Yes, relying on Queries is safe (no side effects); Commands require care",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Side Effect'?",
    "o": [
        "Modifying state outside local scope or observable interaction (I/O) during execution",
        "Medical term",
        "Main effect",
        "Code"
    ]
},
{
    "q": "What is 'Referential Transparency'?",
    "o": [
        "Expression can be replaced by its value without changing program behavior (Pure Functions)",
        "Transparency",
        "Reference",
        "Mirror"
    ]
},
{
    "q": "Is Functional Programming SOLID?",
    "o": [
        "FP promotes Immutability, Pure Functions (SRP), High Cohesion - aligns well with goals",
        "No",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "Immutability and side effects?",
    "o": [
        "Immutable objects prevent side effects related to shared state changes",
        "Cause them",
        "Increase them",
        "No relation"
    ]
},
{
    "q": "Race Conditions?",
    "o": [
        "Outcome depends on timing of threads (Immutability fixes this)",
        "Running",
        "Fast",
        "Slow"
    ]
},
{
    "q": "What is 'Deadlock'?",
    "o": [
        "Two threads waiting for each other to release resources",
        "Lock",
        "Door",
        "Key"
    ]
},
{
    "q": "Are Singletons thread-safe?",
    "o": [
        "Not by default; must be implemented carefully (Enum, Synchronized, Double-Checked Locking)",
        "Yes",
        "Always",
        "Never"
    ]
},
{
    "q": "Double-Checked Locking (Singleton)?",
    "o": [
        "Optimization to avoid synchronization overhead once initialized (requires volatile)",
        "Two locks",
        "Check twice",
        "Secure"
    ]
},
{
    "q": "Why 'volatile' in Double-Checked Locking?",
    "o": [
        "To prevent instruction reordering (ensure partially constructed object is not seen)",
        "Speed",
        "Memory",
        "Cache"
    ]
},
{
    "q": "Initialization-on-demand holder idiom?",
    "o": [
        "Thread-safe Singleton using inner static class (Lazy load without synchronization)",
        "Holder",
        "Lazy",
        "Fast"
    ]
},
{
    "q": "Enum Singleton?",
    "o": [
        "Best Java Singleton (Handles serialization, thread safety auto, prevents reflection attack)",
        "Bad",
        "Wrong",
        "Slow"
    ]
},
{
    "q": "Can you subclass Enum Singleton?",
    "o": [
        "No, Enums are final",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Multiton'?",
    "o": [
        "Map of Singletons (Key -> Instance)",
        "Many",
        "Tons",
        "List"
    ]
},
{
    "q": "What is 'Object Pool' pattern?",
    "o": [
        "Managing a set of expensive objects (Connections, Threads) for reuse",
        "Pool",
        "Swim",
        "Water"
    ]
},
{
    "q": "Flyweight vs Object Pool?",
    "o": [
        "Flyweight shares immutable state (many logic objects); Pool manages mutable resources (limited physical objects)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Prototype Pattern use case?",
    "o": [
        "Creating object is expensive; Cloning is cheaper (or avoiding hierarchy of factories)",
        "Simple",
        "Fast",
        "Copy"
    ]
},
{
    "q": "Shallow Copy vs Deep Copy?",
    "o": [
        "Shallow: copies references; Deep: copies objects recursively",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Prototype in JavaScript?",
    "o": [
        "Core language mechanism (Prototypal Inheritance)",
        "Pattern",
        "Class",
        "None"
    ]
},
{
    "q": "Builder Pattern vs Factory?",
    "o": [
        "Builder: Complex step-by-step construction; Factory: Single step creation",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Director in Builder?",
    "o": [
        "Orchestrates the build steps (optional)",
        "Manager",
        "Boss",
        "Film"
    ]
},
{
    "q": "Fluent Builder?",
    "o": [
        "Methods return 'this' to allow chaining (User.builder().name().age().build())",
        "Fast",
        "Slow",
        "Simple"
    ]
},
{
    "q": "Telescoping Constructor Problem?",
    "o": [
        "Many constructors with increasing parameters (Fixed by Builder)",
        "Star",
        "Space",
        "Scope"
    ]
},
{
    "q": "JavaBeans Pattern (Setters) issues?",
    "o": [
        "Object is mutable; inconsistent state during construction (Not thread safe)",
        "Good",
        "Easy",
        "Simple"
    ]
}
,
{
    "q": "How does 'Strategy Pattern' support OCP?",
    "o": [
        "Allows adding new algorithms (strategies) without modifying the Context class",
        "Violates OCP",
        "Supports LSP",
        "Supports ISP"
    ]
},
{
    "q": "How does 'Decorator Pattern' support OCP?",
    "o": [
        "Adds behavior to objects dynamically without modifying existing code (inheritance alternative)",
        "Violates OCP",
        "Supports SRP",
        "Supports DIP"
    ]
},
{
    "q": "Does 'Observer Pattern' support DIP?",
    "o": [
        "Yes, Subject depends on Observer interface, not concrete Observers",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Does 'Simple Factory' violate OCP?",
    "o": [
        "Yes, usually requires modifying the switch statement to add new types",
        "No",
        "Maybe",
        "It supports it"
    ]
},
{
    "q": "How does 'Factory Method' fix Simple Factory OCP issue?",
    "o": [
        "Allows subclasses to decide which class to instantiate (Polycmorphic creation)",
        "It doesn't",
        "It uses static",
        "It uses generic"
    ]
},
{
    "q": "Abstract Factory and DIP?",
    "o": [
        "Client depends on AbstractFactory interface, not concrete factories",
        "Violates DIP",
        "Neutral",
        "Opposite"
    ]
},
{
    "q": "Singleton and SRP?",
    "o": [
        "Violates SRP: Controls own lifecycle AND performs business logic",
        "Supports SRP",
        "Neutral",
        "Best practice"
    ]
},
{
    "q": "Singleton and DIP?",
    "o": [
        "Violates DIP: Clients usually access Concrete Static Instance directly (hard dependency)",
        "Supports DIP",
        "Neutral",
        "Good"
    ]
},
{
    "q": "Builder Pattern and LSP?",
    "o": [
        "Generally safe; Builders don't usually involve complex inheritance hierarchies to break substitution",
        "Violates LSP",
        "Risk",
        "Unsure"
    ]
},
{
    "q": "Prototype and OCP?",
    "o": [
        "Supports OCP: Client clones existing object (prototype) without knowing concrete class",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Adapter Pattern and DIP?",
    "o": [
        "Supports DIP: Allows Client to depend on Target Interface, while Adapter handles legacy/external code",
        "Violates DIP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Adapter Pattern and SRP?",
    "o": [
        "Supports SRP: separates interface conversion code from business logic",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Bridge Pattern and OCP?",
    "o": [
        "Excellent OCP: Abstraction and Implementation can be extended independently",
        "Violates OCP",
        "Bad OCP",
        "Neutral"
    ]
},
{
    "q": "Composite Pattern and LSP?",
    "o": [
        "Risk: 'Leaf' and 'Composite' might treat add/remove differently (Leaf might throw UnsupportedOperationException)",
        "Always safe",
        "Never safe",
        "Perfect"
    ]
},
{
    "q": "Composite Pattern and ISP?",
    "o": [
        "Can violate ISP if Component interface forces Leaf to implement children-management methods",
        "Supports ISP",
        "Neutral",
        "Good"
    ]
},
{
    "q": "Facade Pattern and coupling?",
    "o": [
        "Reduces coupling: Client depends only on Facade, not complex subsystem classes",
        "Increases coupling",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Flyweight and SRP?",
    "o": [
        "Supports SRP: Separates intrinsic (shared) state from extrinsic (context) state",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Proxy Pattern and OCP?",
    "o": [
        "Supports OCP: Add behavior (logging, auth) without changing RealSubject",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Chain of Responsibility and OCP?",
    "o": [
        "Supports OCP: New handlers can be added to chain without modifying client or other handlers",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Chain of Responsibility and SRP?",
    "o": [
        "Supports SRP: Each handler does one specific check/action",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Command Pattern and SRP?",
    "o": [
        "Supports SRP: Decouples Invoker from Receiver; encapsulates Request as object",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Command Pattern and OCP?",
    "o": [
        "Supports OCP: New commands can be added easily",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Interpreter Pattern and SRP?",
    "o": [
        "Each grammar rule is a class (One Responsibility)",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Iterator Pattern and SRP?",
    "o": [
        "Supports SRP: Traversal logic extracted from Collection class",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Mediator Pattern and OCP?",
    "o": [
        "Risk: ConcreteMediator can become God Class (modifying it for every new interaction)",
        "Perfect OCP",
        "Always good",
        "Neutral"
    ]
},
{
    "q": "Mediator Pattern and Coupling?",
    "o": [
        "Reduces Colleague-to-Colleague coupling, but increases Mediator-tob-Colleague coupling",
        "Eliminates coupling",
        "No effect",
        "Bad"
    ]
},
{
    "q": "Memento Pattern and Encapsulation?",
    "o": [
        "Preserves Encapsulation (Internal state stored in opacity Memento)",
        "Breaks it",
        "Exposes it",
        "Bad"
    ]
},
{
    "q": "Observer Pattern and Coupling?",
    "o": [
        "Loose Coupling (Subject doesn't know details of Observers)",
        "Tight Coupling",
        "No Coupling",
        "Bad"
    ]
},
{
    "q": "State Pattern and OCP?",
    "o": [
        "Supports OCP: New states added as new classes",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "State Pattern and SRP?",
    "o": [
        "Supports SRP: State-specific logic moves to State classes",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Template Method and OCP?",
    "o": [
        "Supports OCP: Skeleton fixed, steps overridden in subclasses",
        "Violates OCP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Template Method vs Strategy for OCP?",
    "o": [
        "Strategy (Composition) is generally more flexible than Template Method (Inheritance)",
        "Template is better",
        "Same",
        "Unknown"
    ]
},
{
    "q": "Visitor Pattern and OCP?",
    "o": [
        "Good for adding Operations (OCP Compliant for operations), BAD for adding Element types (Anti-OCP)",
        "Perfect OCP",
        "Bad OCP",
        "Neutral"
    ]
},
{
    "q": "Visitor Pattern and SRP?",
    "o": [
        "Supports SRP: Gathers related operations into one Visitor class",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Null Object Pattern and LSP?",
    "o": [
        "Supports LSP: NullObject implements interface and does 'nothing' safely (substitutable)",
        "Violates LSP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Null Object removes what?",
    "o": [
        "Null checks (simplifying client code)",
        "Objects",
        "Classes",
        "Memory"
    ]
},
{
    "q": "Service Locator and DIP?",
    "o": [
        "Often violates DIP (Hidden dependencies inside implementation)",
        "Supports DIP",
        "Neutral",
        "Good"
    ]
},
{
    "q": "Repository Pattern and DIP?",
    "o": [
        "Supports DIP: Domain depends on Repository Interface, Infrastructure implements it",
        "Violates DIP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Active Record and SRP?",
    "o": [
        "Violates SRP: One class handles data and database access",
        "Supports SRP",
        "Neutral",
        "Good"
    ]
},
{
    "q": "MVC Controller and SRP?",
    "o": [
        "Risk: Controllers often gather too much logic (Fat Controller)",
        "Always Good",
        "Never Good",
        "Neutral"
    ]
},
{
    "q": "MVVM and SRP?",
    "o": [
        "ViewModel handles View Logic/State, separating it from Model and View (Better SRP)",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Specification Pattern?",
    "o": [
        "Encapsulates business rule (boolean logic) into a class (SRP/OCP)",
        "Database info",
        "Specifics",
        "Details"
    ]
},
{
    "q": "Circuit Breaker and SRP?",
    "o": [
        "Separates failure handling policy from external call logic",
        "Violates SRP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Dependency Injection vs Factory?",
    "o": [
        "DI Framework (IoC) automates wiring; Factory is explicit manual wiring. Both support DIP.",
        "Opposite",
        "Conflict",
        "Same"
    ]
},
{
    "q": "Monolith vs Microservices (SOLID)?",
    "o": [
        "Microservices enforce SRP at architectural level (Service = Responsibility)",
        "Monolith better",
        "Same",
        "Unknown"
    ]
},
{
    "q": "Interface Segregation in Microservices?",
    "o": [
        "Specific APIs for specific clients (BFF pattern)",
        "One API for all",
        "No API",
        "Big API"
    ]
},
{
    "q": "Bounded Context (DDD) and SRP?",
    "o": [
        "Aligns perfectly; Model valid only within its context/responsibility",
        "Conflict",
        "Opposite",
        "Neutral"
    ]
},
{
    "q": "Anti-Corruption Layer (ACL) and DIP?",
    "o": [
        "Supports DIP: Adapter layer preventing external model leaking into internal domain",
        "Violates DIP",
        "Neutral",
        "Bad"
    ]
},
{
    "q": "Strangler Fig and OCP?",
    "o": [
        "Extend system functionality by adding new services (OCP) while strangling old ones",
        "Violates OCP",
        "Bad",
        "Neutral"
    ]
},
{
    "q": "Primitive Obsession fixes?",
    "o": [
        "Key to SRP: Value Objects (Classes) attract behavior related to the data",
        "Ignore",
        "Use int",
        "Use string"
    ]
},
{
    "q": "Feature Flags and OCP?",
    "o": [
        "Allows changing behavior without deploying new code (Dynamic extension)",
        "Violates OCP",
        "Bad",
        "Neutral"
    ]
},
{
    "q": "Callback Hell violation?",
    "o": [
        "High coupling, hard to read (SRP/readability issues)",
        "Good",
        "Fast",
        "Simple"
    ]
},
{
    "q": "Promises/Async-Await SOLID?",
    "o": [
        "Flattens structure, easier resource handling (cleaner code)",
        "Bad",
        "Slow",
        "Complex"
    ]
},
{
    "q": "Global State and Unit Testing?",
    "o": [
        "Nightmare: Tests interfere with each other (Need isolation)",
        "Good",
        "Easy",
        "Fast"
    ]
},
{
    "q": "Mocking Static Methods?",
    "o": [
        "Hard/Requires PowerMock; indicates design smell (Time to wrap in instance)",
        "Easy",
        "Standard",
        "Recommended"
    ]
},
{
    "q": "TDD helping design?",
    "o": [
        "Writing test first forces you to think about Interface (ISP) and Dependencies (DIP)",
        "No help",
        "Slows down",
        "Just checks bugs"
    ]
},
{
    "q": "Code Coverage vs SOLID?",
    "o": [
        "High coverage doesn't mean SOLID; but SOLID makes high coverage easier",
        "Same thing",
        "Opposite",
        "No relation"
    ]
},
{
    "q": "Cyclomatic Complexity vs SRP?",
    "o": [
        "High complexity (many branches) often indicates method doing too much (SRP violation)",
        "Low complexity",
        "No relation",
        "Good thing"
    ]
},
{
    "q": "Depth of Inheritance Tree (DIT)?",
    "o": [
        "Deep hierarchy can violate Composition over Inheritance (Fragile Base Class)",
        "Good thing",
        "Shallow is bad",
        "Ignore"
    ]
},
{
    "q": "Lack of Cohesion of Methods (LCOM)?",
    "o": [
        "Metric: High LCOM means class should likely be split (SRP)",
        "Low LCOM bad",
        "Ignore",
        "Good thing"
    ]
},
{
    "q": "Efferent Coupling (Ce)?",
    "o": [
        "Outgoing dependencies (Fan-out). High Ce -> Unstable.",
        "Incoming",
        "Stable",
        "Good"
    ]
},
{
    "q": "Afferent Coupling (Ca)?",
    "o": [
        "Incoming dependencies (Fan-in). High Ca -> Stable (Hard to change w/o breaking others).",
        "Outgoing",
        "Unstable",
        "Bad"
    ]
},
{
    "q": "Instability (I) formula?",
    "o": [
        "I = Ce / (Ca + Ce). 0 = Stable, 1 = Unstable.",
        "I = Ca / Ce",
        "I = Ca + Ce",
        "I = 1"
    ]
},
{
    "q": "Where should Interfaces be?",
    "o": [
        "In Stable packages (I close to 0)",
        "In Unstable packages",
        "Anywhere",
        "Nowhere"
    ]
},
{
    "q": "God Object Anti-pattern?",
    "o": [
        "Monolithic class knowing everything (SRP/Cohesion disaster)",
        "Hero class",
        "Admin class",
        "Root class"
    ]
},
{
    "q": "Boat Anchor Anti-pattern?",
    "o": [
        "Code kept 'just in case' but not used (clutters interface - ISP)",
        "Heavy code",
        "Stable code",
        "Good code"
    ]
},
{
    "q": "Poltergeist Anti-pattern?",
    "o": [
        "Short-lived objects/classes with no responsibility (Controller with no logic)",
        "Ghost",
        "Spirit",
        "Fast"
    ]
},
{
    "q": "Yo-Yo Problem?",
    "o": [
        "Deep inheritance hierarchy where you bounce up and down to understand flow (Composition fixes)",
        "Toy",
        "Game",
        "String"
    ]
},
{
    "q": "Golden Hammer?",
    "o": [
        "Using same pattern/tool for everything (e.g. Singleton everywhere)",
        "Gold",
        "Tool",
        "Construction"
    ]
},
{
    "q": "Spaghetti Code?",
    "o": [
        "Unstructured control flow (Goto, Exceptions for logic)",
        "Food",
        "Pasta",
        "Tasty"
    ]
},
{
    "q": "Lava Flow?",
    "o": [
        "Dead code no one dares to remove",
        "Hot",
        "Volcano",
        "Fluid"
    ]
},
{
    "q": "Copy-Paste Programming?",
    "o": [
        "DRY violation",
        "Fast",
        "Easy",
        "Good"
    ]
},
{
    "q": "Magic Numbers?",
    "o": [
        "Hardcoded values (Use constraints/enums - OCP/Meaning)",
        "Magic",
        "Tricks",
        "Fun"
    ]
},
{
    "q": "Hardcoding?",
    "o": [
        "Rigidity source; use config or DI injection",
        "Solid",
        "Strong",
        "Fast"
    ]
},
{
    "q": "Premature Optimization?",
    "o": [
        "Root of all evil (can compromise design/readability before bottlenecks known)",
        "Good",
        "Fast",
        "Needed"
    ]
},
{
    "q": "Analysis Paralysis?",
    "o": [
        "Over-analyzing design (trying to be perfect SOLID) preventing progress",
        "Medical",
        "Stop",
        "Slow"
    ]
},
{
    "q": "Big Ball of Mud?",
    "o": [
        "System with no discernible architecture",
        "Muddy",
        "Dirty",
        "Round"
    ]
},
{
    "q": "Does SOLID guarantee good software?",
    "o": [
        "No, it's a heuristic/guideline. Engineering judgement (Context) helps apply it.",
        "Yes, always",
        "No, never",
        "Unsure"
    ]
},
{
    "q": "KISS (Keep It Simple Stupid)?",
    "o": [
        "Simplicity should be a key goal; avoid unnecessary complexity (even SOLID complexity)",
        "Love",
        "Band",
        "Face"
    ]
},
{
    "q": "YAGNI (You Aren't Gonna Need It)?",
    "o": [
        "Don't implement functionality until necessary (Avoid over-abstraction)",
        "Yes",
        "No",
        "Maybe"
    ]
},
{
    "q": "SOLID vs Performance?",
    "o": [
        "Abstractions (Interfaces, Virtual calls) have tiny overhead; usually negligible vs IO/Algo",
        "SOLID is slow",
        "SOLID is fast",
        "No impact"
    ]
},
{
    "q": "Is 'Switch' always bad?",
    "o": [
        "No, simple switches (Factory, Enum mapping) are fine. Polymorphism is for behavior variation.",
        "Yes",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Clean Code: Method Argument Count?",
    "o": [
        "Zero is best, then One, then Two. Used Parameter Object for more (Data Clump).",
        "Any number",
        "Max 10",
        "Min 5"
    ]
},
{
    "q": "Commented out code?",
    "o": [
        "Delete it (Use Git history)",
        "Keep it",
        "Save it",
        "Hide it"
    ]
},
{
    "q": "Boolean arguments?",
    "o": [
        "Flag argument usually implies method does two things (Split method)",
        "Good",
        "Easy",
        "Fast"
    ]
},
{
    "q": "Fail Fast?",
    "o": [
        "Report error immediately (throw exception) rather than continue in unstable state",
        "Fail slow",
        "Ignore",
        "Retry"
    ]
},
{
    "q": "Return Early (Guard Clauses)?",
    "o": [
        "Reduces nesting/complexity compared to nested if-else",
        "Return late",
        "Guard late",
        "Complex"
    ]
},
{
    "q": "Variable naming?",
    "o": [
        "Reveal intent (clean code); crucial for readability and maintenance",
        "Short",
        "Cryptic",
        "Hungarian"
    ]
}
,
{
    "q": "What is 'Code Smell'?",
    "o": [
        "Surface indication that usually corresponds to a deeper problem in the system",
        "Bug",
        "Error",
        "Feature"
    ]
},
{
    "q": "Refactoring: 'Extract Method' helps which SOLID principle?",
    "o": [
        "SRP (Breaks down large methods into smaller, cohesive units)",
        "OCP",
        "LSP",
        "DIP"
    ]
},
{
    "q": "Refactoring: 'Extract Class' helps which SOLID principle?",
    "o": [
        "SRP (Splits God Class into smaller classes)",
        "LSP",
        "ISP",
        "DIP"
    ]
},
{
    "q": "Refactoring: 'Replace Conditional with Polymorphism' helps which SOLID principle?",
    "o": [
        "OCP (New cases added as new classes, not new 'if' branches)",
        "SRP",
        "ISP",
        "DIP"
    ]
},
{
    "q": "Refactoring: 'Pull Up Field'?",
    "o": [
        "Moves a field to the superclass (Removing duplication)",
        "Push Down",
        "Delete",
        "Rename"
    ]
},
{
    "q": "Refactoring: 'Push Down Field'?",
    "o": [
        "Moves a field to a subclass (if only used there) - improves Cohesion/LSP",
        "Pull Up",
        "Delete",
        "Rename"
    ]
},
{
    "q": "Refactoring: 'Introduce Parameter Object'?",
    "o": [
        "Groups parameters into a class (Data Clump fix) - improves Cohesion",
        "Delete params",
        "Global args",
        "Ignore"
    ]
},
{
    "q": "Refactoring: 'Encapsulate Field'?",
    "o": [
        "Make public data private and provide accessors (Data Hiding)",
        "Make public",
        "Make static",
        "Delete"
    ]
},
{
    "q": "Refactoring: 'Replace Magic Number with Symbolic Constant'?",
    "o": [
        "Improves readability and makes change easier (OCP/Maintenance)",
        "Make magic",
        "Hide",
        "Ignore"
    ]
},
{
    "q": "What is 'Inappropriate Intimacy'?",
    "o": [
        "Code Smell: Classes know too much about each other (Tight Coupling)",
        "Good friends",
        "Inheritance",
        "Interfaces"
    ]
},
{
    "q": "What is 'Message Chains'?",
    "o": [
        "Code Smell: a.getB().getC().do() - Violates Law of Demeter",
        "Chain of Responsibility",
        "Emails",
        "Strings"
    ]
},
{
    "q": "Refactoring: 'Hide Delegate'?",
    "o": [
        "Fix for Message Chains (Manager.work() instead of Manager.getDepartment().getWorker().work())",
        "Show delegate",
        "Expose",
        "Public"
    ]
},
{
    "q": "What is 'Middle Man' smell?",
    "o": [
        "Class does nothing but delegate (Over-encapsulation or useless Controller)",
        "Mediator",
        "Proxy",
        "Broker"
    ]
},
{
    "q": "Refactoring: 'Remove Middle Man'?",
    "o": [
        "Let client call delegate directly (Fix for Middle Man smell)",
        "Add middle man",
        "Keep",
        "Hide"
    ]
},
{
    "q": "What is 'Speculative Generality'?",
    "o": [
        "Code created 'just in case' (YAGNI violation)",
        "Good planning",
        "Future proof",
        "Smart"
    ]
},
{
    "q": "Refactoring: 'Collapse Hierarchy'?",
    "o": [
        "Merge Superclass and Subclass if they are not distinct enough (Fix Speculative Generality)",
        "Expand",
        "Split",
        "Clone"
    ]
},
{
    "q": "Testability: What makes code hard to test?",
    "o": [
        "Static calls, 'new' keywords (Hard dependencies), Global state",
        "Interfaces",
        "DI",
        "Small methods"
    ]
},
{
    "q": "What is 'Seam' in Legacy Code?",
    "o": [
        "Place where you can alter behavior without editing source (e.g. override method in test subclass)",
        "Thread",
        "Line",
        "Bug"
    ]
},
{
    "q": "Dependency Injection improves what?",
    "o": [
        "Testability (Easy to mock dependencies) and Flexibility (DIP)",
        "Speed",
        "Memory",
        "Security"
    ]
},
{
    "q": "Mock objects vs Real objects?",
    "o": [
        "Mocks simulate behavior to isolate unit under test (DIP in action)",
        "Same",
        "Real better",
        "No difference"
    ]
},
{
    "q": "Stub vs Mock?",
    "o": [
        "Stub returns data; Mock verifies behavior (expectations like 'method called x times')",
        "Same",
        "Stub verifies",
        "Mock returns"
    ]
},
{
    "q": "Fake Object?",
    "o": [
        "Working implementation but simplified (e.g. In-Memory DB) for testing",
        "Mock",
        "Stub",
        "Spy"
    ]
},
{
    "q": "Spy Object?",
    "o": [
        "Wraps real object and records calls (partial mock)",
        "Agent",
        "Mock",
        "Stub"
    ]
},
{
    "q": "Dummy Object?",
    "o": [
        "Passed around but never used (placeholder to satisfy API)",
        "Smart",
        "Null",
        "Real"
    ]
},
{
    "q": "Can you test private methods?",
    "o": [
        "Generally shouldn't (Implementation detail); test via public interface. If need arises, code might violate SRP.",
        "Yes always",
        "Change to public",
        "Use reflection always"
    ]
},
{
    "q": "What is 'Ports and Adapters' (Hexagonal)?",
    "o": [
        "Architecture ensuring app core (Domain) is isolated from outside (DB, UI) via Ports (Interfaces)",
        "Layered",
        "MVC",
        "Monolith"
    ]
},
{
    "q": "In Hexagonal, what is a 'Primary Adapter'?",
    "o": [
        "Driving Adapter (e.g. Controller, CLI) - calls the Core",
        "Driven",
        "Database",
        "External API"
    ]
},
{
    "q": "In Hexagonal, what is a 'Secondary Adapter'?",
    "o": [
        "Driven Adapter (e.g. Repository impl, SMTP client) - called by the Core",
        "Driving",
        "Controller",
        "User"
    ]
},
{
    "q": "Why is Hexagonal SOLID?",
    "o": [
        "Heavily relies on DIP (Core depends on Ports/Interfaces, not Adapters)",
        "Violates it",
        "Unrelated",
        "Bad"
    ]
},
{
    "q": "Onion Architecture?",
    "o": [
        "Similar to Hexagonal; concentric layers with Dependency Rule pointing inwards",
        "Square",
        "Linear",
        "Flat"
    ]
},
{
    "q": "Core of Onion Architecture?",
    "o": [
        "Domain Model (Entities) - No dependencies",
        "Database",
        "UI",
        "Tests"
    ]
},
{
    "q": "Layered Architecture vs Onion?",
    "o": [
        "Layered often allows transitive dependencies (UI->Service->Data->DB) or shortcuts; Onion strictly isolates Core.",
        "Same",
        "Layered better",
        "Onion worse"
    ]
},
{
    "q": "Vertical Slice Architecture?",
    "o": [
        "Organizing by Feature (Slice) rather than Technical Layer (Controller/Service/Repo)",
        "Horizontal",
        "Layered",
        "Spaghetti"
    ]
},
{
    "q": "CQRS and SOLID?",
    "o": [
        "Applies SRP at architectural level (Read Model vs Write Model)",
        "Violates SRP",
        "Bad",
        "Neutral"
    ]
},
{
    "q": "Event Sourcing and OCP?",
    "o": [
        "Good OCP: New features can be built by replaying old events into new projections",
        "Violates OCP",
        "Bad",
        "Neutral"
    ]
},
{
    "q": "What is 'Anemic Domain Model'?",
    "o": [
        "Anti-pattern: Entities have data but no behavior (Logic is in Services) - purely procedural",
        "Rich Model",
        "Good Model",
        "SOLID Model"
    ]
},
{
    "q": "Rich Domain Model?",
    "o": [
        "Entities contain business logic and ensure invariants (OOP)",
        "Anemic",
        "Poor",
        "Service-heavy"
    ]
},
{
    "q": "Does Hibernate/JPA force Anemic Model?",
    "o": [
        "Often encourages getters/setters/no-arg constructors, but Rich Model is possible with care",
        "Yes always",
        "No never",
        "Unsure"
    ]
},
{
    "q": "Is Setter Injection bad?",
    "o": [
        "Can lead to incomplete objects (temporal coupling); Constructor injection preferred for required deps",
        "Good",
        "Best",
        "Fast"
    ]
},
{
    "q": "Field Injection (Spring @Autowired)?",
    "o": [
        "Hides dependencies, hard to test without reflection (Container magic) - Constructor preferred",
        "Best",
        "Clean",
        "Easy"
    ]
},
{
    "q": "Service vs Component?",
    "o": [
        "Component is generic building block; Service implies stateless business logic container",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Cross-Cutting Concerns?",
    "o": [
        "Aspects that affect many modules (Logging, Auth, Tx) - handled by AOP/Proxy/Decorator",
        "Core concerns",
        "Business logic",
        "Data"
    ]
},
{
    "q": "AOP and SRP?",
    "o": [
        "Supports SRP: Moves 'plumbing' code out of business classes",
        "Violates SRP",
        "Bad",
        "Neutral"
    ]
},
{
    "q": "Decorator vs built-in Subclassing?",
    "o": [
        "Decorator prevents class explosion (combinatorial subclasses)",
        "Subclassing better",
        "Same",
        "Unknown"
    ]
},
{
    "q": "Java 'final' class?",
    "o": [
        "Cannot be subclassed (Enforces Composition over Inheritance, or Security)",
        "Can be",
        "Abstract",
        "Interface"
    ]
},
{
    "q": "Immutable Object benefits?",
    "o": [
        "Thread-safe, hash-safe, easy to reason about",
        "Fast modification",
        "Low memory",
        "Changeable"
    ]
},
{
    "q": "How to create Immutable Class in Java?",
    "o": [
        "Final class, private final fields, no setters, deep copy mutable args/returns",
        "Public fields",
        "Setters",
        "Static"
    ]
},
{
    "q": "Value Object identity?",
    "o": [
        "defined by attributes (values), not memory address/ID",
        "ID",
        "Pointer",
        "Reference"
    ]
},
{
    "q": "Entity identity?",
    "o": [
        "defined by unique ID, persists through value changes",
        "Values",
        "Attributes",
        "State"
    ]
},
{
    "q": "DTO (Data Transfer Object)?",
    "o": [
        "Dumb implementation of data container for moving data between layers (No behavior)",
        "Smart",
        "Logic",
        "Controller"
    ]
},
{
    "q": "POJO (Plain Old Java Object)?",
    "o": [
        "Ordinary object not bound to framework restrictions",
        "EJB",
        "Servlet",
        "System"
    ]
},
{
    "q": "Is 'static' variable global state?",
    "o": [
        "Yes, effectively. Shared across all instances/program.",
        "No",
        "Local",
        "Thread safe"
    ]
},
{
    "q": "Singleton vs Static Class?",
    "o": [
        "Singleton: Can implement interface, pass as param, lazy load, mockable (better OOP); Static: Procedures",
        "Static better",
        "Same",
        "Unknown"
    ]
},
{
    "q": "Utility Classes (StringUtils)?",
    "o": [
        "Usually Static Methods; harmless for pure functions, bad for stateful logic",
        "Good always",
        "Bad always",
        "Unsure"
    ]
},
{
    "q": "Extension Methods over Utils?",
    "o": [
        "Syntactic sugar (obj.method() vs Utils.method(obj)), improves readability/discovery",
        "Worse",
        "Slower",
        "Same"
    ]
},
{
    "q": "Fluent Interface?",
    "o": [
        "Method chaining for readability (often DSLs)",
        "Fast",
        "Slow",
        "Broken"
    ]
},
{
    "q": "DSL (Domain Specific Language)?",
    "o": [
        "Language specialized to a particular application domain (Internal or External)",
        "General",
        "Java",
        "C#"
    ]
},
{
    "q": "Convention over Configuration?",
    "o": [
        "Framework makes decisions based on conventions (e.g. naming) to reduce config (Spring Boot)",
        "Config always",
        "Manual",
        "Hard"
    ]
},
{
    "q": "Sensible Defaults?",
    "o": [
        "Pre-configuring common settings to reduce setup friction",
        "No defaults",
        "Empty",
        "Null"
    ]
},
{
    "q": "SOLID in Dynamic Languages (Python/JS)?",
    "o": [
        "Still applies (Coupling/Cohesion/SRP/OCP), but interfaces/types are implicit (Duck Typing)",
        "Does not apply",
        "Only Java",
        "Only C#"
    ]
},
{
    "q": "Duck Typing and LSP?",
    "o": [
        "If it walks/quacks like duck, it's a duck. Must still adhere to behavioral contract to be safe substitution.",
        "Always safe",
        "Never safe",
        "Ignore"
    ]
},
{
    "q": "Python 'ABC' (Abstract Base Class)?",
    "o": [
        "Used to define formal Interfaces/Contracts in Python",
        "Alphabet",
        "Start",
        "Module"
    ]
},
{
    "q": "TypeScript Interfaces?",
    "o": [
        "Structural typing (shape matching) rather than Nominal (name matching)",
        "Nominal",
        "Classes",
        "Runtime"
    ]
},
{
    "q": "JS Prototype Chain?",
    "o": [
        "Mechanism for inheritance in JS (Objects inherit from other objects)",
        "Class inheritance",
        "Interfaces",
        "Modules"
    ]
},
{
    "q": "Functional Interface (Java)?",
    "o": [
        "Interface with single abstract method (SAM), used for Lambdas",
        "Many methods",
        "Marker",
        "Class"
    ]
},
{
    "q": "Marker Interface?",
    "o": [
        "Empty interface (e.g. Serializable) providing metadata/type check",
        "Full",
        "Method",
        "Data"
    ]
},
{
    "q": "Annotations vs Marker Interfaces?",
    "o": [
        "Annotations generally preferred for metadata now; Markers for type safety",
        "Markers better",
        "Same",
        "Unknown"
    ]
},
{
    "q": "Reflection?",
    "o": [
        "Code inspecting/modifying itself at runtime. Powerful but breaks encapsulation/safety/perf.",
        "Fast",
        "Safe",
        "Easy"
    ]
},
{
    "q": "Generics and type safety?",
    "o": [
        "Compile-time check ensuring type correctness (avoids casting)",
        "Runtime",
        "Slow",
        "Unsafe"
    ]
},
{
    "q": "Type Erasure (Java)?",
    "o": [
        "Generics removed at runtime (backwards compatibility)",
        "Kept",
        "Reified",
        "New"
    ]
},
{
    "q": "Reified Generics (Kotlin/C#)?",
    "o": [
        "Type info available at runtime",
        "Erased",
        "Lost",
        "Hidden"
    ]
},
{
    "q": "Variance (Covariance/Contravariance)?",
    "o": [
        "Rules for subtyping of complex types (List<Dog> vs List<Animal>)",
        "Variables",
        "Variation",
        "Value"
    ]
},
{
    "q": "PECS (Producer Extends, Consumer Super)?",
    "o": [
        "Java mnemonic for wildcard usage (? extends T for reading, ? super T for writing)",
        "Type",
        "Generic",
        "List"
    ]
},
{
    "q": "Can Interface have static methods (Java)?",
    "o": [
        "Yes (since Java 8)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Can Interface have private methods (Java)?",
    "o": [
        "Yes (since Java 9) - for sharing code between default methods",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Record (Java 14+)?",
    "o": [
        "Immutable data carrier class (boilerplate reduction for POJOs/DTOs)",
        "Cassette",
        "Disc",
        "Vinyl"
    ]
},
{
    "q": "Sealed Classes (Java 15+)?",
    "o": [
        "Restrict which other classes may extend them (Control hierarchy - Domain Modeling)",
        "Open",
        "Public",
        "Broken"
    ]
},
{
    "q": "Pattern Matching (Java 16+)?",
    "o": [
        "Testing expression against a pattern (instanceof with binding, switch expressions)",
        "Regex",
        "String",
        "Search"
    ]
},
{
    "q": "Does Pattern Matching violate OCP?",
    "o": [
        "Debatable; good for closed sets (Sealed classes) where operations vary (Visitor-like) without Double Dispatch",
        "Yes",
        "No",
        "Unsure"
    ]
},
{
    "q": "Data Locality Pattern?",
    "o": [
        "Arranging data in memory for cache coherency (Game Dev / Performance)",
        "Database",
        "Cloud",
        "Local"
    ]
},
{
    "q": "Dirty Flag Pattern?",
    "o": [
        "Avoiding expensive work if data hasn't changed",
        "Flag",
        "Clean",
        "Wash"
    ]
},
{
    "q": "EventQueue Pattern?",
    "o": [
        "Decouple when a message is sent from when it is processed",
        "Queue",
        "Stack",
        "Array"
    ]
},
{
    "q": "Type Object Pattern?",
    "o": [
        "Allow creating new 'types' (flexible instances) at runtime by delegation (e.g. Monster(Breed))",
        "Class",
        "Object",
        "Factory"
    ]
},
{
    "q": "Null Object Pattern vs Optionals?",
    "o": [
        "Null object is polymorphic; Optional is container/monad forcing check. Both avoid NPE.",
        "Same",
        "Conflict",
        "Bad"
    ]
},
{
    "q": "Service Layer?",
    "o": [
        "Defines application boundary/operations; coordinates domain objects",
        "UI",
        "DB",
        "Network"
    ]
},
{
    "q": "Unit of Work?",
    "o": [
        "Maintains list of objects affected by transaction and coordinates writing changes (Hibernate Session)",
        "Single work",
        "Job",
        "Task"
    ]
},
{
    "q": "Identity Map?",
    "o": [
        "Ensures each object is loaded only once per transaction (Cache/Uniqueness)",
        "Map",
        "ID",
        "Passport"
    ]
},
{
    "q": "Lazy Loading types?",
    "o": [
        "Virtual Proxy, Value Holder, Ghost",
        "Fast",
        "Real",
        "Now"
    ]
},
{
    "q": "Gateway Pattern?",
    "o": [
        "Encapsulates access to external system/resource (DIP)",
        "Door",
        "Fence",
        "Gate"
    ]
},
{
    "q": "Mapper Pattern?",
    "o": [
        "Moves data between objects/layers that need to stay decoupled (DTO Mapper)",
        "Map",
        "Atlas",
        "GPS"
    ]
},
{
    "q": "Layer Supertype?",
    "o": [
        "Type acting as superclass for all types in a layer (e.g. DomainObject with ID)",
        "Superman",
        "Hero",
        "Base"
    ]
},
{
    "q": "Separated Interface?",
    "o": [
        "Interface in one package, implementation in another (DIP structure)",
        "Together",
        "Coupled",
        "Joined"
    ]
},
{
    "q": "Plugin Pattern?",
    "o": [
        "Classes are loaded at runtime based on config (Strategy + Dynamic Loading)",
        "Plug",
        "Socket",
        "Wire"
    ]
},
{
    "q": "Value Object vs Reference Object?",
    "o": [
        "Value: Equality by value, immutable, replaceable; Reference: Equality by ID, mutable life",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Money Pattern?",
    "o": [
        "Value object representing money (Currency + Amount) to avoid float errors",
        "Cash",
        "Bank",
        "Gold"
    ]
},
{
    "q": "Special Case Pattern?",
    "o": [
        "Subclass that provides special behavior for particular cases (Null Object is a specific type of this)",
        "Switch",
        "If",
        "General"
    ]
}
,
{
    "q": "What is 'Brooks' Law'?",
    "o": [
        "Adding manpower to a late software project makes it later (Communication overhead)",
        "Adding money helps",
        "Adding time helps",
        "Adding managers helps"
    ]
},
{
    "q": "What is 'Conway's Law'?",
    "o": [
        "Organizations design systems that mirror their own communication structure (Microservices often reflect teams)",
        "Good code",
        "Bad code",
        "Fast code"
    ]
},
{
    "q": "Inverse Conway Maneuver?",
    "o": [
        "Designing organization structure to match the desired software architecture",
        "Reverse engineering",
        "Refactoring",
        "Copying"
    ]
},
{
    "q": "What is 'CAP Theorem'?",
    "o": [
        "Distributed Data Store can only guarantee 2 of 3: Consistency, Availability, Partition Tolerance",
        "ACID",
        "BASE",
        "SOLID"
    ]
},
{
    "q": "CP System (CAP)?",
    "o": [
        "Consistent and Partition Tolerant, but not Available (returns error if partition happens)",
        "AP",
        "CA",
        "Fast"
    ]
},
{
    "q": "AP System (CAP)?",
    "o": [
        "Available and Partition Tolerant, but eventually consistent (returns potentially stale data)",
        "CP",
        "CA",
        "Slow"
    ]
},
{
    "q": "CA System (CAP)?",
    "o": [
        "Consistent and Available, but assumed no network partitions (Impossible in distributed system)",
        "CP",
        "AP",
        "Real"
    ]
},
{
    "q": "What is 'PACELC'?",
    "o": [
        "Extension of CAP: If P (Partition), choose A or C. Else (Latency/Consistency trade-off).",
        "Package",
        "Pattern",
        "Protocol"
    ]
},
{
    "q": "Eventual Consistency?",
    "o": [
        "Data will become consistent over time, but no immediate guarantee (AP systems)",
        "Strong Consistency",
        "Immediate",
        "Never"
    ]
},
{
    "q": "Strong Consistency?",
    "o": [
        "All reads receive the most recent write (CP systems)",
        "Weak",
        "Eventual",
        "Slow"
    ]
},
{
    "q": "ACID vs BASE?",
    "o": [
        "ACID: Atomic, Consistent, Isolated, Durable (SQL); BASE: Basic Availability, Soft state, Eventual consistency (NoSQL)",
        "Same",
        "Opposite",
        "Unrelated"
    ]
},
{
    "q": "Distributed Fallacy 1?",
    "o": [
        "The network is reliable",
        "Latency is zero",
        "Bandwidth is infinite",
        "Topology doesn't change"
    ]
},
{
    "q": "Distributed Fallacy 2?",
    "o": [
        "Latency is zero",
        "Network is secure",
        "One admin",
        "Transport cost is zero"
    ]
},
{
    "q": "Sidecar Pattern?",
    "o": [
        "Deploys components of an application into a separate process/container (e.g. Logging sidecar in K8s pod)",
        "Motorcycle",
        "Plugin",
        "Adapter"
    ]
},
{
    "q": "Ambassador Pattern?",
    "o": [
        "Helper service that sends network requests on behalf of a client service (Proxy for external calls)",
        "Diplomat",
        "Decorate",
        "Facade"
    ]
},
{
    "q": "Saga Pattern?",
    "o": [
        "Sequence of local transactions; if one fails, compensating transactions undo previous steps",
        "Story",
        "Myth",
        "Epic"
    ]
},
{
    "q": "Choreography vs Orchestration (Saga)?",
    "o": [
        "Choreography: Services talk to each other (Events); Orchestration: Central coordinator (Command)",
        "Dance",
        "Music",
        "Singing"
    ]
},
{
    "q": "Compensating Transaction?",
    "o": [
        "Action to undo a committed transaction in a Saga (e.g. Refund payment)",
        "Rollback",
        "Commit",
        "Save"
    ]
},
{
    "q": "Idempotency?",
    "o": [
        "Operation can be applied multiple times without changing the result beyond the initial application",
        "Atomic",
        "Unique",
        "Faster"
    ]
},
{
    "q": "Is POST idempotent?",
    "o": [
        "No, creating resource multiple times usually creates duplicates (unless protected)",
        "Yes",
        "Maybe",
        "REST"
    ]
},
{
    "q": "Is PUT idempotent?",
    "o": [
        "Yes, replacing resource multiple times has same effect",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Actor Model?",
    "o": [
        "Concurrency model where 'Actors' send messages to each other; no shared state (Akka/Erlang)",
        "Movie",
        "Thespian",
        "Thread"
    ]
},
{
    "q": "SEDA (Staged Event-Driven Architecture)?",
    "o": [
        "Decomposes complex, event-driven application into stages connected by queues",
        "Flow",
        "Stream",
        "Pipe"
    ]
},
{
    "q": "Backpressure?",
    "o": [
        "Mechanism for a consumer to signal producer to slow down (Reactive Streams)",
        "Pressure",
        "Push",
        "Pull"
    ]
},
{
    "q": "Rate Limiting?",
    "o": [
        "Controlling rate of traffic sent or received (Token Bucket, Leaky Bucket)",
        "Speed",
        "Stop",
        "Go"
    ]
},
{
    "q": "Throttling vs Rate Limiting?",
    "o": [
        "Throttling slows down (queues); Rate Limiting rejects (429 Too Many Requests)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "What is 'Sharding'?",
    "o": [
        "Partitioning data across multiple machines (Horizontal scaling)",
        "Mirroring",
        "Replication",
        "Backup"
    ]
},
{
    "q": "Database Normalization?",
    "o": [
        "Organizing data to reduce redundancy (1NF, 2NF, 3NF)",
        "Optimization",
        "Indexing",
        "Caching"
    ]
},
{
    "q": "Denormalization?",
    "o": [
        "Adding redundancy to improve read performance (NoSQL/Data Warehouse)",
        "Bad",
        "Messy",
        "Slow"
    ]
},
{
    "q": "Polyglot Persistence?",
    "o": [
        "Using different data storage technologies for different needs in same system (Redis + Postgres + Mongo)",
        "Single DB",
        "Many languages",
        "Translation"
    ]
},
{
    "q": "Database Index?",
    "o": [
        "Data structure (B-Tree) improving speed of data retrieval operations",
        "Table",
        "Row",
        "Column"
    ]
},
{
    "q": "N+1 Select Problem?",
    "o": [
        "Performance issue: 1 query for parents, then N queries for children (ORM issue)",
        "Optimization",
        "Faster",
        "Good"
    ]
},
{
    "q": "Lazy Loading vs Eager Loading?",
    "o": [
        "Lazy: Load when accessed (avoids overhead, risks N+1); Eager: Load immediately (join)",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "DTO vs VO?",
    "o": [
        "DTO: Data carrier between processes (dumb); VO: Domain object defined by value (smart)",
        "Same",
        "Opposite",
        "Unknown"
    ]
},
{
    "q": "Entity vs Value Object (DDD)?",
    "o": [
        "Entity: Identity continuity; VO: Immutable attribute description",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "Aggregate Root (DDD)?",
    "o": [
        "Entity ensuring consistency of changes within aggregate boundary (Store vs Transaction)",
        "Root",
        "Leaf",
        "Branch"
    ]
},
{
    "q": "Ubiquitous Language (DDD)?",
    "o": [
        "Common language shared by developers and domain experts (Code matches Reality)",
        "Java",
        "English",
        "Latin"
    ]
},
{
    "q": "Anti-Pattern: Golden Hammer?",
    "o": [
        "I have a hammer, everything looks like a nail",
        "Best tool",
        "Silver bullet",
        "Platinum"
    ]
},
{
    "q": "Anti-Pattern: Not Invented Here?",
    "o": [
        "Refusing to use existing solutions/libraries, building custom ones instead",
        "Inventing",
        "Creating",
        "Buying"
    ]
},
{
    "q": "Anti-Pattern: Reinventing the Wheel?",
    "o": [
        "Building something that already exists and works well",
        "Improving",
        "fixing",
        "Breaking"
    ]
},
{
    "q": "Bus Factor?",
    "o": [
        "Minimum number of team members that must vanish (hit by bus) for project to stall",
        "Vehicle",
        "Transport",
        "Route"
    ]
},
{
    "q": "Code Review Benefits?",
    "o": [
        "Knowledge sharing, Bus Factor reduction, Defect finding, Consistency",
        "Slowing down",
        "Blame",
        "Judging"
    ]
},
{
    "q": "Pair Programming?",
    "o": [
        "Two devs, one computer (Driver/Navigator). High quality, high focus.",
        "Slow",
        "Waste",
        "Fun"
    ]
},
{
    "q": "Mob Programming?",
    "o": [
        "Entire team working on one thing at one time (Extension of Pair)",
        "Gang",
        "Crowd",
        "Riot"
    ]
},
{
    "q": "Trunk Based Development?",
    "o": [
        "Merge to main branch frequently (Short lived branches); avoids merge hell",
        "Git Flow",
        "Release Flow",
        "SVN"
    ]
},
{
    "q": "Feature Toggles vs Long Branches?",
    "o": [
        "Toggles allow merging incomplete code safely (Trunk based); Branches delay integration",
        "Same",
        "Branches better",
        "Toggles worse"
    ]
},
{
    "q": "Shift Left Testing?",
    "o": [
        "Moving testing earlier in the lifecycle (Unit tests, Static Analysis)",
        "Shift Right",
        "Shift Up",
        "Shift Down"
    ]
},
{
    "q": "Chaos Engineering (Netflix)?",
    "o": [
        "Experimenting on a system to build confidence in its capability to withstand turbulent conditions (Killing services)",
        "Random",
        "Messy",
        "Broken"
    ]
},
{
    "q": "Simian Army?",
    "o": [
        "Suite of chaos tools (Chaos Monkey, Latency Monkey)",
        "Zoo",
        "Animals",
        "Circus"
    ]
},
{
    "q": "Immutable Infrastructure?",
    "o": [
        "Servers are never modified after deployment; replaced by new ones (Containers/VMs)",
        "Mutable",
        "Updates",
        "Patches"
    ]
},
{
    "q": "Infrastructure as Code (IaC)?",
    "o": [
        "Managing infrastructure via code (Terraform, Ansible) -> Version Controlled",
        "Manual",
        "ClickOps",
        "Gui"
    ]
},
{
    "q": "Snowflake Server?",
    "o": [
        "Server that is unique/manually configured; hard to reproduce (Anti-pattern vs IaC)",
        "Ice",
        "Cold",
        "Winter"
    ]
},
{
    "q": "Phoenix Server?",
    "o": [
        "Server that acts like Phoenix (Burnt down and recreated regularly) - Immutable Infra",
        "Bird",
        "Fire",
        "Ash"
    ]
},
{
    "q": "Blue-Green Deployment?",
    "o": [
        "Two identical environments (Idle/Live); switch router to new version (Instant rollback)",
        "Red-Black",
        "Purple",
        "Yellow"
    ]
},
{
    "q": "Canary Deployment?",
    "o": [
        "Rollout to small subset of users first, then expand if metrics are good",
        "Bird",
        "Mine",
        "Gas"
    ]
},
{
    "q": "A/B Testing?",
    "o": [
        "Comparing two versions (Control/Variant) to see which performs better (Business metric)",
        "Testing",
        "Checking",
        "Validating"
    ]
},
{
    "q": "Technical Debt Quadrant?",
    "o": [
        "Reckless/Prudent vs Deliberate/Inadvertent",
        "Good/Bad",
        "High/Low",
        "Fast/Slow"
    ]
},
{
    "q": "SOLID in Database Design?",
    "o": [
        "Tables should have Single Responsibility (Normalization); avoid generic 'Data' tables",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "Polymorphic Association (DB)?",
    "o": [
        "Reference to one of several tables (ID + Type); breaks FK constraints (Anti-pattern usually)",
        "Good",
        "Fast",
        "Clean"
    ]
},
{
    "q": "Table per Hierarchy (Inheritance)?",
    "o": [
        "Single table with Discriminator column (performance good, null columns bad)",
        "Two tables",
        "Three tables",
        "No tables"
    ]
},
{
    "q": "Table per Type (Inheritance)?",
    "o": [
        "Separate tables for each subclass (Joined); Clean space, slow joins",
        "One table",
        "Mix",
        "Flat"
    ]
},
{
    "q": "Table per Concrete Class (Inheritance)?",
    "o": [
        "Separate tables with all columns (Union for queries); duplication of schema",
        "One table",
        "Mix",
        "Flat"
    ]
},
{
    "q": "Foreign Key vs Index?",
    "o": [
        "FK enforces integrity; Index improves speed (FK usually implies Index)",
        "Same",
        "Opposite",
        "Different"
    ]
},
{
    "q": "Composite Key?",
    "o": [
        "Key composed of multiple columns",
        "Simple",
        "Single",
        "Unique"
    ]
},
{
    "q": "Surrogate Key?",
    "o": [
        "Artificial key (Auto-increment ID, UUID) - detached from data",
        "Natural Key",
        "Business Key",
        "Composite"
    ]
},
{
    "q": "Natural Key?",
    "o": [
        "Key derived from data attributes (Email, SSN) - can change (bad)",
        "Surrogate",
        "ID",
        "Auto"
    ]
},
{
    "q": "UUID vs Auto-Increment?",
    "o": [
        "UUID: Unique across systems, big, unreadable; Auto: Simple, small, predictable (security risk)",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "Soft Delete?",
    "o": [
        "Marking record as deleted (is_deleted=true) instead of removing row",
        "Hard delete",
        "Drop",
        "Truncate"
    ]
},
{
    "q": "Hard Delete?",
    "o": [
        "Permanently removing row (DELETE FROM)",
        "Soft delete",
        "Update",
        "Hide"
    ]
},
{
    "q": "Optimistic Locking?",
    "o": [
        "Version column check on update (prevents lost updates without DB locks)",
        "Pessimistic",
        "Table lock",
        "Row lock"
    ]
},
{
    "q": "Pessimistic Locking?",
    "o": [
        "Locking row/table (SELECT FOR UPDATE) preventing others from reading/writing",
        "Optimistic",
        "Version",
        "Fast"
    ]
},
{
    "q": "Row Lock vs Table Lock?",
    "o": [
        "Row: Higher concurrency, more overhead; Table: Low concurrency, low overhead",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "Deadlock (DB)?",
    "o": [
        "Transaction A holds Lock 1 waits for Lock 2; Transaction B holds Lock 2 waits for Lock 1",
        "Fast",
        "Slow",
        "Stop"
    ]
},
{
    "q": "Isolation Levels (Read Uncommitted)?",
    "o": [
        "Dirty reads allowed (Fastest, most dangerous)",
        "Committed",
        "Repeatable",
        "Serializable"
    ]
},
{
    "q": "Isolation Levels (Read Committed)?",
    "o": [
        "No dirty reads; distinct reads in same trx can differ (Non-repeatable read)",
        "Dirty",
        "Repeatable",
        "Serializable"
    ]
},
{
    "q": "Isolation Levels (Repeatable Read)?",
    "o": [
        "Reads are consistent within trx; Phantom reads possible (New rows)",
        "Dirty",
        "Committed",
        "Serializable"
    ]
},
{
    "q": "Isolation Levels (Serializable)?",
    "o": [
        "Highest isolation; execution as if serial (Slowest, No concurrency anomalies)",
        "Fastest",
        "Weakest",
        "Bad"
    ]
},
{
    "q": "Connection Pool starvation?",
    "o": [
        "Threads waiting for DB connection (Pool exhausted)",
        "Food",
        "Hungry",
        "Full"
    ]
},
{
    "q": "HikariCP?",
    "o": [
        "Popular high-performance JDBC Connection Pool",
        "River",
        "Mountain",
        "City"
    ]
},
{
    "q": "JPA (Java Persistence API)?",
    "o": [
        "Specification for ORM in Java (Hibernate implements it)",
        "Library",
        "Tool",
        "Framework"
    ]
},
{
    "q": "Hibernate vs JDBC?",
    "o": [
        "Hibernate: ORM (Productivity, caching, lazy loading); JDBC: Low level (Control, performance references)",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "MyBatis?",
    "o": [
        "SQL Mapper framework (Control of SQL like JDBC, but easier mapping than raw JDBC)",
        "ORM",
        "Hibernate",
        "Spring"
    ]
},
{
    "q": "Spring Data JPA?",
    "o": [
        "Abstraction over JPA (Repository interfaces auto-implemented) - productivity booster",
        "Hibernate",
        "Eclipse",
        "JDBC"
    ]
},
{
    "q": "Does Spring Data support Projections?",
    "o": [
        "Yes, interfaces to fetch subset of columns (DTOs avoiding full entity overhead)",
        "No",
        "Maybe",
        "Unsure"
    ]
},
{
    "q": "What is 'Lombok'?",
    "o": [
        "Library to reduce boilerplate (Getters/Setters/Builder) via Annotations - modifies bytecode",
        "Island",
        "City",
        "Language"
    ]
},
{
    "q": "What is 'MapStruct'?",
    "o": [
        "Bean mapper (DTO <-> Entity) that generates code at compile time (Fast, Type safe)",
        "ModelMapper",
        "Reflection",
        "Slow"
    ]
},
{
    "q": "ModelMapper / Dozer?",
    "o": [
        "Reflection based mappers (Simpler setup, slower execution/runtime errors possible)",
        "MapStruct",
        "Fast",
        "Compile time"
    ]
},
{
    "q": "Jackson?",
    "o": [
        "JSON library for Java (Serialization/Deserialization)",
        "Michael",
        "Singer",
        "Town"
    ]
},
{
    "q": "GSON?",
    "o": [
        "Google's JSON library",
        "Facebook",
        "Apple",
        "Amazon"
    ]
},
{
    "q": "Protobuf?",
    "o": [
        "Binary serialization format (Google) - smaller/faster than JSON",
        "Text",
        "XML",
        "HTML"
    ]
},
{
    "q": "Avro?",
    "o": [
        "Row-based storage format (Hadoop) with schema evolution",
        "Column",
        "Text",
        "Json"
    ]
},
{
    "q": "Parquet?",
    "o": [
        "Columnar storage format (Analytics/Spark) - highly compressed",
        "Row",
        "Text",
        "Json"
    ]
},
{
    "q": "Kafka?",
    "o": [
        "Distributed Event Streaming Platform (Log based)",
        "Queue",
        "Topic",
        "DB"
    ]
},
{
    "q": "RabbitMQ vs Kafka?",
    "o": [
        "Rabbit: Smart Broker, Dumb Consumer (Queue/Routing); Kafka: Dumb Broker, Smart Consumer (Log, Replay)",
        "Same",
        "Opposite",
        "Unsure"
    ]
},
{
    "q": "Topic vs Queue?",
    "o": [
        "Queue: One consumer gets message (Point-to-Point); Topic: All subscribers get message (Pub-Sub)",
        "Same",
        "Opposite",
        "Unsure"
    ]
}
]