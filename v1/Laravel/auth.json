[
    {
        "q": "What is the primary configuration file for Laravel authentication?",
        "type": "mcq",
        "o": [
            "config/auth.php",
            "config/security.php",
            "config/user.php",
            "config/session.php"
        ]
    },
    {
        "q": "What Facade is used for interaction with authentication services?",
        "type": "mcq",
        "o": [
            "Msg::class? No, Auth::class (Illuminate\\Support\\Facades\\Auth).",
            "User::class",
            "Login::class",
            "Guard::class"
        ]
    },
    {
        "q": "How do you retrieve the currently authenticated user?",
        "type": "mcq",
        "o": [
            "Auth::user()",
            "Auth::get()",
            "User::current()",
            "Auth::current()"
        ]
    },
    {
        "q": "How to check if the user is authenticated (returns boolean)?",
        "type": "mcq",
        "o": [
            "Auth::check()",
            "Auth::exists()",
            "Auth::isLogged()",
            "Auth::valid()"
        ]
    },
    {
        "q": "How to get the ID of the authenticated user?",
        "type": "mcq",
        "o": [
            "Auth::id()",
            "Auth::user()->id",
            "Both A and B",
            "Auth::userId()"
        ]
    },
    {
        "q": "What is an Authentication 'Guard'?",
        "type": "mcq",
        "o": [
            "Defines how users are authenticated for each request (e.g., session, token).",
            "A firewall rule",
            "A database trigger",
            "A middleware"
        ]
    },
    {
        "q": "What is an Authentication 'Provider'?",
        "type": "mcq",
        "o": [
            "Defines how to retrieve users from persistent storage (e.g., Eloquent, Database).",
            "An external API",
            "A login form",
            "A hashing algorithm"
        ]
    },
    {
        "q": "Default guard in a fresh Laravel installation?",
        "type": "mcq",
        "o": [
            "web (Session based)",
            "api (Token based)",
            "admin",
            "basic"
        ]
    },
    {
        "q": "How to attempt login with credentials?",
        "type": "mcq",
        "o": [
            "Auth::attempt(['email' => $email, 'password' => $password])",
            "Auth::login(['email' => $email, 'password' => $password])",
            "Auth::validate($email, $password)",
            "User::login($email, $password)"
        ]
    },
    {
        "q": "What does `Auth::attempt` return?",
        "type": "mcq",
        "o": [
            "Boolean (true on success, false on failure).",
            "The User object",
            "A token",
            "Redirect response"
        ]
    },
    {
        "q": "Does `Auth::attempt` automatically hash the password for comparison?",
        "type": "mcq",
        "o": [
            "Yes, it expects the plain text password in the array and compares it to the hashed password in DB.",
            "No, you must hash it first",
            "No, it stores plain text",
            "Yes, if configured"
        ]
    },
    {
        "q": "How to remember the user (Remember Me)?",
        "type": "mcq",
        "o": [
            "Pass `true` as second argument to attempt. `Auth::attempt($credentials, true)`.",
            "Auth::remember($user)",
            "Config option",
            "Cookie setup"
        ]
    },
    {
        "q": "How to manually log in a user instance?",
        "type": "mcq",
        "o": [
            "Auth::login($user)",
            "Auth::setUser($user)",
            "Auth::authenticate($user)",
            "Auth::start($user)"
        ]
    },
    {
        "q": "How to login via ID?",
        "type": "mcq",
        "o": [
            "Auth::loginUsingId(1)",
            "Auth::loginId(1)",
            "Auth::idLogin(1)",
            "Auth::start(1)"
        ]
    },
    {
        "q": "How to log the user out?",
        "type": "mcq",
        "o": [
            "Auth::logout()",
            "Auth::exit()",
            "Auth::destroy()",
            "Auth::close()"
        ]
    },
    {
        "q": "After logout, what should you typically do with the session?",
        "type": "mcq",
        "o": [
            "session()->invalidate() and session()->regenerateToken() to prevent session fixation/CSRF.",
            "Nothing",
            "Delete cookie manually",
            "Clear cache"
        ]
    },
    {
        "q": "Middleware to restrict access to authenticated users?",
        "type": "mcq",
        "o": [
            "auth",
            "guest",
            "admin",
            "api"
        ]
    },
    {
        "q": "Middleware to restrict access to UNavailable (guest) users?",
        "type": "mcq",
        "o": [
            "guest",
            "auth",
            "public",
            "open"
        ]
    },
    {
        "q": "How to access the authenticated user via Request?",
        "type": "mcq",
        "o": [
            "$request->user()",
            "$request->auth()",
            "$request->get('user')",
            "$request->identity()"
        ]
    },
    {
        "q": "Specifying a guard on the Auth facade?",
        "type": "mcq",
        "o": [
            "Auth::guard('admin')->check()",
            "Auth::via('admin')->check()",
            "Auth::driver('admin')->check()",
            "Auth::admin()->check()"
        ]
    },
    {
        "q": "What trait does the default User model use?",
        "type": "mcq",
        "o": [
            "HasApiTokens, HasFactory, Notifiable",
            "Authenticatable",
            "Authorizable",
            "All of the above (and extends Authenticatable class)"
        ]
    },
    {
        "q": "What base class does User model extend?",
        "type": "mcq",
        "o": [
            "Illuminate\\Foundation\\Auth\\User as Authenticatable",
            "Illuminate\\Database\\Eloquent\\Model",
            "App\\Models\\Model",
            "BaseUser"
        ]
    },
    {
        "q": "Which hashing algorithm is default in Laravel?",
        "type": "mcq",
        "o": [
            "Bcrypt (or Argon2 if configured)",
            "MD5",
            "SHA1",
            "SHA256"
        ]
    },
    {
        "q": "How to manually hash a password?",
        "type": "mcq",
        "o": [
            "Hash::make('password')",
            "bcrypt('password')",
            "Both A and B",
            "Hash::encrypt('password')"
        ]
    },
    {
        "q": "How to check password against hash?",
        "type": "mcq",
        "o": [
            "Hash::check('text', $hashedValue)",
            "Hash::verify('text', $hashedValue)",
            "Hash::compare('text', $hashedValue)",
            "$text == $hashedValue"
        ]
    },
    {
        "q": "What is 'Basic Authentication'?",
        "type": "mcq",
        "o": [
            "HTTP Basic Auth. Credentials sent in header (usually base64). Laravel supports via `auth.basic` middleware.",
            "Simple login form",
            "Admin login",
            "Guest login"
        ]
    },
    {
        "q": "Stateless middleware for API?",
        "type": "mcq",
        "o": [
            "auth:sanctum or auth:api (depending on setup).",
            "auth:web",
            "guest",
            "stateful"
        ]
    },
    {
        "q": "Login Throttling uses which middleware?",
        "type": "mcq",
        "o": [
            "throttle:attempts,minutes (e.g. throttle:6,1).",
            "limit",
            "block",
            "auth.throttle"
        ]
    },
    {
        "q": "Where to customize the username field (default 'email')?",
        "type": "mcq",
        "o": [
            "In Fortify/Breeze config, or manually in `attempt` array keys. Old controllers used `username()` method.",
            "In .env",
            "In auth.php",
            "Cannot change"
        ]
    },
    {
        "q": "What is 'Password Confirmation'?",
        "type": "mcq",
        "o": [
            "Middleware `password.confirm` that requires user to re-enter password before sensitive actions.",
            "Repeating password in registration",
            "Email verification",
            "Reset password"
        ]
    },
    {
        "q": "What is 'Email Verification'?",
        "type": "mcq",
        "o": [
            "Process of validating user's email ownership. Uses `MustVerifyEmail` interface on User model.",
            "Checking regex of email",
            "Sending newsletter",
            "Banning email"
        ]
    },
    {
        "q": "Middleware for verified email users?",
        "type": "mcq",
        "o": [
            "verified",
            "email",
            "active",
            "confirmed"
        ]
    },
    {
        "q": "How to send password reset link manually?",
        "type": "mcq",
        "o": [
            "Using `Password::sendResetLink($credentials)` facade method (or similar based on broker).",
            "Auth::reset()",
            "Mail::reset()",
            "User::reset()"
        ]
    },
    {
        "q": "Default password reset table name?",
        "type": "mcq",
        "o": [
            "password_resets",
            "password_tokens",
            "resets",
            "passwords"
        ]
    },
    {
        "q": "Authentication Events: Triggered on login?",
        "type": "mcq",
        "o": [
            "Illuminate\\Auth\\Events\\Login",
            "UserLoggedIn",
            "AuthSuccess",
            "SessionStart"
        ]
    },
    {
        "q": "Authentication Events: Triggered on failed attempt?",
        "type": "mcq",
        "o": [
            "Illuminate\\Auth\\Events\\Failed",
            "LoginFailed",
            "AuthError",
            "AttemptFailed"
        ]
    },
    {
        "q": "Authentication Events: Triggered on logout?",
        "type": "mcq",
        "o": [
            "Illuminate\\Auth\\Events\\Logout",
            "UserLoggedOut",
            "SessionEnd",
            "AuthStop"
        ]
    },
    {
        "q": "What is a 'Gate'?",
        "type": "mcq",
        "o": [
            "Closure-based authorization check. Defined in `AuthServiceProvider`.",
            "Database table",
            "Route group",
            "Firewall"
        ]
    },
    {
        "q": "How to define a Gate?",
        "type": "mcq",
        "o": [
            "Gate::define('update-post', function ($user, $post) { ... });",
            "Gate::make()",
            "Gate::rule()",
            "Gate::create()"
        ]
    },
    {
        "q": "How to check a Gate?",
        "type": "mcq",
        "o": [
            "Gate::allows('update-post', $post)",
            "Gate::check()",
            "Gate::can()",
            "Gate::test()"
        ]
    },
    {
        "q": "Inverse of `Gate::allows`?",
        "type": "mcq",
        "o": [
            "Gate::denies()",
            "Gate::refuses()",
            "Gate::fails()",
            "Gate::cant()"
        ]
    },
    {
        "q": "Facade `Gate` full class?",
        "type": "mcq",
        "o": [
            "Illuminate\\Support\\Facades\\Gate",
            "Illuminate\\Auth\\Gate",
            "App\\Gate",
            "Illuminate\\Security\\Gate"
        ]
    },
    {
        "q": "What is a 'Policy'?",
        "type": "mcq",
        "o": [
            "Class organizing authorization logic around a specific model.",
            "Government rule",
            "Terms of Service",
            "Privacy Policy"
        ]
    },
    {
        "q": "Command to create a policy?",
        "type": "mcq",
        "o": [
            "php artisan make:policy PostPolicy",
            "php artisan create:policy",
            "php artisan auth:policy",
            "php artisan make:auth"
        ]
    },
    {
        "q": "Create policy for specific model?",
        "type": "mcq",
        "o": [
            "php artisan make:policy PostPolicy --model=Post",
            "php artisan make:policy Post --for=Post",
            "php artisan make:modelpolicy Post",
            "php artisan auth:model Post"
        ]
    },
    {
        "q": "Where are Policies registered?",
        "type": "mcq",
        "o": [
            "AuthServiceProvider `$policies` array (or auto-discovered in newer Laravel).",
            "RouteServiceProvider",
            "Config/auth.php",
            "Controller"
        ]
    },
    {
        "q": "Check policy via User model?",
        "type": "mcq",
        "o": [
            "$user->can('update', $post)",
            "$user->allowed('update', $post)",
            "$user->policy('update', $post)",
            "$user->auth('update', $post)"
        ]
    },
    {
        "q": "Check policy via Controller helper?",
        "type": "mcq",
        "o": [
            "$this->authorize('update', $post)",
            "$this->check('update', $post)",
            "$this->validate('update', $post)",
            "$this->permit('update', $post)"
        ]
    },
    {
        "q": "Check policy in Blade?",
        "type": "mcq",
        "o": [
            "@can('update', $post) ... @endcan",
            "@policy('update', $post)",
            "@auth('update', $post)",
            "@allowed('update', $post)"
        ]
    },
    {
        "q": "Policy method `before`?",
        "type": "mcq",
        "o": [
            "Runs before any other check. Useful for granting Admin all access.",
            "Runs after check",
            "Runs on fail",
            "Runs on view"
        ]
    },
    {
        "q": "What is Laravel Sanctum?",
        "type": "mcq",
        "o": [
            "Lightweight authentication system for SPAs and simple APIs (Token based).",
            "Complex OAuth2 server",
            "Session manager",
            "Password hasher"
        ]
    },
    {
        "q": "What is Laravel Passport?",
        "type": "mcq",
        "o": [
            "Full OAuth2 server implementation for Laravel.",
            "Simple token auth",
            "Password manager",
            "2FA provider"
        ]
    },
    {
        "q": "Sanctum: Creating a token?",
        "type": "mcq",
        "o": [
            "$user->createToken('token-name')->plainTextToken",
            "$user->makeToken()",
            "Sanctum::create($user)",
            "Auth::token($user)"
        ]
    },
    {
        "q": "Sanctum: Revoking tokens?",
        "type": "mcq",
        "o": [
            "$user->tokens()->delete() (Delete all) or specific delete.",
            "$user->revoke()",
            "Sanctum::revoke($user)",
            "Auth::revoke()"
        ]
    },
    {
        "q": "Is Auth Facade a singleton?",
        "type": "mcq",
        "o": [
            "The underlying service (`auth`) is a singleton factory.",
            "No, new instance every time",
            "No, static only",
            "Depends on driver"
        ]
    },
    {
        "q": "How to access user ID without loading model?",
        "type": "mcq",
        "o": [
            "Auth::id() (Returns ID from session usually without DB query if optimized/id stored).",
            "Auth::user()->id",
            "Auth::getAuthIdentifier()",
            "Cannot do it"
        ]
    },
    {
        "q": "What is `LoginController` (Legacy)?",
        "type": "mcq",
        "o": [
            "Controller provided by `laravel/ui` auth scaffolding.",
            "Core framework class",
            "PHP class",
            "Composer package"
        ]
    },
    {
        "q": "What is `Breeze`?",
        "type": "mcq",
        "o": [
            "Minimal, simple implementation of all Laravel's authentication features.",
            "Heavy scaffolding",
            "API only auth",
            "Socialite wrapper"
        ]
    },
    {
        "q": "What is `Jetstream`?",
        "type": "mcq",
        "o": [
            "Application scaffolding for Laravel. Includes Auth, 2FA, Teams, etc.",
            "Database driver",
            "Testing tool",
            "Deploy tool"
        ]
    },
    {
        "q": "What is `Socialite`?",
        "type": "mcq",
        "o": [
            "Package for OAuth authentication with Facebook, Twitter, Google, etc.",
            "Social media feed",
            "Chat package",
            "Forum package"
        ]
    },
    {
        "q": "Hash: `needsRehash`?",
        "type": "mcq",
        "o": [
            "Checks if the password needs to be rehashed (e.g. algorithm work factor changed). `Hash::needsRehash($hashed)`.",
            "Checks if weak",
            "Checks if invalid",
            "Checks if expired"
        ]
    },
    {
        "q": "Authorization vs Authentication?",
        "type": "mcq",
        "o": [
            "Authentication: Who are you? (Login). Authorization: What can you do? (Permissions).",
            "Same thing",
            "Auth is logic, Authen is DB",
            "Reverse"
        ]
    },
    {
        "q": "Guest Middleware behavior?",
        "type": "mcq",
        "o": [
            "Redirects authenticated users to `HOME` (typically /home or /dashboard). Allow only guests.",
            "Allows everyone",
            "Blocks everyone",
            "Redirects to login"
        ]
    },
    {
        "q": "Redirecting unauthenticated users?",
        "type": "mcq",
        "o": [
            "Middleware `Authenticate` handles it. Usually redirects to named route `login`. (See `redirectTo` method in middleware).",
            "Always 403",
            "Always 500",
            "Always /"
        ]
    },
    {
        "q": "Protecting strict routes defined in closure?",
        "type": "mcq",
        "o": [
            "Route::get('/profile', ...)->middleware('auth');",
            "Route::auth('/profile')",
            "Route::secure('/profile')",
            "Auth::route('/profile')"
        ]
    },
    {
        "q": "Protecting Controllers in constructor?",
        "type": "mcq",
        "o": [
            "$this->middleware('auth');",
            "$this->auth()",
            "Auth::protect()",
            "Middleware::auth()"
        ]
    },
    {
        "q": "Does `Auth::logout()` invalidate other devices?",
        "type": "mcq",
        "o": [
            "No, only current session (unless using specific method to logout other devices).",
            "Yes, global logout",
            "Yes, bans user",
            "No, does nothing"
        ]
    },
    {
        "q": "Logging out other devices?",
        "type": "mcq",
        "o": [
            "Auth::logoutOtherDevices($password);",
            "Auth::logoutAll()",
            "Auth::killSessions()",
            "Cannot do it"
        ]
    },
    {
        "q": "Session Table Requirement for `logoutOtherDevices`?",
        "type": "mcq",
        "o": [
            "Session driver must not be 'cookie'. Usually 'database', 'redis' etc. And Middleware `AuthenticateSession` must be active.",
            "No requirement",
            "Must be 'file'",
            "Must be 'array'"
        ]
    },
    {
        "q": "Auth `defaults` in `config/auth.php`?",
        "type": "mcq",
        "o": [
            "Sets default guard (web) and passwords broker (users).",
            "Sets default user",
            "Sets default password",
            "Sets admin"
        ]
    },
    {
        "q": "What is a 'User Provider'?",
        "type": "mcq",
        "o": [
            "Implementation of finding users. e.g. `eloquent` (User model) or `database` (DB Query Builder).",
            "Social provider",
            "Internet provider",
            "Hosting provider"
        ]
    },
    {
        "q": "Custom Guard?",
        "type": "mcq",
        "o": [
            "You can define custom guards in `auth.php` using custom drivers.",
            "Not allowed",
            "Only paid feature",
            "Only Laravel Enterprise"
        ]
    },
    {
        "q": "Auth check returns false if?",
        "type": "mcq",
        "o": [
            "Session expired, user not logged in, or token invalid.",
            "User is admin",
            "User is active",
            "User exists"
        ]
    },
    {
        "q": "Can you use `Auth` in Blade?",
        "type": "mcq",
        "o": [
            "Yes, via `Auth` facade or `auth()` helper. `@if(Auth::check())`.",
            "No",
            "Only variables",
            "Only directives"
        ]
    },
    {
        "q": "Auth `viaRemember`?",
        "type": "mcq",
        "o": [
            "Auth::viaRemember(). Returns true if user was authenticated via 'remember me' cookie.",
            "Returns remember token",
            "Returns boolean if remember enabled",
            "Resets remember"
        ]
    },
    {
        "q": "Recalling user without login?",
        "type": "mcq",
        "o": [
            "Auth::once($credentials). Logs in for single request, no session/cookie.",
            "Auth::temp()",
            "Auth::quick()",
            "Auth::peek()"
        ]
    },
    {
        "q": "Auth `loginUsingId` remember argument?",
        "type": "mcq",
        "o": [
            "Auth::loginUsingId(1, true); (2nd arg is remember).",
            "Not supported",
            "Use loginUsingIdRemember",
            "Use array"
        ]
    },
    {
        "q": "Default Password Reset validity?",
        "type": "mcq",
        "o": [
            "60 minutes (configured in `auth.php` -> `passwords.users.expire`).",
            "24 hours",
            "1 week",
            "Unlimited"
        ]
    },
    {
        "q": "Password Broker?",
        "type": "mcq",
        "o": [
            "Handles sending reset links and validating tokens.",
            "Hacks passwords",
            "Sells passwords",
            "Stores passwords"
        ]
    },
    {
        "q": "Does User model require `password` column?",
        "type": "mcq",
        "o": [
            "Yes, by default Authenticatable expects `password` (and `getAuthPassword` method uses it).",
            "No, uses `secret`",
            "No, uses `pass`",
            "No, uses `key`"
        ]
    },
    {
        "q": "Customizing password column name?",
        "type": "mcq",
        "o": [
            "Override `getAuthPassword()` in User model.",
            "Config auth.php",
            "Migration only",
            "Cannot change"
        ]
    },
    {
        "q": "What is `MustVerifyEmail`?",
        "type": "mcq",
        "o": [
            "Interface to mark that User model should verify email.",
            "Trait",
            "Class",
            "Middleware"
        ]
    },
    {
        "q": "Can you have multiple Auth guards active?",
        "type": "mcq",
        "o": [
            "Yes, usually one default, but you can explicitly use others. `Auth::guard('api')->user()`.",
            "No, only one",
            "Only in distinct routes",
            "Only in console"
        ]
    },
    {
        "q": "Is Session ID regenerated on login?",
        "type": "mcq",
        "o": [
            "Yes, automatically to prevent session fixation.",
            "No",
            "Only on logout",
            "Only on register"
        ]
    },
    {
        "q": "What is `Authenticatable` contract?",
        "type": "mcq",
        "o": [
            "Interface defining methods needed for a model to be used by Auth driver (getAuthIdentifier, getAuthPassword, etc).",
            "Just a name",
            "Database schema",
            "Validation rule"
        ]
    },
    {
        "q": "Auth: `id()` vs `user()->id`?",
        "type": "mcq",
        "o": [
            "`id()` is slightly optimized (checks session first), `user()->id` retrieves full user model then id.",
            "Same",
            "`id()` is deprecated",
            "`user()->id` is deprecated"
        ]
    },
    {
        "q": "What is `RedirectIfAuthenticated`?",
        "type": "mcq",
        "o": [
            "Middleware that redirects already logged-in users away from login/register pages.",
            "Redirects to login",
            "Redirects to error",
            "Redirects to index"
        ]
    },
    {
        "q": "How to create a custom User Provider?",
        "type": "mcq",
        "o": [
            "Implement `UserProvider` interface and register via `Auth::provider`.",
            "Extend Model",
            "Extend Controller",
            "Extend Middleware"
        ]
    },
    {
        "q": "Sanctum: Middleware for ensuring request is stateful (SPA)?",
        "type": "mcq",
        "o": [
            "EnsureFrontendRequestsAreStateful",
            "StartSession",
            "VerifyCsrfToken",
            "Authenticate"
        ]
    },
    {
        "q": "Breeze vs Jetstream?",
        "type": "mcq",
        "o": [
            "Breeze is minimal (Blade/React/Vue options). Jetstream is robust (2FA, Teams, Profile management, Livewire/Inertia).",
            "Breeze is paid",
            "Jetstream is deprecated",
            "Both are same"
        ]
    },
    {
        "q": "Does Laravel Auth support JWT out of box?",
        "type": "mcq",
        "o": [
            "No, requires package (e.g. `tymon/jwt-auth`) or custom implementation. Sanctum/Passport use tokens but managed differently.",
            "Yes",
            "Yes, via API guard",
            "Yes, via JWT guard"
        ]
    },
    {
        "q": "Authorizing resources in controller?",
        "type": "mcq",
        "o": [
            "$this->authorizeResource(Post::class, 'post'); maps resourceful methods to policy methods.",
            "$this->resource()",
            "$this->guardResource()",
            "$this->policyResource()"
        ]
    },
    {
        "q": "Policy naming convention?",
        "type": "mcq",
        "o": [
            "ModelName + Policy (e.g. UserPolicy).",
            "Policy + ModelName",
            "ModelName + Auth",
            "ModelName + Access"
        ]
    },
    {
        "q": "Gate `before` vs `after`?",
        "type": "mcq",
        "o": [
            "`before` runs before checking rules (allow superadmin). `after` runs after rules (modification).",
            "Same",
            "After runs first",
            "Before runs last"
        ]
    },
    {
        "q": "Can you use Gates without Models?",
        "type": "mcq",
        "o": [
            "Yes. `Gate::define('access-dashboard', fn($user) => ...)`.",
            "No",
            "Only for admins",
            "Only for guests"
        ]
    },
    {
        "q": "What happens if no policy is found?",
        "type": "mcq",
        "o": [
            "Authorization fails (unless Gates handle it). Throws AuthorizationException if using `authorize`.",
            "Access granted",
            "Redirects",
            "Logs warning"
        ]
    },
    {
        "q": "Can you check multiple permissions at once?",
        "type": "mcq",
        "o": [
            "Gate::check(['perm1', 'perm2'])? `any`, `none` methods exist.",
            "Yes, always",
            "No",
            "Only via loop"
        ]
    },
    {
        "q": "What is `Auth::setUser($user)` used for?",
        "type": "mcq",
        "o": [
            "Sets the currently authenticated user for the request (without necessarily logging in session persistently, depending on guard).",
            "Persists to database",
            "Creates user",
            "Updates user"
        ]
    },
    {
        "q": "Where to customize the authentication guard for a specific route?",
        "type": "mcq",
        "o": [
            "Use middleware: `auth:guard_name`. e.g. `auth:api`.",
            "In config",
            "In controller",
            "In model"
        ]
    },
    {
        "q": "What is the `MustVerifyEmail` interface used for?",
        "type": "mcq",
        "o": [
            "Forces users to verify their email address before accessing protected routes.",
            "Sends spam",
            "Validates email format",
            "Encrypts email"
        ]
    },
    {
        "q": "What middleware ensures email is verified?",
        "type": "mcq",
        "o": [
            "verified",
            "auth.verified",
            "email",
            "check"
        ]
    },
    {
        "q": "How to manually mark a user's email as verified?",
        "type": "mcq",
        "o": [
            "$user->markEmailAsVerified()",
            "$user->verify()",
            "$user->confirm()",
            "$user->validate()"
        ]
    },
    {
        "q": "How to check if user has verified email?",
        "type": "mcq",
        "o": [
            "$user->hasVerifiedEmail()",
            "$user->isVerified()",
            "$user->verified()",
            "$user->checkEmail()"
        ]
    },
    {
        "q": "Where is the password reset token stored?",
        "type": "mcq",
        "o": [
            "In the `password_resets` table (hashed).",
            "In users table",
            "In session",
            "In cache"
        ]
    },
    {
        "q": "Can you use a different table for password resets?",
        "type": "mcq",
        "o": [
            "Yes, configured in `config/auth.php` (passwords > table).",
            "No",
            "Only defaults",
            "Only users"
        ]
    },
    {
        "q": "Command to scaffold authentication (Laravel UI)?",
        "type": "mcq",
        "o": [
            "php artisan ui vue --auth",
            "php artisan make:auth",
            "php artisan scaffold:auth",
            "php artisan create:auth"
        ]
    },
    {
        "q": "Command to install Breeze?",
        "type": "mcq",
        "o": [
            "php artisan breeze:install",
            "php artisan install:breeze",
            "php artisan make:breeze",
            "php artisan auth:breeze"
        ]
    },
    {
        "q": "Can you customize the password reset email?",
        "type": "mcq",
        "o": [
            "Yes, by overriding `sendPasswordResetNotification` on the User model.",
            "No",
            "Only subject",
            "Only footer"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\Events\\Registered`?",
        "type": "mcq",
        "o": [
            "Event dispatched when a new user registers. Often triggers sending verification email.",
            "Event on login",
            "Event on logout",
            "Event on delete"
        ]
    },
    {
        "q": "How to manually fire the Registered event?",
        "type": "mcq",
        "o": [
            "event(new Registered($user));",
            "Event::fire('registered')",
            "Auth::register($user)",
            "User::event($user)"
        ]
    },
    {
        "q": "What is the `throttle` middleware purpose in Auth?",
        "type": "mcq",
        "o": [
            "Prevent brute-force attacks by limiting login attempts.",
            "Throttle database",
            "Throttle bandwidth",
            "Throttle CPU"
        ]
    },
    {
        "q": "Default throttle limit for login?",
        "type": "mcq",
        "o": [
            "Usually 5 attempts per minute (defined in `LoginController` or Fortify config).",
            "10 attempts",
            "1 attempt",
            "Unlimited"
        ]
    },
    {
        "q": "How to define a Gate resource?",
        "type": "mcq",
        "o": [
            "Gate::resource('posts', 'PostPolicy'); (registers view, create, update, delete abilities automatically).",
            "Gate::model()",
            "Gate::crud()",
            "Gate::rest()"
        ]
    },
    {
        "q": "Gate `authorize` method usage?",
        "type": "mcq",
        "o": [
            "Gate::authorize('update', $post). Throws AuthorizationException if denied.",
            "Return bool",
            "Return string",
            "Redirects"
        ]
    },
    {
        "q": "Can Gates return a Response object?",
        "type": "mcq",
        "o": [
            "Yes, `Illuminate\\Auth\\Access\\Response::allow()` or `deny('Message')`.",
            "No, booleans only",
            "Only strings",
            "Only ints"
        ]
    },
    {
        "q": "Can you define Gates using a class callback?",
        "type": "mcq",
        "o": [
            "Yes. `Gate::define('update-post', [PostPolicy::class, 'update'])`.",
            "No",
            "Only closures",
            "Only strings"
        ]
    },
    {
        "q": "Policy: `viewAny` method matches what action?",
        "type": "mcq",
        "o": [
            "Index (listing all resources).",
            "View single",
            "View deleted",
            "View admin"
        ]
    },
    {
        "q": "Policy: `view` method matches what action?",
        "type": "mcq",
        "o": [
            "Show (viewing a single resource).",
            "Index",
            "Edit",
            "Create"
        ]
    },
    {
        "q": "Policy: `create` method?",
        "type": "mcq",
        "o": [
            "Determine if user can create a resource.",
            "Create resource",
            "Save to DB",
            "Validate"
        ]
    },
    {
        "q": "Policy: `restore` method?",
        "type": "mcq",
        "o": [
            "Determine if user can restore a soft-deleted model.",
            "Restore backup",
            "Restore session",
            "Restore factory"
        ]
    },
    {
        "q": "Policy: `forceDelete` method?",
        "type": "mcq",
        "o": [
            "Determine if user can permanently delete a model.",
            "Force push",
            "Hard reset",
            "Drop table"
        ]
    },
    {
        "q": "How to authorize inside a Form Request?",
        "type": "mcq",
        "o": [
            "Use the `authorize()` method in the request class. Return true/false or use `$this->user()->can(...)`.",
            "Use middleware",
            "Use rules",
            "Use validate"
        ]
    },
    {
        "q": "Can policies filter checks (Before method)?",
        "type": "mcq",
        "o": [
            "Yes, using `before` method in Policy. Returns true to allow all, false to deny all, or null to continue.",
            "No",
            "Only after",
            "Only middleware"
        ]
    },
    {
        "q": "How to register Policy auto-discovery?",
        "type": "mcq",
        "o": [
            "It is enabled by default in Laravel 9+. Looks in `app/Policies` matching Model naming.",
            "Manually in auth.php",
            "Manually in composer.json",
            "Not supported"
        ]
    },
    {
        "q": "Blade: `@canany` acts like?",
        "type": "mcq",
        "o": [
            "OR condition. If user has any of the given permissions.",
            "AND condition",
            "NOT condition",
            "XOR condition"
        ]
    },
    {
        "q": "Default user model namespace?",
        "type": "mcq",
        "o": [
            "App\\Models\\User",
            "App\\User",
            "User",
            "App\\Auth\\User"
        ]
    },
    {
        "q": "How to change the default user model location?",
        "type": "mcq",
        "o": [
            "Update `config/auth.php` (providers > users > model).",
            "Update composer.json",
            "Update .env",
            "Update database"
        ]
    },
    {
        "q": "What is `Auth::routes()`?",
        "type": "mcq",
        "o": [
            "Helper method (from `laravel/ui`) that registers standard authentication routes (login, register, password reset).",
            "Lists routes",
            "Debugs routes",
            "Clears routes"
        ]
    },
    {
        "q": "Disabling registration route in `Auth::routes`?",
        "type": "mcq",
        "o": [
            "Auth::routes(['register' => false]);",
            "Auth::routes()->noRegister()",
            "Auth::disableRegister()",
            "Config auth.register"
        ]
    },
    {
        "q": "Disabling password reset routes?",
        "type": "mcq",
        "o": [
            "Auth::routes(['reset' => false]);",
            "Auth::noReset()",
            "Auth::routes()->skipReset()",
            "Config auth.reset"
        ]
    },
    {
        "q": "Verify email routes with `Auth::routes`?",
        "type": "mcq",
        "o": [
            "Auth::routes(['verify' => true]); (False by default).",
            "Auth::verify()",
            "Auth::plus()",
            "Auth::email()"
        ]
    },
    {
        "q": "Sanctum: `HasApiTokens` trait methods?",
        "type": "mcq",
        "o": [
            "tokens(), tokenCan(), createToken(), currentAccessToken(), withAccessToken().",
            "getApi()",
            "setApi()",
            "authApi()"
        ]
    },
    {
        "q": "Sanctum: `tokenCan` usage?",
        "type": "mcq",
        "o": [
            "$user->tokenCan('post:update') checks if the access token has the specific capability.",
            "Checks role",
            "Checks gates",
            "Checks policy"
        ]
    },
    {
        "q": "Sanctum: Protecting routes?",
        "type": "mcq",
        "o": [
            "Route::middleware('auth:sanctum')",
            "Route::middleware('api')",
            "Route::sanctum()",
            "Route::secure()"
        ]
    },
    {
        "q": "Password Confirmation timeout default?",
        "type": "mcq",
        "o": [
            "3 hours (10800 seconds). Configured in `auth.php`.",
            "1 hour",
            "30 mins",
            "1 day"
        ]
    },
    {
        "q": "How to check if password confirmation is required?",
        "type": "mcq",
        "o": [
            "Use `RequirePassword` middleware or check timestamp manually?",
            "Auth::needsConfirm()",
            "Auth::checkConfirm()",
            "Auth::confirm()"
        ]
    },
    {
        "q": "What is the `Authorize` middleware?",
        "type": "mcq",
        "o": [
            "Illuminate\\Auth\\Middleware\\Authorize. Maps to `can` in kernel.",
            "Checks password",
            "Checks API key",
            "Checks login"
        ]
    },
    {
        "q": "Using `can` middleware with parameters?",
        "type": "mcq",
        "o": [
            "middleware('can:update,post')",
            "middleware('can:update-post')",
            "middleware('auth:update')",
            "middleware('gate:update')"
        ]
    },
    {
        "q": "Pass current user to Policy automatically?",
        "type": "mcq",
        "o": [
            "Yes, the first argument of policy methods is always the authenticated User (unless optional for guests).",
            "No, must pass manually",
            "Only for admins",
            "Only for creation"
        ]
    },
    {
        "q": "Allow guests in Policy?",
        "type": "mcq",
        "o": [
            "Type-hint User as nullable `?User $user` in policy method.",
            "Not possible",
            "Use Guest class",
            "Use Auth::guest()"
        ]
    },
    {
        "q": "Sanctum: Token abilities?",
        "type": "mcq",
        "o": [
            "Passed as 2nd arg to createToken. `['post:update', 'post:delete']`.",
            "Defined in config",
            "Defined in DB",
            "Not supported"
        ]
    },
    {
        "q": "Sanctum: Check all abilities?",
        "type": "mcq",
        "o": [
            "['*'] represents all abilities.",
            "['all']",
            "['root']",
            "['admin']"
        ]
    },
    {
        "q": "What driver does Sanctum use for SPA?",
        "type": "mcq",
        "o": [
            "It uses Laravel's built-in cookie based session authentication services.",
            "Token driver",
            "JWT driver",
            "OAuth driver"
        ]
    },
    {
        "q": "Customizing the 'unauthenticated' response?",
        "type": "mcq",
        "o": [
            "In `app/Exceptions/Handler.php` (unauthenticated method).",
            "In Controller",
            "In Route",
            "In Config"
        ]
    },
    {
        "q": "Is the User model the only authenticatable model?",
        "type": "mcq",
        "o": [
            "No, you can configure multiple guards with different models (e.g. Admin, Customer).",
            "Yes",
            "Yes, but can rename",
            "No, only 2 allowed"
        ]
    },
    {
        "q": "Accessing the current guard name?",
        "type": "mcq",
        "o": [
            "Auth::guard()->name? Not directly exposed easily. Usually configured via defaults.",
            "Auth::name()",
            "Auth::currentGuard()",
            "Auth::mode()"
        ]
    },
    {
        "q": "Stateless vs Stateful guards?",
        "type": "mcq",
        "o": [
            "Stateful uses sessions/cookies (web). Stateless uses tokens per request (api).",
            "Same",
            "Stateful is faster",
            "Stateless is safer"
        ]
    },
    {
        "q": "What is `RequestGuard`?",
        "type": "mcq",
        "o": [
            "A simple guard implementation using a closure to authenticate the request (used by Sanctum/Passport).",
            "Firewall",
            "Validation",
            "Rate limiter"
        ]
    },
    {
        "q": "How to authenticate a user for a single request without session?",
        "type": "mcq",
        "o": [
            "Auth::once($credentials) or Auth::onceUsingId($id).",
            "Auth::temp()",
            "Auth::flash()",
            "Auth::check()"
        ]
    },
    {
        "q": "What does `Auth::check()` return for guests?",
        "type": "mcq",
        "o": [
            "False.",
            "Null",
            "Error",
            "Guest object"
        ]
    },
    {
        "q": "What does `Auth::user()` return for guests?",
        "type": "mcq",
        "o": [
            "Null.",
            "False",
            "Error",
            "Guest object"
        ]
    },
    {
        "q": "Customizing password reset link email view?",
        "type": "mcq",
        "o": [
            "Publish the notification class or use `toMail` callback customization.",
            "Edit vendor files",
            "Edit config",
            "Edit .env"
        ]
    },
    {
        "q": "Is the `password` field hidden in User model serialization?",
        "type": "mcq",
        "o": [
            "Yes, usually in `$hidden` array to prevents leaking hash in API responses.",
            "No",
            "Only on export",
            "Only on production"
        ]
    },
    {
        "q": "What is `Remember Token`?",
        "type": "mcq",
        "o": [
            "A random string stored in database (`remember_token` column) and cookie to identify 'Remember Me' sessions.",
            "JWT token",
            "Session ID",
            "CSRF token"
        ]
    },
    {
        "q": "When is the `remember_token` refreshed?",
        "type": "mcq",
        "o": [
            "On login (if remember me selected) and logout (cleared/cycled to invalidate stolen cookies).",
            "Every request",
            "Every hour",
            "Never"
        ]
    },
    {
        "q": "Can you define policies for Pivot models?",
        "type": "mcq",
        "o": [
            "Yes, if they extend Model or Pivot.",
            "No",
            "Only via Gates",
            "Only via Controllers"
        ]
    },
    {
        "q": "Bypassing authorization for Super Admin?",
        "type": "mcq",
        "o": [
            "Use `Gate::before(function ($user, $ability) { if ($user->isSuperAdmin()) return true; });` in AuthServiceProvider.",
            "Config option",
            "Middleware",
            "Route group"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\AuthenticationException`?",
        "type": "mcq",
        "o": [
            "Thrown when an unauthenticated user tries to access a protected route.",
            "Login error",
            "Database error",
            "Validation error"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\Access\\AuthorizationException`?",
        "type": "mcq",
        "o": [
            "Thrown when an authenticated user is denied access to a resource (403 Forbidden).",
            "Login error",
            "404 error",
            "500 error"
        ]
    },
    {
        "q": "How to specify a custom error message for Gate denial?",
        "type": "mcq",
        "o": [
            "Return `Response::deny('Custom Message')` from the Gate/Policy.",
            "Throw Exception",
            "Return string",
            "Return false"
        ]
    },
    {
        "q": "Testing: acting as a user?",
        "type": "mcq",
        "o": [
            "$this->actingAs($user)",
            "$this->login($user)",
            "$this->auth($user)",
            "$this->user($user)"
        ]
    },
    {
        "q": "Testing: acting as user with specific guard?",
        "type": "mcq",
        "o": [
            "$this->actingAs($user, 'api')",
            "$this->guard('api')->login($user)",
            "$this->loginAs($user, 'api')",
            "$this->apiUser($user)"
        ]
    },
    {
        "q": "Testing: assert authenticated?",
        "type": "mcq",
        "o": [
            "$this->assertAuthenticated()",
            "$this->assertLoggedIn()",
            "$this->assertUser()",
            "$this->checkAuth()"
        ]
    },
    {
        "q": "Testing: assert guest?",
        "type": "mcq",
        "o": [
            "$this->assertGuest()",
            "$this->assertNotLoggedIn()",
            "$this->assertAnonymous()",
            "$this->checkGuest()"
        ]
    },
    {
        "q": "Sanctum: How are tokens stored?",
        "type": "mcq",
        "o": [
            "In `personal_access_tokens` table (Poly-morphic relation usually). Hashed.",
            "In users table",
            "In redis",
            "In file"
        ]
    },
    {
        "q": "Can you use Sanctum for mobile apps?",
        "type": "mcq",
        "o": [
            "Yes, issuing API tokens is its primary mobile use case.",
            "No, only web",
            "No, only SPA",
            "No, only desktop"
        ]
    },
    {
        "q": "Where is the `Auth::routes()` definition usually located in `web.php`?",
        "type": "mcq",
        "o": [
            "Top level, or inside a group. Just `Auth::routes();`.",
            "In Controller",
            "In Model",
            "In View"
        ]
    },
    {
        "q": "Default redirect after login?",
        "type": "mcq",
        "o": [
            "RouteServiceProvider::HOME (usually '/home' or '/dashboard').",
            "/",
            "/admin",
            "/profile"
        ]
    },
    {
        "q": "Customizing redirect path `redirectTo`?",
        "type": "mcq",
        "o": [
            "Define `redirectTo` property or method in LoginController/RegisterController.",
            "Edit .env",
            "Edit config",
            "Edit route"
        ]
    },
    {
        "q": "What is `EnsureEmailIsVerified` middleware?",
        "type": "mcq",
        "o": [
            "Full class name for 'verified' alias.",
            "Checks password",
            "Checks 2FA",
            "Checks CAPTCHA"
        ]
    },
    {
        "q": "Auth: `password.update` route?",
        "type": "mcq",
        "o": [
            "Handles the actual password change form submission.",
            "Shows form",
            "Sends email",
            "Verifies token"
        ]
    },
    {
        "q": "Auth: `password.request` route?",
        "type": "mcq",
        "o": [
            "Shows the 'Forgot Password' form.",
            "Shows reset form",
            "Handles submit",
            "Sends email"
        ]
    },
    {
        "q": "Auth: `password.reset` route?",
        "type": "mcq",
        "o": [
            "Shows the 'Reset Password' form (with token).",
            "Shows forgot form",
            "Handles submit",
            "Sends email"
        ]
    },
    {
        "q": "Auth: `password.email` route?",
        "type": "mcq",
        "o": [
            "Handles sending the reset link email.",
            "Shows form",
            "Shows reset form",
            "Updates password"
        ]
    },
    {
        "q": "Can you use `Auth::login` with an ID that doesn't exist?",
        "type": "mcq",
        "o": [
            "No, `loginUsingId` returns false/null if user not found. `login` requires a User instance.",
            "Yes, creates user",
            "Yes, logs as guest",
            "Throws error"
        ]
    },
    {
        "q": "What is `Auth::check()` performance?",
        "type": "mcq",
        "o": [
            "Very fast. Checks session/token. Does not hit DB if session is active and user is loaded/cached (depending on driver).",
            "Slow, always queries DB",
            "Slow, calls API",
            "Instant, magic"
        ]
    },
    {
        "q": "How to get the 'guard' instance configuration?",
        "type": "mcq",
        "o": [
            "Config::get('auth.guards.web')",
            "Auth::config()",
            "Guard::config()",
            "Not possible"
        ]
    },
    {
        "q": "What is the `HasApiTokens` trait in User model for?",
        "type": "mcq",
        "o": [
            "Provides methods to manage Sanctum/Passport tokens.",
            "Provides API routes",
            "Provides API controller",
            "Provides API middleware"
        ]
    },
    {
        "q": "Can you customize the token name in Sanctum?",
        "type": "mcq",
        "o": [
            "Yes, passed to `createToken`.",
            "No, always 'default'",
            "No, always random",
            "Only in config"
        ]
    },
    {
        "q": "Can you set token abilities in Passport?",
        "type": "mcq",
        "o": [
            "Yes, using Scopes.",
            "No",
            "Only Sanctum",
            "Only JWT"
        ]
    },
    {
        "q": "Passport: Personal Access Clients?",
        "type": "mcq",
        "o": [
            "Allow users to issue tokens for themselves without full OAuth flow.",
            "For admins only",
            "For APIs only",
            "For tests only"
        ]
    },
    {
        "q": "Passport: Password Grant Client?",
        "type": "mcq",
        "o": [
            "Allows other clients (like your mobile app) to exchange username/password for token.",
            "Reset password",
            "Change password",
            "Forgot password"
        ]
    },
    {
        "q": "Passport vs Sanctum performance?",
        "type": "mcq",
        "o": [
            "Sanctum is lighter (one DB query). Passport is heavier (OAuth tables, checks). Use Sanctum for simple need.",
            "Passport is lighter",
            "Same",
            "Sanctum is slower"
        ]
    },
    {
        "q": "Does Sanctum support expiration?",
        "type": "mcq",
        "o": [
            "Yes, configurable in `sanctum.php` (`expiration`).",
            "No, never expire",
            "No, 1 hour fixed",
            "No, 1 day fixed"
        ]
    },
    {
        "q": "Does Sanctum support Scopes?",
        "type": "mcq",
        "o": [
            "It supports 'Abilities' (lighter version of scopes).",
            "Full OAuth scopes",
            "No",
            "Only Permissions"
        ]
    },
    {
        "q": "How to list all abilities of a token?",
        "type": "mcq",
        "o": [
            "$token->abilities",
            "$token->scopes",
            "$token->list()",
            "$token->get()"
        ]
    },
    {
        "q": "What is `Laravel\\Fortify`?",
        "type": "mcq",
        "o": [
            "A frontend-agnostic authentication backend implementation. Powering Jetstream.",
            "Frontend UI",
            "Database tool",
            "Testing tool"
        ]
    },
    {
        "q": "Does Fortify include views?",
        "type": "mcq",
        "o": [
            "No. You must define the views and link them in Fortify config.",
            "Yes, Blade",
            "Yes, Vue",
            "Yes, React"
        ]
    },
    {
        "q": "What features does Fortify provide?",
        "type": "mcq",
        "o": [
            "Login, Registration, Reset Password, Email Verification, 2FA, Profile Update, Password Update.",
            "Just Login",
            "Just Register",
            "Just API"
        ]
    },
    {
        "q": "Sanctum: How to protect SPA routes (CSRF)?",
        "type": "mcq",
        "o": [
            "Laravel automatically handles CSRF protection via cookie if `EnsureFrontendRequestsAreStateful` and axios/sanctum client are configured.",
            "Must send token manually in header every time",
            "Must disable CSRF",
            "Must use Passport"
        ]
    },
    {
        "q": "Sanctum: Authentication Guard for SPA?",
        "type": "mcq",
        "o": [
            "web guard (Session based). Sanctum hooks into it.",
            "api guard",
            "sanctum guard",
            "spa guard"
        ]
    },
    {
        "q": "Sanctum: Authentication Guard for Mobile? (API Tokens)",
        "type": "mcq",
        "o": [
            "sanctum guard (which uses RequestGuard and checks for Bearer token).",
            "web guard",
            "api guard",
            "token guard"
        ]
    },
    {
        "q": "Socialite: Redirect method?",
        "type": "mcq",
        "o": [
            "Socialite::driver('github')->redirect()",
            "Socialite::login('github')",
            "Socialite::github()->auth()",
            "Socialite::start('github')"
        ]
    },
    {
        "q": "Socialite: Callback method?",
        "type": "mcq",
        "o": [
            "$user = Socialite::driver('github')->user();",
            "$user = Socialite::callback('github')",
            "$user = Socialite::handle('github')",
            "$user = Auth::social('github')"
        ]
    },
    {
        "q": "Socialite: Stateless method?",
        "type": "mcq",
        "o": [
            "Socialite::driver('github')->stateless()->user() (Useful for APIs where no session exists).",
            "Socialite::api('github')",
            "Socialite::token('github')",
            "Socialite::noSession('github')"
        ]
    },
    {
        "q": "Socialite: Retrieving raw user details?",
        "type": "mcq",
        "o": [
            "$user->getRaw() array.",
            "$user->original",
            "$user->raw",
            "$user->json"
        ]
    },
    {
        "q": "Socialite: Retrieving token?",
        "type": "mcq",
        "o": [
            "$user->token",
            "$user->accessToken",
            "$user->getToken()",
            "$user->secret"
        ]
    },
    {
        "q": "Passport: Do you need to run migrations?",
        "type": "mcq",
        "o": [
            "Yes, Passport creates several tables (oauth_clients, oauth_access_tokens, etc).",
            "No, it uses existing users table",
            "No, uses file storage",
            "No, uses Redis"
        ]
    },
    {
        "q": "Passport: `php artisan passport:install`?",
        "type": "mcq",
        "o": [
            "Generates encryption keys and creates 'personal access' and 'password grant' clients.",
            "Installs composer package",
            "Migrates database",
            "Creates admin user"
        ]
    },
    {
        "q": "Passport: Token expiration configuration?",
        "type": "mcq",
        "o": [
            "In `AuthServiceProvider`, use `Passport::tokensExpireIn(...)`.",
            "In config/auth.php",
            "In .env",
            "In Middleware"
        ]
    },
    {
        "q": "Passport: Pruning revoked tokens?",
        "type": "mcq",
        "o": [
            "php artisan passport:purge",
            "php artisan passport:clear",
            "php artisan passport:clean",
            "php artisan auth:clear"
        ]
    },
    {
        "q": "Policy Filter: `before` method priority?",
        "type": "mcq",
        "o": [
            "If `before` returns non-null result, that result is considered the final authorization decision.",
            "Runs alongside checked method",
            "Runs after",
            "Runs on exception"
        ]
    },
    {
        "q": "Policy `update` method typically accepts which arguments?",
        "type": "mcq",
        "o": [
            "User $user, Post $post",
            "User $user",
            "Post $post",
            "Request $request"
        ]
    },
    {
        "q": "Does Policy `create` method need a model instance?",
        "type": "mcq",
        "o": [
            "No, because the model doesn't exist yet. `create(User $user)`.",
            "Yes, empty instance",
            "Yes, null",
            "Yes, array"
        ]
    },
    {
        "q": "Gate `forUser` method?",
        "type": "mcq",
        "o": [
            "Gate::forUser($user)->allows('update', $post). Checks permission for a specific user (not currently authenticated).",
            "Gate::as($user)",
            "Gate::user($user)",
            "Gate::checkUser($user)"
        ]
    },
    {
        "q": "Auth: `viaRequest` (Custom Guards)?",
        "type": "mcq",
        "o": [
            "Auth::viaRequest('custom-token', function ($request) { ... }); Registers a driver.",
            "Auth::guardRequest()",
            "Auth::driver()",
            "Auth::listen()"
        ]
    },
    {
        "q": "How to verify password without logging in?",
        "type": "mcq",
        "o": [
            "Hash::check($password, $user->password) or `validate` method on provider.",
            "Auth::checkOneTime()",
            "Auth::verifyPassword()",
            "User::check()"
        ]
    },
    {
        "q": "Encrypting cookies in Sanctum?",
        "type": "mcq",
        "o": [
            "Sanctum's `laravel_session` cookie is encrypted by Laravel default encryption.",
            "Must be disabled",
            "Not encrypted",
            "Plain text"
        ]
    },
    {
        "q": "Sanctum: Customizing token model?",
        "type": "mcq",
        "o": [
            "Sanctum::usePersonalAccessTokenModel(CustomToken::class)",
            "Config sanctum.model",
            "Not possible",
            "Extend trait"
        ]
    },
    {
        "q": "What is `AuthServiceProvider` `boot` method used for?",
        "type": "mcq",
        "o": [
            "Registering Policies and Gates.",
            "Logging in user",
            "Redirecting",
            "Configuring DB"
        ]
    },
    {
        "q": "Can you use Gate inside a Policy?",
        "type": "mcq",
        "o": [
            "Yes, but be careful of circular logic. Usually Policy is the implementation OF a gate check for a model.",
            "No, conflict",
            "Only for admins",
            "Only in create"
        ]
    },
    {
        "q": "How to clear all sessions for a user?",
        "type": "mcq",
        "o": [
            "DB table manipulation (delete where user_id) or invalidate session store if using compatible driver.",
            "Auth::flush()",
            "Auth::clear()",
            "Session::clearAll()"
        ]
    },
    {
        "q": "What if `Auth::user()` returns null in a test?",
        "type": "mcq",
        "o": [
            "You probably forgot `$this->actingAs($user)`.",
            "Authentication is broken",
            "Database empty",
            "Route is public"
        ]
    },
    {
        "q": "Password Broker `sendResetLink` returns?",
        "type": "mcq",
        "o": [
            "A status string (e.g. `Password::RESET_LINK_SENT`).",
            "Boolean",
            "The token",
            "Response object"
        ]
    },
    {
        "q": "Customizing Password Validation Rules?",
        "type": "mcq",
        "o": [
            "Use `Password::defaults()` rule object customization in AppServiceProvider.",
            "Config auth.password_rules",
            "Cannot customize",
            "Regex only"
        ]
    },
    {
        "q": "Password Rule: `uncompromised()`?",
        "type": "mcq",
        "o": [
            "Checks if password has been leaked in data breaches (using HIBP API).",
            "Checks if strong",
            "Checks complexity",
            "Checks history"
        ]
    },
    {
        "q": "Password Rule: `mixedCase()`?",
        "type": "mcq",
        "o": [
            "Requires both uppercase and lowercase.",
            "Requires letters",
            "Requires special chars",
            "Requires numbers"
        ]
    },
    {
        "q": "Can you force logout a specific user by ID?",
        "type": "mcq",
        "o": [
            "Requires Session manipulation (finding session ID for user ID and deleting it). No direct Auth facade method for 'other' user.",
            "Auth::logout($id)",
            "Auth::kick($id)",
            "Auth::ban($id)"
        ]
    },
    {
        "q": "What is `Authenticatable` trait vs interface?",
        "type": "mcq",
        "o": [
            "Trait implements the methods defined in Interface (e.g. `getAuthIdentifierName`). Use both on User model (standard).",
            "Trait is deprecated",
            "Interface is deprecated",
            "Only use trait"
        ]
    },
    {
        "q": "What is `UserProvider::retrieveByToken`?",
        "type": "mcq",
        "o": [
            "Retrieves a user by their unique identifier and 'remember me' token.",
            "Retrieves by API token",
            "Retrieves by password reset token",
            "Retrieves by email token"
        ]
    },
    {
        "q": "What is `UserProvider::updateRememberToken`?",
        "type": "mcq",
        "o": [
            "Updates the 'remember me' token in storage for the given user.",
            "Updates session",
            "Updates password",
            "Updates email"
        ]
    },
    {
        "q": "What is `UserProvider::validateCredentials`?",
        "type": "mcq",
        "o": [
            "Compare given credentials against the user instance (hashing check).",
            "Check validation rules",
            "Check user exists",
            "Check user active"
        ]
    },
    {
        "q": "What is the Database User Provider?",
        "type": "mcq",
        "o": [
            "Uses `DB::table('users')` directly instead of Eloquent models.",
            "Uses MongoDB",
            "Uses Redis",
            "Uses XML"
        ]
    },
    {
        "q": "Can you switch default guard at runtime?",
        "type": "mcq",
        "o": [
            "Auth::shouldUse('api');",
            "Auth::setDefaultDriver('api');",
            "Config::set('auth.defaults.guard', 'api')",
            "All of the above"
        ]
    },
    {
        "q": "What is `Auth::check()` inside a `guest` middleware?",
        "type": "mcq",
        "o": [
            "Should be false.",
            "True",
            "Null",
            "Undefined"
        ]
    },
    {
        "q": "Middleware `auth.basic`?",
        "type": "mcq",
        "o": [
            "Enables HTTP Basic Auth for the route.",
            "Basic features only",
            "Simple auth",
            "Admin auth"
        ]
    },
    {
        "q": "Does HTTP Basic Auth use sessions?",
        "type": "mcq",
        "o": [
            "No, usually stateless (credentials sent every request), unless configured otherwise.",
            "Yes, creates cookies",
            "Yes, creates files",
            "Yes, creates tokens"
        ]
    },
    {
        "q": "What is `Auth::loginUsingId(1)` equivalent to?",
        "type": "mcq",
        "o": [
            "Finding user 1 and calling `Auth::login($user)`.",
            "Auth::attempt(['id' => 1])",
            "Auth::force(1)",
            "Auth::fake(1)"
        ]
    },
    {
        "q": "Does `loginUsingId` emit Login event?",
        "type": "mcq",
        "o": [
            "Yes.",
            "No",
            "Only if configured",
            "Only if remembered"
        ]
    },
    {
        "q": "Can you define policies for models in subfolders?",
        "type": "mcq",
        "o": [
            "Yes, Auto-discovery supports `Models/Sub` -> `Policies/SubPolicy` mapping.",
            "No, only root",
            "No, only App\\Models",
            "No, only flat structure"
        ]
    },
    {
        "q": "Policy `denyWithStatus`?",
        "type": "mcq",
        "o": [
            "Response::denyWithStatus(404); (Hides existence of resource).",
            "Deny 403",
            "Deny 500",
            "Deny 200"
        ]
    },
    {
        "q": "How to check if the user is a 'guest' inside Blade?",
        "type": "mcq",
        "o": [
            "@guest ... @endguest",
            "@if(!Auth::check())",
            "Both A and B",
            "@notauth"
        ]
    },
    {
        "q": "What is `Auth::userResolver()`?",
        "type": "mcq",
        "o": [
            "Get the callback used to resolve the user from the request.",
            "Resolve dependencies",
            "Resolve container",
            "Resolve session"
        ]
    },
    {
        "q": "Can you use different user models for different guards?",
        "type": "mcq",
        "o": [
            "Yes. `auth.php` defines providers, each provider sets a model class. Guard uses provider.",
            "No, only User model",
            "No, only Authenticatable",
            "Only with packages"
        ]
    },
    {
        "q": "What is `TwoFactorAuthenticatable`?",
        "type": "mcq",
        "o": [
            "Trait (often from Fortify) to handle 2FA secrets and recovery codes.",
            "Interface",
            "Middleware",
            "Event"
        ]
    },
    {
        "q": "What is `ConfirmPassword` middleware?",
        "type": "mcq",
        "o": [
            "Requires user to re-enter password if session timeout passed since last confirmation.",
            "Confirms email",
            "Confirms registration",
            "Confirms delete"
        ]
    },
    {
        "q": "Default password confirmation timeout?",
        "type": "mcq",
        "o": [
            "3 hours (config `auth.password_timeout`).",
            "1 hour",
            "10 mins",
            "24 hours"
        ]
    },
    {
        "q": "What is `VerifyEmail` Mailable?",
        "type": "mcq",
        "o": [
            "The built-in email notification class for verification.",
            "Controller",
            "Job",
            "Event"
        ]
    },
    {
        "q": "Customizing the verification URL?",
        "type": "mcq",
        "o": [
            "VerifyEmail::createUrlUsing($callback); in ServiceProvider.",
            "Edit routes",
            "Edit .env",
            "Edit config"
        ]
    },
    {
        "q": "How to manually check a password hash in a controller?",
        "type": "mcq",
        "o": [
            "Hash::check($input, $user->password)",
            "Auth::checkHash($input)",
            "User::checkPassword($input)",
            "Crypt::decrypt($input)"
        ]
    },
    {
        "q": "Is the `remember_token` column nullable?",
        "type": "mcq",
        "o": [
            "Yes (100 chars).",
            "No",
            "Default '0'",
            "Default 'null'"
        ]
    },
    {
        "q": "Is the `email_verified_at` column nullable?",
        "type": "mcq",
        "o": [
            "Yes (Timestamp). Null means unverified.",
            "No",
            "Default '0'",
            "Default today"
        ]
    },
    {
        "q": "Auth: `password.confirm` configuration?",
        "type": "mcq",
        "o": [
            "password_timeout in auth.php",
            "session.lifetime",
            "cache.ttl",
            "cookie.expire"
        ]
    },
    {
        "q": "What is `TokenGuard`?",
        "type": "mcq",
        "o": [
            "Implementation for `api_token` via database column (Legacy simple token auth).",
            "Sanctum guard",
            "Passport guard",
            "JWT guard"
        ]
    },
    {
        "q": "Does `TokenGuard` support scopes?",
        "type": "mcq",
        "o": [
            "No, usually simple string matching.",
            "Yes",
            "Yes, advanced",
            "Only read/write"
        ]
    },
    {
        "q": "Can you have multiple hashing drivers?",
        "type": "mcq",
        "o": [
            "Yes, `config/hashing.php`. Defaults to bcrypt.",
            "No",
            "Only one",
            "Only MD5"
        ]
    },
    {
        "q": "Argon2 vs Bcrypt?",
        "type": "mcq",
        "o": [
            "Argon2 is newer, memory-hard (resistant to GPU cracking). Bcrypt is classic standard.",
            "Argon2 is faster",
            "Bcrypt is insecure",
            "Same"
        ]
    },
    {
        "q": "Hashing rounds/memory cost config?",
        "type": "mcq",
        "o": [
            "Configured in `config/hashing.php`.",
            "Hardcoded",
            "In .env only",
            "In database"
        ]
    },
    {
        "q": "What is `Auth::provider('name', callback)`?",
        "type": "mcq",
        "o": [
            "Register a custom user provider creator.",
            "Register generic provider",
            "Register service provider",
            "Register login provider"
        ]
    },
    {
        "q": "What is `Auth::extend('driver', callback)`?",
        "type": "mcq",
        "o": [
            "Register a user-defined authentication Guard driver.",
            "Extend user model",
            "Extend token lifetime",
            "Extend session"
        ]
    },
    {
        "q": "If a user is logged in via 'web', are they logged in via 'api'?",
        "type": "mcq",
        "o": [
            "No, guards are separate. Unless you share session logic or sync them.",
            "Yes, always",
            "Yes, if same user",
            "Yes, if same browser"
        ]
    },
    {
        "q": "Sanctum: `abilities` column in database?",
        "type": "mcq",
        "o": [
            "Stores JSON array of allowed actions for that token.",
            "Stores string",
            "Stores encrypted blob",
            "Stores integer"
        ]
    },
    {
        "q": "Passport: `Client Credentials Grant`?",
        "type": "mcq",
        "o": [
            "Machine-to-machine authentication. No user involved. Returns access token for the client app.",
            "User login",
            "Admin login",
            "Guest access"
        ]
    },
    {
        "q": "Passport: `Implicit Grant`?",
        "type": "mcq",
        "o": [
            "Legacy flow for browser-based apps. Generally replaced by Auth Code with PKCE.",
            "Standard flow",
            "Secure flow",
            "Server flow"
        ]
    },
    {
        "q": "Passport: `Auth Code Grant`?",
        "type": "mcq",
        "o": [
            "Standard 3-legged OAuth flow. Redirect to auth server, get code, exchange for token.",
            "Simple login",
            "API key",
            "Basic auth"
        ]
    },
    {
        "q": "Passport: Refresh Tokens?",
        "type": "mcq",
        "o": [
            "Long-lived tokens used to obtain new short-lived access tokens without re-login.",
            "Reset password token",
            "Email token",
            "Not supported"
        ]
    },
    {
        "q": "Sanctum: Does it support refresh tokens?",
        "type": "mcq",
        "o": [
            "Not natively (it uses long-lived tokens). You revoke and re-issue if needed.",
            "Yes, built-in",
            "Yes, mandatory",
            "Yes, distinct table"
        ]
    },
    {
        "q": "How to check if user has 'admin' role in simple setup?",
        "type": "mcq",
        "o": [
            "If using a column: `$user->is_admin` or helper `$user->isAdmin()`. Or Gate/Policy.",
            "Auth::admin()",
            "User::admin()",
            "Check session"
        ]
    },
    {
        "q": "Is 'role' part of default Laravel User?",
        "type": "mcq",
        "o": [
            "No, you must add the column/relation and logic yourself (or use `spatie/laravel-permission`).",
            "Yes, `role_id`",
            "Yes, `type`",
            "Yes, `group`"
        ]
    },
    {
        "q": "Socialite: Handling missing email?",
        "type": "mcq",
        "o": [
            "Some providers don't return email (e.g. Twitter/X). Logic must handle nullable email or request extra scopes.",
            "Throws error",
            "Invents email",
            "Bans user"
        ]
    },
    {
        "q": "Socialite: `scopes(...)`?",
        "type": "mcq",
        "o": [
            "Socialite::driver('google')->scopes(['read:calendar'])->redirect(); Request extra permissions.",
            "Filters users",
            "Search users",
            "Limits login"
        ]
    },
    {
        "q": "Socialite: `with(...)`?",
        "type": "mcq",
        "o": [
            "Add optional parameters to the redirect request (e.g. `['prompt' => 'select_account']`).",
            "With user data",
            "With session",
            "With token"
        ]
    },
    {
        "q": "How to invalidate a password reset token manually?",
        "type": "mcq",
        "o": [
            "Delete the row from `password_resets` table.",
            "Auth::invalidateToken()",
            "Auth::clearReset()",
            "Cannot do it"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\Middleware\\Authenticate`?",
        "type": "mcq",
        "o": [
            "The class handling `auth` middleware logic (checking guard, redirecting if fail).",
            "Login form",
            "Register logic",
            "Route definition"
        ]
    },
    {
        "q": "Sanctum: `HasApiTokens` vs `Passport` trait?",
        "type": "mcq",
        "o": [
            "Sanctum uses `Laravel\\Sanctum\\HasApiTokens`. Passport uses `Laravel\\Passport\\HasApiTokens`. Do not mix them.",
            "Same trait",
            "Interchangeable",
            "Auto-detected"
        ]
    },
    {
        "q": "Passport: `Client` model customization?",
        "type": "mcq",
        "o": [
            "Extend `Laravel\\Passport\\Client` and configure via `Passport::useClientModel()` in AuthServiceProvider.",
            "Config auth.client",
            "Edit vendor",
            "Not allowed"
        ]
    },
    {
        "q": "Passport: Storing keys in `.env` instead of storage?",
        "type": "mcq",
        "o": [
            "Publish keys to environment variables passing file content? Actually `Passport::loadKeysFrom` or standard storage path. Can use env vars for keys content since v7.",
            "Not supported",
            "Only public key",
            "Only private key"
        ]
    },
    {
        "q": "Auth: Preventing 'Session Fixation'?",
        "type": "mcq",
        "o": [
            "Laravel automatically regenerates session ID on login (`migrateSession`).",
            "Manual check",
            "Disabled by default",
            "Requires middleware"
        ]
    },
    {
        "q": "How does `Auth::logout()` affect the 'Remember Me' cookie?",
        "type": "mcq",
        "o": [
            "It queues a cookie deletion (forget) and invalidates the remember token in DB.",
            "Deletes immediately",
            "Does nothing",
            "Sends email"
        ]
    },
    {
        "q": "Passport: Scopes middleware?",
        "type": "mcq",
        "o": [
            "`CheckScopes` and `CheckForAnyScope`. Registered as route middleware (often `scopes` and `scope`).",
            "auth:scope",
            "passport:scope",
            "oauth:scope"
        ]
    },
    {
        "q": "Protect route, requiring ONE of multiple scopes?",
        "type": "mcq",
        "o": [
            "middleware('scope:admin,editor')? No, standard `CheckScopes` requires ALL. `CheckForAnyScope` requires ANY.",
            "middleware('scopes:admin|editor')",
            "middleware('auth:admin,editor')",
            "Cannot do it"
        ]
    },
    {
        "q": "Sanctum: Token expiration vs Revocation?",
        "type": "mcq",
        "o": [
            "Expiration is time-based (if configured). Revocation is manual deletion from DB.",
            "Same thing",
            "Expiration deletes row",
            "Revocation hides row"
        ]
    },
    {
        "q": "Customizing the 'users' table name for Auth?",
        "type": "mcq",
        "o": [
            "In User model `protected $table = 'members'`. Auth provider config just points to model.",
            "In auth.php",
            "In session.php",
            "In .env"
        ]
    },
    {
        "q": "Using a non-incrementing ID (UUID) for User?",
        "type": "mcq",
        "o": [
            "Ensure Model uses `HasUuids` (Laravel 9+) and `$incrementing = false`, `$keyType = 'string'`. Auth flows respect this.",
            "Not supported",
            "Requires plugin",
            "Auth works only with int"
        ]
    },
    {
        "q": "How to handle Multi-Auth (Admin + User) tables?",
        "type": "mcq",
        "o": [
            "Define two guards ('admin', 'web') and two providers ('admins', 'users') in `auth.php` pointing to different models.",
            "Use one table with type column",
            "Use two apps",
            "Use JWT only"
        ]
    },
    {
        "q": "Admin guard login?",
        "type": "mcq",
        "o": [
            "Auth::guard('admin')->attempt($credentials)",
            "Auth::attemptAdmin($credentials)",
            "Admin::login($credentials)",
            "Auth::login($credentials, 'admin')"
        ]
    },
    {
        "q": "Protecting Admin routes?",
        "type": "mcq",
        "o": [
            "Route::middleware('auth:admin')",
            "Route::middleware('admin')",
            "Route::auth('admin')",
            "Route::guard('admin')"
        ]
    },
    {
        "q": "Can a user be logged in to multiple guards simultaneously?",
        "type": "mcq",
        "o": [
            "Yes, sessions are separate (different session keys/cookies usually handled by Framework or same session store with different keys).",
            "No",
            "Only if same table",
            "Only via API"
        ]
    },
    {
        "q": "Middleware `auth:web,admin` meaning?",
        "type": "mcq",
        "o": [
            "Allows access if authenticated via 'web' OR 'admin' guard.",
            "Requires BOTH",
            "Requires Web then Admin",
            "Invalid syntax"
        ]
    },
    {
        "q": "How `Authenticate` middleware determines partial login?",
        "type": "mcq",
        "o": [
            "It iterates through guards passed arguments. First one that checks true sets the default user for that request context.",
            "Checks all",
            "Checks random",
            "Checks last"
        ]
    },
    {
        "q": "Socialite: Stateless with session?",
        "type": "mcq",
        "o": [
            "Oxymoron. Stateless (`stateless()`) specifically disables session state verification (CSRF state param check). Used for APIs.",
            "Valid",
            "Recommended",
            "Mandatory"
        ]
    },
    {
        "q": "Auth: `viaRequest` driver return value?",
        "type": "mcq",
        "o": [
            "Must return the User instance or null.",
            "Boolean",
            "ID",
            "Token"
        ]
    },
    {
        "q": "Custom Password Reset Logic?",
        "type": "mcq",
        "o": [
            "Implement `CanResetPassword` contract manually or override trait methods `sendPasswordResetNotification`.",
            "Edit core",
            "Not possible",
            "Only verify"
        ]
    },
    {
        "q": "What is `Auth::shouldUse('guard')`?",
        "type": "mcq",
        "o": [
            "Sets the default guard for the duration of the request. Useful in middleware.",
            "Permanent config change",
            "Database change",
            "Session change"
        ]
    },
    {
        "q": "Sanctum: `personal_access_tokens` table `last_used_at`?",
        "type": "mcq",
        "o": [
            "Updated when token is used. Useful for pruning old tokens.",
            "Never updated",
            "Updated on create",
            "Updated on revoke"
        ]
    },
    {
        "q": "Does updating `last_used_at` cause DB write every request?",
        "type": "mcq",
        "o": [
            "Yes, if using Sanctum middleware. Can be performance hit on high traffic. (Can be customized/throttled in later versions or custom middleware).",
            "No, only in cache",
            "No, only in memory",
            "No, never"
        ]
    },
    {
        "q": "Auth: Impersonation implementation?",
        "type": "mcq",
        "o": [
            "Login as other user `Auth::login($otherUser)`. Store original ID in session to allow 'switch back'.",
            "Auth::impersonate($otherUser)",
            "Auth::fake($otherUser)",
            "User::act($otherUser)"
        ]
    },
    {
        "q": "What is `User::withoutEvents(fn() => ...)`?",
        "type": "mcq",
        "o": [
            "Executes callback without firing model events (creating, saving). Useful for seeders/tests to avoid side effects like emails.",
            "Disables Auth",
            "Disables Validation",
            "Disables DB"
        ]
    },
    {
        "q": "Laravel Breeze: 'Next.js' stack?",
        "type": "mcq",
        "o": [
            "Provides an API-only backend (Laravel) and a Next.js frontend application (separate repo/folder).",
            "Blade implementation",
            "Vue implementation",
            "Livewire implementation"
        ]
    },
    {
        "q": "Jetstream: Teams feature?",
        "type": "mcq",
        "o": [
            "Allows users to create and manage teams, invite members, assign roles. Uses `Team` model.",
            "Chat feature",
            "Project management",
            "Billing"
        ]
    },
    {
        "q": "Jetstream: Two Factor Auth storage?",
        "type": "mcq",
        "o": [
            "Columns in `users` table: `two_factor_secret`, `two_factor_recovery_codes`, `two_factor_confirmed_at`.",
            "Separate table",
            "Redis",
            "File"
        ]
    },
    {
        "q": "Fortify: Route definition?",
        "type": "mcq",
        "o": [
            "Routes are defined in `vendor/...`. You can disable them in `config/fortify.php` (`features` array).",
            "web.php",
            "api.php",
            "routes.php"
        ]
    },
    {
        "q": "Fortify: Customizing Login logic?",
        "type": "mcq",
        "o": [
            "Fortify::authenticateUsing(function ($request) { ... });",
            "Override controller",
            "Edit middleware",
            "Event listener"
        ]
    },
    {
        "q": "Bcrypt supports custom cost per hash?",
        "type": "mcq",
        "o": [
            "Yes, `Hash::make('password', ['rounds' => 12])`.",
            "No, global only",
            "No, fixed 10",
            "No, fixed 12"
        ]
    },
    {
        "q": "Can you use `Auth::id()` inside a queued Job?",
        "type": "mcq",
        "o": [
            "No, Auth state is not persisted to queue. Pass the `User` model or ID to the Job constructor.",
            "Yes, it works",
            "Yes, via session",
            "Yes, via cookie"
        ]
    },
    {
        "q": "Auth: `Boot` method in `AuthServiceProvider` missing?",
        "type": "mcq",
        "o": [
            "If it's empty, you might not be registering policies manually (auto-discovery). But `registerPolicies()` call is standard boilerplate.",
            "Breaking error",
            "Auth disabled",
            "Policies disabled"
        ]
    },
    {
        "q": "How to cache policy checks?",
        "type": "mcq",
        "o": [
            "They are not cached by default. Use `Cache` facade inside Policy or Gate if calculation is heavy.",
            "Auto cached",
            "Config auth.cache",
            "Middleware cache"
        ]
    },
    {
        "q": "Difference between `Gate::allows` and `context()->can`?",
        "type": "mcq",
        "o": [
            "Context (`$user->can`) delegates to Gate. Same result.",
            "Different checks",
            "Context is faster",
            "Gate is faster"
        ]
    },
    {
        "q": "If `Gate::before` allows, does policy run?",
        "type": "mcq",
        "o": [
            "No, `before` granting access shortcuts the check.",
            "Yes",
            "Maybe",
            "Only denies"
        ]
    },
    {
        "q": "Using `Authorize` middleware in constructor of API controller?",
        "type": "mcq",
        "o": [
            "Common practice. `$this->authorize('view', $post)` inside methods or `$this->middleware('can:view,post')`.",
            "Forbidden",
            "Deprecated",
            "Slower"
        ]
    },
    {
        "q": "What is `Password::min(8)->letters()->numbers()`?",
        "type": "mcq",
        "o": [
            "Fluent Password Verification Rule object (Laravel 8+).",
            "Generator",
            "Hasher",
            "Validator"
        ]
    },
    {
        "q": "Using `Password` rule object in validation?",
        "type": "mcq",
        "o": [
            "`'password' => ['required', Password::defaults()]`.",
            "`'password' => 'rule'`",
            "`'password' => 'secure'`",
            "`'password' => 'strong'`"
        ]
    },
    {
        "q": "Auth: `Broadcasting` private channels?",
        "type": "mcq",
        "o": [
            "Requires auth. Check `channels.php` `Broadcast::channel(...)`.",
            "Open by default",
            "Only admins",
            "Only public"
        ]
    },
    {
        "q": "Broadcast channel authorization callback?",
        "type": "mcq",
        "o": [
            "Returns boolean (authorized) or user array (for presence channels). `function ($user, $id) { return $user->id === $id; }`.",
            "Returns response",
            "Returns view",
            "Returns redirect"
        ]
    },
    {
        "q": "What is `Sanctum::actingAs($user)` in tests?",
        "type": "mcq",
        "o": [
            "Authenticates the user for the test request using Sanctum logic (abilities etc).",
            "Same as `actingAs`",
            "Only for Passport",
            "Only for Session"
        ]
    },
    {
        "q": "Does `Sanctum::actingAs` set session?",
        "type": "mcq",
        "o": [
            "No, it sets up the `guard` for API token emulation.",
            "Yes",
            "Yes, encrypted",
            "Yes, persistent"
        ]
    },
    {
        "q": "Can you use Gate for frontend UI visibility?",
        "type": "mcq",
        "o": [
            "Yes, standard use case (`@can`). If using JS framework, you often pass permissions as JSON to frontend.",
            "No, backend only",
            "Only Blade",
            "Only API"
        ]
    },
    {
        "q": "Exposing permissions to Inertia/Vue?",
        "type": "mcq",
        "o": [
            "Handle (middleware) -> Share `auth.user.permissions` or `can` object in Inertia shared data.",
            "Exposed automatically",
            "Via API call only",
            "Not possible"
        ]
    },
    {
        "q": "Rate Limiting by User ID vs IP?",
        "type": "mcq",
        "o": [
            "RateLimiter::for('api', function (Request $request) { return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip()); });",
            "Config option",
            "Auto sensing",
            "Can't choose"
        ]
    },
    {
        "q": "Auth: `Attempt` event payload?",
        "type": "mcq",
        "o": [
            "Contains `credentials`, `remember`, `guard`.",
            "User object",
            "Success boolean",
            "Token"
        ]
    },
    {
        "q": "Can you salt passwords manually in Laravel?",
        "type": "mcq",
        "o": [
            "Bcrypt/Argon2 handle salting internally. You don't manage salts manually.",
            "Yes, required",
            "Yes, recommended",
            "No, insecure"
        ]
    },
    {
        "q": "What is `CreatesUserProviders` trait?",
        "type": "mcq",
        "o": [
            "Internal trait in AuthManager responsible for building provider instances.",
            "Factory for users",
            "Seeder for users",
            "Testing trait"
        ]
    },
    {
        "q": "Where to define `HOME` constant?",
        "type": "mcq",
        "o": [
            "RouteServiceProvider typically. `public const HOME = '/dashboard';`.",
            "AuthServiceProvider",
            "User model",
            "Config"
        ]
    },
    {
        "q": "If `Auth::check()` is true, is `Auth::user()` guaranteed non-null?",
        "type": "mcq",
        "o": [
            "Yes.",
            "No",
            "Maybe",
            "Depends on driver"
        ]
    },
    {
        "q": "What does `Auth::guard()` with no args do?",
        "type": "mcq",
        "o": [
            "Returns the default guard (usually `web`).",
            "Returns all guards",
            "Returns api guard",
            "Returns null"
        ]
    },
    {
        "q": "Auth: `recaller` cookie security?",
        "type": "mcq",
        "o": [
            "It holds the 'remember token'. If stolen, anyone can login. It should be HttpOnly and Encrypted (Laravel default).",
            "Not important",
            "Holds password",
            "Holds session"
        ]
    },
    {
        "q": "How to invalidate `remember_token` on all devices?",
        "type": "mcq",
        "o": [
            "Cycle the `remember_token` column in DB (set to new random string).",
            "Auth::logout()",
            "Clear cookies",
            "Cannot do it"
        ]
    },
    {
        "q": "Passport: `CreateFreshApiToken` middleware?",
        "type": "mcq",
        "o": [
            "Attaches a `laravel_token` cookie to outgoing responses, allowing the JS frontend to consume API with that token. (Cookie based auth for Passport).",
            "Creates new user",
            "Refreshes page",
            "Clears cache"
        ]
    },
    {
        "q": "Customizing the `User` model retrieval in `EloquentUserProvider`?",
        "type": "mcq",
        "o": [
            "Extend `EloquentUserProvider` and override `retrieveByCredentials`. Bind new provider in AuthServiceProvider.",
            "Edit model",
            "Edit controller",
            "Edit view"
        ]
    },
    {
        "q": "What is `Auth::extend` actually doing internally?",
        "type": "mcq",
        "o": [
            "Registers a custom driver creator closure in the `AuthManager`. When `guard` config uses that driver, the closure is called.",
            "Extends class",
            "Extends interface",
            "Extends trait"
        ]
    },
    {
        "q": "Auth: `Attempting` event?",
        "type": "mcq",
        "o": [
            "Fired before authentication check begins. Allows listener to modify credentials or log attempt.",
            "Fired after success",
            "Fired after fail",
            "Fired on logout"
        ]
    },
    {
        "q": "Auth: `Validated` event?",
        "type": "mcq",
        "o": [
            "Fired after credentials are verified but BEFORE login (session) occurs. Useful for '2FA' checks or 'Banned' checks.",
            "Fired on logout",
            "Fired on fail",
            "Fired on register"
        ]
    },
    {
        "q": "Auth: `OtherDeviceLogout` event?",
        "type": "mcq",
        "o": [
            "Fired when `logoutOtherDevices` is called?",
            "Fired on single logout",
            "Fired on time out",
            "Fired on error"
        ]
    },
    {
        "q": "Sanctum: Customizing the `PersonalAccessToken` model?",
        "type": "mcq",
        "o": [
            "Sanctum::usePersonalAccessTokenModel(Custom::class). Must extend default or implement contract.",
            "Config sanctum.php",
            "Not allowed",
            "Edit vendor"
        ]
    },
    {
        "q": "What if you need different expiration for different token types in Sanctum?",
        "type": "mcq",
        "o": [
            "Default config is global. You must override `createToken` logic or use a scheduled job to prune based on token abilities/name meta.",
            "Config supports array",
            "Config supports map",
            "Not possible"
        ]
    },
    {
        "q": "Can you use different user tables for Sanctum?",
        "type": "mcq",
        "o": [
            "Yes. The `tokenable` relationship is polymorphic (`tokenable_type`, `tokenable_id`). Works with any model using `HasApiTokens`.",
            "No, only users",
            "No, only admins",
            "No, hardcoded"
        ]
    },
    {
        "q": "Passport: Pruning tokens command frequency?",
        "type": "mcq",
        "o": [
            "Recommended to run `passport:purge` via Scheduler (daily/hourly).",
            "Every request",
            "Manually only",
            "Never"
        ]
    },
    {
        "q": "Spatie Permission: `givePermissionTo`?",
        "type": "mcq",
        "o": [
            "$user->givePermissionTo('edit articles').",
            "$user->allow('edit articles')",
            "$user->can('edit articles')",
            "$user->permit('edit articles')"
        ]
    },
    {
        "q": "Spatie Permission: `assignRole`?",
        "type": "mcq",
        "o": [
            "$user->assignRole('writer').",
            "$user->role('writer')",
            "$user->setRole('writer')",
            "$user->make('writer')"
        ]
    },
    {
        "q": "Spatie Permission: `syncRoles`?",
        "type": "mcq",
        "o": [
            "Replaces all current roles with given roles. `$user->syncRoles(['writer', 'editor'])`.",
            "Adds roles",
            "Removes roles",
            "Lists roles"
        ]
    },
    {
        "q": "Sanctum: Disabling migration?",
        "type": "mcq",
        "o": [
            "Sanctum::ignoreMigrations() in AppServiceProvider `register`.",
            "Config sanctum.migrations",
            "Delete migration file",
            "Not supported"
        ]
    },
    {
        "q": "How to unit test a Policy?",
        "type": "mcq",
        "o": [
            "Instantiate Policy class and call methods directly with User/Model mocks.",
            "Use Auth facade",
            "Use Route",
            "Use Controller"
        ]
    },
    {
        "q": "Policy: Handling `null` user (Guests)?",
        "type": "mcq",
        "o": [
            "Argument must be nullable `?User $user` and method returns true/false. Standard `Gate` returns false for guests automatically if not nullable.",
            "Always allowed",
            "Always denied",
            "Exception"
        ]
    },
    {
        "q": "Can you use Gate inside a Blade component constructor?",
        "type": "mcq",
        "o": [
            "Yes, if you need to filter data before rendering view.",
            "No",
            "Only in render",
            "Only in blade file"
        ]
    },
    {
        "q": "What is `Guard::user()` vs `Guard::combine()`?",
        "type": "mcq",
        "o": [
            "Legacy terms. Modern guards just implement `Guard` or `StatefulGuard` interface.",
            "Important",
            "Related to JWT",
            "Related to Session"
        ]
    },
    {
        "q": "Implementing `StatefulGuard` interface?",
        "type": "mcq",
        "o": [
            "Required if you want the guard to support maintaining state (sessions/cookies). Interface methods: `attempt`, `once`, `login`, `loginUsingId`, etc.",
            "For API only",
            "For Tokens only",
            "For Stateless only"
        ]
    },
    {
        "q": "What is `Auth::createEloquentProvider`?",
        "type": "mcq",
        "o": [
            "Internal method in AuthManager to create default Eloquent provider.",
            "Public helper",
            "Factory",
            "Seeder"
        ]
    },
    {
        "q": "Sanctum: Current Access Token access?",
        "type": "mcq",
        "o": [
            "$user->currentAccessToken(). returns the `PersonalAccessToken` model.",
            "$user->token()",
            "$user->accessToken",
            "$user->getCurrent()"
        ]
    },
    {
        "q": "Deleting ONLY current token (Logout one device)?",
        "type": "mcq",
        "o": [
            "$user->currentAccessToken()->delete();",
            "$user->logout()",
            "$user->tokens()->delete()",
            "Auth::logout()"
        ]
    },
    {
        "q": "Can you use Auth Gates for API Rate Limiting?",
        "type": "mcq",
        "o": [
            "Technically yes, but RateLimiter is preferred. Gates return authorization, not 429.",
            "Yes, standard",
            "No",
            "Only for admins"
        ]
    },
    {
        "q": "What is `Auth::basic('email')`?",
        "type": "mcq",
        "o": [
            "Uses 'email' column for basic auth username.",
            "Sends email",
            "Validates email",
            "Resets email"
        ]
    },
    {
        "q": "Stateless Basic Auth?",
        "type": "mcq",
        "o": [
            "Auth::onceBasic(). Checks credentials, does NOT set cookie.",
            "Auth::basic()",
            "Auth::stateless()",
            "Auth::api()"
        ]
    },
    {
        "q": "Where does `Auth::guest()` check?",
        "type": "mcq",
        "o": [
            "Inverse of `check()`. Checks current guard.",
            "Checks session only",
            "Checks cookie only",
            "Checks DB"
        ]
    },
    {
        "q": "Customizing the 'password' validation message?",
        "type": "mcq",
        "o": [
            "In `validation.php` language file.",
            "In auth.php",
            "In Controller",
            "In Model"
        ]
    },
    {
        "q": "Password Reset: `ResetPassword` notification class?",
        "type": "mcq",
        "o": [
            "The class sent by PasswordBroker. Can be overridden in User model.",
            "Built-in unchangeable",
            "Deprecated",
            "Removed"
        ]
    },
    {
        "q": "Auth: `Pipeline` usage?",
        "type": "mcq",
        "o": [
            "Login logic often routed through pipeline (Fortify especially) to handle 2FA, validation, etc.",
            "Not used",
            "For rendering",
            "For database"
        ]
    },
    {
        "q": "Can you share session between subdomains?",
        "type": "mcq",
        "o": [
            "Yes, set `domain` in `config/session.php` to `.example.com`.",
            "No",
            "Only specific drivers",
            "Only https"
        ]
    },
    {
        "q": "What is `SameSite` cookie attribute impact on Auth?",
        "type": "mcq",
        "o": [
            "Affects cross-site requests (e.g. iframe login, external redirect). 'Lax' is default. 'None' requires Secure.",
            "No impact",
            "Increases speed",
            "Decreases speed"
        ]
    },
    {
        "q": "Auth: `Hash::info($hash)`?",
        "type": "mcq",
        "o": [
            "Returns array describing the hash (algo, options).",
            "Returns password",
            "Returns salt",
            "Returns user"
        ]
    },
    {
        "q": "What happens if encryption key rotates?",
        "type": "mcq",
        "o": [
            "Sessions/Cookies encrypted with old key become invalid (User logged out). Encrypted DB fields unreadable.",
            "Nothing",
            "Auto re-encrypt",
            "Fatal error"
        ]
    },
    {
        "q": "Auth: `Lockout` event?",
        "type": "mcq",
        "o": [
            "Fired when user hits throttle limit.",
            "Fired on ban",
            "Fired on logout",
            "Fired on reset"
        ]
    },
    {
        "q": "Is it safe to store Auth User in a public property of Livewire component?",
        "type": "mcq",
        "o": [
            "No! Whole model is serialized to frontend. Can leak sensitive data. Use ID or computed property.",
            "Yes, convenient",
            "Yes, encrypted",
            "Yes, if guarded"
        ]
    },
    {
        "q": "Does `Auth::login($user)` regenerate session ID?",
        "type": "mcq",
        "o": [
            "Yes, `login` method calls `cycleRememberToken` and `session->migrate(true)`.",
            "No",
            "Only attempt",
            "Only once"
        ]
    },
    {
        "q": "Can you manually set the current user for 'api' guard?",
        "type": "mcq",
        "o": [
            "Auth::guard('api')->setUser($user).",
            "Auth::setUser($user)",
            "Auth::apiUser($user)",
            "User::current($user)"
        ]
    },
    {
        "q": "Sanctum: Token name importance?",
        "type": "mcq",
        "o": [
            "Mainly for UI/User reference (e.g. 'iPad', 'Chrome'). Can be used to revoke specific token.",
            "Security critical",
            "Unused",
            "Unique index"
        ]
    },
    {
        "q": "Passport: `checkClientCredentials` middleware?",
        "type": "mcq",
        "o": [
            "Validates if the incoming request has a valid client credential token. (Machine-to-machine).",
            "Validates user",
            "Validates session",
            "Validates API key"
        ]
    },
    {
        "q": "Passport: Is it compatible with Sanctum?",
        "type": "mcq",
        "o": [
            "Technically yes, can exist in same app, but confusing. Each guard handles its own routes.",
            "No, conflict",
            "Yes, automatic",
            "Yes, shared tables"
        ]
    },
    {
        "q": "How to get all active sessions for a user (Database driver)?",
        "type": "mcq",
        "o": [
            "Query `sessions` table where `user_id` matches. (Requires adding user_id to session via middleware/hook).",
            "Auth::sessions()",
            "User::sessions()",
            "Session::all()"
        ]
    },
    {
        "q": "Auth: `User::boot()` usage?",
        "type": "mcq",
        "o": [
            "To register model events like `creating` (e.g. generating UUID, hashing password if not using mutator).",
            "To login",
            "To logout",
            "To register"
        ]
    },
    {
        "q": "What is `hashed` cast in Eloquent?",
        "type": "mcq",
        "o": [
            "Automatically hashes the value on set. `$casts = ['password' => 'hashed']`. Laravel 10+.",
            "Decrypts on get",
            "Encrypts on set",
            "Validates hash"
        ]
    },
    {
        "q": "Does `hashed` cast prevent double hashing?",
        "type": "mcq",
        "o": [
            "Yes, it checks if value is already a hash info structure (or looks like hash).",
            "No",
            "Only if 'strict'",
            "Only if 'safe'"
        ]
    },
    {
        "q": "Can you make a user Admin directly in database?",
        "type": "mcq",
        "o": [
            "Yes, if logic is based on column/role. Auth framework just reads the model.",
            "No, must use UI",
            "No, must use API",
            "No, must use Command"
        ]
    },
    {
        "q": "Gate definition: `User` argument optional?",
        "type": "mcq",
        "o": [
            "Yes, define `?User $user` to create a gate that runs for guests.",
            "No",
            "Only policies",
            "Only middleware"
        ]
    },
    {
        "q": "What is `config('auth.defaults.passwords')`?",
        "type": "mcq",
        "o": [
            "Defines the default password broker (usually 'users').",
            "Defines the default password",
            "Defines the default hasher",
            "Defines the default salt"
        ]
    },
    {
        "q": "Where is the `users` provider defined?",
        "type": "mcq",
        "o": [
            "config/auth.php -> providers -> users.",
            "config/app.php",
            "config/database.php",
            "config/session.php"
        ]
    },
    {
        "q": "What is the `driver` for the `users` provider typically?",
        "type": "mcq",
        "o": [
            "eloquent",
            "database",
            "array",
            "json"
        ]
    },
    {
        "q": "Can you use different models for the same provider?",
        "type": "mcq",
        "o": [
            "No, one model per provider configuration. You'd need multiple providers for multiple models.",
            "Yes, comma separated",
            "Yes, array",
            "Yes, wildcard"
        ]
    },
    {
        "q": "Auth: `viaRequest` hook?",
        "type": "mcq",
        "o": [
            "Used to define how `Auth::guard('custom')` retrieves user from request. `Auth::viaRequest('driver', fn($request) => ...)`.",
            "Used to login",
            "Used to logout",
            "Used to redirect"
        ]
    },
    {
        "q": "Is the `password_resets` table required?",
        "type": "mcq",
        "o": [
            "Only if using the default DatabaseTokenRepository. You can implement custom repository.",
            "Yes, always",
            "No, never",
            "Only for admins"
        ]
    },
    {
        "q": "What is `Auth::shouldUse()` useful for?",
        "type": "mcq",
        "o": [
            "Testing or swapping authentication context dynamically (e.g. impersonation or specific admin actions).",
            "Nothing",
            "Database config",
            "Routing"
        ]
    },
    {
        "q": "Can `Auth::login()` take a boolean for remember?",
        "type": "mcq",
        "o": [
            "Yes. `Auth::login($user, $remember = true)`.",
            "No, use `loginRemember`",
            "No, distinct method",
            "No, in array"
        ]
    },
    {
        "q": "Does `Auth::user()` hit the database every call?",
        "type": "mcq",
        "o": [
            "No, the `Guard` instance (singleton in container) caches the user object in memory for the request duration once retrieved.",
            "Yes, always",
            "Yes, unless cached manually",
            "No, only first time"
        ]
    },
    {
        "q": "If you update the user in DB, does `Auth::user()` reflect it immediately in same request?",
        "type": "mcq",
        "o": [
            "No, because it's cached in memory. Use `Auth::setUser($freshUser)` or refresh the model.",
            "Yes, always",
            "Yes, magic",
            "Only if saved"
        ]
    },
    {
        "q": "Auth: `setUser()` method?",
        "type": "mcq",
        "o": [
            "Manually set the current authenticated user in the Guard instance.",
            "Saves user to DB",
            "Creates user",
            "Logs out"
        ]
    },
    {
        "q": "What is `Auth::guard('web')->logout()`?",
        "type": "mcq",
        "o": [
            "Logs out specifically from the web guard session.",
            "Logs out api",
            "Logs out all",
            "Deletes user"
        ]
    },
    {
        "q": "Does `Auth::logout` destroy the session?",
        "type": "mcq",
        "o": [
            "It calls `session()->invalidate()` usually (in LoginController implementation), but strictly `Guard::logout()` just clears user/cookie info from session.",
            "Destroys DB",
            "Destroys file",
            "Destroys application"
        ]
    },
    {
        "q": "Sanctum: `CreateFreshApiToken` cookie name?",
        "type": "mcq",
        "o": [
            "laravel_token (encrypted JWT-like payload).",
            "sanctum_token",
            "api_token",
            "auth_token"
        ]
    },
    {
        "q": "Sanctum: Does it work with GraphQL?",
        "type": "mcq",
        "o": [
            "Yes, it's just authentication middleware. Use `auth:sanctum` on graphql endpoint.",
            "No, REST only",
            "No, RPC only",
            "No, Blade only"
        ]
    },
    {
        "q": "Can you define `gate` abilities in database?",
        "type": "mcq",
        "o": [
            "Yes, typically load them in `AuthServiceProvider` boot (loop DB records -> Gate::define).",
            "No, hardcoded only",
            "No, config only",
            "No, file only"
        ]
    },
    {
        "q": "Performance of DB-based Gates?",
        "type": "mcq",
        "o": [
            "Can be slow if querying permissions every request. Cache them!",
            "Fastest",
            "Zero overhead",
            "Instant"
        ]
    },
    {
        "q": "What is `Gate::guessPolicyNamesUsing`?",
        "type": "mcq",
        "o": [
            "Customize the logic for finding a policy class for a given model class.",
            "Guess passwords",
            "Guess usernames",
            "Guess routes"
        ]
    },
    {
        "q": "Default policy guess logic?",
        "type": "mcq",
        "o": [
            "App\\Models\\Post -> App\\Policies\\PostPolicy.",
            "Post -> PostAuth",
            "Post -> PolicyPost",
            "Post -> AuthPost"
        ]
    },
    {
        "q": "Sanctum: `HasApiTokens` on separate model?",
        "type": "mcq",
        "o": [
            "Yes, e.g. `Admin` model. `Admin` can issue tokens too.",
            "No, only User",
            "No, only one model",
            "No, only one table"
        ]
    },
    {
        "q": "Passport: `Client` UUIDs?",
        "type": "mcq",
        "o": [
            "Passport supports UUIDs for client IDs. Must configure usage.",
            "Not supported",
            "Only int",
            "Only string"
        ]
    },
    {
        "q": "Passport: Hashing client secrets?",
        "type": "mcq",
        "o": [
            "Supported (and recommended) to store client secrets hashed in DB.",
            "Not supported",
            "Mandatory since v1",
            "Impossible"
        ]
    },
    {
        "q": "How to command Passport to hash keys?",
        "type": "mcq",
        "o": [
            "Passport::hashClientSecrets(); in AppServiceProvider.",
            "Config option",
            "Env var",
            "Middleware"
        ]
    },
    {
        "q": "What is `Auth::check()` in a closure route without middleware?",
        "type": "mcq",
        "o": [
            "It might work if the `StartSession` and `EncryptCookies` middleware ran (global stack). Defaults to false if no session started.",
            "Always works",
            "Throws error",
            "Returns null"
        ]
    },
    {
        "q": "Can you use `Auth` in `AppServiceProvider`?",
        "type": "mcq",
        "o": [
            "In `boot` yes. Be careful, session might not be started yet for `user()`. Usually used for defining Gates.",
            "In register yes",
            "No",
            "Only in Controllers"
        ]
    },
    {
        "q": "Auth: `forUser($user)` on Guard?",
        "type": "mcq",
        "o": [
            "Some guards allow switching context. `Auth::guard('web')->forUser($user)` (sets user without login/session?).",
            "Login as user",
            "Logout user",
            "Delete user"
        ]
    },
    {
        "q": "What is `Auth::onceUsingId($id)` return value?",
        "type": "mcq",
        "o": [
            "Boolean (success) or User? Actually returns false if failed, or logs in and returns true?",
            "The user",
            "The id",
            "The token"
        ]
    },
    {
        "q": "Does `onceUsingId` set cookies?",
        "type": "mcq",
        "o": [
            "No. Stateless login for that request.",
            "Yes",
            "Only session",
            "Only flash"
        ]
    },
    {
        "q": "Can you mock Auth in tests?",
        "type": "mcq",
        "o": [
            "Yes, `Auth::shouldReceive(...)`. But `actingAs` is preferred for integration tests.",
            "No",
            "Only via database",
            "Only via http"
        ]
    },
    {
        "q": "Can `actingAs` specify driver?",
        "type": "mcq",
        "o": [
            "Yes, `$this->actingAs($user, 'api')`.",
            "No",
            "Auto detected",
            "Only web"
        ]
    },
    {
        "q": "What is `UserProvider` contract namespace?",
        "type": "mcq",
        "o": [
            "Illuminate\\Contracts\\Auth\\UserProvider",
            "App\\Contracts\\UserProvider",
            "Illuminate\\Auth\\UserProvider",
            "Illuminate\\Database\\UserProvider"
        ]
    },
    {
        "q": "What is `Authenticatable` contract namespace?",
        "type": "mcq",
        "o": [
            "Illuminate\\Contracts\\Auth\\Authenticatable",
            "App\\User",
            "Illuminate\\Auth\\Authenticatable",
            "Illuminate\\Database\\Authenticatable"
        ]
    },
    {
        "q": "Can you define `getAuthPassword` to return 'email'?",
        "type": "mcq",
        "o": [
            "Technically yes, but authentication will fail because it expects a hash to compare against input password.",
            "Yes, works magic",
            "No, type error",
            "No, SQL error"
        ]
    },
    {
        "q": "What is `Auth::guard('web')->check()` equivalent to?",
        "type": "mcq",
        "o": [
            "Auth::check() (if default is web).",
            "Auth::guest()",
            "Auth::user()",
            "Auth::id()"
        ]
    },
    {
        "q": "Can you access `Auth::user()` in model boot?",
        "type": "mcq",
        "o": [
            "Yes, usually. Useful for `creating` events (setting `user_id`). Ensure checking for null (console commands/seeders have no user).",
            "No",
            "Only if admin",
            "Only if queued"
        ]
    },
    {
        "q": "What if `Auth::user()` is called in `config` files?",
        "type": "mcq",
        "o": [
            "It will return null or throw error. Config is loaded BEFORE session/auth middleware.",
            "Works fine",
            "Returns admin",
            "Returns guest"
        ]
    },
    {
        "q": "How to restrict access by IP address using Auth?",
        "type": "mcq",
        "o": [
            "Not Auth's responsibility. Use Middleware (e.g. `blockIP`) or Web Server config.",
            "Auth::block($ip)",
            "User::block($ip)",
            "Guard::block($ip)"
        ]
    },
    {
        "q": "Auth: `password_confirmed_at` session key?",
        "type": "mcq",
        "o": [
            "Stores timestamp of last password confirmation.",
            "Stores password",
            "Stores boolean",
            "Stores hash"
        ]
    },
    {
        "q": "Can `Sanctum` issue tokens for guests?",
        "type": "mcq",
        "o": [
            "Yes, if you implement a 'Guest User' model or attach tokens to something else. But typically tied to Authenticatable.",
            "No",
            "Yes, always",
            "Yes, anonymous"
        ]
    },
    {
        "q": "Passport: `HasApiTokens` trait defines `clients()`?",
        "type": "mcq",
        "o": [
            "Yes, relation to OAuth clients created by user.",
            "No",
            "Defines `tokens` only",
            "Defines `scopes` only"
        ]
    },
    {
        "q": "Does `Auth::routes` support 'register' => false?",
        "type": "mcq",
        "o": [
            "Yes.",
            "No",
            "Only 'login'",
            "Only 'reset'"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\GuardHelpers` trait?",
        "type": "mcq",
        "o": [
            "Trait containing common guard methods (`authenticate`, `hasUser`, `check`, `id`, `setUser`) to reduce boilerplate in custom guards.",
            "Helper functions",
            "Middleware",
            "Event listener"
        ]
    },
    {
        "q": "What is `Auth::createTokenDriver`?",
        "type": "mcq",
        "o": [
            "Deprecated or internal. AuthManager methods usually `create{Driver}Driver`.",
            "Public API",
            "Factory",
            "Seeder"
        ]
    },
    {
        "q": "Can you use Auth in global scope?",
        "type": "mcq",
        "o": [
            "Be careful. Global scopes run on all queries. If they use `Auth::user()`, filtering applies globally.",
            "No",
            "Yes, always safe",
            "Yes, faster"
        ]
    },
    {
        "q": "Issue with `Auth::user()` in Global Scope in Constructor?",
        "type": "mcq",
        "o": [
            "Session might not differ yet. Best to use check inside the `apply` method, not constructor.",
            "No issue",
            "Infinite loop",
            "Crash"
        ]
    },
    {
        "q": "Auth: `logout` method in `LoginController` uses trait?",
        "type": "mcq",
        "o": [
            "AuthenticatesUsers trait.",
            "RegistersUsers trait",
            "ResetsPasswords trait",
            "VerifiesEmails trait"
        ]
    },
    {
        "q": "Breeze vs Jetstream vs Standard UI?",
        "type": "mcq",
        "o": [
            "Standard UI (legacy bootstrap), Breeze (modern minimal Tailwind), Jetstream (full featured).",
            "All same",
            "Only React",
            "Only Vue"
        ]
    },
    {
        "q": "Fortify: `Fortify::loginView(...)`?",
        "type": "mcq",
        "o": [
            "Define the view to render for login. `Fortify::loginView(fn() => view('auth.login'));`.",
            "Define logic",
            "Define redirect",
            "Define guard"
        ]
    },
    {
        "q": "Fortify: `Fortify::registerView(...)`?",
        "type": "mcq",
        "o": [
            "Define the view for registration.",
            "Define logic",
            "Define redirect",
            "Define guard"
        ]
    },
    {
        "q": "Requesting password confirmation in code?",
        "type": "mcq",
        "o": [
            "Redirect to `password.confirm` route if not confirmed.",
            "Auth::askPassword()",
            "Gate::confirm()",
            "Policy::confirm()"
        ]
    },
    {
        "q": "Auth: `Password::confirm` method?",
        "type": "mcq",
        "o": [
            "Validates confirm password matches.",
            "Sends email",
            "Shows view",
            "Redirects"
        ]
    },
    {
        "q": "Can policies have constructor dependencies?",
        "type": "mcq",
        "o": [
            "Yes, they are resolved from container.",
            "No",
            "Only models",
            "Only user"
        ]
    },
    {
        "q": "Registering a policy for a 3rd party class?",
        "type": "mcq",
        "o": [
            "Manually in AuthServiceProvider policies array. `Vendor\\Class::class => App\\Policies\\VendorPolicy::class`.",
            "Not possible",
            "Use Gate",
            "Use Middleware"
        ]
    },
    {
        "q": "Auth: `AccessResponse` inspect/message?",
        "type": "mcq",
        "o": [
            "$response->allowed(), $response->message(), $response->code().",
            "$response->check()",
            "$response->get()",
            "$response->text()"
        ]
    },
    {
        "q": "What is `Auth::basic` realm?",
        "type": "mcq",
        "o": [
            "2nd arg to middleware. `auth.basic:realm`? Or `Auth::basic('field', 'extra')`?",
            "Domain",
            "Kingdom",
            "Zone"
        ]
    },
    {
        "q": "Can you disable `remember_me` functionality globally?",
        "type": "mcq",
        "o": [
            "Don't provide the option in UI, and don't pass `true` to `attempt`. No specific 'disable' config toggle usually.",
            "Config auth.remember = false",
            "Delete db column",
            "Middleware"
        ]
    },
    {
        "q": "Auth: `viaRemember` checks what?",
        "type": "mcq",
        "o": [
            "If the user was authenticated via the `remember_token` cookie (and not a fresh login in this session).",
            "If token exists",
            "If user exists",
            "If session exists"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\GenericUser`?",
        "type": "mcq",
        "o": [
            "A simple user implementation used by the Database user provider (returns this class instead of Eloquent model).",
            "Abstract class",
            "Interface",
            "Trait"
        ]
    },
    {
        "q": "Does `GenericUser` support `getAuthPassword`?",
        "type": "mcq",
        "o": [
            "Yes, it exposes properties as magic methods/attributes.",
            "No",
            "Only getters",
            "Only setters"
        ]
    },
    {
        "q": "Difference between HTTP Basic and Digest Auth?",
        "type": "mcq",
        "o": [
            "Basic sends base64 credentials (insecure without SSL). Digest uses hashing/challenge-response (more secure, less common). Laravel `auth.basic` uses Basic.",
            "Digest is default",
            "Basic is encrypted",
            "Same thing"
        ]
    },
    {
        "q": "Sanctum: Hashing tokens in DB benefit?",
        "type": "mcq",
        "o": [
            "If database is compromised, tokens cannot be used to impersonate users (similar to password hashing).",
            "No benefit",
            "Faster lookup",
            "Smaller storage"
        ]
    },
    {
        "q": "Sanctum: Token format `id|token`?",
        "type": "mcq",
        "o": [
            "The ID part allows fast database lookup (primary key), the token part is then hashed and compared.",
            "Just for show",
            "Version number",
            "Expiration time"
        ]
    },
    {
        "q": "Can you disable Sanctum CSRF protection?",
        "type": "mcq",
        "o": [
            "Yes, but risky for SPAs. API tokens (Mobile) don't use it.",
            "No, mandatory",
            "Only via config",
            "Only via env"
        ]
    },
    {
        "q": "Auth: `viaRequest` callback receives what?",
        "type": "mcq",
        "o": [
            "The incoming `Request` instance and the `Provider` instance? Usually just `$request`.",
            "User",
            "Token",
            "Session"
        ]
    },
    {
        "q": "Rate Limiting: Why use `user_id` in key?",
        "type": "mcq",
        "o": [
            "To limit specific accounts regardless of IP/device. `throttle:6,1` uses IP by default for guests, user ID for auth users.",
            "No reason",
            "Track billing",
            "Track location"
        ]
    },
    {
        "q": "Rate Limiter: `headers`?",
        "type": "mcq",
        "o": [
            "X-RateLimit-Limit, X-RateLimit-Remaining, Retry-After. (Configurable).",
            "Content-Type",
            "Auth-Token",
            "Set-Cookie"
        ]
    },
    {
        "q": "Socialite: `stateless` impact on state verification?",
        "type": "mcq",
        "o": [
            "Skips verification of the `state` parameter which prevents CSRF in OAuth flows.",
            "Enforces it",
            "Logs it",
            "Hashes it"
        ]
    },
    {
        "q": "Password Reset: `CanResetPassword` trait vs interface?",
        "type": "mcq",
        "o": [
            "Trait implements the Interface methods (`getEmailForPasswordReset`, `sendPasswordResetNotification`).",
            "Interface implements Trait",
            "User must extend Trait",
            "User must extend Interface"
        ]
    },
    {
        "q": "Auth: `setUser` event?",
        "type": "mcq",
        "o": [
            "Doesn't exist as standard event. `Login` or `Authenticated` events are used.",
            "Fired always",
            "Fired never",
            "Fired on update"
        ]
    },
    {
        "q": "Does `Auth::once` fire login event?",
        "type": "mcq",
        "o": [
            "No. Because no persistent session is created.",
            "Yes",
            "Only if successful",
            "Only if failed"
        ]
    },
    {
        "q": "Configuring Auth Defaults: `passwords`?",
        "type": "mcq",
        "o": [
            "Defaults name of password broker (e.g. 'users').",
            "Defaults algorithm",
            "Defaults length",
            "Defaults complexity"
        ]
    },
    {
        "q": "Auth: `TokenGuard` input key?",
        "type": "mcq",
        "o": [
            "Defaults to `api_token` in request (query string or header or input).",
            "token_key",
            "key",
            "secret"
        ]
    },
    {
        "q": "Auth: `TokenGuard` storage column?",
        "type": "mcq",
        "o": [
            "Defaults to `api_token` in database users table.",
            "token",
            "key",
            "secret"
        ]
    },
    {
        "q": "Can you change `TokenGuard` column?",
        "type": "mcq",
        "o": [
            "Yes, in `auth.php` guards config (storage_key / input_key).",
            "No",
            "Only input",
            "Only storage"
        ]
    },
    {
        "q": "Auth: Is `TokenGuard` secure?",
        "type": "mcq",
        "o": [
            "Less secure than Sanctum (static token, rarely rotated, stored plain text usually).",
            "Very secure",
            "Bank grade",
            "Military grade"
        ]
    },
    {
        "q": "How to handle 'soft delete' with Auth lookup?",
        "type": "mcq",
        "o": [
            "Eloquent User Provider uses `first()`, which respects global scopes (SoftDeletes excludes deleted). Deleted users cannot login.",
            "Deleted users can login",
            "Throws error",
            "Ignores scope"
        ]
    },
    {
        "q": "Allowing soft-deleted users to login?",
        "type": "mcq",
        "o": [
            "You must create a custom User Provider that uses `withTrashed()`.",
            "Config option",
            "Middleware",
            "Not possible"
        ]
    },
    {
        "q": "Auth: `getAuthIdentifierName`?",
        "type": "mcq",
        "o": [
            "Returns the name of the primary key column (usually 'id').",
            "Returns value",
            "Returns password column",
            "Returns email column"
        ]
    },
    {
        "q": "Auth: `getAuthIdentifier`?",
        "type": "mcq",
        "o": [
            "Returns the value of the primary key.",
            "Returns column name",
            "Returns password",
            "Returns email"
        ]
    },
    {
        "q": "Auth: `getAuthPassword`?",
        "type": "mcq",
        "o": [
            "Returns the hashed password for comparison.",
            "Returns plain password",
            "Returns salt",
            "Returns nothing"
        ]
    },
    {
        "q": "Auth: `getRememberToken`?",
        "type": "mcq",
        "o": [
            "Returns the current remember token string.",
            "Returns column name",
            "Returns boolean",
            "Returns duration"
        ]
    },
    {
        "q": "Auth: `setRememberToken`?",
        "type": "mcq",
        "o": [
            "Sets the remember token value (e.g. before save).",
            "Saves to DB",
            "Deletes token",
            "Validates token"
        ]
    },
    {
        "q": "Auth: `getRememberTokenName`?",
        "type": "mcq",
        "o": [
            "Returns the column name for remember token (default 'remember_token').",
            "Returns value",
            "Returns config",
            "Returns null"
        ]
    },
    {
        "q": "Sanctum: Middleware priority?",
        "type": "mcq",
        "o": [
            "Ideally runs early to authenticate user for subsequent logic. Kernel defaults are usually fine.",
            "Run last",
            "Run never",
            "Run randomly"
        ]
    },
    {
        "q": "Auth: `login` route name convention?",
        "type": "mcq",
        "o": [
            "Route named `login` is expected by `Authenticate` middleware for redirection.",
            "signin",
            "auth.login",
            "user.login"
        ]
    },
    {
        "q": "What if `login` route is missing?",
        "type": "mcq",
        "o": [
            "Unauthenticated redirection fails with RouteNotFoundException.",
            "Redirects to home",
            "Shows 404",
            "Shows 500"
        ]
    },
    {
        "q": "How to register `Sanctum` routes manually?",
        "type": "mcq",
        "o": [
            "You don't usually invoke a helper. Sanctum provides controllers you can route to, or `Sanctum::routes()`? No, Sanctum doesn't have `Sanctum::routes()` like Passport/Breeze.",
            "Sanctum::routes()",
            "Sanctum::auth()",
            "Sanctum::api()"
        ]
    },
    {
        "q": "Does Sanctum provide Login UI?",
        "type": "mcq",
        "o": [
            "No, it's backend/API auth. Breeze/Jetstream provide the UI.",
            "Yes",
            "Yes, basic",
            "Yes, complex"
        ]
    },
    {
        "q": "Passport: `Personal Access Client` ID config?",
        "type": "mcq",
        "o": [
            "ENV: `PASSPORT_PERSONAL_ACCESS_CLIENT_ID` and `PASSPORT_PERSONAL_ACCESS_CLIENT_SECRET`.",
            "Hardcoded",
            "Database only",
            "File only"
        ]
    },
    {
        "q": "Passport: Does it use JWTs?",
        "type": "mcq",
        "o": [
            "Yes, access tokens are JWTs signed by the private key.",
            "No, opaque strings",
            "No, session IDs",
            "No, hashes"
        ]
    },
    {
        "q": "Parsing a Passport JWT manually?",
        "type": "mcq",
        "o": [
            "Use a JWT library and the public key to verify signature and read payload.",
            "base64 decode only",
            "hex decode",
            "cannot read"
        ]
    },
    {
        "q": "Auth: `Session` driver 'lifetime'?",
        "type": "mcq",
        "o": [
            "In `config/session.php`. Defaults to 120 minutes. Controls login duration (unless remember me used).",
            "1 day",
            "1 week",
            "Forever"
        ]
    },
    {
        "q": "Auth: `expire_on_close`?",
        "type": "mcq",
        "o": [
            "If true, session cookie expires when browser closes.",
            "Expires on logout",
            "Expires on error",
            "Expires on midnight"
        ]
    },
    {
        "q": "Protecting strict routes with `can`?",
        "type": "mcq",
        "o": [
            "Route::get(...)->can('update', 'post'); (Laravel 9+ syntax shorthand for middleware).",
            "Route::can()",
            "Route::allow()",
            "Route::permit()"
        ]
    },
    {
        "q": "What is `Auth::check()` return type?",
        "type": "mcq",
        "o": [
            "bool",
            "int",
            "string",
            "User"
        ]
    },
    {
        "q": "What is `Auth::user()` return type?",
        "type": "mcq",
        "o": [
            "\\Illuminate\\Contracts\\Auth\\Authenticatable|null",
            "bool",
            "int",
            "string"
        ]
    },
    {
        "q": "What is `Auth::id()` return type?",
        "type": "mcq",
        "o": [
            "int|string|null",
            "bool",
            "User",
            "array"
        ]
    },
    {
        "q": "Auth: `CreatesUserProviders` `createDatabaseProvider`?",
        "type": "mcq",
        "o": [
            "Creates the `DatabaseUserProvider` using DB connection and table.",
            "Creates table",
            "Creates database",
            "Creates model"
        ]
    },
    {
        "q": "Auth: `CreatesUserProviders` `createEloquentProvider`?",
        "type": "mcq",
        "o": [
            "Creates `EloquentUserProvider` using hashing service and model class.",
            "Creates model",
            "Creates hash",
            "Creates controller"
        ]
    },
    {
        "q": "Does `EloquentUserProvider` support custom hasher?",
        "type": "mcq",
        "o": [
            "Yes, it is injected into the constructor.",
            "No",
            "Only global",
            "Only bcrypt"
        ]
    },
    {
        "q": "Can you define `hasRole` method on User?",
        "type": "mcq",
        "o": [
            "Yes, common practice. Checks relation or attribute.",
            "No, reserved",
            "No, dangerous",
            "No, invalid"
        ]
    },
    {
        "q": "Using `hasRole` in Middleware?",
        "type": "mcq",
        "o": [
            "Check `$request->user()->hasRole('admin')` and abort/redirect if false.",
            "Check Auth::role()",
            "Check Role::has()",
            "Check Admin::check()"
        ]
    },
    {
        "q": "What is `Auth::guard()` return type?",
        "type": "mcq",
        "o": [
            "\\Illuminate\\Contracts\\Auth\\Guard|\\Illuminate\\Contracts\\Auth\\StatefulGuard",
            "User",
            "Provider",
            "string"
        ]
    },
    {
        "q": "What is `Lockout` event fired by?",
        "type": "mcq",
        "o": [
            "Usually `Illuminate\\Foundation\\Auth\\ThrottlesLogins` trait when rate limit is exceeded.",
            "Guard",
            "Provider",
            "Controller"
        ]
    },
    {
        "q": "What is `PasswordReset` event payload?",
        "type": "mcq",
        "o": [
            "The user instance and the user's password? No, just the User usually. (Depends on version, usually `new PasswordReset($user)`).",
            "Token",
            "Email",
            "Status"
        ]
    },
    {
        "q": "What is `Verified` event payload?",
        "type": "mcq",
        "o": [
            "The user instance that was verified.",
            "Token",
            "Date",
            "Status"
        ]
    },
    {
        "q": "Auth: `setUser` vs `login`?",
        "type": "mcq",
        "o": [
            "`setUser` only sets the user for the current request context (in memory). `login` persists it to session/cookie.",
            "Same",
            "Login is temporary",
            "SetUser is permanent"
        ]
    },
    {
        "q": "Auth: `hasUser` check?",
        "type": "mcq",
        "o": [
            "Checks if the guard currently has a user instance loaded (without necessarily trying to load from session/cookie if not yet attempted).",
            "Checks DB",
            "Checks cache",
            "Checks file"
        ]
    },
    {
        "q": "Testing: `actingAs` arguments?",
        "type": "mcq",
        "o": [
            "User contract instance, and optional guard name.",
            "ID only",
            "Email only",
            "Credentials"
        ]
    },
    {
        "q": "Does `actingAs` persist across test methods?",
        "type": "mcq",
        "o": [
            "No, tests are isolated (conceptually). Session is usually flushed.",
            "Yes",
            "Sometimes",
            "Only in browser tests"
        ]
    },
    {
        "q": "Password Defaults: `Password::defaults(fn() => ...)`?",
        "type": "mcq",
        "o": [
            "Sets the global default password validation rules (usually in AppServiceProvider).",
            "Sets default password",
            "Sets default hashing",
            "Sets default user"
        ]
    },
    {
        "q": "What is `Auth::createSessionDriver`?",
        "type": "mcq",
        "o": [
            "Creates the `SessionGuard`.",
            "Creates session",
            "Creates cookies",
            "Creates controller"
        ]
    },
    {
        "q": "Sanctum: `HasApiTokens` token access serialization?",
        "type": "mcq",
        "o": [
            "The `tokens` relation is usually hidden in serialization if you hide the relation, but by default it might be exposed if loaded. Typically you don't return the User object with tokens loaded to API.",
            "Always hidden",
            "Always visible",
            "Encrypted"
        ]
    },
    {
        "q": "Auth: `guard` helper vs Facade?",
        "type": "mcq",
        "o": [
            "Same underlying instance. `auth()->guard()` vs `Auth::guard()`.",
            "Helper is faster",
            "Facade is faster",
            "Different"
        ]
    },
    {
        "q": "Can you use `Auth` in `console.php` routes?",
        "type": "mcq",
        "o": [
            "Yes, usually via closure if command is run in a way that sets user, but typically Console is stateless/cli. Auth usually irrelevant unless simulating.",
            "No, error",
            "Only admin",
            "Only guest"
        ]
    },
    {
        "q": "Basic Auth 'basic' vs 'digest' config?",
        "type": "mcq",
        "o": [
            "Not configurable in Laravel Auth out of box. `auth.basic` middleware purely does Basic. Digest requires custom implementation.",
            "Config in auth.php",
            "Config in app.php",
            "Env var"
        ]
    },
    {
        "q": "Auth: `getRecallerName`?",
        "type": "mcq",
        "o": [
            "Returns the name of the 'remember me' cookie.",
            "Returns value",
            "Returns user",
            "Returns id"
        ]
    },
    {
        "q": "Recaller Cookie Name format?",
        "type": "mcq",
        "o": [
            "'remember_web_'.sha1(class) usually.",
            "remember_me",
            "auth_token",
            "laravel_auth"
        ]
    },
    {
        "q": "Can you manually cycle the `remember_token`?",
        "type": "mcq",
        "o": [
            "Yes, `$user->setRememberToken(Str::random(60)); $user->save();`.",
            "No, only logout",
            "No, only login",
            "No, auto only"
        ]
    },
    {
        "q": "Auth: `logoutCurrentDevice`?",
        "type": "mcq",
        "o": [
            "Deletes the session for the current device (effectively logout).",
            "Deletes all",
            "Deletes others",
            "Deletes user"
        ]
    },
    {
        "q": "Auth: `invalidate` session?",
        "type": "mcq",
        "o": [
            "Regenerates session ID and removes all data. Standard logout practice.",
            "Deletes session file",
            "Deletes session row",
            "Resets timer"
        ]
    },
    {
        "q": "Password Confirmation: `password.confirm` view?",
        "type": "mcq",
        "o": [
            "Shows a form asking for password again. Post to `password.confirm` route.",
            "Email verify",
            "Reset password",
            "Login"
        ]
    },
    {
        "q": "Using `auth` middleware on a Controller group?",
        "type": "mcq",
        "o": [
            "Route::controller(...)->group(function() { ... })->middleware('auth');",
            "In constructor",
            "Both A and B",
            "Cannot do it"
        ]
    },
    {
        "q": "Can `Auth::attempt` take extra conditions?",
        "type": "mcq",
        "o": [
            "Yes. `Auth::attempt(['email' => $e, 'password' => $p, 'active' => 1])`. Checks `active` column.",
            "No",
            "Only id",
            "Only email"
        ]
    },
    {
        "q": "Does `Auth::attempt` modify the query?",
        "type": "mcq",
        "o": [
            "Yes, it uses the keys in credentials array (except password) as 'where' clauses.",
            "No, filters in PHP",
            "No, grabs all",
            "No, ignores extras"
        ]
    },
    {
        "q": "Auth: `login` vs `attempt` return?",
        "type": "mcq",
        "o": [
            "`login` is void (or null). `attempt` returns boolean.",
            "Same",
            "Both return User",
            "Both return bool"
        ]
    },
    {
        "q": "Why `Hash::make` in seeder?",
        "type": "mcq",
        "o": [
            "Store passwords hashed so they work with standard Auth.",
            "Store plain",
            "Store encrypted",
            "Store encoded"
        ]
    },
    {
        "q": "Sanctum: `HasApiTokens` vs `MorphMany`?",
        "type": "mcq",
        "o": [
            "The trait defines the `tokens` MorphMany relationship.",
            "Trait is redundant",
            "MorphMany is deprecated",
            "Use BelongsTo"
        ]
    },
    {
        "q": "Passport: `Client` redirects?",
        "type": "mcq",
        "o": [
            "Must be whitelisted in DB `redirect` column to prevent open redirect vulnerabilities.",
            "Any url allowed",
            "Localhost only",
            "Https only"
        ]
    },
    {
        "q": "Socialite: `stateless` mandatory for API?",
        "type": "mcq",
        "o": [
            "Yes, because APIs don't have session state between the redirect and callback usually.",
            "No",
            "Optional",
            "Only for Facebook"
        ]
    },
    {
        "q": "Socialite: `user` vs `userFromToken`?",
        "type": "mcq",
        "o": [
            "`user()` handles the OAuth flow (code exchange). `userFromToken($token)` retrieves user details using an existing access token.",
            "Same",
            "Token is legacy",
            "User is legacy"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\Access\\Response`?",
        "type": "mcq",
        "o": [
            "Result of a Gate check. Can be allowed or denied (with message/code).",
            "Http Response",
            "Json Response",
            "Redirect Response"
        ]
    },
    {
        "q": "Auth: `logoutOtherDevices` requires password?",
        "type": "mcq",
        "o": [
            "Yes, to confirm intent. `Auth::logoutOtherDevices('password')`.",
            "No",
            "Yes, email",
            "Yes, username"
        ]
    },
    {
        "q": "Can you use `Auth` in a Service Provider `register` method?",
        "type": "mcq",
        "o": [
            "Avoid it. Session/Auth services aren't fully loaded/booted. Use `boot` or callback.",
            "Yes, safe",
            "Yes, recommended",
            "No, fatal error"
        ]
    },
    {
        "q": "Auth: `ResolvesHashMatches` trait?",
        "type": "mcq",
        "o": [
            "Internal trait used by `DatabaseUserProvider` to compare hashes.",
            "Used by Session",
            "Used by Cookie",
            "Used by Request"
        ]
    },
    {
        "q": "What is `Auth::routes` `register` option default?",
        "type": "mcq",
        "o": [
            "true.",
            "false",
            "null",
            "undefined"
        ]
    },
    {
        "q": "What is `Auth::routes` `reset` option default?",
        "type": "mcq",
        "o": [
            "true.",
            "false",
            "null",
            "undefined"
        ]
    },
    {
        "q": "What is `Auth::routes` `verify` option default?",
        "type": "mcq",
        "o": [
            "false.",
            "true",
            "null",
            "undefined"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\Guard` interface?",
        "type": "mcq",
        "o": [
            "The base contract for all auth guards. Defines `check`, `guest`, `user`, `id`, `validate`, `setUser`.",
            "Class",
            "Trait",
            "Abstract"
        ]
    },
    {
        "q": "What is `Illuminate\\Auth\\StatefulGuard` interface?",
        "type": "mcq",
        "o": [
            "Extends Guard with stateful methods: `attempt`, `once`, `login`, `loginUsingId`, `logout`.",
            "For tokens",
            "For API",
            "For Statless"
        ]
    },
    {
        "q": "Auth: `onceBasic`?",
        "type": "mcq",
        "o": [
            "Perform stateless HTTP Basic Auth login attempt for the current request.",
            "Log in once",
            "Basic features",
            "Redirects"
        ]
    },
    {
        "q": "Auth: `once` method?",
        "type": "mcq",
        "o": [
            "Log a user into the application for a single request. No session or cookie.",
            "Retry once",
            "Redirect",
            "Error"
        ]
    },
    {
        "q": "What is `Auth::routes` `home` option (Legacy)?",
        "type": "mcq",
        "o": [
            "Registers the /home route? Actually `Auth::routes()` does NOT register /home. `HomeController` usually does.",
            "Registers",
            "Redirects",
            "Ignores"
        ]
    },
    {
        "q": "Auth: `VerificationController`?",
        "type": "mcq",
        "o": [
            "Handles email verification logic (show, verify, resend). Defined in `laravel/ui`.",
            "Verifies passwords",
            "Verifies login",
            "Verifies errors"
        ]
    },
    {
        "q": "Auth: `ConfirmPasswordController`?",
        "type": "mcq",
        "o": [
            "Handles showing and processing password confirmation form.",
            "Confirm email",
            "Confirm register",
            "Confirm delete"
        ]
    },
    {
        "q": "Auth: `ForgotPasswordController`?",
        "type": "mcq",
        "o": [
            "Handles sending the password reset link emails.",
            "Shows form",
            "Resets password",
            "Logs out"
        ]
    },
    {
        "q": "Auth: `ResetPasswordController`?",
        "type": "mcq",
        "o": [
            "Handles the actual reset of the password (new password input).",
            "Sends email",
            "Forgot password",
            "Logs out"
        ]
    },
    {
        "q": "Can you use `Auth` in Middleware `handle` method?",
        "type": "mcq",
        "o": [
            "Yes, this is the primary place for access control.",
            "No, too early",
            "No, too late",
            "Only in terminate"
        ]
    },
    {
        "q": "Auth: `Authenticate` middleware `redirectTo` method behavior?",
        "type": "mcq",
        "o": [
            "If request expects JSON (API), returns null (causing 401). If Web, returns login route string.",
            "Always login",
            "Always 401",
            "Always home"
        ]
    },
    {
        "q": "Does `Sanctum` automatically load relations?",
        "type": "mcq",
        "o": [
            "No. `Auth::user()` returns the model as is. You must load relations yourself.",
            "Yes, all",
            "Yes, tokens",
            "Yes, roles"
        ]
    },
    {
        "q": "Sanctum: Revoking all tokens for everyone?",
        "type": "mcq",
        "o": [
            "DB::table('personal_access_tokens')->truncate();",
            "Sanctum::revokeAll()",
            "Auth::revokeAll()",
            "Cannot do it"
        ]
    },
    {
        "q": "Auth: `password_resets` table columns?",
        "type": "mcq",
        "o": [
            "email, token, created_at.",
            "id, email, token",
            "user_id, token, created_at",
            "token, expires_at"
        ]
    },
    {
        "q": "Is `token` in `password_resets` hashed?",
        "type": "mcq",
        "o": [
            "Yes (since Laravel 6+).",
            "No, plain text",
            "Encrypted",
            "Encoded"
        ]
    },
    {
        "q": "Auth: `CanResetPassword` vs `MustVerifyEmail`?",
        "type": "mcq",
        "o": [
            "`CanResetPassword` is for resetting forgotten passwords. `MustVerifyEmail` is for verifying email ownership on register.",
            "Same",
            "Reverse",
            "Unrelated"
        ]
    },
    {
        "q": "Auth: `UserProvider` `updateRememberToken` triggered when?",
        "type": "mcq",
        "o": [
            "On Login (if remember me checked) AND on Logout (to invalidate old token).",
            "Only Login",
            "Only Logout",
            "Only Register"
        ]
    },
    {
        "q": "Auth: `SessionGuard` `fireAuthenticatedEvent`?",
        "type": "mcq",
        "o": [
            "Internal method to fire `Authenticated` event after check.",
            "Fires login",
            "Fires logout",
            "Fires failed"
        ]
    },
    {
        "q": "Auth: `SessionGuard` `fireLoginEvent`?",
        "type": "mcq",
        "o": [
            "Internal method to fire `Login` event after login.",
            "Fires check",
            "Fires logout",
            "Fires failed"
        ]
    },
    {
        "q": "Auth: `SessionGuard` `fireFailedEvent`?",
        "type": "mcq",
        "o": [
            "Internal method to fire `Failed` event.",
            "Fires success",
            "Fires error",
            "Fires warning"
        ]
    },
    {
        "q": "Can you use `Auth` in `App\\Exceptions\\Handler`?",
        "type": "mcq",
        "o": [
            "Yes, e.g. checking if user is admin to show detail. `Auth::check()`.",
            "No",
            "Only guest",
            "Only id"
        ]
    },
    {
        "q": "Auth: `AuthenticationException` vs `AccessDeniedHttpException`?",
        "type": "mcq",
        "o": [
            "AuthException = 401 (Not Logged In). AccessDenied = 403 (Logged In but No Permission).",
            "Reverse",
            "Both 401",
            "Both 403"
        ]
    },
    {
        "q": "Auth: `AuthorizationException`?",
        "type": "mcq",
        "o": [
            "Converted to `AccessDeniedHttpException` (403) by Exception Handler.",
            "500 Error",
            "404 Error",
            "200 OK"
        ]
    },
    {
        "q": "Can `Auth::user()` return null even if `Auth::check()` is true?",
        "type": "mcq",
        "o": [
            "Should not happen in standard guards. `check` usually relies on `user() !== null`.",
            "Yes",
            "Depends on driver",
            "Depends on cache"
        ]
    },
    {
        "q": "Can `Auth::id()` return null?",
        "type": "mcq",
        "o": [
            "Yes, if not logged in.",
            "No, 0",
            "No, -1",
            "No, false"
        ]
    },
    {
        "q": "Sanctum: `PersonalAccessToken` implements which contract?",
        "type": "mcq",
        "o": [
            "Laravel\\Sanctum\\Contracts\\HasAbilities? Actually usually just extends Model. No strict contract for the token itself exposed globally.",
            "TokenContract",
            "AuthContract",
            "UserContract"
        ]
    },
    {
        "q": "Passport: `HasApiTokens` methods collision?",
        "type": "mcq",
        "o": [
            "Methods like `token` or `tokens` conflict if you use both traits. Don't use both.",
            "No conflict",
            "Auto resolved",
            "Merged"
        ]
    },
    {
        "q": "Auth: `AccessGate` trait?",
        "type": "mcq",
        "o": [
            "Usually referring to `Illuminate\\Foundation\\Auth\\Access\\Authorizable` trait used in User model.",
            "Gate class",
            "Policy class",
            "Provider class"
        ]
    },
    {
        "q": "Auth: `Authorizable` vs `Authenticatable`?",
        "type": "mcq",
        "o": [
            "`Authenticatable` = Identity (Who). `Authorizable` = Permissions (Can).",
            "Same",
            "Reverse",
            "Unrelated"
        ]
    },
    {
        "q": "Can `Sanctum` work with separate `guards` for different user types?",
        "type": "mcq",
        "o": [
            "Yes, configure different guards in `auth.php` using `sanctum` driver and different providers.",
            "No, only one",
            "No, only web",
            "No, only api"
        ]
    },
    {
        "q": "Auth: `DatabaseUserProvider` hashing?",
        "type": "mcq",
        "o": [
            "Uses the Hash instance passed in constructor to validate credentials.",
            "Uses MD5",
            "Uses SHA1",
            "Uses Plain"
        ]
    },
    {
        "q": "Auth: `retrieveByCredentials` logic?",
        "type": "mcq",
        "o": [
            "Finds first user matching all non-array/non-password keys.",
            "Finds all",
            "Finds exact match including password",
            "Finds by id"
        ]
    },
    {
        "q": "Can `retrieveByCredentials` return multiple users?",
        "type": "mcq",
        "o": [
            "Returns a single `Authenticatable` (first match) or null.",
            "Returns Collection",
            "Returns Array",
            "Returns Boolean"
        ]
    },
    {
        "q": "Auth: `validateCredentials` return?",
        "type": "mcq",
        "o": [
            "Boolean.",
            "User",
            "Token",
            "String"
        ]
    },
    {
        "q": "Auth: `password` rule `letters()`?",
        "type": "mcq",
        "o": [
            "Requires at least one letter.",
            "Requires all letters",
            "Requires no letters",
            "Requires A-Z"
        ]
    },
    {
        "q": "Auth: `password` rule `numbers()`?",
        "type": "mcq",
        "o": [
            "Requires at least one number.",
            "Requires all numbers",
            "Requires no numbers",
            "Requires 0-9"
        ]
    },
    {
        "q": "Auth: `password` rule `symbols()`?",
        "type": "mcq",
        "o": [
            "Requires at least one symbol.",
            "Requires all symbols",
            "Requires no symbols",
            "Requires $ or @"
        ]
    },
    {
        "q": "Auth: `password` rule `mixedCase()`?",
        "type": "mcq",
        "o": [
            "Requires upper and lower case.",
            "Requires camel case",
            "Requires snake case",
            "Requires title case"
        ]
    },
    {
        "q": "Auth: `password` rule `uncompromised(3)`?",
        "type": "mcq",
        "o": [
            "Allows password if it appears less than 3 times in leak database.",
            "Checking top 3 databases",
            "Checking 3 times",
            "Checking 3 servers"
        ]
    },
    {
        "q": "Auth: `password` rule default implementation?",
        "type": "mcq",
        "o": [
            "Validation rule string 'current_password' checks against auth user password.",
            "Different from object",
            "Legacy",
            "Deprecated"
        ]
    },
    {
        "q": "What is `current_password` validation rule?",
        "type": "mcq",
        "o": [
            "Validates that the attribute matches the authenticated user's current password.",
            "Checks if password is 'current'",
            "Checks if password is set",
            "Checks if password is new"
        ]
    },
    {
        "q": "Auth: `password` confirmation validation?",
        "type": "mcq",
        "o": [
            "Use `confirmed` rule on the password field (expects `password_confirmation` field).",
            "Use `same:password`",
            "Use `match:password`",
            "Use `equal:password`"
        ]
    },
    {
        "q": "Auth: `can` middleware response type?",
        "type": "mcq",
        "o": [
            "403 Forbidden on failure.",
            "401 Unauthorized",
            "404 Not Found",
            "302 Redirect"
        ]
    },
    {
        "q": "Auth: `guest` middleware response type?",
        "type": "mcq",
        "o": [
            "Redirect to home (302).",
            "403 Forbidden",
            "401 Unauthorized",
            "404 Not Found"
        ]
    },
    {
        "q": "Auth: `auth` middleware JSON request response?",
        "type": "mcq",
        "o": [
            "401 Unauthorized json message.",
            "Redirect to login",
            "403 Forbidden",
            "404 Not Found"
        ]
    },
    {
        "q": "Can you configure `auth` middleware redirect logic?",
        "type": "mcq",
        "o": [
            "Yes, by modifying `redirectTo` in `Authenticate` middleware.",
            "No, hardcoded",
            "Only via .env",
            "Only via routes"
        ]
    },
    {
        "q": "Does `Auth::check` verify `email_verified_at`?",
        "type": "mcq",
        "o": [
            "No, only checks authentication (login). Use `verified` middleware for verification check.",
            "Yes, always",
            "Yes, if configured",
            "Yes, if strict"
        ]
    },
    {
        "q": "Auth: `Attempting` event parameters?",
        "type": "mcq",
        "o": [
            "Array $credentials, bool $remember, string $guards.",
            "User $user",
            "Token $token",
            "Request $request"
        ]
    },
    {
        "q": "Auth: `CurrentDeviceLogout` event?",
        "type": "mcq",
        "o": [
            "Does not exist as standard event. `Logout` is generic.",
            "Existing event",
            "Fired on timeout",
            "Fired on error"
        ]
    },
    {
        "q": "Auth: `Events\\Registered` constructor?",
        "type": "mcq",
        "o": [
            "Accepts the `$user` instance.",
            "Accepts email",
            "Accepts id",
            "Accepts request"
        ]
    },
    {
        "q": "Auth: `Events\\Verified` constructor?",
        "type": "mcq",
        "o": [
            "Accepts the `$user` instance.",
            "Accepts email",
            "Accepts id",
            "Accepts date"
        ]
    },
    {
        "q": "Auth: `Events\\Lockout` constructor?",
        "type": "mcq",
        "o": [
            "Accepts `$request` instance.",
            "Accepts user",
            "Accepts ip",
            "Accepts email"
        ]
    },
    {
        "q": "Auth: `Events\\PasswordReset` constructor?",
        "type": "mcq",
        "o": [
            "Accepts `$user` instance.",
            "Accepts token",
            "Accepts email",
            "Accepts password"
        ]
    }
]