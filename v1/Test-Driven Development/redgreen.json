[
    {
        "q": "What is the 'Red' phase in Red-Green-Refactor?",
        "o": [
            "Write a test that fails (usually because the feature is missing)",
            "Write the production code first",
            "Fix bugs",
            "Optimize code"
        ]
    },
    {
        "q": "What is the 'Green' phase in Red-Green-Refactor?",
        "o": [
            "Write just enough code to make the failing test pass",
            "Write all the features",
            "Refactor the code",
            "Deploy to production"
        ]
    },
    {
        "q": "What is the 'Refactor' phase in Red-Green-Refactor?",
        "o": [
            "Improve the code structure without changing its behavior",
            "Add new features",
            "Write more tests",
            "Fix bugs"
        ]
    },
    {
        "q": "What is the correct order of the TDD cycle?",
        "o": [
            "Red -> Green -> Refactor",
            "Green -> Red -> Refactor",
            "Refactor -> Red -> Green",
            "Red -> Refactor -> Green"
        ]
    },
    {
        "q": "Why must the test fail first (Red)?",
        "o": [
            "To ensure the test is actually testing something and to define success",
            "To check if the compiler works",
            "To waste time",
            "Because red is a nice color"
        ]
    },
    {
        "q": "What should you do if the test passes immediately in the Red phase?",
        "o": [
            "Verify the test logic, it might be tautological or the feature already exists",
            "Celebrate",
            "Move to Refactor",
            "Delete the test"
        ]
    },
    {
        "q": "In the Green phase, is it okay to write messy code?",
        "o": [
            "Yes, the goal is to pass the test quickly; clean it up in Refactor",
            "No, code must always be perfect",
            "Only if no one sees it",
            "Only if you are a senior dev"
        ]
    },
    {
        "q": "Why do we Refactor?",
        "o": [
            "To keep technical debt low and maintain clean architecture",
            "To add features",
            "To make code slower",
            "To satisfy the manager"
        ]
    },
    {
        "q": "When do you fix specific bugs found during TDD?",
        "o": [
            "Write a failing test that reproduces the bug, then fix it (Green)",
            "Fix it directly",
            "Ignore it",
            "Create a ticket"
        ]
    },
    {
        "q": "What is the 'Three Rules of TDD' first rule?",
        "o": [
            "You are not allowed to write any production code unless it is to make a failing unit test pass",
            "Write all tests first",
            "Write all code first",
            "Test after coding"
        ]
    },
    {
        "q": "What is the 'Three Rules of TDD' second rule?",
        "o": [
            "You are not allowed to write more of a unit test than is sufficient to fail",
            "Write failing tests forever",
            "Compilation failure doesn't count",
            "Write complex tests"
        ]
    },
    {
        "q": "What is the 'Three Rules of TDD' third rule?",
        "o": [
            "You are not allowed to write more production code than is sufficient to pass the one failing unit test",
            "You can write extra code for future",
            "You should write comments",
            "You should optimize immediately"
        ]
    },
    {
        "q": "During the Refactor phase, do you write new tests?",
        "o": [
            "No, existing tests ensure you don't break functionality",
            "Yes, always",
            "Maybe",
            "Only integration tests"
        ]
    },
    {
        "q": "Does compilation failure count as 'failing' in Red phase?",
        "o": [
            "Yes",
            "No, it must run and assert false",
            "Only in C++",
            "Never"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "cycle = ['Red', 'Green', 'Refactor']\nprint(cycle[0])",
        "o": [
            "Red",
            "Green",
            "Refactor",
            "Error"
        ]
    },
    {
        "q": "Can you skip the Refactor phase?",
        "o": [
            "Ideally no, skipping it leads to technical debt",
            "Yes, always",
            "Yes, if in a hurry",
            "Refactoring is optional"
        ]
    },
    {
        "q": "Who popularized the Red-Green-Refactor mantra?",
        "o": [
            "Kent Beck",
            "Steve Jobs",
            "Bill Gates",
            "Ada Lovelace"
        ]
    },
    {
        "q": "What is the primary goal of the Green phase?",
        "o": [
            "Make the bar go green (pass) as fast as possible",
            "Write perfect code",
            "Design architecture",
            "Write documentation"
        ]
    },
    {
        "q": "In Red-Green-Refactor, when do you design the interface?",
        "o": [
            "During the Red phase (by writing the test call)",
            "Before starting",
            "In Green phase",
            "In Refactor phase"
        ]
    },
    {
        "q": "If you find you need a helper function during Green, what do you do?",
        "o": [
            "Write it to get to Green, then clean/move it during Refactor",
            "Stop and write a test for the helper",
            "Don't use helpers",
            "Quit"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "test_passed = False\nif not test_passed:\n    print('Red')\nelse:\n    print('Green')",
        "o": [
            "Red",
            "Green",
            "Refactor",
            "Error"
        ]
    },
    {
        "q": "Is Hardcoding values allow in the Green phase?",
        "o": [
            "Yes, often used to pass the first simple test ('Sliming')",
            "No, never",
            "Only for strings",
            "Illegal"
        ]
    },
    {
        "q": "What is 'Triangulation' in TDD?",
        "o": [
            "Writing a second test case to force generalization of the code",
            "Using 3 monitors",
            "Geometric testing",
            "Testing triangles"
        ]
    },
    {
        "q": "When implies the need to move from specific to generic code?",
        "o": [
            "When a new test case fails with the hardcoded value",
            "Immediately",
            "Never",
            "When manager asks"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "status = 'Green'\nprint(status == 'Red')",
        "o": [
            "False",
            "True",
            "Error",
            "None"
        ]
    },
    {
        "q": "Does Refactoring change the public behavior?",
        "o": [
            "No, observable behavior must remain the same",
            "Yes, it improves behavior",
            "Yes, it changes API",
            "Sometimes"
        ]
    },
    {
        "q": "What verifies that Refactoring was safe?",
        "o": [
            "The tests still pass (stay Green)",
            "Manual checking",
            "Code review",
            "Compiling"
        ]
    },
    {
        "q": "If you break a test during Refactor, what should you do?",
        "o": [
            "Undo the change and try again, or fix the mistake immediately",
            "Delete the test",
            "Change the test to match",
            "Leave it broken"
        ]
    },
    {
        "q": "How long should a Red-Green-Refactor cycle take?",
        "o": [
            "Minutes (very short)",
            "Hours",
            "Days",
            "Weeks"
        ]
    },
    {
        "q": "What is 'Baby Steps' in TDD?",
        "o": [
            "Taking very small incremental steps to minimize error",
            "Walking slowly",
            "Coding for babies",
            "Using small fonts"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "steps = [1, 2, 3]\nprint(len(steps))",
        "o": [
            "3",
            "1",
            "2",
            "0"
        ]
    },
    {
        "q": "Why is 'Red' important psychologically?",
        "o": [
            "Prevents false positives (tests that always pass)",
            "It is scary",
            "It makes you fast",
            "It causes stress"
        ]
    },
    {
        "q": "Can you change tests during Refactor?",
        "o": [
            "Generally no, unless the test itself needs refactoring (e.g. readability)",
            "Yes, to make them pass",
            "Yes, change requirements",
            "Always"
        ]
    },
    {
        "q": "What if a test is hard to write?",
        "o": [
            "It signals a design problem (e.g. high coupling)",
            "You are tired",
            "Skip it",
            "Use AI"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('Test'.lower())",
        "o": [
            "test",
            "TEST",
            "Test",
            "Error"
        ]
    },
    {
        "q": "Is TDD just determining if code works?",
        "o": [
            "No, it is a design methodology guiding structure",
            "Yes, basic testing",
            "It is debugging",
            "It is QA"
        ]
    },
    {
        "q": "What does 'Clean Code that Works' mean?",
        "o": [
            "The ultimate goal of TDD",
            "Washing code",
            "Formatting code",
            "Deleting comments"
        ]
    },
    {
        "q": "In which phase do you optimize performance?",
        "o": [
            "Refactor (if necessary)",
            "Red",
            "Green",
            "Before Red"
        ]
    },
    {
        "q": "What is 'Obvious Implementation'?",
        "o": [
            "Writing the real implementation immediately if the solution is trivial",
            "Guessing",
            "Copying code",
            "Skipping tests"
        ]
    },
    {
        "q": "What is 'Fake It' ('Til You Make It')?",
        "o": [
            "Returning a constant to pass the test, then gradually replacing with logic",
            "Lying",
            "Fraud",
            "Mocking"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def add(a, b):\n    return 3 # Fake it for 1+2\nprint(add(1, 2))",
        "o": [
            "3",
            "1",
            "2",
            "Error"
        ]
    },
    {
        "q": "Which strategy drives implementation from hardcoded to dynamic?",
        "o": [
            "Triangulation",
            "Refactoring",
            "Obvious Implementation",
            "Faking it"
        ]
    },
    {
        "q": "What comes after the Refactor phase?",
        "o": [
            "Start over with a new Red test for the next functionality",
            "Deploy",
            "Quit",
            "Sleep"
        ]
    },
    {
        "q": "How many assertions per test (guideline)?",
        "o": [
            "One logical assertion per test",
            "Hundreds",
            "Zero",
            "Ten"
        ]
    },
    {
        "q": "Why one assertion per test?",
        "o": [
            "To pinpoint failures accurately",
            "To maximize file size",
            "To slow down testing",
            "Rules are rules"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "assert 1 == 1\nprint('Passed')",
        "o": [
            "Passed",
            "Failed",
            "Error",
            "None"
        ]
    },
    {
        "q": "Is it okay to write multiple tests at once?",
        "o": [
            "No, write one, make it pass, then next",
            "Yes, batch them",
            "Yes, save time",
            "No, write all code first"
        ]
    },
    {
        "q": "Why not write multiple tests at once?",
        "o": [
            "It breaks the feedback loop and makes fixing failures harder",
            "It is illegal",
            "It is too fast",
            "IDE crashes"
        ]
    },
    {
        "q": "What is a 'Unit' in TDD?",
        "o": [
            "The smallest testable part of an application (function/class)",
            "One line of code",
            "One file",
            "One byte"
        ]
    },
    {
        "q": "Does TDD eliminate all bugs?",
        "o": [
            "No, but it significantly reduces them",
            "Yes, 100%",
            "No, it adds bugs",
            "Maybe"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 5\nassert x > 0\nprint('OK')",
        "o": [
            "OK",
            "Error",
            "5",
            "False"
        ]
    },
    {
        "q": "Most common mistake for TDD beginners?",
        "o": [
            "Writing too much code in Green phase",
            "Writing test first",
            "Refactoring too much",
            "Using Git"
        ]
    },
    {
        "q": "Another common TDD mistake?",
        "o": [
            "Skipping the Red phase",
            "Using IDE",
            "Using Python",
            "Drinking coffee"
        ]
    },
    {
        "q": "What happens if you skip Red?",
        "o": [
            "You don't know if the test actually catches failures",
            "Nothing",
            "You save time",
            "Code is better"
        ]
    },
    {
        "q": "What does a passing test signify?",
        "o": [
            "The code meets the requirement specified by the test",
            "The code is bug free",
            "The code is fast",
            "The code is finished"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(bool(0))",
        "o": [
            "False",
            "True",
            "Error",
            "None"
        ]
    },
    {
        "q": "What role does Version Control play in TDD?",
        "o": [
            "Allows reverting to the last identifying 'Green' state if Refactoring fails",
            "No role",
            "Backups only",
            "Sharing code"
        ]
    },
    {
        "q": "Meaning of 'Keep the Bar Green'?",
        "o": [
            "Ensure all tests pass before checking in",
            "Drink at a green bar",
            "Paint the screen",
            "Use green monitor"
        ]
    },
    {
        "q": "What is 'Regression Testing'?",
        "o": [
            "Verifying that recent changes haven't broken existing features",
            "Testing backward",
            "Testing math",
            "Testing future"
        ]
    },
    {
        "q": "Does TDD provide Regression Testing?",
        "o": [
            "Yes, the suite of tests acts as a safety net against regression",
            "No",
            "Only manually",
            "Sometimes"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def is_green(passed):\n    return 'Green' if passed else 'Red'\nprint(is_green(True))",
        "o": [
            "Green",
            "Red",
            "True",
            "False"
        ]
    },
    {
        "q": "Can TDD be used for Legacy Code?",
        "o": [
            "Yes, but it is challenging (requires breaking dependencies)",
            "No, only new projects",
            "No, legacy code is perfect",
            "Only for Java"
        ]
    },
    {
        "q": "What is 'Test First Programming'?",
        "o": [
            "Broad term for writing tests before code (includes TDD)",
            "Programming tests",
            "First test",
            "Beta testing"
        ]
    },
    {
        "q": "Is TDD only for Unit Tests?",
        "o": [
            "Primarily, but concept applies to Acceptance/Integration (ATDD)",
            "Yes, strictly",
            "No, only UI tests",
            "No, only manual tests"
        ]
    },
    {
        "q": "What is 'Ping Pong Pair Programming'?",
        "o": [
            "One writes Red test, other writes Green code + next Red test",
            "Playing table tennis",
            "Server testing",
            "Network test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('Red' in ['Red', 'Green'])",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "Why are short cycles improved?",
        "o": [
            "Keeps context fresh and focus sharp",
            "Makes you tired",
            "Uses more CPU",
            "More typing"
        ]
    },
    {
        "q": "Refactoring without tests is called:",
        "o": [
            "Living dangerously (or just 'editing')",
            "TDD",
            "Professional coding",
            "Optimization"
        ]
    },
    {
        "q": "What is 'Inside-Out' TDD?",
        "o": [
            "Starting with core domain logic and moving to UI/API",
            "Cleaning house",
            "Reversing code",
            "Inverting dependencies"
        ]
    },
    {
        "q": "What is 'Outside-In' TDD?",
        "o": [
            "Starting with Acceptance Test (API/UI) and driving down to units",
            "Gardening",
            "UI design",
            "Mocking everything"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "res = []\nres.append('Red')\nres.append('Green')\nprint(res[-1])",
        "o": [
            "Green",
            "Red",
            "Refactor",
            "Error"
        ]
    },
    {
        "q": "What to do if you can't figure out the test?",
        "o": [
            "Spike separate prototype code to learn, then discard and TDD",
            "Give up",
            "Commit without test",
            "Guess"
        ]
    },
    {
        "q": "What is a 'Spike'?",
        "o": [
            "A quick experiment to learn how to solve a problem",
            "A sharp object",
            "A weapon",
            "A bug"
        ]
    },
    {
        "q": "Do you keep Spike code?",
        "o": [
            "No, throw it away and rewrite with TDD",
            "Yes, ship it",
            "Yes, patch it",
            "Maybe"
        ]
    },
    {
        "q": "Why discard Spike code?",
        "o": [
            "It is usually messy and untested",
            "It is cursed",
            "It is copyrighted",
            "It is too fast"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(1 + 1 == 2)",
        "o": [
            "True",
            "False",
            "2",
            "Error"
        ]
    },
    {
        "q": "Does TDD imply design is finished before coding?",
        "o": [
            "No, design emerges and evolves with the code",
            "Yes, Big Design Up Front",
            "No, no design allowed",
            "Yes, always"
        ]
    },
    {
        "q": "What is 'Emergent Design'?",
        "o": [
            "Design patterns and structure revealing themselves via Refactoring",
            "Emergency design",
            "Fast design",
            "Random design"
        ]
    },
    {
        "q": "Can TDD be used with GUI?",
        "o": [
            "Yes, often using patterns like MVP/MVVM to separate logic",
            "No, GUI is impossible to test",
            "Only CLI",
            "Only Web"
        ]
    },
    {
        "q": "Green phase focus:",
        "o": [
            "Correctness",
            "Efficiency",
            "Beauty",
            "Structure"
        ]
    },
    {
        "q": "Refactor phase focus:",
        "o": [
            "Structure / Maintainability",
            "Behavior change",
            "Adding features",
            "Fixing bugs"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 'Refactor'\nprint(x[:3])",
        "o": [
            "Ref",
            "ref",
            "tor",
            "Error"
        ]
    },
    {
        "q": "What is the 'Transformation Priority Premise'?",
        "o": [
            "Premise by Uncle Bob about prioritizing simpler code transformations",
            "Transformers movie",
            "A law",
            "A database rule"
        ]
    },
    {
        "q": "Goal of Transformation Priority Premise?",
        "o": [
            "To prevent taking too large steps during Green phase",
            "To restrict coding",
            "To make code slow",
            "To use complex logic"
        ]
    },
    {
        "q": "Does TDD guarantee good design?",
        "o": [
            "No, requires developer skill (especially in Refactoring)",
            "Yes, automatically",
            "Yes, if using Java",
            "No, it prevents it"
        ]
    },
    {
        "q": "What if you find a better way during Red?",
        "o": [
            "Finish the cycle (get to Green), then Refactor",
            "Change test immediately",
            "Delete code",
            "Start over"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(len('TDD'))",
        "o": [
            "3",
            "1",
            "2",
            "0"
        ]
    },
    {
        "q": "Is TDD slower?",
        "o": [
            "Initially yes, but reduces debug time and maintenance (faster long term)",
            "Yes, always slower",
            "No, infinite speed",
            "Only on Mondays"
        ]
    },
    {
        "q": "When does TDD payoff?",
        "o": [
            "Medium to long term (maintenance phase)",
            "Never",
            "First hour",
            "Immediately"
        ]
    },
    {
        "q": "Does TDD replace QA?",
        "o": [
            "No, QA provides different perspective (E2E, usability, edge cases)",
            "Yes, fire QA",
            "Yes, devs do all",
            "Maybe"
        ]
    },
    {
        "q": "Can you do TDD with Database?",
        "o": [
            "Yes, using integration tests or mocking the repository",
            "No",
            "Only SQL",
            "Only NoSQL"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1]\nl.append(2)\nprint(l)",
        "o": [
            "[1, 2]",
            "[2]",
            "[1]",
            "Error"
        ]
    },
    {
        "q": "What if tests are flaky?",
        "o": [
            "Fix them immediately (they undermine trust)",
            "Ignore them",
            "Delete them",
            "Run them twice"
        ]
    },
    {
        "q": "Primary benefit of TDD documentation?",
        "o": [
            "Tests act as executable specifications that never lie",
            "Lots of text files",
            "PDFs",
            "Comments"
        ]
    },
    {
        "q": "What is 'Test Fatigue'?",
        "o": [
            "When tests are too slow or brittle, devs stop running them",
            "Tired computer",
            "Sleepy dev",
            "Broken keyboard"
        ]
    },
    {
        "q": "How to avoid Test Fatigue?",
        "o": [
            "Keep tests fast and reliable",
            "Drink coffee",
            "Write fewer tests",
            "Hire more people"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(10 % 3)",
        "o": [
            "1",
            "3",
            "10",
            "0"
        ]
    },
    {
        "q": "Does Red-Green-Refactor apply to bug fixing?",
        "o": [
            "Yes: Write failing test (Red), Fix bug (Green), Clean up (Refactor)",
            "No, just fix it",
            "Only for new features",
            "Never"
        ]
    },
    {
        "q": "What is 'Zombie' testing (mnemonic)?",
        "o": [
            "Zero, One, Many, Boundary, Interface, Exceptions",
            "Undead testing",
            "Horror testing",
            "Scary code"
        ]
    },
    {
        "q": "What does Zero represent in ZOMBIE?",
        "o": [
            "Test case with zero items/inputs",
            "Test nothing",
            "Zero failures",
            "Zero code"
        ]
    },
    {
        "q": "What does One represent in ZOMBIE?",
        "o": [
            "Test case with one item",
            "One test",
            "One file",
            "One user"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(min([5, 1, 10]))",
        "o": [
            "1",
            "5",
            "10",
            "Error"
        ]
    },
    {
        "q": "What is the danger of writing a test that passes immediately?",
        "o": [
            "It might not be asserting anything, or the code already does what is expected by accident",
            "It is too fast",
            "It is lucky",
            "It is perfect"
        ]
    },
    {
        "q": "If a test passes immediately, what is the best practice?",
        "o": [
            "Break the test or the code temporarily to verify the test fails when it should",
            "Keep it",
            "Delete it",
            "Ignore it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def add(x, y):\n    return x + y\nprint(add(2, 3))",
        "o": [
            "5",
            "23",
            "6",
            "Error"
        ]
    },
    {
        "q": "When refactoring, should you change the logic significantly?",
        "o": [
            "No, only the structure; functionality must stay the same",
            "Yes, optimize logic",
            "Yes, change output",
            "Yes, fix bugs"
        ]
    },
    {
        "q": "Can you refactor tests?",
        "o": [
            "Yes, tests should be maintained like production code",
            "No, never touch tests",
            "Only if they fail",
            "Only renaming"
        ]
    },
    {
        "q": "What is 'Refactoring to Pattern'?",
        "o": [
            "Introducing a design pattern during the Refactor phase to solve a specific design problem",
            "Drawing patterns",
            "Knitting",
            "Coding style"
        ]
    },
    {
        "q": "What does TDD say about 'Big Design Up Front'?",
        "o": [
            "Avoid it; let design emerge from small steps",
            "Do it always",
            "It is required",
            "It is the only way"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nprint(l.pop())",
        "o": [
            "3",
            "1",
            "2",
            "Error"
        ]
    },
    {
        "q": "Why is 'Green' phase not the end?",
        "o": [
            "Because minimal code to pass is often messy or duplicative",
            "It is the end",
            "Green is bad",
            "Refactor is optional"
        ]
    },
    {
        "q": "How does TDD reduce debugging time?",
        "o": [
            "Failures are caught immediately when written, localised to the last few changes",
            "It doesn't",
            "It increases it",
            "Magic"
        ]
    },
    {
        "q": "What is 'System Under Test' (SUT)?",
        "o": [
            "The specific object or system being verified by the test",
            "The computer",
            "The user",
            "The database"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 'test'\nprint(x.upper())",
        "o": [
            "TEST",
            "test",
            "Test",
            "Error"
        ]
    },
    {
        "q": "In TDD, who writes the tests?",
        "o": [
            "The developer writing the code",
            "The QA team",
            "The manager",
            "The customer"
        ]
    },
    {
        "q": "Can TDD be applied to legacy code?",
        "o": [
            "Yes, usually by adding tests before changing code",
            "No",
            "Only if rewritten",
            "Only if Java"
        ]
    },
    {
        "q": "What is a 'Characterization Test'?",
        "o": [
            "A test written to describe/lock down the current behavior of legacy code",
            "Testing characters",
            "Testing fonts",
            "Testing roleplay"
        ]
    },
    {
        "q": "When do you use Characterization Tests?",
        "o": [
            "Before refactoring legacy code without tests",
            "After deleting code",
            "For new features",
            "Never"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "d = {'id': 1}\nprint('id' in d)",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "Does TDD hinder creativity?",
        "o": [
            "No, it frees the mind from fear of breaking things, allowing experiments",
            "Yes, it is rigid",
            "Yes, it is boring",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Cycle Time' in TDD?",
        "o": [
            "Time to go through Red-Green-Refactor once",
            "Time to compile",
            "Time to deploy",
            "Bicycle time"
        ]
    },
    {
        "q": "Ideal Cycle Time?",
        "o": [
            "Very short (minutes)",
            "Hours",
            "Days",
            "Weeks"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(abs(-5))",
        "o": [
            "5",
            "-5",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is 'Arrange-Act-Assert' (AAA)?",
        "o": [
            "Structure of a unit test: Setup data, Execute action, Verify result",
            "Battery type",
            "Car service",
            "Audio format"
        ]
    },
    {
        "q": "Does TDD enforce AAA?",
        "o": [
            "Yes, typically tests follow this pattern",
            "No",
            "Only Arrange",
            "Only Assert"
        ]
    },
    {
        "q": "What if 'Arrange' is too long?",
        "o": [
            "Consider using a factory, builder, or setup method",
            "Delete the test",
            "Write comments",
            "Ignore it"
        ]
    },
    {
        "q": "What if 'Assert' is too long?",
        "o": [
            "You might be testing too many things; split the test or use custom assertion",
            "Use print statements",
            "Delete assertions",
            "Keep it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = [1, 2, 3]\nx.reverse()\nprint(x)",
        "o": [
            "[3, 2, 1]",
            "[1, 2, 3]",
            "[3, 1]",
            "Error"
        ]
    },
    {
        "q": "What is 'Behavior verification'?",
        "o": [
            "Checking that specific methods were called on dependencies",
            "Checking variable values",
            "Checking logs",
            "Checking UI"
        ]
    },
    {
        "q": "What is 'State verification'?",
        "o": [
            "Checking the state (values) of the object after action",
            "Checking method calls",
            "Checking database",
            "Checking network"
        ]
    },
    {
        "q": "Which is preferred: State or Behavior verification?",
        "o": [
            "State verification is usually less brittle than Behavior",
            "Behavior is better",
            "Neither",
            "Both equal"
        ]
    },
    {
        "q": "When is Behavior verification needed?",
        "o": [
            "When testing side effects (e.g. sending email, saving to DB) via mocks",
            "Always",
            "For math functions",
            "For strings"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = 'hello'\nprint(s[1:])",
        "o": [
            "ello",
            "hello",
            "h",
            "Error"
        ]
    },
    {
        "q": "What is a 'Stub'?",
        "o": [
            "A test double that provides canned answers to calls",
            "A short object",
            "A ticket",
            "A pencil"
        ]
    },
    {
        "q": "What is a 'Mock'?",
        "o": [
            "A test double that expects specific calls and verifies them",
            "A joke",
            "A copy",
            "A fake"
        ]
    },
    {
        "q": "Stub vs Mock?",
        "o": [
            "Stubs verify state/return values; Mocks verify behavior",
            "No difference",
            "Stubs are faster",
            "Mocks are simpler"
        ]
    },
    {
        "q": "Can you use console.log/print for TDD?",
        "o": [
            "Not recommended; use assertions and a test runner",
            "Yes, exclusively",
            "Yes, best way",
            "No, forbidden"
        ]
    },
    {
        "q": "Why not use print statements?",
        "o": [
            "Requires manual inspection; assertions are automated red/green",
            "They are slow",
            "They waste paper",
            "They are ugly"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(len(set([1, 1, 2])))",
        "o": [
            "2",
            "3",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Continuous Integration' (CI)?",
        "o": [
            "Developers merge changes frequently and automated tests run",
            "Continuous coding",
            "Continuous deployment",
            "Meeting daily"
        ]
    },
    {
        "q": "How does TDD relate to CI?",
        "o": [
            "TDD provides the test suite that CI runs to ensure stability",
            "They are enemies",
            "CI replaces TDD",
            "TDD blocks CI"
        ]
    },
    {
        "q": "What implies a broken build in CI?",
        "o": [
            "Stop and fix it immediately",
            "Ignore it",
            "Blame others",
            "Go home"
        ]
    },
    {
        "q": "What is 'Test Coverage'?",
        "o": [
            "Percentage of code executed by tests",
            "Number of tests",
            "Quality of tests",
            "Time taken"
        ]
    },
    {
        "q": "Is 100% coverage the goal?",
        "o": [
            "Not necessarily; focus on critical paths and confidence, not just number",
            "Yes, absolutely",
            "No, 0% is fine",
            "50% is max"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 10\nif x > 5:\n    print('Big')\nelse:\n    print('Small')",
        "o": [
            "Big",
            "Small",
            "Error",
            "None"
        ]
    },
    {
        "q": "What happens if you only write 'Happy Path' tests?",
        "o": [
            "You miss edge cases and error handling bugs",
            "You are happy",
            "Code is perfect",
            "Coverage is 100%"
        ]
    },
    {
        "q": "What is 'Sad Path' testing?",
        "o": [
            "Testing error conditions and invalid inputs",
            "Crying while testing",
            "Testing deletion",
            "Testing slow code"
        ]
    },
    {
        "q": "Should you write tests for getters/setters?",
        "o": [
            "Usually no, unless they have logic; too trivial",
            "Yes, always",
            "No, never",
            "Only getters"
        ]
    },
    {
        "q": "Should you test private methods?",
        "o": [
            "Ideally no; test them through the public interface",
            "Yes, make them public",
            "Yes, use reflection",
            "Copy them"
        ]
    },
    {
        "q": "Why avoid testing private methods directly?",
        "o": [
            "They are implementation details; testing them couples tests to structure",
            "They are secrets",
            "It is illegal",
            "It is impossible"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nprint(l[1])",
        "o": [
            "2",
            "1",
            "3",
            "Error"
        ]
    },
    {
        "q": "What is 'Integration Testing'?",
        "o": [
            "Testing combined parts of application to ensure they work together",
            "Testing math integrals",
            "Unit testing",
            "Manual testing"
        ]
    },
    {
        "q": "Why are Unit Tests preferred over Integration Tests for TDD?",
        "o": [
            "Faster and pinpoint errors easier",
            "Integration tests are impossible",
            "Unit tests are cooler",
            "Managers like them"
        ]
    },
    {
        "q": "Ratio of Unit to Integration tests?",
        "o": [
            "Many Unit, fewer Integration (Pyramid)",
            "Many Integration, few Unit (Cone)",
            "Equal",
            "Zero Integration"
        ]
    },
    {
        "q": "What is 'End-to-End' (E2E) testing?",
        "o": [
            "Testing the full flow from user UI to database and back",
            "Testing the end",
            "Testing boundaries",
            "Last test"
        ]
    },
    {
        "q": "Cost of E2E tests?",
        "o": [
            "High maintenance, slow execution, flaky",
            "Cheap",
            "Fast",
            "Easy"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('Hello'.replace('H', 'J'))",
        "o": [
            "Jello",
            "Hello",
            "Jeljo",
            "Error"
        ]
    },
    {
        "q": "What is 'Faking' a dependency?",
        "o": [
            "Using a working implementation but lighter (e.g. In-Memory DB)",
            "Lying",
            "Mocking",
            "Stubbing"
        ]
    },
    {
        "q": "What is 'Dummy' object?",
        "o": [
            "Object passed around but never actually used (filler)",
            "Smart object",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "What is 'Spy' object?",
        "o": [
            "Wraps real object and records calls for verification",
            "Secret agent",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "Can TDD be done in frontend?",
        "o": [
            "Yes, using tools like Jest, React Testing Library, Jasmine",
            "No, only backend",
            "No, only API",
            "Only HTML"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(lambda x: x+1)",
        "o": [
            "<function <lambda>...>",
            "1",
            "x+1",
            "Error"
        ]
    },
    {
        "q": "What is 'Assertion'?",
        "o": [
            "Statement verifying that a condition is true",
            "A question",
            "A comment",
            "A loop"
        ]
    },
    {
        "q": "What happens if assertion fails?",
        "o": [
            "Test execution stops and is marked as failed/Red",
            "It continues",
            "Computer crashes",
            "It prints warning"
        ]
    },
    {
        "q": "What is 'SetUp' method?",
        "o": [
            "Code that runs before each test to prepare state",
            "Initial code",
            "Bootloader",
            "Constructor"
        ]
    },
    {
        "q": "What is 'TearDown' method?",
        "o": [
            "Code that runs after each test to clean up",
            "Destructor",
            "Deleter",
            "Shutdown"
        ]
    },
    {
        "q": "Why is isolation important?",
        "o": [
            "Tests should not affect each other (order independent)",
            "Ideally solitary",
            "Security",
            "Speed"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(max(1, 10, 5))",
        "o": [
            "10",
            "1",
            "5",
            "0"
        ]
    },
    {
        "q": "What is 'Regression'?",
        "o": [
            "When a feature that used to work stops working",
            "Moving back",
            "Improving code",
            "A statistical method"
        ]
    },
    {
        "q": "What is a 'Unit Test Suite'?",
        "o": [
            "Collection of unit tests run together",
            "A room",
            "A framework",
            "A software"
        ]
    },
    {
        "q": "How often should you run the suite?",
        "o": [
            "As often as possible, definitely after every cycle",
            "Once a day",
            "Once a week",
            "Never"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "a = [1, 2]\nb = [3, 4]\nprint(a + b)",
        "o": [
            "[1, 2, 3, 4]",
            "[4, 6]",
            "[[1, 2], [3, 4]]",
            "Error"
        ]
    },
    {
        "q": "Does TDD help with documentation?",
        "o": [
            "Yes, tests describe how the system is supposed to work",
            "No",
            "Documentation is separate",
            "Comments are better"
        ]
    },
    {
        "q": "What is 'Living Documentation'?",
        "o": [
            "Documentation (tests) that is always up to date because it runs",
            "Video docs",
            "AI docs",
            "Wiki"
        ]
    },
    {
        "q": "Who benefits from TDD?",
        "o": [
            "Developers (confidence), Business (quality), Users (fewer bugs)",
            "Only developers",
            "Only testers",
            "No one"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = {1, 2}\ns.add(3)\nprint(len(s))",
        "o": [
            "3",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "Is TDD easy to learn?",
        "o": [
            "Concept is simple, but discipline and skill take time to master",
            "Yes, very easy",
            "No, impossible",
            "Don't learn it"
        ]
    },
    {
        "q": "Does TDD guarantee project success?",
        "o": [
            "No, but it improves technical quality; you can still build the wrong thing",
            "Yes, always",
            "No, destroys it",
            "Maybe"
        ]
    },
    {
        "q": "What is 'YAGNI'?",
        "o": [
            "You Ain't Gonna Need It - don't build features until required",
            "Yoga",
            "A greeting",
            "A framework"
        ]
    },
    {
        "q": "Does TDD support YAGNI?",
        "o": [
            "Yes, you only write code to pass the current test",
            "No, it over-engineers",
            "They are unrelated",
            "No"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 10\nprint(f'{x}')",
        "o": [
            "10",
            "x",
            "{x}",
            "Error"
        ]
    },
    {
        "q": "What is 'DRY'?",
        "o": [
            "Don't Repeat Yourself",
            "Dry code",
            "No comments",
            "No abstraction"
        ]
    },
    {
        "q": "Does Refactoring aim for DRY?",
        "o": [
            "Yes, removing duplication is a key goal of Refactoring",
            "No",
            "DRY is bad",
            "Only for CSS"
        ]
    },
    {
        "q": "What is 'KISS'?",
        "o": [
            "Keep It Simple, Stupid",
            "A band",
            "Love",
            "A test"
        ]
    },
    {
        "q": "Does TDD prevent spaghetti code?",
        "o": [
            "Yes, by encouraging modular design and constant refactoring",
            "No",
            "It creates it",
            "Maybe"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "try:\n    1/0\nexcept:\n    print('Caught')\nelse:\n    print('Ok')",
        "o": [
            "Caught",
            "Ok",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Feature Interaction'?",
        "o": [
            "How different features of the system affect each other's behavior",
            "Talking to features",
            "User interaction",
            "UI design"
        ]
    },
    {
        "q": "Does TDD help with Feature Interaction bugs?",
        "o": [
            "Yes, the regression suite (Green state) ensures new features don't break old ones",
            "No",
            "It makes them worse",
            "Only for UI"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('hello'.find('z'))",
        "o": [
            "-1",
            "0",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Code Toxicity'?",
        "o": [
            "Accumulation of bad practices (high complexity, low coverage, duplication)",
            "Poisonous code",
            "Viruses",
            "Dangerous software"
        ]
    },
    {
        "q": "What is 'Technical Debt'?",
        "o": [
            "Implied cost of additional rework caused by choosing an easy solution now instead of a better one later",
            "Money owed",
            "Loan",
            "Budget defect"
        ]
    },
    {
        "q": "How does Refactoring manage Technical Debt?",
        "o": [
            "It pays down the debt incrementaly",
            "It increases it",
            "It ignores it",
            "It hides it"
        ]
    },
    {
        "q": "What is a 'Code Kata'?",
        "o": [
            "A coding exercise repeated to practice skills and internalize TDD steps",
            "Martial arts",
            "Japanese code",
            "A game"
        ]
    },
    {
        "q": "Famous TDD Katas?",
        "o": [
            "FizzBuzz, Bowling Game, Roman Numerals",
            "Mario, Sonic",
            "Chess, Checkers",
            "Poker, Blackjack"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(int(3.9))",
        "o": [
            "3",
            "4",
            "3.9",
            "Error"
        ]
    },
    {
        "q": "What is 'Transformation' vs 'Refactoring'?",
        "o": [
            "Transformation changes behavior (Red->Green); Refactoring changes structure (Green->Refactor)",
            "They are the same",
            "Transformation is for data",
            "Refactoring is for UI"
        ]
    },
    {
        "q": "What is 'Guard Clause'?",
        "o": [
            "Check at the beginning of a function to return early if conditions aren't met",
            "Security guard",
            "If-else ladder",
            "A loop"
        ]
    },
    {
        "q": "Refactoring pattern 'Replace Nested Conditional with Guard Clauses'?",
        "o": [
            "Flattening logic by returning early",
            "Adding more nesting",
            "Using switch",
            "Deleting logic"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def f(x):\n    if x < 0: return\n    print(x)\nf(-1)",
        "o": [
            "None",
            "-1",
            "Error",
            "0"
        ]
    },
    {
        "q": "What is 'Primitive Obsession'?",
        "o": [
            "Using primitive types (int, string) for complex domain concepts",
            "Loving primitives",
            "Low level coding",
            "Assembly"
        ]
    },
    {
        "q": "Why replace Primitives with Objects?",
        "o": [
            "To encapsulate validation and behavior (e.g. Phone number format)",
            "To use more memory",
            "To make code slower",
            "Paradigm shift"
        ]
    },
    {
        "q": "What is 'Feature Envy'?",
        "o": [
            "A method accesses data of another object more than its own",
            "Jealousy",
            "Copying features",
            "Stealing code"
        ]
    },
    {
        "q": "How to fix Feature Envy?",
        "o": [
            "Move Method or Extract Method to the other class",
            "Delete method",
            "Ignore it",
            "Add comments"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class A:\n    val = 1\na = A()\nprint(a.val)",
        "o": [
            "1",
            "0",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Inappropriate Intimacy'?",
        "o": [
            "Classes know too much about each other's private details",
            "Dating",
            "Friendship",
            "Coupling"
        ]
    },
    {
        "q": "What is 'Message Chain' smell?",
        "o": [
            "Code like a.getB().getC().do() - breaking Law of Demeter",
            "Email chain",
            "Linked list",
            "Chat history"
        ]
    },
    {
        "q": "What is 'Long Parameter List' smell?",
        "o": [
            "Method takes too many arguments (> 3 or 4)",
            "A list object",
            "Array",
            "Config file"
        ]
    },
    {
        "q": "Refactoring Long Parameter List?",
        "o": [
            "Introduce Parameter Object",
            "Use global variables",
            "Hardcode values",
            "Pass array"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "d = dict(a=1, b=2)\nprint(d['a'])",
        "o": [
            "1",
            "2",
            "a",
            "Error"
        ]
    },
    {
        "q": "What is 'TDD Anti-pattern: The Liar'?",
        "o": [
            "A test that passes but doesn't test what it says it does",
            "Lying dev",
            "Fake mock",
            "Broken test"
        ]
    },
    {
        "q": "What is 'TDD Anti-pattern: The Inspector'?",
        "o": [
            "A test that violates encapsulation to check internal state (Reflection)",
            "Police",
            "Detective",
            "Debugging"
        ]
    },
    {
        "q": "What is 'TDD Anti-pattern: The Giant'?",
        "o": [
            "A huge unit test verifying everything (Integration test disguised)",
            "Big person",
            "Big file",
            "Big data"
        ]
    },
    {
        "q": "What is 'TDD Anti-pattern: The Mockery'?",
        "o": [
            "Testing mocks instead of the system (over-mocking)",
            "Making fun",
            "Comedy",
            "Fake test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(range(1, 3)))",
        "o": [
            "[1, 2]",
            "[1, 2, 3]",
            "[2, 3]",
            "Error"
        ]
    },
    {
        "q": "What is 'Outside-In TDD' often associated with?",
        "o": [
            "Mockist TDD (London School)",
            "Classic TDD",
            "Integration testing",
            "Frontend dev"
        ]
    },
    {
        "q": "What is 'Classic TDD' (Detroit School) associated with?",
        "o": [
            "State-based verification, minimizing mocks (Chicago School)",
            "Mockist TDD",
            "London School",
            "Frontend dev"
        ]
    },
    {
        "q": "London School TDD focuses on:",
        "o": [
            "Interaction between objects (roles and responsibilities)",
            "State of objects",
            "Algorithms",
            "Data structures"
        ]
    },
    {
        "q": "Chicago School TDD focuses on:",
        "o": [
            "Return values and state changes (black box behavior)",
            "Interaction",
            "Mocks",
            "Spies"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = [1, 2]\ny = x\nx.append(3)\nprint(len(y))",
        "o": [
            "3",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Cyclomatic Complexity'?",
        "o": [
            "A metric indicating the number of linearly independent paths through a program",
            "Cycling speed",
            "Circle math",
            "Code size"
        ]
    },
    {
        "q": "Does TDD reduce Cyclomatic Complexity?",
        "o": [
            "Yes, by encouraging small methods and simple logic",
            "No",
            "Increases it",
            "Maybe"
        ]
    },
    {
        "q": "What happens if you have high Cyclomatic Complexity?",
        "o": [
            "Hard to test completely (too many paths)",
            "Easy to test",
            "Fast code",
            "Good design"
        ]
    },
    {
        "q": "What is 'Code Coverage'?",
        "o": [
            "Measure of how many lines/branches are executed during tests",
            "Insurance",
            "Code size",
            "Comments"
        ]
    },
    {
        "q": "What is 'Branch Coverage'?",
        "o": [
            "Ensuring both True and False outcomes of every decision are tested",
            "Tree climbing",
            "Git branches",
            "Bank branches"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('a' < 'b')",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Mutation Testing'?",
        "o": [
            "Modifying production code (mutants) to see if tests fail (kill the mutant)",
            "X-Men",
            "Genetics",
            "Changing tests"
        ]
    },
    {
        "q": "Why use Mutation Testing?",
        "o": [
            "To check the quality of the test suite (does it catch bugs?)",
            "To find bugs",
            "To optimize code",
            "To refactor"
        ]
    },
    {
        "q": "If a mutant survives, what does it mean?",
        "o": [
            "The test suite is missing a check for that specific logic",
            "The code is robust",
            "The mutant is strong",
            "The test passed"
        ]
    },
    {
        "q": "Is Mutation Testing slow?",
        "o": [
            "Yes, computationally expensive",
            "No, very fast",
            "Instant",
            "Same as unit tests"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def f():\n    pass\nprint(f())",
        "o": [
            "None",
            "Error",
            "Pass",
            "False"
        ]
    },
    {
        "q": "What is 'Acceptance Test Driven Development' (ATDD)?",
        "o": [
            "Writing acceptance tests (user perspective) before writing functionality",
            "Accepting code",
            "Deployment testing",
            "Manual testing"
        ]
    },
    {
        "q": "Who is involved in ATDD?",
        "o": [
            "Developers, Testers, and Product Owners (Three Amigos)",
            "Only devs",
            "Only users",
            "Only managers"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = {1, 2}\ny = {2, 3}\nprint(x | y)",
        "o": [
            "{1, 2, 3}",
            "{1, 2, 2, 3}",
            "{2}",
            "Error"
        ]
    },
    {
        "q": "What is 'Double Loop Learning' in TDD?",
        "o": [
            "Outer loop (Acceptance Test) + Inner loop (Unit Test / RGR)",
            "Looping twice",
            "Recursion",
            "For loop"
        ]
    },
    {
        "q": "What is 'Specification by Example'?",
        "o": [
            "Defining requirements using realistic examples",
            "Writing specs",
            "Coding examples",
            "Documentation"
        ]
    },
    {
        "q": "Can you use Gherkin for TDD?",
        "o": [
            "Yes, typically for the BDD flavor/Acceptance tests",
            "No",
            "Only for cucumbers",
            "Only for Java"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(all([]))",
        "o": [
            "True",
            "False",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Coarse-Grained' test?",
        "o": [
            "Test covering a large chunk of functionality (e.g. API endpoint)",
            "Rough test",
            "Sandpaper",
            "Slow test"
        ]
    },
    {
        "q": "What is 'Fine-Grained' test?",
        "o": [
            "Test covering a small piece of logic (e.g. single method)",
            "Smooth test",
            "Fast test",
            "Good test"
        ]
    },
    {
        "q": "Which granularity fits TDD unit tests?",
        "o": [
            "Fine-Grained",
            "Coarse-Grained",
            "Medium",
            "Both"
        ]
    },
    {
        "q": "What is 'Test Data Builder'?",
        "o": [
            "Pattern to easily construct complex objects for testing",
            "Construction worker",
            "Database script",
            "Factory"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(any([False, False]))",
        "o": [
            "False",
            "True",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Test Pollution'?",
        "o": [
            "One test modifying shared state that affects another test",
            "Dirty tests",
            "Smog",
            "Bad code"
        ]
    },
    {
        "q": "How to prevent Test Pollution?",
        "o": [
            "Use Teardown/Cleanup or fresh fixtures for every test",
            "Run tests sequentially",
            "Don't use state",
            "Restart computer"
        ]
    },
    {
        "q": "What is 'Flaky Test'?",
        "o": [
            "Test that sometimes passes and sometimes fails without code changes",
            "Pastry",
            "Bad test",
            "Slow test"
        ]
    },
    {
        "q": "Common cause of flakiness?",
        "o": [
            "Async timing issues, ordering dependency, shared state",
            "Cosmic rays",
            "Bad hardware",
            "Typing errors"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "import random\nrandom.seed(1)\nprint(random.randint(1, 10))",
        "o": [
            "3",
            "random",
            "1",
            "10"
        ]
    },
    {
        "q": "What is 'Hard to Test' code usually implying?",
        "o": [
            "Poor design (Tight coupling, low cohesion)",
            "Complex problem",
            "Smart code",
            "Bad language"
        ]
    },
    {
        "q": "What is 'Testable Design'?",
        "o": [
            "Design facilitating easy testing (Modular, loose coupling)",
            "Design pattern",
            "UI design",
            "Graphic design"
        ]
    },
    {
        "q": "What is 'Dependency Injection'?",
        "o": [
            "Providing dependencies from outside rather than creating them inside",
            "Vaccine",
            "Drug",
            "Importing"
        ]
    },
    {
        "q": "How does DI help testing?",
        "o": [
            "Allows injecting mocks/stubs easily",
            "It doesn't",
            "It speeds up code",
            "It makes code smaller"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('Hello'.startswith('H'))",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Inversion of Control' (IoC)?",
        "o": [
            "Framework calls your code, rather than you calling library",
            "Turning upside down",
            "Controlling reverse",
            "Looping"
        ]
    },
    {
        "q": "What is 'Service Locator'?",
        "o": [
            "Pattern to obtain dependencies (often considered anti-pattern vs DI)",
            "GPS",
            "Google Maps",
            "Phone book"
        ]
    },
    {
        "q": "Why prefer DI over Service Locator/Global State?",
        "o": [
            "Dependencies are explicit in constructor, easier to mock",
            "Service locator is slow",
            "Globals are fast",
            "DI is cooler"
        ]
    },
    {
        "q": "What is 'Constructor Injection'?",
        "o": [
            "Passing dependencies via constructor parameters",
            "Building injection",
            "Medical term",
            "Code init"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class B:\n    def __init__(self, x=1):\n        self.x = x\nprint(B(2).x)",
        "o": [
            "2",
            "1",
            "x",
            "Error"
        ]
    },
    {
        "q": "What is 'Setter Injection'?",
        "o": [
            "Passing dependencies via setter methods",
            "Setting values",
            "Variable assignment",
            "Property change"
        ]
    },
    {
        "q": "What is 'Interface Injection'?",
        "o": [
            "Dependency provides an injector method that will inject the dependency into any client that passes itself (rare)",
            "UI injection",
            "Screen injection",
            "Port injection"
        ]
    },
    {
        "q": "What is 'Mock Object' library in Python?",
        "o": [
            "unittest.mock",
            "pytest-mock",
            "Mockito",
            "JMock"
        ]
    },
    {
        "q": "What is 'Mock Object' library in Java?",
        "o": [
            "Mockito",
            "unittest",
            "Jest",
            "Mocha"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(' '.join(['A', 'B']))",
        "o": [
            "A B",
            "AB",
            "A,B",
            "Error"
        ]
    },
    {
        "q": "What is 'Test Suite' vs 'Test Case'?",
        "o": [
            "Suite is a collection of Cases; Case tests a single scenario",
            "Same thing",
            "Case is bigger",
            "Suite is smaller"
        ]
    },
    {
        "q": "What is 'NUnit'?",
        "o": [
            "Unit testing framework for .NET",
            "New Unit",
            "Number Unit",
            "Java tool"
        ]
    },
    {
        "q": "What is 'JUnit'?",
        "o": [
            "Unit testing framework for Java",
            "Javascript Unit",
            "Junior Unit",
            ".NET tool"
        ]
    },
    {
        "q": "What is 'PyTest'?",
        "o": [
            "Testing framework for Python",
            "Pie Test",
            "PHP Test",
            "Perl Test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(type(None))",
        "o": [
            "<class 'NoneType'>",
            "None",
            "Null",
            "Error"
        ]
    },
    {
        "q": "What is 'RSpec'?",
        "o": [
            "BDD framework for Ruby",
            "Rust Spec",
            "Requirements Spec",
            "Random Spec"
        ]
    },
    {
        "q": "What is 'Jasmine'?",
        "o": [
            "BDD framework for JavaScript",
            "A flower",
            "Java tool",
            "Python tool"
        ]
    },
    {
        "q": "What is 'Jest'?",
        "o": [
            "Testing framework for JavaScript (often React)",
            "A joke",
            "Java Test",
            "Just Test"
        ]
    },
    {
        "q": "What is 'Selenium'?",
        "o": [
            "Tool for automating web browsers (E2E testing)",
            "Element",
            "Unit test tool",
            "Mock tool"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = [1, 2, 3]\nprint(x[-1])",
        "o": [
            "3",
            "1",
            "2",
            "Error"
        ]
    },
    {
        "q": "What is 'Cypress'?",
        "o": [
            "Frontend testing tool for the modern web",
            "A tree",
            "Backend tool",
            "Database"
        ]
    },
    {
        "q": "What is 'Table-Driven Tests'?",
        "o": [
            "Using a data table (inputs/expected outputs) to drive a single test logic",
            "Testing tables",
            "Database testing",
            "Excel testing"
        ]
    },
    {
        "q": "Benefit of Table-Driven Tests?",
        "o": [
            "Reduces duplication for testing multiple inputs against same logic",
            "Faster execution",
            "More code",
            "Better UI"
        ]
    },
    {
        "q": "What is 'Parameterized Test'?",
        "o": [
            "Running the same test method multiple times with different parameters",
            "Variable test",
            "Function test",
            "Loop test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(bool(''))",
        "o": [
            "False",
            "True",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Equivalence Partitioning'?",
        "o": [
            "Dividing inputs into valid/invalid classes and testing one from each",
            "Equality",
            "Math",
            "Partitions"
        ]
    },
    {
        "q": "What is 'Boundary Value Analysis'?",
        "o": [
            "Testing at the boundaries of input ranges (e.g. min, max, min-1, max+1)",
            "Testing borders",
            "Testing limits",
            "Testing fences"
        ]
    },
    {
        "q": "Why test boundaries?",
        "o": [
            "Errors often occur at the edges of input domains (off-by-one bugs)",
            "It is fun",
            "It is fast",
            "It is easy"
        ]
    },
    {
        "q": "What is 'Mockist' vs 'Classicist'?",
        "o": [
            "Mockist uses mocks for dependencies; Classicist uses real objects where possible",
            "Old vs New",
            "Fast vs Slow",
            "Good vs Bad"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(pow(2, 3))",
        "o": [
            "8",
            "6",
            "5",
            "Error"
        ]
    },
    {
        "q": "What is 'Test Contamination'?",
        "o": [
            "When tests share state or resources, causing one test's outcome to depend on another",
            "Virus in test",
            "Dirty code",
            "Bad smell"
        ]
    },
    {
        "q": "How to fix Test Contamination?",
        "o": [
            "Isolate tests by resetting state (DB, globals, files) in teardown or using transactions",
            "Delete tests",
            "Reboot server",
            "Ignore it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sum([1, 2, 3]))",
        "o": [
            "6",
            "5",
            "123",
            "Error"
        ]
    },
    {
        "q": "What is 'Nondeterministic Test'?",
        "o": [
            "A test that passes sometimes and fails others with same inputs (Flaky)",
            "Random test",
            "Statistical test",
            "Quantum test"
        ]
    },
    {
        "q": "Common cause of Nondeterminism?",
        "o": [
            "Reliance on system time, random numbers, or network latency without mocking",
            "Bad CPU",
            "Gamma rays",
            "User error"
        ]
    },
    {
        "q": "How to handle Time in TDD?",
        "o": [
            "Inject a Clock/TimeProvider dependency to mock the current time",
            "Wait for time to pass",
            "Change system clock",
            "Use sleep()"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "from datetime import datetime\n# Assume mocked now\nprint(isinstance(datetime.now(), object))",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'SUT' in testing context?",
        "o": [
            "System Under Test",
            "System Unit Test",
            "Single Unit Test",
            "Simple Unit Test"
        ]
    },
    {
        "q": "What is 'DOC' in testing context?",
        "o": [
            "Depended-on Component (Collaborator)",
            "Doctor",
            "Document",
            "Docker"
        ]
    },
    {
        "q": "What is 'Indirect Input'?",
        "o": [
            "Data the SUT receives from DOCs (e.g. return value from a stub)",
            "User input",
            "Keyboard",
            "Mouse"
        ]
    },
    {
        "q": "What is 'Indirect Output'?",
        "o": [
            "Data/Action the SUT sends to DOCs (e.g. calling a method on a mock)",
            "Print to screen",
            "Log file",
            "Return value"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(map(str, [1, 2])))",
        "o": [
            "['1', '2']",
            "[1, 2]",
            "'1', '2'",
            "Error"
        ]
    },
    {
        "q": "What is 'Test specific subclass'?",
        "o": [
            "Subclassing SUT in test to override specific methods for testing access",
            "A bad class",
            "A new feature",
            "Production code"
        ]
    },
    {
        "q": "Is Test specific subclass good practice?",
        "o": [
            "It can be useful for legacy code, but generally preferring Composition/DI is better",
            "Yes, always",
            "No, never",
            "Only in C++"
        ]
    },
    {
        "q": "What is 'Self Shunt' pattern?",
        "o": [
            "The test class itself acts as the mock/collaborator for the SUT",
            "Electric shock",
            "Redirecting traffic",
            "Looping"
        ]
    },
    {
        "q": "Benefits of Self Shunt?",
        "o": [
            "Avoids creating separate mock classes for simple interfaces",
            "Safer",
            "Faster",
            "More code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(divmod(5, 2))",
        "o": [
            "(2, 1)",
            "2",
            "1",
            "2.5"
        ]
    },
    {
        "q": "What is 'Humble Object' pattern?",
        "o": [
            "Extracting logic from hard-to-test classes (e.g. GUI) into testable logic classes, leaving the original humble",
            "Honest object",
            "Simple object",
            "Small object"
        ]
    },
    {
        "q": "When to use Humble Object?",
        "o": [
            "When frameworks (UI, DB) make testing difficult; keeps framework binding thin",
            "Always",
            "Never",
            "For math"
        ]
    },
    {
        "q": "What is 'Test Hook'?",
        "o": [
            "Feature added to production code specifically to enabling testing (logging, state check)",
            "Fishing hook",
            "Coat hook",
            "A trap"
        ]
    },
    {
        "q": "Are Test Hooks desirable?",
        "o": [
            "Ideally avoid modifying production code for tests, but sometimes necessary",
            "Yes, add everywhere",
            "No, strictly forbidden",
            "Maybe"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = frozenset([1, 2])\nprint(len(x))",
        "o": [
            "2",
            "1",
            "Frozen",
            "Error"
        ]
    },
    {
        "q": "What is 'Property-based Testing' (e.g. Hypothesis)?",
        "o": [
            "Generates many random inputs to verify properties (invariants) hold true",
            "Testing real estate",
            "Testing object properties",
            "Testing getters"
        ]
    },
    {
        "q": "How does Property-based testing extend TDD?",
        "o": [
            "Finds edge cases you didn't think of manually",
            "Replaces TDD",
            "Slows down TDD",
            "Makes TDD harder"
        ]
    },
    {
        "q": "What is 'Snapshot Testing'?",
        "o": [
            "Comparing current output (e.g. UI render, JSON) against a stored 'golden' file",
            "Taking photos",
            "Screen recording",
            "Backup"
        ]
    },
    {
        "q": "Downside of Snapshot Testing?",
        "o": [
            "Brittle (changes easily), hard to review diffs, easy to blindly update",
            "Too fast",
            "Uses disk space",
            "None"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sorted([3, 1, 2]))",
        "o": [
            "[1, 2, 3]",
            "[3, 2, 1]",
            "[3, 1, 2]",
            "Error"
        ]
    },
    {
        "q": "What is 'Test Pyramid'?",
        "o": [
            "Metaphor for test distribution: Many Units (base), some Integration, few E2E (top)",
            "Egyptian tomb",
            "Geometry shape",
            "Scheme"
        ]
    },
    {
        "q": "What is 'Test Ice Cream Cone' (Anti-pattern)?",
        "o": [
            "Few unit tests, many manual/E2E tests (inverted pyramid)",
            "Tasty treat",
            "Cold test",
            "Melting code"
        ]
    },
    {
        "q": "Why is Ice Cream Cone bad?",
        "o": [
            "Tests are slow, expensive, and brittle; feedback is delayed",
            "Too much sugar",
            "Brain freeze",
            "Sticky keyboard"
        ]
    },
    {
        "q": "What is 'Test Trophy' (Frontend context)?",
        "o": [
            "Emphasis on Integration tests over Unit tests for component interactions",
            "Winning",
            "Award",
            "Prize"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(str(1) + '2')",
        "o": [
            "12",
            "3",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Approval Testing'?",
        "o": [
            "Verifying output by approving a result once, then comparing future runs (like Snapshots)",
            "Manager approval",
            "Code review",
            "Voting"
        ]
    },
    {
        "q": "What is 'Golden Master' technique?",
        "o": [
            "Capturing output of legacy code to ensure refactoring doesn't change it",
            "Kung Fu",
            "A movie",
            "Gold coin"
        ]
    },
    {
        "q": "Difference between Golden Master and Characterization Test?",
        "o": [
            "Golden Master is often large scale (whole system output); Characterization is more granular",
            "None",
            "Gold is better",
            "Character is better"
        ]
    },
    {
        "q": "What is 'Fake Object'?",
        "o": [
            "Working implementation (e.g. HashMap instead of DB) used for testing speed/simplicity",
            "A lie",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "d = {1: 'a', 2: 'b'}\nprint(d.get(3, 'c'))",
        "o": [
            "c",
            "None",
            "Error",
            "3"
        ]
    },
    {
        "q": "What is 'Deterministic'?",
        "o": [
            "Given same input, always produces same output",
            "Determined dev",
            "Fast code",
            "Random code"
        ]
    },
    {
        "q": "Why TDD prefers Deterministic tests?",
        "o": [
            "Reliability; nondeterminism leads to flakiness and distrust",
            "Speed",
            "Simplicity",
            "Ease"
        ]
    },
    {
        "q": "What is 'Wait' in testing?",
        "o": [
            "Pausing execution to allow async operation to complete (avoid if possible)",
            "Stopping",
            "Service",
            "Queue"
        ]
    },
    {
        "q": "Why is 'Thread.sleep' bad in tests?",
        "o": [
            "Slows down suite unnecessarily; brittle (might not wait long enough)",
            "CPU usage",
            "Hard to read",
            "It is fine"
        ]
    },
    {
        "q": "Alternative to sleep in async tests?",
        "o": [
            "Polling with timeout, callbacks, or awaiting promises/futures",
            "Looping forever",
            "Guessing",
            "Ignoring"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(1 == 1.0)",
        "o": [
            "True",
            "False",
            "Error",
            "1"
        ]
    },
    {
        "q": "What is 'Orphaned Test'?",
        "o": [
            "Test that is never run (removed from suite or ignored)",
            "Sad test",
            "Lost test",
            "Child test"
        ]
    },
    {
        "q": "What is 'Rotting Test'?",
        "o": [
            "Test that is failing but ignored for so long it becomes irrelevant",
            "Old food",
            "Smelly test",
            "Bad code"
        ]
    },
    {
        "q": "What is 'Evergreen' tests?",
        "o": [
            "Tests that always pass (reliable)",
            "Trees",
            "Plants",
            "Color"
        ]
    },
    {
        "q": "Can failing tests be good?",
        "o": [
            "Yes, if they reveal a bug or missing feature (Red phase)",
            "No, never",
            "Only on Fridays",
            "If you like red"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(' '.isspace())",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Given-When-Then'?",
        "o": [
            "BDD syntax for test structure (Setup, Action, Assertion)",
            "Time travel",
            "Logic gate",
            "English grammar"
        ]
    },
    {
        "q": "Does TDD use Given-When-Then?",
        "o": [
            "Yes, it maps to Arrange-Act-Assert",
            "No, only BDD",
            "No, forbidden",
            "Only in Cucumber"
        ]
    },
    {
        "q": "What is 'Contract Testing'?",
        "o": [
            "Verifying that service provider adheres to the contract expected by consumer",
            "Legal docs",
            "Signing papers",
            "Unit testing"
        ]
    },
    {
        "q": "What is 'PACT'?",
        "o": [
            "Tool for Consumer-Driven Contract testing",
            "Agreement",
            "Treaty",
            "Library"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\ndel l[1]\nprint(l)",
        "o": [
            "[1, 3]",
            "[1, 2]",
            "[2, 3]",
            "Error"
        ]
    },
    {
        "q": "What is 'Seam' in generic code?",
        "o": [
            "Place where behavior can be altered (e.g. for testing) without editing source",
            "Fabric join",
            "Crack",
            "Line"
        ]
    },
    {
        "q": "How to create a Seam?",
        "o": [
            "Dependency Injection, Polymorphism, Virtual methods",
            "Tearing code",
            "Cutting code",
            "Gluing code"
        ]
    },
    {
        "q": "What is 'Code Smell'?",
        "o": [
            "Surface indication that usually corresponds to a deeper problem in the system",
            "Bad odor",
            "Perfume",
            "Dirty screen"
        ]
    },
    {
        "q": "What is 'Duplicated Code' smell?",
        "o": [
            "Same code structure in two or more places",
            "Copy paste",
            "Backup",
            "Redundancy"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(max([1, 2], [3]))",
        "o": [
            "[3]",
            "[1, 2]",
            "3",
            "Error"
        ]
    },
    {
        "q": "What is 'Shotgun Surgery' smell?",
        "o": [
            "One change requires small edits in many different classes",
            "Medical term",
            "Weapon",
            "Coding style"
        ]
    },
    {
        "q": "What is 'Divergent Change' smell?",
        "o": [
            "One class is changed in different ways for different reasons (Violates SRP)",
            "Movie",
            "Book",
            "Road"
        ]
    },
    {
        "q": "What is 'Large Class' smell?",
        "o": [
            "Class doing too much (God Class)",
            "School",
            "Big file",
            "Many lines"
        ]
    },
    {
        "q": "What is 'Lazy Class' smell?",
        "o": [
            "Class that doesn't do enough to justify its existence",
            "Sleeping code",
            "Slow code",
            "Bad student"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('123'.isdigit())",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Data Class' smell?",
        "o": [
            "Class with only fields and getters/setters, no behavior",
            "Database",
            "Struct",
            "Good practice"
        ]
    },
    {
        "q": "Is Data Class always bad?",
        "o": [
            "Not always (DTOs), but in domain model it implies anemic model",
            "Yes always",
            "No never",
            "It is best"
        ]
    },
    {
        "q": "What is 'Refused Bequest' smell?",
        "o": [
            "Subclass uses only few of parents methods/data",
            "Legal term",
            "Inheritance",
            "Will"
        ]
    },
    {
        "q": "What is 'Comments' smell?",
        "o": [
            "Comments used to explain bad code instead of refactoring it",
            "Documentation",
            "Notes",
            "Helpful text"
        ]
    },
    {
        "q": "TDD stance on comments?",
        "o": [
            "Code should be self-documenting; comments are for 'why', not 'what'",
            "Write many comments",
            "No comments ever",
            "Comments are code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(zip([1], [2])))",
        "o": [
            "[(1, 2)]",
            "[1, 2]",
            "[[1], [2]]",
            "Error"
        ]
    },
    {
        "q": "What is 'Parallel Inheritance Hierarchies' smell?",
        "o": [
            "Every time you make a subclass of A, you must also make a subclass of B",
            "Parallel lines",
            "Geometry",
            "Family tree"
        ]
    },
    {
        "q": "What is 'Speculative Generality' smell?",
        "o": [
            "Code created for future features that don't exist yet (over-engineering)",
            "Stock market",
            "Gambling",
            "Planning"
        ]
    },
    {
        "q": "Does TDD prevent Speculative Generality?",
        "o": [
            "Yes, by focusing on passing only the current test case (YAGNI)",
            "No",
            "Increases it",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Temporary Field' smell?",
        "o": [
            "Instance variable set only in certain circumstances",
            "Temp file",
            "Cache",
            "Buffer"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(round(2.5))",
        "o": [
            "2",
            "3",
            "2.5",
            "Error"
        ]
    },
    {
        "q": "What is 'Middle Man' smell?",
        "o": [
            "Class delegating all work to another class",
            "Broker",
            "Manager",
            "Proxy"
        ]
    },
    {
        "q": "Refactoring Middle Man?",
        "o": [
            "Remove Middle Man, talk to delegate directly",
            "Add more layers",
            "Hire more",
            "Keep it"
        ]
    },
    {
        "q": "What is 'Alternative Classes with Different Interfaces'?",
        "o": [
            "Classes doing same thing but with different method names",
            "Polymorphism",
            "Confusion",
            "Clones"
        ]
    },
    {
        "q": "How to fix Alternative Classes?",
        "o": [
            "Rename methods, Move Method, Extract Superclass to unify interface",
            "Delete them",
            "Ignore them",
            "Wrap them"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('a'.upper())",
        "o": [
            "A",
            "a",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Incomplete Library Class'?",
        "o": [
            "Library doesn't provide feature you need",
            "Bad book",
            "Missing page",
            "Empty shelf"
        ]
    },
    {
        "q": "Fixing Incomplete Library Class?",
        "o": [
            "Introduce Foreign Method or Introduce Local Extension",
            "Write new library",
            "Hack it",
            "Complain"
        ]
    },
    {
        "q": "What is 'Data Clumps' smell?",
        "o": [
            "Data items that always hang around together (e.g. x, y, z coords)",
            "Clustering",
            "Database",
            "Arrays"
        ]
    },
    {
        "q": "Fixing Data Clumps?",
        "o": [
            "Extract Class / Introduce Parameter Object",
            "Group in array",
            "Stringify",
            "Ignore"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(bool(None))",
        "o": [
            "False",
            "True",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Switch Statements' smell (OO context)?",
        "o": [
            "Complex switches on type codes often imply missing Polymerphism",
            "Light switch",
            "Network switch",
            "Toggle"
        ]
    },
    {
        "q": "Refactoring Switch Statements?",
        "o": [
            "Replace Conditional with Polymorphism",
            "Use If-Else",
            "Use Dictionary",
            "Delete it"
        ]
    },
    {
        "q": "What is 'Single Responsibility Principle' (SRP)?",
        "o": [
            "A class should have only one reason to change",
            "Do one thing",
            "Solo work",
            "Management rule"
        ]
    },
    {
        "q": "Does TDD encourage SRP?",
        "o": [
            "Yes, easier to test small, focused classes",
            "No",
            "No opinion",
            "Prevents it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2]\nl.clear()\nprint(len(l))",
        "o": [
            "0",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Open/Closed Principle'?",
        "o": [
            "Software entities should be open for extension, but closed for modification",
            "Door rule",
            "Store hours",
            "Security"
        ]
    },
    {
        "q": "What is 'Liskov Substitution Principle'?",
        "o": [
            "Subtypes must be substitutable for their base types",
            "Replacement rule",
            "Sports rule",
            "Coding standard"
        ]
    },
    {
        "q": "What is 'Interface Segregation Principle'?",
        "o": [
            "Clients should not be forced to depend on interfaces they do not use",
            "Separation",
            "Segregation",
            "Isolation"
        ]
    },
    {
        "q": "What is 'Dependency Inversion Principle'?",
        "o": [
            "Depend on abstractions, not on concretions",
            "Upside down",
            "Inversion",
            "Abstract art"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sum((1, 2)))",
        "o": [
            "3",
            "12",
            "Error",
            "0"
        ]
    },
    {
        "q": "What is 'Behavioral Subtyping'?",
        "o": [
            "Subtypes should behave like their parent types (LSP logic)",
            "Behavioral science",
            "Psychology",
            "Class hierarchy"
        ]
    },
    {
        "q": "What is 'Test Isolation' mechanism?",
        "o": [
            "Process or Sandbox that ensures tests run without interference (e.g. DB rollback)",
            "Quarantine",
            "Mask",
            "Vacuum"
        ]
    },
    {
        "q": "What is 'Test Harness'?",
        "o": [
            "Collection of software and test data configured to test a program unit",
            "Safety gear",
            "Horse gear",
            "Test runner"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(min(1, 2, 3))",
        "o": [
            "1",
            "3",
            "2",
            "Error"
        ]
    },
    {
        "q": "What is 'Object Mother' pattern?",
        "o": [
            "Class that contains factory methods for creating objects for tests",
            "Parent object",
            "Creator",
            "God object"
        ]
    },
    {
        "q": "Difference between Object Mother and Test Data Builder?",
        "o": [
            "Object Mother provides fixed standard objects; Builder allows flexibility in overriding fields",
            "Name",
            "Gender",
            "None"
        ]
    },
    {
        "q": "What is 'Test Double'?",
        "o": [
            "Generic term for any object that replaces a production object for testing purposes",
            "Two tests",
            "Clone",
            "Copy"
        ]
    },
    {
        "q": "What are types of Test Doubles?",
        "o": [
            "Dummy, Fake, Stub, Spy, Mock",
            "Clone, Copy, Paste",
            "1, 2, 3",
            "Alpha, Beta"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(' '.join('ab'))",
        "o": [
            "a b",
            "ab",
            "a,b",
            "Error"
        ]
    },
    {
        "q": "What is 'Humble Dialog Box'?",
        "o": [
            "Applying Humble Object pattern to GUI dialogs to move logic to Presenter",
            "Polite box",
            "Simple UI",
            "Alert helper"
        ]
    },
    {
        "q": "What is 'Presentational Logic' vs 'Business Logic'?",
        "o": [
            "How to show data (View/Presenter) vs Rules of data (Model)",
            "Colors vs Math",
            "CSS vs SQL",
            "Buttons vs Text"
        ]
    },
    {
        "q": "What is 'Passive View'?",
        "o": [
            "A view that has no logic and is controlled entirely by presenter (Humble Object)",
            "Lazy view",
            "Static HTML",
            "Image"
        ]
    },
    {
        "q": "What is 'Supervising Controller'?",
        "o": [
            "View handles simple data binding/synchronization; Controller handles complex logic",
            "Boss",
            "Manager",
            "Admin"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(abs(-10.5))",
        "o": [
            "10.5",
            "-10.5",
            "10",
            "Error"
        ]
    },
    {
        "q": "What is 'Obscure Test' smell?",
        "o": [
            "Test is hard to understand (doesn't tell a story)",
            "Dark test",
            "Hidden test",
            "Secret test"
        ]
    },
    {
        "q": "Causes of Obscure Test?",
        "o": [
            "Mystery Guest, General Fixture, Irrelevant Information",
            "Bad font",
            "Low light",
            "Tiny screen"
        ]
    },
    {
        "q": "What is 'Mystery Guest' smell?",
        "o": [
            "Test uses external resources (file, db) whose content is not visible in the test code",
            "Surprise visitor",
            "Ghost",
            "Stranger"
        ]
    },
    {
        "q": "What is 'General Fixture' smell?",
        "o": [
            "Fixture setup is too large and sets up things not needed for the specific test",
            "Plumbing",
            "Tool",
            "Generic code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('1,2,3'.split(','))",
        "o": [
            "['1', '2', '3']",
            "['1,2,3']",
            "1 2 3",
            "Error"
        ]
    },
    {
        "q": "What is 'Irrelevant Information' smell?",
        "o": [
            "Test contains hardcoded values that don't affect the outcome but distract reader",
            "Spam",
            "Noise",
            "Ads"
        ]
    },
    {
        "q": "What is 'Hard-Coded Test Data' smell?",
        "o": [
            "Data buried in test body instead of being clear variables/constants",
            "Stone tablet",
            "Firmware",
            "ROM"
        ]
    },
    {
        "q": "What is 'Test Logic in Production' smell?",
        "o": [
            "Production code contains 'if (testing) ...' logic",
            "Bad practice",
            "Debug mode",
            "Flag"
        ]
    },
    {
        "q": "What is 'Conditional Test Logic' smell?",
        "o": [
            "Test contains loops are if statements (tests should be linear)",
            "Complex test",
            "Smart test",
            "Branching"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(all([True, True]))",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Test Method vs Test Class' scope?",
        "o": [
            "Setup per method (fresh) vs Setup per class (shared)",
            "Small vs Big",
            "Local vs Global",
            "Private vs Public"
        ]
    },
    {
        "q": "What is 'Derived Value' in tests?",
        "o": [
            "Calculating expected value in test (logic duplication) vs Hardcoding expected value",
            "Math",
            "Function",
            "Variable"
        ]
    },
    {
        "q": "Should you calculate expectation in test?",
        "o": [
            "Avoid it; if calculation is wrong, test passes incorrectly. Use literals.",
            "Yes always",
            "Maybe",
            "If difficult"
        ]
    },
    {
        "q": "What is 'Verify at the End'?",
        "o": [
            "Assertions should be at the end of the test (AAA)",
            "Check later",
            "Final check",
            "Last step"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(any([True, False]))",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Delta Assertion'?",
        "o": [
            "Asserting that a value changed by X, rather than absolute value",
            "Change check",
            "Diff check",
            "Relative check"
        ]
    },
    {
        "q": "What is 'Guard Assertion'?",
        "o": [
            "Assertion at start of test to ensure assumptions about initial state are correct",
            "Security",
            "Pre-check",
            "Safety"
        ]
    },
    {
        "q": "What is 'Unused Code' smell?",
        "o": [
            "Dead code that is never called; delete it",
            "Zombie code",
            "Ghost code",
            "Dusty code"
        ]
    },
    {
        "q": "Can you delete code in Refactor phase?",
        "o": [
            "Yes, if it is no longer needed or replaced",
            "No, never delete",
            "Only comment out",
            "Archive it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(float(1))",
        "o": [
            "1.0",
            "1",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Strangler Fig' pattern?",
        "o": [
            "Gradually replacing legacy system parts with new system until old is gone",
            "Plant",
            "Tree killer",
            "Rooting"
        ]
    },
    {
        "q": "How to use Strangler Fig with TDD?",
        "o": [
            "Build new components with TDD and route traffic to them incrementally",
            "Plant trees",
            "Write new app separate",
            "Delete old app"
        ]
    },
    {
        "q": "What is 'Branch by Abstraction'?",
        "o": [
            "Technique to make large scale changes incrementally using an abstraction layer",
            "Tree branch",
            "Git branch",
            "Abstract art"
        ]
    },
    {
        "q": "What is 'Tell, Don't Ask' principle?",
        "o": [
            "Tell objects what to do, don't ask for their state and do it yourself",
            "Commanding",
            "Questioning",
            "Secretive"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('abc'.upper())",
        "o": [
            "ABC",
            "abc",
            "Abc",
            "Error"
        ]
    },
    {
        "q": "What is 'Command-Query Separation' (CQS)?",
        "o": [
            "Method should be either a Command (action, side effect) or Query (return data), not both",
            "Question Answer",
            "Talk Listen",
            "Read Write"
        ]
    },
    {
        "q": "Does TDD favor CQS?",
        "o": [
            "Yes, queries are easy to test; commands are tested by side effects",
            "No",
            "Maybe",
            "Only for SQL"
        ]
    },
    {
        "q": "What is 'Law of Demeter' (Principle of Least Knowledge)?",
        "o": [
            "Module should not know about innards of objects it manipulates (don't talk to strangers)",
            "Greek law",
            "Privacy law",
            "Secret law"
        ]
    },
    {
        "q": "Does Message Chain violation relate to Demeter?",
        "o": [
            "Yes, chaining calls usually means knowing too much about structure",
            "No",
            "Maybe",
            "Unrelated"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(reversed([1, 2])))",
        "o": [
            "[2, 1]",
            "[1, 2]",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Fluent Interface'?",
        "o": [
            "API design where method chaining is used (obj.doThis().thenThat())",
            "Liquid code",
            "Smooth API",
            "Fast coding"
        ]
    },
    {
        "q": "Is Fluent Interface good for TDD?",
        "o": [
            "Can make test setup readable (builders), but can violate Demeter in implementation",
            "Always good",
            "Always bad",
            "Depends on language"
        ]
    },
    {
        "q": "What is 'Microtests'?",
        "o": [
            "Very small, fast unit tests (another name for TDD unit tests)",
            "Microscope",
            "Tiny tests",
            "Bacteria"
        ]
    },
    {
        "q": "What is 'Domain Driven Design' (DDD)?",
        "o": [
            "Approach to software development connecting implementation to an evolving model",
            "Web domains",
            "Hosting",
            "Graphics"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sorted([2, 1]))",
        "o": [
            "[1, 2]",
            "[2, 1]",
            "Error",
            "None"
        ]
    },
    {
        "q": "TDD and DDD relationship?",
        "o": [
            "Complementary; TDD helps verify the Domain Model correctness",
            "Enemies",
            "Competitors",
            "Different worlds"
        ]
    },
    {
        "q": "What is 'Ubiquitous Language'?",
        "o": [
            "Common language shared by devs and domain experts",
            "Latin",
            "English",
            "Code"
        ]
    },
    {
        "q": "What is 'Bounded Context'?",
        "o": [
            "Explicit boundary within which a domain model exists",
            "Fence",
            "Wall",
            "Limit"
        ]
    },
    {
        "q": "What is 'Value Object'?",
        "o": [
            "Object defined by its attributes, immutable, no identity",
            "Money",
            "Variable",
            "Const"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sum([10, 20]))",
        "o": [
            "30",
            "1020",
            "Error",
            "2"
        ]
    },
    {
        "q": "What is 'Entity'?",
        "o": [
            "Object defined by its identity, continues through time",
            "Ghost",
            "Person",
            "Being"
        ]
    },
    {
        "q": "What is 'Aggregate'?",
        "o": [
            "Cluster of domain objects that can be treated as a single unit",
            "Rock",
            "Sand",
            "Total"
        ]
    },
    {
        "q": "What is 'Repository' pattern?",
        "o": [
            "Abstraction of a collection of objects (usually DB access)",
            "Storage",
            "Bin",
            "Archive"
        ]
    },
    {
        "q": "Why mock Repository in TDD?",
        "o": [
            "To test domain logic without touching the database (speed)",
            "To save disk",
            "To be lazy",
            "No reason"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('1' + '1')",
        "o": [
            "11",
            "2",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Adapter' pattern?",
        "o": [
            "Allows incompatible interfaces to work together",
            "Plug",
            "Converter",
            "Charger"
        ]
    },
    {
        "q": "What is 'Hexagonal Architecture' (Ports and Adapters)?",
        "o": [
            "Architecture checking isolation of core logic from external details",
            "Beehive",
            "Six sides",
            "Shape"
        ]
    },
    {
        "q": "Does TDD fit Hexagonal Architecture?",
        "o": [
            "Yes, perfectly; allows testing core logic via ports without adapters",
            "No",
            "Bad fit",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Clean Architecture'?",
        "o": [
            "Uncle Bob's consolidation of independent architecture principles",
            "Cleaning",
            "Maid",
            "Building"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(int('10'))",
        "o": [
            "10",
            "1",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is 'SOLID' principles?",
        "o": [
            "SRP, OCP, LSP, ISP, DIP",
            "Hard",
            "Rock",
            "Gas"
        ]
    },
    {
        "q": "How TDD relates to SOLID?",
        "o": [
            "TDD tends to drive code towards SOLID design via refactoring",
            "No relation",
            "Opposite",
            "Confusion"
        ]
    },
    {
        "q": "What is 'Primitive Obsession' fix?",
        "o": [
            "Replace Data Value with Object",
            "Delete it",
            "Use int",
            "Use string"
        ]
    },
    {
        "q": "What is 'Feature Toggle'?",
        "o": [
            "Configuration to enable/disable feature at runtime",
            "Switch",
            "Button",
            "Lever"
        ]
    },
    {
        "q": "Testing with Feature Toggles?",
        "o": [
            "Test both states (On/Off) if necessary",
            "Test only on",
            "Test only off",
            "Don't test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(len({'a': 1, 'b': 2}))",
        "o": [
            "2",
            "1",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Pair Programming'?",
        "o": [
            "Two devs, one computer",
            "Dating",
            "Double work",
            "Fast typing"
        ]
    },
    {
        "q": "What is 'Mob Programming'?",
        "o": [
            "Whole team, one computer",
            "Gang",
            "Crowd",
            "Meeting"
        ]
    },
    {
        "q": "Ping-Pong pattern benefits?",
        "o": [
            "Keeps both pairs engaged and enforces TDD flow",
            "Fun",
            "Exercise",
            "Sport"
        ]
    },
    {
        "q": "Driver vs Navigator?",
        "o": [
            "Driver types; Navigator thinks/reviews",
            "Car",
            "Boat",
            "Plane"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(2 * 3)",
        "o": [
            "6",
            "5",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Pomodoro'?",
        "o": [
            "Time management (25min work, 5min break)",
            "Tomato",
            "Pasta",
            "Fruit"
        ]
    },
    {
        "q": "Can you use Pomodoro with TDD?",
        "o": [
            "Yes, helps focus; often time a TDD cycle to a pomodoro",
            "No",
            "Illegal",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Kata' origin?",
        "o": [
            "Martial Arts (forms)",
            "Cooking",
            "Dancing",
            "Singing"
        ]
    },
    {
        "q": "Does TDD guarantee bug-free?",
        "o": [
            "No, reduces probability but logic errors still possible",
            "Yes",
            "Absolutely",
            "Magic"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(10 / 2)",
        "o": [
            "5.0",
            "5",
            "2",
            "Error"
        ]
    },
    {
        "q": "What is 'Over-testing'?",
        "o": [
            "Testing trivial code, internals, or tautologies",
            "Too much work",
            "Boring",
            "Slow"
        ]
    },
    {
        "q": "Signs of Over-testing?",
        "o": [
            "Refactoring breaks many tests (Fragile Tests)",
            "Green bar",
            "Fast tests",
            "Happy dev"
        ]
    },
    {
        "q": "What is 'Fragile Test'?",
        "o": [
            "Test that fails when implementation changes but behavior doesn't",
            "Glass test",
            "Weak test",
            "Old test"
        ]
    },
    {
        "q": "How to fix Fragile Tests?",
        "o": [
            "Test behavior (public interface), not implementation details",
            "Delete them",
            "Glue them",
            "Wrap them"
        ]
    },
    {
        "q": "What is 'TDD' in one sentence?",
        "o": [
            "Design and development technique where you write tests before code",
            "Testing tool",
            "QA process",
            "Deployment script"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('end'.upper())",
        "o": [
            "END",
            "End",
            "end",
            "Error"
        ]
    }
]