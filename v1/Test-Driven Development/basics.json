[
    {
        "q": "What is the primary goal of Test-Driven Development (TDD)?",
        "o": [
            "To write clean code that works",
            "To write code faster",
            "To test existing code",
            "To eliminate all bugs"
        ]
    },
    {
        "q": "Which step comes first in the TDD cycle?",
        "o": [
            "Write a failing test",
            "Write the implementation code",
            "Refactor the code",
            "Run all tests"
        ]
    },
    {
        "q": "What color represents a failing test in the Red-Green-Refactor cycle?",
        "o": [
            "Red",
            "Green",
            "Blue",
            "Yellow"
        ]
    },
    {
        "q": "What color represents a passing test in the Red-Green-Refactor cycle?",
        "o": [
            "Green",
            "Red",
            "Orange",
            "Purple"
        ]
    },
    {
        "q": "What is the next step after writing a failing test in TDD?",
        "o": [
            "Write just enough code to pass the test",
            "Refactor the code",
            "Write another failing test",
            "Write valid comments"
        ]
    },
    {
        "q": "In TDD, when should you refactor your code?",
        "o": [
            "After the test passes",
            "Before writing the test",
            "While writing the test",
            "When the test fails"
        ]
    },
    {
        "q": "Why should the new test fail initially?",
        "o": [
            "To confirm the test is effectively testing the feature",
            "To ensure the test runner works",
            "To check for syntax errors",
            "To prove the code is broken"
        ]
    },
    {
        "q": "What does the 'Green' phase in Red-Green-Refactor signify?",
        "o": [
            "The test now passes",
            "The code is fully optimized",
            "The code is ready for production",
            "The test is failing"
        ]
    },
    {
        "q": "Which of these is a core principle of TDD?",
        "o": [
            "Write tests before writing code",
            "Write tests after writing code",
            "Write tests only for bugs",
            "Write tests by QA team"
        ]
    },
    {
        "q": "What is the scope of a unit test in TDD?",
        "o": [
            "A small units of code like a function",
            "The entire application",
            "Database connections only",
            "User interface only"
        ]
    },
    {
        "q": "How much code should you write to pass a failing test?",
        "o": [
            "The minimum amount necessary",
            "The complete feature implementation",
            "As much as possible",
            "Enough to cover future requirements"
        ]
    },
    {
        "q": "What happens if a test passes without writing any code?",
        "o": [
            "The test is likely invalid or testing nothing",
            "The code is already perfect",
            "You should skip to the next feature",
            "The compiler is optimized"
        ]
    },
    {
        "q": "What is 'Refactoring' in the context of TDD?",
        "o": [
            "Improving code structure without changing behavior",
            "Adding new features",
            "Fixing bugs",
            "Writing documentation"
        ]
    },
    {
        "q": "Why is 'minimal code' emphasized in TDD?",
        "o": [
            "To avoid over-engineering",
            "To save disk space",
            "To make the code look simple",
            "To reduce compilation time"
        ]
    },
    {
        "q": "Who typically writes the tests in TDD?",
        "o": [
            "The developer writing the code",
            "The project manager",
            "The QA engineer",
            "The client"
        ]
    },
    {
        "q": "What is a benefit of TDD regarding documentation?",
        "o": [
            "Tests serve as living documentation",
            "It automatically generates PDF manuals",
            "It removes the need for comments",
            "It writes the README file"
        ]
    },
    {
        "q": "What does TDD stand for?",
        "o": [
            "Test-Driven Development",
            "Test-Debug-Deploy",
            "Technical-Design-Document",
            "Time-Driven-Deployment"
        ]
    },
    {
        "q": "Which phase of TDD focuses on code quality and design?",
        "o": [
            "Refactor",
            "Red",
            "Green",
            "Blue"
        ]
    },
    {
        "q": "Ideally, how often should you run your tests in TDD?",
        "o": [
            "Frequently, after every small change",
            "Once a day",
            "Before every commit",
            "Once a week"
        ]
    },
    {
        "q": "What is a 'regression' in software development?",
        "o": [
            "When a change breaks existing functionality",
            "Improving the code speed",
            "Adding a new feature",
            "Deleting old code"
        ]
    },
    {
        "q": "How does TDD help with regression?",
        "o": [
            "By catching breaking changes immediately",
            "By preventing code changes",
            "By automatically fixing bugs",
            "By documenting the errors"
        ]
    },
    {
        "q": "What is the 'Simplicity' principle in TDD?",
        "o": [
            "Solution should be as simple as possible",
            "Code should be complex",
            "Tests should be long",
            "Features should be hidden"
        ]
    },
    {
        "q": "Can TDD be applied to legacy code?",
        "o": [
            "Yes, but it may be challenging",
            "No, only for new projects",
            "No, legacy code cannot be tested",
            "Yes, it is automatic"
        ]
    },
    {
        "q": "What is a 'test suite'?",
        "o": [
            "A collection of test cases",
            "A single test",
            "A testing tool",
            "A bug report"
        ]
    },
    {
        "q": "In TDD, tests are typically written in the same language as:",
        "o": [
            "The application code",
            "Binary code",
            "Assembly language",
            "Database queries"
        ]
    },
    {
        "q": "What is 'Test Coverage'?",
        "o": [
            "The percentage of code executed by tests",
            "The number of tests written",
            "The time taken to run tests",
            "The number of bugs found"
        ]
    },
    {
        "q": "Does 100% test coverage guarantee bug-free code?",
        "o": [
            "No",
            "Yes",
            "Maybe",
            "Only in TDD"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def add(a, b):\n    return a + b\n\n# logical test\nprint(add(2, 3) == 5)",
        "o": [
            "True",
            "False",
            "5",
            "Error"
        ]
    },
    {
        "q": "What defines a 'unit' in unit testing?",
        "o": [
            "The smallest testable part of an application",
            "A whole file",
            "A database table",
            "A user session"
        ]
    },
    {
        "q": "Which tool is commonly used for TDD in Java?",
        "o": [
            "JUnit",
            "PyTest",
            "Mocha",
            "RSpec"
        ]
    },
    {
        "q": "Which tool is commonly used for TDD in Python?",
        "o": [
            "PyTest",
            "JUnit",
            "NUnit",
            "Jest"
        ]
    },
    {
        "q": "Which tool is commonly used for TDD in JavaScript?",
        "o": [
            "Jest",
            "JUnit",
            "PyTest",
            "RSpec"
        ]
    },
    {
        "q": "What is 'Red' state indicative of?",
        "o": [
            "Test failure due to missing code",
            "Syntax error",
            "Compilation error",
            "Test success"
        ]
    },
    {
        "q": "Should tests depend on each other?",
        "o": [
            "No, they should be independent",
            "Yes, for performance",
            "Yes, to share state",
            "It doesn't matter"
        ]
    },
    {
        "q": "What is 'State Pollution' in testing?",
        "o": [
            "One test affecting the outcome of another",
            "Writing dirty code",
            "Using global variables correctly",
            "Testing state machines"
        ]
    },
    {
        "q": "What is a 'Stub'?",
        "o": [
            "A piece of code used to stand in for some other programming functionality",
            "A broken test",
            "A database connection",
            "A type of bug"
        ]
    },
    {
        "q": "What is a 'Mock'?",
        "o": [
            "An object that simulates the behavior of real objects",
            "A copy of the production code",
            "A failing test",
            "A unit test"
        ]
    },
    {
        "q": "When writing a test, what is the 'Arrange' step?",
        "o": [
            "Setting up the conditions for the test",
            "Executing the code",
            "Verifying the result",
            "Cleaning up"
        ]
    },
    {
        "q": "When writing a test, what is the 'Act' step?",
        "o": [
            "Executing the function or method being tested",
            "Setting up variables",
            "Asserting the results",
            "Writing the test function"
        ]
    },
    {
        "q": "When writing a test, what is the 'Assert' step?",
        "o": [
            "Verifying that the result matches expectations",
            "Running the code",
            "Setting up the test",
            "Defining variables"
        ]
    },
    {
        "q": "What helps keep TDD cycles short?",
        "o": [
            "Testing small increments of functionality",
            "Writing all tests at once",
            "Writing complex code",
            "Ignoring refactoring"
        ]
    },
    {
        "q": "What is the disadvantage of TDD initially?",
        "o": [
            "It may feel slower due to writing tests first",
            "It creates more bugs",
            "It requires expensive tools",
            "It makes code unreadable"
        ]
    },
    {
        "q": "Long term, how does TDD affect development speed?",
        "o": [
            "Increases speed by reducing debugging time",
            "Decreases speed significantly",
            "Has no effect",
            "Stops development"
        ]
    },
    {
        "q": "What is 'Positive Testing'?",
        "o": [
            "Testing that the system correctly handles valid input",
            "Testing to break the system",
            "Testing with invalid input",
            "Testing error messages"
        ]
    },
    {
        "q": "What is 'Negative Testing'?",
        "o": [
            "Testing how the system handles invalid input",
            "Testing valid input",
            "Deleting tests",
            "Testing only happy paths"
        ]
    },
    {
        "q": "In TDD, if you find a bug, what should you do first?",
        "o": [
            "Write a test that reproduces the bug",
            "Fix the code immediately",
            "Delete the code",
            "Document the bug"
        ]
    },
    {
        "q": "What is the purpose of 'Clean Code' in Refactoring?",
        "o": [
            "To make code easy to understand and maintain",
            "To make code shorter",
            "To use less memory",
            "To pass tests faster"
        ]
    },
    {
        "q": "Does TDD replace QA?",
        "o": [
            "No, TDD is a development practice, QA checks quality",
            "Yes, TDD eliminates the need for QA",
            "Yes, automated tests are enough",
            "No, QA writes the unit tests"
        ]
    },
    {
        "q": "What is an 'Integration Test'?",
        "o": [
            "Testing how different units work together",
            "Testing a single function",
            "Testing the UI only",
            "Testing the database only"
        ]
    },
    {
        "q": "Is TDD only for Object-Oriented Programming?",
        "o": [
            "No, it can be used with other paradigms too",
            "Yes, strictly for OOP",
            "No, only for Functional Programming",
            "Yes, only for Java"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def multiply(a, b):\n    return a * b\n\n# TDD assert\nassert multiply(4, 5) == 20\nprint('Passed')",
        "o": [
            "Passed",
            "Failed",
            "20",
            "Error"
        ]
    },
    {
        "q": "In TDD, what should you do if a test is hard to write?",
        "o": [
            "Consider if the design is too complex",
            "Skip the test",
            "Write the code first",
            "Use a different language"
        ]
    },
    {
        "q": "What is 'Baby Steps' in TDD?",
        "o": [
            "Making small, incremental changes",
            "Writing extensive code at once",
            "Writing all tests first",
            "Using simple languages"
        ]
    },
    {
        "q": "Why is 'Design' improved by TDD?",
        "o": [
            "Because testable code tends to be modular",
            "Because tests design the code",
            "It adds graphical elements",
            "It enforces specific patterns"
        ]
    },
    {
        "q": "What is a 'Test Runner'?",
        "o": [
            "Software that executes tests and reports results",
            "The person running tests",
            "The IDE",
            "The compiler"
        ]
    },
    {
        "q": "What is an 'Assertion'?",
        "o": [
            "A statement that checks if a condition is true",
            "A variable declaration",
            "A comment",
            "A loop"
        ]
    },
    {
        "q": "If you change code and a test fails, what is that called?",
        "o": [
            "Breaking a test",
            "Refactoring",
            "Optimizing",
            "Green phase"
        ]
    },
    {
        "q": "What implies that code is 'Testable'?",
        "o": [
            "It is loosely coupled and modular",
            "It is very short",
            "It has no dependencies",
            "It is written in Python"
        ]
    },
    {
        "q": "What is 'Legacy Code' often defined as in TDD context?",
        "o": [
            "Code without tests",
            "Old code",
            "Code written in C",
            "Code by former employees"
        ]
    },
    {
        "q": "What is the order of AAA pattern?",
        "o": [
            "Arrange, Act, Assert",
            "Act, Arrange, Assert",
            "Assert, Act, Arrange",
            "Arrange, Assert, Act"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def is_positive(n):\n    return n > 0\n\nprint(is_positive(-5))",
        "o": [
            "False",
            "True",
            "-5",
            "0"
        ]
    },
    {
        "q": "Why avoid 'Global State' in TDD?",
        "o": [
            "It causes tests to interfere with each other",
            "It is slower",
            "It uses too much memory",
            "It is forbidden syntax"
        ]
    },
    {
        "q": "What is 'Continuous Integration' relation to TDD?",
        "o": [
            "CI servers run the TDD tests automatically",
            "They are the same thing",
            "CI writes the tests",
            "TDD replaces CI"
        ]
    },
    {
        "q": "What does 'DRY' stand for?",
        "o": [
            "Don't Repeat Yourself",
            "Do Repeat Yourself",
            "Don't Run Yet",
            "Do Run Yesterday"
        ]
    },
    {
        "q": "How does Refactoring support DRY?",
        "o": [
            "By removing duplicate code",
            "By adding comments",
            "By writing more tests",
            "By separating files"
        ]
    },
    {
        "q": "What is 'KISS' principle?",
        "o": [
            "Keep It Simple, Stupid",
            "Keep It Short, Sweet",
            "Keep It Safe, Secure",
            "Keep It Super Fast"
        ]
    },
    {
        "q": "In TDD, code is written to satisfy:",
        "o": [
            "The failing test",
            "The manager",
            "The documentation",
            "The user interface"
        ]
    },
    {
        "q": "What is a common pitfall in TDD?",
        "o": [
            "Writing tests that are too large or complex",
            "Running tests too often",
            "Refactoring too much",
            "Using red color"
        ]
    },
    {
        "q": "What is 'White Box Testing'?",
        "o": [
            "Testing with knowledge of internal structures",
            "Testing the UI only",
            "Testing without code access",
            "Testing by users"
        ]
    },
    {
        "q": "What is 'Black Box Testing'?",
        "o": [
            "Testing without knowledge of internal structures",
            "Testing with code access",
            "Unit testing",
            "Refactoring"
        ]
    },
    {
        "q": "Unit tests in TDD are usually:",
        "o": [
            "White Box",
            "Black Box",
            "Integration tests",
            "User Acceptance Tests"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def get_status(code):\n    if code == 200:\n        return 'OK'\n    return 'Error'\n\nprint(get_status(200))",
        "o": [
            "OK",
            "Error",
            "200",
            "None"
        ]
    },
    {
        "q": "What is a 'Fixture' in testing?",
        "o": [
            "A fixed state used as a baseline for tests",
            "A broken test",
            "A bug fix",
            "A type of mock"
        ]
    },
    {
        "q": "Why rename variables during Refactoring?",
        "o": [
            "To improve clarity and intent",
            "To make them shorter",
            "To obfuscate code",
            "To follow old conventions"
        ]
    },
    {
        "q": "What is 'YAGNI'?",
        "o": [
            "You Aren't Gonna Need It",
            "You Are Good Now Indeed",
            "You Always Get New Items",
            "Yes A Good New Idea"
        ]
    },
    {
        "q": "How does TDD encourage YAGNI?",
        "o": [
            "By writing code only for the current test case",
            "By planning features ahead",
            "By writing extra code",
            "By guessing future needs"
        ]
    },
    {
        "q": "What is the role of assertions?",
        "o": [
            "To validate the outcome",
            "To run the code",
            "To print output",
            "To define variables"
        ]
    },
    {
        "q": "If a test fails, but the code is correct, what is the issue?",
        "o": [
            "The test itself is wrong",
            "The computer is broken",
            "The compiler is wrong",
            "It is a feature"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def is_even(n):\n    return n % 2 == 0\n\nprint(is_even(3))",
        "o": [
            "False",
            "True",
            "3",
            "Error"
        ]
    },
    {
        "q": "Should unit tests access the database?",
        "o": [
            "No, mock the database for speed",
            "Yes, always",
            "Yes, for data integrity",
            "Only on Mondays"
        ]
    },
    {
        "q": "What is the benefit of fast tests?",
        "o": [
            "Developers run them more often",
            "They use less electricity",
            "They are harder to read",
            "They cover less code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def greet(name):\n    return f'Hello, {name}'\n\nprint(greet('TDD'))",
        "o": [
            "Hello, TDD",
            "Hello, name",
            "Hello, ",
            "Error"
        ]
    },
    {
        "q": "In TDD, a test should fail for:",
        "o": [
            "Exactly one reason",
            "Multiple reasons",
            "Any reason",
            "No reason"
        ]
    },
    {
        "q": "What is 'flaky' test?",
        "o": [
            "A test that sometimes passes and sometimes fails",
            "A test that always fails",
            "A test that always passes",
            "A fast test"
        ]
    },
    {
        "q": "How do you handle flaky tests?",
        "o": [
            "Investigate and fix the cause, or remove it",
            "Ignore them",
            "Run them repeatedly until pass",
            "Comment them out"
        ]
    },
    {
        "q": "What is code 'Coupling'?",
        "o": [
            "The degree of interdependence between software modules",
            "Coding with a partner",
            "Linking libraries",
            "Internet connection"
        ]
    },
    {
        "q": "What does TDD aim for regarding coupling?",
        "o": [
            "Low coupling",
            "High coupling",
            "No coupling",
            "Tight coupling"
        ]
    },
    {
        "q": "What is code 'Cohesion'?",
        "o": [
            "The degree to which elements inside a module belong together",
            "Code sticking together",
            "File size",
            "Number of lines"
        ]
    },
    {
        "q": "What does TDD aim for regarding cohesion?",
        "o": [
            "High cohesion",
            "Low cohesion",
            "No cohesion",
            "Random cohesion"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def subtract(a, b):\n    return a - b\n\nprint(subtract(10, 5) > 0)",
        "o": [
            "True",
            "False",
            "5",
            "10"
        ]
    },
    {
        "q": "If you are following TDD, when do you write the production code?",
        "o": [
            "Only after you have a failing test",
            "Before the test",
            "Whenever you want",
            "After the project is done"
        ]
    },
    {
        "q": "What is the primary artifact of TDD besides code?",
        "o": [
            "A suite of regression tests",
            "A Gantt chart",
            "UML diagrams",
            "User manual"
        ]
    },
    {
        "q": "What makes a test 'Fragile'?",
        "o": [
            "It breaks with every internal implementation change",
            "It is written in old language",
            "It is too small",
            "It is too fast"
        ]
    },
    {
        "q": "How to avoid fragile tests?",
        "o": [
            "Test behavior, not implementation details",
            "Test implementation details",
            "Don't write tests",
            "Write very long tests"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class Calc:\n    def double(self, x):\n        return x * 2\n\nc = Calc()\nprint(c.double(4))",
        "o": [
            "8",
            "4",
            "16",
            "2"
        ]
    },
    {
        "q": "In TDD, we want tests to be:",
        "o": [
            "Readable and maintenance-friendly",
            "Cryptic",
            "As short as possible regardless of clarity",
            "Hidden from other developers"
        ]
    },
    {
        "q": "What comes after 'Green'?",
        "o": [
            "Refactor",
            "Red",
            "Stop",
            "Deploy"
        ]
    },
    {
        "q": "When is a task considered 'done' in TDD?",
        "o": [
            "When tests pass and code is refactored",
            "When code is written",
            "When test is written",
            "When deadline is met"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def check_val(x):\n    if x:\n        return 'Yes'\n    return 'No'\n\nprint(check_val(0))",
        "o": [
            "No",
            "Yes",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is a 'Regression Test'?",
        "o": [
            "Verifying that recent changes haven't broken existing features",
            "Testing new features",
            "Testing performance",
            "Testing UI design"
        ]
    },
    {
        "q": "What is the primary reason for writing a failing test first?",
        "o": [
            "To ensure the test actually fails when the feature is missing",
            "To satisfy the manager",
            "To create documentation",
            "To check compile speed"
        ]
    },
    {
        "q": "In TDD, what does 'Green' mean generally?",
        "o": [
            "Tests are passing",
            "Tests are failing",
            "Code is compiling",
            "Code is deployed"
        ]
    },
    {
        "q": "What is the main risk of writing code without tests first?",
        "o": [
            "Writing hard-to-test code",
            "Writing too fast",
            "Writing too slow",
            "Using wrong variable names"
        ]
    },
    {
        "q": "What is 'Triangulation' in TDD?",
        "o": [
            "Using multiple test cases to generalize a solution",
            "Testing three times",
            "Using three monitors",
            "Testing triangles"
        ]
    },
    {
        "q": "When should you stop writing tests for a specific feature?",
        "o": [
            "When all requirements are met and tests pass",
            "When you are tired",
            "When the file is too big",
            "When the deadline passes"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def diff(a, b):\n    return abs(a - b)\n\nprint(diff(10, 15))",
        "o": [
            "5",
            "-5",
            "10",
            "15"
        ]
    },
    {
        "q": "What is a 'Test Double'?",
        "o": [
            "A generic term for any object that replaces a production object for testing",
            "A duplicate test",
            "A failing test",
            "A database backup"
        ]
    },
    {
        "q": "Which of these is a type of Test Double?",
        "o": [
            "Spy",
            "Clone",
            "Copy",
            "Twin"
        ]
    },
    {
        "q": "What is the 'Dummy' test double?",
        "o": [
            "Objects passed around but never actually used",
            "A stupid test",
            "A failed test",
            "A slow test"
        ]
    },
    {
        "q": "What is the 'Fake' test double?",
        "o": [
            "Working implementation but not suitable for production",
            "A broken implementation",
            "A copy of production code",
            "A malicious code"
        ]
    },
    {
        "q": "Example of a 'Fake'?",
        "o": [
            "In-memory database",
            "Production database",
            "Real credit card gateway",
            "User interface"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def is_null(x):\n    return x is None\n\nprint(is_null(''))",
        "o": [
            "False",
            "True",
            "Null",
            "None"
        ]
    },
    {
        "q": "What is 'Code Rot'?",
        "o": [
            "Slow deterioration of software quality over time",
            "Virus infection",
            "Hardware failure",
            "Deleting code"
        ]
    },
    {
        "q": "How does TDD prevent Code Rot?",
        "o": [
            "By ensuring constant refactoring and regression testing",
            "It doesn't",
            "By locking the code",
            "By encrypting the code"
        ]
    },
    {
        "q": "What is the relationship between TDD and Agile?",
        "o": [
            "TDD is a technical practice often used in Agile",
            "They are opposites",
            "TDD replaces Agile",
            "Agile forbids TDD"
        ]
    },
    {
        "q": "What is 'Velocity' in Agile/TDD context?",
        "o": [
            "The rate at which a team delivers working software",
            "The speed of the CPU",
            "The network speed",
            "The typing speed"
        ]
    },
    {
        "q": "Does TDD improve Velocity initially?",
        "o": [
            "Usually no, it's an investment",
            "Yes, immediately",
            "It stops velocity",
            "It makes it infinite"
        ]
    },
    {
        "q": "Does TDD improve Velocity over long term?",
        "o": [
            "Yes, by reducing maintenance overhead",
            "No, it slows it down",
            "No change",
            "Depends on the weather"
        ]
    },
    {
        "q": "What is 'Technical Debt'?",
        "o": [
            "Implied cost of additional rework caused by choosing an easy solution now",
            "Money owed to developers",
            "Cost of servers",
            "Loan from bank"
        ]
    },
    {
        "q": "How does TDD manage Technical Debt?",
        "o": [
            "By encouraging refactoring and keeping code clean",
            "By ignoring it",
            "By paying it with bitcoin",
            "By rewriting everything"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "vals = [1, 2, 3]\n\ndef sum_list(lst):\n    return sum(lst)\n\nprint(sum_list(vals))",
        "o": [
            "6",
            "5",
            "123",
            "Error"
        ]
    },
    {
        "q": "What is 'Acceptance Test Driven Development' (ATDD)?",
        "o": [
            "Writing acceptance tests before developers begin coding",
            "Writing unit tests only",
            "Testing only at the end",
            "Testing by customers manually"
        ]
    },
    {
        "q": "What is the difference between TDD and ATDD?",
        "o": [
            "TDD is developer-focused; ATDD is business-focused",
            "No difference",
            "TDD is for testers",
            "ATDD is for managers only"
        ]
    },
    {
        "q": "What is 'Gherkin'?",
        "o": [
            "A readable language for defining test cases",
            "A pickle",
            "A programming language like Java",
            "A database"
        ]
    },
    {
        "q": "Common keywords in Gherkin?",
        "o": [
            "Given, When, Then",
            "If, Else, Switch",
            "Try, Catch, Finally",
            "Select, From, Where"
        ]
    },
    {
        "q": "What is a 'Unit' in OOP TDD often considered?",
        "o": [
            "A Class",
            "A Namespace",
            "A Project",
            "A Variable"
        ]
    },
    {
        "q": "What is 'Obvious Implementation'?",
        "o": [
            "Writing the exact solution code directly if it's simple",
            "Writing complex code",
            "Guessing the solution",
            "Copying from StackOverflow"
        ]
    },
    {
        "q": "When should you use 'Obvious Implementation'?",
        "o": [
            "When the solution is trivial",
            "When you don't know the answer",
            "When the test is failing",
            "Never"
        ]
    },
    {
        "q": "What is the 'Fake It' strategy?",
        "o": [
            "Return a hardcoded constant to pass the test first",
            "Lie about the test results",
            "Write a fake test",
            "Skip the test"
        ]
    },
    {
        "q": "Why use 'Fake It'?",
        "o": [
            "To distinguish between 'missing implementation' and 'buggy implementation'",
            "To cheat",
            "To speed up compilation",
            "To avoid work"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def get_first(lst):\n    return lst[0] if lst else None\n\nprint(get_first([]))",
        "o": [
            "None",
            "[]",
            "Error",
            "0"
        ]
    },
    {
        "q": "What is 'Mutation Testing'?",
        "o": [
            "Modifying program code slightly to check if tests fail",
            "Testing biological mutations",
            "Changing test code",
            "Random testing"
        ]
    },
    {
        "q": "What is the goal of Mutation Testing?",
        "o": [
            "To assess the quality of the test suite",
            "To find bugs in production",
            "To optimize performance",
            "To refactor code"
        ]
    },
    {
        "q": "If a mutant survives (test still passes), what does it mean?",
        "o": [
            "The test suite is missing a test case for that logic",
            "The code is robust",
            "The mutant is friendly",
            "The compiler optimized it"
        ]
    },
    {
        "q": "What is 'Behavior Verification'?",
        "o": [
            "Checking that certain methods were called",
            "Checking the return value",
            "Checking the variable state",
            "Checking the UI"
        ]
    },
    {
        "q": "What is 'State Verification'?",
        "o": [
            "Checking the state of the object after operation",
            "Checking method calls",
            "Checking logs",
            "Checking performance"
        ]
    },
    {
        "q": "Mocks are typically used for:",
        "o": [
            "Behavior Verification",
            "State Verification",
            "Integration Testing",
            "Performance Testing"
        ]
    },
    {
        "q": "Stubs are typically used for:",
        "o": [
            "State Verification / Providing indirect inputs",
            "Behavior Verification",
            "Database schemas",
            "UI layouts"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def power(a, b):\n    return a ** b\n\nprint(power(2, 3))",
        "o": [
            "8",
            "6",
            "5",
            "9"
        ]
    },
    {
        "q": "What is 'Test Pollution'?",
        "o": [
            "Side effects from one test affecting others",
            "Dirty code",
            "Too many tests",
            "Bad variable names"
        ]
    },
    {
        "q": "How to prevent Test Pollution?",
        "o": [
            "Proper teardown and isolation",
            "Running tests in random order only",
            "Deleting tests",
            "Restarting computer"
        ]
    },
    {
        "q": "What is 'SetUp' method utilized for?",
        "o": [
            "Code that runs before each test",
            "Code that runs after each test",
            "Code that runs once per suite",
            "Code that installs the app"
        ]
    },
    {
        "q": "What is 'TearDown' method utilized for?",
        "o": [
            "Code that runs after each test",
            "Code that runs before each test",
            "Code that runs once per suite",
            "Code that uninstalls the app"
        ]
    },
    {
        "q": "Can you have multiple asserts in one test?",
        "o": [
            "Yes, but generally discouraged if testing different concepts",
            "No, strictly one",
            "Yes, unlimited is best",
            "No, compiler error"
        ]
    },
    {
        "q": "Why is 'one assert per test' a common guideline?",
        "o": [
            "Pinpoints failure exactly",
            "Saves memory",
            "Runs faster",
            "Looks better"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def contains_a(text):\n    return 'a' in text\n\nprint(contains_a('apple'))",
        "o": [
            "True",
            "False",
            "a",
            "Error"
        ]
    },
    {
        "q": "What is 'Characterization Test'?",
        "o": [
            "Tests that lock down existing behavior of legacy code",
            "Tests for characters",
            "Tests for fonts",
            "Tests for performance"
        ]
    },
    {
        "q": "When is the best time to write Characterization Tests?",
        "o": [
            "Before refactoring legacy code",
            "After rewriting code",
            "Never",
            "When creating new features"
        ]
    },
    {
        "q": "What is 'Golden Master' testing?",
        "o": [
            "Capturing output of known good version and comparing future outputs",
            "Testing only the master branch",
            "Testing with gold data",
            "Testing payments"
        ]
    },
    {
        "q": "What is 'Transformation Priority Premise'?",
        "o": [
            "Choosing simpler code transformations to pass tests",
            "Prioritizing transformers",
            "Ordering tests by speed",
            "A project management tool"
        ]
    },
    {
        "q": "Which is a simpler transformation?",
        "o": [
            "Constant to Variable",
            "Scalar to Array",
            "Statement to Recursion",
            "Null to Object"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 10\nif x > 5:\n    print('Big')\nelse:\n    print('Small')",
        "o": [
            "Big",
            "Small",
            "10",
            "Error"
        ]
    },
    {
        "q": "In TDD, exceptions should be:",
        "o": [
            "Tested as expected behavior when appropriate",
            "Avoided",
            "Ignored",
            "Silenced"
        ]
    },
    {
        "q": "How do you test for an exception?",
        "o": [
            "Assert that the code throws the expected exception",
            "Use a try-catch block and print error",
            "Hope it doesn't crash",
            "Check the logs manually"
        ]
    },
    {
        "q": "What is a 'Test Spy'?",
        "o": [
            "A test double that records calls made to it",
            "A secret agent",
            "A hidden test",
            "A password cracker"
        ]
    },
    {
        "q": "What is the difference between Mock and Spy?",
        "o": [
            "Mocks verify behavior internally; Spies allow external verification",
            "Mocks are red; Spies are blue",
            "No difference",
            "Spies are for database only"
        ]
    },
    {
        "q": "What is 'Parametrized Testing'?",
        "o": [
            "Running the same test logic with different inputs",
            "Testing parameters only",
            "Testing setting files",
            "Hardcoding values"
        ]
    },
    {
        "q": "Benefit of Parametrized Testing?",
        "o": [
            "Reduces code duplication for similar test cases",
            "runs faster",
            "uses less memory",
            "automatically fixes bugs"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def area(w, h):\n    return w * h\n\nprint(area(5, 5))",
        "o": [
            "25",
            "10",
            "55",
            "Error"
        ]
    },
    {
        "q": "What should you do with 'commented out' tests?",
        "o": [
            "Delete them or fix them",
            "Keep them forever",
            "Uncomment them even if they fail",
            "Move them to another file"
        ]
    },
    {
        "q": "Why is 'Testing Private Methods' controversial?",
        "o": [
            "Tests should focus on public interface behavior",
            "Private methods are slow",
            "It is illegal",
            "Private methods don't exist"
        ]
    },
    {
        "q": "Standard advice for testing private methods?",
        "o": [
            "Test them indirectly through public methods",
            "Make them public just for testing",
            "Don't test the class",
            "Use reflection always"
        ]
    },
    {
        "q": "What is 'Inside-Out' TDD?",
        "o": [
            "Starting with the core domain logic/entities",
            "Starting with the UI",
            "Starting with the database",
            "Starting with API"
        ]
    },
    {
        "q": "What is 'Outside-In' TDD?",
        "o": [
            "Starting with the acceptance test/GUI and working inward",
            "Starting with database",
            "Starting with unit tests",
            "Starting with utils"
        ]
    },
    {
        "q": "Outside-In TDD is also known as:",
        "o": [
            "London School / Mockist",
            "Detroit School",
            "Chicago School",
            "Classic TDD"
        ]
    },
    {
        "q": "Inside-Out TDD is also known as:",
        "o": [
            "Detroit School / Classicist",
            "London School",
            "Mockist",
            "GUI driven"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def reverse_str(s):\n    return s[::-1]\n\nprint(reverse_str('tdd'))",
        "o": [
            "ddt",
            "tdd",
            "d",
            "Error"
        ]
    },
    {
        "q": "What is 'E2E' testing?",
        "o": [
            "End-to-End testing",
            "Easy-to-Edit",
            "Error-to-Error",
            "Event-to-Event"
        ]
    },
    {
        "q": "Where does E2E fit in the Testing Pyramid?",
        "o": [
            "At the top (fewest tests)",
            "At the bottom (most tests)",
            "In the middle",
            "It is the whole pyramid"
        ]
    },
    {
        "q": "Where do Unit Tests fit in the Testing Pyramid?",
        "o": [
            "At the bottom (most tests)",
            "At the top",
            "In the middle",
            "Replacing the pyramid"
        ]
    },
    {
        "q": "Why are E2E tests often fewer than Unit tests?",
        "o": [
            "They are slow and brittle",
            "They are easy to write",
            "They cover less",
            "They are not important"
        ]
    },
    {
        "q": "What is the 'Testing Pyramid' concept?",
        "o": [
            "A strategy for balancing different types of tests",
            "A scheme to make money",
            "A way to build pyramids",
            "A database structure"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def cube(x):\n    return x * x * x\n\nprint(cube(3))",
        "o": [
            "27",
            "9",
            "6",
            "333"
        ]
    },
    {
        "q": "Can you combine TDD with Pair Programming?",
        "o": [
            "Yes, it is a common practice (Ping-Pong Pair Programming)",
            "No, impossible",
            "Only for experts",
            "Only on weekends"
        ]
    },
    {
        "q": "What is 'Ping-Pong' Pair Programming?",
        "o": [
            "Person A writes failing test, Person B passes it and writes next failing test",
            "Playing table tennis",
            "Writing code separately",
            "Person A writes all tests"
        ]
    },
    {
        "q": "Does TDD guarantee good design?",
        "o": [
            "No, but it provides feedback to help create it",
            "Yes, always",
            "No, it ruins design",
            "Yes, automatically"
        ]
    },
    {
        "q": "If you struggle to write a test, it might indicate:",
        "o": [
            "High coupling or bad design",
            "You are tired",
            "The language is bad",
            "The computer is slow"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nl.append(4)\nprint(len(l))",
        "o": [
            "4",
            "3",
            "5",
            "Error"
        ]
    },
    {
        "q": "What is 'Hard-coded' value?",
        "o": [
            "Data embedded directly into the source code",
            "Encrypted data",
            "Database data",
            "User input"
        ]
    },
    {
        "q": "Should tests contain hard-coded values?",
        "o": [
            "Yes, often as expected results",
            "No, never",
            "Only numbers",
            "Only strings"
        ]
    },
    {
        "q": "What is 'System Under Test' (SUT)?",
        "o": [
            "The entity being tested",
            "The test runner",
            "The computer",
            "The operating system"
        ]
    },
    {
        "q": "Ideally, unit tests should run in:",
        "o": [
            "Milliseconds",
            "Minutes",
            "Hours",
            "Days"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def my_func(a=1, b=2):\n    return a + b\n\nprint(my_func(b=5))",
        "o": [
            "6",
            "3",
            "7",
            "Error"
        ]
    },
    {
        "q": "What is 'Dependency Injection'?",
        "o": [
            "Providing dependencies from the outside rather than creating them internally",
            "Vaccinating code",
            "Installing libraries",
            "Importing files"
        ]
    },
    {
        "q": "How does Dependency Injection help TDD?",
        "o": [
            "Makes it easier to swap real dependencies with mocks",
            "Makes code faster",
            "Makes code smaller",
            "It doesn't help"
        ]
    },
    {
        "q": "What is 'Inversion of Control'?",
        "o": [
            "A design principle where control flow is inverted",
            "Writing tests last",
            "Using global variables",
            "Reversing strings"
        ]
    },
    {
        "q": "What is a 'Test Fixture Teardown' important for?",
        "o": [
            "Cleaning up resources (files, db) to prevent side effects",
            "Deleting the code",
            "Stopping the computer",
            "Formatting the code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = 'Hello'\nprint(x.upper())",
        "o": [
            "HELLO",
            "Hello",
            "hello",
            "Error"
        ]
    },
    {
        "q": "What is 'Walking Skeleton'?",
        "o": [
            "A tiny implementation of the system that performs a small end-to-end function",
            "A Halloween decoration",
            "A broken code",
            "A missing feature"
        ]
    },
    {
        "q": "Why start with a Walking Skeleton?",
        "o": [
            "To validate architecture and automated build/deployment early",
            "To scare users",
            "To waste time",
            "To test UI colors"
        ]
    },
    {
        "q": "In TDD, do you write tests for third-party libraries?",
        "o": [
            "Generally no, unless verifying your assumption on how they work (Learning Tests)",
            "Yes, check their bugs",
            "Yes, always",
            "No, never"
        ]
    },
    {
        "q": "What is a 'Learning Test'?",
        "o": [
            "A test written to understand a third-party API",
            "A test for students",
            "A test that learns",
            "A quiz"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [10, 20, 30]\nprint(l.pop())",
        "o": [
            "30",
            "10",
            "20",
            "Error"
        ]
    },
    {
        "q": "What is 'Cyclomatic Complexity'?",
        "o": [
            "A metric indicating the complexity of a program",
            "A bicycle race",
            "A hardware spec",
            "A type of test"
        ]
    },
    {
        "q": "High Cyclomatic Complexity usually means:",
        "o": [
            "Harder to test and maintain",
            "Better code",
            "Faster code",
            "More secure"
        ]
    },
    {
        "q": "TDD tends to keep Cyclomatic Complexity:",
        "o": [
            "Lower",
            "Higher",
            "Constant",
            "Zero"
        ]
    },
    {
        "q": "What is 'Code Coverage' really measuring?",
        "o": [
            "Which lines of code were executed during tests",
            "The quality of the tests",
            "The correctness of the code",
            "The speed of the tests"
        ]
    },
    {
        "q": "What is the 'Law of Demeter'?",
        "o": [
            "Principle of Least Knowledge - don't talk to strangers",
            "Law of gravity",
            "Law of large numbers",
            "Testing law"
        ]
    },
    {
        "q": "How does TDD help adherence to Law of Demeter?",
        "o": [
            "By highlighting when setup becomes too complex due to deep chains",
            "It forces you to break it",
            "It doesn't affect it",
            "By using global variables"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class User:\n    def __init__(self, name):\n        self.name = name\n\nu = User('Alice')\nprint(u.name)",
        "o": [
            "Alice",
            "User",
            "Name",
            "Error"
        ]
    },
    {
        "q": "What is a 'Slow Test' often a sign of?",
        "o": [
            "Dependency on external systems (DB, Network, FileSystem)",
            "Too many assertions",
            "Too much logic",
            "Fast computer"
        ]
    },
    {
        "q": "How to fix a slow unit test?",
        "o": [
            "Mock the external dependencies",
            "Buy a faster computer",
            "Delete the test",
            "Run it less often"
        ]
    },
    {
        "q": "What is 'Deterministic' test?",
        "o": [
            "A test that produces the same result every time it runs",
            "A test that determines the future",
            "A random test",
            "A flaky test"
        ]
    },
    {
        "q": "What causes Non-Deterministic tests?",
        "o": [
            "Time dependency, random numbers, race conditions",
            "Hardcoded values",
            "Pure functions",
            "Static typing"
        ]
    },
    {
        "q": "How to test code that depends on current time?",
        "o": [
            "Inject a Clock/Time provider that can be mocked",
            "Wait for the time to match",
            "Change the system clock",
            "Use sleep()"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "import datetime\n# Assume mock\nclass MockDate:\n    def today(self):\n        return '2023-01-01'\n\nprint(MockDate().today())",
        "o": [
            "2023-01-01",
            "Today's Date",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Property-Based Testing'?",
        "o": [
            "Verifying that code satisfies properties for a wide range of inputs",
            "Testing real estate",
            "Testing class properties",
            "Testing only strings"
        ]
    },
    {
        "q": "How does Property-Based Testing differ from Example-Based Testing?",
        "o": [
            "Generates many random inputs checking general laws",
            "Checks specific hardcoded examples",
            "It is slower",
            "It is manual"
        ]
    },
    {
        "q": "What is 'Fuzz Testing'?",
        "o": [
            "Feeding invalid, unexpected, or random data to find crashes",
            "Testing fuzzy logic",
            "Testing UI blur",
            "Testing warm things"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return 'Inf'\n\nprint(divide(10, 0))",
        "o": [
            "Inf",
            "Error",
            "0",
            "10"
        ]
    },
    {
        "q": "What is 'Primitive Obsession'?",
        "o": [
            "Using primitive types instead of small objects for domain concepts",
            "Obsessing over old code",
            "Using only assembly",
            "Hating objects"
        ]
    },
    {
        "q": "How does TDD help fix Primitive Obsession?",
        "o": [
            "Encourages creating Value Objects to encapsulate behavior",
            "It forces primitives",
            "It bans integers",
            "It doesn't help"
        ]
    },
    {
        "q": "What is a 'Value Object'?",
        "o": [
            "An immutable object defined by its attributes, not identity",
            "A variable",
            "A database row",
            "A global constant"
        ]
    },
    {
        "q": "In TDD, when do you optimize for performance?",
        "o": [
            "Later, after correctness is verified and if needed",
            "First thing",
            "During Green phase always",
            "Before writing tests"
        ]
    },
    {
        "q": "Premature optimization is:",
        "o": [
            "The root of all evil",
            "Good practice",
            "Required by TDD",
            "The best way to code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nprint(l[-1])",
        "o": [
            "3",
            "1",
            "2",
            "Error"
        ]
    },
    {
        "q": "What is 'Zombie Code'?",
        "o": [
            "Code that is technically dead (unreachable) but still in the codebase",
            "Code that runs forever",
            "Viruses",
            "Code that bites"
        ]
    },
    {
        "q": "Does TDD help remove Zombie Code?",
        "o": [
            "Yes, if you only write code to pass tests, no dead code exists",
            "No, it creates more",
            "Yes, by burning it",
            "Only on Halloween"
        ]
    },
    {
        "q": "What is 'Shotgun Surgery'?",
        "o": [
            "A change requiring small edits to many different classes",
            "Medical procedure",
            "Deleting files randomly",
            "Renaming files"
        ]
    },
    {
        "q": "What does Shotgun Surgery indicate?",
        "o": [
            "Poor cohesion or high coupling",
            "Good design",
            "Fast coding",
            "Modular system"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "text = ' hello '\nprint(text.strip())",
        "o": [
            "hello",
            " hello ",
            "hello ",
            " hello"
        ]
    },
    {
        "q": "What is 'mocking the type' vs 'mocking the instance'?",
        "o": [
            "Mocking a class definition vs mocking a specific object",
            "Mocking fonts",
            "Mocking files",
            "No difference"
        ]
    },
    {
        "q": "Why prefer 'Interface-based' testing?",
        "o": [
            "Decouples tests from implementation details",
            "It is faster",
            "It is easier",
            "It looks better"
        ]
    },
    {
        "q": "What is 'Contract Testing'?",
        "o": [
            "Verifying that services communicate according to agreed specifications",
            "Testing legal contracts",
            "Testing employment",
            "Testing paper"
        ]
    },
    {
        "q": "What is the Consumer-Driven Contract?",
        "o": [
            "Consumers define expectations (contracts) required from Providers",
            "Providers dictate the API",
            "Managers decide contracts",
            "Users sign contracts"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "d = {'a': 1}\nprint(d.get('b', 0))",
        "o": [
            "0",
            "None",
            "Error",
            "1"
        ]
    },
    {
        "q": "What is a 'Test Factory'?",
        "o": [
            "A helper to create objects for testing",
            "A building",
            "A slow test",
            "A machine"
        ]
    },
    {
        "q": "What is 'Object Mother' pattern?",
        "o": [
            "A class creating predefined objects for tests",
            "A parent class",
            "A coding standard",
            "A database"
        ]
    },
    {
        "q": "Difference between Object Mother and Builder pattern in tests?",
        "o": [
            "Object Mother provides static fixed objects; Builder allows customization",
            "No difference",
            "Builder is for construction",
            "Object Mother is for inheritance"
        ]
    },
    {
        "q": "What is 'Fluent Interface' in testing assertions?",
        "o": [
            "Chained method calls usually reading like natural language",
            "Speaking multiple languages",
            "Fast typing",
            "Graphical interface"
        ]
    },
    {
        "q": "Example of Fluent Assertion?",
        "o": [
            "expect(value).to.be.equal(5)",
            "assert len(x) == 5",
            "if x != 5: error()",
            "check(x, 5)"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def func(*args):\n    return sum(args)\n\nprint(func(1, 2, 3))",
        "o": [
            "6",
            "1",
            "3",
            "Error"
        ]
    },
    {
        "q": "What is 'Divergent Change'?",
        "o": [
            "When one class is commonly changed in different ways for different reasons",
            "Versioning",
            "Branching code",
            "Merging code"
        ]
    },
    {
        "q": "What does Divergent Change violate?",
        "o": [
            "Single Responsibility Principle",
            "Open-Closed Principle",
            "Liskov Substitution",
            "Interface Segregation"
        ]
    },
    {
        "q": "What is 'Feature Envy'?",
        "o": [
            "A method that seems more interested in a class other than the one it is in",
            "Jealousy",
            "Copying features",
            "Stealing code"
        ]
    },
    {
        "q": "How to fix Feature Envy?",
        "o": [
            "Move the method to the class it envies",
            "Delete the method",
            "Hide the method",
            "Ignore it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "key = 'name'\nval = 'TDD'\nprint(f'{key}={val}')",
        "o": [
            "name=TDD",
            "key=val",
            "{key}={val}",
            "Error"
        ]
    },
    {
        "q": "What is 'Inappropriate Intimacy'?",
        "o": [
            "Classes that know too much about each other's privates",
            "Pair programming too close",
            "Sharing passwords",
            "Global variables"
        ]
    },
    {
        "q": "What is a 'God Class'?",
        "o": [
            "A class that does too much and knows too much",
            "A religious class",
            "A perfect class",
            "A small class"
        ]
    },
    {
        "q": "How to refactor a God Class?",
        "o": [
            "Extract Class / Decompose into smaller responsibilities",
            "Rename it",
            "Delete it",
            "Make it static"
        ]
    },
    {
        "q": "What is 'Spaghetti Code'?",
        "o": [
            "Unstructured and difficult-to-maintain code",
            "Italian code",
            "Code involving food",
            "Tasty code"
        ]
    },
    {
        "q": "What is 'Ravioli Code'?",
        "o": [
            "Code with lots of tiny, loosely coupled classes (sometimes hard to follow flow)",
            "Better than spaghetti",
            "Food code",
            "Bad code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = {1, 2, 2, 3}\nprint(len(s))",
        "o": [
            "3",
            "4",
            "2",
            "1"
        ]
    },
    {
        "q": "What is 'Speculative Generality'?",
        "o": [
            "Coding for future use cases that may never happen",
            "Investing",
            "General knowledge",
            "Guessing tests"
        ]
    },
    {
        "q": "How does TDD counter Speculative Generality?",
        "o": [
            "By focusing on current requirements (YAGNI)",
            "By predicting future",
            "By writing generic code",
            "It promotes it"
        ]
    },
    {
        "q": "What is 'Data Clumps'?",
        "o": [
            "Data items that often appear together (e.g., start and end date)",
            "Database clusters",
            "Arrays",
            "Big files"
        ]
    },
    {
        "q": "Refactoring for Data Clumps?",
        "o": [
            "Extract Class (e.g., DateRange)",
            "Separate them",
            "Delete them",
            "Use global vars"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(bool([]))",
        "o": [
            "False",
            "True",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Middle Man' smell?",
        "o": [
            "A class that delegates all its work to another class",
            "A manager",
            "A router",
            "A proxy"
        ]
    },
    {
        "q": "Refactoring Middle Man?",
        "o": [
            "Remove Middle Man / Inline",
            "Add more delegation",
            "Make it larger",
            "Pay him"
        ]
    },
    {
        "q": "What is 'Parallel Inheritance Hierarchies'?",
        "o": [
            "Every time you add a subclass to one hierarchy, you must add one to another",
            "Coding in parallel",
            "Threading",
            "Multiple inheritance"
        ]
    },
    {
        "q": "What is 'Message Chains'?",
        "o": [
            "A client asks one object for another, which asks another, etc.",
            "Email chains",
            "Messaging app",
            "Linked lists"
        ]
    },
    {
        "q": "Refactoring Message Chains?",
        "o": [
            "Hide Delegate / Extract Method",
            "Make chain longer",
            "Use more dots",
            "Ignore it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class Dog:\n    species = 'Canine'\n\nd1 = Dog()\nd2 = Dog()\nd1.species = 'Wolf'\nprint(d2.species)",
        "o": [
            "Canine",
            "Wolf",
            "Dog",
            "Error"
        ]
    },
    {
        "q": "What is 'Temporary Field'?",
        "o": [
            "A field set only in certain circumstances",
            "A temp variable",
            "A cache",
            "A timer"
        ]
    },
    {
        "q": "What is 'Refused Bequest'?",
        "o": [
            "Subclasses using only a few methods of their parents",
            "Rejecting money",
            "Inheriting debt",
            "Compilation error"
        ]
    },
    {
        "q": "What is 'Alternative Classes with Different Interfaces'?",
        "o": [
            "Classes doing the same thing but with different method names",
            "Polymorphism",
            "Interface segregation",
            "Overloading"
        ]
    },
    {
        "q": "How to fix Alternative Classes?",
        "o": [
            "Rename Method / Move Method / Extract Superclass",
            "Delete them",
            "Keep them",
            "Make them private"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def outer():\n    x = 1\n    def inner():\n        return x\n    return inner()\n\nprint(outer())",
        "o": [
            "1",
            "None",
            "Error",
            "x"
        ]
    },
    {
        "q": "What is 'Comment' smell?",
        "o": [
            "Using comments to explain bad code instead of fixing it",
            "Writing docs",
            "Annotations",
            "TODOs"
        ]
    },
    {
        "q": "TDD view on comments?",
        "o": [
            "Code and tests should be self-documenting; minimize comments",
            "Comments are mandatory every line",
            "No comments allowed ever",
            "Comments replace tests"
        ]
    },
    {
        "q": "What is 'Duplicate Code'?",
        "o": [
            "Identical or very similar code structure in more than one place",
            "Copy paste",
            "Backups",
            "Redundancy for safety"
        ]
    },
    {
        "q": "What is 'Long Method'?",
        "o": [
            "A procedure that is too long to understand easily",
            "A good method",
            "A detailed method",
            "A slow method"
        ]
    },
    {
        "q": "Refactoring Long Method?",
        "o": [
            "Extract Method",
            "Add comments",
            "Fold code",
            "Make it static"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "a = [1, 2]\nb = a\nb.append(3)\nprint(len(a))",
        "o": [
            "3",
            "2",
            "1",
            "0"
        ]
    },
    {
        "q": "What is 'Large Class'?",
        "o": [
            "A class meant to do too much",
            "A high school class",
            "Big object",
            "Main class"
        ]
    },
    {
        "q": "What is 'Long Parameter List'?",
        "o": [
            "A method call with too many arguments",
            "Flexible method",
            "Detailed config",
            "Secure method"
        ]
    },
    {
        "q": "Refactoring Long Parameter List?",
        "o": [
            "Introduce Parameter Object / Preserve Whole Object",
            "Remove parameters",
            "Use global variables",
            "Hardcode values"
        ]
    },
    {
        "q": "What is a 'Unit Test Framework'?",
        "o": [
            "Library providing tools to write and run tests",
            "A methodology",
            "A book",
            "A compiler"
        ]
    },
    {
        "q": "What is 'xUnit'?",
        "o": [
            "Collective name for standard unit testing frameworks (JUnit, NUnit, etc.)",
            "A specific tool",
            "Unknown unit",
            "Variables"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(type(lambda x: x))",
        "o": [
            "<class 'function'>",
            "<class 'lambda'>",
            "function",
            "Error"
        ]
    },
    {
        "q": "What is 'SUT' in xUnit patterns?",
        "o": [
            "System Under Test",
            "Standard Unit Test",
            "Special User Test",
            "Safe Unit Type"
        ]
    },
    {
        "q": "What is 'DOC' in xUnit patterns?",
        "o": [
            "Depended-On Component",
            "Document",
            "Doctor",
            "Docker"
        ]
    },
    {
        "q": "What is 'Fresh Fixture'?",
        "o": [
            "Creating a fresh test fixture for every test method",
            "Cleaning the room",
            "New computer",
            "Restarting IDE"
        ]
    },
    {
        "q": "What is 'Shared Fixture'?",
        "o": [
            "Reusing the same fixture instance across multiple tests",
            "Shared folder",
            "Shared memory",
            "Global variable"
        ]
    },
    {
        "q": "Pros of Fresh Fixture?",
        "o": [
            "Test isolation, no side effects",
            "Faster setup",
            "Less memory",
            "Easier to write"
        ]
    },
    {
        "q": "Pros of Shared Fixture?",
        "o": [
            "Performance (setup once)",
            "Isolation",
            "Safety",
            "Simplicity"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(min(10, 5, 20))",
        "o": [
            "5",
            "10",
            "20",
            "Error"
        ]
    },
    {
        "q": "What is 'Transient Fixture'?",
        "o": [
            "A fixture created and destroyed within the test",
            "A ghost fixture",
            "A global fixture",
            "A database"
        ]
    },
    {
        "q": "What is 'Persistent Fixture'?",
        "o": [
            "Fixture that persists after test (e.g., DB data)",
            "Memory leak",
            "Hard drive",
            "Constant"
        ]
    },
    {
        "q": "What is 'Implicit Setup'?",
        "o": [
            "Setup logic in a special setup method called automatically",
            "Magic",
            "Hidden code",
            "Constructors"
        ]
    },
    {
        "q": "What is 'Delegated Setup'?",
        "o": [
            "Setup logic in a helper method called explicitly",
            " delegation pattern",
            "Imports",
            "Inheritance"
        ]
    },
    {
        "q": "What is 'Inline Setup'?",
        "o": [
            "Setup logic inside the test method itself",
            "Inline CSS",
            "Fastest setup",
            "Global setup"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = [1]\ny = [1]\nprint(x == y)",
        "o": [
            "True",
            "False",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Four-Phase Test'?",
        "o": [
            "Setup, Exercise, Verify, Teardown",
            "Four steps of TDD",
            "Complex test",
            "Integration test"
        ]
    },
    {
        "q": "Which phase corresponds to 'Act' in AAA?",
        "o": [
            "Exercise",
            "Setup",
            "Verify",
            "Teardown"
        ]
    },
    {
        "q": "Which phase corresponds to 'Arrange' in AAA?",
        "o": [
            "Setup",
            "Exercise",
            "Verify",
            "Teardown"
        ]
    },
    {
        "q": "Which phase corresponds to 'Assert' in AAA?",
        "o": [
            "Verify",
            "Setup",
            "Exercise",
            "Teardown"
        ]
    },
    {
        "q": "What is 'Teardown' used for?",
        "o": [
            "Restoring the environment to original state",
            "Breaking code",
            "Deleting files",
            "Crashing app"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = 'abc'\nprint(s.find('d'))",
        "o": [
            "-1",
            "0",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Humble Object' pattern?",
        "o": [
            "Splitting a hard-to-test object into two: one easy-to-test (logic) and one humble (doesn't need testing)",
            "A modest object",
            "A small object",
            "A weak object"
        ]
    },
    {
        "q": "When is Humble Object useful?",
        "o": [
            "When forcing testability on UI controls or opaque frameworks",
            "Always",
            "Never",
            "For databases"
        ]
    },
    {
        "q": "What is 'Self-Shunt' pattern?",
        "o": [
            "The test class itself acts as a mock/stub for the object under test",
            "Short circuit",
            "Self testing code",
            "Recursion"
        ]
    },
    {
        "q": "What is 'Loop-Back' in testing?",
        "o": [
            "Testing by writing to an interface and reading back from it",
            "Infinite loop",
            "Recursion",
            "Feedback loop"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def check(x):\n    assert x > 0, 'Must be positive'\n    return x\n\ntry:\n    print(check(-1))\nexcept AssertionError as e:\n    print(e)",
        "o": [
            "Must be positive",
            "-1",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Mock Object' framework?",
        "o": [
            "A library that creates mock objects dynamically at runtime",
            "A coding standard",
            "A design pattern",
            "A database"
        ]
    },
    {
        "q": "Common Mock Object frameworks?",
        "o": [
            "Mockito, Moq, unittest.mock",
            "Django, Flask",
            "React, Vue",
            "Postgres, MySQL"
        ]
    },
    {
        "q": "What is 'Strict Mock'?",
        "o": [
            "A mock that fails if any unexpected method is called",
            "A strict parent",
            "A fast mock",
            "A static mock"
        ]
    },
    {
        "q": "What is 'Nice/Lenient Mock'?",
        "o": [
            "A mock that ignores unexpected calls or returns defaults",
            "A friendly mock",
            "A slow mock",
            "A broken mock"
        ]
    },
    {
        "q": "Why avoid over-specification in Mocks?",
        "o": [
            "It makes tests brittle to implementation details",
            "It is too fast",
            "It uses too much memory",
            "It is deprecated"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(range(3)))",
        "o": [
            "[0, 1, 2]",
            "[1, 2, 3]",
            "[0, 1, 2, 3]",
            "Error"
        ]
    },
    {
        "q": "What is 'Diamond Problem' in inheritance?",
        "o": [
            "Ambiguity when two superclasses inherit from a common base class",
            "Hard problem",
            "Costly problem",
            "Geometric problem"
        ]
    },
    {
        "q": "How does Composition over Inheritance help testing?",
        "o": [
            "Easier to inject mocks for components than to mock parent behavior",
            "It doesn't",
            "It makes code slower",
            "Inheritance is better for testing"
        ]
    },
    {
        "q": "What is 'Snapshot Testing'?",
        "o": [
            "Comparing rendered output (like UI or JSON) to a stored reference file",
            " Taking photos",
            "Database backups",
            "Screen recording"
        ]
    },
    {
        "q": "When is Snapshot Testing most useful?",
        "o": [
            "UI components or large data structure outputs",
            "Math logic",
            "Network protocols",
            "System kernel"
        ]
    },
    {
        "q": "What is a risk of Snapshot Testing?",
        "o": [
            "Developers might blindly update snapshots without verifying correctness",
            "It is too slow",
            "It takes too much disk space",
            "It is illegal"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = {'a', 'b', 'c'}\nx.add('a')\nprint(len(x))",
        "o": [
            "3",
            "4",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is 'Ports and Adapters' (Hexagonal Architecture)?",
        "o": [
            "Architecture decoupling core logic from external inputs/outputs",
            "Network ports",
            "USB adapters",
            "Shape drawing"
        ]
    },
    {
        "q": "Relationship between TDD and Hexagonal Architecture?",
        "o": [
            "Hexagonal makes TDD easier by isolating domain logic from infrastructure",
            "They are incompatible",
            "TDD forbids architecture",
            "Hexagonal replaces TDD"
        ]
    },
    {
        "q": "What is a 'Port'?",
        "o": [
            "An interface defining an entry/exit point for data",
            "A network socket",
            "A ship harbor",
            "A variable"
        ]
    },
    {
        "q": "What is an 'Adapter'?",
        "o": [
            "Implementation that connects the Port to the outside world",
            "A cable",
            "A power supply",
            "A test"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def gen():\n    yield 1\n    yield 2\n\ng = gen()\nprint(next(g))",
        "o": [
            "1",
            "2",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Domain-Driven Design' (DDD)?",
        "o": [
            "Approach to software development centering on the domain model",
            "Web domain design",
            "Network design",
            "Graphic design"
        ]
    },
    {
        "q": "How does TDD fit with DDD?",
        "o": [
            "Tests help clarify and verify the domain mode",
            "They conflict",
            "DDD replaces TDD",
            "TDD is only for UI"
        ]
    },
    {
        "q": "What is 'Ubiquitous Language'?",
        "o": [
            "Common language shared by developers and domain experts",
            "English",
            "Latin",
            "Java"
        ]
    },
    {
        "q": "Should test names use Ubiquitous Language?",
        "o": [
            "Yes, tests should read like business requirements",
            "No, use technical terms",
            "No, use abbreviations",
            "Doesn't matter"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = 'Hello World'\nprint(s.split()[1])",
        "o": [
            "World",
            "Hello",
            " ",
            "Error"
        ]
    },
    {
        "q": "What is 'Asynchronous Testing'?",
        "o": [
            "Testing code that runs randomly or after a delay",
            "Testing without sync",
            "Fast testing",
            "Slow testing"
        ]
    },
    {
        "q": "Challenge of Asynchronous Testing?",
        "o": [
            "Knowing when the async operation has completed",
            "It is too fast",
            "It assumes specific hardware",
            "It deletes code"
        ]
    },
    {
        "q": "Common pattern for testing Async code?",
        "o": [
            "Callback notification or Promise/Future awaiting",
            "Sleep 10 seconds",
            "Ignore it",
            "Run repeatedly"
        ]
    },
    {
        "q": "What is 'Fake Async'?",
        "o": [
            "Controlling the flow of time in tests to make async code sync",
            " Lying about async",
            "A slow test",
            "A database"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "import asyncio\nasync def main():\n    return 42\n\n# logical repr\nprint('Coroutine')",
        "o": [
            "Coroutine",
            "42",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Race Condition'?",
        "o": [
            "System depends on the sequence or timing of uncontrollable events",
            "Car race",
            "Running fast",
            "Competition"
        ]
    },
    {
        "q": "Can TDD detect Race Conditions?",
        "o": [
            "Hard with standard unit tests, requires stress/concurrency tests",
            "Yes, easily",
            "No, never",
            "Only in Java"
        ]
    },
    {
        "q": "What is 'Thread Safety'?",
        "o": [
            "Code functions correctly during simultaneous execution by multiple threads",
            "Safety gear",
            "Locking doors",
            "Antivirus"
        ]
    },
    {
        "q": "How to test Thread Safety?",
        "o": [
            "Run methods from multiple threads simultaneously and verify state/output",
            "Run test twice",
            "Use a mock",
            "Ask developer"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = [1, 2, 3]\ndel x[1]\nprint(x)",
        "o": [
            "[1, 3]",
            "[1, 2]",
            "[2, 3]",
            "Error"
        ]
    },
    {
        "q": "What is 'Load Testing'?",
        "o": [
            "Testing system behavior under expected load",
            "Testing weight",
            "Loading files",
            "Installation test"
        ]
    },
    {
        "q": "What is 'Stress Testing'?",
        "o": [
            "Testing system behavior under extreme/peak load to find breaking point",
            "Psychological test",
            "Testing urgency",
            "Unit testing"
        ]
    },
    {
        "q": "What is 'Soak Testing'?",
        "o": [
            "Testing system under significant load for extended period",
            "Water testing",
            "Testing in rain",
            "Cleaning code"
        ]
    },
    {
        "q": "Unit tests vs Performance tests?",
        "o": [
            "Unit tests check logic; Performance tests check speed/scalability",
            "No difference",
            "Performance tests are smaller",
            "Unit tests are slower"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = set()\ns.add(1)\ns.add(1)\nprint(len(s))",
        "o": [
            "1",
            "2",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is 'Code Smell'?",
        "o": [
            "Surface indication that there might be a deeper problem",
            "Bad smell",
            "Burning hardware",
            "Compiler error"
        ]
    },
    {
        "q": "Who coined the term 'Code Smell'?",
        "o": [
            "Kent Beck",
            "Bill Gates",
            "Steve Jobs",
            "Linus Torvalds"
        ]
    },
    {
        "q": "What is 'Refactoring' book author?",
        "o": [
            "Martin Fowler",
            "Robert Martin",
            "Kent Beck",
            "Erich Gamma"
        ]
    },
    {
        "q": "What is 'Test-Driven Development' book author?",
        "o": [
            "Kent Beck",
            "Martin Fowler",
            "Robert Martin",
            "Ward Cunningham"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(round(2.51))",
        "o": [
            "3",
            "2",
            "2.5",
            "Error"
        ]
    },
    {
        "q": "What is 'Clean Code' book author?",
        "o": [
            "Robert C. Martin",
            "Martin Fowler",
            "Kent Beck",
            "Dave Thomas"
        ]
    },
    {
        "q": "What is 'Working Effectively with Legacy Code' author?",
        "o": [
            "Michael Feathers",
            "Robert Martin",
            "Kent Beck",
            "Martin Fowler"
        ]
    },
    {
        "q": "Core message of 'Working Effectively with Legacy Code'?",
        "o": [
            "To change legacy code safely, you must get it under test first",
            "Delete old code",
            "Rewrite everything",
            "Don't touch it"
        ]
    },
    {
        "q": "What is a 'Seam' in legacy code?",
        "o": [
            "A place where you can alter behavior without editing that place",
            "A clothing line",
            "A syntax error",
            "A database connection"
        ]
    },
    {
        "q": "What is 'Enabling Point'?",
        "o": [
            "A place where you can make a decision to use one behavior or another (for testing)",
            "A switch",
            "A button",
            "A variable"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "a = [1, 2, 3]\nb = a[:]\nb[0] = 9\nprint(a[0])",
        "o": [
            "1",
            "9",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is 'Sprout Method'?",
        "o": [
            "Writing new code in a new method and testing that method",
            "Growing code",
            "Vegetable code",
            "Branching"
        ]
    },
    {
        "q": "What is 'Wrap Method'?",
        "o": [
            "Renaming original method and calling it from new method with new logic",
            "Packing code",
            "Gift wrapping",
            "Hiding code"
        ]
    },
    {
        "q": "Why use Sprout/Wrap methods?",
        "o": [
            "To add functionality to legacy code with tests without modifying existing massive methods",
            "To make code look pretty",
            "To hide bugs",
            "To increase line count"
        ]
    },
    {
        "q": "What is 'Null Object Pattern'?",
        "o": [
            "An object with defined neutral ('do nothing') behavior",
            "None",
            "Null pointer",
            "Empty file"
        ]
    },
    {
        "q": "How does Null Object Pattern help?",
        "o": [
            "Removes need for null checks",
            "Saves memory",
            "Speeds up code",
            "Fixes bugs"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def f(x):\n    return x * 2\n\nprint(f(f(2)))",
        "o": [
            "8",
            "4",
            "16",
            "2"
        ]
    },
    {
        "q": "What is 'Immutable Object'?",
        "o": [
            "An object whose state cannot be modified after it is created",
            "A constant variable",
            "A database record",
            "A slow object"
        ]
    },
    {
        "q": "Benefits of Immutability for testing?",
        "o": [
            "No side effects, thread-safe, predictable",
            "Faster creation",
            "Less memory",
            "Automatic tests"
        ]
    },
    {
        "q": "What is 'Command Query Separation' (CQS)?",
        "o": [
            "Every method should either be a command (perform action) or a query (return data), not both",
            "SQL commands",
            "Asking questions",
            "Military commands"
        ]
    },
    {
        "q": "Why is CQS good for testing?",
        "o": [
            "Queries are safe to call (no side effects); Commands isolate state changes",
            "It makes code shorter",
            "It runs faster",
            "It is easier to read"
        ]
    },
    {
        "q": "Does TDD require strict CQS?",
        "o": [
            "No, but it is highly recommended for testability",
            "Yes, strictly",
            "No, it forbids it",
            "Only for C++"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = ['a', 'b', 'c']\nprint(''.join(l))",
        "o": [
            "abc",
            "a b c",
            "a,b,c",
            "Error"
        ]
    },
    {
        "q": "What is 'Behavior-Driven Development' (BDD)?",
        "o": [
            "An extension of TDD focusing on behavioral specifications",
            "Testing behavior only",
            "Psychology testing",
            "Backend design"
        ]
    },
    {
        "q": "BDD focuses on:",
        "o": [
            "The 'Why' and 'What' instead of just 'How'",
            "The 'How' only",
            "The speed",
            "The cost"
        ]
    },
    {
        "q": "Standard BDD format?",
        "o": [
            "Given-When-Then",
            "If-Then-Else",
            "Try-Catch",
            "Input-Output"
        ]
    },
    {
        "q": "Is BDD a replacement for TDD?",
        "o": [
            "No, it builds upon TDD practices",
            "Yes, TDD is dead",
            "They are unrelated",
            "BDD is only for managers"
        ]
    },
    {
        "q": "Can you use TDD tools for BDD?",
        "o": [
            "Yes, many BDD frameworks are wrappers around TDD tools",
            "No, strictly separate",
            "Only JUnit",
            "Only Selenium"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(int('101', 2))",
        "o": [
            "5",
            "101",
            "2",
            "Error"
        ]
    },
    {
        "q": "What is 'Exploratory Testing'?",
        "o": [
            "Simultaneous learning, test design, and execution",
            "Hiking",
            "Searching google",
            "Map reading"
        ]
    },
    {
        "q": "Does TDD replace Exploratory Testing?",
        "o": [
            "No, they are complementary",
            "Yes, totally",
            "Yes, TDD covers everything",
            "No, Exploratory is useless"
        ]
    },
    {
        "q": "What is 'Sanity Testing'?",
        "o": [
            "Quick check to see if basic functionality works after changes",
            "Mental health check",
            "Full regression",
            "Unit testing"
        ]
    },
    {
        "q": "What is 'Smoke Testing'?",
        "o": [
            "Preliminary testing to reveal simple failures severe enough to reject a release",
            "Fire testing",
            "Smoking code",
            "Gas testing"
        ]
    },
    {
        "q": "Difference between Smoke and Sanity?",
        "o": [
            "Smoke is broad and shallow; Sanity is narrow and deep (targeted)",
            "No difference",
            "Smoke is for hardware",
            "Sanity is for users"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = True\ny = False\nprint(x or y)",
        "o": [
            "True",
            "False",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Dependency Inversion Principle' (SOLID)?",
        "o": [
            "Depend on abstractions, not on concretions",
            "Inverting colors",
            "Moving files",
            "Changing databases"
        ]
    },
    {
        "q": "How does Dependency Inversion aid TDD?",
        "o": [
            "Allows substituting real implementations with mocks easily",
            "It makes code cryptic",
            "It slows down tests",
            "It doesn't help"
        ]
    },
    {
        "q": "What is 'Liskov Substitution Principle' (SOLID)?",
        "o": [
            "Subtypes must be substitutable for their base types",
            "Replacing code",
            "Renaming variables",
            "Deleting files"
        ]
    },
    {
        "q": "Violation of Liskov Principle often leads to:",
        "o": [
            "Unexpected behavior and instanceof checks",
            "Better code",
            "Faster code",
            "Secure code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def func(a, b=0):\n    return a + b\n\nprint(func(5))",
        "o": [
            "5",
            "0",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Single Responsibility Principle' (SOLID)?",
        "o": [
            "A class should have only one reason to change",
            "One developer per class",
            "One method per class",
            "One file per project"
        ]
    },
    {
        "q": "How does SRP help TDD?",
        "o": [
            "Smaller, focused classes are easier to test",
            "It makes fewer classes",
            "It reduces files",
            "It ignores tests"
        ]
    },
    {
        "q": "What is 'Open/Closed Principle' (SOLID)?",
        "o": [
            "Software entities should be open for extension, but closed for modification",
            "Open source code",
            "Closing files",
            "Opening doors"
        ]
    },
    {
        "q": "How does TDD encourage Open/Closed?",
        "o": [
            "New features are added by new code (and tests) rather than changing old code",
            "It locks files",
            "It encrypts code",
            "It closes bugs"
        ]
    },
    {
        "q": "What is 'Interface Segregation Principle' (SOLID)?",
        "o": [
            "Clients should not be forced to depend on interfaces they do not use",
            "Separating UI",
            "Splitting screens",
            "Using multiple monitors"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('abc'.upper())",
        "o": [
            "ABC",
            "abc",
            "Abc",
            "Error"
        ]
    },
    {
        "q": "What is 'Cyclic Dependency'?",
        "o": [
            "A depends on B, and B depends on A",
            "Bicycle",
            "Round robin",
            "Loop"
        ]
    },
    {
        "q": "Why is Cyclic Dependency bad for testing?",
        "o": [
            "Hard to isolate A or B for unit testing",
            "It causes infinite loops",
            "It crashes compiler",
            "It is fine"
        ]
    },
    {
        "q": "How to break Cyclic Dependency?",
        "o": [
            "Introduce an Interface or separate the shared logic",
            "Delete one class",
            "Merge them",
            "Ignore it"
        ]
    },
    {
        "q": "What is 'Integration Hell'?",
        "o": [
            "When integrating independently developed components takes longer than development",
            "A warm place",
            "Database error",
            "Network failure"
        ]
    },
    {
        "q": "What prevents Integration Hell?",
        "o": [
            "Continuous Integration and TDD",
            "Praying",
            "Working alone",
            "Not integrating"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(abs(-10.5))",
        "o": [
            "10.5",
            "-10.5",
            "10",
            "11"
        ]
    },
    {
        "q": "What is 'Tautological Test'?",
        "o": [
            "A test that asserts exactly what the code does, providing no value",
            "A logical test",
            "A fast test",
            "A complex test"
        ]
    },
    {
        "q": "Example of Tautological Test?",
        "o": [
            "Mocking a method and asserting it returns what was mocked",
            "Asserting 1 == 1",
            "Testing true is true",
            "Testing addition"
        ]
    },
    {
        "q": "What is 'Overspecified Software'?",
        "o": [
            "Software where tests tightly couple to implementation details, hardening the code against change",
            "Fast software",
            "Documented software",
            "Bug free software"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(all([True, True, False]))",
        "o": [
            "False",
            "True",
            "None",
            "Error"
        ]
    },
    {
        "q": "What is 'Fragile Test Problem'?",
        "o": [
            "Tests that fail frequently when internal structure changes, even if behavior remains correct",
            "Broken glass",
            "Weak compilation",
            "Slow tests"
        ]
    },
    {
        "q": "How to fix Fragile Tests?",
        "o": [
            "Test behavior/public API, not internal state or private methods",
            "Delete them",
            "Make them slower",
            "Use more mocks"
        ]
    },
    {
        "q": "What is 'Obscure Test'?",
        "o": [
            "A test that is hard to understand what it verifies",
            "A dark test",
            "A hidden test",
            "A slow test"
        ]
    },
    {
        "q": "What is 'General Fixture' smell?",
        "o": [
            "A large, complex setup used by all tests, containing unnecessary data for many",
            "A general manager",
            "A public variable",
            "Standard library"
        ]
    },
    {
        "q": "What is 'Eager Test'?",
        "o": [
            "A test checking too much functionality (multiple verifies)",
            "An excited test",
            "A fast test",
            "A unit test"
        ]
    },
    {
        "q": "What is 'Lazy Test'?",
        "o": [
            "A test that checks several unrelated conditions to save effort",
            "A slow test",
            "A sleeping test",
            "A commented test"
        ]
    },
    {
        "q": "What is 'Mystery Guest'?",
        "o": [
            "A test using external resources (files/db) where content is not visible within the test method",
            "A spy",
            "A secret user",
            "Unknown variable"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def f(a, b=[]):\n    b.append(a)\n    return b\nprint(f(1))\nprint(f(2))",
        "o": [
            "[1]\n[1, 2]",
            "[1]\n[2]",
            "[1]\n[1]",
            "Error"
        ]
    },
    {
        "q": "What is 'Conditional Test Logic'?",
        "o": [
            "Tests containing if/else or loops, reducing readability and hiding bugs",
            "Smart tests",
            "Logic gates",
            "Boolean tests"
        ]
    },
    {
        "q": "Should tests have logic?",
        "o": [
            "Ideally no, they should be linear statements of fact",
            "Yes, lots",
            "Only loops",
            "Only switch"
        ]
    },
    {
        "q": "What is 'Test Logic in Production'?",
        "o": [
            "Production code containing logic specifically for testing (e.g., if(Testing) ...)",
            "A good practice",
            "A pattern",
            "A mock"
        ]
    },
    {
        "q": "Why is Test Logic in Production bad?",
        "o": [
            "Adds complexity, security risks, and potential bugs in prod",
            "It is slow",
            "It is ugly",
            "It is fine"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('%.2f' % 3.14159)",
        "o": [
            "3.14",
            "3.15",
            "3.141",
            "Error"
        ]
    },
    {
        "q": "What is 'Irrelevant Information' in tests?",
        "o": [
            "Data in test setup that doesn't affect the test outcome but clutters the test",
            "Comments",
            "Whitespace",
            "Imports"
        ]
    },
    {
        "q": "What is 'Hard-Coded Test Data' smell?",
        "o": [
            "Using 'magic values' extensively without explanation",
            "Constants",
            "Variables",
            "Database"
        ]
    },
    {
        "q": "What is 'Test Code Duplication'?",
        "o": [
            "Copy-pasting test setup or assertion logic",
            "Backups",
            "Good practice",
            "Safety"
        ]
    },
    {
        "q": "What is 'Resource Optimism'?",
        "o": [
            "Assuming resources (DB, files) are available and in correct state without verifying",
            "Positive thinking",
            "Fast tests",
            "Using cloud"
        ]
    },
    {
        "q": "What is 'Assertion Roulette'?",
        "o": [
            "Multiple assertions in a test without messages, making it hard to know which failed",
            "Gambling",
            "Random testing",
            "Chaos engineering"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = {1: 'a', 2: 'b'}\nprint(x.pop(1))\nprint(x)",
        "o": [
            "a\n{2: 'b'}",
            "b\n{1: 'a'}",
            "1\n{2: 'b'}",
            "Error"
        ]
    },
    {
        "q": "What is 'Incidental Coverage'?",
        "o": [
            "Code executed by a test but not actually verified by assertions",
            "Accidental testing",
            "Bonus marks",
            "Free tests"
        ]
    },
    {
        "q": "What is 'Golden Hammer' anti-pattern?",
        "o": [
            "Using the same tool/approach for every problem (e.g., Mocks everywhere)",
            "A strong hammer",
            "Expensive tool",
            "Best practice"
        ]
    },
    {
        "q": "What is 'Lava Flow' code?",
        "o": [
            "Code kept because nobody knows if it's still used or what it does",
            "Hot code",
            "Fast code",
            "Liquid code"
        ]
    },
    {
        "q": "What is 'Boat Anchor'?",
        "o": [
            "A piece of code left in the codebase 'just in case' it's needed later",
            "Heavy code",
            "Stable code",
            "Slow code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nl.insert(1, 10)\nprint(l)",
        "o": [
            "[1, 10, 2, 3]",
            "[10, 1, 2, 3]",
            "[1, 2, 10, 3]",
            "Error"
        ]
    },
    {
        "q": "What is 'Poltergeist' antipattern?",
        "o": [
            "Short-lived objects/classes that just start processes/invoke methods",
            "Ghosts",
            "Scary code",
            "Bad tests"
        ]
    },
    {
        "q": "What is 'Gypsy Wagon' / 'Trampoline'?",
        "o": [
            "Passing parameters through unrelated methods to get them to a target",
            "Jumping code",
            "Mobile code",
            "Bouncing tests"
        ]
    },
    {
        "q": "How to fix Gypsy Wagon?",
        "o": [
            "Dependency Injection or Context Object",
            "Global variables",
            "More parameters",
            "Static methods"
        ]
    },
    {
        "q": "What is 'Sequential Coupling'?",
        "o": [
            "Methods must be called in a specific order to work",
            "Loose coupling",
            "Good design",
            "Chain of responsibility"
        ]
    },
    {
        "q": "Refactoring Sequential Coupling?",
        "o": [
            "Template Method Pattern",
            "Add comments",
            "Enforce with exceptions",
            "Use boolean flags"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "s = 'a,b,c'\nprint(s.replace(',', '-'))",
        "o": [
            "a-b-c",
            "a,b,c",
            "abc",
            "Error"
        ]
    },
    {
        "q": "What is 'Big Ball of Mud'?",
        "o": [
            "A system with no recognizable architecture",
            "Dirty code",
            "Complex app",
            "Large database"
        ]
    },
    {
        "q": "What is 'Scatter-Gather'?",
        "o": [
            "Pattern where request is broadcast to multiple handlers and results aggregated",
            "Scattering code",
            "Random collection",
            "Memory allocation"
        ]
    },
    {
        "q": "What is 'Object Cesspool'?",
        "o": [
            "Reusing objects in a pool that are not properly cleaned/reset",
            "Memory leak",
            "Dirty objects",
            "Garbage collection"
        ]
    },
    {
        "q": "What is 'Ambiguous Interface'?",
        "o": [
            "Interface that doesn't clearly communicate its purpose or usage",
            "Confusing UI",
            "Multiple inheritance",
            "Void pointers"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(list(zip([1, 2], [3, 4])))",
        "o": [
            "[(1, 3), (2, 4)]",
            "[[1, 3], [2, 4]]",
            "[(1, 2), (3, 4)]",
            "Error"
        ]
    },
    {
        "q": "What is 'Circular Dependency'?",
        "o": [
            "A depends on B, B depends on A",
            "Circle",
            "Roundabout",
            "Curve"
        ]
    },
    {
        "q": "What is 'Combinatorial Explosion' in testing?",
        "o": [
            "Too many test cases needed due to multiple interacting parameters",
            "Exploding computer",
            "Too much memory",
            "Crash"
        ]
    },
    {
        "q": "How to handle Combinatorial Explosion?",
        "o": [
            "Pairwise testing / Orthogonal Arrays",
            "Write all tests",
            "Skip tests",
            "Buy more servers"
        ]
    },
    {
        "q": "What is 'Feature Toggle' / 'Flag'?",
        "o": [
            "Configuration to enable/disable features at runtime",
            "A switch",
            "A boolean",
            "A variable"
        ]
    },
    {
        "q": "How do Feature Flags affect TDD?",
        "o": [
            "Allow merging incomplete code (with tests) safely",
            "Disable tests",
            "Break build",
            "Slow down code"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = {1, 2}\ny = {2, 3}\nprint(x & y)",
        "o": [
            "{2}",
            "{1, 2, 3}",
            "{1, 3}",
            "Error"
        ]
    },
    {
        "q": "What is 'Strangler Fig' pattern?",
        "o": [
            "Gradually replacing legacy system with new system around the edges",
            "A plant",
            "Killing code",
            "Wrapping code"
        ]
    },
    {
        "q": "What is 'Branch By Abstraction'?",
        "o": [
            "Using an abstraction layer to switch between old and new implementations gradually",
            "Git branching",
            "Tree branching",
            "Abstract art"
        ]
    },
    {
        "q": "What is 'Canary Release'?",
        "o": [
            "Rolling out features to a small subset of users first",
            "Bird release",
            "Mining",
            "Alpha test"
        ]
    },
    {
        "q": "What is 'Blue-Green Deployment'?",
        "o": [
            "Running two identical production environments to switch traffic instanly",
            "Colors",
            "Painting",
            "Environment variables"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('1' + '2')",
        "o": [
            "12",
            "3",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Chaos Engineering'?",
        "o": [
            "Experimenting on a system to build confidence in its capability to withstand turbulence",
            "Creating bugs",
            "Deleting production db",
            "Hacking"
        ]
    },
    {
        "q": "Tool for Chaos Engineering?",
        "o": [
            "Chaos Monkey",
            "JUnit",
            "Selenium",
            "Git"
        ]
    },
    {
        "q": "What is 'Shift Left' testing?",
        "o": [
            "Moving testing earlier in the lifecycle (e.g., TDD)",
            "Moving fast",
            "Testing only left side",
            "Politics"
        ]
    },
    {
        "q": "What is 'Shift Right' testing?",
        "o": [
            "Testing in production (observability, canary, chaos)",
            "Moving slow",
            "Testing right side",
            "Delaying tests"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "d = {'a': 1}\nd['b'] = 2\nprint(len(d))",
        "o": [
            "2",
            "1",
            "3",
            "0"
        ]
    },
    {
        "q": "What is 'Architecture Decision Record' (ADR)?",
        "o": [
            "Documenting architectural decisions and their context",
            "Audio recording",
            "Meeting minutes",
            "Code comments"
        ]
    },
    {
        "q": "Why use ADRs?",
        "o": [
            "To prevent revisiting settled discussions and explain 'Why' to future devs",
            "To waste time",
            "To fill disk space",
            "To spy on devs"
        ]
    },
    {
        "q": "What is 'Conway's Law'?",
        "o": [
            "Systems are constrained to produce designs mirroring the communication structure of organizations",
            "Law of physics",
            "Law of code",
            "Murphy's law"
        ]
    },
    {
        "q": "Inverse Conway Maneuver?",
        "o": [
            "Structuring teams to match the desired architecture",
            "Breaking the law",
            "Ignoring teams",
            "Merging everyone"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def f():\n    return\nprint(f())",
        "o": [
            "None",
            "Error",
            "False",
            "True"
        ]
    },
    {
        "q": "What is 'Bus Factor'?",
        "o": [
            "Number of team members that can be hit by a bus before the project stalls",
            "Transportation",
            "Hardware bus",
            "Ticket price"
        ]
    },
    {
        "q": "How does TDD improve Bus Factor?",
        "o": [
            "Tests document system behavior, making knowledge transfer easier",
            "It keeps devs safe",
            "It hires more people",
            "It buys buses"
        ]
    },
    {
        "q": "What is 'Brook's Law'?",
        "o": [
            "Adding manpower to a late software project makes it later",
            "More people equals faster",
            "Code never finishes",
            "Tests are optional"
        ]
    },
    {
        "q": "What is 'Second System Effect'?",
        "o": [
            "Tendency of small, elegant systems to be succeeded by over-engineered bloated systems",
            "Second version is always better",
            "Versioning",
            "Backups"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(2 ** 3 ** 2)",
        "o": [
            "512",
            "64",
            "12",
            "Error"
        ]
    },
    {
        "q": "What is 'Fail Fast' principle?",
        "o": [
            "System should report failure immediately rather than continuing with bad state",
            "Giving up",
            "Running away",
            "Coding fast"
        ]
    },
    {
        "q": "What is 'Fail Safe'?",
        "o": [
            "System continues to operate (perhaps degraded) in event of failure",
            "Safety net",
            "Backup",
            "Shield"
        ]
    },
    {
        "q": "What is 'Idempotency'?",
        "o": [
            "Operation can be applied multiple times without changing the result beyond the initial application",
            "Identity",
            "Power",
            "Variables"
        ]
    },
    {
        "q": "Is TDD 'Silver Bullet'?",
        "o": [
            "No, there is no silver bullet (Fred Brooks)",
            "Yes, it solves everything",
            "Maybe",
            "Only for C#"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2, 3]\nprint(l.index(2))",
        "o": [
            "1",
            "2",
            "0",
            "Error"
        ]
    },
    {
        "q": "Refactoring pattern 'Extract Method' primary goal?",
        "o": [
            "Reduce method length and improve readability",
            "Increase lines",
            "Hide code",
            "Reuse variables"
        ]
    },
    {
        "q": "Refactoring pattern 'Inline Method' primary goal?",
        "o": [
            "Remove unnecessary indirection for very simple methods",
            "Make method larger",
            "Speed up compilation",
            "Delete code"
        ]
    },
    {
        "q": "Refactoring pattern 'Replace Temp with Query'?",
        "o": [
            "Extracting expression into a method to encourage reuse and reduce state",
            "Deleting variables",
            "Using database",
            "Optimizing speed"
        ]
    },
    {
        "q": "Refactoring pattern 'Introduce Null Object'?",
        "o": [
            "Replacing null checks with polymorphic object",
            "Adding nulls",
            "Deleting objects",
            "Creating bugs"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "x = (1, 2)\ny = (1, 2)\nprint(x is y)",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Cargo Cult Programming'?",
        "o": [
            "Ritual inclusion of code/structure that serves no real purpose",
            "Shipping code",
            "Transport logic",
            "Good practice"
        ]
    },
    {
        "q": "Is blindly following TDD steps Cargo Culting?",
        "o": [
            "Yes, if you don't understand the 'Why'",
            "No, TDD is always right",
            "Maybe",
            "Only in Python"
        ]
    },
    {
        "q": "What is 'Primitive Obsession' refactoring?",
        "o": [
            "Replace Data Value with Object",
            "Using ints",
            "Using arrays",
            "Using strings"
        ]
    },
    {
        "q": "What is 'Switch Statements' bad smell?",
        "o": [
            "Complex conditionals often better handled by polymorphism",
            "Network switch",
            "Light switch",
            "Nintendo Switch"
        ]
    },
    {
        "q": "Refactoring Switch Statements?",
        "o": [
            "Replace Conditional with Polymorphism",
            "Use more if-else",
            "Use goto",
            "Delete them"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print('hello'.replace('l', ''))",
        "o": [
            "heo",
            "hello",
            "helo",
            "Error"
        ]
    },
    {
        "q": "What is 'Lazy Class' smell?",
        "o": [
            "A class that doesn't do enough to justify its existence",
            "A slow class",
            "A tired class",
            "A student"
        ]
    },
    {
        "q": "Refactoring Lazy Class?",
        "o": [
            "Collapse Hierarchy / Inline Class",
            "Add more code",
            "Add comments",
            "Keep it"
        ]
    },
    {
        "q": "What is 'Data Class' smell?",
        "o": [
            "A class with only fields and getters/setters (dumb container)",
            "Database",
            "Data structure",
            "Normal class"
        ]
    },
    {
        "q": "Refactoring Data Class?",
        "o": [
            "Move Method (move behavior closer to data)",
            "Add fields",
            "Delete getters",
            "Keep it"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(sorted([3, 1, 2]))",
        "o": [
            "[1, 2, 3]",
            "[3, 2, 1]",
            "[3, 1, 2]",
            "Error"
        ]
    },
    {
        "q": "What is 'Side Effect' in a function?",
        "o": [
            "Function modifies state outside its local scope",
            "Function returns error",
            "Function prints",
            "Function takes time"
        ]
    },
    {
        "q": "Why avoid Side Effects in TDD?",
        "o": [
            "Makes testing harder and order-dependent",
            "It is illegal",
            "It is slow",
            "It is ugly"
        ]
    },
    {
        "q": "What is 'Referential Transparency'?",
        "o": [
            "An expression can be replaced by its value without changing propertry",
            "See-through code",
            "Documentation",
            "References"
        ]
    },
    {
        "q": "What is 'Higher Order Function'?",
        "o": [
            "A function that takes a function as arg or returns one",
            "A loud function",
            "A big function",
            "Main method"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "def add(x):\n    return x + 1\n\nprint(list(map(add, [1, 2])))",
        "o": [
            "[2, 3]",
            "[1, 2]",
            "[3, 4]",
            "Error"
        ]
    },
    {
        "q": "What is 'Currying'?",
        "o": [
            "Transforming a function with multiple args into sequence of single-arg functions",
            "Cooking",
            "Spice",
            "Mixing"
        ]
    },
    {
        "q": "What is 'Closure'?",
        "o": [
            "A function remembering the scope in which it was created",
            "Closing a file",
            "Ending a program",
            "A loop"
        ]
    },
    {
        "q": "What is 'Monkey Patching'?",
        "o": [
            "Dynamic modification of a class or module at runtime",
            "Zoo code",
            "Patching clothes",
            "Fixing bugs"
        ]
    },
    {
        "q": "Risks of Monkey Patching?",
        "o": [
            "Unpredictable behavior and hard to debug",
            "It bites",
            "It smells",
            "It is fast"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "l = [1, 2]\nl.extend([3, 4])\nprint(len(l))",
        "o": [
            "4",
            "2",
            "3",
            "Error"
        ]
    },
    {
        "q": "What is 'Cohesion' vs 'Coupling' mnemonic?",
        "o": [
            "High Cohesion, Low Coupling",
            "Low Cohesion, High Coupling",
            "High Coupling, High Cohesion",
            "Low everything"
        ]
    },
    {
        "q": "What is 'Law of Instrument'?",
        "o": [
            "If you only have a hammer, everything looks like a nail",
            "Music law",
            "Testing law",
            "Code law"
        ]
    },
    {
        "q": "What is 'Pareto Principle'?",
        "o": [
            "80% of effects come from 20% of causes (80/20 rule)",
            "90/10 rule",
            "50/50 rule",
            "100/0 rule"
        ]
    },
    {
        "q": "How does Pareto apply to testing?",
        "o": [
            "20% of code often causes 80% of bugs",
            "Test 20% of code",
            "Write 80% tests",
            "Ignore 20%"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(bool('False'))",
        "o": [
            "True",
            "False",
            "Error",
            "None"
        ]
    },
    {
        "q": "What is 'Heisenbug'?",
        "o": [
            "A bug that disappears or alters behavior when you try to study/debug it",
            "Quantum bug",
            "Big bug",
            "Scary bug"
        ]
    },
    {
        "q": "What is 'Bohrbug'?",
        "o": [
            "A bug that is solid, reproducible, and doesn't change",
            "Atom bug",
            "Small bug",
            "Fast bug"
        ]
    },
    {
        "q": "What is 'First Principles' thinking?",
        "o": [
            "Breaking a problem down to basic elements and rebuilding",
            "Guessing",
            "Copying",
            "Memorizing"
        ]
    },
    {
        "q": "What is 'Rubber Duck Debugging'?",
        "o": [
            "Explaining code line-by-line to an inanimate object to find bugs",
            "Playing with toys",
            "Bath time",
            "Quacking"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "print(10 // 3)",
        "o": [
            "3",
            "3.33",
            "4",
            "1"
        ]
    }
]