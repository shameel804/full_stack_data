[
    {
        "q": "What is a 'Test Double'?",
        "o": [
            "A generic term for any object that stands in for a real object during testing",
            "A test that runs twice",
            "A duplicate test",
            "A failed test"
        ]
    },
    {
        "q": "Which is NOT a type of Test Double?",
        "o": [
            "Clone",
            "Mock",
            "Stub",
            "Spy"
        ]
    },
    {
        "q": "What is a 'Dummy' object?",
        "o": [
            "An object that is passed around but never actually used (e.g., to fill parameter lists)",
            "A smart object",
            "A broken object",
            "A copy"
        ]
    },
    {
        "q": "What is a 'Stub'?",
        "o": [
            "An object that provides canned answers to calls made during the test",
            "An object that verifies calls",
            "An object that records history",
            "A real object"
        ]
    },
    {
        "q": "What is a 'Spy'?",
        "o": [
            "An object that records how it was called (arguments, count) and optionally delegates to real behavior",
            "A secret agent",
            "A database",
            "A fake"
        ]
    },
    {
        "q": "What is a 'Mock'?",
        "o": [
            "An object pre-programmed with expectations about calls it should receive (behavior verification)",
            "A joke",
            "A simple stub",
            "A shadow"
        ]
    },
    {
        "q": "What is a 'Fake'?",
        "o": [
            "A working implementation but with shortcuts (e.g. in-memory DB) making it unsuitable for production",
            "A fraud",
            "A broken code",
            "A slow code"
        ]
    },
    {
        "q": "What is the primary purpose of mocking?",
        "o": [
            "To isolate the unit under test from its dependencies",
            "To test the dependencies",
            "To go faster",
            "To write less code"
        ]
    },
    {
        "q": "What is 'State Verification'?",
        "o": [
            "Verifying the final state (variables, return values) of the system after execution",
            "Verifying interactions",
            "Verifying logs",
            "Verifying performance"
        ]
    },
    {
        "q": "What is 'Behavior Verification'?",
        "o": [
            "Verifying that the system interacted with its dependencies correctly (e.g. called specific methods)",
            "Verifying state",
            "Verifying database",
            "Verifying UI"
        ]
    },
    {
        "q": "Mocks are primarily used for...",
        "o": [
            "Behavior verification",
            "State verification",
            "Integration testing",
            "Load testing"
        ]
    },
    {
        "q": "Stubs are primarily used for...",
        "o": [
            "State verification (providing inputs to the unit)",
            "Behavior verification",
            "Spying",
            "Reporting"
        ]
    },
    {
        "q": "Which principle does Mocking support?",
        "o": [
            "Seperation of Concerns / Isolation",
            "Coupling",
            "Duplication",
            "Complexity"
        ]
    },
    {
        "q": "What is 'Dependency Injection' (DI)?",
        "o": [
            "A design pattern where dependencies are provided to a class rather than created inside it",
            "A virus",
            "A testing tool",
            "A database"
        ]
    },
    {
        "q": "Why is DI important for mocking?",
        "o": [
            "It allows replacing real dependencies with test doubles easily",
            "It is faster",
            "It is required by Java",
            "It is modern"
        ]
    },
    {
        "q": "What is 'Constructor Injection'?",
        "o": [
            "Passing dependencies via the class constructor",
            "Injecting code",
            "Injecting SQL",
            "Creating object"
        ]
    },
    {
        "q": "What is 'Setter Injection'?",
        "o": [
            "Passing dependencies via setter methods",
            "Passing via fields",
            "Passing via constructor",
            "Passing via main"
        ]
    },
    {
        "q": "What is 'Field Injection'?",
        "o": [
            "Injecting dependencies directly into fields (often via reflection/frameworks)",
            "Injecting into constructor",
            "Injecting into setter",
            "Injecting into method"
        ]
    },
    {
        "q": "Which injection type is generally preferred for testability?",
        "o": [
            "Constructor Injection (ensures valid state, immutable, easy to pass mocks)",
            "Field Injection",
            "Setter Injection",
            "Method Injection"
        ]
    },
    {
        "q": "What creates a text double in Manual Mocking?",
        "o": [
            "Creating a class that implements the interface and returning hardcoded values",
            "Using Mockito",
            "Using PowerMock",
            "Using Jest"
        ]
    },
    {
        "q": "Does mocking require a framework?",
        "o": [
            "No, you can write manual mocks",
            "Yes",
            "Only in Java",
            "Only in Python"
        ]
    },
    {
        "q": "What is the downside of manual mocks?",
        "o": [
            "Boilerplate code and maintenance burden",
            "Performance",
            "Accuracy",
            "Security"
        ]
    },
    {
        "q": "What is the 'System Under Test' (SUT)?",
        "o": [
            "The specific class or component being tested",
            "The test class",
            "The mock object",
            "The framework"
        ]
    },
    {
        "q": "What is a 'Collaborator'?",
        "o": [
            "A class that the SUT depends on or interacts with",
            "The developer",
            "The tester",
            "The manager"
        ]
    },
    {
        "q": "Should you mock Value Objects (e.g. String, Date)?",
        "o": [
            "No, just use the real objects",
            "Yes, always",
            "Maybe",
            "If large"
        ]
    },
    {
        "q": "Should you mock Data Transfer Objects (DTOs)?",
        "o": [
            "No, use real DTOs",
            "Yes",
            "Sometimes",
            "If private"
        ]
    },
    {
        "q": "Should you mock External Services (API, DB)?",
        "o": [
            "Yes, in unit tests",
            "No",
            "Never",
            "Only in production"
        ]
    },
    {
        "q": "Should you mock Standard Library classes (e.g. List, Map)?",
        "o": [
            "No, use real implementations (ArrayList, HashMap)",
            "Yes",
            "Always",
            "Recommended"
        ]
    },
    {
        "q": "If a test fails because a Mock was not called, what kind of failure is it?",
        "o": [
            "Interaction/Verification failure",
            "Assertion failure",
            "Compilation error",
            "Timeout"
        ]
    },
    {
        "q": "If a test fails because a Stub returned null, what kind of failure is it?",
        "o": [
            "Likely a NullPointerException or assertion failure in SUT logic",
            "Verification failure",
            "Mock failure",
            "Spy failure"
        ]
    },
    {
        "q": "What is 'Over-mocking'?",
        "o": [
            "Mocking too many details, making tests fragile and coupled to implementation",
            "Mocking well",
            "Mocking fast",
            "Mocking slow"
        ]
    },
    {
        "q": "What happens if strict mock receives an unexpected call?",
        "o": [
            "It throws an exception (fail fast)",
            "It returns null",
            "It ignores it",
            "It logs it"
        ]
    },
    {
        "q": "What happens if lenient mock receives an unexpected call?",
        "o": [
            "It returns a default value (null/0/false) and ignores it",
            "It fails",
            "It crashes",
            "It warns"
        ]
    },
    {
        "q": "What is 'Mocking the clock'?",
        "o": [
            "Using a mock/fake time source to test time-dependent code",
            "Wasting time",
            "Timing tests",
            "Scheduling"
        ]
    },
    {
        "q": "Why mock the file system?",
        "o": [
            "To avoid disk I/O (slow, stateful) and simulate error conditions (disk full)",
            "To save space",
            "To read files",
            "To write files"
        ]
    },
    {
        "q": "What is 'Deterministic' test?",
        "o": [
            "A test that always produces the same result given the same inputs",
            "Random test",
            "Flaky test",
            "Unknown test"
        ]
    },
    {
        "q": "How do mocks help determinism?",
        "o": [
            "By controlling non-deterministic dependencies (time, random, network)",
            "They don't",
            "By confusing code",
            "By slowing down"
        ]
    },
    {
        "q": "What is 'Law of Demeter' in context of mocking?",
        "o": [
            "Limit interactions to immediate friends; helps avoid deep mocking chains (getA().getB().getC())",
            "Mock everything",
            "Stub nothing",
            "Test everything"
        ]
    },
    {
        "q": "What is 'Mock Object Framework'?",
        "o": [
            "Library that simplifies creation and usage of mocks (e.g. Mockito, Moq, Jest)",
            "Library for DB",
            "Library for UI",
            "Library for logs"
        ]
    },
    {
        "q": "Can you mock private methods?",
        "o": [
            "Generally discouraged; indicates design smell. Some tools allow it (PowerMock).",
            "Yes, easy",
            "Always",
            "Standard"
        ]
    },
    {
        "q": "Why is mocking private methods bad?",
        "o": [
            "Restricts refactoring (private implementation details should be hidden)",
            "It is slow",
            "It is impossible",
            "It is illegal"
        ]
    },
    {
        "q": "What is 'Partial Mock'?",
        "o": [
            "Mocking some methods of a real object while keeping others real (Spy)",
            "Half mock",
            "Weak mock",
            "Bad mock"
        ]
    },
    {
        "q": "When to use Partial Mock?",
        "o": [
            "Legacy code refactoring where separation is hard",
            "Greenfield projects",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'Canned Answer'?",
        "o": [
            "A fixed return value configured in a stub",
            "A question",
            "A database",
            "A log"
        ]
    },
    {
        "q": "What is 'Expectations'?",
        "o": [
            "Definitions of what calls a mock should receive",
            "Hopes",
            "Dreams",
            "Settings"
        ]
    },
    {
        "q": "In 'Arrange-Act-Assert', where does Stubbing happen?",
        "o": [
            "Arrange",
            "Act",
            "Assert",
            "After"
        ]
    },
    {
        "q": "In 'Arrange-Act-Assert', where does Verification happen?",
        "o": [
            "Assert",
            "Act",
            "Arrange",
            "Before"
        ]
    },
    {
        "q": "What is 'Record-Replay-Verify' pattern?",
        "o": [
            "Old mocking pattern (Record expectations, Replay/Run code, Verify all met)",
            "Video pattern",
            "Audio pattern",
            "Gaming pattern"
        ]
    },
    {
        "q": "What is 'Spying on a real object'?",
        "o": [
            "Wrapping a real instance to track calls without replacing functionality (unless overridden)",
            "Hacking",
            "Debugging",
            "Logging"
        ]
    },
    {
        "q": "Is Stubbing same as Mocking?",
        "o": [
            "No, stubbing = state/return values; mocking = behavior/interactions",
            "Yes",
            "Almost",
            "Sometimes"
        ]
    },
    {
        "q": "Can a Test Double be both a Mock and a Stub?",
        "o": [
            "Yes, often configured to return values AND verified related to calls",
            "No",
            "Impossible",
            "Rare"
        ]
    },
    {
        "q": "What is interface segregation principle impact on mocking?",
        "o": [
            "Smaller interfaces are easier to mock",
            "Harder to mock",
            "No impact",
            "Slower"
        ]
    },
    {
        "q": "What is 'Seam' in testing?",
        "o": [
            "A place where you can alter behavior in your program without editing it (e.g. for mocking)",
            "A joint",
            "A bug",
            "A feature"
        ]
    },
    {
        "q": "Example of Object Seam?",
        "o": [
            "Passing a collaborator in constructor (allows replacing it)",
            "Private method",
            "Static method",
            "Final class"
        ]
    },
    {
        "q": "What is 'Mock Hell'?",
        "o": [
            "Tests with excessive, complex setup of mocks, making them hard to read and maintain",
            "A game",
            "A place",
            "A tool"
        ]
    },
    {
        "q": "How to avoid Mock Hell?",
        "o": [
            "Refactor code, meaningful abstractions, don't mock everything",
            "Add more mocks",
            "Use bigger mocks",
            "Ignore tests"
        ]
    },
    {
        "q": "What is 'Contract Tests' alternative to mocking?",
        "o": [
            "Ensures that mocks stay in sync with real implementation",
            "Legal tests",
            "Paper tests",
            "Slow tests"
        ]
    },
    {
        "q": "Can you mock a database?",
        "o": [
            "Yes, by mocking the DAO/Repository (but Integration tests are better for DB logic)",
            "No",
            "Only SQL",
            "Only NoSQL"
        ]
    },
    {
        "q": "Can you mock a static utility class manually?",
        "o": [
            "Hard/Impossible without refactoring (wrapper) or字节code manipulation",
            "Yes, easy",
            "Always",
            "Standard"
        ]
    },
    {
        "q": "Why are static methods hard to mock?",
        "o": [
            "Because they are bound at compile time / no instance to replace",
            "Because they are fast",
            "Because they are public",
            "Because they are pure"
        ]
    },
    {
        "q": "What is the 'Wrapper' pattern for statics?",
        "o": [
            "Create an instance class that calls the static method, inject that instance, mock the instance",
            "Wrap text",
            "Gift wrap",
            "Code wrap"
        ]
    },
    {
        "q": "What is 'Virtual Mock'?",
        "o": [
            "Not a standard term.",
            "Cloud mock",
            "VR mock",
            "AI mock"
        ]
    },
    {
        "q": "What is 'Mockist' testing style?",
        "o": [
            "Heavy reliance on mocks and behavior verification (London School)",
            "Classic style",
            "Detroit style",
            "Integration style"
        ]
    },
    {
        "q": "What is 'Classicist' testing style?",
        "o": [
            "Prefer using real objects (state verification) and only mock external boundaries (Detroit School)",
            "Mockist",
            "London style",
            "Modern style"
        ]
    },
    {
        "q": "Mockist vs Classicist: which one verifies interactions more?",
        "o": [
            "Mockist",
            "Classicist",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "When is a Stub sufficient?",
        "o": [
            "When you only care about the return value to proceed with the test",
            "When verifying calls",
            "When Side effects matter",
            "Never"
        ]
    },
    {
        "q": "When is a Mock needed?",
        "o": [
            "When checking *if* and *how* a dependency was called (side effect is the message)",
            "Reading data",
            "Calculating math",
            "Always"
        ]
    },
    {
        "q": "What is 'Cascading Mocks'?",
        "o": [
            "Mock returning another Mock (fluent interface scenario)",
            "Falling mocks",
            "Water mock",
            "Error"
        ]
    },
    {
        "q": "Is mocking 3rd party types (e.g. library classes) recommended?",
        "o": [
            "Generally 'Don't mock types you don't own' (wrap them instead)",
            "Yes, always",
            "It is fine",
            "Required"
        ]
    },
    {
        "q": "Why 'Don't mock types you don't own'?",
        "o": [
            "Because their behavior might change, and your mock won't detecting it",
            "Copyright issues",
            "Compile errors",
            "Slow"
        ]
    },
    {
        "q": "What is 'Null Object Pattern'?",
        "o": [
            "Using a real object that does nothing (neutral behavior) instead of null or mock",
            "Null",
            "Mock",
            "Spy"
        ]
    },
    {
        "q": "Is Null Object a Test Double?",
        "o": [
            "Can be used as one (Dummy/Stub)",
            "No",
            "Yes, always",
            "Maybe"
        ]
    },
    {
        "q": "What is 'In-Memory Database'?",
        "o": [
            "H2, SQLite, etc. running in RAM (Fake)",
            "Mock",
            "Stub",
            "Spy"
        ]
    },
    {
        "q": "Is In-Memory DB a Mock?",
        "o": [
            "No, it's a Fake (has working logic)",
            "Yes",
            "Stub",
            "Dummy"
        ]
    },
    {
        "q": "What is 'Service Virtualization'?",
        "o": [
            "Simulating behavior of specific components (APIs) in heterogeneous environments (like sophisticated Record/Replay)",
            "Mocking",
            "Stubbing",
            "Unit testing"
        ]
    },
    {
        "q": "Does manual mocking require inheritance?",
        "o": [
            "Usually requires implementing an interface or extending a class",
            "No",
            "Yes, strict",
            "Only Java"
        ]
    },
    {
        "q": "Can you mock a final method manually?",
        "o": [
            "No, you cannot override it (unless using interfaces)",
            "Yes",
            "Always",
            "Easy"
        ]
    },
    {
        "q": "What is 'anonymous inner class' used for in manual mocking?",
        "o": [
            "Quickly creating an implementation of an interface for a test",
            "Hidden class",
            "Secret class",
            "Private class"
        ]
    },
    {
        "q": "What is 'lambda' used for in manual mocking?",
        "o": [
            "Implementing functional interfaces concisely",
            "Math",
            "Loop",
            "String"
        ]
    },
    {
        "q": "Is it okay to have logic in a Mock?",
        "o": [
            "Avoid complex logic; keeps tests simple. Use Fakes if logic is needed.",
            "Yes, complex is good",
            "Always",
            "Recommended"
        ]
    },
    {
        "q": "What is 'Fragile Test'?",
        "o": [
            "Test that breaks easily with internal code changes even if behavior is correct (often due to over-mocking)",
            "Weak test",
            "Glass test",
            "Bad test"
        ]
    },
    {
        "q": "Does Mocking improve design?",
        "o": [
            "Yes, forces decoupling and DI",
            "No",
            "Makes it worse",
            "Neutral"
        ]
    },
    {
        "q": "What is 'Spying' without a framework?",
        "o": [
            "Manually wrapping an object and counting calls in a decorated method",
            "Impossible",
            "Easy",
            "Hard"
        ]
    },
    {
        "q": "Can you usage 'Map' as a simple stub?",
        "o": [
            "Yes, stubbing a lookup service with a Map",
            "No",
            "Only List",
            "Only Set"
        ]
    },
    {
        "q": "What is 'Self-Shunt' pattern?",
        "o": [
            "The test class itself implements the interface expected by SUT and acts as the Mock/Stub",
            "Self test",
            "Recursion",
            "Mirror"
        ]
    },
    {
        "q": "Advantage of Self-Shunt?",
        "o": [
            "No need for inner classes or frameworks; assert directly in test methods",
            "Performance",
            "Memory",
            "Speed"
        ]
    },
    {
        "q": "Disadvantage of Self-Shunt?",
        "o": [
            "Pollutes test class with interface methods",
            "Slow",
            "Hard",
            "Complex"
        ]
    },
    {
        "q": "What is 'Verify' phase?",
        "o": [
            "Checking that expected interactions occurred",
            "Setup",
            "Run",
            "Tear down"
        ]
    },
    {
        "q": "Can you verify order of calls manually?",
        "o": [
            "Yes, by recording timestamps or sequence numbers in the manual mock",
            "No",
            "Only framework",
            "Impossible"
        ]
    },
    {
        "q": "What is 'Mock Object' book?",
        "o": [
            "Growing Object-Oriented Software, Guided by Tests",
            "Mockingbird",
            "Test Driven",
            "Clean Code"
        ]
    },
    {
        "q": "Who popularized Mock Roles, Objects?",
        "o": [
            "Freeman and Pryce",
            "Kent Beck",
            "Uncle Bob",
            "Martin Fowler"
        ]
    },
    {
        "q": "Is Mocking white-box or black-box testing?",
        "o": [
            "Tends towards White-box (knows about internal dependencies)",
            "Black-box",
            "Gray-box",
            "Blue-box"
        ]
    },
    {
        "q": "What is 'Strict Mock'?",
        "o": [
            "Fails on any unexpected call or order violation",
            "Lenient",
            "Loose",
            "Nice"
        ]
    },
    {
        "q": "What is 'Nice Mock'?",
        "o": [
            "Allows unexpected calls (returns defaults) without failing",
            "Strict",
            "Mean",
            "Hard"
        ]
    },
    {
        "q": "What is 'Mockito'?",
        "o": [
            "The most popular mocking framework for Java",
            "A drink",
            "A testing tool for Python",
            "A database"
        ]
    },
    {
        "q": "How to create a mock with Mockito (static method)?",
        "o": [
            "List mockedList = Mockito.mock(List.class);",
            "List mockedList = new Mock(List.class);",
            "List mockedList = Mockito.create(List.class);",
            "List mockedList = new Fake(List.class);"
        ]
    },
    {
        "q": "How to create a mock using annotation?",
        "o": [
            "@Mock List mockedList;",
            "@Spy List mockedList;",
            "@Stub List mockedList;",
            "@Fake List mockedList;"
        ]
    },
    {
        "q": "What is required to initialize @Mock annotations?",
        "o": [
            "MockitoAnnotations.openMocks(this) or @ExtendWith(MockitoExtension.class)",
            "Nothing",
            "New Mock()",
            "System.init()"
        ]
    },
    {
        "q": "How to stub a method to return a value?",
        "o": [
            "when(mock.method()).thenReturn(value);",
            "expect(mock.method()).andReturn(value);",
            "mock.method().returns(value);",
            "stub(mock.method()).toReturn(value);"
        ]
    },
    {
        "q": "How to stub a method to throw an exception?",
        "o": [
            "when(mock.method()).thenThrow(new Exception());",
            "when(mock.method()).throwException();",
            "expect(mock.method()).throw();",
            "mock.throw();"
        ]
    },
    {
        "q": "How to verify a method was called?",
        "o": [
            "verify(mock).method();",
            "assertCalled(mock.method());",
            "check(mock.method());",
            "expect(mock.method());"
        ]
    },
    {
        "q": "How to verify a method was NOT called?",
        "o": [
            "verify(mock, never()).method();",
            "verify(mock, times(1)).method();",
            "verifyNoCall(mock.method());",
            "assertNotCalled(mock);"
        ]
    },
    {
        "q": "How to verify a method was called exact number of times?",
        "o": [
            "verify(mock, times(n)).method();",
            "verify(mock, n).method();",
            "check(mock, n);",
            "count(mock, n);"
        ]
    },
    {
        "q": "How to verify at least one call?",
        "o": [
            "verify(mock, atLeastOnce()).method();",
            "verify(mock, 1+).method();",
            "verify(mock, min(1)).method();",
            "assertOne(mock);"
        ]
    },
    {
        "q": "What is 'any()' in Mockito?",
        "o": [
            "An argument matcher that matches any value (of a type)",
            "A random value",
            "Null",
            "Everything"
        ]
    },
    {
        "q": "How to stub using argument matchers?",
        "o": [
            "when(mock.get(anyInt())).thenReturn(element);",
            "when(mock.get(*)).thenReturn(element);",
            "when(mock.get(wildcard)).thenReturn(element);",
            "when(mock.get(?)).thenReturn(element);"
        ]
    },
    {
        "q": "Rule about argument matchers?",
        "o": [
            "If you use matchers, ALL arguments must be provided by matchers",
            "You can mix matchers and raw values",
            "Use only one matcher",
            "No rules"
        ]
    },
    {
        "q": "How to fix 'InvalidUseOfMatchersException'?",
        "o": [
            "Replace raw values with eq() matcher (e.g. eq('foo')) when mixing with other matchers",
            "Remove matchers",
            "Restart IDE",
            "Upgrade Mockito"
        ]
    },
    {
        "q": "What is 'doReturn(...).when(...)' syntax?",
        "o": [
            "Alternative stubbing syntax, mainly for spies or void methods (to avoid side effects at stubbing time)",
            "Standard syntax",
            "Deprecated",
            "Wrong"
        ]
    },
    {
        "q": "When MUST you use doReturn/doThrow family?",
        "o": [
            "When stubbing void methods or when calling the real method on a Spy would be dangerous",
            "Always",
            "Never",
            "For performance"
        ]
    },
    {
        "q": "How to stub a void method to throw exception?",
        "o": [
            "doThrow(new Exception()).when(mock).voidMethod();",
            "when(mock.voidMethod()).thenThrow(...); // compiler error",
            "mock.voidMethod() throw ...",
            "cannot stub void"
        ]
    },
    {
        "q": "What is '@InjectMocks'?",
        "o": [
            "Annotation to inject @Mock/ @Spy fields into the tested object",
            "Creates a mock",
            "Creates a spy",
            "Constructor"
        ]
    },
    {
        "q": "Does @InjectMocks create a mock of the SUT?",
        "o": [
            "No, it creates a REAL instance of the class under test and injects mocks into it",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "How does @InjectMocks inject?",
        "o": [
            "Constructor injection, then Setter injection, then Field injection (best effort)",
            "Randomly",
            "Only Constructor",
            "Only Field"
        ]
    },
    {
        "q": "What happens if @InjectMocks fails to inject?",
        "o": [
            "Mockito might silently fail or leave fields null (depends on strategy), but usually initializes the object",
            "Throws exception immediately",
            "Crashes JVM",
            "Retries"
        ]
    },
    {
        "q": "What is 'InOrder' verification?",
        "o": [
            "Verifying that interactions happened in a specific order",
            "Sorting",
            "Random verify",
            "Parallel verify"
        ]
    },
    {
        "q": "How to use InOrder?",
        "o": [
            "InOrder inOrder = inOrder(mock1, mock2); inOrder.verify(mock1).callA(); inOrder.verify(mock2).callB();",
            "verify(mock1).ordering()",
            "Order.verify(mock)",
            "Sequence.verify(mock)"
        ]
    },
    {
        "q": "What is 'mocking details'?",
        "o": [
            "Mockito.mockingDetails(mock) - inspects if object is mock/spy to get info",
            "Logs",
            "Debug info",
            "History"
        ]
    },
    {
        "q": "Can you mock a class with no-arg constructor?",
        "o": [
            "Yes",
            "No",
            "Only interface",
            "Only abstract"
        ]
    },
    {
        "q": "Can you mock an abstract class?",
        "o": [
            "Yes, Mockito will ignore abstract methods (unless stubbed) and mock others",
            "No",
            "Only concrete",
            "Only interface"
        ]
    },
    {
        "q": "What is 'MockitoJUnitRunner' (JUnit 4)?",
        "o": [
            "Runner to initialize mocks and validate usage in JUnit 4",
            "JUnit 5 Extension",
            "TestNG Runner",
            "Main class"
        ]
    },
    {
        "q": "What is 'MockitoExtension' (JUnit 5)?",
        "o": [
            "Extension to initialize mocks (@Mock, etc.) in JUnit 5",
            "Runner",
            "Rule",
            "Plugin"
        ]
    },
    {
        "q": "Default scope of Mockito mock?",
        "o": [
            "Test method scope (reset after each test if created in method, or if lifecycle dictates)",
            "Class scope",
            "Suite scope",
            "Global"
        ]
    },
    {
        "q": "Mockito 'reset(mock)' method?",
        "o": [
            "Clears all interactions and stubs from the mock (use sparingly, indicates bad design)",
            "Restarts mock",
            "Deletes mock",
            "Creates mock"
        ]
    },
    {
        "q": "What is 'ArgumentCaptor'?",
        "o": [
            "Allows capturing arguments passed to verified methods for further assertions",
            "Video capturer",
            "Screen grab",
            "Log"
        ]
    },
    {
        "q": "How to use ArgumentCaptor?",
        "o": [
            "ArgumentCaptor<T> c = ArgumentCaptor.forClass(T.class); verify(m).do(c.capture()); assertEquals(x, c.getValue());",
            "capture(arg)",
            "mock.capture()",
            "Hold()"
        ]
    },
    {
        "q": "What is '@Captor'?",
        "o": [
            "Annotation to create ArgumentCaptor field",
            "Annotation for Mock",
            "Annotation for Spy",
            "Annotation for Stub"
        ]
    },
    {
        "q": "What is 'thenAnswer(...)'?",
        "o": [
            "Detailed stubbing where you define a callback (Answer interface) to compute return value dynamically",
            "Simple return",
            "Throw exception",
            "Do nothing"
        ]
    },
    {
        "q": "Interface 'Answer<T>' method?",
        "o": [
            "T answer(InvocationOnMock invocation)",
            "T return(Object o)",
            "void run()",
            "T get()"
        ]
    },
    {
        "q": "How to access arguments in Answer?",
        "o": [
            "invocation.getArgument(0)",
            "invocation.args[0]",
            "invocation.get(0)",
            "this.arg"
        ]
    },
    {
        "q": "What is 'Spy' in Mockito?",
        "o": [
            "Partial mock on a real object; real methods are called unless stubbed",
            "Full mock",
            "Dummy",
            "Double"
        ]
    },
    {
        "q": "How to create a Spy?",
        "o": [
            "List spy = spy(new ArrayList());",
            "spy(List.class)",
            "mock(List.class, SPY)",
            "new Spy()"
        ]
    },
    {
        "q": "When verifying a spy, can you verify real method calls?",
        "o": [
            "Yes, calls are tracked just like mocks",
            "No",
            "Sometimes",
            "Only if abstract"
        ]
    },
    {
        "q": "Important pitfall with Spy and 'when(...)'?",
        "o": [
            "when(spy.get(0)).thenReturn(...) will call real get(0) and throw IndexOutOfBounds. Use doReturn(...).when(spy).get(0)",
            "It works fine",
            "Spy crashes",
            "Nothing happens"
        ]
    },
    {
        "q": "What is '@Spy'?",
        "o": [
            "Annotation to create a spy (must initialize with instance or default constructor)",
            "Mock annotation",
            "Stub annotation",
            "Verify annotation"
        ]
    },
    {
        "q": "Can you spy on an interface?",
        "o": [
            "No, only classes (Spy wraps an instance). But you can Mock an interface.",
            "Yes",
            "Always",
            "If public"
        ]
    },
    {
        "q": "What is 'BDDMockito'?",
        "o": [
            "Mockito aliases following BDD naming (given/willReturn instead of when/thenReturn)",
            "Different library",
            "Plugin",
            "Extension"
        ]
    },
    {
        "q": "BDD syntax for stubbing?",
        "o": [
            "given(mock.method()).willReturn(value)",
            "when(mock.method()).thenReturn(value)",
            "expect(mock.method()).return(value)",
            "stub(mock.method())"
        ]
    },
    {
        "q": "BDD syntax for verification?",
        "o": [
            "then(mock).should().method()",
            "verify(mock).method()",
            "assert(mock)",
            "check(mock)"
        ]
    },
    {
        "q": "Mockito 'strictness' levels?",
        "o": [
            "Lenient, Warn, Strict_Stubs (default in JUnit 5 extension varies)",
            "On, Off",
            "High, Low",
            "1, 2, 3"
        ]
    },
    {
        "q": "What does 'Strict_Stubs' do?",
        "o": [
            "Ensures no unnecessary stubs (throws if stubbed method not called) and checks argument alignment",
            "Nothing",
            "Speed up",
            "Slow down"
        ]
    },
    {
        "q": "How to enable lenient stubbing explicitly?",
        "o": [
            "lenient().when(mock.method()).thenReturn(...)",
            "strict().when(...)",
            "force().when(...)",
            "allow().when(...)"
        ]
    },
    {
        "q": "Why remove unused stubs?",
        "o": [
            "Cleaner tests, ensures test is actually using what it sets up",
            "Save memory",
            "Save disk",
            "Mockito requirement"
        ]
    },
    {
        "q": "Does Mockito support final classes?",
        "o": [
            "Yes, with 'mock-maker-inline' extension (since Mockito 2.x)",
            "No, never",
            "Native support",
            "Only Java 17"
        ]
    },
    {
        "q": "How to enable inline mock maker?",
        "o": [
            "Add 'mockito-inline' dependency or create strict configuration file",
            "Magic",
            "Default",
            "Cannot"
        ]
    },
    {
        "q": "What is 'MockSettings'?",
        "o": [
            "Allows extra configuration: name, defaultAnswer, extraInterfaces, lenient",
            "Settings file",
            "Config class",
            "Env var"
        ]
    },
    {
        "q": "How to pass settings?",
        "o": [
            "mock(Class.class, withSettings().name('myMock').lenient())",
            "new Mock(settings)",
            "config(mock)",
            "setup(mock)"
        ]
    },
    {
        "q": "What is 'RETURNS_DEEP_STUBS'?",
        "o": [
            "Default Answer that returns mocks of deeper objects (foo.bar().baz())",
            "Recursion",
            "Error",
            "Log"
        ]
    },
    {
        "q": "When to use RETURNS_DEEP_STUBS?",
        "o": [
            "Legacy code with long chains (Law of Demeter violation). Avoid in new code.",
            "Always",
            "For creating builders",
            "For fluency"
        ]
    },
    {
        "q": "What is 'RETURNS_SMART_NULLS'?",
        "o": [
            "Returns Short/Empty values instead of null, and gives better stack trace if used",
            "Returns null",
            "Returns objects",
            "Returns mocks"
        ]
    },
    {
        "q": "What is 'RETURNS_MOCKS'?",
        "o": [
            "Returns mocks for return types that can be mocked (default is usually RETURNS_DEFAULTS)",
            "Returns null",
            "Returns real",
            "Returns nothing"
        ]
    },
    {
        "q": "Default Answer for Mockito mocks?",
        "o": [
            "RETURNS_DEFAULTS (null for objects, 0 for numbers, false for boolean, empty collections)",
            "RETURNS_MOCKS",
            "RETURNS_SMART_NULLS",
            "Throws Exception"
        ]
    },
    {
        "q": "Can you mock static methods with plain Mockito (before 3.4)?",
        "o": [
            "No, required PowerMock. Now supported in Mockito 3.4+ via mockStatic",
            "Yes",
            "Easy",
            "Native"
        ]
    },
    {
        "q": "How to mock static in Mockito 3.4+?",
        "o": [
            "try (MockedStatic<Util> mocked = mockStatic(Util.class)) { mocked.when(Util::method).thenReturn(val); ... }",
            "mock(Util.class)",
            "staticMock(Util.class)",
            "spy(Util.class)"
        ]
    },
    {
        "q": "Scope of static mock?",
        "o": [
            "Thread-local containment within the try-with-resources block",
            "Global (dangerous)",
            "Class",
            "Method"
        ]
    },
    {
        "q": "Can you mock construction (new Object()) in Mockito?",
        "o": [
            "Yes, mockConstruction(Target.class, (mock, context) -> ...)",
            "No",
            "With PowerMock",
            "With ByteBuddy"
        ]
    },
    {
        "q": "What is 'Invocation'?",
        "o": [
            "Object containing method called, arguments, execution time, etc.",
            "Call",
            "Request",
            "Command"
        ]
    },
    {
        "q": "Can you verify no more interactions?",
        "o": [
            "verifyNoMoreInteractions(mock);",
            "verifyEnd(mock)",
            "assertEmpty(mock)",
            "done(mock)"
        ]
    },
    {
        "q": "Is 'verifyNoMoreInteractions' recommended everywhere?",
        "o": [
            "No, makes tests fragile (overspecified). Use only when rigorous strictness is needed.",
            "Yes, always",
            "Best practice",
            "Standard"
        ]
    },
    {
        "q": "What is 'Timeout' verification?",
        "o": [
            "verify(mock, timeout(100)).method(); (Wait up to 100ms for interaction)",
            "Sleep",
            "Delay",
            "Lag"
        ]
    },
    {
        "q": "Difference between timeout() and after()?",
        "o": [
            "timeout returns as soon as verification passes (async). after waits full duration (to ensure nothing happens).",
            "Same",
            "No difference",
            "Inverse"
        ]
    },
    {
        "q": "How to capture multiple arguments?",
        "o": [
            "captor.capture() called multiple times, then captor.getAllValues()",
            "Cannot",
            "captor.last()",
            "captor.first()"
        ]
    },
    {
        "q": "What is 'AdditionalAnswers'?",
        "o": [
            "Collection of helpful answers (returnsFirstArg, returnsSecondArg, delegatesTo)",
            "Questions",
            "Helpers",
            "Tools"
        ]
    },
    {
        "q": "How to stub a method to return its first argument?",
        "o": [
            "when(m.echo(any())).thenAnswer(AdditionalAnswers.returnsFirstArg())",
            "returns(arg1)",
            "returnArgument(0)",
            "echo()"
        ]
    },
    {
        "q": "Can you mock final fields?",
        "o": [
            "No. Mocking is about behavior/methods. Final fields are state.",
            "Yes",
            "With reflection",
            "With Unsafe"
        ]
    },
    {
        "q": "What is a 'Partial Mock' using 'spy()'?",
        "o": [
            "The real object is instrumented. Calls usually go to real methods unless stubbed.",
            "Fake",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "What is 'Partial Mock' using 'thenCallRealMethod()'?",
        "o": [
            "A mock where specific methods are told to call real implementation. when(mock.foo()).thenCallRealMethod()",
            "Spy",
            "Stub",
            "Fake"
        ]
    },
    {
        "q": "Difference mock-thenCallRealMethod vs spy?",
        "o": [
            "Spy is real object centered (default real). Mock is mock centered (default mock).",
            "Same",
            "None",
            "Reversed"
        ]
    },
    {
        "q": "Can Mockito mock equals() and hashCode()?",
        "o": [
            "Usually no, Mockito relies on them for its own tracking. Avoid mocking them usually.",
            "Yes, always",
            "Required",
            "Standard"
        ]
    },
    {
        "q": "Can Mockito mock private methods directly?",
        "o": [
            "No, not supported by design (breaks encapsulation).",
            "Yes",
            "With settings",
            "With plugin"
        ]
    },
    {
        "q": "How to test private methods then?",
        "o": [
            "Test via public interface, or refactor (extract class), or use Reflection (Whitebox) if desperate.",
            "Mock them",
            "Delete them",
            "Make public"
        ]
    },
    {
        "q": "What is 'ReflectionTestUtils' (Spring) or Whitebox?",
        "o": [
            "Utilities to set private fields or call private methods in tests",
            "Mocking tools",
            "Verify tools",
            "Logging tools"
        ]
    },
    {
        "q": "What is 'Mockito.reset()' use case?",
        "o": [
            "Rarely needed. Maybe in containers/stateful tests. Usually, create new mocks per test (@BeforeEach).",
            "Every test",
            "End of test",
            "Start of test"
        ]
    },
    {
        "q": "Is Mockito thread-safe?",
        "o": [
            "Mocks can be shared, but interaction verification is tricky across threads. Concurrent testing needs care.",
            "Fully locked",
            "Not at all",
            "Yes"
        ]
    },
    {
        "q": "What allows creating mocks without annotations?",
        "o": [
            "Mockito.mock(Class)",
            "Mockito.init()",
            "Mockito.start()",
            "Mockito.run()"
        ]
    },
    {
        "q": "What is '@MockBean'?",
        "o": [
            "Spring Boot annotation, NOT Mockito core. Replaces a bean in ApplicationContext with a Mockito mock.",
            "Mockito Core",
            "Java Annotation",
            "JUnit Annotation"
        ]
    },
    {
        "q": "Does Mockito depend on JUnit?",
        "o": [
            "No, it works with TestNG, JUnit 4, JUnit 5, etc.",
            "Yes, strictly",
            "Depends on Maven",
            "Depends on Java"
        ]
    },
    {
        "q": "Where to find Mockito docs?",
        "o": [
            "javadoc.io / mockito.org",
            "junit.org",
            "oracle.com",
            "google.com"
        ]
    },
    {
        "q": "Latest major version of Mockito?",
        "o": [
            "Mockito 5 (supports Java 11+ primarily, though 4 is widely used)",
            "Mockito 2",
            "Mockito 1",
            "Mockito 10"
        ]
    },
    {
        "q": "What JDK version does Mockito 5 require?",
        "o": [
            "Java 11+",
            "Java 8",
            "Java 17",
            "Java 21"
        ]
    },
    {
        "q": "Does Mockito use ByteBuddy?",
        "o": [
            "Yes, as the default bytecode generation engine",
            "No, CGLIB",
            "No, ASM",
            "No, Javassist"
        ]
    },
    {
        "q": "What is 'Objenesis'?",
        "o": [
            "Library used by Mockito to instantiate objects without calling constructors",
            "Mock engine",
            "Spy engine",
            "Verify engine"
        ]
    },
    {
        "q": "Can you mock Enums?",
        "o": [
            "Yes, but generally weird. Enums are constants.",
            "No",
            "Only one",
            "Only values"
        ]
    },
    {
        "q": "Can you mock primitives?",
        "o": [
            "Mock objects, no. But methods returning primitives can be stubbed.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "What does a mock return for int by default?",
        "o": [
            "0",
            "1",
            "-1",
            "Exception"
        ]
    },
    {
        "q": "What does a mock return for boolean by default?",
        "o": [
            "false",
            "true",
            "exception",
            "random"
        ]
    },
    {
        "q": "What is 'ArgumentCaptor.getAllValues()?'",
        "o": [
            "Returns a List of all values captured if verify was called multiple times",
            "Returns single value",
            "Returns size",
            "Returns last value"
        ]
    },
    {
        "q": "Can you use ArgumentCaptor with Stubbing (when/thenReturn)?",
        "o": [
            "Yes, but tricky. Better to use argument matchers (any()) or Answer for stubbing logic. Captor is ideal for Verify.",
            "No",
            "Only for void",
            "Required"
        ]
    },
    {
        "q": "What happens if you use @Captor on a non-ArgumentCaptor field?",
        "o": [
            "Mockito might throw an exception or ignore it",
            "Nothing",
            "Fails silently",
            "Works"
        ]
    },
    {
        "q": "What is 'AdditionalMatchers'?",
        "o": [
            "Utility class with more matchers (gt, lt, not, and, or, aryEq, cmpEq)",
            "Standard Matchers",
            "Core Matchers",
            "Java Util"
        ]
    },
    {
        "q": "How to match an array content equality?",
        "o": [
            "AdditionalMatchers.aryEq(arr)",
            "eq(arr)",
            "same(arr)",
            "equals(arr)"
        ]
    },
    {
        "q": "How to combine matchers (AND)?",
        "o": [
            "and(gt(5), lt(10))",
            "gt(5) && lt(10)",
            "plus(5, 10)",
            "combine(5, 10)"
        ]
    },
    {
        "q": "What is 'Mockito.ignoreStubs(mocks...)'?",
        "o": [
            "Used in verifyNoMoreInteractions() to ignore stubbed method calls (focus only on unstubbed side-effects)",
            "Delete stubs",
            "Reset stubs",
            "Hide stubs"
        ]
    },
    {
        "q": "Why ignore stubs in verification?",
        "o": [
            "Because stubs are usually for setup (query), not for verifying behavior (command). Reduces noise.",
            "Performance",
            "It is default",
            "Impossible"
        ]
    },
    {
        "q": "What is the 'VerificationMode' interface?",
        "o": [
            "Interface for strategies like times(N), never(), atLeast(N), timeout(N)",
            "Mode",
            "Enum",
            "Type"
        ]
    },
    {
        "q": "Can you write custom VerificationMode?",
        "o": [
            "Yes",
            "No",
            "Only Mockito team",
            "Only in Java 9"
        ]
    },
    {
        "q": "What is 'CallsRealMethods'?",
        "o": [
            "An Answer that calls the real method (used by Spy)",
            "A spy",
            "A mock",
            "A stub"
        ]
    },
    {
        "q": "What is 'MockName'?",
        "o": [
            "Internal interface for retrieving mock name",
            "String",
            "ID",
            "Label"
        ]
    },
    {
        "q": "How to check if a mock has any interactions?",
        "o": [
            "verifyNoInteractions(mock) throws if it has",
            "mock.hasInteractions()",
            "mock.isEmpty()",
            "check(mock)"
        ]
    },
    {
        "q": "What is 'Mockito.description(String)'?",
        "o": [
            "Adds a custom failure message to the verification (since Mockito 2.1)",
            "Comments",
            "Logs",
            "Tags"
        ]
    },
    {
        "q": "Syntax for description?",
        "o": [
            "verify(mock, description('Should have called foo')).foo();",
            "verify(mock).description('...').foo()",
            "verify('...', mock).foo()",
            "assert('...', mock.foo())"
        ]
    },
    {
        "q": "What is 'Mockito.framework()''?",
        "o": [
            "Access to internal Mockito framework configuration (listeners, plugins)",
            "Nothing",
            "Main entry",
            "Start"
        ]
    },
    {
        "q": "What is 'InstantiatorProvider'?",
        "o": [
            "Plugin API to control how mocks are instantiated",
            "Constructor",
            "Factory",
            "Builder"
        ]
    },
    {
        "q": "What is 'MockMaker'?",
        "o": [
            "Plugin API to control usage of CGLIB vs ByteBuddy vs Inline",
            "Creator",
            "Builder",
            "Factory"
        ]
    },
    {
        "q": "What is 'StackTraceCleaner'?",
        "o": [
            "Plugin to clean up stack traces in failures (remove Mockito internal lines)",
            "Garbage collector",
            "Duster",
            "Filter"
        ]
    },
    {
        "q": "How to spy on an abstract class?",
        "o": [
            "Mockito.spy(Abstract.class) (will call real methods, abstract ones must be stubbed or are ignored)",
            "Cannot",
            "Use Mock",
            "Use Fake"
        ]
    },
    {
        "q": "Can you use @InjectMocks with @Spy?",
        "o": [
            "Yes, Mockito will try to inject mocks INTO the spy as well",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Is @InjectMocks + @Spy recommended?",
        "o": [
            "Use with caution. It's complex state management. Prefer manual wiring used in constructor.",
            "Yes perfect",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'reset' danger?",
        "o": [
            "If you reset a mock in the middle of a test, other threads/code holding reference might be confused. State is lost.",
            "None",
            "Memory leak",
            "Segfault"
        ]
    },
    {
        "q": "What is 'One-liner stubbing'?",
        "o": [
            "mock = when(mock(Class.class).method()).thenReturn(val).getMock(); (Fluent API pattern)",
            "Quick mock",
            "Short mock",
            "Small mock"
        ]
    },
    {
        "q": "Can you stub 'void' method to do nothing?",
        "o": [
            "It does nothing by default. Explicitly: doNothing().when(mock).voidMethod()",
            "No",
            "Always returns null",
            "Throws"
        ]
    },
    {
        "q": "When is doNothing() useful?",
        "o": [
            "Only for Spies (to prevent real execution) or if void method was previously stubbed to throw",
            "Always",
            "For stats",
            "For logging"
        ]
    },
    {
        "q": "What is 'Stubbing Consecutive Calls'?",
        "o": [
            "when(m.foo()).thenReturn(1).thenReturn(2).thenThrow(ex)",
            "Chaining",
            "Looping",
            "Recursion"
        ]
    },
    {
        "q": "Alternative syntax for consecutive?",
        "o": [
            "when(m.foo()).thenReturn(1, 2, 3)",
            "returns(1, 2, 3)",
            "list(1, 2, 3)",
            "array(1, 2, 3)"
        ]
    },
    {
        "q": "What happens after the last consecutive answer?",
        "o": [
            "The last answer is repeated forever",
            "Returns null",
            "Throws exception",
            "Resets to first"
        ]
    },
    {
        "q": "What is mocks of final classes limitation?",
        "o": [
            "Requires mockito-inline. Without it, Mockito can't subclass final class.",
            "Impossible",
            "No limit",
            "Slow"
        ]
    },
    {
        "q": "Can you mock JDK classes like String or Integer?",
        "o": [
            "Generally no (bootstrapped classes). Wrapper is better. Mockito-inline allows some if careful.",
            "Yes always",
            "Easy",
            "Recommended"
        ]
    },
    {
        "q": "What is 'Verify in order' across multiple mocks?",
        "o": [
            "Supported using single InOrder object",
            "Not supported",
            "Using threads",
            "Using timestamps"
        ]
    },
    {
        "q": "Can InOrder verify calls that were not verified explicitly?",
        "o": [
            "InOrder only verifies what you ask it to. It doesn't fail if other calls happened unless strict.",
            "Yes",
            "Fails",
            "Ignores"
        ]
    },
    {
        "q": "Does verify(mock) check order?",
        "o": [
            "No, only count. Use InOrder for sequence.",
            "Yes",
            "Sometimes",
            "Maybe"
        ]
    },
    {
        "q": "What is 'lenient()'?",
        "o": [
            "Marks a specific stubbing as lenient (Mockito won't remove it or warn if unused)",
            "Soft",
            "Easy",
            "Weak"
        ]
    },
    {
        "q": "Why is 'lenient()' bad default?",
        "o": [
            "Hides dead code in tests (setup that does nothing)",
            "Slow",
            "Complex",
            "Ugly"
        ]
    },
    {
        "q": "What is 'Mockito.lenient() ' static method?",
        "o": [
            "Wait, lenient() is usually invoked on Strictness object/rule. Or lenient().when(...).",
            "Global setting",
            "Local variable",
            "Field"
        ]
    },
    {
        "q": "How to make a whole mock lenient?",
        "o": [
            "mock(Class.class, withSettings().lenient())",
            "lenient(mock)",
            "mock.setLenient()",
            "new LenientMock()"
        ]
    },
    {
        "q": "What is 'VerboseMock'?",
        "o": [
            "Debugging feature (withSettings().verboseLogging()) to print all interactions to console",
            "Loud mock",
            "Big mock",
            "Log mock"
        ]
    },
    {
        "q": "What is 'InvocationOnMock'?",
        "o": [
            "Context passed to Answer.contains method, arguments, mock reference",
            "Call",
            "Stack",
            "Event"
        ]
    },
    {
        "q": "Can you change arguments in Answer?",
        "o": [
            "If arguments are mutable objects, yes (side effects). If primitives/immutable, no impact on caller.",
            "Yes always",
            "No never",
            "Maybe"
        ]
    },
    {
        "q": "What is 'ArgumentMatcher<T>' interface?",
        "o": [
            "boolean matches(T argument)",
            "boolean check(T arg)",
            "void match(T arg)",
            "T get()"
        ]
    },
    {
        "q": "How to create custom matcher?",
        "o": [
            "Implement ArgumentMatcher, then use argThat(new MyMatcher())",
            "Use string",
            "Use regex",
            "Use int"
        ]
    },
    {
        "q": "Simplest way to use custom logic for matching?",
        "o": [
            "argThat(arg -> arg.getName().equals('Bob')) (Lambda)",
            "Custom class",
            "Anonymous class",
            "String"
        ]
    },
    {
        "q": "What is 'hamcrest' integration?",
        "o": [
            "Mockito.argThat(org.hamcrest.Matcher)",
            "Mockito.hamcrest()",
            "Mockito.match()",
            "Mockito.is()"
        ]
    },
    {
        "q": "What is 'Mockito v1 vs v2' argument matchers?",
        "o": [
            "v1 extended Hamcrest Matcher. v2 uses its own ArgumentMatcher interface (cleaner, no hamcrest dep).",
            "Same",
            "No difference",
            "Worse"
        ]
    },
    {
        "q": "Is PowerMock recommended used with Mockito 5?",
        "o": [
            "No, Mockito-inline replaces most PowerMock use cases (static, final). PowerMock is in maintenance mode.",
            "Yes",
            "Always",
            "Required"
        ]
    },
    {
        "q": "What distinguishes PowerMock?",
        "o": [
            "Uses custom ClassLoader to modify bytecode deeply (allows mocking private, static, constructors, system classes)",
            "Uses Reflection",
            "Uses Proxies",
            "Uses Agents"
        ]
    },
    {
        "q": "Cons of PowerMock?",
        "o": [
            "Custom ClassLoader causes conflicts with other tools (coverage, other agents), slow, fragile updates.",
            "None",
            "Fast",
            "Simple"
        ]
    },
    {
        "q": "What is 'Awaitility'?",
        "o": [
            "Library for testing asynchronous systems (wait for condition), complementary to Mockito",
            "Wait tool",
            "Sleep tool",
            "Mock tool"
        ]
    },
    {
        "q": "How to test async logic with Mockito?",
        "o": [
            "Use timeout() verification or Awaitility to wait for side effects",
            "Thread.sleep",
            "Guess",
            "Impossible"
        ]
    },
    {
        "q": "What is 'EasyMock'?",
        "o": [
            "Another mocking framework (older than Mockito). More strict record/replay approach by default.",
            "Simpler Mockito",
            "Complex Mockito",
            "Clone"
        ]
    },
    {
        "q": "What is 'JMock'?",
        "o": [
            "Another mocking framework (pioneered Mock Objects). Uses Hamcrest extensively.",
            "Java Mock",
            "JSON Mock",
            "Jest Mock"
        ]
    },
    {
        "q": "Why Mockito won over EasyMock/JMock?",
        "o": [
            "Simpler 'When/Then' usage (no record-replay switching), sensible defaults (Nice mocks), clean syntax",
            "Marketing",
            "Speed",
            "Logo"
        ]
    },
    {
        "q": "What is 'Spies' limitation in serialization?",
        "o": [
            "Spies are hard to serialize. Mocks can be serializable withSettings().serializable().",
            "None",
            "Impossible",
            "Easy"
        ]
    },
    {
        "q": "How to make a mock serializable?",
        "o": [
            "mock(List.class, withSettings().serializable())",
            "Cannot",
            "Automatic",
            "Implement Serializable"
        ]
    },
    {
        "q": "Why serialize a mock?",
        "o": [
            "Testing distributed systems, sticky sessions, or specific frameworks requiring serialization",
            "Saving to disk",
            "Caching",
            "Logging"
        ]
    },
    {
        "q": "What is 'Extra Interfaces'?",
        "o": [
            "mock(List.class, withSettings().extraInterfaces(Serializable.class))",
            "Mixins",
            "Traits",
            "Aspects"
        ]
    },
    {
        "q": "Can you mock multiple interfaces?",
        "o": [
            "Yes, create mock of one and add others as extraInterfaces",
            "No",
            "Only two",
            "Only three"
        ]
    },
    {
        "q": "What is 'Constructor Mocking' limitation in Mockito-inline?",
        "o": [
            "Scope must be managed (try-with-resources). Cannot mock constructor of system classes sometimes.",
            "None",
            "Slow",
            "Hard"
        ]
    },
    {
        "q": "What is 'Mocking statics' risk?",
        "o": [
            "Global state pollution. If not closed/cleared, affects other tests. Parallel execution issues.",
            "None",
            "Speed",
            "Dependencies"
        ]
    },
    {
        "q": "How to ensure static mocks are closed?",
        "o": [
            "Use try-with-resources block",
            "Explicit close() in finally",
            "GC",
            "Auto"
        ]
    },
    {
        "q": "Behavior of Spy on interface methods?",
        "o": [
            "Impossible directly (interface has no code). You mock interfaces, spy instances.",
            "Works",
            "Calls default",
            "Throws"
        ]
    },
    {
        "q": "Can you spy on a Mock?",
        "o": [
            "Technically possible (spy(mock)), but redundant. Mocks are already doubles.",
            "Yes",
            "No",
            "Required"
        ]
    },
    {
        "q": "What is 'clearInvocations(mock)'?",
        "o": [
            "Clears invocation history (for verification) but keeps stubs",
            "Resets everything",
            "Clears stubs",
            "Deletes mock"
        ]
    },
    {
        "q": "Difference reset() vs clearInvocations()?",
        "o": [
            "reset clears Stubs AND History. clearInvocations clears ONLY History.",
            "Same",
            "Inverse",
            "None"
        ]
    },
    {
        "q": "When to use clearInvocations?",
        "o": [
            "In a long test where you want to verify 'what happened since X'",
            "Always",
            "Never",
            "At start"
        ]
    },
    {
        "q": "Does @Mock need public class?",
        "o": [
            "No, Mockito can mock package-private classes",
            "Yes",
            "Maybe",
            "Only Java 8"
        ]
    },
    {
        "q": "Mockito support for JPMS (Modules)?",
        "o": [
            "Yes, works with modules, might need --add-opens if reflecting on private members",
            "No",
            "Maybe",
            "Future"
        ]
    },
    {
        "q": "What if mockito cannot mock/spy because of 'Can not set final field'?",
        "o": [
            "Remove final or usage constructor injection, or check if field is static final (hard to inject)",
            "Use PowerMock",
            "Ignore",
            "Cry"
        ]
    },
    {
        "q": "Can you use Mockito with Kotlin 'object' (singleton)?",
        "o": [
            "mockStatic can handle it, or specific Kotlin libraries like MockK (preferred for Kotlin)",
            "Yes directly",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "What is 'MockK'?",
        "o": [
            "Mocking library designed specifically for Kotlin (coroutines, objects, extension functions)",
            "Mockito clone",
            "Java lib",
            "Groovy lib"
        ]
    },
    {
        "q": "Mockito vs MockK?",
        "o": [
            "Mockito is Java-first (works in Kotlin with issues). MockK is Kotlin-first.",
            "Same",
            "Mockito better",
            "MockK worse"
        ]
    },
    {
        "q": "What is 'Mockito-Python'?",
        "o": [
            "A Python library inspired by Mockito java",
            "Real Mockito",
            "Port",
            "Fake"
        ]
    },
    {
        "q": "Is Mockito related to 'Moq' (.NET)?",
        "o": [
            "Conceptually similar (mocking framework), but different languages",
            "Direct port",
            "Same author",
            "Dependency"
        ]
    },
    {
        "q": "What is 'ArgumentCaptor' generic warning?",
        "o": [
            "Unchecked assignment (generics erasure). @Captor handles this cleanly.",
            "Ignore",
            "Error",
            "Bug"
        ]
    },
    {
        "q": "Can you mock 'System.currentTimeMillis()' with Mockito?",
        "o": [
            "No, it's a native static method. Use MockedStatic on System? No, System is protected. Use Clock abstraction!",
            "Yes",
            "Maybe",
            "PowerMock"
        ]
    },
    {
        "q": "Best practice for time testing?",
        "o": [
            "Inject java.time.Clock and mock the Clock, or use Clock.fixed()",
            "Mock System",
            "Sleep",
            "Wait"
        ]
    },
    {
        "q": "How to stub a Clock?",
        "o": [
            "when(clock.instant()).thenReturn(fixedInstant)",
            "clock.setTime()",
            "new Clock()",
            "System.setClock()"
        ]
    },
    {
        "q": "Can you mock 'Logger'?",
        "o": [
            "Yes, but verifying log messages is brittle. Better use LogCaptor or memory appender.",
            "No",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'Mockito.mockingDetails(mock).printInvocations()'?",
        "o": [
            "Prints all interactions with the mock to stdout (useful for debugging)",
            "Logs",
            "Nothing",
            "Errors"
        ]
    },
    {
        "q": "What is 'Mockito.mockingDetails(mock).getInvocations()'?",
        "o": [
            "Returns Collection<Invocation> for programmatic inspection",
            "List",
            "Set",
            "Map"
        ]
    },
    {
        "q": "What is 'Mockito.mockingDetails(mock).getStubbings()'?",
        "o": [
            "Returns Collection<Stubbing> to see what is stubbed",
            "List",
            "Set",
            "Map"
        ]
    },
    {
        "q": "Can you determine if an object is a mock?",
        "o": [
            "Mockito.mockingDetails(obj).isMock()",
            "obj instanceof Mock",
            "obj.isMock()",
            "Mock.check(obj)"
        ]
    },
    {
        "q": "Can you determine if an object is a spy?",
        "o": [
            "Mockito.mockingDetails(obj).isSpy()",
            "obj instanceof Spy",
            "obj.isSpy()",
            "Spy.check(obj)"
        ]
    },
    {
        "q": "What is 'Contract Testing'?",
        "o": [
            "Verifying that providers and consumers of a service adhere to a shared contract (schema + behavior)",
            "Legal testing",
            "Unit testing",
            "Load testing"
        ]
    },
    {
        "q": "Why mock is not enough for microservices?",
        "o": [
            "Mocks can drift from reality (provider changes API, consumer mocks stick to old API). Contract tests prevent this.",
            "Mocks are slow",
            "Mocks are hard",
            "No reason"
        ]
    },
    {
        "q": "What is 'Consumer-Driven Contracts' (CDC)?",
        "o": [
            "Pattern where consumers define expectations (contracts), and providers are verified against them",
            "Provider-driven",
            "Random",
            "Manual"
        ]
    },
    {
        "q": "What is 'Pact'?",
        "o": [
            "Popular framework for consumer-driven contract testing",
            "Mock framework",
            "Unit framework",
            "Web server"
        ]
    },
    {
        "q": "What replaces Mocks in Contract Tests?",
        "o": [
            "The contract (stub generated from contract for consumer; verification suite for provider)",
            "Nothing",
            "Spies",
            "Dummies"
        ]
    },
    {
        "q": "hexagonal Architecture (Ports & Adapters) enhances testing how?",
        "o": [
            "By isolating core domain logic from infrastructure (DB, Web), allowing easy mocking of 'Ports'",
            "By adding layers",
            "By removing tests",
            "By slowing down"
        ]
    },
    {
        "q": "In Hexagonal, what do you mock when testing Domain?",
        "o": [
            "The 'Secondary Ports' (interfaces to Driven Adapters - DB, external APIs)",
            "The UI",
            "The Controller",
            "Logic"
        ]
    },
    {
        "q": "What is 'Sociable Unit Tests'?",
        "o": [
            "Unit tests that allow real collaborators (no mocks) if they are fast/deterministic (Detroit School)",
            "Solitary tests",
            "Friendly tests",
            "Social network"
        ]
    },
    {
        "q": "What is 'Solitary Unit Tests'?",
        "o": [
            "Unit tests where ALL collaborators are mocked (London School)",
            "Sociable tests",
            "Integration tests",
            "Lonely tests"
        ]
    },
    {
        "q": "When is it better to NOT mock?",
        "o": [
            "When the collaborator is a value object, simple entity, or fast/deterministic calculation",
            "Always",
            "Never",
            "For DB"
        ]
    },
    {
        "q": "What is 'Humble Object Pattern'?",
        "o": [
            "Splitting code into logic (easy to test) and hard-to-test boundary code (Humble Object), keeping Humble Object minimal",
            "Proud Object",
            "Smart Object",
            "God Object"
        ]
    },
    {
        "q": "Example of Humble Object usage?",
        "o": [
            "Moving logic out of UI View (Humble) into Presenter/ViewModel (Testable)",
            "Testing UI",
            "Testing DB",
            "Testing Network"
        ]
    },
    {
        "q": "What is 'Test-Specific Subclass' pattern?",
        "o": [
            "Subclassing SUT in test to override specific methods (seams) for testing purposes (manual partial mock)",
            "Framework",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "Risk of Test-Specific Subclass?",
        "o": [
            "Testing the subclass, not the real class. Fragile inheritance.",
            "None",
            "Speed",
            "Security"
        ]
    },
    {
        "q": "What is 'Constructor Parametrization' refactoring?",
        "o": [
            "Replacing 'new Dependency()' inside method with a field initialized in constructor (enables mocking)",
            "Adding loop",
            "Adding if",
            "Deleting code"
        ]
    },
    {
        "q": "What is 'Extract and Override Call' refactoring?",
        "o": [
            "Extracting 'new Dependency()' into a protected method, then overriding it in test subclass to return mock",
            "Extract Method",
            "Rename",
            "Move"
        ]
    },
    {
        "q": "What is 'Clean Architecture' and Mocks?",
        "o": [
            "Inner layers (Use Cases) define interfaces (Gateways) for outer layers to implement. Tests mock the Gateways.",
            "Dirty Code",
            "Spaghetti",
            "No pattern"
        ]
    },
    {
        "q": "What is 'Presentational logic' testing?",
        "o": [
            "Testing Presenters/ViewModels using mocks for View and Model",
            "UI testing",
            "E2E testing",
            "Manual"
        ]
    },
    {
        "q": "What is 'Testing Legacy Code' main challenge?",
        "o": [
            "Lack of seams / tight coupling preventing instantiation and mocking",
            "Old Java version",
            "Slow machine",
            "No IDE"
        ]
    },
    {
        "q": "Book 'Working Effectively with Legacy Code' author?",
        "o": [
            "Michael Feathers",
            "Kent Beck",
            "Uncle Bob",
            "Martin Fowler"
        ]
    },
    {
        "q": "Golden Rule of Legacy Code?",
        "o": [
            "Write tests before changing code (but you often need to refactor to write tests - Catch-22)",
            "Delete everything",
            "Rewrite",
            "Ignore tests"
        ]
    },
    {
        "q": "What is 'Sprout Method'?",
        "o": [
            "Write new code in a new method, test that method (TDD), call it from legacy code",
            "Plant method",
            "Tree method",
            "Root method"
        ]
    },
    {
        "q": "What is 'Sprout Class'?",
        "o": [
            "Write new code in a new class, test it, use it in legacy code",
            "New class",
            "Old class",
            "Inner class"
        ]
    },
    {
        "q": "What is 'Wrap Method'?",
        "o": [
            "Rename old method, create new method with old name that calls old method + new logic",
            "Decorate",
            "Proxy",
            "Facade"
        ]
    },
    {
        "q": "How to dependency break 'Singleton'?",
        "o": [
            "Add 'setInstance' method (relaxed singleton) or Introduce Instance Delegator",
            "Cannot",
            "Delete singleton",
            "Make public"
        ]
    },
    {
        "q": "What is 'Static Cling'?",
        "o": [
            "Hard dependencies on static methods making code untestable",
            "Static electricity",
            "Performance",
            "Variable"
        ]
    },
    {
        "q": "How to break Static Cling?",
        "o": [
            "Extract interface, make static method an instance method of a class implementing it, inject that class",
            "Use PowerMock",
            "Delete it",
            "Ignore"
        ]
    },
    {
        "q": "What is 'Global State' problem?",
        "o": [
            "Tests interfering with each other (order dependency, parallel failure)",
            "Speed",
            "Memory",
            "Disk"
        ]
    },
    {
        "q": "How to Mock a 'Singleton' enum?",
        "o": [
            "Very hard. Refactor to interface. Or use specialized hacks/tools.",
            "Easy",
            "Standard",
            "Just new it"
        ]
    },
    {
        "q": "What is 'Characterization Test'?",
        "o": [
            "Test describing current behavior of legacy code (even if buggy) to lock it down before refactoring",
            "Unit test",
            "Feature test",
            "Bug test"
        ]
    },
    {
        "q": "What is 'Sensing Variable'?",
        "o": [
            "A variable introduced in the code just to allow a test to sense what happened (e.g. log output)",
            "Sensor",
            "Mock",
            "Spy"
        ]
    },
    {
        "q": "What is 'Interceptor' in testing?",
        "o": [
            "Mechanism to intercept calls (AOP) for verification or stubbing",
            "Spy",
            "Mock",
            "Stub"
        ]
    },
    {
        "q": "Can you use AOP for mocking?",
        "o": [
            "Yes (Spring AOP, AspectJ), but frameworks like Mockito match expected behavior better",
            "No",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'Database Sandbox'?",
        "o": [
            "Pattern where each test allows DB changes but rolls them back after test (Transactional tests)",
            "Playground",
            "Mock DB",
            "No DB"
        ]
    },
    {
        "q": "What is '@TxDaoTest' etc?",
        "o": [
            "Annotations indicating test runs in transaction and rolls back",
            "Commit",
            "Save",
            "Persist"
        ]
    },
    {
        "q": "Should you mock HttpClient?",
        "o": [
            "Yes (Mock the client interface) OR use WireMock (better, mocks the server)",
            "No",
            "Always real",
            "Never"
        ]
    },
    {
        "q": "What is 'MockServer' tool?",
        "o": [
            "Tool similar to WireMock for mocking HTTP/HTTPS services",
            "Server",
            "Client",
            "Proxy"
        ]
    },
    {
        "q": "Difference between WireMock and Mockito?",
        "o": [
            "WireMock mocks HTTP/Network protocol (out-of-process usually). Mockito mocks Java Objects (in-process).",
            "Same",
            "None",
            "Colors"
        ]
    },
    {
        "q": "When to use WireMock?",
        "o": [
            "Integration testing of HTTP clients, checking wire format, headers, error codes",
            "Unit testing logic",
            "Testing DB",
            "Testing UI"
        ]
    },
    {
        "q": "What is 'Testcontainers'?",
        "o": [
            "Java library to spin up Docker containers (DBs, Queues) for Integration Tests (Fakes)",
            "Mocks",
            "Stubs",
            "Spies"
        ]
    },
    {
        "q": "Testcontainers vs In-Memory DB (H2)?",
        "o": [
            "Testcontainers uses REAL DB (Postgres/MySQL) via Docker = high fidelity. H2 acts differently.",
            "H2 is better",
            "Same",
            "H2 is faster"
        ]
    },
    {
        "q": "Is Testcontainers a Mock?",
        "o": [
            "No, it provides a real instance (ephemeral). It's an environment provisioning tool.",
            "Yes",
            "Stub",
            "Dummy"
        ]
    },
    {
        "q": "What is 'Mountebank'?",
        "o": [
            "Cross-platform over-the-wire test double (imposters) for HTTP, TCP, SMTP",
            "Bank",
            "Money",
            "Mount"
        ]
    },
    {
        "q": "What is 'Greenmail'?",
        "o": [
            "Test suite of email servers (SMTP, POP3, IMAP) for testing email sending/receiving (Fake)",
            "Spam",
            "Client",
            "Mock"
        ]
    },
    {
        "q": "What is 'MailHog'/'MailCatcher'?",
        "o": [
            "Tools to catch emails during dev/test",
            "Virus",
            "Game",
            "Animal"
        ]
    },
    {
        "q": "What is 'LocalStack'?",
        "o": [
            "A fully functional local AWS cloud stack (S3, Lambda, DynamoDB) for testing (Fake/Simulator)",
            "Stack",
            "Queue",
            "Heap"
        ]
    },
    {
        "q": "What is 'ArchUnit' for mocks?",
        "o": [
            "Can ensure rules like 'Don't use Mockito in domain layer' or 'Don't verify toString'",
            "Mocking tool",
            "Unit tool",
            "Design tool"
        ]
    },
    {
        "q": "Can you mock 'HttpServletRequest'?",
        "o": [
            "Yes, Mockito works. Or use Spring's MockHttpServletRequest (Fake/Stub implementation).",
            "No",
            "Only Real",
            "Only Jetty"
        ]
    },
    {
        "q": "Why prefer MockHttpServletRequest over Mockito mock?",
        "o": [
            "It behaves like a real request (stores attributes, parameters) without needing endless stubbing",
            "Faster",
            "Slower",
            "Cleaner"
        ]
    },
    {
        "q": "What is 'MockMvc'?",
        "o": [
            "Spring Test tool to test Controllers without starting Servlet Container (DispatcherServlet mock)",
            "Real Server",
            "Browser",
            "Selenium"
        ]
    },
    {
        "q": "Is MockMvc a Unit or Integration test?",
        "o": [
            "Technically Integration (tests Spring context + Controller), but runs fast (in-process)",
            "Unit",
            "E2E",
            "Manual"
        ]
    },
    {
        "q": "What is '@WebMvcTest'?",
        "o": [
            "Slice test annotation for MockMvc, auto-configures minimal context for Controller layer",
            "Integration",
            "E2E",
            "Unit"
        ]
    },
    {
        "q": "In @WebMvcTest, do you mock services?",
        "o": [
            "Yes, usually with @MockBean",
            "No, use real",
            "Use H2",
            "Use Docker"
        ]
    },
    {
        "q": "What is 'RestAssured'?",
        "o": [
            "Fluent library to test REST APIs (usually against running server or MockMvc)",
            "Mocking",
            "Server",
            "Client"
        ]
    },
    {
        "q": "RestAssured vs MockMvc?",
        "o": [
            "RestAssured is HTTP Client (E2E/Integration). MockMvc is In-Process (Integration/Component). RestAssuredMockMvc exists.",
            "Same",
            "None",
            "Different"
        ]
    },
    {
        "q": "What is 'Karate'?",
        "o": [
            "API test automation tool combining API mocks, testing, and performance (BDD style)",
            "Martial art",
            "Scanning",
            "Linting"
        ]
    },
    {
        "q": "Can Karate mock services?",
        "o": [
            "Yes, has built-in Netty based mocks",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Selenium'?",
        "o": [
            "Browser automation tool (E2E UI testing)",
            "Mock tool",
            "Unit tool",
            "API tool"
        ]
    },
    {
        "q": "Do you use Mocks in Selenium tests?",
        "o": [
            "Ideally not in the app (E2E = Real). But you might mock 3rd party APIs (Payment Gateway) at network level.",
            "Yes everywhere",
            "No never",
            "Depends"
        ]
    },
    {
        "q": "What is 'Page Object Pattern'?",
        "o": [
            "Design pattern in UI testing (Selenium) abstracting page details into objects",
            "Mock pattern",
            "Stub pattern",
            "Spy pattern"
        ]
    },
    {
        "q": "Is Page Object a Mock?",
        "o": [
            "No, it's an abstraction/proxy to the UI",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Cypress' intercept?",
        "o": [
            "Ability to spy on and stub network requests in browser tests (Mocking backend)",
            "Tree",
            "Wood",
            "Log"
        ]
    },
    {
        "q": "What is 'Playwright' route?",
        "o": [
            "Equivalent to Cypress intercept; mocking network at browser level",
            "Play",
            "Write",
            "Read"
        ]
    },
    {
        "q": "What is 'Snapshot Testing' (Jest)?",
        "o": [
            "Comparing current output (UI/JSON) against a stored 'golden master' snapshot",
            "Camera",
            "Photo",
            "Video"
        ]
    },
    {
        "q": "Is Snapshot Testing mocking?",
        "o": [
            "No, it's state verification (Golden Master pattern)",
            "Yes",
            "Stubbing",
            "Spying"
        ]
    },
    {
        "q": "What is 'Mutation Testing'?",
        "o": [
            "Modifying code (mutants) and running tests to see if tests fail (kill mutants). Measures test quality.",
            "Zombie",
            "Aliens",
            "X-Men"
        ]
    },
    {
        "q": "Does Mutation Testing help with Mocks?",
        "o": [
            "Yes, detects if mocks are too permissive (e.g. any(), no verify) and don't catch behavior changes",
            "No",
            "Ignores",
            "Breaks"
        ]
    },
    {
        "q": "What is 'PIT' (Pitest)?",
        "o": [
            "Mutation testing system for Java",
            "Hole",
            "Fruit",
            "Seed"
        ]
    },
    {
        "q": "What is 'Mock Roles, not Objects' philosophy?",
        "o": [
            "Mock interactions based on the Role the collaborator plays, not its class implementation",
            "Mock classes",
            "Mock data",
            "Mock nothing"
        ]
    },
    {
        "q": "What is a 'Role'?",
        "o": [
            "A set of related behaviors/messages defined by an interface",
            "Actor",
            "Job",
            "Person"
        ]
    },
    {
        "q": "What is 'Telescoping Mocks'?",
        "o": [
            "Getting a mock from a mock from a mock (A.getB().getC().do()). Bad pattern.",
            "Space",
            "Stars",
            "Lens"
        ]
    },
    {
        "q": "How to fix Telescoping Mocks?",
        "o": [
            "Mock the ultimate result or Law of Demeter (inject 'C' directly)",
            "Stub deeper",
            "Ignore",
            "Retry"
        ]
    },
    {
        "q": "What is 'Mocking getters/setters'?",
        "o": [
            "Usually antipattern. Use real value objects (POJO) with real getters/setters.",
            "Good",
            "Required",
            "Standard"
        ]
    },
    {
        "q": "When to mock getters?",
        "o": [
            "Only if they are complex calculations or part of an interface you must mock. Avoid for simple fields.",
            "Always",
            "Never",
            "Random"
        ]
    },
    {
        "q": "What is 'verifyZeroInteractions' (Deprecated)?",
        "o": [
            "Replaced by verifyNoInteractions()",
            "Same",
            "Deleted",
            "Gone"
        ]
    },
    {
        "q": "What is 'ArgumentCaptor' for varargs?",
        "o": [
            "Tricky. Captor captures List. Check documentation for specific Mockito versions.",
            "Easy",
            "Impossible",
            "Regular"
        ]
    },
    {
        "q": "Can you capture arguments with 'Answer'?",
        "o": [
            "Yes, invocation.getArgument(i)",
            "No",
            "Only verify",
            "Only stub"
        ]
    },
    {
        "q": "Which is more powerful: Captor or Answer?",
        "o": [
            "Answer (can affect return value based on args). Captor (can only inspect after).",
            "Captor",
            "Same",
            "Neither"
        ]
    },
    {
        "q": "Can you mock a Thread?",
        "o": [
            "Ideally don't. Abstract it to Executor service or Runnable and test logic separately.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "How to unit test multithreaded code?",
        "o": [
            "Refactor logic out of run(). Mock the threading wrapper/executor.",
            "Sleeps",
            "Prints",
            "Prayers"
        ]
    },
    {
        "q": "What is 'ConcurrentTest'?",
        "o": [
            "Testing thread safety. Mocks usually aren't thread safe.",
            "Unit test",
            "Integration",
            "Mock test"
        ]
    },
    {
        "q": "Does Mockito support Android?",
        "o": [
            "Yes, Mockito-Android extension (uses Dexmaker)",
            "No",
            "Native",
            "Web only"
        ]
    },
    {
        "q": "What is 'Robolectric'?",
        "o": [
            "Test framework for Android that runs tests on JVM (mocks Android SDK)",
            "Robot",
            "Electric",
            "Mock"
        ]
    },
    {
        "q": "Is Robolectric a mocking framework?",
        "o": [
            "Yes, essentially a massive set of Mocks/Fakes (Shadows) for Android SDK",
            "No",
            "Unit framework",
            "Runner"
        ]
    },
    {
        "q": "What is 'Shadow' in Robolectric?",
        "o": [
            "Class that monitors/modifies behavior of Android classes during test",
            "Mock",
            "Spy",
            "Stub"
        ]
    },
    {
        "q": "What is 'Mocking generics' issue?",
        "o": [
            "Type erasure. Mockito mostly handles it via deep reflection, but sometimes requires casting.",
            "Compile error",
            "Runtime error",
            "None"
        ]
    },
    {
        "q": "What is '@Mock(answer=Answers.RETURNS_DEEP_STUBS)'?",
        "o": [
            "Easy way to set default answer via annotation",
            "Error",
            "Invalid",
            "Constructor"
        ]
    },
    {
        "q": "What is 'Mockito.mock(Class, Answer)'?",
        "o": [
            "Factory method with custom default answer",
            "Factory",
            "Constructor",
            "Builder"
        ]
    },
    {
        "q": "Can multiple threads call a mock safely?",
        "o": [
            "No, unless synchronized or pure reading. Mockito doesn't guarantee thread safety of recording.",
            "Yes",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What if you need thread safe mock?",
        "o": [
            "Synchronize access in test or SUT, or use simple Stubs (manual)",
            "Use Mockito",
            "Use PowerMock",
            "Impossible"
        ]
    },
    {
        "q": "How to verify a static method call count directly?",
        "o": [
            "mockedStatic.verify(() -> Util.method(), times(1))",
            "verify(Util.class)",
            "verifyStatic(Util.class)",
            "verify(Util::method)"
        ]
    },
    {
        "q": "What is 'Quarkus Mocking' mechanism?",
        "o": [
            "@InjectMock (based on Mockito) but handled at compile time/build time for native image compatibility",
            "Dynamic proxy",
            "AspectJ",
            "Manual"
        ]
    },
    {
        "q": "What is 'Micronaut Mocking'?",
        "o": [
            "@MockBean replaces bean in context. Uses compilation-time AOP (Annotation Processor) rather than runtime reflection.",
            "Runtime reflection",
            "Dynamic proxy",
            "PowerMock"
        ]
    },
    {
        "q": "What is 'Property-based Testing' combined with Mocks?",
        "o": [
            "Using generators (jqwik) to feed random data into mocks or SUT to find edge cases",
            "Impossible",
            "Standard",
            "Slow"
        ]
    },
    {
        "q": "What is 'Spying on Spring Beans'?",
        "o": [
            "@SpyBean wraps the existing bean in a Mockito Spy. Careful with AOP proxies (transactional beans).",
            "Easy",
            "Safe",
            "Fast"
        ]
    },
    {
        "q": "Risk of @SpyBean on AOP Proxy?",
        "o": [
            "You might spy on the proxy, or the target, confusing 'when' vs 'doReturn'. Mockito might verify proxy calls, not internal calls.",
            "None",
            "Crash",
            "Loop"
        ]
    },
    {
        "q": "What is 'Mocking final classes' trade-off?",
        "o": [
            "Requires 'mockito-inline'. Slightly slower startup. Relies on instrumentation API (can clash with other agents).",
            "More memory",
            "More disk",
            "None"
        ]
    },
    {
        "q": "What is 'ArgumentMatcher' type safety?",
        "o": [
            "Matchers are typed (ArgumentMatcher<T>), but internal implementation often erases type. 'any(Class)' helps check type.",
            "Always safe",
            "Broken",
            "Strict"
        ]
    },
    {
        "q": "Can you mock 'Optional'?",
        "o": [
            "Bad practice. Return Optional.of/empty instead of mocking the Optional class.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Can you mock 'Stream'?",
        "o": [
            "Bad practice. Return Stream.of(...) or list.stream(). Mocking fluent stream chains is painful.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Can you mock 'Collections'?",
        "o": [
            "Bad practice. Use real ArrayList/HashSet. Takes less code and behaves correctly.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Mocking static initialization block'?",
        "o": [
            "PowerMock feature. Mockito cannot prevent static init blocks from running (class loading).",
            "Mockito feature",
            "Java feature",
            "Standard"
        ]
    },
    {
        "q": "What is 'Suppressing static initialization'?",
        "o": [
            "Preventing 'static { ... }' code from executing. Dangerous, leaves class in uninitialized state.",
            "Good practice",
            "Optimization",
            "Cleaning"
        ]
    },
    {
        "q": "Can Mockito suppress static init?",
        "o": [
            "No. PowerMock can.",
            "Yes",
            "Maybe",
            "Future"
        ]
    },
    {
        "q": "What is 'Stubbing void with return'?",
        "o": [
            "Compile error. 'when(mock.voidMethod()).thenReturn()' is invalid Java.",
            "Valid",
            "Runtime error",
            "Ignored"
        ]
    },
    {
        "q": "What is 'Mocking equals' risk?",
        "o": [
            "If you put mock in a Set/Map, its behavior depends on your mock of hashCode/equals. Can break collection logic.",
            "None",
            "Slow",
            "Memory leak"
        ]
    },
    {
        "q": "What is 'Mockito.only() ' verification mode?",
        "o": [
            "verify(mock, only()).method(). Checks that this was the ONLY interaction with this mock.",
            "At least once",
            "One time",
            "First time"
        ]
    },
    {
        "q": "Difference verify(mock, times(1)) vs verify(mock, only())?",
        "o": [
            "times(1) checks count of that method (ignoring other calls). only() checks that NO OTHER method was called.",
            "Same",
            "Inverse",
            "None"
        ]
    },
    {
        "q": "What is 'ArgThat' vs 'ArgumentCaptor'?",
        "o": [
            "ArgThat matches during verification (boolean). Captor saves it for later assertions (more detail).",
            "Same",
            "ArgThat is deprecated",
            "Captor is deprecated"
        ]
    },
    {
        "q": "Can you serialize an ArgumentCaptor?",
        "o": [
            "No, it holds state.",
            "Yes",
            "Maybe",
            "If transient"
        ]
    },
    {
        "q": "What is 'Mocking a functional interface'?",
        "o": [
            "Possible, e.g. mock(Runnable.class). Often cleaner than manual lambda if you need verification.",
            "Impossible",
            "Bad",
            "Slow"
        ]
    },
    {
        "q": "What is 'Mocking a generic class'?",
        "o": [
            "mock(new TypeReference<List<String>>(){}) - No, Mockito API is mock(Class). You usually just CAST the mock.",
            "Easy",
            "Implicit",
            "Auto"
        ]
    },
    {
        "q": "How to creating a mock with deep generics?",
        "o": [
            "@Mock List<String> list; (Annotation handles generics signature better via reflection)",
            "mock(List<String>.class)",
            "Cannot",
            "Ignore"
        ]
    },
    {
        "q": "What is 'Mocking bridge methods'?",
        "o": [
            "Mockito handles bridge methods (synthetic methods for generics) automatically usually.",
            "Manual",
            "Impossible",
            "Error"
        ]
    },
    {
        "q": "What is 'Mocking package-private methods'?",
        "o": [
            "Works if test is in same package. If not, Mockito can still mock them if they are accessible/visible to the proxy.",
            "Cannot",
            "Prohibited",
            "Only public"
        ]
    },
    {
        "q": "What is 'Mocking native methods'?",
        "o": [
            "Mockito cannot mock native methods directly (they have no bytecode to instrument). PowerMock required.",
            "Yes",
            "Easy",
            "Standard"
        ]
    },
    {
        "q": "What is 'Mocking System.getenv()'?",
        "o": [
            "Static native. Hard. Better use a 'Environment' wrapper/abstraction and mock that.",
            "Easy",
            "mockStatic",
            "PowerMock"
        ]
    },
    {
        "q": "What is 'System Rules' library?",
        "o": [
            "JUnit rules (deprecated in 5) to test code calling System.exit, System.out, etc. Useful for legacy.",
            "Mock lib",
            "Spy lib",
            "Trace lib"
        ]
    },
    {
        "q": "What is 'System Stubs' (JUnit 5)?",
        "o": [
            "Modern library to stub System properties/environment variables for JUnit 5 (EnvironmentVariables ext)",
            "Old lib",
            "Java lib",
            "Core lib"
        ]
    },
    {
        "q": "What is 'Mocking a Builder Pattern'?",
        "o": [
            "Painful. Returns deep Stubs helps (RETURNS_SELF). better: don't mock builders, use real ones.",
            "Easy",
            "Fast",
            "Required"
        ]
    },
    {
        "q": "What is 'RETURNS_SELF'?",
        "o": [
            "Answer that returns the mock itself (useful for builder chains)",
            "Returns null",
            "Returns new",
            "Returns spy"
        ]
    },
    {
        "q": "How to use RETURNS_SELF?",
        "o": [
            "mock(Builder.class, Answers.RETURNS_SELF)",
            "mock.returnSelf()",
            "when(..).thenReturn(this)",
            "auto()"
        ]
    },
    {
        "q": "What is 'Mocking an iterator'?",
        "o": [
            "when(it.hasNext()).thenReturn(true, false); when(it.next()).thenReturn(val);",
            "Easy",
            "Hard",
            "Bad"
        ]
    },
    {
        "q": "What is 'Mocking a callback'?",
        "o": [
            "Use doAnswer() to invoke the callback passed as argument.",
            "when(callback.run())",
            "Impossible",
            "Ignore"
        ]
    },
    {
        "q": "Example of invoking callback?",
        "o": [
            "doAnswer(invocation -> { ((Runnable)invocation.getArgument(0)).run(); return null; }).when(mock).execute(any());",
            "callback.run()",
            "invoke()",
            "call()"
        ]
    },
    {
        "q": "What is 'Synchronous Mocking' of Async code?",
        "o": [
            "Forcing async operations to run synchronously (e.g. direct executor) to simplify testing",
            "Async mocking",
            "Parallel mocking",
            "Slow mocking"
        ]
    },
    {
        "q": "What is 'Mockito.after(ms)' usage?",
        "o": [
            "verify(mock, after(100)).method(); - waits 100ms then verifies. Useful to prove something didn't happen (never()).",
            "Waits until call",
            "Time travel",
            "Delay"
        ]
    },
    {
        "q": "Is 'after()' efficient?",
        "o": [
            "No, it sleeps for the full duration. Use timeout() if looking for a positive signal (returns early).",
            "Yes",
            "Very fast",
            "Instant"
        ]
    },
    {
        "q": "What is 'Mock Injection' vs 'Spring Injection'?",
        "o": [
            "Mock Injection (@InjectMocks) is simple, reflection based, no context. Spring Injection is complex, dependency graph, proxies.",
            "Same",
            "Opposite",
            "None"
        ]
    },
    {
        "q": "What is '@TestSubject' (EasyMock/JMockit)?",
        "o": [
            "Equivalent to @InjectMocks",
            "Equivalent to @Mock",
            "Equivalent to @Spy",
            "Equivalent to @Test"
        ]
    },
    {
        "q": "What is 'JMockit'?",
        "o": [
            "Advanced mocking framework using Java Agent (instrumentation) to mock everything (static, private, final, new)",
            "Mockito plugin",
            "Simple lib",
            "Old lib"
        ]
    },
    {
        "q": "Why is JMockit less popular now?",
        "o": [
            "Complex syntax (Expectations block), magic behavior. Mockito + Inline covers most needs simpler.",
            "Slow",
            "Expensive",
            "Closed source"
        ]
    },
    {
        "q": "What is 'Opaque Object' in testing?",
        "o": [
            "Object whose state you cannot inspect/verify easily (no getters). Hard to verify state.",
            "Transparent",
            "Clear",
            "Glass"
        ]
    },
    {
        "q": "How to verify Opaque Object passed to mock?",
        "o": [
            "Use ArgumentCaptor + Reflection, or add debug getters, or ArgumentMatcher",
            "Cannot",
            "Guess",
            "Ignore"
        ]
    },
    {
        "q": "What is 'Non-strict recording'?",
        "o": [
            "Where order and count don't matter, just that it happened eventually",
            "Strict",
            "Rigid",
            "Fixed"
        ]
    },
    {
        "q": "Is Mockito strict by default?",
        "o": [
            "Historically Loose (Nice). Recent versions (JUnit 5 extension) default to Strict Stubs (fail on unused stubs).",
            "Strict always",
            "Loose always",
            "No default"
        ]
    },
    {
        "q": "What is 'Redundant Stubbing'?",
        "o": [
            "Stubbing a method that is never called. Strict Stubs treats this as a failure (cleaner tests).",
            "Over stubbing",
            "Double stubbing",
            "Safe stubbing"
        ]
    },
    {
        "q": "What is 'Stubbing Variance'?",
        "o": [
            "Different return values for same arguments in same test? Or random returns?",
            "Noise",
            "Error",
            "Bug"
        ]
    },
    {
        "q": "Can you stub 'hashCode'?",
        "o": [
            "Yes, but risky if mock is in HashMap. Mockito allows it.",
            "No",
            "Never",
            "Always"
        ]
    },
    {
        "q": "What is 'Mocking a recursive structure'?",
        "o": [
            "Node n = mock(Node.class); when(n.getNext()).thenReturn(n); // Cyclic",
            "Impossible",
            "StackOverflow",
            "Hard"
        ]
    },
    {
        "q": "What is 'Cross-contamination' of mocks?",
        "o": [
            "Using same mock instance across tests without resetting. Static mocks are prime suspects.",
            "Dirty mocks",
            "Viral mocks",
            "Sick mocks"
        ]
    },
    {
        "q": "How to prevent cross-contamination?",
        "o": [
            "Create fresh mocks in @BeforeEach or use @Mock on fields (created per test class instance)",
            "Reset manually",
            "Don't test",
            "Use one test"
        ]
    },
    {
        "q": "What is 'Mock Injection order'?",
        "o": [
            "Constructor -> Setter -> Field. Mockito stops at first successful strategy.",
            "Field -> Setter",
            "Random",
            "All at once"
        ]
    },
    {
        "q": "What if you have multiple mocks of same type for injection?",
        "o": [
            "Mockito @InjectMocks might pick one randomly or by name matching (parameter name/field name). Can be flaky. Use manual setters.",
            "It fails",
            "It works perfectly",
            "It crashes"
        ]
    },
    {
        "q": "What is 'Mock name' useful for?",
        "o": [
            "Debugging messages. 'Wanted but not invoked: userMock.save()'. Default is 'userMock'.",
            "Nothing",
            "Performance",
            "Serialization"
        ]
    },
    {
        "q": "How to name a mock?",
        "o": [
            "@Mock(name='myMock') or mock(Class.class, 'myName')",
            "mock.setName()",
            "name(mock)",
            "rename(mock)"
        ]
    },
    {
        "q": "What is 'Mocking JDK internal classes'?",
        "o": [
            "Java 9+ modules encapsulate internals. Need --add-opens to mock them via reflection.",
            "Impossible",
            "Easy",
            "Allowed"
        ]
    },
    {
        "q": "Does Mockito support Java 21 Virtual Threads?",
        "o": [
            "Yes, generally behaves like normal threads. Mocking is thread-agnostic logic.",
            "No",
            "Maybe",
            "Future"
        ]
    },
    {
        "q": "What is 'SpotBugs' with Mocks?",
        "o": [
            "Static analysis tool. Might report false positives on mocks (e.g. null dereference on unconfigured stubs).",
            "Debugger",
            "Linter",
            "Compiler"
        ]
    },
    {
        "q": "What is 'Checkstyle' with Mocks?",
        "o": [
            "Coding style. Can enforce naming conventions (e.g. *Mock).",
            "Formatter",
            "Builder",
            "Runner"
        ]
    },
    {
        "q": "What is 'Mocking File I/O'?",
        "o": [
            "Prefer Jimfs (In-memory file system) over mocking File/Path classes manually.",
            "Mock File",
            "Mock Path",
            "Spy File"
        ]
    },
    {
        "q": "What is 'Jimfs'?",
        "o": [
            "Google's in-memory implementation of Java NIO FileSystem. Great for testing file logic.",
            "Mock FS",
            "Stub FS",
            "Fake FS"
        ]
    },
    {
        "q": "What is 'Mocking JDBC'?",
        "o": [
            "Painful steps (mock Connection, Statement, ResultSet). Use H2 or Testcontainers instead.",
            "Good idea",
            "Standard",
            "Fast"
        ]
    },
    {
        "q": "What is 'Mocking JPA'?",
        "o": [
            "Mocking EntityManager is complex. Use DataJpaTest with H2.",
            "Easy",
            "Standard",
            "Recommended"
        ]
    },
    {
        "q": "What is 'Mocking Slf4j'?",
        "o": [
            "Don't mock Logger. Use output capture.",
            "Mock Logger",
            "Mock Appender",
            "Mock LoggerFactory"
        ]
    },
    {
        "q": "When is 'doCallRealMethod()' dangerous?",
        "o": [
            "If the real method alters state that the mock doesn't possess or relies on dependencies that are null.",
            "Never",
            "Always",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Mockito.reset()' anti-pattern?",
        "o": [
            "Code smell. Usually means test method is doing too much (testing multiple scenarios).",
            "Good practice",
            "Optimization",
            "Required"
        ]
    },
    {
        "q": "What is 'SmartNulls' return type?",
        "o": [
            "Returns a proxy that throws a clearer exception when a method is called on it, saying 'You forgot to stub X'",
            "Null",
            "Zero",
            "Void"
        ]
    },
    {
        "q": "Can Mockito mock interfaces with default methods?",
        "o": [
            "Yes. Unless stubbed, calling them on a mock behaves like abstract methods (returns default).",
            "No",
            "Calls real code",
            "Throws"
        ]
    },
    {
        "q": "How to call real default method on mock?",
        "o": [
            "doCallRealMethod().when(mock).defaultMethod()",
            "Automatic",
            "Cannot",
            "mock.callReal()"
        ]
    },
    {
        "q": "What is 'Mocking final methods' mechanism?",
        "o": [
            "Inline mock maker removes 'final' modifier at runtime class generation step.",
            "Impossible",
            "Proxy",
            "Wrapper"
        ]
    },
    {
        "q": "What is 'Self-validating Mock'?",
        "o": [
            "Mock that checks its own arguments during call (using Answer) and throws if invalid",
            "Smart mock",
            "Active mock",
            "Checked mock"
        ]
    },
    {
        "q": "What is 'Mock Object' history?",
        "o": [
            "Originated at Connextra (2000), Tim Mackinnon et al. 'Endo-Testing'.",
            "Google",
            "Facebook",
            "Sun"
        ]
    },
    {
        "q": "What is 'Endo-Testing'?",
        "o": [
            "Testing the inside/interactions of the object (Behavior) rather than just IO.",
            "Inner testing",
            "Outer testing",
            "Exo testing"
        ]
    },
    {
        "q": "Is Mockito open source?",
        "o": [
            "Yes, MIT License. Maintained by Szczepan Faber and community.",
            "No",
            "Apache",
            "GPL"
        ]
    }
]