[
    {
        "q": "What is 'Code Coverage'?",
        "o": [
            "A metric used to measure how much of the source code is executed when tests run",
            "A metric of code quality",
            "A metric of code speed",
            "A metric of code size"
        ]
    },
    {
        "q": "What is 'Statement Coverage'?",
        "o": [
            "Percentage of executable statements that have been executed at least once",
            "Lines of code",
            "Methods called",
            "Classes loaded"
        ]
    },
    {
        "q": "What is 'Line Coverage'?",
        "o": [
            "Percentage of lines of code that have been executed (often synonymous with statement coverage, but subtle differences exist)",
            "File size",
            "Line count",
            "Character count"
        ]
    },
    {
        "q": "What is 'Branch Coverage'?",
        "o": [
            "Percentage of branches (decisions like if/else) that have been executed in both directions (true and false)",
            "Tree coverage",
            "Leaf coverage",
            "Node coverage"
        ]
    },
    {
        "q": "Which is generally harder to achieve: Branch or Line Coverage?",
        "o": [
            "Branch Coverage (requires evaluating all conditions)",
            "Line Coverage",
            "Statement Coverage",
            "Method Coverage"
        ]
    },
    {
        "q": "What is 'Condition Coverage'?",
        "o": [
            "Evaluating each boolean sub-expression in a compound condition (e.g. A && B) independently",
            "Branch coverage",
            "Loop coverage",
            "State coverage"
        ]
    },
    {
        "q": "What is 'Path Coverage'?",
        "o": [
            "Executes every possible execution path through the code (often impossible due to loops)",
            "Line coverage",
            "Route coverage",
            "Map coverage"
        ]
    },
    {
        "q": "What is 'Function/Method Coverage'?",
        "o": [
            "Percentage of functions/methods that have been called at least once",
            "Class coverage",
            "Package coverage",
            "Module coverage"
        ]
    },
    {
        "q": "What is 'Class Coverage'?",
        "o": [
            "Percentage of classes that have been accessed/loaded during testing",
            "Method coverage",
            "Line coverage",
            "File coverage"
        ]
    },
    {
        "q": "Does 100% Code Coverage guarantee no bugs?",
        "o": [
            "No, it only means all code was executed, not that logic is correct or all states handled",
            "Yes",
            "Usually",
            "Always"
        ]
    },
    {
        "q": "What is 'JaCoCo'?",
        "o": [
            "Java Code Coverage library (popular with Maven/Gradle)",
            "Java Compiler",
            "Java Container",
            "Java Console"
        ]
    },
    {
        "q": "What is 'Cobertura'?",
        "o": [
            "Older Java code coverage tool (less active now)",
            "Coverage",
            "Blanket",
            "Tool"
        ]
    },
    {
        "q": "What is 'Istanbul' (nyc)?",
        "o": [
            "Popular code coverage tool for JavaScript (Node.js/Browser)",
            "City",
            "Server",
            "Proxy"
        ]
    },
    {
        "q": "What is 'lcov'?",
        "o": [
            "Graphical front-end for GCC's coverage testing tool gcov (generates HTML reports)",
            "Linux command",
            "List cover",
            "Line cover"
        ]
    },
    {
        "q": "What is 'Instruction Coverage' (JaCoCo)?",
        "o": [
            "Percentage of Java bytecode instructions executed (primary metric for JaCoCo)",
            "Line coverage",
            "Branch coverage",
            "Class coverage"
        ]
    },
    {
        "q": "What is 'Missed Instructions'?",
        "o": [
            "Bytecode instructions that were not executed by any test",
            "Errors",
            "Warnings",
            "Bugs"
        ]
    },
    {
        "q": "What is 'Cyclomatic Complexity'?",
        "o": [
            "A quantitative measure of the number of linearly independent paths through a program's source code",
            "Code size",
            "Code speed",
            "Code age"
        ]
    },
    {
        "q": "How does JaCoCo calculate Complexity?",
        "o": [
            "Based on number of branches (B) and decision points (D): v(G) = B - D + 1 ... roughly count of if/for/while/case",
            "Lines",
            "Files",
            "Classes"
        ]
    },
    {
        "q": "Why measure Cyclomatic Complexity?",
        "o": [
            "High complexity implies code is hard to test and maintain (needs more tests to cover paths)",
            "To brag",
            "To optimize",
            "To compress"
        ]
    },
    {
        "q": "What is 'Coverage Gap'?",
        "o": [
            "The difference between target coverage (e.g. 80%) and actual coverage",
            "Space",
            "Time",
            "Null"
        ]
    },
    {
        "q": "What indicates 'Red' lines in coverage report?",
        "o": [
            "Lines not executed at all",
            "Error lines",
            "Executed lines",
            "Ignored lines"
        ]
    },
    {
        "q": "What indicates 'Green' lines in coverage report?",
        "o": [
            "Lines fully executed",
            "New lines",
            "Comments",
            "Empty lines"
        ]
    },
    {
        "q": "What indicates 'Yellow' lines in coverage report?",
        "o": [
            "Lines partially executed (e.g. branch taken only one way)",
            "Warnings",
            "Slow lines",
            "Deprecated"
        ]
    },
    {
        "q": "How is usage of instrumentation in Coverage?",
        "o": [
            "Tools insert tracking code (counters/probes) into bytecode/source to record execution",
            "Cameras",
            "Logs",
            "Spies"
        ]
    },
    {
        "q": "On-the-fly instrumentation?",
        "o": [
            "Modifying classes as they are loaded by the ClassLoader (Java Agent)",
            "Static",
            "Offline",
            "Manual"
        ]
    },
    {
        "q": "Offline instrumentation?",
        "o": [
            "Modifying class files on disk before execution (useful for Android or environments without agents)",
            "Online",
            "Live",
            "Dynamic"
        ]
    },
    {
        "q": "What is 'SonarQube' role in coverage?",
        "o": [
            "It aggregates coverage reports (from JaCoCo, LCOV, etc.) and tracks trends/quality gates",
            "Generates coverage",
            "Compiles code",
            "Runs tests"
        ]
    },
    {
        "q": "What is 'Coverage Gate' / 'Quality Gate'?",
        "o": [
            "A threshold (e.g. 80% coverage) that must be met for the build/PR to pass",
            "Door",
            "Fence",
            "Wall"
        ]
    },
    {
        "q": "Why avoid 100% coverage target?",
        "o": [
            "Diminishing returns. Encourages trivial tests, testing auto-generated code, and maintenance burden.",
            "Impossible",
            "Too fast",
            "Too easy"
        ]
    },
    {
        "q": "Reasonable target for coverage?",
        "o": [
            "Often 70-80% is cited as a healthy balance",
            "100%",
            "10%",
            "50%"
        ]
    },
    {
        "q": "What code should be excluded from coverage?",
        "o": [
            "DTOs, auto-generated code, simple getters/setters, configuration classes",
            "Logic",
            "Services",
            "Controllers"
        ]
    },
    {
        "q": "How to exclude package/classes in JaCoCo?",
        "o": [
            "Configuration usage <excludes> pattern (e.g. **/model/**, **/*Dto)",
            "Cannot",
            "Delete files",
            "Rename files"
        ]
    },
    {
        "q": "What is '@Generated' annotation effect?",
        "o": [
            "Most coverage tools automatically ignore methods/classes marked with @Generated",
            "None",
            "Highlighted",
            "Executed"
        ]
    },
    {
        "q": "Does coverage measure assertion quality?",
        "o": [
            "No, you can execute code without asserting anything (Assertion-Free Testing)",
            "Yes",
            "Always",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Change Coverage' (Codecov)?",
        "o": [
            "Coverage percentage only on the lines changed in the Pull Request",
            "Total coverage",
            "File coverage",
            "Line coverage"
        ]
    },
    {
        "q": "Why is Change Coverage checking important?",
        "o": [
            "Ensures new code is tested without forcing legacy code to be covered immediately (Ratchet effect)",
            "Speed",
            "Size",
            "Fun"
        ]
    },
    {
        "q": "What is 'Test Gap Analysis'?",
        "o": [
            "Identifying code that has changed but was not executed by any test",
            "Gap in wall",
            "Space",
            "Null"
        ]
    },
    {
        "q": "Coverage is a good metric for...",
        "o": [
            "Finding missing tests (what is NOT tested)",
            "Proving correctness",
            "Measuring speed",
            "Measuring security"
        ]
    },
    {
        "q": "Coverage is a bad metric for...",
        "o": [
            "Determining test quality (quality of assertions)",
            "Finding dead code",
            "Finding unused imports",
            "Complexity"
        ]
    },
    {
        "q": "What is 'Mutation Score' vs Coverage?",
        "o": [
            "Mutation score checks if tests fail when code breaks (quality). Coverage checks if code runs.",
            "Same",
            "Inverse",
            "None"
        ]
    },
    {
        "q": "Can you have 100% coverage and 0% mutation score?",
        "o": [
            "Yes, if tests have no assertions",
            "No",
            "Impossible",
            "Maybe"
        ]
    },
    {
        "q": "What is 'Branch' in 'switch' statement?",
        "o": [
            "Each case (including default) is a branch",
            "The switch keyword",
            "The variable",
            "The break"
        ]
    },
    {
        "q": "If 'if (a || b)' is executed, how many conditions?",
        "o": [
            "2 (a and b)",
            "1",
            "3",
            "4"
        ]
    },
    {
        "q": "To cover 'if (a || b)', what inputs needed for full Condition Coverage?",
        "o": [
            "(F,F), (T,?), (?,T) - typically TT, TF, FT, FF depending on strictness",
            "T, F",
            "A, B",
            "1, 2"
        ]
    },
    {
        "q": "Short-circuit evaluation impact on coverage?",
        "o": [
            "If 'a' is true in (a || b), 'b' is not evaluated/executed. Might show as partial coverage.",
            "None",
            "Full coverage",
            "Error"
        ]
    },
    {
        "q": "What is 'exec file' (JaCoCo)?",
        "o": [
            "Binary file containing execution data dumped by JaCoCo agent (jacoco.exec)",
            "Report",
            "Config",
            "Log"
        ]
    },
    {
        "q": "Can you merge exec files?",
        "o": [
            "Yes, JaCoCo Merge task allows combining multiple test runs (unit + integration)",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Clover'?",
        "o": [
            "Another Java coverage tool (from Atlassian)",
            "Luck",
            "Plant",
            "Tool"
        ]
    },
    {
        "q": "What is 'OpenClover'?",
        "o": [
            "Open source fork of Clover",
            "Closed Clover",
            "Red Clover",
            "Blue Clover"
        ]
    },
    {
        "q": "Instrumenting tests vs production code?",
        "o": [
            "Only production code instrumented usually. Coverage of test code itself is irrelevant.",
            "Both",
            "Only tests",
            "Neither"
        ]
    },
    {
        "q": "Impact of coverage tool on performance?",
        "o": [
            "Slows down execution (instrumentation overhead, tracking). Usually acceptable for CI.",
            "Speeds up",
            "No impact",
            "Crashes"
        ]
    },
    {
        "q": "When does JaCoCo dump data?",
        "o": [
            "On JVM exit (shutdown hook) or on demand (JMX/TCP)",
            "Every line",
            "Start",
            "Never"
        ]
    },
    {
        "q": "What is 'Diamond Problem' in testing paths?",
        "o": [
            "Not specific to coverage. Path coverage explosion due to independent branches.",
            "Inheritance",
            "Gem",
            "Shape"
        ]
    },
    {
        "q": "How many paths in a loop?",
        "o": [
            "Potentially infinite (0, 1, many iterations). Path coverage usually limits loops (0, 1, n).",
            "1",
            "2",
            "3"
        ]
    },
    {
        "q": "What is 'Basis Path Testing'?",
        "o": [
            "Testing a set of linearly independent paths (Cyclomatic Complexity determines this number)",
            "All paths",
            "Random paths",
            "No paths"
        ]
    },
    {
        "q": "Can generated toString() reduce coverage?",
        "o": [
            "Yes, if not tested/called. Often excluded.",
            "No",
            "Increases",
            "None"
        ]
    },
    {
        "q": "Can private constructors (utility classes) reduce coverage?",
        "o": [
            "Yes, they are never called. Exclude class or invoke via reflection (hacky).",
            "No",
            "Increases",
            "None"
        ]
    },
    {
        "q": "What is 'Lombok' impact on coverage?",
        "o": [
            "Generates code (getters/setters). Coverage tools might mark them missed. Use lombok.addLombokGeneratedAnnotation = true.",
            "None",
            "Good",
            "Bad"
        ]
    },
    {
        "q": "Configuring lombok.config for JaCoCo?",
        "o": [
            "lombok.addLombokGeneratedAnnotation = true (JaCoCo ignores @Generated)",
            "lombok.coverage = true",
            "lombok.test = true",
            "lombok.ignore = true"
        ]
    },
    {
        "q": "What is 'Baseline' coverage?",
        "o": [
            "The coverage level of the master branch. PRs should not decrease it.",
            "Zero",
            "100%",
            "Target"
        ]
    },
    {
        "q": "What is 'Report Aggregation'?",
        "o": [
            "Combining reports from sub-modules into a single project-wide HTML report",
            "Summing numbers",
            "Deleting reports",
            "Copying files"
        ]
    },
    {
        "q": "JaCoCo Maven Plugin goal 'prepare-agent'?",
        "o": [
            "Sets up the javaagent VM argument for the surefire plugin",
            "Runs tests",
            "Creates report",
            "Checks gate"
        ]
    },
    {
        "q": "JaCoCo Maven Plugin goal 'report'?",
        "o": [
            "Generates report (HTML/XML/CSV) from exec data",
            "Runs agent",
            "Compiles",
            "Installs"
        ]
    },
    {
        "q": "JaCoCo Maven Plugin goal 'check'?",
        "o": [
            "Fails build if rules (limits) are not met",
            "Runs tests",
            "Reports",
            "Agents"
        ]
    },
    {
        "q": "Common coverage format for CI upload?",
        "o": [
            "XML (generic format parsed by tools like Codecov, SonarCloud)",
            "HTML",
            "Binary",
            "Text"
        ]
    },
    {
        "q": "What is 'Codecov'?",
        "o": [
            "SaaS tool to visualize coverage, integrate with GitHub PRs",
            "Library",
            "Compiler",
            "IDE"
        ]
    },
    {
        "q": "What is 'Coveralls'?",
        "o": [
            "SaaS tool for coverage history and badges",
            "Suit",
            "Cloud",
            "Tool"
        ]
    },
    {
        "q": "Coverage of Exceptions?",
        "o": [
            "Catch blocks are branches. Need tests that throw exception to cover catch block.",
            "Impossible",
            "Automatic",
            "Ignored"
        ]
    },
    {
        "q": "What is 'Data Flow Coverage'?",
        "o": [
            "Tracks definitions and uses of variables (def-use pairs)",
            "Control flow",
            "Line flow",
            "Branch flow"
        ]
    },
    {
        "q": "Is Data Flow Coverage common?",
        "o": [
            "Less common than Control Flow (Statement/Branch) in standard tools",
            "Yes",
            "Standard",
            "Required"
        ]
    },
    {
        "q": "What is 'Strict Coverage'?",
        "o": [
            "Failing if coverage drops even 0.1%",
            "Loose",
            "Flexible",
            "Open"
        ]
    },
    {
        "q": "Does comments affect coverage?",
        "o": [
            "No, comments are not executable",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Does formatting affect coverage?",
        "o": [
            "Line coverage yes (if multiple statements on one line). Statement/Instruction coverage no.",
            "Yes always",
            "No never",
            "Maybe"
        ]
    },
    {
        "q": "Why put one statement per line?",
        "o": [
            "Better Line Coverage resolution (identifying exactly which statement was missed)",
            "Readability",
            "Style",
            "All of above"
        ]
    },
    {
        "q": "What is 'Partial Line Coverage'?",
        "o": [
            "When a line has multiple instructions/branches and only some were executed",
            "Yellow line",
            "Red line",
            "Green line"
        ]
    },
    {
        "q": "Can you test private methods to increase coverage?",
        "o": [
            "Controversial. Generally test public API. Private code covered via public calls.",
            "Yes always",
            "No never",
            "Required"
        ]
    },
    {
        "q": "If private method is not covered by any public call?",
        "o": [
            "It is likely Code (delete it)",
            "Add test",
            "Make public",
            "Ignore"
        ]
    },
    {
        "q": "What is 'MC/DC'?",
        "o": [
            "Modified Condition/Decision Coverage. Highly rigorous, used in safety-critical (avionics, automotive).",
            "Rock band",
            "Power",
            "Coverage"
        ]
    },
    {
        "q": "Does JaCoCo support MC/DC?",
        "o": [
            "No, primarily Instruction and Branch. Some commercial tools do.",
            "Yes",
            "Maybe",
            "Plugins"
        ]
    },
    {
        "q": "Does coverage guarantee happy path?",
        "o": [
            "No, it guarantees execution. You need assertions for correctness.",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Does coverage guarantee error handling?",
        "o": [
            "Only if error branches (catch, if error) are executed (covered)",
            "Yes",
            "Automatic",
            "Assume"
        ]
    },
    {
        "q": "Can reflection bypass coverage?",
        "o": [
            "No, executed instructions are counted regardless of how they were invoked",
            "Yes",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Does mocking reduce coverage?",
        "o": [
            "Mocks replace real implementations, so code INSIDE the mocked class is NOT covered (executed).",
            "Increases",
            "No effect",
            "Changes"
        ]
    },
    {
        "q": "Does Integration Tests increase coverage?",
        "o": [
            "Yes, they typically cover large swaths of code, including DB/Network layers",
            "No",
            "Decreases",
            "Same"
        ]
    },
    {
        "q": "Should Unit and Integration coverage be merged?",
        "o": [
            "Yes, to get the overall picture of Tested Code",
            "No, keep separate",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "What is 'Source encoding' issue in reports?",
        "o": [
            "If source encoding doesn't match report generation encoding, special characters break in HTML view",
            "Binary",
            "Zip",
            "Path"
        ]
    },
    {
        "q": "What is 'Execution Data Store'?",
        "o": [
            "Runtime structure holding probes state in JaCoCo",
            "Database",
            "File",
            "Disk"
        ]
    },
    {
        "q": "Can coverage run on remote server?",
        "o": [
            "Yes, via JaCoCo agent with TCPSERVER output mode, then dump via check command",
            "No",
            "Local only",
            "Impossible"
        ]
    },
    {
        "q": "Coverage overhead is typically...",
        "o": [
            "Small (<10%) for standard tools",
            "Huge (2x)",
            "Massive (10x)",
            "None"
        ]
    },
    {
        "q": "What is 'Diff Coverage'?",
        "o": [
            "Coverage on the diff (changed lines) only",
            "Full coverage",
            "Zero coverage",
            "Max coverage"
        ]
    },
    {
        "q": "Tool to generate JaCoCo report in Terminal?",
        "o": [
            "Not standard. Some CLI wrappers exist.",
            "Default",
            "Easy",
            "Built-in"
        ]
    },
    {
        "q": "Is Code Coverage black-box or white-box?",
        "o": [
            "White-box measurement (analyzes internals)",
            "Black-box",
            "Gray-box",
            "Red-box"
        ]
    },
    {
        "q": "What is 'Entry Point Coverage'?",
        "o": [
            "Ensuring all public methods are called",
            "Line",
            "Branch",
            "Condition"
        ]
    },
    {
        "q": "Does coverage prove code is bug free?",
        "o": [
            "No. Dijkstra: 'Testing shows the presence, not the absence of bugs'.",
            "Yes",
            "Maybe",
            "Often"
        ]
    },
    {
        "q": "What is the standard Maven plugin for JaCoCo?",
        "o": [
            "org.jacoco:jacoco-maven-plugin",
            "org.maven:jacoco-plugin",
            "com.jacoco:maven-plugin",
            "org.code:coverage-plugin"
        ]
    },
    {
        "q": "What is the 'prepare-agent' goal in JaCoCo?",
        "o": [
            "Initializes the java agent before tests run; essential for collecting execution data",
            "Compiles tests",
            "Builds report",
            "Fails build"
        ]
    },
    {
        "q": "When does 'prepare-agent' typically run?",
        "o": [
            "initialize phase (before test phase)",
            "verify phase",
            "deploy phase",
            "install phase"
        ]
    },
    {
        "q": "What is the 'report' goal in JaCoCo?",
        "o": [
            "Generates the code coverage report (HTML, XML, CSV) from execution data",
            "Runs the agent",
            "Cleans",
            "Deletes"
        ]
    },
    {
        "q": "When does 'report' typically run?",
        "o": [
            "verify phase (after test phase)",
            "compile phase",
            "clean phase",
            "validate phase"
        ]
    },
    {
        "q": "Where is the default HTML report located (Maven)?",
        "o": [
            "target/site/jacoco/index.html",
            "target/jacoco.html",
            "build/report.html",
            "src/report.html"
        ]
    },
    {
        "q": "Where is the default execution data file (Maven)?",
        "o": [
            "target/jacoco.exec",
            "target/data.exec",
            "build/jacoco.exec",
            "coverage.exec"
        ]
    },
    {
        "q": "Does JaCoCo support Gradle?",
        "o": [
            "Yes, via the 'jacoco' plugin",
            "No",
            "Only Maven",
            "Only Ant"
        ]
    },
    {
        "q": "Gradle task to generate report?",
        "o": [
            "jacocoTestReport",
            "testReport",
            "jacocoReport",
            "coverageReport"
        ]
    },
    {
        "q": "Gradle task to verify coverage limits?",
        "o": [
            "jacocoTestCoverageVerification",
            "jacocoVerify",
            "checkCoverage",
            "verifyLimits"
        ]
    },
    {
        "q": "How to include multiple execution files in report?",
        "o": [
            "Use 'merge' task to combine jacoco.exec files before reporting",
            "Cannot",
            "Automatic",
            "Manual"
        ]
    },
    {
        "q": "What is specific to JaCoCo 'Complexity' metric?",
        "o": [
            "It calculates Cyclomatic Complexity at bytecode level. Total complexity = sum of complexity of all methods.",
            "Not supported",
            "Only for Line",
            "Only for Branch"
        ]
    },
    {
        "q": "Minimum complexity of a method?",
        "o": [
            "1 (linear path)",
            "0",
            "2",
            "-1"
        ]
    },
    {
        "q": "Does 'switch' statement increase complexity?",
        "o": [
            "Yes, complexity increases by number of cases",
            "No",
            "Depends",
            "Decreases"
        ]
    },
    {
        "q": "Does 'throw' statement increase complexity (JaCoCo)?",
        "o": [
            "No. Exceptions are exit points, but effectively just return. Handling them (catch) increases complexity.",
            "Yes",
            "Double",
            "Triple"
        ]
    },
    {
        "q": "What is 'Missed Complexity'?",
        "o": [
            "Complexity that was not covered (tested). Good indicator of untested logic paths.",
            "Error",
            "Warning",
            "Good"
        ]
    },
    {
        "q": "Can you exclude constructors from coverage?",
        "o": [
            "Private empty constructors? JaCoCo 0.8.0+ has filters. Or ignore via pattern.",
            "No",
            "Always",
            "Never"
        ]
    },
    {
        "q": "How to enforce 80% line coverage in Maven?",
        "o": [
            "Define <rule> in <configuration> of 'check' goal with element=BUNDLE and limit counter=LINE value=COVEREDRATIO minimum=0.80",
            "Cannot",
            "Use property",
            "Use flag"
        ]
    },
    {
        "q": "What is 'Element' in JaCoCo rule?",
        "o": [
            "Scope of the check: BUNDLE (project), PACKAGE, CLASS, SOURCEFILE, METHOD",
            "Type",
            "Metric",
            "Limits"
        ]
    },
    {
        "q": "What are 'Counters' in JaCoCo?",
        "o": [
            "INSTRUCTION, LINE, BRANCH, COMPLEXITY, METHOD, CLASS",
            "A B C",
            "1 2 3",
            "Time"
        ]
    },
    {
        "q": "What represents 0.80 coverage?",
        "o": [
            "80% covered",
            "0.8% covered",
            "8% covered",
            "80 lines"
        ]
    },
    {
        "q": "If I set limit 1.00 (100%), will build fail on 99%?",
        "o": [
            "Yes",
            "No",
            "Warns",
            "Ignores"
        ]
    },
    {
        "q": "Can you verify rules per class?",
        "o": [
            "Yes, set element=CLASS",
            "No, only global",
            "Only package",
            "Only method"
        ]
    },
    {
        "q": "What is 'JaCoCo offline instrumentation' use case?",
        "o": [
            "Android testing, or environments where Java Agent cannot be attached (e.g. some OSGi containers or PowerMock conflicts)",
            "Standard",
            "CI",
            "Local"
        ]
    },
    {
        "q": "Offline instrumentation requires...?",
        "o": [
            "jacoco-agent.jar on classpath (Runtime dependency) and explicit instrument/restore-instrumented-classes steps",
            "Nothing",
            "Internet",
            "License"
        ]
    },
    {
        "q": "Does PowerMock break JaCoCo?",
        "o": [
            "Often yes, because PowerMock uses custom ClassLoaders. Needs Offline Instrumentation to work reliably.",
            "No",
            "Never",
            "Depends"
        ]
    },
    {
        "q": "What is 'sonar.coverage.exclusions'?",
        "o": [
            "Property to exclude files from SonarQube coverage calculation (doesn't affect local report unless configured there)",
            "Local exclusion",
            "Global exclusion",
            "Check"
        ]
    },
    {
        "q": "What is 'sonar.jacoco.reportPath' (deprecated)?",
        "o": [
            "Old property to point to exec file. Modern Sonar uses 'sonar.coverage.jacoco.xmlReportPaths'.",
            "Valid",
            "Required",
            "New"
        ]
    },
    {
        "q": "Why prefer XML report for Sonar/Codecov?",
        "o": [
            "It is structured, machine readable, and language agnostic structure mostly.",
            "Smaller",
            "Faster",
            "Prettier"
        ]
    },
    {
        "q": "Can you Aggregate multi-module project coverage in Maven?",
        "o": [
            "Yes, create a separate 'coverage-report' module using 'report-aggregate' goal",
            "No, manually",
            "Use Gradle",
            "Use terminal"
        ]
    },
    {
        "q": "What does 'report-aggregate' do?",
        "o": [
            "Collects dependencies that are part of the reactor, grabs their exec data and sources, and creates a unified report",
            "Zips files",
            "Sends email",
            "Deletes files"
        ]
    },
    {
        "q": "Why combine unit and integration tests?",
        "o": [
            "To see total path execution. Code covered by IT might not need Unit test coverage (debatable, but valid for coverage stats).",
            "To save space",
            "To go fast",
            "To clear disk"
        ]
    },
    {
        "q": "How to separate Unit and IT coverage?",
        "o": [
            "Use different execution files (jacoco-ut.exec, jacoco-it.exec) and separate reports",
            "Cannot",
            "By name",
            "By date"
        ]
    },
    {
        "q": "What is 'Failsafe' plugin relation?",
        "o": [
            "Runs integration tests. JaCoCo agent must be passed to failsafe configuration (argLine).",
            "Runs unit tests",
            "Compiles",
            "Packages"
        ]
    },
    {
        "q": "What is 'Surefire' plugin relation?",
        "o": [
            "Runs unit tests. JaCoCo agent acts as a VM argument to surefire (argLine).",
            "Runs IT",
            "Deploys",
            "Installs"
        ]
    },
    {
        "q": "Common error: 'Skipping JaCoCo execution due to missing execution data'?",
        "o": [
            "Tests didn't run, or agent wasn't attached, or exec file wasn't found at expected path",
            "Coverage is 0",
            "Coverage is 100",
            "Success"
        ]
    },
    {
        "q": "Does coverage work with Kotlin?",
        "o": [
            "Yes, JaCoCo supports Kotlin (filters generated code better in recent versions)",
            "No",
            "Only Java",
            "Only Scala"
        ]
    },
    {
        "q": "Coverage of Kotlin 'inline' functions?",
        "o": [
            "Tricky. Bytecode is inlined into caller. Original function might show as not covered if not called directly.",
            "Easy",
            "Perfect",
            "Full"
        ]
    },
    {
        "q": "Coverage of Kotlin 'data class'?",
        "o": [
            "Generates equals/hash/toString/copy. Often lowers coverage if not used. Filter or test them.",
            "High coverage",
            "Low impact",
            "Ignored"
        ]
    },
    {
        "q": "What is 'IntelliJ IDEA' coverage runner?",
        "o": [
            "Built-in runner (can optionally use JaCoCo engine). Provides live highlighting in editor.",
            "External",
            "Plugin",
            "Slow"
        ]
    },
    {
        "q": "Does IDEA use same engine as Maven?",
        "o": [
            "Can differ. You can select 'JaCoCo' in run configuration to align with CI.",
            "Yes always",
            "No never",
            "Maybe"
        ]
    },
    {
        "q": "What is 'HTML Report' structure?",
        "o": [
            "Index -> Packages -> Classes -> Methods -> Source View with colors",
            "Flat list",
            "Text only",
            "Graph"
        ]
    },
    {
        "q": "Can you see source code in JaCoCo report?",
        "o": [
            "Yes, if source encoding and path are correct. Shows green/red/yellow highlighting.",
            "No",
            "Bytecode only",
            "Assembly"
        ]
    },
    {
        "q": "What if source code is missing in report?",
        "o": [
            "Report will show class/method stats but no clickable source view (link to source failed)",
            "Error",
            "Empty",
            "Missing"
        ]
    },
    {
        "q": "Does code coverage prevent regression?",
        "o": [
            "It helps (ensures paths are exercised), but assertions prevent regression. Coverage of 100% without assertions catches nothing.",
            "Yes",
            "Always",
            "No"
        ]
    },
    {
        "q": "What is 'Pseudo-tested' code?",
        "o": [
            "Code that is executed by tests (covered) but can be deleted/mutated without tests failing (weak assertions)",
            "Fake code",
            "Mock code",
            "Bad code"
        ]
    },
    {
        "q": "How to find pseudo-tested code?",
        "o": [
            "Mutation Testing (Pitest)",
            "Coverage tools",
            "Linting",
            "Code review"
        ]
    },
    {
        "q": "JaCoCo agent parameter 'includes'?",
        "o": [
            "List of class names to instrument (default *)",
            "Files",
            "Tests",
            "Plugins"
        ]
    },
    {
        "q": "JaCoCo agent parameter 'excludes'?",
        "o": [
            "List of class names to exclude from instrumentation",
            "Tests",
            "Files",
            "Jars"
        ]
    },
    {
        "q": "JaCoCo agent parameter 'append'?",
        "o": [
            "true/false. If true, appends to existing exec file. If false, overwrites on start.",
            "Delete",
            "Merge",
            "Copy"
        ]
    },
    {
        "q": "When is 'append=false' useful?",
        "o": [
            "When running completely fresh test suite and want clean data",
            "Continuous testing",
            "Merging",
            "Never"
        ]
    },
    {
        "q": "JaCoCo agent parameter 'dumpOnExit'?",
        "o": [
            "true/false. If true, dumps data when JVM stops. Default true.",
            "Dump on error",
            "Dump on start",
            "Dump on test"
        ]
    },
    {
        "q": "What is 'SessionId' in JaCoCo?",
        "o": [
            "Identifier for the data dump session (often host/timestamp)",
            "User ID",
            "Test ID",
            "Process ID"
        ]
    },
    {
        "q": "What is 'Effective Pom'?",
        "o": [
            "mvn help:effective-pom (shows calculated config including injected plugin executions)",
            "Pom.xml",
            "Parent pom",
            "Root pom"
        ]
    },
    {
        "q": "How to debug why JaCoCo didn't cover a class?",
        "o": [
            "Check excludes, check if class was loaded, check if test actually calls it, check agent attachment",
            "Guess",
            "Reinstall",
            "Reboot"
        ]
    },
    {
        "q": "What is 'Java Agent'?",
        "o": [
            "JVM mechanism to instrument programs (-javaagent:jarpath). JaCoCo uses this.",
            "Spy",
            "Proxy",
            "Service"
        ]
    },
    {
        "q": "Can you have multiple Java Agents?",
        "o": [
            "Yes, order matters",
            "No",
            "Only two",
            "Only three"
        ]
    },
    {
        "q": "Conflict between JaCoCo and other agents?",
        "o": [
            "Possible if both modify bytecode heavily. Order can fix it.",
            "Never",
            "Always",
            "Maybe"
        ]
    },
    {
        "q": "What is 'argLine' property in Surefire?",
        "o": [
            "Property where VM arguments are set. JaCoCo appends its agent string here. Be careful not to overwrite it.",
            "Cmd line",
            "Input",
            "Output"
        ]
    },
    {
        "q": "How to correctly append argLine?",
        "o": [
            "<argLine>@{argLine} -Xmx1G ...</argLine> (User late binding syntax)",
            "Overwrite it",
            "Ignore it",
            "Delete it"
        ]
    },
    {
        "q": "What happens if you define <argLine> without referencing existing one?",
        "o": [
            "You might overwrite JaCoCo's agent setup and get 0% coverage (agent not attached)",
            "Nothing",
            "Errors",
            "Warnings"
        ]
    },
    {
        "q": "JaCoCo 'destFile' property?",
        "o": [
            "Path to execution data file output",
            "Input",
            "Report",
            "Source"
        ]
    },
    {
        "q": "JaCoCo 'dataFile' property (report)?",
        "o": [
            "Path to execution data file input (for reporting)",
            "Output",
            "Dest",
            "Source"
        ]
    },
    {
        "q": "Do you need debug info for Source Line highlighting?",
        "o": [
            "Yes, compiled classes must have debug info (lines, vars, source) for JaCoCo to map bytecode to source lines.",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "Compiler flag for debug info?",
        "o": [
            "-g (default in Maven/Gradle)",
            "-d",
            "-v",
            "-O"
        ]
    },
    {
        "q": "What is 'Probe' in JaCoCo?",
        "o": [
            "Boolean array inserted into bytecode to track execution of blocks",
            "Sensor",
            "Needle",
            "Spy"
        ]
    },
    {
        "q": "Why 64kb method limit risk with coverage?",
        "o": [
            "Instrumentation adds code. If method is near 64kb limit, adding probes might exceed JVM size limit -> verifying error.",
            "Performance",
            "Memory",
            "Speed"
        ]
    },
    {
        "q": "Does coverage reporting need source files?",
        "o": [
            "Yes, for the HTML source view. No, for the metrics summary (XML/CSV can be generated without sources, just classes).",
            "Always",
            "Never",
            "Maybe"
        ]
    },
    {
        "q": "Can you generate coverage for Interface?",
        "o": [
            "Only for default/static methods. Abstract methods have no code.",
            "Yes always",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "Can you generate coverage for Enum?",
        "o": [
            "Yes, methods and static init.",
            "No",
            "Maybe",
            "Sometimes"
        ]
    },
    {
        "q": "What is the 'values()' method coverage issue in Enums?",
        "o": [
            "Compiler generates values() and valueOf(). If you don't call them, coverage < 100%.",
            "None",
            "Good",
            "Bad"
        ]
    },
    {
        "q": "How to fix Enum coverage?",
        "o": [
            "Call MyEnum.values() in a test, or ignore generated code.",
            "Delete enum",
            "Use class",
            "Ignore it"
        ]
    },
    {
        "q": "Impact of anonymous classes on coverage?",
        "o": [
            "They are separate class files ($1.class). Tracked individually.",
            "Merged",
            "Ignored",
            "None"
        ]
    },
    {
        "q": "Impact of Lambdas on coverage?",
        "o": [
            "JaCoCo tracks lambdas. They run as synthetic methods/classes. Covered if executed.",
            "None",
            "Ignored",
            "Hard"
        ]
    },
    {
        "q": "Can you exclude specific methods?",
        "o": [
            "Not easily by name in XML. Filter by annotation works best.",
            "Yes",
            "No",
            "Maybe"
        ]
    },
    {
        "q": "JaCoCo version recommendation?",
        "o": [
            "Always use latest stable matching your JDK version (JDK changes often break bytecode instrumentation tools)",
            "Use old",
            "Any",
            "Beta"
        ]
    },
    {
        "q": "Is JaCoCo accurate?",
        "o": [
            "Very accurate for execution tracking. Branch coverage can be tricky with complex boolean logic.",
            "No",
            "Yes perfect",
            "Okay"
        ]
    },
    {
        "q": "What is 'Code Coverage' vs 'Test Coverage'?",
        "o": [
            "Code coverage = automated metric. Test coverage = broader term (functional coverage, requirements coverage).",
            "Same",
            "Opposite",
            "None"
        ]
    },
    {
        "q": "Can manual tests contribute to code coverage?",
        "o": [
            "Yes, if app is started with JaCoCo agent and manual tests are performed, then dumped on exit.",
            "No",
            "Never",
            "Automatic"
        ]
    },
    {
        "q": "This technique (manual coverage) is used for...",
        "o": [
            "QA testing, E2E flows, finding untested legacy paths",
            "Unit testing",
            "CI",
            "Linting"
        ]
    },
    {
        "q": "Does running tests in parallel affect coverage?",
        "o": [
            "JaCoCo handles concurrent threads fine. Forked processes need separate agents/execution files, then merged.",
            "Breaks it",
            "Slows it",
            "Stops it"
        ]
    },
    {
        "q": "JaCoCo vs Cobertura?",
        "o": [
            "JaCoCo is active, bytecode based, faster. Cobertura is older, source based (mostly), inactive.",
            "Same",
            "Cobertura newer",
            "JaCoCo slower"
        ]
    },
    {
        "q": "Is it possible to have > 100% coverage?",
        "o": [
            "No",
            "Yes",
            "Maybe",
            "Bug"
        ]
    },
    {
        "q": "Can you merge coverage from different languages?",
        "o": [
            "Generally no, unless tool supports polyglot (SonarQube aggregates them). JaCoCo is JVM only.",
            "Yes",
            "Always",
            "Easy"
        ]
    },
    {
        "q": "What is 'Universal Coverage'?",
        "o": [
            "Marketing term. Usually implies coverage across entire stack (Frontend + Backend).",
            "Standard",
            "Metric",
            "Goal"
        ]
    },
    {
        "q": "How to get Frontend coverage?",
        "o": [
            "Jest, Istanbul, Cypress (code coverage plugin)",
            "JaCoCo",
            "JUnit",
            "Maven"
        ]
    },
    {
        "q": "Can SonarQube show both Java and JS coverage?",
        "o": [
            "Yes, if both reports (jacoco.xml, lcov.info) are provided to the scanner.",
            "No",
            "Only Java",
            "Only JS"
        ]
    },
    {
        "q": "What characterizes 'Flaky Coverage'?",
        "o": [
            "Coverage that varies between runs (non-deterministic tests, race conditions).",
            "Stable",
            "Good",
            "High"
        ]
    },
    {
        "q": "Does 'Thread.sleep()' count as covered?",
        "o": [
            "The line is covered if executed. Whether it slept effectively is not checked.",
            "No",
            "Maybe",
            "Wait"
        ]
    },
    {
        "q": "Does coverage check for concurrency bugs?",
        "o": [
            "No. It tracks execution, not thread safety.",
            "Yes",
            "Always",
            "Maybe"
        ]
    }
,
    {
        "q": "What is the primary difference between statement coverage and branch coverage?",
        "o": [
            "Statement coverage checks executed lines; branch coverage checks both true/false outcomes of conditionals.",
            "Statement coverage is for loops; branch coverage is for if-statements.",
            "They are the same thing.",
            "Branch coverage is always 100% if statement coverage is 100%."
        ]
    },
    {
        "q": "If a method contains 'if (x > 0) return true; return false;', can you have 100% statement coverage but less than 100% branch coverage?",
        "o": [
            "No, executing both returns implies evaluating the condition both ways.",
            "Yes, if you only test x > 0.",
            "Yes, if you only test x <= 0.",
            "It depends on the compiler."
        ]
    },
    {
        "q": "What is 'path coverage' in unit testing?",
        "o": [
            "Ensuring every possible execution path through the code is taken.",
            "Ensuring every method is called at least once.",
            "Ensuring every file is imported.",
            "Ensuring the file path is correct."
        ]
    },
    {
        "q": "Which is generally harder to achieve: 100% path coverage or 100% branch coverage?",
        "o": [
            "Path coverage, due to the exponential detailed combinations of branches.",
            "Branch coverage, because it requires boolean logic.",
            "They are equally hard.",
            "Statement coverage is hardest."
        ]
    },
    {
        "q": "In a coverage report, what does a yellow/partially covered line usually indicate?",
        "o": [
            "A conditional branch where only one outcome (true or false) was executed.",
            "The line was executed very slowly.",
            "The line contains a syntax warning.",
            "The test failed on that line."
        ]
    },
    {
        "q": "Why might 100% code coverage still not guarantee a bug-free application?",
        "o": [
            "It doesn't verify the correctness of the logic, only its execution.",
            "It does guarantee it, actually.",
            "Because coverage tools are buggy.",
            "Because it ignores comments."
        ]
    },
    {
        "q": "What is 'condition coverage' (or expression coverage)?",
        "o": [
            "Verifying that each boolean sub-expression evaluates to both true and false.",
            "Verifying the if-statement runs.",
            "Verifying the method throws an exception.",
            "Verifying the loop terminates."
        ]
    },
    {
        "q": "If you have 'if (A && B)', how many test cases are minimally needed for 100% condition coverage?",
        "o": [
            "Enough to make A true/false and B true/false independently.",
            "Just one: A=true, B=true.",
            "Two: A=true/B=true and A=false/B=false.",
            "None."
        ]
    },
    {
        "q": "What is the 'cyclomatic complexity' metric often found in coverage reports?",
        "o": [
            "A measure of the number of linearly independent paths through a program's source code.",
            "The number of cycles in the CPU.",
            "The number of lines of code.",
            "The amount of memory used."
        ]
    },
    {
        "q": "High cyclomatic complexity usually correlates with:",
        "o": [
            "Lower testability and higher maintenance risk.",
            "Better performance.",
            "Simpler code.",
            "Higher code coverage automatically."
        ]
    },
    {
        "q": "Does generating a coverage report typically slow down the test execution?",
        "o": [
            "Yes, because of the instrumentation overhead.",
            "No, it creates it after execution.",
            "No, it runs in parallel.",
            "Only on Windows."
        ]
    },
    {
        "q": "Which tool is commonly used for code coverage in Python?",
        "o": [
            "coverage.py",
            "JaCoCo",
            "Istanbul",
            "Cobertura"
        ]
    },
    {
        "q": "Which tool is commonly used for code coverage in JavaScript/TypeScript?",
        "o": [
            "Istanbul (nyc) or Jest's built-in coverage.",
            "JaCoCo",
            "Emma",
            "PyCov"
        ]
    },
    {
        "q": "What does 'missed instructions' mean in JaCoCo?",
        "o": [
            "Bytecode instructions that were not executed during the test run.",
            "Comments that were ignored.",
            "Import statements.",
            "CPU instructions missed by the processor."
        ]
    },
    {
        "q": "Why is 'branch coverage' often preferred over 'line coverage' for critical systems?",
        "o": [
            "It ensures decision logic is tested, preventing hidden bugs in unchecked conditions.",
            "It is easier to achieve.",
            "It looks better on reports.",
            "Line coverage is deprecated."
        ]
    },
    {
        "q": "Can you have 100% branch coverage but less than 100% path coverage?",
        "o": [
            "Yes, independent branches might not be tested in all combinations.",
            "No, branch coverage implies path coverage.",
            "Only in C++.",
            "Never."
        ]
    },
    {
        "q": "What is a 'coverage gap'?",
        "o": [
            "Code that is not executed by any test.",
            "A pause in the test execution.",
            "Code that is commented out.",
            "Visual space in the IDE."
        ]
    },
    {
        "q": "How can excluding DTOs (Data Transfer Objects) from coverage reports improve metrics?",
        "o": [
            "It focuses the report on business logic rather than simple getters/setters.",
            "It cheats the system to get 100%.",
            "It makes the tests run faster.",
            "It breaks the build."
        ]
    },
    {
        "q": "What is 'MC/DC' (Modified Condition/Decision Coverage)?",
        "o": [
            "A rigorous coverage criterion requiring each condition to independently affect the decision outcome.",
            "A rock band.",
            "Maximum Code / Design Coverage.",
            "Multi-Core Data Check."
        ]
    },
    {
        "q": "In which domain is MC/DC coverage typically mandated?",
        "o": [
            "Safety-critical systems like avionics (DO-178C) or automotive.",
            "Web development.",
            "Game development.",
            "Mobile apps."
        ]
    },
    {
        "q": "If you mocking a dependency, does the code inside the mocked dependency count towards coverage?",
        "o": [
            "No, because the real code of the dependency is not executed.",
            "Yes, mocks are counted.",
            "Only if using spy.",
            "Yes, always."
        ]
    },
    {
        "q": "What is the danger of asserting coverage thresholds globally (e.g., must be > 80%)?",
        "o": [
            "Developers might write low-quality assertion-free tests just to hit the number.",
            "It makes the build too fast.",
            "It prevents refactoring.",
            "It consumes too much disk space."
        ]
    },
    {
        "q": "What does 'instrumentation' mean in the context of code coverage?",
        "o": [
            "Injecting tracking code into the binary or source to record execution.",
            "Playing music during tests.",
            "Setting up the IDE.",
            "Writing the tests manually."
        ]
    },
    {
        "q": "Can on-the-fly instrumentation be done without recompiling source code?",
        "o": [
            "Yes, often by using a Java Agent or similar runtime manipulation.",
            "No, source must always be changed.",
            "Only in interpreted languages.",
            "Never."
        ]
    },
    {
        "q": "What is 'offline instrumentation'?",
        "o": [
            "Modifying the build artifacts (class files) before running tests.",
            "Testing without internet.",
            "Manual testing.",
            "Testing on a different machine."
        ]
    },
    {
        "q": "If a ternary operator 'a ? b : c' is used, simple line coverage counts it as covered if:",
        "o": [
            "The line is hit, even if only 'b' or 'c' is executed.",
            "Both 'b' and 'c' are executed.",
            "Neither is executed.",
            "The variable 'a' is null."
        ]
    },
    {
        "q": "How does coverage tool handle exception handling blocks?",
        "o": [
            "Catch blocks are marked uncovered if no test triggers that exception.",
            "They are ignored.",
            "They are always assumed covered.",
            "They crash the tool."
        ]
    },
    {
        "q": "What is 'LCOV'?",
        "o": [
            "A graphical front-end for GCC's coverage testing tool gcov.",
            "A Java library.",
            "A Python script.",
            "A type of tea."
        ]
    },
    {
        "q": "What file format is commonly used to exchange coverage data between tools (e.g., CI pipelines)?",
        "o": [
            "XML (like Cobertura XML or JaCoCo XML) or LCOV info files.",
            "MP3.",
            "JPEG.",
            "EXE."
        ]
    },
    {
        "q": "Does code coverage tell you if you are missing a test case for a requirement?",
        "o": [
            "No, it only tells you what code you wrote is executed, not what is missing.",
            "Yes, strictly.",
            "Yes, if 100%.",
            "Maybe."
        ]
    },
    {
        "q": "If a function is never called by any test, its coverage is:",
        "o": [
            "0%.",
            "50%.",
            "100%.",
            "Undefined."
        ]
    },
    {
        "q": "What is 'mutation testing' in relation to code coverage?",
        "o": [
            "A technique to assess the quality of tests by modifying code and checking if tests fail.",
            "Changing the coverage tool.",
            "Randomly changing test order.",
            "Using mutants as developers."
        ]
    },
    {
        "q": "Does passing tests with 100% coverage imply the software is correct?",
        "o": [
            "No, logic errors can still exist, and requirements might be misunderstood.",
            "Yes, absolutely.",
            "Yes, for typed languages.",
            "No, unless using TDD."
        ]
    },
    {
        "q": "What is a 'partial line coverage'?",
        "o": [
            "When a line contains multiple statements or branches and only some are executed.",
            "When the line is half-written.",
            "When the git diff is partial.",
            "When the comment is too long."
        ]
    },
    {
        "q": "Tool like SonarQube uses coverage reports to:",
        "o": [
            "Compute technical debt and quality gate status.",
            "Compile the code.",
            "Deploy the code.",
            "Format the code."
        ]
    },
    {
        "q": "In a switch-case statement, to get 100% branch coverage, you must:",
        "o": [
            "Exercise every 'case' and the 'default' case.",
            "Exercise just the first case.",
            "Exercise just the default.",
            "Exercise any two cases."
        ]
    },
    {
        "q": "If code has unreachable blocks (dead code), can you achieve 100% coverage?",
        "o": [
            "No, the dead code will never be executed.",
            "Yes, if you mock it.",
            "Yes, coverage ignores dead code.",
            "Yes, using force execution."
        ]
    },
    {
        "q": "What is the impact of excluding auto-generated code from coverage?",
        "o": [
            "Metrics become more meaningful as they reflect maintainable logic.",
            "Coverage drops to 0.",
            "It breaks the build.",
            "It makes the report larger."
        ]
    },
    {
        "q": "Which is a coverage metric?",
        "o": [
            "Function coverage.",
            "Loop coverage.",
            "Execution coverage.",
            "All of the above."
        ]
    },
    {
        "q": "What does 'Function coverage' measure?",
        "o": [
            "Whether each function/method has been called at least once.",
            "How many lines in a function.",
            "How fast the function runs.",
            "Function name length."
        ]
    },
    {
        "q": "Why is 'code coverage' considered a 'white-box' testing metric?",
        "o": [
            "It requires knowledge of and access to the internal source code structure.",
            "It is transparent.",
            "It is for UI testing.",
            "It is printed on white paper."
        ]
    },
    {
        "q": "Can integration tests contribute to code coverage?",
        "o": [
            "Yes, integration tests execute code paths and can be measured by coverage tools.",
            "No, only unit tests count.",
            "No, they are different processes.",
            "Only for databases."
        ]
    },
    {
        "q": "What is a 'hit count' in coverage data?",
        "o": [
            "The number of times a specific line or branch was executed.",
            "The number of tests run.",
            "The number of failures.",
            "The number of developers."
        ]
    },
    {
        "q": "If a line has a hit count of 0, it means:",
        "o": [
            "It was never executed during the tests.",
            "It failed.",
            "It passed.",
            "It was executed 0 times successfully."
        ]
    },
    {
        "q": "Which Java coverage tool works by offline instrumentation of class files?",
        "o": [
            "Cobertura (historically) or JaCoCo (offline mode).",
            "JUnit.",
            "Mockito.",
            "Maven."
        ]
    },
    {
        "q": "How does 'Codecov' or 'Coveralls' work?",
        "o": [
            "They are SaaS services that visualize coverage reports generated by CI.",
            "They generate the tests.",
            "They compile the code.",
            "They automatically fix bugs."
        ]
    },
    {
        "q": "What does a significant drop in code coverage in a PR suggest?",
        "o": [
            "New code was added without corresponding tests.",
            "Tests were deleted.",
            "Code was refactored.",
            "All of the above."
        ]
    },
    {
        "q": "Is it possible to have high coverage but low test quality?",
        "o": [
            "Yes, if assertions are weak or missing.",
            "No, coverage implies quality.",
            "No, coverage prevents bugs.",
            "Tests always have assertions."
        ]
    },
    {
        "q": "What is 'statement coverage' formula?",
        "o": [
            "(Number of executed statements / Total number of statements) * 100.",
            "(Executed tests / Total tests) * 100.",
            "(Passed tests / Total tests) * 100.",
            "(Lines of code / Comments) * 100."
        ]
    },
    {
        "q": "Does 100% path coverage imply 100% statement coverage?",
        "o": [
            "Yes.",
            "No.",
            "Maybe.",
            "Depends on the language."
        ]
    },
    {
        "q": "Why is 100% path coverage practically impossible for large systems?",
        "o": [
            "Loops and recursion create an infinite or astronomically large number of paths.",
            "Computers are too slow.",
            "Code is too small.",
            "Paths are not defined."
        ]
    },
    {
        "q": "What is 'boundary value analysis' related to in coverage?",
        "o": [
            "Checking conditions at their limits (e.g., <, <=, >, >=).",
            "Checking the edge of the screen.",
            "Checking file boundaries.",
            "Checking network limits."
        ]
    },
    {
        "q": "If a boolean condition is 'A || B', and A is true, B might not be evaluated. This relates to:",
        "o": [
            "Short-circuit evaluation affecting coverage metrics.",
            "Compiler error.",
            "Runtime exception.",
            "Memory leak."
        ]
    },
    {
        "q": "To get 100% condition coverage on 'if (A || B)', you need to test situations where B is evaluated, which means:",
        "o": [
            "A must be false.",
            "A must be true.",
            "B must be true.",
            "B must be false."
        ]
    },
    {
        "q": "What is the benefit of 'differential coverage' in a pull request?",
        "o": [
            "Ensuring that *new or modified* code is adequately covered, regardless of overall project coverage.",
            "Comparing coverage between two teams.",
            "Running tests on different OS.",
            "Checking diffs manually."
        ]
    },
    {
        "q": "Can you use code coverage tools for manual testing?",
        "o": [
            "Yes, by instrumenting the app and clicking through the UI manually.",
            "No, only for automated tests.",
            "No, manual testing has no code.",
            "Only on Tuesdays."
        ]
    },
    {
        "q": "What is a common Pitfall of chasing 100% coverage?",
        "o": [
            "Writing trivial tests for getters/setters or mocking too much, ignoring real behavior.",
            "Finding too many bugs.",
            "Improving code structure.",
            "Making managers happy."
        ]
    },
    {
        "q": "When using a mocking framework, if you verify a call happened, does that count as covering the called method?",
        "o": [
            "No, it verifies the interaction, but the code inside the mocked method is not executed.",
            "Yes, verification equals execution.",
            "Yes, always.",
            "Only for void methods."
        ]
    },
    {
        "q": "What is 'Branch Probability'?",
        "o": [
            "The likelihood of a branch being taken, rarely measured by standard tools.",
            "The percentage of branches covered.",
            "The number of if-statements.",
            "A gambling term."
        ]
    },
    {
        "q": "Which file is commonly ignored in coverage to avoid skewing results?",
        "o": [
            "Test files themselves, configuration files, and generated code.",
            "Controller files.",
            "Service files.",
            "Utility files."
        ]
    },
    {
        "q": "If you have a try-catch block where catch is empty and never hit, is line coverage 100%?",
        "o": [
            "No, the catch line/block is not executed.",
            "Yes, empty blocks don't count.",
            "Yes, try covers catch.",
            "Maybe."
        ]
    },
    {
        "q": "Is code coverage a functional or structural metric?",
        "o": [
            "Structural (White-box).",
            "Functional (Black-box).",
            "Performance.",
            "Usability."
        ]
    },
    {
        "q": "What is 'Loop Boundary Coverage'?",
        "o": [
            "Testing loops executed 0 times, 1 time, and many times.",
            "Testing infinite loops.",
            "Testing nested loops.",
            "Testing loop variables."
        ]
    },
    {
        "q": "Can an empty constructor affect coverage?",
        "o": [
            "Yes, if not called, the class declaration line or constructor line shows as uncovered.",
            "No, it's empty.",
            "No, constructors are ignored.",
            "Only private ones."
        ]
    },
    {
        "q": "In Python coverage, what does  do?",
        "o": [
            "Configures settings like included/excluded files, concurrency, and report formats.",
            "Stores the report.",
            "Is the executable.",
            "Is a virus."
        ]
    },
    {
        "q": "What does the term 'Test Gap Analysis' refer to?",
        "o": [
            "Identifying changed code that has not been executed by any test.",
            "Analyzing gaps in resume.",
            "Analyzing time gaps.",
            "Analyzing network gaps."
        ]
    },
    {
        "q": "Is it possible for coverage to decrease when adding a new test?",
        "o": [
            "No, adding a test can only increase or maintain coverage (assuming code logic is constant).",
            "Yes, if the test fails.",
            "Yes, if the test is slow.",
            "Yes, if the test is large."
        ]
    },
    {
        "q": "Is it possible for coverage to decrease when deleting code?",
        "o": [
            "Yes, if the deleted code was covered and the remaining code has less coverage proportion.",
            "No, less code means higher coverage.",
            "Always increases.",
            "Never changes."
        ]
    },
    {
        "q": "Which Java Agent is usually used by JaCoCo?",
        "o": [
            "jacocoagent.jar",
            "junit.jar",
            "mockito.jar",
            "agent.jar"
        ]
    },
    {
        "q": "Can you merge multiple coverage execution data files (e.g. from parallel builds)?",
        "o": [
            "Yes, tools like JaCoCo allow merging .exec files.",
            "No, they are incompatible.",
            "No, must run serially.",
            "Only if on same machine."
        ]
    },
    {
        "q": "What is the typical color for uncovered code in HTML reports?",
        "o": [
            "Red.",
            "Green.",
            "Blue.",
            "Yellow."
        ]
    },
    {
        "q": "What is the typical color for covered code in HTML reports?",
        "o": [
            "Green.",
            "Red.",
            "Yellow.",
            "Black."
        ]
    },
    {
        "q": "Does 'assert' statement failure affect coverage?",
        "o": [
            "If it fails, execution stops, so subsequent lines are not covered.",
            "No.",
            "Yes, it increases coverage.",
            "It deletes coverage."
        ]
    },
    {
        "q": "What does a 'branch' usually correspond to in bytecode?",
        "o": [
            "A jump instruction (like IFEQ, IFNE).",
            "A load instruction.",
            "A store instruction.",
            "A nop."
        ]
    },
    {
        "q": "If you have a 'static' block, when is it covered?",
        "o": [
            "When the class is loaded and initialized.",
            "When an instance is created.",
            "When a method is called.",
            "When the file is saved."
        ]
    },
    {
        "q": "Can a private method have code coverage?",
        "o": [
            "Yes, if it is called by a public method that is tested.",
            "No, private methods cannot be tested.",
            "No, they are invisible.",
            "Only with reflection."
        ]
    },
    {
        "q": "Does code coverage guarantee that there are no memory leaks?",
        "o": [
            "No.",
            "Yes.",
            "Maybe.",
            "Only if 100%."
        ]
    },
    {
        "q": "Does coverage analysis work for multi-threaded applications?",
        "o": [
            "Yes, generally, though race conditions are not detected by coverage itself.",
            "No, it only works for single threads.",
            "No, it crashes.",
            "Only in Go."
        ]
    },
    {
        "q": "What is 'Decision Coverage'?",
        "o": [
            "Another term often used interchangeably with Branch Coverage.",
            "Coverage of management decisions.",
            "Coverage of architecture.",
            "Coverage of UI."
        ]
    },
    {
        "q": "How can you exclude a specific method from JaCoCo coverage?",
        "o": [
            "Using a custom annotation like @Generated (if configured) or filtering configuration.",
            "Deleting it.",
            "Commenting it out.",
            "Renaming it."
        ]
    },
    {
        "q": "Does 100% coverage mean all user scenarios are tested?",
        "o": [
            "No, unit tests mocking dependencies don't reflect real user flows.",
            "Yes.",
            "Most likely.",
            "Of course."
        ]
    },
    {
        "q": "If code coverage is 80%, what does the 20% represent?",
        "o": [
            "Code that was never executed during the test suite run.",
            "Comments.",
            "Whitespace.",
            "Bugs."
        ]
    },
    {
        "q": "Which is an example of code that is hard to cover?",
        "o": [
            "Error handling for rare system failures (e.g. OutOfMemoryError).",
            "Simple addition.",
            "String concatenation.",
            "Variable assignment."
        ]
    },
    {
        "q": "What happens to coverage if you use 'System.exit()' in a test?",
        "o": [
            "It might terminate the JVM before coverage data is dumped, losing the report.",
            "It increases coverage.",
            "It validates the exit.",
            "Nothing."
        ]
    },
    {
        "q": "Why is 'code coverage' useful for legacy code?",
        "o": [
            "It identifies which parts of the system are exercised by the current safety net of tests.",
            "It refactors the code automatically.",
            "It rewrites the code.",
            "It deletes the code."
        ]
    },
    {
        "q": "What is the 'Pareto principle' applied to testing?",
        "o": [
            "20% of the code might cause 80% of the bugs, so cover critical paths first.",
            "Cover 50% only.",
            "Cover 100% always.",
            "Don't test."
        ]
    },
    {
        "q": "How does 'lazy initialization' affect coverage?",
        "o": [
            "The initialization block is only covered if the getter is called.",
            "It is always covered.",
            "It is never covered.",
            "It is skipped."
        ]
    },
    {
        "q": "Can you have good coverage with bad tests?",
        "o": [
            "Yes, if tests execute code but assert nothing.",
            "No.",
            "Only in Ruby.",
            "Never."
        ]
    },
    {
        "q": "What is 'Block coverage'?",
        "o": [
            "Coverage of basic blocks (sequences of instructions with one entry and one exit).",
            "Coverage of blocking I/O.",
            "Coverage of synchronize blocks.",
            "Coverage of Lego blocks."
        ]
    },
    {
        "q": "If a line contains , is it covered if b is 0?",
        "o": [
            "No, if it throws ArithmeticException before completion (depends on tool granularity).",
            "Yes, it ran until the crash.",
            "Yes, always.",
            "No, exceptions mean no coverage."
        ]
    },
    {
        "q": "Which tool is used for C/C++ coverage?",
        "o": [
            "gcov",
            "JaCoCo",
            "Istanbul",
            "Coverage.py"
        ]
    },
    {
        "q": "What is the main output file of ?",
        "o": [
            ".gcov file",
            ".xml",
            ".html",
            ".json"
        ]
    },
    {
        "q": "Does running tests in parallel on different machines simplify coverage collection?",
        "o": [
            "No, it complicates it because you must merge partial reports.",
            "Yes, it makes it instant.",
            "Yes, no merging needed.",
            "It's the same."
        ]
    },
    {
        "q": "Can IDEs like IntelliJ or Eclipse show coverage in the editor?",
        "o": [
            "Yes, usually with green/red bars in the gutter.",
            "No.",
            "Only in Ultimate edition.",
            "Only via plugins."
        ]
    },
    {
        "q": "What does a diamond icon usually represent in a coverage gutter?",
        "o": [
            "Branch coverage status (partially or fully covered).",
            "A breakpoint.",
            "An error.",
            "A warning."
        ]
    },
    {
        "q": "If you use reflection to invoke a method, is it covered?",
        "o": [
            "Yes, execution is execution regardless of how it was invoked.",
            "No.",
            "Only if public.",
            "Only if annotated."
        ]
    },
    {
        "q": "What is 'Application code' vs 'Test code' coverage?",
        "o": [
            "You typically only care about coverage of Application code.",
            "You should cover Test code too.",
            "They are the same.",
            "Only test code matters."
        ]
    },
    {
        "q": "Does strict coverage enforcement slow down development?",
        "o": [
            "It can, if developers struggle to test trivial code or difficult legacy static blocks.",
            "No, it speeds it up.",
            "No effect.",
            "It promotes copy-paste."
        ]
    },
    {
        "q": "What is a 'baseline' in coverage?",
        "o": [
            "The current coverage level against which future changes are compared (e.g., 'ratcheting').",
            "The bottom line of code.",
            "The 0% mark.",
            "The compiler version."
        ]
    },
    {
        "q": "If you have a default interface method in Java 8+, is it covered?",
        "o": [
            "Only if a class implementing it does not override it and the test calls it.",
            "Yes, always.",
            "No, interfaces have no code.",
            "Maybe."
        ]
    }
,
    {
        "q": "Why is it recommended to run coverage analysis during the CI (Continuous Integration) phase?",
        "o": [
            "To automatically detect if new code executes tests and ensure quality gates are met.",
            "To crash the server.",
            "To slow down the build.",
            "To use more license seats."
        ]
    },
    {
        "q": "What happens if a CI build fails a 'coverage threshold' check?",
        "o": [
            "The build is marked as failed/unstable, preventing merge or deployment.",
            "The build passes with a warning.",
            "The build deletes the code.",
            "The coverage increases."
        ]
    },
    {
        "q": "Is fail-under-coverage the only useful CI policy?",
        "o": [
            "No, checking for 'decreased coverage' (ratcheting) is often more effective than static thresholds.",
            "Yes, hard limits are best.",
            "No, manual review is the only way.",
            "Yes, always fail under 100%."
        ]
    },
    {
        "q": "How can you exclude test utility classes from JaCoCo reports in Maven?",
        "o": [
            "Use the <excludes> tag in the configuration with wildcard patterns.",
            "Delete the files.",
            "Rename them to .txt.",
            "Move them to another project."
        ]
    },
    {
        "q": "What is the risk of using too many exclusion patterns?",
        "o": [
            "Real production code might be accidentally excluded, inflating the coverage metrics.",
            "The report generation becomes too slow.",
            "The XML file becomes corrupt.",
            "Exclusions are illegal."
        ]
    },
    {
        "q": "When looking at historical coverage trends, a downward slope usually indicates:",
        "o": [
            "Accumulation of technical debt (new code without tests).",
            "Improved code quality.",
            "Better performance.",
            "Refactoring."
        ]
    },
    {
        "q": "What is 'Codecov's' concept of 'patch coverage'?",
        "o": [
            "Coverage percentage specifically for lines changed in the pull request.",
            "Coverage of patches applied to the OS.",
            "Coverage of the logo.",
            "Coverage of dependencies."
        ]
    },
    {
        "q": "If 'patch coverage' is 100% but overall coverage drops, what happened?",
        "o": [
            "The new code is covered, but deletions removed previously covered code, shifting the ratio.",
            "The new code is not covered.",
            "The tool is broken.",
            "Nothing."
        ]
    },
    {
        "q": "Why might you exclude Lombok-generated code from coverage?",
        "o": [
            "Because boilerplate getters/setters/builders are trusted and testing them adds little value.",
            "Because Lombok code is slow.",
            "Because Lombok is unsafe.",
            "Because Lombok is deprecated."
        ]
    },
    {
        "q": "How does Lombok config `lombok.addLombokGeneratedAnnotation = true` help coverage tools?",
        "o": [
            "It adds an annotation that tools like JaCoCo can use to automatically ignore the generated methods.",
            "It generates tests.",
            "It prints logs.",
            "It disables Lombok."
        ]
    },
    {
        "q": "What is 'merging' in the context of coverage reports?",
        "o": [
            "Combining unit, integration, and functional test coverage data into a single unified report.",
            "Git merge.",
            "Merging PDFs.",
            "Merging database tables."
        ]
    },
    {
        "q": "If you run tests in a Docker container, how do you get the coverage report out?",
        "o": [
            "Using volume mounts or copying the artifact out after execution.",
            "You can't.",
            "Print it to stdout.",
            "It writes to the host automatically."
        ]
    },
    {
        "q": "Can you use JaCoCo with remote integration tests (e.g. running on a Tomcat server)?",
        "o": [
            "Yes, by attaching the JaCoCo agent to the Tomcat JVM and dumping execution data via TCP or JMX.",
            "No, only local tests.",
            "No, Tomcat is not supported.",
            "Only on JBoss."
        ]
    },
    {
        "q": "What implies a 'false positive' in code coverage?",
        "o": [
            "The line is executed and marked green, but the logic is wrong or assertions are missing.",
            "The line is red but tested.",
            "The line is yellow.",
            "The report is blank."
        ]
    },
    {
        "q": "How does Kotlin inline functions affect coverage?",
        "o": [
            "They can be tricky because the bytecode is copied to call sites, potentially complicating mapping back to source.",
            "It works perfectly always.",
            "Inline functions are ignored.",
            "Kotlin has no coverage."
        ]
    },
    {
        "q": "What is 'branch coverage' limit in JaCoCo for exception handling?",
        "o": [
            "JaCoCo tracks exception handlers, but standard try-catch sometimes shows partial if only the happy path is run.",
            "It ignores exceptions.",
            "It marks exceptions as 100% always.",
            "It crashes."
        ]
    },
    {
        "q": "Why exclude 'configuration' classes from coverage?",
        "o": [
            "They often contain hard-to-test startup logic or framework bindings better verified by integration tests.",
            "They are too large.",
            "They are binary.",
            "They are text files."
        ]
    },
    {
        "q": "What is a 'threshold violation'?",
        "o": [
            "When the measured coverage falls below the configured minimum percentage.",
            "When a test fails.",
            "When code is too complex.",
            "When a file is too large."
        ]
    },
    {
        "q": "Does 100% coverage guarantee no runtime errors?",
        "o": [
            "No, coverage checks execution, not state validity or concurrency issues.",
            "Yes.",
            "Almost.",
            "Yes, for Java."
        ]
    },
    {
        "q": "What is 'delta coverage'?",
        "o": [
            "The difference in coverage between the current branch and the target branch.",
            "Coverage of the Delta airline app.",
            "Change in file size.",
            "Change in test count."
        ]
    },
    {
        "q": "How can 'Git' integration help coverage analysis locally?",
        "o": [
            "Tools can show coverage only for modified lines in the current working copy (e.g., in IDE).",
            "Git runs the tests.",
            "Git merges the tests.",
            "Git blames the developer."
        ]
    },
    {
        "q": "Code coverage overhead is usually negligible for:",
        "o": [
            "Unit tests.",
            "Load tests.",
            "Performance benchmarks.",
            "Real-time systems."
        ]
    },
    {
        "q": "Why should performance tests generally NOT track code coverage?",
        "o": [
            "Instrumentation adds overhead/latency that skews performance metrics.",
            "It is impossible.",
            "Coverage tools don't support it.",
            "It breaks the server."
        ]
    },
    {
        "q": "If you have a 'switch' on an Enum, and you cover all enum values, is default covered?",
        "o": [
            "Often default is marked unreachable/uncovered if the compiler generates it but code never hits it.",
            "Yes, always.",
            "No, must add a new Enum value.",
            "Default is removed by compiler."
        ]
    },
    {
        "q": "How do you handle 'unreachable code' coverage noise?",
        "o": [
            "Exclude the specific lines/methods or use 'suppress' annotations if the tool supports it.",
            "Delete the project.",
            "Write a test that does magic.",
            "Accept 0% coverage."
        ]
    },
    {
        "q": "What benefit does 'visualization' (treemaps/sunbursts) offer for coverage?",
        "o": [
            "Quickly identifying large modules or packages with poor coverage (hotspots).",
            "It looks cool.",
            "It shows dependency graph.",
            "It shows class hierarchy."
        ]
    },
    {
        "q": "Can you combine Front-end and Back-end coverage into one report?",
        "o": [
            "Yes, using tools like SonarQube that ingest multiple formats (LCOV + XML).",
            "No, never.",
            "Only if same language.",
            "Only if same file."
        ]
    },
    {
        "q": "What is 'branch coverage' for a 'for-each' loop?",
        "o": [
            "It checks if the loop was entered (list not empty) and skipped (list empty).",
            "If checks each item.",
            "It checks loop variable type.",
            "It checks nothing."
        ]
    },
    {
        "q": "If you use 'assert' in production code (Java), how does it affect coverage?",
        "o": [
            "The assert statement generates a branch. If assertions are disabled (default), branch is ignored or optimized out.",
            "It crashes coverage.",
            "It is always covered.",
            "It is compile time only."
        ]
    },
    {
        "q": "Why is 'complexity' often reported alongside coverage?",
        "o": [
            "Complex code with low coverage is the highest risk area (e.g., Coordinate in the 'Quadrant of Death').",
            "They are the same.",
            "Complexity is coverage.",
            "To fill space."
        ]
    },
    {
        "q": "What is 'Crap4J' metric?",
        "o": [
            "A metric combining Cyclomatic Complexity and Code Coverage to indicate risk/maintainability.",
            "A bad Java framework.",
            "A fast testing tool.",
            "A logger."
        ]
    },
    {
        "q": "A CRAP score of > 30 usually means:",
        "o": [
            "The method is complex and has too little coverage; refactor or test more.",
            "It is perfect.",
            "It has 30 lines.",
            "It is compatible with Java 30."
        ]
    },
    {
        "q": "In a Ruby on Rails project, 'SimpleCov' is used for:",
        "o": [
            "Code coverage analysis.",
            "Simplifying code.",
            "Generating scaffolding.",
            "Database migration."
        ]
    },
    {
        "q": "How to handle coverage for 'private constructor' of a strict utility class?",
        "o": [
            "Usually ignore it, or trigger it via reflection, or just accept the tiny coverage loss.",
            "Make it public.",
            "Remove the class.",
            "Add a main method."
        ]
    },
    {
        "q": "Does Jacoco support 'per-test' coverage (mapping specific lines to specific tests)?",
        "o": [
            "No, it aggregates execution data. Tools like Clover or SonarQube (with listeners) can attempt this.",
            "Yes, natively.",
            "Yes, always.",
            "JaCoCo is only for C++."
        ]
    },
    {
        "q": "What is 'test optimization' based on coverage?",
        "o": [
            "Running only the tests that cover the modified code (Test Impact Analysis).",
            "Deleting slow tests.",
            "Writing shorter tests.",
            "Optimizing the compiler."
        ]
    },
    {
        "q": "Why is 'branch coverage' superior to 'statement coverage' for `x = (a > b) ? a : b`?",
        "o": [
            "Statement coverage is 100% just by executing the line once, but branch requires testing both a > b and a <= b.",
            "It isn't superior.",
            "Because it is longer.",
            "Because it uses math."
        ]
    },
    {
        "q": "What file pattern is typical for exclusion?",
        "o": [
            "**/*Test.java, **/IT*.java, **/generated/**",
            "**/*Controller.java",
            "**/*.xml",
            "**/*.md"
        ]
    },
    {
        "q": "If you see 0% coverage on a class you tested, what is a likely cause?",
        "o": [
            "The test ran against a different version of the class, or instrumented class was not used.",
            "The code is perfect.",
            "The test passed too fast.",
            "The class is final."
        ]
    },
    {
        "q": "What is 'Modified Condition/Decision Coverage' (MCDC) essential for?",
        "o": [
            "Certifying strict safety standards (e.g. ISO 26262) where redundancy must also be verified.",
            "Web apps.",
            "Startups.",
            "Prototypes."
        ]
    },
    {
        "q": "Can Cobertura XML be used by Jenkins?",
        "o": [
            "Yes, Jenkins Cobertura plugin can preserve and display the reports.",
            "No.",
            "Only on Linux.",
            "Only with Maven."
        ]
    },
    {
        "q": "What is 'block-mode' vs 'line-mode' in some tools?",
        "o": [
            "Block mode tracks basic blocks; Line mode tracks textual lines. Block is more precise for multi-statement lines.",
            "Block limits execution.",
            "Line mode is faster.",
            "No difference."
        ]
    },
    {
        "q": "If a method throws Exception immediately, is the catch block covered?",
        "o": [
            "Yes, if the test is designed to catch it.",
            "No, execution stops.",
            "Only if finally exists.",
            "Never."
        ]
    },
    {
        "q": "Does 'coverage' prove that the code does what the user wants?",
        "o": [
            "No, that is 'validation'. Coverage verifies 'verification' (execution).",
            "Yes.",
            "Maybe.",
            "Coverage equals Requirements."
        ]
    },
    {
        "q": "What is the role of 'Source Verification' in coverage reports?",
        "o": [
            "Ensuring the source code shown in the report matches the bytecode executed.",
            "Verifying the author.",
            "Verifying git sha.",
            "Checking spelling."
        ]
    },
    {
        "q": "Why might 'anonymous inner classes' or 'lambdas' appear clearly in coverage reports?",
        "o": [
            "They compile to separate class files (e.g., $1.class) and are instrumented individually.",
            "They don't appear.",
            "They are always green.",
            "They are always red."
        ]
    },
    {
        "q": "In JaCoCo, what does the 'diamond' color code 'red' mean?",
        "o": [
            "Neither branch taken (e.g. loops never entered, if never executed).",
            "One branch taken.",
            "All branches taken.",
            "Syntax error."
        ]
    },
    {
        "q": "In JaCoCo, what does the 'diamond' color code 'yellow' mean?",
        "o": [
            "Partially covered branch (some outcomes missed).",
            "Fully covered.",
            "Not covered.",
            "Warning."
        ]
    },
    {
        "q": "What is the typical exclusion strategy for GUI code (Swing/JavaFX)?",
        "o": [
            "Exclude the View layer if automated UI tests are not running with coverage, mock the view in presenters.",
            "Test everything manually.",
            "Use robot always.",
            "Delete the UI."
        ]
    },
    {
        "q": "Does 'Spring Boot' test slice (@WebMvcTest) provide full coverage?",
        "o": [
            "No, it only loads the web layer. Service/Repository beans are mocked, so their code isn't covered.",
            "Yes, it loads everything.",
            "Yes, for controllers.",
            "No, it fails."
        ]
    },
    {
        "q": "How to aggregate coverage in a multi-module Maven project?",
        "o": [
            "Use jacoco-maven-plugin:report-aggregate goal in a parent or dedicated reporting module.",
            "Copy paste files.",
            "Run mvn clean install twice.",
            "Use Gradle."
        ]
    },
    {
        "q": "What is 'Code Coverage' vs 'Test Coverage'?",
        "o": [
            "Code coverage is percentage of code executed. Test coverage usually refers to requirements coverage (traceability).",
            "They are synonyms.",
            "Test coverage counts number of tests.",
            "Code coverage counts classes."
        ]
    },
    {
        "q": "Can you have 100% Code Coverage and 50% Test (Requirements) Coverage?",
        "o": [
            "Yes, you can execute all code but miss half the business scenarios.",
            "No, they are linked.",
            "Only in C#.",
            "Impossible."
        ]
    },
    {
        "q": "What is 'Mutation Score'?",
        "o": [
            "Percentage of mutants killed (detected) by the test suite.",
            "Percentage of mutants created.",
            "The speed of mutation.",
            "A movie rating."
        ]
    },
    {
        "q": "Which tool offers mutation testing for Java?",
        "o": [
            "PIT (Pitest).",
            "JUnit.",
            "Mockito.",
            "Maven."
        ]
    },
    {
        "q": "Mutation testing helps find:",
        "o": [
            "Weak assertions where code is executed but results are ignored.",
            "Syntax errors.",
            "Compiler bugs.",
            "Slow code."
        ]
    },
    {
        "q": "Is mutation testing faster or slower than standard coverage?",
        "o": [
            "Much slower, as it runs the test suite many times.",
            "Faster.",
            "Same speed.",
            "Instant."
        ]
    },
    {
        "q": "Why exclude `hashCode` and `equals` from manual unit testing sometimes?",
        "o": [
            "If auto-generated (e.g. IDE, Lombok), testing them is often low-value/redundant unless logic is custom.",
            "They are hard to test.",
            "They are private.",
            "They are deprecated."
        ]
    },
    {
        "q": "What is 'n-switch coverage'?",
        "o": [
            "Coverage of sequences of 'n' transitions in a state machine.",
            "Coverage of network switches.",
            "Coverage of Nintendo Switch.",
            "Coverage of n variables."
        ]
    },
    {
        "q": "In JavaScript, how does 'source map' help coverage?",
        "o": [
            "It maps code coverage from the transpiled/minified bundle back to the original source (TS/ES6).",
            "It maps images.",
            "It maps files.",
            "It creates routes."
        ]
    },
    {
        "q": "If you cover a 'deprecated' method, should it count?",
        "o": [
            "Yes, if it's still in the codebase, it should be tested until removed.",
            "No, ignores deprecated.",
            "Only if marked for removal.",
            "No."
        ]
    },
    {
        "q": "What is 'Data Flow Coverage'?",
        "o": [
            "Tracks the lifecycle of variables: definition, usage, and destruction paths.",
            "Tracks database flow.",
            "Tracks network packets.",
            "Tracks user clicks."
        ]
    },
    {
        "q": "Which is a 'definition-use' pair in data flow coverage?",
        "o": [
            "A place where a variable is assigned (def) and a place where it is read (use).",
            "A dictionary.",
            "A key-value pair.",
            "A function call."
        ]
    },
    {
        "q": "Can static analysis tools (like FindBugs/SpotBugs) replace code coverage?",
        "o": [
            "No, they find potential bugs by pattern matching, not by executing tests.",
            "Yes, entirely.",
            "Yes, they are better.",
            "Maybe."
        ]
    },
    {
        "q": "What is 'Strict Boolean Coverage'?",
        "o": [
            "Evaluating conditions where short-circuiting is forbidden or tracked explicitly.",
            "Always returning true.",
            "Always returning false.",
            "Using boolean only."
        ]
    },
    {
        "q": "If you have a CI pipeline with multiple stages (Unit, Integration, E2E), how do you get global coverage?",
        "o": [
            "Collect .exec data from each stage and merge them into a single report.",
            "You cannot.",
            "Sum the percentages manually.",
            "Average the percentages."
        ]
    },
    {
        "q": "Why is 'E2E' coverage often lower/harder to collect than Unit coverage?",
        "o": [
            "Because instrumenting a deployed/running app is complex and E2E tests are slower/flakier.",
            "E2E has no code.",
            "E2E is manual.",
            "Browsers block coverage."
        ]
    },
    {
        "q": "What does 'Branch Coverage' of 50% generally mean?",
        "o": [
            "For every if/else, on average only one path was taken.",
            "Code is half compiled.",
            "Code is half wrong.",
            "Tests failed halfway."
        ]
    },
    {
        "q": "Can you use JaCoCo for Android testing?",
        "o": [
            "Yes, configured via Gradle Android, heavily used for instrumented tests.",
            "No, Android uses Dalvik.",
            "No, Google forbids it.",
            "Only for NDK."
        ]
    },
    {
        "q": "What is 'Regression Testing' vs Coverage?",
        "o": [
            "Regression ensures old features break; coverage ensures code execution.",
            "They are the same.",
            "Regression is for UI.",
            "Coverage is for DB."
        ]
    },
    {
        "q": "If a method is 'final', does it affect coverage instrumentation?",
        "o": [
            "Usually no for JaCoCo (bytecode instrumentation), but can affect mocking tools.",
            "Yes, cannot be covered.",
            "Yes, stops instrumentation.",
            "No."
        ]
    },
    {
        "q": "What is the 'line hit' count?",
        "o": [
            "How many times a line was executed.",
            "How many bugs in a line.",
            "How many chars in a line.",
            "How many commits."
        ]
    },
    {
        "q": "Can you verify coverage of a 'catch(OutOfMemoryError e)' block easily?",
        "o": [
            "No, triggering OOM is hard/unstable in unit tests, often requires mocking or exclusion.",
            "Yes, just allocate array.",
            "Yes, using throw new OOM.",
            "Never cover errors."
        ]
    },
    {
        "q": "What is 'All-Defs' coverage?",
        "o": [
            "Every variable definition must reach at least one use.",
            "Defining all variables.",
            "Defining all functions.",
            "Using all types."
        ]
    },
    {
        "q": "Why might a 'switch' on String generate more branches than expected in Java?",
        "o": [
            "Because compilation converts it to hashcode checks and equals checks, creating multiple bytecode branches.",
            "It doesn't.",
            "Strings are complex.",
            "Java is buggy."
        ]
    },
    {
        "q": "Does 'code coverage' indicate 'dead code'?",
        "o": [
            "Yes, code that is never hit during extensive testing *might* be dead (or just untestable).",
            "No.",
            "Dead code flies away.",
            "Maybe."
        ]
    },
    {
        "q": "Which is better: 80% coverage with robust assertions or 100% with no assertions?",
        "o": [
            "80% with robust assertions.",
            "100% with no assertions.",
            "Neither.",
            "Both are good."
        ]
    },
    {
        "q": "What is the 'test pyramid' and coverage?",
        "o": [
            "Unit tests (base) should provide bulk of coverage; UI tests (top) cover critical paths but less code percentage.",
            "Pyramid scheme.",
            "Testing in Egypt.",
            "Triangular code."
        ]
    },
    {
        "q": "How to handle 'flaky tests' in coverage reports?",
        "o": [
            "They distort results (if failed). Fix or quarantine them.",
            "Include them always.",
            "Ignore the report.",
            "Delete the code."
        ]
    },
    {
        "q": "If you use 'Groovy' for testing Java, can you get Java coverage?",
        "o": [
            "Yes, JaCoCo instruments the actual executed Java bytecode regardless of the test language.",
            "No, mismatched languages.",
            "Only with Spock.",
            "Only with JUnit."
        ]
    },
    {
        "q": "What is 'Call-Pair Coverage'?",
        "o": [
            "Ensuring every method call from A to B is executed.",
            "Pair programming.",
            "Calling twice.",
            "Bluetooth pairing."
        ]
    },
    {
        "q": "Why is 'code coverage' a 'necessary but not sufficient' condition for quality?",
        "o": [
            "You cannot find bugs in code you don't execute, but execution doesn't prove correctness.",
            "It is sufficient.",
            "It is not necessary.",
            "It is irrelevant."
        ]
    },
    {
        "q": "What is 'Per-Test Coverage' useful for?",
        "o": [
            "Fault localization: knowing exactly which test covers the failing line.",
            "Nothing.",
            "Making report big.",
            "Slowing down tests."
        ]
    },
    {
        "q": "Can you use coverage to detect 'Bloated Code'?",
        "o": [
            "Yes, large chunks of uncovered code might indicate unused features.",
            "No.",
            "Maybe.",
            "Only manually."
        ]
    },
    {
        "q": "What is the role of 'JaCoCo.exec' file?",
        "o": [
            "Start the JVM with a javaagent to collect execution data into this binary file.",
            "Is the report.",
            "Is the source.",
            "Is the config."
        ]
    },
    {
        "q": "How to convert 'JaCoCo.exec' to HTML?",
        "o": [
            "Use the 'report' ant task or maven goal.",
            "Rename it.",
            "Open in browser.",
            "Use Word."
        ]
    },
    {
        "q": "Does coverage analysis work with obfuscated code?",
        "o": [
            "It's difficult; line mapping breaks unless mapping files are preserved and supported.",
            "Yes, easily.",
            "No, never.",
            "Only ProGuard."
        ]
    },
    {
        "q": "What is 'Function Entry Coverage'?",
        "o": [
            "Simply checking if the function was entered/called, regardless of what happened inside.",
            "Writing the function.",
            "Naming the function.",
            "Deleting the function."
        ]
    },
    {
        "q": "If coverage drops overnight without code changes, what happened?",
        "o": [
            "Maybe a test was disabled, or environment issue caused tests to skip.",
            "Magic.",
            "Compiler update.",
            "Cosmic rays."
        ]
    },
    {
        "q": "What is 'Instruction Coverage' (JaCoCo default)?",
        "o": [
            "Percentage of Java bytecode instructions executed.",
            "Percentage of lines.",
            "Percentage of methods.",
            "Percentage of classes."
        ]
    },
    {
        "q": "Is 'Instruction Coverage' more or less granular than 'Line Coverage'?",
        "o": [
            "More granular; one line can compile to many instructions.",
            "Less granular.",
            "Same.",
            "Different units."
        ]
    },
    {
        "q": "Why might a single-line getter show partial coverage?",
        "o": [
            "Usually shouldn't, unless complex expression inside or instrumenting anomaly.",
            "It's normal.",
            "Getters are hard.",
            "Setters are hard."
        ]
    },
    {
        "q": "What is 'basis path testing'?",
        "o": [
            "Deriving a set of execution paths that linearly independent to achieve full coverage.",
            "Testing path basis.",
            "Basic testing.",
            "Testing bases."
        ]
    },
    {
        "q": "Can you automate 'pull request decoration' with coverage?",
        "o": [
            "Yes, using tools like SonarCloud or Codecov to post comments on PRs.",
            "No, manual only.",
            "No, git forbids it.",
            "Only in SVN."
        ]
    },
    {
        "q": "What is the safest way to increase coverage?",
        "o": [
            "Write tests for uncovered viable use-cases.",
            "Delete code.",
            "Write assert(true).",
            "Lower the threshold."
        ]
    },
    {
        "q": "If you refactor one large method into two smaller ones, does coverage change?",
        "o": [
            "Percentage might persist, but maintainability improves. Coverage count might shift slightly due to method signatures.",
            "No.",
            "Yes, drops to 0.",
            "Yes, doubles."
        ]
    },
    {
        "q": "What is 'Coincidental Correctness'?",
        "o": [
            "When code is executed and produces correct output for the wrong reason, masking a bug despite coverage.",
            "Lucky guess.",
            "Good coding.",
            "AI generated."
        ]
    },
    {
        "q": "How does 'Design for Testability' affect coverage?",
        "o": [
            "Makes it easier to reach deep code paths, facilitating higher coverage.",
            "Makes it harder.",
            "No effect.",
            "Reduces coverage."
        ]
    },
    {
        "q": "What is 'Coupling' vs Coverage?",
        "o": [
            "High coupling makes unit test coverage harder (need complex mocks).",
            "High coupling makes it easier.",
            "No relation.",
            "Coupling increases coverage."
        ]
    }
,
    {
        "q": "What is 'Probe' in the context of JaCoCo instrumentation?",
        "o": [
            "A small piece of code (boolean array access) inserted into the control flow to mark execution of a block.",
            "A satellite.",
            "A debugger tool.",
            "A compiler optimization."
        ]
    },
    {
        "q": "How does JaCoCo minimize the performance overhead of probes?",
        "o": [
            "By using a boolean array per class and minimizing thread contention with simple array assignments.",
            "By using synchronized blocks.",
            "By writing to disk immediately.",
            "By sending data to weird ports."
        ]
    },
    {
        "q": "Which bytecode instruction is commonly used to inject probes?",
        "o": [
            "No specific instruction, but usually sequence causing side-effect on a localized array.",
            "NOP.",
            "INVOKEDYNAMIC.",
            "GOTO."
        ]
    },
    {
        "q": "What is the 'control flow graph' (CFG) role in coverage analysis?",
        "o": [
            "coverage tools build a CFG of the method to determine where to place probes for branch/instruction coverage.",
            "It visualizes the UI.",
            "It optimizes database.",
            "It configures git."
        ]
    },
    {
        "q": "Why does 'offline instrumentation' sometimes break method signatures?",
        "o": [
            "If the tool adds a parameter to pass the coverage data structure (e.g. Cobertura did this).",
            "It never breaks signatures.",
            "Because it renames methods.",
            "Because it changes return types."
        ]
    },
    {
        "q": "How does JaCoCo avoid modifying method signatures?",
        "o": [
            "It adds a synthetic static field ($jacocoData) to the class or uses a ThreadLocal/System property mechanism to retrieve the probe array.",
            "It doesn't.",
            "It changes all methods to public.",
            "It uses reflection."
        ]
    },
    {
        "q": "What is 'dominator tree' analysis in coverage?",
        "o": [
            "Using dominators in the CFG to deduce coverage of blocks that must be executed if a child block is executed.",
            "Tree planting.",
            "DOM parsing.",
            "Database indexing."
        ]
    },
    {
        "q": "If block A dominates block B, and B is executed, is A covered?",
        "o": [
            "Yes, assuming no exceptions jumped out between A and B.",
            "No.",
            "Maybe.",
            "Only if B is true."
        ]
    },
    {
        "q": "What is the challenge of coverage with 'InvokeDynamic' (Lambdas) in Java?",
        "o": [
            "The lambda body is in a synthetic method or class generated at runtime, tracking its source mapping requires specific support.",
            "It is impossible.",
            "Lambdas have no bytecode.",
            "Lambdas are interpreted."
        ]
    },
    {
        "q": "Can you measure coverage of JNI (Java Native Interface) C++ code with JaCoCo?",
        "o": [
            "No, JaCoCo only sees Java bytecode. You need a mix of JaCoCo (Java) and gcov/LCOV (C++).",
            "Yes, JaCoCo covers C++.",
            "Yes, native code is bytecode.",
            "No, JNI is untestable."
        ]
    },
    {
        "q": "How to merge coverage reports from a distributed system (microservices)?",
        "o": [
            "Collect execution data (exec) from each service instance, aggregate them centrally, and generate a report using the shared source/classes.",
            "Take screenshots.",
            "Use average.",
            "Run them on one machine."
        ]
    },
    {
        "q": "What is 'ObjCode' coverage?",
        "o": [
            "Coverage of the object code (machine code) rather than source lines. Critical in avionics/automotive.",
            "Coverage of objects.",
            "Coverage of Strings.",
            "Coverage of COMMENTS."
        ]
    },
    {
        "q": "Why is DO-178C Level A coverage so expensive?",
        "o": [
            "It requires MCDC and often Object Code Verification to ensure compiler didn't introduce uncovered paths.",
            "Software is expensive.",
            "Pilots are expensive.",
            "It requires golden machines."
        ]
    },
    {
        "q": "What is 'Bit-level coverage'?",
        "o": [
            "Analyzing coverage at the bit manipulation level (hardware/register logic).",
            "Coverage of bitmaps.",
            "Coverage of boolean keys.",
            "Coverage of coins."
        ]
    },
    {
        "q": "How does 'Code Aging' relate to coverage?",
        "o": [
            "Old code with high legacy coverage might still fail due to 'bit rot' (environment changes). Coverage is a snapshot.",
            "Code gets slower.",
            "Code loses coverage.",
            "Old code is better."
        ]
    },
    {
        "q": "Can 'Fuzz Testing' improve code coverage?",
        "o": [
            "Yes, fuzzers generate random/edge-case inputs that often hit deep, unexpected code paths.",
            "No, fuzzing matches strings.",
            "No, they are unrelated.",
            "Fuzzing reduces coverage."
        ]
    },
    {
        "q": "What is 'Symbolic Execution' used for in coverage?",
        "o": [
            "Analyzing code to compute inputs that will force execution of specific paths, aiming for high coverage automatically.",
            "Executing symbols.",
            "Compiling symbols.",
            "Linking symbols."
        ]
    },
    {
        "q": "Metric 'TMap' (Test Map) relates coverage to:",
        "o": [
            "Test cases mapping to requirements or features.",
            "Google Maps.",
            "TreeMap.",
            "HashMap."
        ]
    },
    {
        "q": "What is a 'Basic Block' in LLVM coverage?",
        "o": [
            "A sequence of instructions with one entry and one exit. LLVM instruments edges between blocks.",
            "A brick.",
            "A file.",
            "A function."
        ]
    },
    {
        "q": "Why might 'Edge Coverage' differ from 'Branch Coverage'?",
        "o": [
            "They are theoretically similar (edges in CFG), but tools might define 'branch' as source-level conditionals vs CFG edges.",
            "Edges are sharper.",
            "Branch is wood.",
            "No difference."
        ]
    },
    {
        "q": "If a method is 'inlined' by JIT (Just-in-Time) compiler, is coverage lost?",
        "o": [
            "No, JaCoCo instruments bytecode *before* JIT. However, JIT aggressive optimizations don't affect the probe execution logic usually.",
            "Yes, JIT deletes code.",
            "Yes, probes vanish.",
            "Maybe."
        ]
    },
    {
        "q": "What is 'Test Impact Analysis' (TIA)?",
        "o": [
            "Using coverage data to select only relevant tests for a given changeset to speed up CI.",
            "Analyzing impact of test failure.",
            "Analyzing CPU usage.",
            "Analyzing disk usage."
        ]
    },
    {
        "q": "How to handle 'Split Bytecode' (e.g. Kotlin 'when' compiled to tableswitch)?",
        "o": [
            "Tools map the potentially complex bytecode structure back to the single source line or expression.",
            "You can't.",
            "It shows 0%.",
            "It crashes."
        ]
    },
    {
        "q": "What is 'Definition-Use' chain (DU-chain)?",
        "o": [
            "A path from variable definition to its use without redefinition.",
            "A chain of commands.",
            "A blockchain.",
            "A compiler error."
        ]
    },
    {
        "q": "Does 'volatile' keyword affect coverage?",
        "o": [
            "No direct effect, but logic involving threads might be harder to cover deterministically.",
            "Yes, volatile cannot be covered.",
            "Yes, it explodes.",
            "No."
        ]
    },
    {
        "q": "What is 'Strong Mutation' testing?",
        "o": [
            "The mutant must not only be executed but also cause a state change visible at the end of the test (assertion failure).",
            "Mutating muscles.",
            "Deleting files.",
            "Renaming variables."
        ]
    },
    {
        "q": "What is 'Weak Mutation' testing?",
        "o": [
            "The mutant is executed and causes an internal state change, but test might pass if that state isn't asserted.",
            "Weak typing.",
            "Weak references.",
            "Weak signals."
        ]
    },
    {
        "q": "What is 'Equivalent Mutant' problem?",
        "o": [
            "A mutant that is syntactically different but semantically identical to original code, making it unkillable.",
            "Two identical files.",
            "Copy paste error.",
            "Git conflict."
        ]
    },
    {
        "q": "Covering 'race conditions' requires:",
        "o": [
            "Tools like 'ThreadSanitizer' or specialized concurrency testing (e.g. JCStress), not just standard coverage.",
            "More unit tests.",
            "Faster CPU.",
            "Slow motion."
        ]
    },
    {
        "q": "What is 'Path Sensitization'?",
        "o": [
            "The process of finding input values that force execution along a specific path.",
            "Making path sensitive.",
            "Creating files.",
            "Deleting paths."
        ]
    },
    {
        "q": "In theoretical coverage, what is 'infeasible path'?",
        "o": [
            "A path in the CFG that cannot be executed by any possible input (logic contradiction).",
            "A broken link.",
            "A missing file.",
            "A slow network."
        ]
    },
    {
        "q": "Does 100% path coverage require covering infeasible paths?",
        "o": [
            "No, only feasible paths. But detecting infeasibility is undecidable (Halting Problem).",
            "Yes.",
            "Maybe.",
            "Always."
        ]
    },
    {
        "q": "What is 'Strict Probe Strategy'?",
        "o": [
            "Inserting probes such that every transition is uniquely identified.",
            "Probing strictly.",
            "Strict typing.",
            "Strict mode."
        ]
    },
    {
        "q": "Can 'AspectJ' interfere with code coverage?",
        "o": [
            "Yes, weaving code changes bytecode. Coverage might flag synthetic aspect code or miss original lines if structure changes heavily.",
            "No.",
            "Only in Spring.",
            "Only for logging."
        ]
    },
    {
        "q": "What is 'Coverage Profiling'?",
        "o": [
            "Using coverage data to find frequently executed paths for optimization (Hot paths).",
            "Profiling users.",
            "Profiling memory.",
            "Profiling disk."
        ]
    },
    {
        "q": "How does 'OSGi' bundle structure affect JaCoCo?",
        "o": [
            "Classloaders in OSGi are complex; JaCoCo agent must be accessible to all bundles (bootdelegation) to instrument correctly.",
            "It breaks it completely.",
            "It simplifies it.",
            "No effect."
        ]
    },
    {
        "q": "What is 'Decision/Condition Coverage' (D/CC)?",
        "o": [
            "A metric requiring both Decision coverage and Condition coverage, but not necessarily MC/DC independence.",
            "Direct Current.",
            "Data Center.",
            "Design Code."
        ]
    },
    {
        "q": "Why is 'Kernel Coverage' hard?",
        "o": [
            "Interrupts, hardware dependencies, and critical timing make instrumentation risky and complex (often needs KCOV).",
            "Kernels are small.",
            "Kernels are protected.",
            "Kernels use assembly."
        ]
    },
    {
        "q": "What is 'Non-intrusive' coverage monitoring?",
        "o": [
            "Using hardware trace ports (ETM/PTM on ARM) to record execution without modifying software binary.",
            "Asking purely.",
            "Using cameras.",
            "Using log files."
        ]
    },
    {
        "q": "What is 'Test Suite Minimization' using coverage?",
        "o": [
            "Selecting a minimal subset of tests that achieves the same coverage as the full suite.",
            "Deleting tests.",
            "Making tests smaller.",
            "Zipping tests."
        ]
    },
    {
        "q": "Is 'Cyclomatic Complexity' 10 always bad?",
        "o": [
            "Not necessarily (e.g., a large switch-case), but it suggests high testing effort required.",
            "Yes, always refactor.",
            "No, 10 is low.",
            "It is perfect."
        ]
    },
    {
        "q": "What is 'Essential Complexity'?",
        "o": [
            "Complexity that cannot be removed (inherent to the problem logic) vs 'Accidental Complexity' (bad structure).",
            "Complexity of installation.",
            "Complexity of UI.",
            "Complexity of life."
        ]
    },
    {
        "q": "Can 'Code Coverage' detect 'Security Vulnerabilities'?",
        "o": [
            "Indirectly, by ensuring security sensitive paths are tested, but it doesn't detect the flaw itself.",
            "Yes, it flags SQL Injection.",
            "Yes, it finds XSS.",
            "No."
        ]
    },
    {
        "q": "What is 'Branch Coupling'?",
        "o": [
            "When a branch in one method forces a specific path in a called method.",
            "Two trees.",
            "Git branches.",
            "Merging branches."
        ]
    },
    {
        "q": "How does 'Polymorphism' affect coverage tracking?",
        "o": [
            "One call site 'a.foo()' might execute different implementations. Coverage aggregates them or tracks per class.",
            "It breaks coverage.",
            "It simplifies coverage.",
            "Polymorphism is ignored."
        ]
    },
    {
        "q": "What is 'Back-to-Back Testing' coverage?",
        "o": [
            "Comparing coverage of a model (e.g. Simulink) vs the generated code.",
            "Testing back buttons.",
            "Testing audio.",
            "Testing backups."
        ]
    },
    {
        "q": "Why is 'Code Coverage' mandatory for ISO 26262 ASIL D?",
        "o": [
            "Highest safety integrity level requires proof of strict structural coverage (often MC/DC) to minimize risk of unintended behavior.",
            "It is standard.",
            "It is law.",
            "It is easy."
        ]
    },
    {
        "q": "What is 'probe effect'?",
        "o": [
            "The intended instrumentation changes the timing/behavior of the system, potentially masking or creating bugs (Heisenbug).",
            "Alien probe.",
            "Network probe.",
            "Temperature probe."
        ]
    },
    {
        "q": "In coverage, what is a 'super block'?",
        "o": [
            "An aggregation of basic blocks that are always executed together.",
            "A large Lego.",
            "A neighbourhood.",
            "A file system."
        ]
    },
    {
        "q": "Can you get coverage for 'SQL Stored Procedures'?",
        "o": [
            "Yes, using database-specific tools (like SQLCover), standard Java/JS tools won't see inside DB logic.",
            "No, never.",
            "Yes, JaCoCo does it.",
            "Yes, JUnit does it."
        ]
    },
    {
        "q": "What is 'Gamification' of coverage?",
        "o": [
            "Using leaderboards or badges (e.g., 'Coverage King') to motivate developers (can backfire if quality is ignored).",
            "Playing games.",
            "Using Unity.",
            "Buying lootboxes."
        ]
    },
    {
        "q": "What is 'Residual Coverage'?",
        "o": [
            "Coverage remaining after removing code related to assertions, logging, or debug features.",
            "Coverage of residues.",
            "Trash coverage.",
            "Memory leaks."
        ]
    },
    {
        "q": "How to cover 'private static final' field initialization?",
        "o": [
            "It runs at class loading. Testing any static method or creating instance triggers it.",
            "You cannot.",
            "Wait for garbage collection.",
            "Use restart."
        ]
    },
    {
        "q": "What is 'Branch distance'?",
        "o": [
            "A heuristic used in search-based testing to measure how close an input was to flipping a branch condition.",
            "Distance between git branches.",
            "Length of if statement.",
            "Physical distance."
        ]
    },
    {
        "q": "Can 'Code Review' be guided by coverage?",
        "o": [
            "Yes, reviewers focus on uncovered lines or complex covered lines with weak assertions.",
            "No.",
            "Code review is manual.",
            "Coverage is automated."
        ]
    },
    {
        "q": "What is 'Specification Coverage'?",
        "o": [
            "Extent to which requirements/specs are covered by tests, orthogonal to code coverage.",
            "Coverage of spec files.",
            "Coverage of glasses.",
            "Coverage of comments."
        ]
    },
    {
        "q": "Does 'Code Coverage' help in 'Deadlock' detection?",
        "o": [
            "No, deadlock is a runtime state/concurrency issue, not a coverage issue.",
            "Yes.",
            "Maybe.",
            "Only if 100%."
        ]
    },
    {
        "q": "What is 'Loop Interior' coverage?",
        "o": [
            "Ensuring the body of the loop is executed.",
            "Cleaning the loop.",
            "Closing the loop.",
            "Looping forever."
        ]
    },
    {
        "q": "If 'x' is an Object, does 'if (x != null)' count as a branch?",
        "o": [
            "Yes, two outcomes: null or not null.",
            "No, implicit.",
            "No, object.",
            "Maybe."
        ]
    },
    {
        "q": "What is 'State Coverage'?",
        "o": [
            "Ensuring all states in a finite state machine are visited.",
            "Coverage of USA states.",
            "Coverage of React state.",
            "Coverage of Redux."
        ]
    },
    {
        "q": "What is 'Transition Coverage'?",
        "o": [
            "Ensuring all valid transitions between states are executed.",
            "Coverage of CSS transitions.",
            "Coverage of slides.",
            "Coverage of animation."
        ]
    },
    {
        "q": "Why is '100% coverage' a misleading goal?",
        "o": [
            "Diminishing returns: high cost for low risk code (getters), and false sense of security.",
            "It is impossible.",
            "It is too easy.",
            "It is expensive."
        ]
    },
    {
        "q": "What is 'Elapse Time' in coverage reports?",
        "o": [
            "Time taken to run the tests (session duration).",
            "Time to compile.",
            "Time to write code.",
            "Time to read report."
        ]
    },
    {
        "q": "Can you change coverage data file (exec) manually?",
        "o": [
            "It is a binary format, editing requires hex editor or API, usually corrupts it if checksums mismatch.",
            "Yes, text editor.",
            "Yes, notepad.",
            "No, it is read only."
        ]
    },
    {
        "q": "What is 'Session Info' in JaCoCo?",
        "o": [
            "Metadata about the test run (start time, dump time, node id).",
            "User login info.",
            "Browser cookies.",
            "Server session."
        ]
    },
    {
        "q": "What is the 'CRC' checksum role in JaCoCo class instrumentation?",
        "o": [
            "Ensures the class file analyzed at report time exactly matches the one executed. Mismatch = 0% coverage.",
            "Checks for virus.",
            "Checks for speed.",
            "Checks for style."
        ]
    },
    {
        "q": "Can you use coverage to detect 'unused dependencies'?",
        "o": [
            "Partially, if a jar's classes show 0% coverage and are known to be part of the app scope, maybe unused.",
            "Yes, always.",
            "No.",
            "Use Maven dependency:analyze."
        ]
    },
    {
        "q": "What is 'Branch Predicate'?",
        "o": [
            "The boolean expression determining the branch.",
            "The branch name.",
            "The git branch.",
            "The tree branch."
        ]
    },
    {
        "q": "What is 'Relational Operator' coverage?",
        "o": [
            "Checking if boundary errors exist (e.g. using > instead of >=).",
            "Coverage of SQL.",
            "Coverage of tables.",
            "Coverage of family."
        ]
    },
    {
        "q": "Who invented 'Code Coverage' concept?",
        "o": [
            "Miller and Maloney (1963) are often cited for initial work on testing measures.",
            "Linus Torvalds.",
            "Bill Gates.",
            "Steve Jobs."
        ]
    },
    {
        "q": "What is 'Statement' vs 'Block' in GCC?",
        "o": [
            "GCC uses basic blocks essentially, mapping them to lines.",
            "Statement is faster.",
            "Block is slower.",
            "No distinction."
        ]
    },
    {
        "q": "Is 'Comment Coverage' a thing?",
        "o": [
            "No, comments are discarded by compiler, not executable.",
            "Yes, 100% comments.",
            "Yes, javadoc.",
            "Maybe."
        ]
    },
    {
        "q": "What is the 'Law of Large Numbers' in testing?",
        "o": [
            "More tests doesn't necessarily mean better tests, quality beats quantity.",
            "Use large integers.",
            "Use big data.",
            "Test everything."
        ]
    },
    {
        "q": "How does 'Remote Debugging' affect coverage?",
        "o": [
            "It doesn't prevents coverage collection if the agent is attached.",
            "Stops it.",
            "Pauses it.",
            "Deletes it."
        ]
    },
    {
        "q": "What is 'Probe Insertion' strategy: 'Superblock' vs 'Optimal'?",
        "o": [
            "Optimal strategy minimizes number of probes needed to deduce full flow, reducing overhead.",
            "Superblock is better.",
            "Optimal is slower.",
            "No strategy."
        ]
    },
    {
        "q": "Can you get coverage of 'Annotation Processors'?",
        "o": [
            "Yes, by testing the processor execution loop.",
            "No, compiler time only.",
            "No, meta data.",
            "Maybe."
        ]
    },
    {
        "q": "What is 'Code Coverage' in a 'Serverless' (Lambda) environment?",
        "o": [
            "Harder to collect due to ephemeral containers; requires custom layers or vendor support.",
            "Easy.",
            "Standard.",
            "Not needed."
        ]
    },
    {
        "q": "What is 'Linear Code Sequence and Jump' (LCSAJ)?",
        "o": [
            "A wider coverage metric including sequential blocks and the jump.",
            "A game.",
            "A protocol.",
            "A standard."
        ]
    },
    {
        "q": "Do 'End-to-End' frameworks like Cypress provide code coverage?",
        "o": [
            "Yes, by instrumenting the source code (using nyc/babel-plugin-istanbul) served to the browser.",
            "No.",
            "Only for backend.",
            "Only for database."
        ]
    },
    {
        "q": "What is 'Hit Map'?",
        "o": [
            "A data structure mapping every coverable element to its execution count.",
            "A heat map.",
            "A game map.",
            "A road map."
        ]
    },
    {
        "q": "Should 'Exceptions' be covered?",
        "o": [
            "Yes, exception paths are code and should be verified.",
            "No, they are errors.",
            "Only checked exceptions.",
            "Only runtime exceptions."
        ]
    },
    {
        "q": "What is 'System Coverage'?",
        "o": [
            "Coverage of the system as a whole (black box).",
            "Coverage of OS.",
            "Coverage of hardware.",
            "Coverage of network."
        ]
    },
    {
        "q": "Is 'Code Coverage' an 'Objective' metric?",
        "o": [
            "Yes, it is a calculated number, unlike 'User Satisfaction'.",
            "No, subjective.",
            "No, abstract.",
            "No, random."
        ]
    },
    {
        "q": "Can 'Code Coverage' define 'Done' criteria?",
        "o": [
            "Yes, typically as a DoD (Definition of Done) requirement (e.g. > 85%).",
            "No.",
            "Maybe.",
            "Only for managers."
        ]
    },
    {
        "q": "What is the ultimate goal of code coverage?",
        "o": [
            "Confidence that the code behaves as expected and regression risk is low.",
            "100%.",
            "Green bars.",
            "Promotion."
        ]
    }
]
