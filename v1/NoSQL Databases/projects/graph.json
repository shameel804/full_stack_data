[
    {
        "title": "Graph Model",
        "ques": "What is a **Graph Database** optimized for?",
        "answer": {
            "type": "text",
            "content": "It is optimized for storing and traversing **Relationships** between data.\n\nIt stores **Nodes** (Entities) and **Edges** (Relationships). Unlike SQL, the relationship is a first-class citizen and physically persists, making traversals ('Friends of Friends') incredibly fast."
        },
        "explanation": "Neo4j is the market leader."
    },
    {
        "title": "Use Cases",
        "ques": "When should you use a Graph Database like **Neo4j**?",
        "answer": {
            "type": "text",
            "content": "1.  **Social Networks:** (Who follows whom?)\n2.  **Recommendation Engines:** (People who bought X also bought Y).\n3.  **Fraud Detection:** (Ring of fraudsters sharing the same phone number)."
        },
        "explanation": "Any problem where connections matter more than the data itself."
    },
    {
        "title": "Cypher",
        "ques": "What is **Cypher**?",
        "answer": {
            "type": "text",
            "content": "The query language for Neo4j.\n\nIt uses ASCII-art syntax to represent patterns.\n`MATCH (user:Person)-[:FRIEND]->(friend:Person) RETURN friend`"
        },
        "explanation": "It's intuitive to read."
    },
    {
        "title": "Performance vs SQL",
        "ques": "Why is SQL bad at 'Friends of Friends of Friends' queries?",
        "answer": {
            "type": "text",
            "content": "In SQL, this requires **Self-Joins**.\n\nA query for 3 degrees of separation requires joining the `users` table to itself 3 times. The performance degrades exponentially with depth (O(log n) or worse). In Graph DBs, traversal performance is constant (O(1)) relative to the total data size, it only depends on the number of relationships."
        },
        "explanation": "No 'Join Bomb'."
    }
]