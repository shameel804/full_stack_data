[
    {
        "q": "What does API stand for?",
        "type": "mcq",
        "o": [
            "Application Programming Interface",
            "Application Protocol Interface",
            "Advanced Programming Interface",
            "Application Process Integration"
        ]
    },
    {
        "q": "Which HTTP method is used to retrieve data from a server?",
        "type": "mcq",
        "o": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ]
    },
    {
        "q": "Which HTTP method is used to send new data to a server?",
        "type": "mcq",
        "o": [
            "POST",
            "GET",
            "DELETE",
            "HEAD"
        ]
    },
    {
        "q": "What HTTP status code indicates a successful request?",
        "type": "mcq",
        "o": [
            "200",
            "404",
            "500",
            "301"
        ]
    },
    {
        "q": "What HTTP status code indicates that a resource was not found?",
        "type": "mcq",
        "o": [
            "404",
            "200",
            "500",
            "403"
        ]
    },
    {
        "q": "An API endpoint is a URL where the API can be accessed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP method is used to delete a resource?",
        "type": "mcq",
        "o": [
            "DELETE",
            "REMOVE",
            "POST",
            "GET"
        ]
    },
    {
        "q": "What does the HTTP status code 500 indicate?",
        "type": "mcq",
        "o": [
            "Internal Server Error",
            "Not Found",
            "Unauthorized",
            "Bad Request"
        ]
    },
    {
        "q": "HTTP headers contain ______ information about the request or response.",
        "type": "fill_blank",
        "answers": [
            "metadata"
        ],
        "other_options": [
            "body",
            "endpoint",
            "protocol"
        ]
    },
    {
        "q": "Which HTTP method is used to update an existing resource?",
        "type": "mcq",
        "o": [
            "PUT",
            "GET",
            "POST",
            "HEAD"
        ]
    },
    {
        "q": "The GET method should never modify data on the server.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What HTTP status code indicates an unauthorized request?",
        "type": "mcq",
        "o": [
            "401",
            "404",
            "200",
            "500"
        ]
    },
    {
        "q": "Match the HTTP methods with their purposes:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Retrieve data",
            "Create data",
            "Update data",
            "Remove data"
        ]
    },
    {
        "q": "Which header specifies the format of data being sent in a request?",
        "type": "mcq",
        "o": [
            "Content-Type",
            "Authorization",
            "Accept",
            "Cache-Control"
        ]
    },
    {
        "q": "What does the HTTP status code 201 indicate?",
        "type": "mcq",
        "o": [
            "Created",
            "OK",
            "Not Found",
            "Moved Permanently"
        ]
    },
    {
        "q": "An endpoint typically consists of a base URL and a ______.",
        "type": "fill_blank",
        "answers": [
            "path"
        ],
        "other_options": [
            "header",
            "body",
            "method"
        ]
    },
    {
        "q": "HTTP is a stateless protocol.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP method only retrieves headers without the body?",
        "type": "mcq",
        "o": [
            "HEAD",
            "GET",
            "OPTIONS",
            "TRACE"
        ]
    },
    {
        "q": "What HTTP status code indicates a bad request due to client error?",
        "type": "mcq",
        "o": [
            "400",
            "500",
            "404",
            "200"
        ]
    },
    {
        "q": "The Accept header tells the server what format the client can ______.",
        "type": "fill_blank",
        "answers": [
            "understand"
        ],
        "other_options": [
            "send",
            "delete",
            "create"
        ]
    },
    {
        "q": "Which HTTP status code indicates forbidden access?",
        "type": "mcq",
        "o": [
            "403",
            "401",
            "404",
            "500"
        ]
    },
    {
        "q": "Match the HTTP status codes with their meanings:",
        "type": "match",
        "left": [
            "200",
            "404",
            "500",
            "301"
        ],
        "right": [
            "OK",
            "Not Found",
            "Server Error",
            "Moved Permanently"
        ]
    },
    {
        "q": "The POST method is idempotent.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "Which header is used to send authentication credentials?",
        "type": "mcq",
        "o": [
            "Authorization",
            "Content-Type",
            "Accept",
            "Host"
        ]
    },
    {
        "q": "What does the HTTP status code 204 indicate?",
        "type": "mcq",
        "o": [
            "No Content",
            "Created",
            "OK",
            "Not Found"
        ]
    },
    {
        "q": "Rearrange the HTTP request components in correct order:",
        "type": "rearrange",
        "words": [
            "Method",
            "URL",
            "Headers",
            "Body"
        ]
    },
    {
        "q": "Which HTTP method is used for partial updates?",
        "type": "mcq",
        "o": [
            "PATCH",
            "PUT",
            "POST",
            "UPDATE"
        ]
    },
    {
        "q": "The Content-Length header specifies the size of the request body in ______.",
        "type": "fill_blank",
        "answers": [
            "bytes"
        ],
        "other_options": [
            "kilobytes",
            "characters",
            "lines"
        ]
    },
    {
        "q": "What HTTP status code indicates a redirect?",
        "type": "mcq",
        "o": [
            "302",
            "200",
            "404",
            "500"
        ]
    },
    {
        "q": "The PUT method is idempotent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header tells the server the type of browser making the request?",
        "type": "mcq",
        "o": [
            "User-Agent",
            "Accept",
            "Host",
            "Referer"
        ]
    },
    {
        "q": "What is the default port for HTTP?",
        "type": "mcq",
        "o": [
            "80",
            "443",
            "8080",
            "3000"
        ]
    },
    {
        "q": "Match the HTTP headers with their purposes:",
        "type": "match",
        "left": [
            "Content-Type",
            "Authorization",
            "Accept",
            "Cache-Control"
        ],
        "right": [
            "Data format",
            "Credentials",
            "Response format",
            "Caching rules"
        ]
    },
    {
        "q": "HTTPS uses port ______ by default.",
        "type": "fill_blank",
        "answers": [
            "443"
        ],
        "other_options": [
            "80",
            "8080",
            "3000"
        ]
    },
    {
        "q": "Which HTTP method is safe and idempotent?",
        "type": "mcq",
        "o": [
            "GET",
            "POST",
            "DELETE",
            "PATCH"
        ]
    },
    {
        "q": "A query string in a URL starts with which character?",
        "type": "mcq",
        "o": [
            "?",
            "&",
            "#",
            "/"
        ]
    },
    {
        "q": "The OPTIONS method returns allowed HTTP methods for an endpoint.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP status code indicates the server is temporarily unavailable?",
        "type": "mcq",
        "o": [
            "503",
            "500",
            "404",
            "400"
        ]
    },
    {
        "q": "Query parameters in a URL are separated by the ______ character.",
        "type": "fill_blank",
        "answers": [
            "&"
        ],
        "other_options": [
            "?",
            "/",
            "#"
        ]
    },
    {
        "q": "What does the HTTP status code 429 indicate?",
        "type": "mcq",
        "o": [
            "Too Many Requests",
            "Not Found",
            "Unauthorized",
            "Bad Gateway"
        ]
    },
    {
        "q": "Match URL components with examples:",
        "type": "match",
        "left": [
            "Protocol",
            "Domain",
            "Path",
            "Query"
        ],
        "right": [
            "https://",
            "api.example.com",
            "/users",
            "?id=1"
        ]
    },
    {
        "q": "Which header controls browser caching behavior?",
        "type": "mcq",
        "o": [
            "Cache-Control",
            "Content-Type",
            "Accept",
            "Host"
        ]
    },
    {
        "q": "The DELETE method should be idempotent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What HTTP status code indicates a gateway timeout?",
        "type": "mcq",
        "o": [
            "504",
            "503",
            "500",
            "502"
        ]
    },
    {
        "q": "An API base URL typically includes the protocol and ______.",
        "type": "fill_blank",
        "answers": [
            "domain"
        ],
        "other_options": [
            "path",
            "query",
            "method"
        ]
    },
    {
        "q": "Which HTTP method is used to check available communication options?",
        "type": "mcq",
        "o": [
            "OPTIONS",
            "HEAD",
            "TRACE",
            "CONNECT"
        ]
    },
    {
        "q": "The Host header specifies which server should handle the request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the HTTP status code 502 indicate?",
        "type": "mcq",
        "o": [
            "Bad Gateway",
            "Service Unavailable",
            "Gateway Timeout",
            "Internal Server Error"
        ]
    },
    {
        "q": "Rearrange the URL structure in correct order:",
        "type": "rearrange",
        "words": [
            "Protocol",
            "Domain",
            "Port",
            "Path",
            "Query"
        ]
    },
    {
        "q": "Which header indicates the language preference of the client?",
        "type": "mcq",
        "o": [
            "Accept-Language",
            "Content-Language",
            "User-Agent",
            "Accept"
        ]
    },
    {
        "q": "A path parameter is embedded directly in the URL ______.",
        "type": "fill_blank",
        "answers": [
            "path"
        ],
        "other_options": [
            "query",
            "header",
            "body"
        ]
    },
    {
        "q": "Match HTTP status code ranges with their categories:",
        "type": "match",
        "left": [
            "1xx",
            "2xx",
            "4xx",
            "5xx"
        ],
        "right": [
            "Informational",
            "Success",
            "Client Error",
            "Server Error"
        ]
    },
    {
        "q": "What does the HTTP status code 304 indicate?",
        "type": "mcq",
        "o": [
            "Not Modified",
            "Moved Permanently",
            "Found",
            "See Other"
        ]
    },
    {
        "q": "The TRACE method echoes back the received request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header specifies the encoding of the response body?",
        "type": "mcq",
        "o": [
            "Content-Encoding",
            "Content-Type",
            "Accept-Encoding",
            "Transfer-Encoding"
        ]
    },
    {
        "q": "What HTTP status code range indicates redirection?",
        "type": "mcq",
        "o": [
            "3xx",
            "2xx",
            "4xx",
            "5xx"
        ]
    },
    {
        "q": "The Referer header contains the URL of the ______ page.",
        "type": "fill_blank",
        "answers": [
            "previous"
        ],
        "other_options": [
            "current",
            "next",
            "home"
        ]
    },
    {
        "q": "What is the output of this code checking an HTTP response?",
        "type": "mcq",
        "c": "const status = 200;\nif (status >= 200 && status < 300) {\n    console.log('Success');\n} else {\n    console.log('Error');\n}",
        "o": [
            "Success",
            "Error",
            "undefined",
            "null"
        ]
    },
    {
        "q": "The HTTP CONNECT method is used to establish a tunnel.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header prevents the browser from caching a response?",
        "type": "mcq",
        "o": [
            "Cache-Control: no-store",
            "Cache-Control: public",
            "Cache-Control: max-age=3600",
            "Cache-Control: private"
        ]
    },
    {
        "q": "What HTTP status code indicates permanent redirect?",
        "type": "mcq",
        "o": [
            "301",
            "302",
            "307",
            "308"
        ]
    },
    {
        "q": "Match response header types with examples:",
        "type": "match",
        "left": [
            "Entity",
            "General",
            "Response",
            "Request"
        ],
        "right": [
            "Content-Length",
            "Date",
            "Server",
            "Accept"
        ]
    },
    {
        "q": "The X-prefix in headers indicates ______ headers.",
        "type": "fill_blank",
        "answers": [
            "custom"
        ],
        "other_options": [
            "standard",
            "secure",
            "required"
        ]
    },
    {
        "q": "Which HTTP method should not have a request body?",
        "type": "mcq",
        "o": [
            "GET",
            "POST",
            "PUT",
            "PATCH"
        ]
    },
    {
        "q": "The 1xx status codes are informational responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does the HTTP status code 100 indicate?",
        "type": "mcq",
        "o": [
            "Continue",
            "OK",
            "Processing",
            "Switching Protocols"
        ]
    },
    {
        "q": "What is the output of this status code check?",
        "type": "mcq",
        "c": "const code = 404;\nconst type = Math.floor(code / 100);\nconsole.log(type + 'xx');",
        "o": [
            "4xx",
            "404",
            "4",
            "xx"
        ]
    },
    {
        "q": "Which header specifies acceptable response formats?",
        "type": "mcq",
        "o": [
            "Accept",
            "Content-Type",
            "Content-Accept",
            "Response-Type"
        ]
    },
    {
        "q": "API endpoints should use ______ for resource names.",
        "type": "fill_blank",
        "answers": [
            "nouns"
        ],
        "other_options": [
            "verbs",
            "adjectives",
            "numbers"
        ]
    },
    {
        "q": "What HTTP status code indicates unsupported media type?",
        "type": "mcq",
        "o": [
            "415",
            "400",
            "406",
            "422"
        ]
    },
    {
        "q": "The ETag header is used for caching validation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match HTTP methods with their safety characteristics:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Safe",
            "Not Safe",
            "Idempotent",
            "Idempotent"
        ]
    },
    {
        "q": "Which HTTP status code indicates not acceptable?",
        "type": "mcq",
        "o": [
            "406",
            "400",
            "415",
            "422"
        ]
    },
    {
        "q": "The If-Modified-Since header is used for ______ caching.",
        "type": "fill_blank",
        "answers": [
            "conditional"
        ],
        "other_options": [
            "permanent",
            "temporary",
            "forced"
        ]
    },
    {
        "q": "What does the HTTP status code 101 indicate?",
        "type": "mcq",
        "o": [
            "Switching Protocols",
            "Continue",
            "Processing",
            "OK"
        ]
    },
    {
        "q": "What is the output of this endpoint parsing code?",
        "type": "mcq",
        "c": "const url = '/api/users/123';\nconst parts = url.split('/');\nconsole.log(parts[2]);",
        "o": [
            "users",
            "api",
            "123",
            "undefined"
        ]
    },
    {
        "q": "The Last-Modified header indicates when a resource was last changed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP status code indicates a conflict in the request?",
        "type": "mcq",
        "o": [
            "409",
            "400",
            "404",
            "500"
        ]
    },
    {
        "q": "A ______ endpoint returns a collection of resources.",
        "type": "fill_blank",
        "answers": [
            "collection"
        ],
        "other_options": [
            "single",
            "nested",
            "root"
        ]
    },
    {
        "q": "What HTTP status code indicates request entity too large?",
        "type": "mcq",
        "o": [
            "413",
            "400",
            "414",
            "415"
        ]
    },
    {
        "q": "Rearrange HTTP response components in order:",
        "type": "rearrange",
        "words": [
            "Status Line",
            "Headers",
            "Blank Line",
            "Body"
        ]
    },
    {
        "q": "Match common Content-Type values with formats:",
        "type": "match",
        "left": [
            "application/json",
            "text/html",
            "text/plain",
            "application/xml"
        ],
        "right": [
            "JSON data",
            "Web pages",
            "Plain text",
            "XML data"
        ]
    },
    {
        "q": "Which HTTP status code indicates a gone resource?",
        "type": "mcq",
        "o": [
            "410",
            "404",
            "403",
            "400"
        ]
    },
    {
        "q": "The Expires header sets an absolute ______ time for cache.",
        "type": "fill_blank",
        "answers": [
            "expiration"
        ],
        "other_options": [
            "creation",
            "modification",
            "access"
        ]
    },
    {
        "q": "What is the output of this code validating HTTP methods?",
        "type": "mcq",
        "c": "const methods = ['GET', 'POST', 'PUT', 'DELETE'];\nconsole.log(methods.includes('PATCH'));",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "HTTP/2 supports multiplexing multiple requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP status code indicates URI too long?",
        "type": "mcq",
        "o": [
            "414",
            "413",
            "400",
            "431"
        ]
    },
    {
        "q": "The Vary header indicates which request headers affect ______.",
        "type": "fill_blank",
        "answers": [
            "caching"
        ],
        "other_options": [
            "routing",
            "authentication",
            "encoding"
        ]
    },
    {
        "q": "What HTTP status code indicates expectation failed?",
        "type": "mcq",
        "o": [
            "417",
            "400",
            "406",
            "415"
        ]
    },
    {
        "q": "Match HTTP status codes with their descriptions:",
        "type": "match",
        "left": [
            "201",
            "204",
            "400",
            "401"
        ],
        "right": [
            "Resource created",
            "No content",
            "Bad request",
            "Unauthorized"
        ]
    },
    {
        "q": "The Connection header controls whether the network stays ______.",
        "type": "fill_blank",
        "answers": [
            "open"
        ],
        "other_options": [
            "closed",
            "secure",
            "encrypted"
        ]
    },
    {
        "q": "What is the output of this HTTP method check?",
        "type": "mcq",
        "c": "const method = 'GET';\nconst safe = ['GET', 'HEAD', 'OPTIONS'];\nconsole.log(safe.includes(method) ? 'Safe' : 'Unsafe');",
        "o": [
            "Safe",
            "Unsafe",
            "true",
            "false"
        ]
    },
    {
        "q": "HTTP/1.1 introduced persistent connections by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which HTTP status code indicates precondition failed?",
        "type": "mcq",
        "o": [
            "412",
            "400",
            "417",
            "422"
        ]
    },
    {
        "q": "The Date header contains the ______ when the message was sent.",
        "type": "fill_blank",
        "answers": [
            "timestamp"
        ],
        "other_options": [
            "version",
            "type",
            "encoding"
        ]
    },
    {
        "q": "What HTTP status code indicates unprocessable entity?",
        "type": "mcq",
        "o": [
            "422",
            "400",
            "415",
            "406"
        ]
    },
    {
        "q": "The Server header identifies the software used by the origin server.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of the Content-Disposition header?",
        "type": "mcq",
        "o": [
            "Specify how content should be displayed or downloaded",
            "Define the content type",
            "Set the content length",
            "Control caching behavior"
        ]
    },
    {
        "q": "Which HTTP status code indicates method not allowed?",
        "type": "mcq",
        "o": [
            "405",
            "400",
            "403",
            "406"
        ]
    },
    {
        "q": "The Transfer-Encoding header specifies the encoding used for message ______.",
        "type": "fill_blank",
        "answers": [
            "transfer"
        ],
        "other_options": [
            "storage",
            "display",
            "compression"
        ]
    },
    {
        "q": "Match HTTP methods with typical use cases:",
        "type": "match",
        "left": [
            "GET /users",
            "POST /users",
            "PUT /users/1",
            "DELETE /users/1"
        ],
        "right": [
            "List all users",
            "Create new user",
            "Update user 1",
            "Remove user 1"
        ]
    },
    {
        "q": "What is the output of this code building a query string?",
        "type": "mcq",
        "c": "const params = new URLSearchParams();\nparams.append('name', 'John');\nparams.append('age', '30');\nconsole.log(params.toString());",
        "o": [
            "name=John&age=30",
            "name:John,age:30",
            "{name:John,age:30}",
            "?name=John&age=30"
        ]
    },
    {
        "q": "Chunked transfer encoding allows sending data in multiple parts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header is used to specify allowed origins for CORS?",
        "type": "mcq",
        "o": [
            "Access-Control-Allow-Origin",
            "Origin",
            "Allow-Origin",
            "CORS-Origin"
        ]
    },
    {
        "q": "What HTTP status code indicates length required?",
        "type": "mcq",
        "o": [
            "411",
            "400",
            "413",
            "414"
        ]
    },
    {
        "q": "The WWW-Authenticate header is sent when the server requires ______.",
        "type": "fill_blank",
        "answers": [
            "authentication"
        ],
        "other_options": [
            "authorization",
            "validation",
            "encryption"
        ]
    },
    {
        "q": "Which header specifies the maximum age for caching?",
        "type": "mcq",
        "o": [
            "Cache-Control: max-age",
            "Expires",
            "Age",
            "Cache-Max"
        ]
    },
    {
        "q": "HTTP/3 uses QUIC protocol instead of TCP.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this HTTP method validation?",
        "type": "mcq",
        "c": "const method = 'POST';\nconst hasBody = ['POST', 'PUT', 'PATCH'].includes(method);\nconsole.log(hasBody ? 'Has body' : 'No body');",
        "o": [
            "Has body",
            "No body",
            "true",
            "false"
        ]
    },
    {
        "q": "Match CORS headers with their purposes:",
        "type": "match",
        "left": [
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Methods",
            "Access-Control-Allow-Headers",
            "Access-Control-Max-Age"
        ],
        "right": [
            "Allowed domains",
            "Allowed HTTP methods",
            "Allowed request headers",
            "Preflight cache time"
        ]
    },
    {
        "q": "Which header indicates the content language?",
        "type": "mcq",
        "o": [
            "Content-Language",
            "Accept-Language",
            "Language",
            "Locale"
        ]
    },
    {
        "q": "A preflight request uses the ______ HTTP method.",
        "type": "fill_blank",
        "answers": [
            "OPTIONS"
        ],
        "other_options": [
            "GET",
            "HEAD",
            "POST"
        ]
    },
    {
        "q": "What HTTP status code indicates request header fields too large?",
        "type": "mcq",
        "o": [
            "431",
            "413",
            "414",
            "400"
        ]
    },
    {
        "q": "The Age header indicates how long a response has been in a cache.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header is used for content negotiation based on encoding?",
        "type": "mcq",
        "o": [
            "Accept-Encoding",
            "Content-Encoding",
            "Transfer-Encoding",
            "Encoding"
        ]
    },
    {
        "q": "Rearrange these steps in making an HTTP request:",
        "type": "rearrange",
        "words": [
            "DNS lookup",
            "TCP handshake",
            "Send request",
            "Receive response"
        ]
    },
    {
        "q": "What is the output of this status code check?",
        "type": "mcq",
        "c": "const status = 301;\nconst isRedirect = status >= 300 && status < 400;\nconsole.log(isRedirect);",
        "o": [
            "true",
            "false",
            "301",
            "undefined"
        ]
    },
    {
        "q": "Which header prevents clickjacking attacks?",
        "type": "mcq",
        "o": [
            "X-Frame-Options",
            "X-XSS-Protection",
            "Content-Security-Policy",
            "X-Content-Type-Options"
        ]
    },
    {
        "q": "The Retry-After header indicates when to retry a ______ request.",
        "type": "fill_blank",
        "answers": [
            "failed"
        ],
        "other_options": [
            "successful",
            "cached",
            "pending"
        ]
    },
    {
        "q": "Match HTTP version features:",
        "type": "match",
        "left": [
            "HTTP/1.0",
            "HTTP/1.1",
            "HTTP/2",
            "HTTP/3"
        ],
        "right": [
            "No persistent connections",
            "Keep-alive default",
            "Multiplexing",
            "QUIC protocol"
        ]
    },
    {
        "q": "What HTTP status code indicates upgrade required?",
        "type": "mcq",
        "o": [
            "426",
            "400",
            "101",
            "505"
        ]
    },
    {
        "q": "The X-Content-Type-Options header prevents MIME type sniffing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header specifies allowed HTTP methods for a resource?",
        "type": "mcq",
        "o": [
            "Allow",
            "Access-Control-Allow-Methods",
            "Methods",
            "Allowed-Methods"
        ]
    },
    {
        "q": "What is the output of this URL parsing code?",
        "type": "mcq",
        "c": "const url = new URL('https://api.example.com:8080/users');\nconsole.log(url.port);",
        "o": [
            "8080",
            "443",
            "80",
            "undefined"
        ]
    },
    {
        "q": "The Strict-Transport-Security header enforces ______ connections.",
        "type": "fill_blank",
        "answers": [
            "HTTPS"
        ],
        "other_options": [
            "HTTP",
            "TCP",
            "TLS"
        ]
    },
    {
        "q": "Which HTTP status code indicates network authentication required?",
        "type": "mcq",
        "o": [
            "511",
            "401",
            "407",
            "403"
        ]
    },
    {
        "q": "HTTP pipelining allows sending multiple requests without waiting for responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match security headers with their protections:",
        "type": "match",
        "left": [
            "X-Frame-Options",
            "X-XSS-Protection",
            "X-Content-Type-Options",
            "Strict-Transport-Security"
        ],
        "right": [
            "Clickjacking",
            "Cross-site scripting",
            "MIME sniffing",
            "Force HTTPS"
        ]
    },
    {
        "q": "What is the purpose of the Location header?",
        "type": "mcq",
        "o": [
            "Specify redirect URL or new resource location",
            "Indicate server location",
            "Define geographic location",
            "Set client location"
        ]
    },
    {
        "q": "The If-None-Match header is used with ______ for cache validation.",
        "type": "fill_blank",
        "answers": [
            "ETag"
        ],
        "other_options": [
            "Last-Modified",
            "Expires",
            "Cache-Control"
        ]
    },
    {
        "q": "Which HTTP status code indicates proxy authentication required?",
        "type": "mcq",
        "o": [
            "407",
            "401",
            "403",
            "511"
        ]
    },
    {
        "q": "What is the output of this header parsing code?",
        "type": "mcq",
        "c": "const contentType = 'application/json; charset=utf-8';\nconst type = contentType.split(';')[0].trim();\nconsole.log(type);",
        "o": [
            "application/json",
            "charset=utf-8",
            "application/json; charset=utf-8",
            "json"
        ]
    },
    {
        "q": "HTTP/2 uses binary framing instead of text-based protocol.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header indicates the source of a cross-origin request?",
        "type": "mcq",
        "o": [
            "Origin",
            "Referer",
            "Host",
            "From"
        ]
    },
    {
        "q": "Rearrange the TLS handshake steps:",
        "type": "rearrange",
        "words": [
            "Client Hello",
            "Server Hello",
            "Certificate",
            "Key Exchange",
            "Finished"
        ]
    },
    {
        "q": "The Pragma header is used for backward compatibility with ______.",
        "type": "fill_blank",
        "answers": [
            "HTTP/1.0"
        ],
        "other_options": [
            "HTTP/1.1",
            "HTTP/2",
            "HTTP/3"
        ]
    },
    {
        "q": "What HTTP status code indicates I'm a teapot (April Fools)?",
        "type": "mcq",
        "o": [
            "418",
            "400",
            "420",
            "451"
        ]
    },
    {
        "q": "Match URL encoding with special characters:",
        "type": "match",
        "left": [
            "%20",
            "%2F",
            "%3D",
            "%26"
        ],
        "right": [
            "Space",
            "Forward slash",
            "Equals sign",
            "Ampersand"
        ]
    },
    {
        "q": "Which header specifies credentials mode for CORS requests?",
        "type": "mcq",
        "o": [
            "Access-Control-Allow-Credentials",
            "Credentials",
            "Authorization",
            "Cookie"
        ]
    },
    {
        "q": "The DNT header indicates ______ preference.",
        "type": "fill_blank",
        "answers": [
            "Do-Not-Track"
        ],
        "other_options": [
            "Delete-Not-Transfer",
            "Data-No-Track",
            "Device-Network-Type"
        ]
    },
    {
        "q": "What is the output of this base URL construction?",
        "type": "mcq",
        "c": "const base = 'https://api.example.com';\nconst path = '/users';\nconst full = new URL(path, base);\nconsole.log(full.href);",
        "o": [
            "https://api.example.com/users",
            "/users",
            "api.example.com/users",
            "https://api.example.com"
        ]
    },
    {
        "q": "HTTP/2 server push allows servers to send resources proactively.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header prevents content from being embedded in frames?",
        "type": "mcq",
        "o": [
            "X-Frame-Options: DENY",
            "X-Frame-Options: ALLOW",
            "Frame-Control: none",
            "Content-Frame: deny"
        ]
    },
    {
        "q": "The Expect header is used to indicate ______ before sending body.",
        "type": "fill_blank",
        "answers": [
            "expectations"
        ],
        "other_options": [
            "requirements",
            "preferences",
            "conditions"
        ]
    },
    {
        "q": "What HTTP status code indicates unavailable for legal reasons?",
        "type": "mcq",
        "o": [
            "451",
            "403",
            "404",
            "410"
        ]
    },
    {
        "q": "Match Cache-Control directives with behavior:",
        "type": "match",
        "left": [
            "no-cache",
            "no-store",
            "public",
            "private"
        ],
        "right": [
            "Revalidate always",
            "Never cache",
            "Any cache allowed",
            "Browser only"
        ]
    },
    {
        "q": "Which header indicates when authentication expires?",
        "type": "mcq",
        "o": [
            "Authentication-Info",
            "Authorization-Expires",
            "Auth-Timeout",
            "Session-Expires"
        ]
    },
    {
        "q": "The Via header tracks message ______ through proxies.",
        "type": "fill_blank",
        "answers": [
            "forwarding"
        ],
        "other_options": [
            "caching",
            "encoding",
            "filtering"
        ]
    },
    {
        "q": "What is the output of this query parameter extraction?",
        "type": "mcq",
        "c": "const url = new URL('https://api.com?page=2&limit=10');\nconst params = url.searchParams;\nconsole.log(params.get('limit'));",
        "o": [
            "10",
            "2",
            "page=2&limit=10",
            "null"
        ]
    },
    {
        "q": "HTTP cookies are sent automatically with same-origin requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header controls script execution policy?",
        "type": "mcq",
        "o": [
            "Content-Security-Policy",
            "X-XSS-Protection",
            "Script-Policy",
            "Execution-Control"
        ]
    },
    {
        "q": "Rearrange the HTTP request lifecycle:",
        "type": "rearrange",
        "words": [
            "Build request",
            "Send to server",
            "Server processes",
            "Return response",
            "Parse response"
        ]
    },
    {
        "q": "The Set-Cookie header is used to send cookies from ______.",
        "type": "fill_blank",
        "answers": [
            "server"
        ],
        "other_options": [
            "client",
            "proxy",
            "cache"
        ]
    },
    {
        "q": "What HTTP status code indicates insufficient storage?",
        "type": "mcq",
        "o": [
            "507",
            "500",
            "503",
            "413"
        ]
    },
    {
        "q": "Match cookie attributes with their purposes:",
        "type": "match",
        "left": [
            "HttpOnly",
            "Secure",
            "SameSite",
            "Path"
        ],
        "right": [
            "No JavaScript access",
            "HTTPS only",
            "Cross-site control",
            "URL scope"
        ]
    },
    {
        "q": "Which header controls how long credentials are valid?",
        "type": "mcq",
        "o": [
            "Access-Control-Max-Age",
            "Credentials-Timeout",
            "Auth-Duration",
            "Session-Length"
        ]
    },
    {
        "q": "The Warning header provides additional ______ about messages.",
        "type": "fill_blank",
        "answers": [
            "information"
        ],
        "other_options": [
            "errors",
            "security",
            "encoding"
        ]
    },
    {
        "q": "What is the output of this status code categorization?",
        "type": "mcq",
        "c": "function getCategory(code) {\n    const categories = ['info', 'success', 'redirect', 'client-error', 'server-error'];\n    return categories[Math.floor(code / 100) - 1];\n}\nconsole.log(getCategory(503));",
        "o": [
            "server-error",
            "client-error",
            "redirect",
            "undefined"
        ]
    },
    {
        "q": "HTTP trailers are headers sent after the message body.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header specifies exposed headers for CORS?",
        "type": "mcq",
        "o": [
            "Access-Control-Expose-Headers",
            "Exposed-Headers",
            "CORS-Headers",
            "Visible-Headers"
        ]
    },
    {
        "q": "The TE header specifies acceptable transfer ______.",
        "type": "fill_blank",
        "answers": [
            "encodings"
        ],
        "other_options": [
            "types",
            "methods",
            "protocols"
        ]
    },
    {
        "q": "What HTTP status code indicates loop detected?",
        "type": "mcq",
        "o": [
            "508",
            "500",
            "504",
            "509"
        ]
    },
    {
        "q": "Match status codes with appropriate responses:",
        "type": "match",
        "left": [
            "201",
            "204",
            "301",
            "400"
        ],
        "right": [
            "Return new resource",
            "Return empty body",
            "Include Location header",
            "Return error details"
        ]
    },
    {
        "q": "Which header indicates request processing status?",
        "type": "mcq",
        "o": [
            "X-Request-ID",
            "Request-Status",
            "Processing-State",
            "Transaction-ID"
        ]
    },
    {
        "q": "The Trailer header lists headers sent in message ______.",
        "type": "fill_blank",
        "answers": [
            "trailers"
        ],
        "other_options": [
            "headers",
            "body",
            "metadata"
        ]
    },
    {
        "q": "What is the output of this endpoint construction?",
        "type": "mcq",
        "c": "const baseUrl = 'https://api.example.com/v1';\nconst resource = 'users';\nconst id = 123;\nconsole.log(`${baseUrl}/${resource}/${id}`);",
        "o": [
            "https://api.example.com/v1/users/123",
            "https://api.example.com/users/123",
            "api.example.com/v1/users/123",
            "/v1/users/123"
        ]
    },
    {
        "q": "HTTP/2 header compression uses HPACK algorithm.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header controls prefetching behavior?",
        "type": "mcq",
        "o": [
            "X-DNS-Prefetch-Control",
            "Prefetch-Control",
            "DNS-Control",
            "Cache-Prefetch"
        ]
    },
    {
        "q": "Rearrange these caching steps:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "Validate freshness",
            "Send conditional request",
            "Update cache"
        ]
    },
    {
        "q": "The Timing-Allow-Origin header controls ______ API access.",
        "type": "fill_blank",
        "answers": [
            "performance"
        ],
        "other_options": [
            "network",
            "resource",
            "timing"
        ]
    },
    {
        "q": "What HTTP status code indicates already reported?",
        "type": "mcq",
        "o": [
            "208",
            "200",
            "202",
            "204"
        ]
    },
    {
        "q": "Match request headers with their functions:",
        "type": "match",
        "left": [
            "Host",
            "User-Agent",
            "Accept",
            "Cookie"
        ],
        "right": [
            "Target server",
            "Client info",
            "Preferred format",
            "Session data"
        ]
    },
    {
        "q": "Which header specifies the range of bytes to return?",
        "type": "mcq",
        "o": [
            "Range",
            "Content-Range",
            "Byte-Range",
            "Partial-Content"
        ]
    },
    {
        "q": "The Accept-Ranges header indicates support for ______ requests.",
        "type": "fill_blank",
        "answers": [
            "partial"
        ],
        "other_options": [
            "full",
            "chunked",
            "compressed"
        ]
    },
    {
        "q": "What is the output of this header check?",
        "type": "mcq",
        "c": "const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n};\nconsole.log('Accept' in headers);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "HTTP/2 streams allow concurrent request/response exchange.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header indicates partial content response?",
        "type": "mcq",
        "o": [
            "Content-Range",
            "Range",
            "Partial-Content",
            "Byte-Range"
        ]
    },
    {
        "q": "The Feature-Policy header controls browser ______ access.",
        "type": "fill_blank",
        "answers": [
            "feature"
        ],
        "other_options": [
            "security",
            "network",
            "storage"
        ]
    },
    {
        "q": "What HTTP status code indicates partial content?",
        "type": "mcq",
        "o": [
            "206",
            "200",
            "204",
            "202"
        ]
    },
    {
        "q": "Match HTTP/2 concepts with descriptions:",
        "type": "match",
        "left": [
            "Streams",
            "Frames",
            "HPACK",
            "Server Push"
        ],
        "right": [
            "Logical connections",
            "Data units",
            "Header compression",
            "Proactive sending"
        ]
    },
    {
        "q": "Which header specifies acceptable character sets?",
        "type": "mcq",
        "o": [
            "Accept-Charset",
            "Content-Charset",
            "Charset",
            "Encoding-Type"
        ]
    },
    {
        "q": "The If-Range header enables conditional ______ requests.",
        "type": "fill_blank",
        "answers": [
            "range"
        ],
        "other_options": [
            "cache",
            "update",
            "delete"
        ]
    },
    {
        "q": "What is the output of this method checking code?",
        "type": "mcq",
        "c": "const idempotent = ['GET', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'];\nconst method = 'PATCH';\nconsole.log(idempotent.includes(method) ? 'Idempotent' : 'Not idempotent');",
        "o": [
            "Not idempotent",
            "Idempotent",
            "true",
            "false"
        ]
    },
    {
        "q": "HTTP response splitting is a security vulnerability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header controls download filename?",
        "type": "mcq",
        "o": [
            "Content-Disposition: attachment",
            "Download-Name",
            "File-Name",
            "Content-Filename"
        ]
    },
    {
        "q": "The NEL header enables network ______ logging.",
        "type": "fill_blank",
        "answers": [
            "error"
        ],
        "other_options": [
            "event",
            "endpoint",
            "exchange"
        ]
    },
    {
        "q": "What HTTP status code indicates multi-status response?",
        "type": "mcq",
        "o": [
            "207",
            "200",
            "202",
            "208"
        ]
    },
    {
        "q": "HEAD requests should return the same headers as GET.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of HTTP request idempotency?",
        "type": "mcq",
        "o": [
            "Same request can be safely repeated without side effects",
            "Request is processed faster",
            "Request is encrypted automatically",
            "Request is cached by default"
        ]
    },
    {
        "q": "Which header combination is needed for conditional GET requests?",
        "type": "mcq",
        "o": [
            "If-None-Match with ETag",
            "Accept with Content-Type",
            "Authorization with Cookie",
            "Cache-Control with Expires"
        ]
    },
    {
        "q": "The Link header is used to indicate ______ between resources.",
        "type": "fill_blank",
        "answers": [
            "relationships"
        ],
        "other_options": [
            "connections",
            "dependencies",
            "references"
        ]
    },
    {
        "q": "What is the output of this HTTP status validation?",
        "type": "mcq",
        "c": "function isSuccess(status) {\n    return status >= 200 && status < 300;\n}\nconst results = [200, 201, 204].map(isSuccess);\nconsole.log(results.every(r => r));",
        "o": [
            "true",
            "false",
            "[true, true, true]",
            "undefined"
        ]
    },
    {
        "q": "Match endpoint design patterns with examples:",
        "type": "match",
        "left": [
            "Collection",
            "Singleton",
            "Nested",
            "Action"
        ],
        "right": [
            "/users",
            "/users/123",
            "/users/123/orders",
            "/users/123/activate"
        ]
    },
    {
        "q": "Content negotiation allows servers to return different resource representations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which status code should be returned when a resource is successfully created?",
        "type": "mcq",
        "o": [
            "201 with Location header",
            "200 with body only",
            "204 with no content",
            "202 with processing"
        ]
    },
    {
        "q": "The Forwarded header standardizes proxy information instead of ______.",
        "type": "fill_blank",
        "answers": [
            "X-Forwarded"
        ],
        "other_options": [
            "Via",
            "Proxy",
            "Origin"
        ]
    },
    {
        "q": "What is the output of this URL manipulation?",
        "type": "mcq",
        "c": "const url = new URL('https://api.com/users');\nurl.searchParams.set('page', '1');\nurl.searchParams.set('limit', '10');\nconsole.log(url.search);",
        "o": [
            "?page=1&limit=10",
            "page=1&limit=10",
            "?page=1,limit=10",
            "{page:1,limit:10}"
        ]
    },
    {
        "q": "Which header indicates the preferred response language?",
        "type": "mcq",
        "o": [
            "Accept-Language with quality values",
            "Content-Language only",
            "Language-Preference",
            "Response-Language"
        ]
    },
    {
        "q": "Rearrange HTTP connection establishment steps:",
        "type": "rearrange",
        "words": [
            "DNS Resolution",
            "TCP Connect",
            "TLS Handshake",
            "HTTP Request",
            "HTTP Response"
        ]
    },
    {
        "q": "The Sec-Fetch-Mode header indicates the ______ of a fetch request.",
        "type": "fill_blank",
        "answers": [
            "mode"
        ],
        "other_options": [
            "type",
            "origin",
            "destination"
        ]
    },
    {
        "q": "What HTTP method should be used for long-running operations?",
        "type": "mcq",
        "o": [
            "POST returning 202 Accepted",
            "GET with polling",
            "PUT with timeout",
            "PATCH with retry"
        ]
    },
    {
        "q": "Match HTTP header categories:",
        "type": "match",
        "left": [
            "General",
            "Request",
            "Response",
            "Entity"
        ],
        "right": [
            "Apply to both",
            "Client to server",
            "Server to client",
            "Body metadata"
        ]
    },
    {
        "q": "HEAD method is useful for checking if a resource exists without downloading.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this endpoint builder?",
        "type": "mcq",
        "c": "class ApiClient {\n    constructor(base) { this.base = base; }\n    endpoint(path) { return `${this.base}${path}`; }\n}\nconst api = new ApiClient('https://api.com');\nconsole.log(api.endpoint('/users'));",
        "o": [
            "https://api.com/users",
            "/users",
            "api.com/users",
            "undefined"
        ]
    },
    {
        "q": "Which status code indicates that the request was received but not yet processed?",
        "type": "mcq",
        "o": [
            "202 Accepted",
            "200 OK",
            "201 Created",
            "204 No Content"
        ]
    },
    {
        "q": "The Clear-Site-Data header is used to clear browser ______.",
        "type": "fill_blank",
        "answers": [
            "storage"
        ],
        "other_options": [
            "cache",
            "cookies",
            "history"
        ]
    },
    {
        "q": "What is the correct response for a DELETE request on a non-existent resource?",
        "type": "mcq",
        "o": [
            "404 Not Found or 204 No Content (both acceptable)",
            "200 OK always",
            "500 Internal Server Error",
            "400 Bad Request"
        ]
    },
    {
        "q": "Match quality values with priorities:",
        "type": "match",
        "left": [
            "q=1.0",
            "q=0.9",
            "q=0.5",
            "q=0"
        ],
        "right": [
            "Highest priority",
            "High priority",
            "Medium priority",
            "Not acceptable"
        ]
    },
    {
        "q": "Rearrange the content negotiation process:",
        "type": "rearrange",
        "words": [
            "Client sends Accept",
            "Server checks support",
            "Server selects format",
            "Returns Content-Type"
        ]
    },
    {
        "q": "The Early-Hints status code allows servers to send ______.",
        "type": "fill_blank",
        "answers": [
            "preload hints"
        ],
        "other_options": [
            "error messages",
            "redirects",
            "authentication"
        ]
    },
    {
        "q": "What is the output of this request method validator?",
        "type": "mcq",
        "c": "const validMethods = new Set(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']);\nfunction isValid(method) {\n    return validMethods.has(method.toUpperCase());\n}\nconsole.log(isValid('get'));",
        "o": [
            "true",
            "false",
            "GET",
            "undefined"
        ]
    },
    {
        "q": "Which header is used to indicate no transformation should be applied?",
        "type": "mcq",
        "o": [
            "Cache-Control: no-transform",
            "Transform: none",
            "Content-Transform: disabled",
            "No-Transform: true"
        ]
    },
    {
        "q": "PATCH is meant for partial updates while PUT replaces the entire resource.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Alt-Svc header advertises alternative ______ for a resource.",
        "type": "fill_blank",
        "answers": [
            "services"
        ],
        "other_options": [
            "servers",
            "protocols",
            "endpoints"
        ]
    },
    {
        "q": "What is the output of this status code checker?",
        "type": "mcq",
        "c": "const statusCodes = {\n    200: 'OK',\n    201: 'Created',\n    404: 'Not Found'\n};\nconst getMessage = code => statusCodes[code] || 'Unknown';\nconsole.log(getMessage(500));",
        "o": [
            "Unknown",
            "OK",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Match HTTP authentication schemes:",
        "type": "match",
        "left": [
            "Basic",
            "Bearer",
            "Digest",
            "HOBA"
        ],
        "right": [
            "Base64 credentials",
            "Token-based",
            "Hashed credentials",
            "Channel binding"
        ]
    },
    {
        "q": "Which header prevents the response from being stored in any cache?",
        "type": "mcq",
        "o": [
            "Cache-Control: no-store",
            "Cache-Control: no-cache",
            "Pragma: no-cache",
            "Expires: 0"
        ]
    },
    {
        "q": "The Report-To header configures ______ endpoints.",
        "type": "fill_blank",
        "answers": [
            "reporting"
        ],
        "other_options": [
            "logging",
            "monitoring",
            "tracking"
        ]
    },
    {
        "q": "What is the purpose of the 103 Early Hints status code?",
        "type": "mcq",
        "o": [
            "Allow preloading resources before full response",
            "Indicate request continuation",
            "Signal protocol upgrade",
            "Report processing status"
        ]
    },
    {
        "q": "Rearrange REST API error handling steps:",
        "type": "rearrange",
        "words": [
            "Catch exception",
            "Log error",
            "Format response",
            "Set status code",
            "Return error"
        ]
    },
    {
        "q": "OPTIONS preflight requests are required for cross-origin ______ requests.",
        "type": "fill_blank",
        "answers": [
            "non-simple"
        ],
        "other_options": [
            "simple",
            "cached",
            "authenticated"
        ]
    },
    {
        "q": "What is the output of this header parser?",
        "type": "mcq",
        "c": "const acceptHeader = 'text/html, application/json;q=0.9, */*;q=0.8';\nconst preferred = acceptHeader.split(',')[0].trim();\nconsole.log(preferred);",
        "o": [
            "text/html",
            "application/json",
            "*/*",
            "text/html, application/json"
        ]
    },
    {
        "q": "Which status code should be returned for validation errors?",
        "type": "mcq",
        "o": [
            "422 Unprocessable Entity",
            "400 Bad Request",
            "404 Not Found",
            "500 Internal Server Error"
        ]
    },
    {
        "q": "Match proxy header types:",
        "type": "match",
        "left": [
            "X-Forwarded-For",
            "X-Forwarded-Proto",
            "X-Forwarded-Host",
            "X-Real-IP"
        ],
        "right": [
            "Client IP chain",
            "Original protocol",
            "Original host",
            "Single client IP"
        ]
    },
    {
        "q": "The Last-Event-ID header is used with Server-Sent ______.",
        "type": "fill_blank",
        "answers": [
            "Events"
        ],
        "other_options": [
            "Streams",
            "Pushes",
            "Updates"
        ]
    },
    {
        "q": "HTTP/2 priority allows clients to indicate resource importance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this fetch configuration?",
        "type": "mcq",
        "c": "const config = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name: 'test' })\n};\nconsole.log(config.headers['Content-Type']);",
        "o": [
            "application/json",
            "text/plain",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which header indicates the size of the request body in advance?",
        "type": "mcq",
        "o": [
            "Content-Length",
            "Transfer-Encoding",
            "Content-Size",
            "Body-Length"
        ]
    },
    {
        "q": "The Public-Key-Pins header is deprecated due to security ______.",
        "type": "fill_blank",
        "answers": [
            "risks"
        ],
        "other_options": [
            "updates",
            "improvements",
            "standards"
        ]
    },
    {
        "q": "What is the correct way to handle rate limiting responses?",
        "type": "mcq",
        "o": [
            "Check Retry-After header and wait",
            "Immediately retry the request",
            "Switch to a different endpoint",
            "Ignore and continue"
        ]
    },
    {
        "q": "Match response body formats with Content-Types:",
        "type": "match",
        "left": [
            "JSON",
            "XML",
            "Form data",
            "Plain text"
        ],
        "right": [
            "application/json",
            "application/xml",
            "application/x-www-form-urlencoded",
            "text/plain"
        ]
    },
    {
        "q": "Rearrange API request validation steps:",
        "type": "rearrange",
        "words": [
            "Parse request",
            "Validate headers",
            "Authenticate",
            "Authorize",
            "Process"
        ]
    },
    {
        "q": "The Device-Memory header provides client device ______ information.",
        "type": "fill_blank",
        "answers": [
            "memory"
        ],
        "other_options": [
            "storage",
            "processor",
            "screen"
        ]
    },
    {
        "q": "What is the output of this content-type check?",
        "type": "mcq",
        "c": "const contentType = 'application/json; charset=utf-8';\nconst isJson = contentType.includes('application/json');\nconsole.log(isJson);",
        "o": [
            "true",
            "false",
            "application/json",
            "undefined"
        ]
    },
    {
        "q": "Which status code indicates the server understood but refuses to authorize?",
        "type": "mcq",
        "o": [
            "403 Forbidden",
            "401 Unauthorized",
            "407 Proxy Auth Required",
            "423 Locked"
        ]
    },
    {
        "q": "The Sec-CH-UA headers provide user agent client ______ information.",
        "type": "fill_blank",
        "answers": [
            "hints"
        ],
        "other_options": [
            "details",
            "data",
            "metadata"
        ]
    },
    {
        "q": "HTTP/3 uses connection-less transport at the QUIC layer.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "Match HTTP method safety properties:",
        "type": "match",
        "left": [
            "Safe",
            "Idempotent",
            "Cacheable",
            "Body allowed"
        ],
        "right": [
            "GET HEAD OPTIONS",
            "GET PUT DELETE",
            "GET HEAD",
            "POST PUT PATCH"
        ]
    },
    {
        "q": "What is the output of this endpoint matcher?",
        "type": "mcq",
        "c": "const path = '/api/v1/users/123/orders';\nconst regex = /\\/users\\/(\\d+)/;\nconst match = path.match(regex);\nconsole.log(match ? match[1] : null);",
        "o": [
            "123",
            "/users/123",
            "users",
            "null"
        ]
    },
    {
        "q": "Which header is used for WebSocket upgrade requests?",
        "type": "mcq",
        "o": [
            "Upgrade: websocket",
            "Connection: WebSocket",
            "Protocol: ws",
            "WebSocket: upgrade"
        ]
    },
    {
        "q": "The ECT header provides effective connection ______ information.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "speed",
            "quality",
            "status"
        ]
    },
    {
        "q": "A 301 redirect should use GET for the redirected request regardless of original method.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this query builder?",
        "type": "mcq",
        "c": "function buildQuery(params) {\n    return Object.entries(params)\n        .map(([k, v]) => `${k}=${encodeURIComponent(v)}`)\n        .join('&');\n}\nconsole.log(buildQuery({name: 'John Doe', age: 30}));",
        "o": [
            "name=John%20Doe&age=30",
            "name=John Doe&age=30",
            "{name:John Doe,age:30}",
            "name:John Doe,age:30"
        ]
    },
    {
        "q": "Match HTTP redirect codes with their semantics:",
        "type": "match",
        "left": [
            "301",
            "302",
            "307",
            "308"
        ],
        "right": [
            "Permanent GET",
            "Temporary GET",
            "Temporary same method",
            "Permanent same method"
        ]
    },
    {
        "q": "Which header controls resource timing buffer size?",
        "type": "mcq",
        "o": [
            "Timing-Allow-Origin",
            "Resource-Timing",
            "Buffer-Size",
            "Performance-Timing"
        ]
    },
    {
        "q": "The RTT header provides round-trip ______ estimates.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "rate",
            "traffic",
            "throughput"
        ]
    },
    {
        "q": "What is the purpose of the 100 Continue status?",
        "type": "mcq",
        "o": [
            "Allow client to send body after server confirms acceptance",
            "Indicate request is processing",
            "Signal protocol upgrade",
            "Report caching status"
        ]
    },
    {
        "q": "Rearrange conditional request handling:",
        "type": "rearrange",
        "words": [
            "Check ETag",
            "Compare values",
            "Return 304",
            "Or send full response"
        ]
    },
    {
        "q": "The Downlink header provides download bandwidth ______.",
        "type": "fill_blank",
        "answers": [
            "estimate"
        ],
        "other_options": [
            "limit",
            "maximum",
            "minimum"
        ]
    },
    {
        "q": "What is the output of this HTTP version check?",
        "type": "mcq",
        "c": "const versions = ['HTTP/1.0', 'HTTP/1.1', 'HTTP/2', 'HTTP/3'];\nconst modern = versions.filter(v => !v.includes('1.'));\nconsole.log(modern.length);",
        "o": [
            "2",
            "4",
            "1",
            "3"
        ]
    },
    {
        "q": "Which header indicates supported compression algorithms?",
        "type": "mcq",
        "o": [
            "Accept-Encoding",
            "Content-Encoding",
            "Compression",
            "Encode-Type"
        ]
    },
    {
        "q": "Match HTTP cache validators:",
        "type": "match",
        "left": [
            "ETag",
            "Last-Modified",
            "If-None-Match",
            "If-Modified-Since"
        ],
        "right": [
            "Strong validator",
            "Weak validator",
            "ETag condition",
            "Date condition"
        ]
    },
    {
        "q": "The Save-Data header indicates user preference for reduced data ______.",
        "type": "fill_blank",
        "answers": [
            "usage"
        ],
        "other_options": [
            "transfer",
            "storage",
            "processing"
        ]
    },
    {
        "q": "An ETag value starting with W/ indicates a weak validator.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this cache control parser?",
        "type": "mcq",
        "c": "const cacheControl = 'max-age=3600, public, no-transform';\nconst directives = cacheControl.split(',').map(d => d.trim());\nconsole.log(directives.includes('public'));",
        "o": [
            "true",
            "false",
            "public",
            "undefined"
        ]
    },
    {
        "q": "Which status code should be returned when a resource is locked?",
        "type": "mcq",
        "o": [
            "423 Locked",
            "403 Forbidden",
            "409 Conflict",
            "503 Service Unavailable"
        ]
    },
    {
        "q": "The Width header provides screen width for responsive ______.",
        "type": "fill_blank",
        "answers": [
            "images"
        ],
        "other_options": [
            "layouts",
            "videos",
            "fonts"
        ]
    },
    {
        "q": "What is the correct handling of a 307 redirect?",
        "type": "mcq",
        "o": [
            "Redirect using the same method and body",
            "Convert to GET request",
            "Retry the original endpoint",
            "Cancel the request"
        ]
    },
    {
        "q": "Match URI components with their functions:",
        "type": "match",
        "left": [
            "Scheme",
            "Authority",
            "Path",
            "Fragment"
        ],
        "right": [
            "Protocol type",
            "Host and port",
            "Resource location",
            "Section reference"
        ]
    },
    {
        "q": "Rearrange the API response lifecycle:",
        "type": "rearrange",
        "words": [
            "Process request",
            "Build response",
            "Set headers",
            "Serialize body",
            "Send response"
        ]
    },
    {
        "q": "The DPR header provides device pixel ______.",
        "type": "fill_blank",
        "answers": [
            "ratio"
        ],
        "other_options": [
            "resolution",
            "density",
            "rate"
        ]
    },
    {
        "q": "What is the output of this method override check?",
        "type": "mcq",
        "c": "const headers = {\n    'X-HTTP-Method-Override': 'PUT',\n    'Content-Type': 'application/json'\n};\nconst method = headers['X-HTTP-Method-Override'] || 'POST';\nconsole.log(method);",
        "o": [
            "PUT",
            "POST",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which header is deprecated in favor of Permissions-Policy?",
        "type": "mcq",
        "o": [
            "Feature-Policy",
            "Content-Security-Policy",
            "X-Frame-Options",
            "Referrer-Policy"
        ]
    },
    {
        "q": "The Large-Allocation header optimizes memory for large ______.",
        "type": "fill_blank",
        "answers": [
            "allocations"
        ],
        "other_options": [
            "downloads",
            "uploads",
            "transfers"
        ]
    },
    {
        "q": "HTTP 451 status code references Fahrenheit 451 censorship theme.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this response builder?",
        "type": "mcq",
        "c": "function buildResponse(data, status = 200) {\n    return {\n        status,\n        body: JSON.stringify(data),\n        contentType: 'application/json'\n    };\n}\nconst res = buildResponse({id: 1}, 201);\nconsole.log(res.status);",
        "o": [
            "201",
            "200",
            "undefined",
            "{id: 1}"
        ]
    },
    {
        "q": "Match HTTP method characteristics:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "PATCH"
        ],
        "right": [
            "Read operation",
            "Create operation",
            "Full update",
            "Partial update"
        ]
    },
    {
        "q": "Which header specifies the origin server software version?",
        "type": "mcq",
        "o": [
            "Server",
            "X-Powered-By",
            "Via",
            "Software-Version"
        ]
    },
    {
        "q": "The Content-DPR header indicates image display ______ ratio.",
        "type": "fill_blank",
        "answers": [
            "pixel"
        ],
        "other_options": [
            "density",
            "resolution",
            "size"
        ]
    },
    {
        "q": "What is the correct response for a successful PUT creating a new resource?",
        "type": "mcq",
        "o": [
            "201 Created with resource body",
            "200 OK only",
            "204 No Content",
            "202 Accepted"
        ]
    },
    {
        "q": "POST requests can be cached if Cache-Control headers allow.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this endpoint sanitizer?",
        "type": "mcq",
        "c": "function sanitizeEndpoint(path) {\n    return path.replace(/\\/+/g, '/').replace(/\\/$/, '');\n}\nconsole.log(sanitizeEndpoint('//api//users/'));",
        "o": [
            "/api/users",
            "//api//users/",
            "/api/users/",
            "api/users"
        ]
    },
    {
        "q": "Match Accept header quality values:",
        "type": "match",
        "left": [
            "application/json",
            "text/html;q=0.9",
            "text/plain;q=0.5",
            "*/*;q=0.1"
        ],
        "right": [
            "Default q=1",
            "High priority",
            "Medium priority",
            "Low priority"
        ]
    },
    {
        "q": "Which header indicates the timezone preference?",
        "type": "mcq",
        "o": [
            "Sec-CH-UA-Platform",
            "Timezone",
            "Time-Zone",
            "Accept-Timezone"
        ]
    },
    {
        "q": "The Viewport-Width header provides client viewport ______.",
        "type": "fill_blank",
        "answers": [
            "width"
        ],
        "other_options": [
            "height",
            "size",
            "ratio"
        ]
    },
    {
        "q": "A 204 No Content response should never include a message body.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct implementation of request timeout handling?",
        "type": "mcq",
        "c": "const controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 5000);\nfetch('/api/data', { signal: controller.signal })\n    .finally(() => clearTimeout(timeout));",
        "o": [
            "Aborts request after 5 seconds using AbortController",
            "Retries request every 5 seconds",
            "Caches response for 5 seconds",
            "Delays request by 5 seconds"
        ]
    },
    {
        "q": "Which HTTP header combination provides optimal security for APIs?",
        "type": "mcq",
        "o": [
            "Strict-Transport-Security, Content-Security-Policy, X-Content-Type-Options",
            "Cache-Control, Expires, Pragma",
            "Accept, Content-Type, Authorization",
            "Host, Origin, Referer"
        ]
    },
    {
        "q": "The Cross-Origin-Opener-Policy header controls shared ______ between origins.",
        "type": "fill_blank",
        "answers": [
            "browsing context"
        ],
        "other_options": [
            "cookies",
            "storage",
            "cache"
        ]
    },
    {
        "q": "Match advanced caching strategies:",
        "type": "match",
        "left": [
            "stale-while-revalidate",
            "stale-if-error",
            "must-revalidate",
            "immutable"
        ],
        "right": [
            "Serve stale then update",
            "Serve stale on error",
            "Always validate expired",
            "Never revalidate"
        ]
    },
    {
        "q": "What is the output of this retry logic?",
        "type": "mcq",
        "c": "async function fetchWithRetry(url, retries = 3) {\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await fetch(url);\n        } catch (e) {\n            if (i === retries - 1) throw e;\n        }\n    }\n}\n// Returns after first successful attempt or throws after exhausting retries",
        "o": [
            "Retries up to 3 times before throwing",
            "Always retries exactly 3 times",
            "Never retries on failure",
            "Retries infinitely"
        ]
    },
    {
        "q": "HTTP/2 flow control operates on both stream and connection levels.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach is best for handling large file uploads via HTTP?",
        "type": "mcq",
        "o": [
            "Chunked upload with resumable progress tracking",
            "Single POST with unlimited timeout",
            "Base64 encoding in JSON body",
            "Multiple GET requests"
        ]
    },
    {
        "q": "The Cross-Origin-Embedder-Policy header requires resources to grant ______.",
        "type": "fill_blank",
        "answers": [
            "permission"
        ],
        "other_options": [
            "access",
            "authorization",
            "consent"
        ]
    },
    {
        "q": "What is the output of this response interceptor?",
        "type": "mcq",
        "c": "class ResponseInterceptor {\n    intercept(response) {\n        if (response.status === 401) {\n            return this.refreshToken().then(() => this.retry(response));\n        }\n        return response;\n    }\n}",
        "o": [
            "Automatically refreshes token on 401 and retries",
            "Throws error on 401",
            "Returns null on 401",
            "Ignores 401 status"
        ]
    },
    {
        "q": "Match HTTP connection pooling benefits:",
        "type": "match",
        "left": [
            "Reduced latency",
            "Lower resource usage",
            "Improved throughput",
            "Better scalability"
        ],
        "right": [
            "Reuse TCP connections",
            "Fewer socket handles",
            "More concurrent requests",
            "Handle more clients"
        ]
    },
    {
        "q": "Rearrange the request signing process:",
        "type": "rearrange",
        "words": [
            "Canonicalize request",
            "Create signature",
            "Add timestamp",
            "Include in header",
            "Verify server-side"
        ]
    },
    {
        "q": "The Cross-Origin-Resource-Policy header controls cross-origin ______ loading.",
        "type": "fill_blank",
        "answers": [
            "resource"
        ],
        "other_options": [
            "script",
            "style",
            "frame"
        ]
    },
    {
        "q": "What is the primary difference between HTTP/2 and HTTP/3?",
        "type": "mcq",
        "o": [
            "HTTP/3 uses QUIC over UDP instead of TCP",
            "HTTP/3 removes multiplexing",
            "HTTP/3 uses text protocol",
            "HTTP/3 removes header compression"
        ]
    },
    {
        "q": "What is the output of this connection manager?",
        "type": "mcq",
        "c": "class ConnectionPool {\n    constructor(maxConn = 6) {\n        this.pool = new Map();\n        this.max = maxConn;\n    }\n    canOpen(host) {\n        return (this.pool.get(host) || 0) < this.max;\n    }\n}\nconst pool = new ConnectionPool();\nconsole.log(pool.canOpen('api.example.com'));",
        "o": [
            "true",
            "false",
            "6",
            "undefined"
        ]
    },
    {
        "q": "HTTP/2 GOAWAY frame is used for graceful connection ______.",
        "type": "fill_blank",
        "answers": [
            "shutdown"
        ],
        "other_options": [
            "reset",
            "pause",
            "upgrade"
        ]
    },
    {
        "q": "Which status code indicates a payload that's too large for the server?",
        "type": "mcq",
        "o": [
            "413 Payload Too Large",
            "400 Bad Request",
            "414 URI Too Long",
            "431 Request Header Fields Too Large"
        ]
    },
    {
        "q": "Match HTTP/2 frame types:",
        "type": "match",
        "left": [
            "DATA",
            "HEADERS",
            "SETTINGS",
            "PING"
        ],
        "right": [
            "Body content",
            "Request metadata",
            "Connection config",
            "Keep-alive check"
        ]
    },
    {
        "q": "Server-Sent Events use persistent HTTP connections for one-way streaming.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this header merger?",
        "type": "mcq",
        "c": "function mergeHeaders(base, custom) {\n    return { ...base, ...custom };\n}\nconst merged = mergeHeaders(\n    { 'Content-Type': 'text/plain' },\n    { 'Content-Type': 'application/json' }\n);\nconsole.log(merged['Content-Type']);",
        "o": [
            "application/json",
            "text/plain",
            "undefined",
            "null"
        ]
    },
    {
        "q": "The SourceMap header points to debugging ______ files.",
        "type": "fill_blank",
        "answers": [
            "source map"
        ],
        "other_options": [
            "error log",
            "stack trace",
            "breakpoint"
        ]
    },
    {
        "q": "Which approach handles API versioning through HTTP headers?",
        "type": "mcq",
        "o": [
            "Accept: application/vnd.api.v2+json",
            "GET /api/v2/users",
            "GET /users?version=2",
            "POST with X-Version header only"
        ]
    },
    {
        "q": "Rearrange the API gateway request flow:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Authenticate",
            "Rate limit",
            "Route",
            "Forward to service"
        ]
    },
    {
        "q": "The X-Request-Start header records request ______ time.",
        "type": "fill_blank",
        "answers": [
            "start"
        ],
        "other_options": [
            "end",
            "duration",
            "timeout"
        ]
    },
    {
        "q": "What is the output of this circuit breaker pattern?",
        "type": "mcq",
        "c": "class CircuitBreaker {\n    constructor(threshold = 5) {\n        this.failures = 0;\n        this.threshold = threshold;\n        this.state = 'CLOSED';\n    }\n    recordFailure() {\n        this.failures++;\n        if (this.failures >= this.threshold) this.state = 'OPEN';\n    }\n}\nconst cb = new CircuitBreaker(3);\ncb.recordFailure();\ncb.recordFailure();\ncb.recordFailure();\nconsole.log(cb.state);",
        "o": [
            "OPEN",
            "CLOSED",
            "HALF_OPEN",
            "undefined"
        ]
    },
    {
        "q": "Match API authentication patterns:",
        "type": "match",
        "left": [
            "API Key",
            "OAuth 2.0",
            "JWT",
            "mTLS"
        ],
        "right": [
            "Simple header token",
            "Delegated access",
            "Self-contained token",
            "Certificate-based"
        ]
    },
    {
        "q": "HTTP trailers are only usable with chunked transfer encoding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header indicates the real client IP behind a proxy?",
        "type": "mcq",
        "o": [
            "X-Forwarded-For or Forwarded",
            "Client-IP only",
            "Origin",
            "Host"
        ]
    },
    {
        "q": "The Digest header provides integrity verification of message ______.",
        "type": "fill_blank",
        "answers": [
            "body"
        ],
        "other_options": [
            "headers",
            "method",
            "path"
        ]
    },
    {
        "q": "What is the output of this rate limit tracker?",
        "type": "mcq",
        "c": "class RateLimiter {\n    constructor(limit, window) {\n        this.tokens = limit;\n        this.limit = limit;\n        this.window = window;\n    }\n    consume() {\n        if (this.tokens > 0) {\n            this.tokens--;\n            return true;\n        }\n        return false;\n    }\n}\nconst limiter = new RateLimiter(2, 1000);\nconsole.log(limiter.consume() && limiter.consume() && limiter.consume());",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Match HTTP compression algorithms:",
        "type": "match",
        "left": [
            "gzip",
            "br",
            "deflate",
            "zstd"
        ],
        "right": [
            "LZ77 + Huffman",
            "Brotli",
            "Raw DEFLATE",
            "Zstandard"
        ]
    },
    {
        "q": "Rearrange the CORS preflight sequence:",
        "type": "rearrange",
        "words": [
            "Client sends OPTIONS",
            "Server validates origin",
            "Returns allowed headers",
            "Client sends actual request"
        ]
    },
    {
        "q": "The Want-Digest header requests the server to provide a message ______.",
        "type": "fill_blank",
        "answers": [
            "digest"
        ],
        "other_options": [
            "signature",
            "hash",
            "checksum"
        ]
    },
    {
        "q": "Which strategy handles partial network failures gracefully?",
        "type": "mcq",
        "o": [
            "Exponential backoff with jitter",
            "Immediate retry in tight loop",
            "Single retry after fixed delay",
            "No retry mechanism"
        ]
    },
    {
        "q": "What is the output of this exponential backoff?",
        "type": "mcq",
        "c": "function calculateBackoff(attempt, base = 1000) {\n    const exp = Math.pow(2, attempt);\n    const jitter = Math.random() * 1000;\n    return Math.min(exp * base + jitter, 30000);\n}\n// For attempt 3: 2^3 * 1000 + jitter = 8000 + jitter (max 30000)",
        "o": [
            "Between 8000 and 9000 ms for attempt 3",
            "Exactly 8000 ms",
            "Always 30000 ms",
            "Random value only"
        ]
    },
    {
        "q": "Match request deduplication strategies:",
        "type": "match",
        "left": [
            "Idempotency key",
            "Request hash",
            "Timestamp window",
            "Sequence number"
        ],
        "right": [
            "Client-provided ID",
            "Content fingerprint",
            "Time-based filter",
            "Order-based filter"
        ]
    },
    {
        "q": "HTTP/2 RST_STREAM allows canceling individual requests without closing connection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Accept-Post header advertises supported media types for ______.",
        "type": "fill_blank",
        "answers": [
            "POST requests"
        ],
        "other_options": [
            "GET requests",
            "responses",
            "uploads"
        ]
    },
    {
        "q": "What is the output of this idempotency handler?",
        "type": "mcq",
        "c": "const processed = new Map();\nfunction handleRequest(idempotencyKey, handler) {\n    if (processed.has(idempotencyKey)) {\n        return processed.get(idempotencyKey);\n    }\n    const result = handler();\n    processed.set(idempotencyKey, result);\n    return result;\n}\nconst r1 = handleRequest('key1', () => 'first');\nconst r2 = handleRequest('key1', () => 'second');\nconsole.log(r2);",
        "o": [
            "first",
            "second",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which header indicates accepted HTTP methods for PATCH operations?",
        "type": "mcq",
        "o": [
            "Accept-Patch",
            "Allow-Patch",
            "Patch-Methods",
            "Content-Patch"
        ]
    },
    {
        "q": "Rearrange the request validation pipeline:",
        "type": "rearrange",
        "words": [
            "Parse body",
            "Validate schema",
            "Sanitize input",
            "Check business rules",
            "Execute handler"
        ]
    },
    {
        "q": "The Accept-CH header is used for Client ______ negotiation.",
        "type": "fill_blank",
        "answers": [
            "Hints"
        ],
        "other_options": [
            "Headers",
            "Cache",
            "Credentials"
        ]
    },
    {
        "q": "What is the output of this request coalescing?",
        "type": "mcq",
        "c": "const pending = new Map();\nasync function coalesceRequest(key, fetcher) {\n    if (pending.has(key)) return pending.get(key);\n    const promise = fetcher().finally(() => pending.delete(key));\n    pending.set(key, promise);\n    return promise;\n}\n// Multiple calls with same key return same promise",
        "o": [
            "Deduplicates concurrent identical requests",
            "Queues all requests sequentially",
            "Caches responses permanently",
            "Rejects duplicate requests"
        ]
    },
    {
        "q": "Match HTTP streaming patterns:",
        "type": "match",
        "left": [
            "SSE",
            "WebSocket",
            "Long polling",
            "HTTP/2 streaming"
        ],
        "right": [
            "Server-push text",
            "Bidirectional binary",
            "Request-per-update",
            "Multiplexed binary"
        ]
    },
    {
        "q": "The Sunset header announces when an API will be deprecated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which header provides a machine-readable deprecation notice?",
        "type": "mcq",
        "o": [
            "Deprecation",
            "X-Deprecated",
            "API-Deprecation",
            "Notice"
        ]
    },
    {
        "q": "The Accept-Profile header requests specific API ______.",
        "type": "fill_blank",
        "answers": [
            "profiles"
        ],
        "other_options": [
            "versions",
            "formats",
            "schemas"
        ]
    },
    {
        "q": "What is the output of this request logging middleware?",
        "type": "mcq",
        "c": "function logMiddleware(handler) {\n    return async (req) => {\n        const start = Date.now();\n        const res = await handler(req);\n        const duration = Date.now() - start;\n        console.log(`${req.method} ${req.url} - ${duration}ms`);\n        return res;\n    };\n}",
        "o": [
            "Logs method URL and duration after response",
            "Logs only on errors",
            "Logs before request only",
            "Modifies response headers"
        ]
    },
    {
        "q": "Match HTTP status codes with retry behavior:",
        "type": "match",
        "left": [
            "429",
            "503",
            "500",
            "400"
        ],
        "right": [
            "Retry after delay",
            "Retry with backoff",
            "May retry carefully",
            "Do not retry"
        ]
    },
    {
        "q": "Rearrange the graceful degradation steps:",
        "type": "rearrange",
        "words": [
            "Detect failure",
            "Fallback to cache",
            "Serve partial data",
            "Log incident",
            "Notify monitoring"
        ]
    },
    {
        "q": "The Prefer header allows clients to express processing ______.",
        "type": "fill_blank",
        "answers": [
            "preferences"
        ],
        "other_options": [
            "requirements",
            "constraints",
            "demands"
        ]
    },
    {
        "q": "What is the output of this timeout wrapper?",
        "type": "mcq",
        "c": "function withTimeout(promise, ms) {\n    const timeout = new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Timeout')), ms)\n    );\n    return Promise.race([promise, timeout]);\n}\n// Rejects if promise doesn't resolve within ms",
        "o": [
            "Races promise against timeout, rejects on timeout",
            "Always waits for promise completion",
            "Ignores the timeout",
            "Retries on timeout"
        ]
    },
    {
        "q": "Which status code indicates the client should look elsewhere for resource?",
        "type": "mcq",
        "o": [
            "303 See Other",
            "301 Moved Permanently",
            "302 Found",
            "307 Temporary Redirect"
        ]
    },
    {
        "q": "Match HTTP caching headers with their scope:",
        "type": "match",
        "left": [
            "Cache-Control",
            "ETag",
            "Vary",
            "CDN-Cache-Control"
        ],
        "right": [
            "All caches",
            "Validation token",
            "Response variation",
            "CDN only"
        ]
    },
    {
        "q": "The Preference-Applied header confirms honored client preferences.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Repr-Digest header provides digest of the ______ representation.",
        "type": "fill_blank",
        "answers": [
            "selected"
        ],
        "other_options": [
            "original",
            "cached",
            "compressed"
        ]
    },
    {
        "q": "What is the output of this request batching logic?",
        "type": "mcq",
        "c": "class RequestBatcher {\n    constructor(delay = 50) {\n        this.queue = [];\n        this.delay = delay;\n        this.timer = null;\n    }\n    add(req) {\n        this.queue.push(req);\n        if (!this.timer) {\n            this.timer = setTimeout(() => this.flush(), this.delay);\n        }\n    }\n    flush() {\n        const batch = [...this.queue];\n        this.queue = [];\n        this.timer = null;\n        return batch;\n    }\n}",
        "o": [
            "Batches requests within 50ms window",
            "Sends requests immediately",
            "Queues indefinitely",
            "Sends one at a time"
        ]
    },
    {
        "q": "Which header allows specifying expected response time?",
        "type": "mcq",
        "o": [
            "Prefer: respond-async",
            "Response-Time",
            "Expect-Time",
            "Timeout-Hint"
        ]
    },
    {
        "q": "Match request priority hints:",
        "type": "match",
        "left": [
            "high",
            "low",
            "auto",
            ""
        ],
        "right": [
            "Critical resources",
            "Background loads",
            "Browser decides",
            "Default priority"
        ]
    },
    {
        "q": "Rearrange the WebSocket upgrade process:",
        "type": "rearrange",
        "words": [
            "Send upgrade request",
            "Server accepts",
            "Protocol switch",
            "Bidirectional frames"
        ]
    },
    {
        "q": "The Priority header uses Extensible ______ notation.",
        "type": "fill_blank",
        "answers": [
            "Priorities"
        ],
        "other_options": [
            "Parameters",
            "Properties",
            "Preferences"
        ]
    },
    {
        "q": "What is the output of this health check endpoint?",
        "type": "mcq",
        "c": "async function healthCheck() {\n    const checks = [\n        checkDatabase().catch(() => 'db:unhealthy'),\n        checkCache().catch(() => 'cache:unhealthy')\n    ];\n    const results = await Promise.all(checks);\n    const healthy = results.every(r => !r.includes('unhealthy'));\n    return { status: healthy ? 'ok' : 'degraded', checks: results };\n}",
        "o": [
            "Returns ok if all checks pass, degraded otherwise",
            "Throws on any failure",
            "Always returns ok",
            "Returns individual check results only"
        ]
    },
    {
        "q": "Match HTTP/2 settings parameters:",
        "type": "match",
        "left": [
            "HEADER_TABLE_SIZE",
            "MAX_CONCURRENT_STREAMS",
            "INITIAL_WINDOW_SIZE",
            "MAX_FRAME_SIZE"
        ],
        "right": [
            "HPACK table limit",
            "Stream limit",
            "Flow control",
            "Frame limit"
        ]
    },
    {
        "q": "HTTP/3 eliminates head-of-line blocking at the transport layer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Content-Digest header provides digest of the HTTP content, post-encoding.",
        "type": "fill_blank",
        "answers": [
            "message content"
        ],
        "other_options": [
            "request body",
            "response headers",
            "URL path"
        ]
    },
    {
        "q": "What is the output of this request deduplication?",
        "type": "mcq",
        "c": "const inFlight = new Map();\nasync function dedupe(key, fn) {\n    if (inFlight.has(key)) {\n        return inFlight.get(key);\n    }\n    const result = fn();\n    inFlight.set(key, result);\n    try {\n        return await result;\n    } finally {\n        inFlight.delete(key);\n    }\n}",
        "o": [
            "Shares single promise for concurrent identical requests",
            "Queues requests sequentially",
            "Rejects duplicates with error",
            "Caches results permanently"
        ]
    },
    {
        "q": "Which approach ensures exactly-once delivery semantics?",
        "type": "mcq",
        "o": [
            "Idempotency keys with server-side deduplication",
            "Retry with exponential backoff only",
            "Fire and forget pattern",
            "Best-effort delivery"
        ]
    },
    {
        "q": "Match content negotiation headers:",
        "type": "match",
        "left": [
            "Accept",
            "Accept-Language",
            "Accept-Encoding",
            "Accept-Charset"
        ],
        "right": [
            "Media type",
            "Locale",
            "Compression",
            "Character set"
        ]
    },
    {
        "q": "Rearrange the request lifecycle with middleware:",
        "type": "rearrange",
        "words": [
            "Pre-middleware",
            "Route matching",
            "Handler execution",
            "Post-middleware",
            "Response sent"
        ]
    },
    {
        "q": "The Accept-Signature header requests HTTP message ______.",
        "type": "fill_blank",
        "answers": [
            "signatures"
        ],
        "other_options": [
            "encryption",
            "verification",
            "certification"
        ]
    },
    {
        "q": "What is the output of this cache invalidation?",
        "type": "mcq",
        "c": "class CacheManager {\n    constructor() {\n        this.cache = new Map();\n        this.subscriptions = new Map();\n    }\n    invalidate(pattern) {\n        let count = 0;\n        for (const key of this.cache.keys()) {\n            if (key.startsWith(pattern)) {\n                this.cache.delete(key);\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "o": [
            "Deletes all keys matching pattern prefix",
            "Deletes only exact matches",
            "Clears entire cache",
            "Marks entries as stale"
        ]
    },
    {
        "q": "Which status code is appropriate for a soft-deleted resource?",
        "type": "mcq",
        "o": [
            "410 Gone or 404 Not Found depending on policy",
            "200 OK always",
            "204 No Content",
            "301 Moved Permanently"
        ]
    },
    {
        "q": "Match HTTP security mechanisms:",
        "type": "match",
        "left": [
            "HSTS",
            "CSP",
            "CORS",
            "SRI"
        ],
        "right": [
            "Force HTTPS",
            "Script sources",
            "Cross-origin access",
            "Resource integrity"
        ]
    },
    {
        "q": "The Signature header contains HTTP message cryptographic signatures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Signature-Input header describes signature component ______.",
        "type": "fill_blank",
        "answers": [
            "inputs"
        ],
        "other_options": [
            "outputs",
            "algorithms",
            "keys"
        ]
    },
    {
        "q": "What is the output of this request queuing?",
        "type": "mcq",
        "c": "class RequestQueue {\n    constructor(concurrency = 2) {\n        this.queue = [];\n        this.running = 0;\n        this.concurrency = concurrency;\n    }\n    canRun() {\n        return this.running < this.concurrency;\n    }\n}\nconst q = new RequestQueue(2);\nq.running = 2;\nconsole.log(q.canRun());",
        "o": [
            "false",
            "true",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Which header provides links for API discoverability?",
        "type": "mcq",
        "o": [
            "Link with rel attributes",
            "Navigation",
            "Discover-URL",
            "API-Links"
        ]
    },
    {
        "q": "Match API pagination styles:",
        "type": "match",
        "left": [
            "Offset",
            "Cursor",
            "Keyset",
            "Page number"
        ],
        "right": [
            "Skip N items",
            "Opaque marker",
            "Last seen value",
            "Simple page index"
        ]
    },
    {
        "q": "Rearrange the bulk operation processing:",
        "type": "rearrange",
        "words": [
            "Parse batch",
            "Validate items",
            "Process parallel",
            "Aggregate results",
            "Return response"
        ]
    },
    {
        "q": "The Cache-Status header provides cache ______ information.",
        "type": "fill_blank",
        "answers": [
            "diagnostic"
        ],
        "other_options": [
            "control",
            "invalidation",
            "refresh"
        ]
    },
    {
        "q": "What is the output of this concurrent request limiter?",
        "type": "mcq",
        "c": "class Semaphore {\n    constructor(max) {\n        this.max = max;\n        this.current = 0;\n    }\n    async acquire() {\n        while (this.current >= this.max) {\n            await new Promise(r => setTimeout(r, 10));\n        }\n        this.current++;\n    }\n    release() {\n        this.current--;\n    }\n}",
        "o": [
            "Limits concurrent operations to max",
            "Queues all operations",
            "Rejects excess operations",
            "Allows unlimited operations"
        ]
    },
    {
        "q": "Which approach optimizes API responses for different clients?",
        "type": "mcq",
        "o": [
            "GraphQL or sparse fieldsets with ?fields parameter",
            "Always return full resources",
            "Different endpoints per client",
            "Client-side filtering only"
        ]
    },
    {
        "q": "Match HTTP method semantics with resource operations:",
        "type": "match",
        "left": [
            "POST /collection",
            "PUT /resource/id",
            "PATCH /resource/id",
            "DELETE /resource/id"
        ],
        "right": [
            "Create new",
            "Replace entirely",
            "Modify partially",
            "Remove resource"
        ]
    },
    {
        "q": "The Proxy-Status header provides proxy handling information.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct implementation of an HTTP request retry with exponential backoff and jitter?",
        "type": "mcq",
        "c": "async function retryWithBackoff(fn, retries = 5) {\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await fn();\n        } catch (e) {\n            if (i === retries - 1) throw e;\n            const base = Math.pow(2, i) * 1000;\n            const jitter = Math.random() * 500;\n            await new Promise(r => setTimeout(r, base + jitter));\n        }\n    }\n}",
        "o": [
            "Exponential backoff with random jitter prevents thundering herd",
            "Fixed delay retry with no randomization",
            "Immediate retry without any delay",
            "Linear backoff with predictable timing"
        ]
    },
    {
        "q": "Which HTTP/3 feature eliminates connection migration latency?",
        "type": "mcq",
        "o": [
            "Connection IDs that persist across network changes",
            "Faster TLS handshake",
            "Binary protocol",
            "Header compression"
        ]
    },
    {
        "q": "The Client-Integrity header validates client-side code ______.",
        "type": "fill_blank",
        "answers": [
            "integrity"
        ],
        "other_options": [
            "version",
            "identity",
            "origin"
        ]
    },
    {
        "q": "Match advanced HTTP/2 optimization techniques:",
        "type": "match",
        "left": [
            "Priority trees",
            "Stream dependencies",
            "Weight allocation",
            "Exclusive flags"
        ],
        "right": [
            "Resource ordering",
            "Child-parent links",
            "Bandwidth share",
            "Override siblings"
        ]
    },
    {
        "q": "What is the output of this request correlation implementation?",
        "type": "mcq",
        "c": "class RequestTracer {\n    constructor() {\n        this.traces = new Map();\n    }\n    start(traceId, spanId, parentId = null) {\n        const span = { traceId, spanId, parentId, start: Date.now() };\n        this.traces.set(spanId, span);\n        return span;\n    }\n    end(spanId) {\n        const span = this.traces.get(spanId);\n        if (span) span.duration = Date.now() - span.start;\n        return span;\n    }\n}",
        "o": [
            "Distributed tracing with span hierarchy and timing",
            "Simple request logging",
            "Error tracking only",
            "Metric collection"
        ]
    },
    {
        "q": "HTTP/3 0-RTT resumption allows sending data in the first packet.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which technique minimizes CORS preflight overhead?",
        "type": "mcq",
        "o": [
            "Using simple requests and caching preflight with Access-Control-Max-Age",
            "Disabling CORS entirely",
            "Using POST for all requests",
            "Sending credentials with every request"
        ]
    },
    {
        "q": "The Sec-Purpose header indicates the request ______.",
        "type": "fill_blank",
        "answers": [
            "purpose"
        ],
        "other_options": [
            "origin",
            "type",
            "context"
        ]
    },
    {
        "q": "What is the output of this service mesh sidecar pattern?",
        "type": "mcq",
        "c": "class SidecarProxy {\n    constructor(service) {\n        this.service = service;\n        this.metrics = { requests: 0, errors: 0 };\n    }\n    async forward(req) {\n        this.metrics.requests++;\n        try {\n            const res = await this.service.handle(req);\n            return this.addHeaders(res);\n        } catch (e) {\n            this.metrics.errors++;\n            throw e;\n        }\n    }\n}",
        "o": [
            "Proxies requests with observability and cross-cutting concerns",
            "Caches all responses",
            "Blocks unauthorized requests",
            "Encrypts all traffic"
        ]
    },
    {
        "q": "Match HTTP request deduplication strategies with use cases:",
        "type": "match",
        "left": [
            "In-flight dedup",
            "Idempotency keys",
            "Content hash",
            "Request fingerprint"
        ],
        "right": [
            "Prevent parallel duplicates",
            "Retry safety",
            "Duplicate detection",
            "Similar request detection"
        ]
    },
    {
        "q": "Rearrange the service discovery integration flow:",
        "type": "rearrange",
        "words": [
            "Query registry",
            "Get instances",
            "Apply load balancing",
            "Make request",
            "Handle failover"
        ]
    },
    {
        "q": "The Structured-Field header uses RFC 8941 ______.",
        "type": "fill_blank",
        "answers": [
            "serialization"
        ],
        "other_options": [
            "encoding",
            "parsing",
            "validation"
        ]
    },
    {
        "q": "Which pattern provides automatic failover between API endpoints?",
        "type": "mcq",
        "o": [
            "Circuit breaker with fallback and health monitoring",
            "Single endpoint with retry",
            "Manual endpoint switching",
            "DNS round-robin only"
        ]
    },
    {
        "q": "What is the output of this load balancer simulation?",
        "type": "mcq",
        "c": "class LoadBalancer {\n    constructor(endpoints) {\n        this.endpoints = endpoints;\n        this.current = 0;\n    }\n    roundRobin() {\n        const endpoint = this.endpoints[this.current];\n        this.current = (this.current + 1) % this.endpoints.length;\n        return endpoint;\n    }\n}\nconst lb = new LoadBalancer(['a', 'b', 'c']);\nconsole.log([lb.roundRobin(), lb.roundRobin(), lb.roundRobin(), lb.roundRobin()]);",
        "o": [
            "['a', 'b', 'c', 'a']",
            "['a', 'a', 'a', 'a']",
            "['c', 'b', 'a', 'c']",
            "['a', 'b', 'c', 'd']"
        ]
    },
    {
        "q": "Match distributed tracing concepts:",
        "type": "match",
        "left": [
            "Trace ID",
            "Span ID",
            "Parent Span",
            "Baggage"
        ],
        "right": [
            "Request chain identifier",
            "Single operation ID",
            "Calling operation",
            "Propagated context"
        ]
    },
    {
        "q": "HTTP Keep-Alive connections should have configurable idle timeouts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Observe-Execution header indicates ______ execution mode.",
        "type": "fill_blank",
        "answers": [
            "observable"
        ],
        "other_options": [
            "async",
            "sync",
            "deferred"
        ]
    },
    {
        "q": "What is the output of this API gateway rate limiting?",
        "type": "mcq",
        "c": "class SlidingWindowCounter {\n    constructor(windowMs, limit) {\n        this.windowMs = windowMs;\n        this.limit = limit;\n        this.windows = new Map();\n    }\n    isAllowed(key) {\n        const now = Date.now();\n        const windowStart = now - this.windowMs;\n        const count = this.countRequests(key, windowStart, now);\n        return count < this.limit;\n    }\n}",
        "o": [
            "Sliding window rate limiter with configurable window and limit",
            "Fixed window rate limiter",
            "Token bucket algorithm",
            "Leaky bucket algorithm"
        ]
    },
    {
        "q": "Which HTTP caching strategy works best for personalized content?",
        "type": "mcq",
        "o": [
            "Private cache with Vary header for user identification",
            "Public cache with max-age",
            "No caching at all",
            "CDN caching only"
        ]
    },
    {
        "q": "Match API versioning strategies with tradeoffs:",
        "type": "match",
        "left": [
            "URI path",
            "Query param",
            "Header",
            "Content negotiation"
        ],
        "right": [
            "Visible but URL pollution",
            "Simple but less RESTful",
            "Clean but less visible",
            "Flexible but complex"
        ]
    },
    {
        "q": "Rearrange the request authentication flow:",
        "type": "rearrange",
        "words": [
            "Extract token",
            "Validate signature",
            "Check expiration",
            "Verify claims",
            "Authorize access"
        ]
    },
    {
        "q": "The Federation-ID header enables cross-system ______.",
        "type": "fill_blank",
        "answers": [
            "correlation"
        ],
        "other_options": [
            "authentication",
            "authorization",
            "encryption"
        ]
    },
    {
        "q": "What is the output of this distributed cache synchronization?",
        "type": "mcq",
        "c": "class CacheCluster {\n    constructor(nodes) {\n        this.nodes = nodes;\n        this.consistent = new ConsistentHash(nodes);\n    }\n    async get(key) {\n        const node = this.consistent.getNode(key);\n        return await node.get(key);\n    }\n    async set(key, value, ttl) {\n        const node = this.consistent.getNode(key);\n        await node.set(key, value, ttl);\n        await this.propagate(key, value, node);\n    }\n}",
        "o": [
            "Consistent hashing with cache propagation",
            "Simple round-robin cache",
            "No distribution strategy",
            "Broadcast to all nodes"
        ]
    },
    {
        "q": "Match HTTP compression decisions:",
        "type": "match",
        "left": [
            "Text content",
            "Already compressed",
            "Small files",
            "Real-time streams"
        ],
        "right": [
            "High benefit",
            "No benefit",
            "Overhead exceeds benefit",
            "Latency concern"
        ]
    },
    {
        "q": "HTTP/2 allows prioritizing visible content over below-the-fold resources.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Correlation-ID header tracks requests across ______.",
        "type": "fill_blank",
        "answers": [
            "services"
        ],
        "other_options": [
            "users",
            "sessions",
            "endpoints"
        ]
    },
    {
        "q": "What is the output of this request queuing system with priority?",
        "type": "mcq",
        "c": "class PriorityQueue {\n    constructor() {\n        this.queues = { high: [], normal: [], low: [] };\n    }\n    enqueue(item, priority = 'normal') {\n        this.queues[priority].push(item);\n    }\n    dequeue() {\n        for (const p of ['high', 'normal', 'low']) {\n            if (this.queues[p].length) return this.queues[p].shift();\n        }\n        return null;\n    }\n}\nconst q = new PriorityQueue();\nq.enqueue('a', 'low');\nq.enqueue('b', 'high');\nq.enqueue('c', 'normal');\nconsole.log([q.dequeue(), q.dequeue(), q.dequeue()]);",
        "o": [
            "['b', 'c', 'a']",
            "['a', 'b', 'c']",
            "['c', 'b', 'a']",
            "['a', 'c', 'b']"
        ]
    },
    {
        "q": "Which technique reduces API latency for geographically distributed clients?",
        "type": "mcq",
        "o": [
            "Edge computing with regional cache nodes and CDN",
            "Single centralized server",
            "Increased server CPU",
            "Larger response payloads"
        ]
    },
    {
        "q": "Match service mesh patterns:",
        "type": "match",
        "left": [
            "Sidecar",
            "Ambassador",
            "Circuit breaker",
            "Retry"
        ],
        "right": [
            "Per-pod proxy",
            "Shared proxy",
            "Failure isolation",
            "Transient fault handling"
        ]
    },
    {
        "q": "Rearrange the API gateway processing pipeline:",
        "type": "rearrange",
        "words": [
            "TLS termination",
            "Request parsing",
            "Authentication",
            "Rate limiting",
            "Routing",
            "Backend call"
        ]
    },
    {
        "q": "The X-B3-TraceId header is used for Zipkin-compatible ______.",
        "type": "fill_blank",
        "answers": [
            "tracing"
        ],
        "other_options": [
            "logging",
            "metrics",
            "profiling"
        ]
    },
    {
        "q": "What is the output of this connection pool health check?",
        "type": "mcq",
        "c": "class PoolHealthChecker {\n    constructor(pool, intervalMs) {\n        this.pool = pool;\n        this.healthy = new Set();\n        setInterval(() => this.check(), intervalMs);\n    }\n    async check() {\n        for (const conn of this.pool.connections) {\n            try {\n                await conn.ping();\n                this.healthy.add(conn.id);\n            } catch {\n                this.healthy.delete(conn.id);\n            }\n        }\n    }\n    isHealthy(id) { return this.healthy.has(id); }\n}",
        "o": [
            "Periodic health checks with healthy connection tracking",
            "Single health check on startup",
            "No health monitoring",
            "Immediate connection removal on error"
        ]
    },
    {
        "q": "Which header provides hints for prefetching resources?",
        "type": "mcq",
        "o": [
            "Link with rel=prefetch or rel=preload",
            "Cache-Control: prefetch",
            "Prefetch-Hint",
            "Resource-Hint"
        ]
    },
    {
        "q": "Match HTTP performance monitoring metrics:",
        "type": "match",
        "left": [
            "TTFB",
            "DNS lookup",
            "TCP connect",
            "Content download"
        ],
        "right": [
            "Time to first byte",
            "Name resolution",
            "Connection establishment",
            "Transfer time"
        ]
    },
    {
        "q": "API response times should follow a consistent SLA across endpoints.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The traceparent header uses W3C Trace Context ______.",
        "type": "fill_blank",
        "answers": [
            "format"
        ],
        "other_options": [
            "protocol",
            "standard",
            "encoding"
        ]
    },
    {
        "q": "What is the output of this canary deployment traffic splitter?",
        "type": "mcq",
        "c": "class CanaryRouter {\n    constructor(canaryPercent = 10) {\n        this.canaryPercent = canaryPercent;\n    }\n    route(request) {\n        const random = Math.random() * 100;\n        return random < this.canaryPercent ? 'canary' : 'stable';\n    }\n}\nconst router = new CanaryRouter(25);\n// 25% of requests go to canary",
        "o": [
            "Routes 25% of requests to canary, 75% to stable",
            "Routes all requests to canary",
            "Routes all requests to stable",
            "Alternates between canary and stable"
        ]
    },
    {
        "q": "Which pattern handles long-running API operations efficiently?",
        "type": "mcq",
        "o": [
            "Return 202 Accepted with polling endpoint or webhook callback",
            "Keep connection open until complete",
            "Increase request timeout indefinitely",
            "Break into multiple synchronous calls"
        ]
    },
    {
        "q": "Match API security layers:",
        "type": "match",
        "left": [
            "Transport",
            "Message",
            "Application",
            "Data"
        ],
        "right": [
            "TLS/HTTPS",
            "Signatures/Encryption",
            "Authentication/Authorization",
            "Field-level encryption"
        ]
    },
    {
        "q": "Rearrange the blue-green deployment API switch:",
        "type": "rearrange",
        "words": [
            "Deploy to green",
            "Run tests",
            "Update router",
            "Monitor metrics",
            "Rollback if needed"
        ]
    },
    {
        "q": "The tracestate header carries vendor-specific trace ______.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "identifiers",
            "timestamps",
            "flags"
        ]
    },
    {
        "q": "What is the output of this bulkhead isolation pattern?",
        "type": "mcq",
        "c": "class Bulkhead {\n    constructor(maxConcurrent, maxQueued) {\n        this.concurrent = 0;\n        this.maxConcurrent = maxConcurrent;\n        this.queue = [];\n        this.maxQueued = maxQueued;\n    }\n    async execute(fn) {\n        if (this.concurrent >= this.maxConcurrent) {\n            if (this.queue.length >= this.maxQueued) {\n                throw new Error('Bulkhead full');\n            }\n            await this.waitForSlot();\n        }\n        this.concurrent++;\n        try { return await fn(); }\n        finally { this.concurrent--; this.releaseSlot(); }\n    }\n}",
        "o": [
            "Isolates resources with concurrency and queue limits",
            "Unlimited concurrency",
            "No queue management",
            "Simple mutex lock"
        ]
    },
    {
        "q": "Which approach ensures atomic multi-resource API operations?",
        "type": "mcq",
        "o": [
            "Saga pattern with compensating transactions",
            "Single database transaction",
            "Hope for the best",
            "Client-side rollback"
        ]
    },
    {
        "q": "Match API gateway concerns:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Authentication",
            "Request transformation",
            "Load balancing"
        ],
        "right": [
            "Quota enforcement",
            "Identity verification",
            "Payload modification",
            "Traffic distribution"
        ]
    },
    {
        "q": "HTTP/3 connection establishment is faster due to combined handshake.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Span-ID header identifies individual trace ______.",
        "type": "fill_blank",
        "answers": [
            "spans"
        ],
        "other_options": [
            "segments",
            "nodes",
            "hops"
        ]
    },
    {
        "q": "What is the output of this request rate limiter with sliding window log?",
        "type": "mcq",
        "c": "class SlidingWindowLog {\n    constructor(limit, windowMs) {\n        this.limit = limit;\n        this.windowMs = windowMs;\n        this.log = [];\n    }\n    isAllowed() {\n        const now = Date.now();\n        const windowStart = now - this.windowMs;\n        this.log = this.log.filter(t => t > windowStart);\n        if (this.log.length < this.limit) {\n            this.log.push(now);\n            return true;\n        }\n        return false;\n    }\n}",
        "o": [
            "Precise rate limiting with timestamp log pruning",
            "Approximate rate limiting",
            "No memory pruning",
            "Fixed window counting"
        ]
    },
    {
        "q": "Which caching strategy reduces origin server load the most?",
        "type": "mcq",
        "o": [
            "Multi-tier caching with CDN, gateway, and application layers",
            "Single CDN layer only",
            "Application cache only",
            "No caching strategy"
        ]
    },
    {
        "q": "Match request timeout scenarios:",
        "type": "match",
        "left": [
            "Connection timeout",
            "Read timeout",
            "Write timeout",
            "Idle timeout"
        ],
        "right": [
            "TCP handshake limit",
            "Response wait limit",
            "Send data limit",
            "Inactivity limit"
        ]
    },
    {
        "q": "Rearrange the API observability stack:",
        "type": "rearrange",
        "words": [
            "Collect metrics",
            "Aggregate logs",
            "Correlate traces",
            "Alert on anomalies",
            "Dashboard visualization"
        ]
    },
    {
        "q": "The X-Request-Priority header indicates request ______.",
        "type": "fill_blank",
        "answers": [
            "priority"
        ],
        "other_options": [
            "urgency",
            "importance",
            "deadline"
        ]
    },
    {
        "q": "What is the output of this adaptive load balancer?",
        "type": "mcq",
        "c": "class AdaptiveBalancer {\n    constructor(endpoints) {\n        this.endpoints = endpoints.map(e => ({\n            url: e,\n            latency: 0,\n            errors: 0\n        }));\n    }\n    select() {\n        return this.endpoints.reduce((best, curr) =>\n            this.score(curr) > this.score(best) ? curr : best\n        );\n    }\n    score(e) {\n        return 1 / (1 + e.latency + e.errors * 100);\n    }\n}",
        "o": [
            "Selects endpoint with best latency and error score",
            "Random selection",
            "Round-robin only",
            "Always selects first endpoint"
        ]
    },
    {
        "q": "Which pattern prevents cascading failures in microservices?",
        "type": "mcq",
        "o": [
            "Circuit breaker with bulkhead and timeout",
            "Retry without limits",
            "No error handling",
            "Synchronous blocking calls"
        ]
    },
    {
        "q": "Match HTTP/2 performance features:",
        "type": "match",
        "left": [
            "Header compression",
            "Multiplexing",
            "Server push",
            "Stream prioritization"
        ],
        "right": [
            "Reduced overhead",
            "No head-of-line blocking",
            "Proactive resource sending",
            "Bandwidth allocation"
        ]
    },
    {
        "q": "API rate limits should be communicated in response headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Retry-After header can specify absolute ______ or delay.",
        "type": "fill_blank",
        "answers": [
            "datetime"
        ],
        "other_options": [
            "timestamp",
            "period",
            "duration"
        ]
    },
    {
        "q": "What is the output of this request hedging strategy?",
        "type": "mcq",
        "c": "async function hedge(fn, delay) {\n    let winner = null;\n    const first = fn().then(r => { winner = winner || r; return r; });\n    const second = new Promise(resolve =>\n        setTimeout(() => fn().then(r => resolve(winner || r)), delay)\n    );\n    return Promise.race([first, second]);\n}\n// Starts second request if first is slow",
        "o": [
            "Sends backup request after delay if first is too slow",
            "Always sends two requests",
            "Cancels request after delay",
            "Queues second request"
        ]
    },
    {
        "q": "Which approach minimizes API cold start latency?",
        "type": "mcq",
        "o": [
            "Provisioned concurrency with warm pools",
            "No warm-up strategy",
            "Larger instance sizes only",
            "Longer timeout values"
        ]
    },
    {
        "q": "Match API throttling algorithms:",
        "type": "match",
        "left": [
            "Token bucket",
            "Leaky bucket",
            "Fixed window",
            "Sliding log"
        ],
        "right": [
            "Bursty with refill",
            "Smooth rate",
            "Simple counting",
            "Precise tracking"
        ]
    },
    {
        "q": "Rearrange the request lifecycle instrumentation:",
        "type": "rearrange",
        "words": [
            "Start span",
            "Record metadata",
            "Execute logic",
            "Capture timing",
            "End span",
            "Export trace"
        ]
    },
    {
        "q": "The X-RateLimit-Remaining header shows available ______.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "tokens",
            "capacity",
            "quota"
        ]
    },
    {
        "q": "What is the output of this distributed lock implementation?",
        "type": "mcq",
        "c": "class DistributedLock {\n    constructor(store, ttl) {\n        this.store = store;\n        this.ttl = ttl;\n    }\n    async acquire(key, ownerId) {\n        const result = await this.store.setNX(key, ownerId, this.ttl);\n        return result;\n    }\n    async release(key, ownerId) {\n        const current = await this.store.get(key);\n        if (current === ownerId) {\n            await this.store.delete(key);\n            return true;\n        }\n        return false;\n    }\n}",
        "o": [
            "Atomic lock acquire with owner verification on release",
            "Simple mutex without verification",
            "Non-atomic operations",
            "No timeout handling"
        ]
    },
    {
        "q": "Which header indicates the API version explicitly?",
        "type": "mcq",
        "o": [
            "Accept: application/vnd.company.api.v2+json",
            "Content-Version",
            "API-Version",
            "X-Version-Number"
        ]
    },
    {
        "q": "Match API deprecation communication:",
        "type": "match",
        "left": [
            "Sunset header",
            "Deprecation header",
            "Warning header",
            "Link header"
        ],
        "right": [
            "Retirement date",
            "Deprecation date",
            "Deprecation notice",
            "Successor URL"
        ]
    },
    {
        "q": "HTTP/3 QPACK provides better header compression than HPACK.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-RateLimit-Reset header indicates quota reset ______.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "date",
            "period",
            "duration"
        ]
    },
    {
        "q": "What is the output of this request deduplication cache?",
        "type": "mcq",
        "c": "class IdempotencyCache {\n    constructor(ttlMs) {\n        this.cache = new Map();\n        this.ttl = ttlMs;\n    }\n    set(key, response) {\n        this.cache.set(key, {\n            response,\n            expires: Date.now() + this.ttl\n        });\n    }\n    get(key) {\n        const entry = this.cache.get(key);\n        if (!entry) return null;\n        if (Date.now() > entry.expires) {\n            this.cache.delete(key);\n            return null;\n        }\n        return entry.response;\n    }\n}",
        "o": [
            "TTL-based cache with automatic expiration",
            "Permanent cache without expiration",
            "No cache retrieval",
            "Cache without TTL"
        ]
    },
    {
        "q": "Which strategy handles API backward compatibility?",
        "type": "mcq",
        "o": [
            "Additive changes only, deprecate before removing",
            "Breaking changes immediately",
            "No versioning",
            "New endpoint for every change"
        ]
    },
    {
        "q": "Match HTTP streaming techniques:",
        "type": "match",
        "left": [
            "Chunked encoding",
            "Server-Sent Events",
            "WebSocket",
            "gRPC streaming"
        ],
        "right": [
            "Progressive download",
            "Unidirectional push",
            "Bidirectional",
            "Protocol Buffers"
        ]
    },
    {
        "q": "Rearrange the API circuit breaker states:",
        "type": "rearrange",
        "words": [
            "Closed",
            "Open",
            "Half-Open",
            "Test request",
            "Reset"
        ]
    },
    {
        "q": "The X-RateLimit-Limit header indicates total allowed ______.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "connections",
            "bandwidth",
            "duration"
        ]
    },
    {
        "q": "What is the output of this fallback handler chain?",
        "type": "mcq",
        "c": "class FallbackChain {\n    constructor(handlers) {\n        this.handlers = handlers;\n    }\n    async execute(request) {\n        for (const handler of this.handlers) {\n            try {\n                return await handler(request);\n            } catch (e) {\n                continue;\n            }\n        }\n        throw new Error('All handlers failed');\n    }\n}\nconst chain = new FallbackChain([\n    req => Promise.reject('fail'),\n    req => 'fallback'\n]);\nconsole.log(await chain.execute({}));",
        "o": [
            "fallback",
            "fail",
            "Error: All handlers failed",
            "undefined"
        ]
    },
    {
        "q": "Which header communicates API usage limits to clients?",
        "type": "mcq",
        "o": [
            "X-RateLimit-Limit with X-RateLimit-Remaining and X-RateLimit-Reset",
            "Quota-Limit only",
            "Usage-Info",
            "API-Limits"
        ]
    },
    {
        "q": "Match HTTP status codes with circuit breaker actions:",
        "type": "match",
        "left": [
            "429",
            "503",
            "500",
            "200"
        ],
        "right": [
            "Rate limit hit",
            "Service down",
            "May fail",
            "Success"
        ]
    },
    {
        "q": "API observability requires logs, metrics, and traces together.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct implementation of consistent hashing for API load distribution?",
        "type": "mcq",
        "c": "class ConsistentHash {\n    constructor(nodes, replicas = 150) {\n        this.ring = new Map();\n        this.nodes = [];\n        nodes.forEach(n => this.addNode(n, replicas));\n    }\n    hash(key) { return crypto.createHash('md5').update(key).digest('hex'); }\n    addNode(node, replicas) {\n        this.nodes.push(node);\n        for (let i = 0; i < replicas; i++) {\n            this.ring.set(this.hash(node + i), node);\n        }\n    }\n    getNode(key) {\n        const hash = this.hash(key);\n        const keys = [...this.ring.keys()].sort();\n        for (const k of keys) { if (k >= hash) return this.ring.get(k); }\n        return this.ring.get(keys[0]);\n    }\n}",
        "o": [
            "Virtual nodes with consistent hashing ring for even distribution",
            "Simple modulo hashing",
            "Random distribution",
            "Round-robin assignment"
        ]
    },
    {
        "q": "Which approach handles API idempotency for financial transactions most safely?",
        "type": "mcq",
        "o": [
            "Client-provided idempotency key with server-side dedup and conditional processing",
            "Server-generated request ID",
            "Timestamp-based deduplication",
            "No deduplication strategy"
        ]
    },
    {
        "q": "The QUIC Initial packet includes both crypto handshake and ______ data.",
        "type": "fill_blank",
        "answers": [
            "application"
        ],
        "other_options": [
            "control",
            "header",
            "stream"
        ]
    },
    {
        "q": "Match advanced distributed caching patterns:",
        "type": "match",
        "left": [
            "Write-through",
            "Write-behind",
            "Read-through",
            "Cache-aside"
        ],
        "right": [
            "Sync write to cache and DB",
            "Async write to DB later",
            "Load on cache miss",
            "App manages cache"
        ]
    },
    {
        "q": "What is the output of this event sourcing implementation?",
        "type": "mcq",
        "c": "class EventStore {\n    constructor() {\n        this.events = [];\n        this.snapshots = new Map();\n    }\n    append(aggregateId, event) {\n        this.events.push({ aggregateId, event, timestamp: Date.now() });\n    }\n    getHistory(aggregateId) {\n        return this.events.filter(e => e.aggregateId === aggregateId);\n    }\n    rebuildState(aggregateId) {\n        const history = this.getHistory(aggregateId);\n        return history.reduce((state, e) => this.apply(state, e.event), {});\n    }\n}",
        "o": [
            "Event sourcing with state reconstruction from event history",
            "Simple CRUD operations",
            "Write-ahead logging only",
            "Snapshot-only storage"
        ]
    },
    {
        "q": "HTTP/3 QUIC provides built-in connection migration without handshake.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which pattern ensures consistency in distributed API transactions?",
        "type": "mcq",
        "o": [
            "Two-phase commit or Saga with compensating actions",
            "Eventually consistent reads only",
            "No transaction coordination",
            "Single database for all services"
        ]
    },
    {
        "q": "The Service-Worker header indicates resource handling by ______.",
        "type": "fill_blank",
        "answers": [
            "service worker"
        ],
        "other_options": [
            "web worker",
            "shared worker",
            "worklet"
        ]
    },
    {
        "q": "What is the output of this CQRS implementation?",
        "type": "mcq",
        "c": "class CQRS {\n    constructor() {\n        this.commandStore = [];\n        this.queryCache = new Map();\n    }\n    executeCommand(cmd) {\n        this.commandStore.push(cmd);\n        this.invalidateCache(cmd.entity);\n        return { success: true, id: cmd.id };\n    }\n    executeQuery(query) {\n        if (this.queryCache.has(query.key)) {\n            return this.queryCache.get(query.key);\n        }\n        const result = this.buildFromStore(query);\n        this.queryCache.set(query.key, result);\n        return result;\n    }\n}",
        "o": [
            "Command-query separation with caching for reads",
            "Standard CRUD pattern",
            "Event-only architecture",
            "Write-only storage"
        ]
    },
    {
        "q": "Match API resilience patterns:",
        "type": "match",
        "left": [
            "Retry",
            "Circuit breaker",
            "Bulkhead",
            "Timeout"
        ],
        "right": [
            "Transient fault handling",
            "Failure isolation",
            "Resource isolation",
            "Bound waiting time"
        ]
    },
    {
        "q": "Rearrange the distributed transaction saga:",
        "type": "rearrange",
        "words": [
            "Start transaction",
            "Execute steps",
            "Record completion",
            "On failure compensate",
            "Finalize state"
        ]
    },
    {
        "q": "The X-Trace-Debug header enables detailed trace ______ output.",
        "type": "fill_blank",
        "answers": [
            "diagnostic"
        ],
        "other_options": [
            "summary",
            "minimal",
            "compressed"
        ]
    },
    {
        "q": "Which approach handles eventual consistency in API responses?",
        "type": "mcq",
        "o": [
            "Read-your-writes with session stickiness or version tags",
            "Strong consistency everywhere",
            "Ignore consistency concerns",
            "Always fail on stale data"
        ]
    },
    {
        "q": "What is the output of this gossip protocol implementation?",
        "type": "mcq",
        "c": "class GossipNode {\n    constructor(id) {\n        this.id = id;\n        this.state = new Map();\n        this.peers = [];\n    }\n    gossip() {\n        const peer = this.peers[Math.floor(Math.random() * this.peers.length)];\n        return { from: this.id, state: Object.fromEntries(this.state) };\n    }\n    merge(incoming) {\n        for (const [key, value] of Object.entries(incoming.state)) {\n            if (!this.state.has(key) || value.version > this.state.get(key).version) {\n                this.state.set(key, value);\n            }\n        }\n    }\n}",
        "o": [
            "Gossip protocol for distributed state propagation",
            "Consensus algorithm",
            "Leader election",
            "Lock management"
        ]
    },
    {
        "q": "Match content delivery optimization techniques:",
        "type": "match",
        "left": [
            "Edge caching",
            "Compression",
            "HTTP/2 push",
            "Preload hints"
        ],
        "right": [
            "Geographic proximity",
            "Reduced transfer size",
            "Proactive delivery",
            "Browser resource hints"
        ]
    },
    {
        "q": "API gateways should terminate TLS to offload encryption from backend services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Cascade header indicates fallback to next ______ handler.",
        "type": "fill_blank",
        "answers": [
            "route"
        ],
        "other_options": [
            "service",
            "endpoint",
            "proxy"
        ]
    },
    {
        "q": "What is the output of this leader election implementation?",
        "type": "mcq",
        "c": "class LeaderElection {\n    constructor(nodeId, store) {\n        this.nodeId = nodeId;\n        this.store = store;\n        this.leaderKey = 'leader';\n    }\n    async tryBecomeLeader(ttl) {\n        const result = await this.store.setNX(this.leaderKey, this.nodeId, ttl);\n        return result;\n    }\n    async renewLease(ttl) {\n        const current = await this.store.get(this.leaderKey);\n        if (current === this.nodeId) {\n            await this.store.expire(this.leaderKey, ttl);\n            return true;\n        }\n        return false;\n    }\n}",
        "o": [
            "Leader election with TTL-based lease renewal",
            "Static leader assignment",
            "Random leader selection",
            "No leader coordination"
        ]
    },
    {
        "q": "Which pattern handles API request deduplication at scale?",
        "type": "mcq",
        "o": [
            "Bloom filter for quick rejection with backing store for verification",
            "Full request storage for all time",
            "No deduplication",
            "Client-side only deduplication"
        ]
    },
    {
        "q": "Match API design anti-patterns:",
        "type": "match",
        "left": [
            "N+1 queries",
            "Chatty interface",
            "Overfetching",
            "Underfetching"
        ],
        "right": [
            "Multiple sequential calls",
            "Too many round trips",
            "Returning unused data",
            "Missing required data"
        ]
    },
    {
        "q": "Rearrange the API performance optimization pipeline:",
        "type": "rearrange",
        "words": [
            "Identify bottleneck",
            "Profile code",
            "Optimize algorithm",
            "Add caching",
            "Measure improvement"
        ]
    },
    {
        "q": "The X-Shard-Key header routes requests to specific database ______.",
        "type": "fill_blank",
        "answers": [
            "partitions"
        ],
        "other_options": [
            "replicas",
            "nodes",
            "tables"
        ]
    },
    {
        "q": "What is the output of this vector clock implementation?",
        "type": "mcq",
        "c": "class VectorClock {\n    constructor(nodeId) {\n        this.nodeId = nodeId;\n        this.clock = {};\n    }\n    increment() {\n        this.clock[this.nodeId] = (this.clock[this.nodeId] || 0) + 1;\n        return { ...this.clock };\n    }\n    merge(other) {\n        for (const [node, time] of Object.entries(other)) {\n            this.clock[node] = Math.max(this.clock[node] || 0, time);\n        }\n        return this.increment();\n    }\n    compare(other) {\n        let dominated = true, dominates = true;\n        for (const node of new Set([...Object.keys(this.clock), ...Object.keys(other)])) {\n            if ((this.clock[node] || 0) < (other[node] || 0)) dominates = false;\n            if ((this.clock[node] || 0) > (other[node] || 0)) dominated = false;\n        }\n        if (dominates && !dominated) return 1;\n        if (dominated && !dominates) return -1;\n        if (dominated && dominates) return 0;\n        return null;\n    }\n}",
        "o": [
            "Vector clock for distributed event ordering with conflict detection",
            "Simple timestamp comparison",
            "Sequence number counter",
            "Random version assignment"
        ]
    },
    {
        "q": "Which strategy minimizes API latency variance?",
        "type": "mcq",
        "o": [
            "Hedging with tail cancellation and adaptive timeouts",
            "Fixed timeout for all requests",
            "No timeout management",
            "Retry without limit"
        ]
    },
    {
        "q": "Match distributed consensus algorithms:",
        "type": "match",
        "left": [
            "Paxos",
            "Raft",
            "PBFT",
            "Zab"
        ],
        "right": [
            "Multi-round consensus",
            "Leader-based log",
            "Byzantine fault tolerant",
            "Atomic broadcast"
        ]
    },
    {
        "q": "HTTP/3 frames are encrypted at the QUIC layer for better security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Causality header tracks event ______ relationships.",
        "type": "fill_blank",
        "answers": [
            "causal"
        ],
        "other_options": [
            "temporal",
            "logical",
            "sequential"
        ]
    },
    {
        "q": "What is the output of this conflict-free replicated data type?",
        "type": "mcq",
        "c": "class GCounter {\n    constructor(nodeId) {\n        this.nodeId = nodeId;\n        this.counters = {};\n    }\n    increment(amount = 1) {\n        this.counters[this.nodeId] = (this.counters[this.nodeId] || 0) + amount;\n    }\n    value() {\n        return Object.values(this.counters).reduce((sum, v) => sum + v, 0);\n    }\n    merge(other) {\n        for (const [node, count] of Object.entries(other.counters)) {\n            this.counters[node] = Math.max(this.counters[node] || 0, count);\n        }\n    }\n}",
        "o": [
            "CRDT grow-only counter with merge convergence",
            "Simple shared counter",
            "Distributed lock",
            "Transaction log"
        ]
    },
    {
        "q": "Which pattern handles API schema evolution?",
        "type": "mcq",
        "o": [
            "Schema registry with compatible evolution rules",
            "No schema versioning",
            "Breaking changes without notice",
            "New API for every change"
        ]
    },
    {
        "q": "Match API testing strategies:",
        "type": "match",
        "left": [
            "Contract testing",
            "Integration testing",
            "Load testing",
            "Chaos testing"
        ],
        "right": [
            "Consumer-provider agreement",
            "Component interaction",
            "Performance limits",
            "Fault injection"
        ]
    },
    {
        "q": "Rearrange the API blue-green deployment steps:",
        "type": "rearrange",
        "words": [
            "Deploy green",
            "Test deployment",
            "Switch traffic",
            "Monitor health",
            "Retire blue"
        ]
    },
    {
        "q": "The X-Partition-Key header determines data ______.",
        "type": "fill_blank",
        "answers": [
            "placement"
        ],
        "other_options": [
            "version",
            "format",
            "encoding"
        ]
    },
    {
        "q": "What is the output of this anti-entropy repair mechanism?",
        "type": "mcq",
        "c": "class AntiEntropy {\n    constructor(localData, getRemote) {\n        this.data = localData;\n        this.getRemote = getRemote;\n    }\n    async repair() {\n        const remote = await this.getRemote();\n        const diffs = this.findDifferences(remote);\n        for (const diff of diffs) {\n            if (diff.action === 'pull') {\n                this.data.set(diff.key, remote.get(diff.key));\n            } else if (diff.action === 'push') {\n                await this.sendToRemote(diff.key, this.data.get(diff.key));\n            }\n        }\n    }\n}",
        "o": [
            "Background repair synchronizing divergent replicas",
            "Immediate consistency enforcement",
            "One-way sync only",
            "No repair mechanism"
        ]
    },
    {
        "q": "Which approach provides zero-downtime API deployments?",
        "type": "mcq",
        "o": [
            "Rolling deployment with health checks and automatic rollback",
            "Single instance replacement",
            "All-at-once deployment",
            "Manual switchover"
        ]
    },
    {
        "q": "Match API monitoring alerting thresholds:",
        "type": "match",
        "left": [
            "P50 latency",
            "P99 latency",
            "Error rate",
            "Throughput"
        ],
        "right": [
            "Median experience",
            "Tail latency",
            "Failure percentage",
            "Request volume"
        ]
    },
    {
        "q": "API backward compatibility requires only additive changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Consistency-Level header specifies read ______ requirements.",
        "type": "fill_blank",
        "answers": [
            "consistency"
        ],
        "other_options": [
            "isolation",
            "durability",
            "atomicity"
        ]
    },
    {
        "q": "What is the output of this read repair implementation?",
        "type": "mcq",
        "c": "class ReadRepair {\n    constructor(replicas, quorum) {\n        this.replicas = replicas;\n        this.quorum = quorum;\n    }\n    async read(key) {\n        const responses = await Promise.all(\n            this.replicas.map(r => r.get(key).catch(() => null))\n        );\n        const valid = responses.filter(r => r !== null);\n        if (valid.length < this.quorum) throw new Error('Quorum not met');\n        const latest = this.selectLatest(valid);\n        this.asyncRepair(key, latest, responses);\n        return latest.value;\n    }\n}",
        "o": [
            "Quorum reads with asynchronous replica repair",
            "Single replica read",
            "All-replica synchronous read",
            "No consistency guarantee"
        ]
    },
    {
        "q": "Which pattern handles partial API failures gracefully?",
        "type": "mcq",
        "o": [
            "Graceful degradation with feature flags and fallbacks",
            "Complete failure on any error",
            "Retry until success",
            "No error handling"
        ]
    },
    {
        "q": "Match API capacity planning metrics:",
        "type": "match",
        "left": [
            "RPS",
            "Concurrent connections",
            "Memory usage",
            "CPU utilization"
        ],
        "right": [
            "Request throughput",
            "Connection capacity",
            "Heap management",
            "Processing power"
        ]
    },
    {
        "q": "Rearrange the API incident response:",
        "type": "rearrange",
        "words": [
            "Detect anomaly",
            "Assess impact",
            "Mitigate issue",
            "Root cause analysis",
            "Implement fix"
        ]
    },
    {
        "q": "The X-Serialization-Format header specifies message ______.",
        "type": "fill_blank",
        "answers": [
            "format"
        ],
        "other_options": [
            "version",
            "encoding",
            "compression"
        ]
    },
    {
        "q": "What is the output of this write-ahead log implementation?",
        "type": "mcq",
        "c": "class WAL {\n    constructor(storage) {\n        this.storage = storage;\n        this.log = [];\n        this.sequence = 0;\n    }\n    async append(operation) {\n        const entry = { seq: ++this.sequence, op: operation, ts: Date.now() };\n        this.log.push(entry);\n        await this.storage.sync(entry);\n        return entry.seq;\n    }\n    async recover() {\n        const entries = await this.storage.readAll();\n        for (const entry of entries.sort((a, b) => a.seq - b.seq)) {\n            await this.apply(entry.op);\n        }\n    }\n}",
        "o": [
            "Durable WAL with crash recovery and replay",
            "In-memory only log",
            "No durability guarantee",
            "Synchronous write without log"
        ]
    },
    {
        "q": "Which approach handles API rate limiting fairly across tenants?",
        "type": "mcq",
        "o": [
            "Weighted fair queuing with tenant-specific quotas",
            "Global rate limit only",
            "No rate limiting",
            "First-come first-served"
        ]
    },
    {
        "q": "Match API documentation best practices:",
        "type": "match",
        "left": [
            "OpenAPI spec",
            "Examples",
            "Error codes",
            "Changelog"
        ],
        "right": [
            "Machine-readable contract",
            "Usage demonstrations",
            "Error handling guide",
            "Version history"
        ]
    },
    {
        "q": "HTTP Early Data (0-RTT) trades security for latency in resumption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Region-Affinity header routes to geographically ______ servers.",
        "type": "fill_blank",
        "answers": [
            "preferred"
        ],
        "other_options": [
            "closest",
            "fastest",
            "available"
        ]
    },
    {
        "q": "What is the output of this merkle tree implementation?",
        "type": "mcq",
        "c": "class MerkleTree {\n    constructor(leaves) {\n        this.leaves = leaves.map(l => this.hash(l));\n        this.tree = this.build();\n    }\n    hash(data) { return crypto.createHash('sha256').update(data).digest('hex'); }\n    build() {\n        let level = this.leaves;\n        const tree = [level];\n        while (level.length > 1) {\n            level = this.buildNextLevel(level);\n            tree.push(level);\n        }\n        return tree;\n    }\n    getRoot() { return this.tree[this.tree.length - 1][0]; }\n    verify(leaf, proof) {\n        let hash = this.hash(leaf);\n        for (const { sibling, position } of proof) {\n            hash = position === 'left' \n                ? this.hash(sibling + hash)\n                : this.hash(hash + sibling);\n        }\n        return hash === this.getRoot();\n    }\n}",
        "o": [
            "Merkle tree for efficient data integrity verification",
            "Simple hash chain",
            "Linear proof of work",
            "Random hash verification"
        ]
    },
    {
        "q": "Which strategy handles API versioning in microservices?",
        "type": "mcq",
        "o": [
            "Semantic versioning with contract testing and compatibility matrix",
            "No versioning between services",
            "Breaking changes freely",
            "Single version for all services"
        ]
    },
    {
        "q": "Match API security attack prevention:",
        "type": "match",
        "left": [
            "SQL injection",
            "XSS",
            "CSRF",
            "DDoS"
        ],
        "right": [
            "Parameterized queries",
            "Output encoding",
            "CSRF tokens",
            "Rate limiting"
        ]
    },
    {
        "q": "Rearrange the API disaster recovery steps:",
        "type": "rearrange",
        "words": [
            "Detect failure",
            "Failover to DR",
            "Validate DR health",
            "Restore primary",
            "Failback"
        ]
    },
    {
        "q": "The X-Tenant-ID header identifies multi-tenant ______.",
        "type": "fill_blank",
        "answers": [
            "context"
        ],
        "other_options": [
            "session",
            "request",
            "connection"
        ]
    },
    {
        "q": "What is the output of this shard router implementation?",
        "type": "mcq",
        "c": "class ShardRouter {\n    constructor(shardCount) {\n        this.shardCount = shardCount;\n        this.shards = new Array(shardCount);\n    }\n    getShard(key) {\n        const hash = this.hash(key);\n        return hash % this.shardCount;\n    }\n    hash(key) {\n        let h = 0;\n        for (const char of key) {\n            h = ((h << 5) - h) + char.charCodeAt(0);\n            h |= 0;\n        }\n        return Math.abs(h);\n    }\n    route(key, data) {\n        const shardId = this.getShard(key);\n        return this.shards[shardId].write(key, data);\n    }\n}",
        "o": [
            "Hash-based shard routing for horizontal scaling",
            "Random shard selection",
            "Sequential shard filling",
            "Single shard storage"
        ]
    },
    {
        "q": "Which pattern handles API request prioritization under load?",
        "type": "mcq",
        "o": [
            "Priority queuing with admission control and load shedding",
            "FIFO processing only",
            "Random processing order",
            "No prioritization"
        ]
    },
    {
        "q": "Match API operational excellence practices:",
        "type": "match",
        "left": [
            "SLI",
            "SLO",
            "SLA",
            "Error budget"
        ],
        "right": [
            "Service level indicator",
            "Service level objective",
            "Service level agreement",
            "Allowed downtime"
        ]
    },
    {
        "q": "API circuit breakers should have configurable thresholds and timeouts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Deadline header specifies request processing ______.",
        "type": "fill_blank",
        "answers": [
            "deadline"
        ],
        "other_options": [
            "timeout",
            "priority",
            "urgency"
        ]
    },
    {
        "q": "What is the output of this adaptive concurrency limiter?",
        "type": "mcq",
        "c": "class AdaptiveLimiter {\n    constructor(minLimit = 5, maxLimit = 100) {\n        this.limit = minLimit;\n        this.minLimit = minLimit;\n        this.maxLimit = maxLimit;\n        this.inFlight = 0;\n        this.rttAvg = 0;\n    }\n    async acquire() {\n        while (this.inFlight >= this.limit) {\n            await new Promise(r => setTimeout(r, 10));\n        }\n        this.inFlight++;\n    }\n    release(rtt) {\n        this.inFlight--;\n        this.updateLimit(rtt);\n    }\n    updateLimit(rtt) {\n        if (rtt < this.rttAvg * 1.1 && this.limit < this.maxLimit) {\n            this.limit++;\n        } else if (rtt > this.rttAvg * 1.5 && this.limit > this.minLimit) {\n            this.limit = Math.floor(this.limit * 0.9);\n        }\n        this.rttAvg = (this.rttAvg + rtt) / 2;\n    }\n}",
        "o": [
            "RTT-based adaptive concurrency adjustment",
            "Fixed concurrency limit",
            "No concurrency control",
            "Random limit adjustment"
        ]
    },
    {
        "q": "Which approach handles API cross-region replication?",
        "type": "mcq",
        "o": [
            "Async replication with conflict resolution and read-local",
            "Synchronous global writes",
            "Single region only",
            "No replication strategy"
        ]
    },
    {
        "q": "Match API infrastructure as code practices:",
        "type": "match",
        "left": [
            "Terraform",
            "Kubernetes",
            "Helm",
            "GitOps"
        ],
        "right": [
            "Cloud resources",
            "Container orchestration",
            "K8s packages",
            "Git-driven deployment"
        ]
    },
    {
        "q": "Rearrange the API chaos engineering experiment:",
        "type": "rearrange",
        "words": [
            "Define hypothesis",
            "Inject failure",
            "Observe behavior",
            "Analyze results",
            "Improve resilience"
        ]
    },
    {
        "q": "The X-Feature-Flag header enables dynamic feature ______.",
        "type": "fill_blank",
        "answers": [
            "toggling"
        ],
        "other_options": [
            "testing",
            "deployment",
            "rollback"
        ]
    },
    {
        "q": "What is the output of this gossip-based failure detector?",
        "type": "mcq",
        "c": "class FailureDetector {\n    constructor(suspicionThreshold = 3) {\n        this.suspicionThreshold = suspicionThreshold;\n        this.nodes = new Map();\n    }\n    heartbeat(nodeId) {\n        this.nodes.set(nodeId, { timestamp: Date.now(), suspicion: 0 });\n    }\n    checkHealth(timeout) {\n        const now = Date.now();\n        const failed = [];\n        for (const [id, state] of this.nodes) {\n            if (now - state.timestamp > timeout) {\n                state.suspicion++;\n                if (state.suspicion >= this.suspicionThreshold) {\n                    failed.push(id);\n                }\n            }\n        }\n        return failed;\n    }\n}",
        "o": [
            "Accrual failure detector with suspicion levels",
            "Immediate failure detection",
            "No failure detection",
            "Manual health checks"
        ]
    },
    {
        "q": "Which pattern handles API secret rotation without downtime?",
        "type": "mcq",
        "o": [
            "Dual-secret transition with overlapping validity periods",
            "Immediate secret replacement",
            "No secret rotation",
            "Manual credential update"
        ]
    },
    {
        "q": "Match API performance optimization layers:",
        "type": "match",
        "left": [
            "CDN",
            "API Gateway",
            "Service mesh",
            "Database"
        ],
        "right": [
            "Edge caching",
            "Request routing",
            "Service communication",
            "Query optimization"
        ]
    },
    {
        "q": "Zero-trust API security assumes no implicit trust for any request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Idempotency-Key header enables safe request ______.",
        "type": "fill_blank",
        "answers": [
            "retry"
        ],
        "other_options": [
            "caching",
            "routing",
            "logging"
        ]
    },
    {
        "q": "What is the output of this request coalescing implementation?",
        "type": "mcq",
        "c": "class RequestCoalescer {\n    constructor(batchDelay, maxBatchSize) {\n        this.pending = new Map();\n        this.timeout = null;\n        this.batchDelay = batchDelay;\n        this.maxBatchSize = maxBatchSize;\n    }\n    async add(key, request) {\n        return new Promise((resolve, reject) => {\n            if (!this.pending.has(key)) {\n                this.pending.set(key, []);\n            }\n            this.pending.get(key).push({ request, resolve, reject });\n            if (this.pending.get(key).length >= this.maxBatchSize) {\n                this.flush(key);\n            } else if (!this.timeout) {\n                this.timeout = setTimeout(() => this.flushAll(), this.batchDelay);\n            }\n        });\n    }\n}",
        "o": [
            "Request batching with size and time-based triggers",
            "Individual request processing",
            "Infinite buffering",
            "Drop excess requests"
        ]
    },
    {
        "q": "Which approach handles API graceful shutdown?",
        "type": "mcq",
        "o": [
            "Stop accepting new requests, drain existing, with timeout",
            "Immediate process termination",
            "Kill all connections",
            "No shutdown handling"
        ]
    },
    {
        "q": "Match API logging best practices:",
        "type": "match",
        "left": [
            "Structured logs",
            "Log levels",
            "Correlation IDs",
            "Sampling"
        ],
        "right": [
            "Machine-parseable format",
            "Severity classification",
            "Request tracing",
            "Volume reduction"
        ]
    },
    {
        "q": "Rearrange the API canary deployment process:",
        "type": "rearrange",
        "words": [
            "Deploy canary",
            "Route percentage",
            "Monitor metrics",
            "Increase traffic",
            "Full rollout"
        ]
    },
    {
        "q": "The X-Rate-Limit-Policy header describes the limiting ______.",
        "type": "fill_blank",
        "answers": [
            "rules"
        ],
        "other_options": [
            "limits",
            "quotas",
            "thresholds"
        ]
    },
    {
        "q": "What is the output of this back-pressure handler?",
        "type": "mcq",
        "c": "class BackPressureHandler {\n    constructor(highWaterMark, lowWaterMark) {\n        this.queue = [];\n        this.highWaterMark = highWaterMark;\n        this.lowWaterMark = lowWaterMark;\n        this.paused = false;\n    }\n    push(item) {\n        if (this.queue.length >= this.highWaterMark) {\n            this.paused = true;\n            return false;\n        }\n        this.queue.push(item);\n        return true;\n    }\n    pull() {\n        const item = this.queue.shift();\n        if (this.paused && this.queue.length <= this.lowWaterMark) {\n            this.paused = false;\n        }\n        return item;\n    }\n}",
        "o": [
            "Flow control with high/low watermarks for backpressure",
            "Unlimited buffering",
            "Immediate rejection",
            "No flow control"
        ]
    },
    {
        "q": "Which strategy handles API database connection pooling?",
        "type": "mcq",
        "o": [
            "Pool with min/max connections, health checks, and timeout",
            "New connection per request",
            "Single shared connection",
            "No pooling strategy"
        ]
    },
    {
        "q": "Match API deployment strategies:",
        "type": "match",
        "left": [
            "Blue-green",
            "Canary",
            "Rolling",
            "Recreate"
        ],
        "right": [
            "Full swap",
            "Gradual traffic shift",
            "Instance-by-instance",
            "Complete replacement"
        ]
    },
    {
        "q": "API rate limiting headers should include remaining quota and reset time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Request-Timeout header specifies maximum processing ______.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "retries",
            "attempts",
            "cycles"
        ]
    },
    {
        "q": "What is the output of this request timeout propagation?",
        "type": "mcq",
        "c": "class TimeoutPropagator {\n    constructor() {\n        this.context = new Map();\n    }\n    startRequest(requestId, deadline) {\n        this.context.set(requestId, { deadline, start: Date.now() });\n    }\n    getRemainingTime(requestId) {\n        const ctx = this.context.get(requestId);\n        if (!ctx) return null;\n        const elapsed = Date.now() - ctx.start;\n        const remaining = ctx.deadline - elapsed;\n        return Math.max(0, remaining);\n    }\n    propagate(requestId, childDeadline) {\n        const remaining = this.getRemainingTime(requestId);\n        return Math.min(remaining || Infinity, childDeadline);\n    }\n}",
        "o": [
            "Deadline propagation with remaining time calculation",
            "Fixed timeout for all requests",
            "No timeout propagation",
            "Infinite deadlines"
        ]
    },
    {
        "q": "Which approach handles API audit logging?",
        "type": "mcq",
        "o": [
            "Immutable append-only log with tamper detection",
            "Regular application logs",
            "No audit logging",
            "Overwritable logs"
        ]
    },
    {
        "q": "Match API error handling strategies:",
        "type": "match",
        "left": [
            "Fail fast",
            "Fail safe",
            "Fail silent",
            "Fail loud"
        ],
        "right": [
            "Return error immediately",
            "Return default value",
            "Log and suppress",
            "Alert and propagate"
        ]
    },
    {
        "q": "Rearrange the API hot reload process:",
        "type": "rearrange",
        "words": [
            "Detect change",
            "Load new config",
            "Validate config",
            "Apply atomically",
            "Confirm success"
        ]
    },
    {
        "q": "The X-Quota-Policy header describes usage ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "metrics",
            "tracking",
            "billing"
        ]
    },
    {
        "q": "What is the output of this adaptive timeout calculator?",
        "type": "mcq",
        "c": "class AdaptiveTimeout {\n    constructor(samples = 100) {\n        this.latencies = [];\n        this.maxSamples = samples;\n    }\n    record(latency) {\n        this.latencies.push(latency);\n        if (this.latencies.length > this.maxSamples) {\n            this.latencies.shift();\n        }\n    }\n    getTimeout(percentile = 99) {\n        const sorted = [...this.latencies].sort((a, b) => a - b);\n        const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n        return sorted[Math.max(0, index)] * 1.5;\n    }\n}",
        "o": [
            "Percentile-based adaptive timeout with safety margin",
            "Fixed timeout value",
            "Random timeout selection",
            "No timeout calculation"
        ]
    },
    {
        "q": "Which pattern ensures API mutual TLS authentication?",
        "type": "mcq",
        "o": [
            "Client certificate validation with certificate pinning",
            "Server TLS only",
            "No TLS verification",
            "Self-signed certificates without validation"
        ]
    },
    {
        "q": "Match API scalability dimensions:",
        "type": "match",
        "left": [
            "Horizontal",
            "Vertical",
            "Functional",
            "Geographic"
        ],
        "right": [
            "Add more instances",
            "Add more resources",
            "Decompose services",
            "Add more regions"
        ]
    },
    {
        "q": "API gateways should implement defense in depth security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Trace-Sampled header indicates trace ______ decision.",
        "type": "fill_blank",
        "answers": [
            "sampling"
        ],
        "other_options": [
            "recording",
            "exporting",
            "processing"
        ]
    },
    {
        "q": "What is the output of this request weight calculator?",
        "type": "mcq",
        "c": "class RequestWeightCalculator {\n    constructor(weights) {\n        this.weights = weights;\n    }\n    calculate(request) {\n        let weight = 1;\n        if (request.hasAttachment) weight *= this.weights.attachment;\n        if (request.queryComplexity > 5) weight *= this.weights.complex;\n        if (request.priority === 'low') weight *= this.weights.lowPriority;\n        return weight;\n    }\n    consumeQuota(userId, weight) {\n        const remaining = this.getRemainingQuota(userId);\n        if (remaining < weight) return false;\n        this.quotas.set(userId, remaining - weight);\n        return true;\n    }\n}",
        "o": [
            "Weighted quota consumption based on request complexity",
            "Equal weight for all requests",
            "No quota management",
            "Random weight assignment"
        ]
    },
    {
        "q": "Which approach handles API data locality optimization?",
        "type": "mcq",
        "o": [
            "Geo-routing with regional data affinity and edge caching",
            "Centralized data storage only",
            "No locality optimization",
            "Client-side caching only"
        ]
    },
    {
        "q": "Match advanced API patterns:",
        "type": "match",
        "left": [
            "CQRS",
            "Event sourcing",
            "Saga",
            "Strangler fig"
        ],
        "right": [
            "Command-query separation",
            "Event history storage",
            "Distributed transactions",
            "Incremental migration"
        ]
    },
    {
        "q": "What is the output of this connection multiplexer implementation?",
        "type": "mcq",
        "c": "class ConnectionMultiplexer {\n    constructor(maxStreams = 100) {\n        this.streams = new Map();\n        this.maxStreams = maxStreams;\n        this.nextId = 0;\n    }\n    createStream() {\n        if (this.streams.size >= this.maxStreams) {\n            throw new Error('Max streams reached');\n        }\n        const id = this.nextId++;\n        this.streams.set(id, { id, state: 'open' });\n        return id;\n    }\n    closeStream(id) {\n        this.streams.delete(id);\n    }\n}",
        "o": [
            "HTTP/2 style stream multiplexing with limits",
            "Single connection only",
            "Unlimited streams",
            "No stream management"
        ]
    },
    {
        "q": "Which technique prevents request amplification attacks?",
        "type": "mcq",
        "o": [
            "Response size limits with source verification",
            "Unlimited response sizes",
            "No input validation",
            "Open recursive queries"
        ]
    },
    {
        "q": "The X-Forwarded-Prefix header indicates the original request ______.",
        "type": "fill_blank",
        "answers": [
            "path prefix"
        ],
        "other_options": [
            "host",
            "port",
            "protocol"
        ]
    },
    {
        "q": "Match API observability pillars:",
        "type": "match",
        "left": [
            "Metrics",
            "Logs",
            "Traces",
            "Events"
        ],
        "right": [
            "Numeric measurements",
            "Textual records",
            "Request flows",
            "State changes"
        ]
    },
    {
        "q": "What is the output of this request validator?",
        "type": "mcq",
        "c": "class RequestValidator {\n    constructor(schema) {\n        this.schema = schema;\n    }\n    validate(request) {\n        const errors = [];\n        for (const [field, rules] of Object.entries(this.schema)) {\n            if (rules.required && !request[field]) {\n                errors.push({ field, error: 'required' });\n            }\n            if (rules.type && typeof request[field] !== rules.type) {\n                errors.push({ field, error: 'type_mismatch' });\n            }\n        }\n        return { valid: errors.length === 0, errors };\n    }\n}",
        "o": [
            "Schema-based request validation with detailed errors",
            "No validation",
            "Type checking only",
            "Required fields only"
        ]
    },
    {
        "q": "HTTP/2 uses HPACK for efficient header compression.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which pattern handles cross-cutting concerns in APIs?",
        "type": "mcq",
        "o": [
            "Middleware chain with interceptors",
            "Duplicate code in handlers",
            "No cross-cutting support",
            "Client-side handling only"
        ]
    },
    {
        "q": "The X-Real-IP header provides the actual client ______.",
        "type": "fill_blank",
        "answers": [
            "IP address"
        ],
        "other_options": [
            "hostname",
            "user agent",
            "port"
        ]
    },
    {
        "q": "What is the output of this response transformer?",
        "type": "mcq",
        "c": "class ResponseTransformer {\n    constructor(transforms) {\n        this.transforms = transforms;\n    }\n    transform(response) {\n        return this.transforms.reduce(\n            (res, transform) => transform(res),\n            response\n        );\n    }\n}\nconst t = new ResponseTransformer([\n    r => ({ ...r, processed: true }),\n    r => ({ ...r, timestamp: Date.now() })\n]);\nconsole.log(Object.keys(t.transform({ data: 'test' })).length);",
        "o": [
            "3",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Match HTTP request components:",
        "type": "match",
        "left": [
            "Method",
            "URI",
            "Headers",
            "Body"
        ],
        "right": [
            "Action type",
            "Resource path",
            "Metadata",
            "Payload"
        ]
    },
    {
        "q": "Rearrange the TLS handshake steps:",
        "type": "rearrange",
        "words": [
            "Client Hello",
            "Server Hello",
            "Certificate",
            "Key Exchange",
            "Finished"
        ]
    },
    {
        "q": "The X-Content-Duration header specifies media ______ in seconds.",
        "type": "fill_blank",
        "answers": [
            "duration"
        ],
        "other_options": [
            "size",
            "format",
            "quality"
        ]
    },
    {
        "q": "Which approach handles API response pagination efficiently?",
        "type": "mcq",
        "o": [
            "Cursor-based pagination with stateless tokens",
            "Offset pagination only",
            "Load all at once",
            "No pagination support"
        ]
    },
    {
        "q": "What is the output of this cache key generator?",
        "type": "mcq",
        "c": "function generateCacheKey(request) {\n    const parts = [\n        request.method,\n        request.url,\n        JSON.stringify(request.query || {})\n    ];\n    return crypto.createHash('sha256')\n        .update(parts.join('|'))\n        .digest('hex');\n}\nconsole.log(generateCacheKey({ method: 'GET', url: '/api' }).length);",
        "o": [
            "64",
            "32",
            "128",
            "undefined"
        ]
    },
    {
        "q": "Match API authentication token types:",
        "type": "match",
        "left": [
            "Access token",
            "Refresh token",
            "ID token",
            "API key"
        ],
        "right": [
            "Resource access",
            "Token renewal",
            "User identity",
            "App identification"
        ]
    },
    {
        "q": "HTTP/3 connection reuse works across network switches.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Download-Options header controls file ______.",
        "type": "fill_blank",
        "answers": [
            "download behavior"
        ],
        "other_options": [
            "upload limits",
            "compression",
            "caching"
        ]
    },
    {
        "q": "What is the output of this request router?",
        "type": "mcq",
        "c": "class Router {\n    constructor() {\n        this.routes = [];\n    }\n    add(method, path, handler) {\n        this.routes.push({ method, path, handler });\n    }\n    match(method, path) {\n        return this.routes.find(\n            r => r.method === method && r.path === path\n        )?.handler || null;\n    }\n}\nconst router = new Router();\nrouter.add('GET', '/users', () => 'list');\nconsole.log(router.match('GET', '/users')());",
        "o": [
            "list",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which header prevents clickjacking attacks?",
        "type": "mcq",
        "o": [
            "X-Frame-Options or Content-Security-Policy frame-ancestors",
            "X-Content-Type-Options",
            "X-XSS-Protection",
            "Referrer-Policy"
        ]
    },
    {
        "q": "Match HTTP status code categories:",
        "type": "match",
        "left": [
            "1xx",
            "2xx",
            "3xx",
            "4xx",
            "5xx"
        ],
        "right": [
            "Informational",
            "Success",
            "Redirect",
            "Client error",
            "Server error"
        ]
    },
    {
        "q": "Rearrange the request lifecycle phases:",
        "type": "rearrange",
        "words": [
            "Receive",
            "Parse",
            "Route",
            "Handle",
            "Respond"
        ]
    },
    {
        "q": "The X-Permitted-Cross-Domain-Policies header controls cross-domain ______.",
        "type": "fill_blank",
        "answers": [
            "policy files"
        ],
        "other_options": [
            "requests",
            "cookies",
            "storage"
        ]
    },
    {
        "q": "What is the output of this header parser?",
        "type": "mcq",
        "c": "function parseHeaders(rawHeaders) {\n    const headers = {};\n    for (const line of rawHeaders.split('\\n')) {\n        const [key, ...values] = line.split(':');\n        if (key) headers[key.trim().toLowerCase()] = values.join(':').trim();\n    }\n    return headers;\n}\nconst h = parseHeaders('Content-Type: application/json\\nX-Custom: value');\nconsole.log(Object.keys(h).length);",
        "o": [
            "2",
            "1",
            "3",
            "0"
        ]
    },
    {
        "q": "Which technique improves API response compression?",
        "type": "mcq",
        "o": [
            "Brotli with pre-compression for static content",
            "No compression",
            "Compress everything equally",
            "Client-side compression only"
        ]
    },
    {
        "q": "Match request body parsing strategies:",
        "type": "match",
        "left": [
            "JSON",
            "Form data",
            "Multipart",
            "Raw"
        ],
        "right": [
            "Structured data",
            "Key-value pairs",
            "File uploads",
            "Binary content"
        ]
    },
    {
        "q": "API endpoints should use nouns for resources not verbs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-DNS-Prefetch-Control header manages DNS ______.",
        "type": "fill_blank",
        "answers": [
            "prefetching"
        ],
        "other_options": [
            "caching",
            "resolution",
            "validation"
        ]
    },
    {
        "q": "What is the output of this URL router with parameters?",
        "type": "mcq",
        "c": "class ParamRouter {\n    constructor() {\n        this.routes = new Map();\n    }\n    add(pattern, handler) {\n        this.routes.set(pattern, handler);\n    }\n    match(path) {\n        for (const [pattern, handler] of this.routes) {\n            const regex = new RegExp('^' + pattern.replace(/:([^/]+)/g, '([^/]+)') + '$');\n            const match = path.match(regex);\n            if (match) return { handler, params: match.slice(1) };\n        }\n        return null;\n    }\n}\nconst r = new ParamRouter();\nr.add('/users/:id', () => {});\nconsole.log(r.match('/users/123').params[0]);",
        "o": [
            "123",
            "id",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which pattern handles API request queuing?",
        "type": "mcq",
        "o": [
            "Priority queue with fair scheduling",
            "LIFO processing",
            "Random order",
            "No queuing"
        ]
    },
    {
        "q": "Match HTTP cookie attributes:",
        "type": "match",
        "left": [
            "HttpOnly",
            "Secure",
            "SameSite",
            "Path"
        ],
        "right": [
            "No JavaScript access",
            "HTTPS only",
            "Cross-site control",
            "URL scope"
        ]
    },
    {
        "q": "Rearrange the cookie parsing process:",
        "type": "rearrange",
        "words": [
            "Extract header",
            "Split cookies",
            "Parse key-value",
            "Decode values",
            "Return object"
        ]
    },
    {
        "q": "The TE header indicates acceptable transfer ______.",
        "type": "fill_blank",
        "answers": [
            "encodings"
        ],
        "other_options": [
            "formats",
            "types",
            "protocols"
        ]
    },
    {
        "q": "What is the output of this middleware chain?",
        "type": "mcq",
        "c": "class MiddlewareChain {\n    constructor() {\n        this.middlewares = [];\n    }\n    use(fn) {\n        this.middlewares.push(fn);\n    }\n    async execute(ctx) {\n        let index = 0;\n        const next = async () => {\n            if (index < this.middlewares.length) {\n                await this.middlewares[index++](ctx, next);\n            }\n        };\n        await next();\n        return ctx;\n    }\n}\nconst chain = new MiddlewareChain();\nchain.use(async (ctx, next) => { ctx.a = 1; await next(); });\nchain.use(async (ctx, next) => { ctx.b = 2; await next(); });\nchain.execute({}).then(r => console.log(r.a + r.b));",
        "o": [
            "3",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Which header indicates content language?",
        "type": "mcq",
        "o": [
            "Content-Language",
            "Accept-Language",
            "Language",
            "Locale"
        ]
    },
    {
        "q": "Match URL encoding characters:",
        "type": "match",
        "left": [
            "%20",
            "%2F",
            "%3A",
            "%3F"
        ],
        "right": [
            "Space",
            "Slash",
            "Colon",
            "Question mark"
        ]
    },
    {
        "q": "HTTP methods are case-sensitive according to the specification.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Trailer header lists headers sent after message ______.",
        "type": "fill_blank",
        "answers": [
            "body"
        ],
        "other_options": [
            "headers",
            "start",
            "metadata"
        ]
    },
    {
        "q": "What is the output of this query string builder?",
        "type": "mcq",
        "c": "class QueryBuilder {\n    constructor() {\n        this.params = new URLSearchParams();\n    }\n    add(key, value) {\n        this.params.append(key, value);\n        return this;\n    }\n    toString() {\n        return this.params.toString();\n    }\n}\nconst qb = new QueryBuilder();\nqb.add('a', '1').add('b', '2');\nconsole.log(qb.toString());",
        "o": [
            "a=1&b=2",
            "a=1,b=2",
            "{a:1,b:2}",
            "undefined"
        ]
    },
    {
        "q": "Which approach handles API request decompression?",
        "type": "mcq",
        "o": [
            "Check Content-Encoding and decompress accordingly",
            "Always assume uncompressed",
            "Client handles decompression",
            "No decompression support"
        ]
    },
    {
        "q": "Match HTTP/2 pseudo-headers:",
        "type": "match",
        "left": [
            ":method",
            ":path",
            ":scheme",
            ":authority"
        ],
        "right": [
            "Request method",
            "Request path",
            "Protocol",
            "Host"
        ]
    },
    {
        "q": "Rearrange the response building process:",
        "type": "rearrange",
        "words": [
            "Set status",
            "Add headers",
            "Prepare body",
            "Apply encoding",
            "Send"
        ]
    },
    {
        "q": "The Accept-Ranges header indicates support for range ______.",
        "type": "fill_blank",
        "answers": [
            "requests"
        ],
        "other_options": [
            "limits",
            "formats",
            "types"
        ]
    },
    {
        "q": "What is the output of this response streamer?",
        "type": "mcq",
        "c": "class ResponseStreamer {\n    constructor(response) {\n        this.response = response;\n        this.chunks = [];\n    }\n    write(chunk) {\n        this.chunks.push(chunk);\n        return this;\n    }\n    end() {\n        return this.chunks.join('');\n    }\n}\nconst streamer = new ResponseStreamer({});\nstreamer.write('Hello ').write('World');\nconsole.log(streamer.end());",
        "o": [
            "Hello World",
            "HelloWorld",
            "Hello",
            "World"
        ]
    },
    {
        "q": "Which status code indicates a successful partial content response?",
        "type": "mcq",
        "o": [
            "206 Partial Content",
            "200 OK",
            "201 Created",
            "204 No Content"
        ]
    },
    {
        "q": "Match request authentication methods:",
        "type": "match",
        "left": [
            "Bearer token",
            "Basic auth",
            "Digest auth",
            "Certificate"
        ],
        "right": [
            "Authorization header",
            "Base64 credentials",
            "Hashed credentials",
            "Client cert"
        ]
    },
    {
        "q": "API responses should include Cache-Control headers by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Max-Forwards header limits request ______.",
        "type": "fill_blank",
        "answers": [
            "forwarding"
        ],
        "other_options": [
            "retries",
            "redirects",
            "timeouts"
        ]
    },
    {
        "q": "What is the output of this ETag generator?",
        "type": "mcq",
        "c": "function generateETag(content) {\n    const hash = crypto.createHash('md5')\n        .update(content)\n        .digest('hex');\n    return `\"${hash}\"`;\n}\nconsole.log(generateETag('test').startsWith('\"'));",
        "o": [
            "true",
            "false",
            "\"",
            "undefined"
        ]
    },
    {
        "q": "Which header indicates the resource's last modification?",
        "type": "mcq",
        "o": [
            "Last-Modified",
            "Date",
            "Modified-Since",
            "Updated-At"
        ]
    },
    {
        "q": "Match content disposition types:",
        "type": "match",
        "left": [
            "inline",
            "attachment",
            "form-data",
            "signal"
        ],
        "right": [
            "Display in browser",
            "Force download",
            "Form submission",
            "Notification"
        ]
    },
    {
        "q": "Rearrange the conditional GET process:",
        "type": "rearrange",
        "words": [
            "Send If-None-Match",
            "Server checks ETag",
            "Compare values",
            "Return 304 or 200"
        ]
    },
    {
        "q": "The Range header requests partial ______.",
        "type": "fill_blank",
        "answers": [
            "content"
        ],
        "other_options": [
            "headers",
            "metadata",
            "resources"
        ]
    },
    {
        "q": "What is the output of this status code checker?",
        "type": "mcq",
        "c": "function isRedirect(status) {\n    return status >= 300 && status < 400;\n}\nconsole.log([301, 302, 200, 404].filter(isRedirect));",
        "o": [
            "[301, 302]",
            "[200, 404]",
            "[301]",
            "[]"
        ]
    },
    {
        "q": "Which approach handles multipart form data?",
        "type": "mcq",
        "o": [
            "Parse boundary-separated parts with content headers",
            "JSON parsing only",
            "URL encoding only",
            "No file support"
        ]
    },
    {
        "q": "Match HTTP cache directives:",
        "type": "match",
        "left": [
            "max-age",
            "s-maxage",
            "private",
            "public"
        ],
        "right": [
            "Any cache TTL",
            "Shared cache TTL",
            "User cache only",
            "Any cache allowed"
        ]
    },
    {
        "q": "HTTP pipelining is deprecated in favor of multiplexing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Content-Range header specifies returned content ______.",
        "type": "fill_blank",
        "answers": [
            "portion"
        ],
        "other_options": [
            "type",
            "length",
            "format"
        ]
    },
    {
        "q": "What is the output of this CORS validator?",
        "type": "mcq",
        "c": "class CORSValidator {\n    constructor(allowedOrigins) {\n        this.origins = new Set(allowedOrigins);\n    }\n    isAllowed(origin) {\n        return this.origins.has(origin) || this.origins.has('*');\n    }\n}\nconst cors = new CORSValidator(['https://example.com', '*']);\nconsole.log(cors.isAllowed('https://other.com'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which header specifies allowed methods for CORS?",
        "type": "mcq",
        "o": [
            "Access-Control-Allow-Methods",
            "Allow",
            "Methods",
            "Allowed-Methods"
        ]
    },
    {
        "q": "Match request body size limits:",
        "type": "match",
        "left": [
            "413",
            "414",
            "431",
            "507"
        ],
        "right": [
            "Payload too large",
            "URI too long",
            "Headers too large",
            "Insufficient storage"
        ]
    },
    {
        "q": "Rearrange the preflight request flow:",
        "type": "rearrange",
        "words": [
            "Browser sends OPTIONS",
            "Check allowed origins",
            "Return CORS headers",
            "Browser sends actual request"
        ]
    },
    {
        "q": "The Access-Control-Max-Age header caches preflight for ______ seconds.",
        "type": "fill_blank",
        "answers": [
            "specified"
        ],
        "other_options": [
            "unlimited",
            "minimum",
            "default"
        ]
    },
    {
        "q": "What is the output of this request ID generator?",
        "type": "mcq",
        "c": "function generateRequestId() {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `${timestamp}-${random}`;\n}\nconsole.log(generateRequestId().includes('-'));",
        "o": [
            "true",
            "false",
            "-",
            "undefined"
        ]
    },
    {
        "q": "Which pattern handles request context propagation?",
        "type": "mcq",
        "o": [
            "AsyncLocalStorage or context objects",
            "Global variables",
            "No context support",
            "Query parameters only"
        ]
    },
    {
        "q": "Match HTTP date formats:",
        "type": "match",
        "left": [
            "IMF-fixdate",
            "RFC 850",
            "ANSI C",
            "ISO 8601"
        ],
        "right": [
            "Sun, 06 Nov 1994",
            "Sunday, 06-Nov-94",
            "Sun Nov  6",
            "1994-11-06"
        ]
    },
    {
        "q": "HTTP/1.1 requires Host header in all requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Age header indicates cache freshness in ______.",
        "type": "fill_blank",
        "answers": [
            "seconds"
        ],
        "other_options": [
            "minutes",
            "hours",
            "milliseconds"
        ]
    },
    {
        "q": "What is the output of this header normalizer?",
        "type": "mcq",
        "c": "function normalizeHeaderName(name) {\n    return name.toLowerCase().split('-')\n        .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n        .join('-');\n}\nconsole.log(normalizeHeaderName('content-type'));",
        "o": [
            "Content-Type",
            "content-type",
            "CONTENT-TYPE",
            "contentType"
        ]
    },
    {
        "q": "Which status code indicates a precondition failed?",
        "type": "mcq",
        "o": [
            "412 Precondition Failed",
            "428 Precondition Required",
            "400 Bad Request",
            "409 Conflict"
        ]
    },
    {
        "q": "Match response caching strategies:",
        "type": "match",
        "left": [
            "No-store",
            "No-cache",
            "Must-revalidate",
            "Immutable"
        ],
        "right": [
            "Never cache",
            "Validate first",
            "Expired must validate",
            "Never changes"
        ]
    },
    {
        "q": "Rearrange the response validation flow:",
        "type": "rearrange",
        "words": [
            "Check status",
            "Validate headers",
            "Parse body",
            "Handle errors",
            "Return data"
        ]
    },
    {
        "q": "The Warning header conveys additional information about message ______.",
        "type": "fill_blank",
        "answers": [
            "status"
        ],
        "other_options": [
            "content",
            "sender",
            "receiver"
        ]
    },
    {
        "q": "What is the output of this cookie parser?",
        "type": "mcq",
        "c": "function parseCookies(cookieHeader) {\n    return cookieHeader.split(';').reduce((acc, pair) => {\n        const [key, value] = pair.trim().split('=');\n        acc[key] = value;\n        return acc;\n    }, {});\n}\nconst cookies = parseCookies('name=value; session=abc');\nconsole.log(Object.keys(cookies).length);",
        "o": [
            "2",
            "1",
            "3",
            "0"
        ]
    },
    {
        "q": "Which header indicates the origin of the request?",
        "type": "mcq",
        "o": [
            "Origin",
            "Referer",
            "Host",
            "From"
        ]
    },
    {
        "q": "Match request header purposes:",
        "type": "match",
        "left": [
            "Host",
            "User-Agent",
            "Accept",
            "Authorization"
        ],
        "right": [
            "Server identity",
            "Client identity",
            "Preferred format",
            "Credentials"
        ]
    },
    {
        "q": "The Expect header allows clients to check server capabilities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Referer header contains the previous page ______.",
        "type": "fill_blank",
        "answers": [
            "URL"
        ],
        "other_options": [
            "title",
            "content",
            "server"
        ]
    },
    {
        "q": "What is the output of this URL path normalizer?",
        "type": "mcq",
        "c": "function normalizePath(path) {\n    return path\n        .replace(/\\/+/g, '/')\n        .replace(/\\/$/, '')\n        .replace(/^\\//, '/');\n}\nconsole.log(normalizePath('//api//users//'));",
        "o": [
            "/api/users",
            "//api//users//",
            "/api/users/",
            "api/users"
        ]
    },
    {
        "q": "Which status code indicates the method is not allowed?",
        "type": "mcq",
        "o": [
            "405 Method Not Allowed",
            "400 Bad Request",
            "403 Forbidden",
            "404 Not Found"
        ]
    },
    {
        "q": "Match request timing metrics:",
        "type": "match",
        "left": [
            "DNS",
            "Connect",
            "TLS",
            "Wait"
        ],
        "right": [
            "Name resolution",
            "TCP handshake",
            "Security setup",
            "Server processing"
        ]
    },
    {
        "q": "Rearrange the connection establishment:",
        "type": "rearrange",
        "words": [
            "DNS lookup",
            "TCP connect",
            "TLS negotiate",
            "Send request",
            "Receive response"
        ]
    },
    {
        "q": "The DNT header indicates Do Not ______.",
        "type": "fill_blank",
        "answers": [
            "Track"
        ],
        "other_options": [
            "Transfer",
            "Throttle",
            "Terminate"
        ]
    },
    {
        "q": "What is the output of this request timer?",
        "type": "mcq",
        "c": "class RequestTimer {\n    constructor() {\n        this.timings = {};\n    }\n    start(phase) {\n        this.timings[phase] = { start: Date.now() };\n    }\n    end(phase) {\n        this.timings[phase].end = Date.now();\n        this.timings[phase].duration = this.timings[phase].end - this.timings[phase].start;\n    }\n    getTiming(phase) {\n        return this.timings[phase]?.duration;\n    }\n}\nconst timer = new RequestTimer();\ntimer.start('test');\ntimer.end('test');\nconsole.log(typeof timer.getTiming('test'));",
        "o": [
            "number",
            "undefined",
            "object",
            "string"
        ]
    },
    {
        "q": "Which header controls browser feature permissions?",
        "type": "mcq",
        "o": [
            "Permissions-Policy",
            "Feature-Policy",
            "Content-Security-Policy",
            "X-Frame-Options"
        ]
    },
    {
        "q": "Match browser storage mechanisms:",
        "type": "match",
        "left": [
            "Cookies",
            "LocalStorage",
            "SessionStorage",
            "IndexedDB"
        ],
        "right": [
            "Server-sent data",
            "Persistent key-value",
            "Session key-value",
            "Structured database"
        ]
    },
    {
        "q": "Cross-origin requests include credentials only when explicitly enabled.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The Sec-Fetch-Site header indicates request origin ______.",
        "type": "fill_blank",
        "answers": [
            "relationship"
        ],
        "other_options": [
            "location",
            "type",
            "protocol"
        ]
    },
    {
        "q": "What is the output of this base URL resolver?",
        "type": "mcq",
        "c": "function resolveUrl(base, path) {\n    try {\n        return new URL(path, base).href;\n    } catch {\n        return null;\n    }\n}\nconsole.log(resolveUrl('https://api.com', '/users'));",
        "o": [
            "https://api.com/users",
            "/users",
            "null",
            "undefined"
        ]
    },
    {
        "q": "Which technique improves API discoverability?",
        "type": "mcq",
        "o": [
            "HATEOAS with Link headers",
            "No links in responses",
            "Static documentation only",
            "Hardcoded URLs"
        ]
    },
    {
        "q": "Match API response status patterns:",
        "type": "match",
        "left": [
            "200",
            "201",
            "204",
            "404"
        ],
        "right": [
            "Success with body",
            "Created resource",
            "Success no body",
            "Not found"
        ]
    },
    {
        "q": "What is the output of this request body parser?",
        "type": "mcq",
        "c": "async function parseBody(request) {\n    const contentType = request.headers['content-type'];\n    if (contentType?.includes('application/json')) {\n        return JSON.parse(await request.text());\n    }\n    return null;\n}\n// Returns parsed JSON for JSON content-type, null otherwise",
        "o": [
            "Parses JSON based on Content-Type header",
            "Always parses as JSON",
            "Never parses body",
            "Returns raw text only"
        ]
    },
    {
        "q": "Which approach handles API versioning deprecation notices?",
        "type": "mcq",
        "o": [
            "Deprecation and Sunset headers with migration documentation",
            "Immediate version removal",
            "No deprecation notices",
            "Silent version changes"
        ]
    },
    {
        "q": "The Via header shows proxy chain ______.",
        "type": "fill_blank",
        "answers": [
            "information"
        ],
        "other_options": [
            "identity",
            "location",
            "settings"
        ]
    },
    {
        "q": "Match HTTP request body types:",
        "type": "match",
        "left": [
            "application/json",
            "text/plain",
            "multipart/form-data",
            "application/octet-stream"
        ],
        "right": [
            "Structured data",
            "Plain text",
            "Form with files",
            "Binary data"
        ]
    },
    {
        "q": "What is the output of this URL query decoder?",
        "type": "mcq",
        "c": "function decodeQuery(queryString) {\n    const params = new URLSearchParams(queryString);\n    const result = {};\n    for (const [key, value] of params) {\n        result[key] = value;\n    }\n    return result;\n}\nconsole.log(decodeQuery('name=test&value=123').name);",
        "o": [
            "test",
            "value",
            "123",
            "undefined"
        ]
    },
    {
        "q": "HTTP/2 server push requires client opt-in.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "Which status code indicates the resource has not been modified?",
        "type": "mcq",
        "o": [
            "304 Not Modified",
            "204 No Content",
            "200 OK",
            "302 Found"
        ]
    },
    {
        "q": "The Upgrade-Insecure-Requests header requests HTTPS ______.",
        "type": "fill_blank",
        "answers": [
            "upgrade"
        ],
        "other_options": [
            "downgrade",
            "redirect",
            "fallback"
        ]
    },
    {
        "q": "What is the output of this response header builder?",
        "type": "mcq",
        "c": "class HeaderBuilder {\n    constructor() {\n        this.headers = {};\n    }\n    set(key, value) {\n        this.headers[key] = value;\n        return this;\n    }\n    build() {\n        return Object.entries(this.headers)\n            .map(([k, v]) => `${k}: ${v}`)\n            .join('\\n');\n    }\n}\nconst hb = new HeaderBuilder();\nhb.set('Content-Type', 'application/json').set('X-Custom', 'value');\nconsole.log(hb.build().includes('Content-Type'));",
        "o": [
            "true",
            "false",
            "Content-Type",
            "undefined"
        ]
    },
    {
        "q": "Match HTTP message parts:",
        "type": "match",
        "left": [
            "Start line",
            "Headers",
            "Empty line",
            "Body"
        ],
        "right": [
            "Method or status",
            "Metadata",
            "Header delimiter",
            "Payload"
        ]
    },
    {
        "q": "Rearrange the HTTP/2 frame structure:",
        "type": "rearrange",
        "words": [
            "Length",
            "Type",
            "Flags",
            "Stream ID",
            "Payload"
        ]
    },
    {
        "q": "The From header contains requester ______ address.",
        "type": "fill_blank",
        "answers": [
            "email"
        ],
        "other_options": [
            "IP",
            "name",
            "location"
        ]
    },
    {
        "q": "What is the output of this status line parser?",
        "type": "mcq",
        "c": "function parseStatusLine(line) {\n    const [version, status, ...reason] = line.split(' ');\n    return {\n        version,\n        status: parseInt(status),\n        reason: reason.join(' ')\n    };\n}\nconst parsed = parseStatusLine('HTTP/1.1 200 OK');\nconsole.log(parsed.status);",
        "o": [
            "200",
            "HTTP/1.1",
            "OK",
            "undefined"
        ]
    },
    {
        "q": "Which header indicates request cacheability?",
        "type": "mcq",
        "o": [
            "Cache-Control",
            "Content-Type",
            "Accept",
            "Authorization"
        ]
    },
    {
        "q": "HTTP headers are case-insensitive according to specification.",
        "type": "true_false",
        "correct": "True"
    }
]