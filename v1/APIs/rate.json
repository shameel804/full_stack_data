[
    {
        "q": "What is rate limiting?",
        "type": "mcq",
        "o": [
            "Controlling the number of requests a client can make",
            "Speeding up requests",
            "Caching responses",
            "Encrypting data"
        ]
    },
    {
        "q": "Rate limiting protects APIs from ______.",
        "type": "fill_blank",
        "answers": [
            "abuse"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Rate limiting helps prevent server overload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match rate limiting benefits:",
        "type": "match",
        "left": [
            "Protection",
            "Fairness",
            "Availability",
            "Cost control"
        ],
        "right": [
            "Prevent abuse",
            "Equal access",
            "Keep running",
            "Manage resources"
        ]
    },
    {
        "q": "Rearrange rate limiting flow:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check rate limit",
            "Increment counter",
            "Allow or reject",
            "Send response"
        ]
    },
    {
        "q": "What is throttling?",
        "type": "mcq",
        "o": [
            "Slowing down request processing",
            "Speeding up requests",
            "Caching data",
            "Encrypting traffic"
        ]
    },
    {
        "q": "Throttling ______ the rate of requests.",
        "type": "fill_blank",
        "answers": [
            "reduces"
        ],
        "other_options": [
            "increases",
            "maintains",
            "ignores"
        ]
    },
    {
        "q": "Throttling can delay requests instead of rejecting them.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match rate control types:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Throttling",
            "Quota",
            "Burst"
        ],
        "right": [
            "Block excess",
            "Slow down",
            "Total limit",
            "Temporary spike"
        ]
    },
    {
        "q": "What is a request quota?",
        "type": "mcq",
        "o": [
            "Total number of requests allowed in a period",
            "Request speed",
            "Request size",
            "Request priority"
        ]
    },
    {
        "q": "Quotas are typically measured in ______.",
        "type": "fill_blank",
        "answers": [
            "requests per period"
        ],
        "other_options": [
            "bytes",
            "milliseconds",
            "users"
        ]
    },
    {
        "q": "Daily quotas reset every 24 hours.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match quota periods:",
        "type": "match",
        "left": [
            "Second",
            "Minute",
            "Hour",
            "Day"
        ],
        "right": [
            "1000ms",
            "60s",
            "3600s",
            "86400s"
        ]
    },
    {
        "q": "Rearrange quota check:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Get current usage",
            "Compare to quota",
            "Decide allow/deny",
            "Update counter"
        ]
    },
    {
        "q": "What is requests per second?",
        "type": "mcq",
        "o": [
            "Rate limit measured per second",
            "Total requests ever",
            "Request size",
            "Response time"
        ]
    },
    {
        "q": "RPS stands for requests per ______.",
        "type": "fill_blank",
        "answers": [
            "second"
        ],
        "other_options": [
            "minute",
            "hour",
            "day"
        ]
    },
    {
        "q": "100 RPS means 100 requests allowed per second.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match rate units:",
        "type": "match",
        "left": [
            "RPS",
            "RPM",
            "RPH",
            "RPD"
        ],
        "right": [
            "Per second",
            "Per minute",
            "Per hour",
            "Per day"
        ]
    },
    {
        "q": "What is a rate limit window?",
        "type": "mcq",
        "o": [
            "Time period for counting requests",
            "API dashboard",
            "Error message",
            "Response header"
        ]
    },
    {
        "q": "A sliding window moves with ______.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "users",
            "requests",
            "data"
        ]
    },
    {
        "q": "Fixed windows reset at specific intervals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match window types:",
        "type": "match",
        "left": [
            "Fixed",
            "Sliding",
            "Rolling",
            "Tumbling"
        ],
        "right": [
            "Set boundaries",
            "Continuous",
            "Moving average",
            "Non-overlapping"
        ]
    },
    {
        "q": "Rearrange window operation:",
        "type": "rearrange",
        "words": [
            "Define window",
            "Track requests",
            "Check threshold",
            "Reset if needed",
            "Continue"
        ]
    },
    {
        "q": "What header indicates rate limit status?",
        "type": "mcq",
        "o": [
            "X-RateLimit headers",
            "Content-Type",
            "Cache-Control",
            "Authorization"
        ]
    },
    {
        "q": "X-RateLimit-Limit shows ______ allowed requests.",
        "type": "fill_blank",
        "answers": [
            "maximum"
        ],
        "other_options": [
            "minimum",
            "current",
            "average"
        ]
    },
    {
        "q": "X-RateLimit-Remaining shows remaining requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match rate limit headers:",
        "type": "match",
        "left": [
            "Limit",
            "Remaining",
            "Reset",
            "Retry-After"
        ],
        "right": [
            "Max allowed",
            "Requests left",
            "Window reset",
            "Wait time"
        ]
    },
    {
        "q": "What status code indicates rate limiting?",
        "type": "mcq",
        "o": [
            "429 Too Many Requests",
            "200 OK",
            "404 Not Found",
            "500 Internal Server Error"
        ]
    },
    {
        "q": "429 status code means ______.",
        "type": "fill_blank",
        "answers": [
            "too many requests"
        ],
        "other_options": [
            "not found",
            "unauthorized",
            "server error"
        ]
    },
    {
        "q": "429 responses should include Retry-After header.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match HTTP status codes:",
        "type": "match",
        "left": [
            "429",
            "503",
            "504",
            "202"
        ],
        "right": [
            "Rate limited",
            "Unavailable",
            "Gateway timeout",
            "Accepted"
        ]
    },
    {
        "q": "Rearrange 429 handling:",
        "type": "rearrange",
        "words": [
            "Receive 429",
            "Read Retry-After",
            "Wait specified time",
            "Retry request",
            "Process response"
        ]
    },
    {
        "q": "What is the token bucket algorithm?",
        "type": "mcq",
        "o": [
            "Rate limiting using tokens that refill over time",
            "Authentication method",
            "Encryption algorithm",
            "Caching strategy"
        ]
    },
    {
        "q": "Tokens are consumed per ______.",
        "type": "fill_blank",
        "answers": [
            "request"
        ],
        "other_options": [
            "user",
            "second",
            "byte"
        ]
    },
    {
        "q": "Token bucket allows burst traffic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match token bucket terms:",
        "type": "match",
        "left": [
            "Bucket",
            "Tokens",
            "Refill rate",
            "Capacity"
        ],
        "right": [
            "Container",
            "Available requests",
            "Tokens per second",
            "Maximum tokens"
        ]
    },
    {
        "q": "What is the leaky bucket algorithm?",
        "type": "mcq",
        "o": [
            "Requests processed at constant rate",
            "Authentication method",
            "Encryption algorithm",
            "Caching strategy"
        ]
    },
    {
        "q": "Leaky bucket processes requests at ______ rate.",
        "type": "fill_blank",
        "answers": [
            "constant"
        ],
        "other_options": [
            "variable",
            "random",
            "maximum"
        ]
    },
    {
        "q": "Leaky bucket smooths out traffic spikes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match bucket algorithms:",
        "type": "match",
        "left": [
            "Token bucket",
            "Leaky bucket",
            "Fixed window",
            "Sliding window"
        ],
        "right": [
            "Allows bursts",
            "Constant rate",
            "Time slots",
            "Smooth average"
        ]
    },
    {
        "q": "Rearrange leaky bucket:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Add to queue",
            "Process at fixed rate",
            "Drain bucket",
            "Complete request"
        ]
    },
    {
        "q": "What is burst capacity?",
        "type": "mcq",
        "o": [
            "Allowing temporary spikes above normal rate",
            "Maximum speed",
            "Minimum rate",
            "Average rate"
        ]
    },
    {
        "q": "Burst allows temporary ______ requests.",
        "type": "fill_blank",
        "answers": [
            "extra"
        ],
        "other_options": [
            "fewer",
            "slower",
            "same"
        ]
    },
    {
        "q": "Burst capacity helps handle traffic spikes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match burst terms:",
        "type": "match",
        "left": [
            "Burst size",
            "Sustained rate",
            "Peak rate",
            "Recovery time"
        ],
        "right": [
            "Max spike",
            "Normal rate",
            "Maximum rate",
            "Refill time"
        ]
    },
    {
        "q": "What is client-based rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting requests per client",
            "Server limiting",
            "Network limiting",
            "Global limiting"
        ]
    },
    {
        "q": "Client rate limits are typically per ______.",
        "type": "fill_blank",
        "answers": [
            "API key"
        ],
        "other_options": [
            "endpoint",
            "server",
            "method"
        ]
    },
    {
        "q": "Each client can have different rate limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match client identifiers:",
        "type": "match",
        "left": [
            "API key",
            "User ID",
            "IP address",
            "OAuth token"
        ],
        "right": [
            "Application",
            "Account",
            "Network",
            "Authorized user"
        ]
    },
    {
        "q": "Rearrange client rate check:",
        "type": "rearrange",
        "words": [
            "Extract client ID",
            "Look up limits",
            "Check current usage",
            "Apply limit",
            "Record request"
        ]
    },
    {
        "q": "What is IP-based rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting requests per IP address",
            "Client limiting",
            "User limiting",
            "Application limiting"
        ]
    },
    {
        "q": "IP limits protect against ______ from single sources.",
        "type": "fill_blank",
        "answers": [
            "abuse"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Shared IPs can affect innocent users.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match IP considerations:",
        "type": "match",
        "left": [
            "Single IP",
            "Shared IP",
            "Proxy",
            "NAT"
        ],
        "right": [
            "One user",
            "Multiple users",
            "Intermediate",
            "Address translation"
        ]
    },
    {
        "q": "What is endpoint-based rate limiting?",
        "type": "mcq",
        "o": [
            "Different limits for different endpoints",
            "Same limit everywhere",
            "No limits",
            "Global limit only"
        ]
    },
    {
        "q": "Sensitive endpoints may have ______ limits.",
        "type": "fill_blank",
        "answers": [
            "lower"
        ],
        "other_options": [
            "higher",
            "no",
            "same"
        ]
    },
    {
        "q": "Read endpoints often have higher limits than write.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match endpoint limits:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "DELETE",
            "Admin"
        ],
        "right": [
            "High limit",
            "Medium limit",
            "Low limit",
            "Very low limit"
        ]
    },
    {
        "q": "Rearrange endpoint limiting:",
        "type": "rearrange",
        "words": [
            "Identify endpoint",
            "Look up specific limit",
            "Check usage",
            "Apply decision",
            "Log result"
        ]
    },
    {
        "q": "What is global rate limiting?",
        "type": "mcq",
        "o": [
            "Overall limit across all clients",
            "Per-client limit",
            "Per-IP limit",
            "Per-endpoint limit"
        ]
    },
    {
        "q": "Global limits protect overall ______.",
        "type": "fill_blank",
        "answers": [
            "capacity"
        ],
        "other_options": [
            "user",
            "endpoint",
            "client"
        ]
    },
    {
        "q": "Global limits prevent total system overload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match limit scopes:",
        "type": "match",
        "left": [
            "Global",
            "Regional",
            "Client",
            "Endpoint"
        ],
        "right": [
            "System-wide",
            "Geographic",
            "Per user",
            "Per API path"
        ]
    },
    {
        "q": "What is adaptive rate limiting?",
        "type": "mcq",
        "o": [
            "Adjusting limits based on conditions",
            "Fixed limits",
            "No limits",
            "Static configuration"
        ]
    },
    {
        "q": "Adaptive limiting responds to system ______.",
        "type": "fill_blank",
        "answers": [
            "load"
        ],
        "other_options": [
            "color",
            "name",
            "version"
        ]
    },
    {
        "q": "Limits can change based on server health.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match adaptive triggers:",
        "type": "match",
        "left": [
            "CPU load",
            "Memory",
            "Latency",
            "Error rate"
        ],
        "right": [
            "Processing",
            "Resource usage",
            "Response time",
            "Failure rate"
        ]
    },
    {
        "q": "Rearrange adaptive limiting:",
        "type": "rearrange",
        "words": [
            "Monitor metrics",
            "Evaluate conditions",
            "Calculate new limits",
            "Apply changes",
            "Continue monitoring"
        ]
    },
    {
        "q": "What is tiered rate limiting?",
        "type": "mcq",
        "o": [
            "Different limits for different service tiers",
            "Same limits for all",
            "No limits",
            "Random limits"
        ]
    },
    {
        "q": "Premium users may have ______ limits.",
        "type": "fill_blank",
        "answers": [
            "higher"
        ],
        "other_options": [
            "lower",
            "no",
            "same"
        ]
    },
    {
        "q": "Free tier usually has lower limits than paid.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match service tiers:",
        "type": "match",
        "left": [
            "Free",
            "Basic",
            "Pro",
            "Enterprise"
        ],
        "right": [
            "Low limits",
            "Medium limits",
            "High limits",
            "Custom limits"
        ]
    },
    {
        "q": "What is rate limit bypass?",
        "type": "mcq",
        "o": [
            "Exempting certain clients from limits",
            "Breaking limits",
            "Ignoring limits",
            "Removing limits"
        ]
    },
    {
        "q": "Internal services may ______ rate limits.",
        "type": "fill_blank",
        "answers": [
            "bypass"
        ],
        "other_options": [
            "increase",
            "decrease",
            "remove"
        ]
    },
    {
        "q": "Whitelisting allows bypass for trusted clients.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match bypass scenarios:",
        "type": "match",
        "left": [
            "Internal",
            "Partner",
            "Admin",
            "Health check"
        ],
        "right": [
            "Service-to-service",
            "Trusted external",
            "Privileged user",
            "Monitoring"
        ]
    },
    {
        "q": "Rearrange bypass check:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check whitelist",
            "If whitelisted skip",
            "Else check limit",
            "Process request"
        ]
    },
    {
        "q": "What is rate limit configuration?",
        "type": "mcq",
        "o": [
            "Setting up rate limit parameters",
            "Removing limits",
            "Ignoring limits",
            "Breaking limits"
        ]
    },
    {
        "q": "Configuration defines ______ and thresholds.",
        "type": "fill_blank",
        "answers": [
            "windows"
        ],
        "other_options": [
            "users",
            "data",
            "servers"
        ]
    },
    {
        "q": "Rate limits should be configurable per environment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match configuration items:",
        "type": "match",
        "left": [
            "Threshold",
            "Window",
            "Action",
            "Identifier"
        ],
        "right": [
            "Max requests",
            "Time period",
            "Block or delay",
            "Client key"
        ]
    },
    {
        "q": "What is rate limit monitoring?",
        "type": "mcq",
        "o": [
            "Tracking rate limit usage and violations",
            "Setting limits",
            "Removing limits",
            "Ignoring limits"
        ]
    },
    {
        "q": "Monitoring tracks limit ______.",
        "type": "fill_blank",
        "answers": [
            "violations"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Alerts should trigger on unusual rate limit patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match monitoring metrics:",
        "type": "match",
        "left": [
            "Requests",
            "Rejections",
            "Near-limit",
            "Violations"
        ],
        "right": [
            "Total count",
            "Blocked count",
            "Approaching limit",
            "Exceeded count"
        ]
    },
    {
        "q": "Rearrange monitoring setup:",
        "type": "rearrange",
        "words": [
            "Define metrics",
            "Collect data",
            "Visualize trends",
            "Set alerts",
            "Review regularly"
        ]
    },
    {
        "q": "What is request queuing?",
        "type": "mcq",
        "o": [
            "Holding requests for later processing",
            "Rejecting requests",
            "Speeding requests",
            "Caching requests"
        ]
    },
    {
        "q": "Queuing delays requests instead of ______.",
        "type": "fill_blank",
        "answers": [
            "rejecting"
        ],
        "other_options": [
            "accepting",
            "speeding",
            "caching"
        ]
    },
    {
        "q": "Queues have maximum size limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match queue properties:",
        "type": "match",
        "left": [
            "Size",
            "Timeout",
            "Priority",
            "FIFO"
        ],
        "right": [
            "Max items",
            "Max wait",
            "Order by importance",
            "First in first out"
        ]
    },
    {
        "q": "Rate limiting protects API infrastructure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match protection goals:",
        "type": "match",
        "left": [
            "Availability",
            "Performance",
            "Fairness",
            "Cost"
        ],
        "right": [
            "Keep running",
            "Maintain speed",
            "Equal access",
            "Control spend"
        ]
    },
    {
        "q": "What is distributed rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting across multiple servers",
            "Single server limiting",
            "No limiting",
            "Local limiting"
        ]
    },
    {
        "q": "Distributed rate limiting requires ______.",
        "type": "fill_blank",
        "answers": [
            "synchronization"
        ],
        "other_options": [
            "isolation",
            "no storage",
            "no network"
        ]
    },
    {
        "q": "Redis is commonly used for distributed rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match distributed storage:",
        "type": "match",
        "left": [
            "Redis",
            "Memcached",
            "Database",
            "In-memory"
        ],
        "right": [
            "Key-value",
            "Cached",
            "Persistent",
            "Local only"
        ]
    },
    {
        "q": "Rearrange distributed check:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Query central store",
            "Get current count",
            "Check limit",
            "Update and respond"
        ]
    },
    {
        "q": "What is sliding window log algorithm?",
        "type": "mcq",
        "o": [
            "Storing timestamps of each request",
            "Fixed time slots",
            "Token counting",
            "Queue processing"
        ]
    },
    {
        "q": "Sliding log stores request ______.",
        "type": "fill_blank",
        "answers": [
            "timestamps"
        ],
        "other_options": [
            "sizes",
            "users",
            "endpoints"
        ]
    },
    {
        "q": "Sliding log is more memory intensive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match sliding window variants:",
        "type": "match",
        "left": [
            "Log",
            "Counter",
            "Hybrid",
            "Weighted"
        ],
        "right": [
            "Store timestamps",
            "Count only",
            "Combined",
            "Prioritized"
        ]
    },
    {
        "q": "What is sliding window counter algorithm?",
        "type": "mcq",
        "o": [
            "Weighted average of current and previous windows",
            "Store all timestamps",
            "Token bucket",
            "Leaky bucket"
        ]
    },
    {
        "q": "Sliding counter uses ______ approximation.",
        "type": "fill_blank",
        "answers": [
            "weighted"
        ],
        "other_options": [
            "exact",
            "random",
            "fixed"
        ]
    },
    {
        "q": "Sliding counter is memory efficient.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match algorithm tradeoffs:",
        "type": "match",
        "left": [
            "Memory",
            "Accuracy",
            "Simplicity",
            "Performance"
        ],
        "right": [
            "Space used",
            "Precision",
            "Ease of use",
            "Speed"
        ]
    },
    {
        "q": "Rearrange sliding counter:",
        "type": "rearrange",
        "words": [
            "Get current window",
            "Get previous window",
            "Calculate weighted",
            "Compare to limit",
            "Update counter"
        ]
    },
    {
        "q": "What is rate limit sharding?",
        "type": "mcq",
        "o": [
            "Distributing limits across nodes",
            "Single limit storage",
            "No distribution",
            "Local limits only"
        ]
    },
    {
        "q": "Sharding distributes ______ across nodes.",
        "type": "fill_blank",
        "answers": [
            "load"
        ],
        "other_options": [
            "code",
            "users",
            "requests"
        ]
    },
    {
        "q": "Consistent hashing helps with sharding.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match sharding concepts:",
        "type": "match",
        "left": [
            "Shard",
            "Partition",
            "Replica",
            "Node"
        ],
        "right": [
            "Subset",
            "Division",
            "Copy",
            "Server"
        ]
    },
    {
        "q": "What is rate limit failover?",
        "type": "mcq",
        "o": [
            "Handling rate limit service failures",
            "Normal operation",
            "No backup",
            "Single server"
        ]
    },
    {
        "q": "Failover ensures ______ during outages.",
        "type": "fill_blank",
        "answers": [
            "availability"
        ],
        "other_options": [
            "speed",
            "features",
            "users"
        ]
    },
    {
        "q": "Allow-on-failure is a common failover strategy.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match failover strategies:",
        "type": "match",
        "left": [
            "Allow",
            "Deny",
            "Cached",
            "Degraded"
        ],
        "right": [
            "Permit all",
            "Block all",
            "Use stale",
            "Reduced limits"
        ]
    },
    {
        "q": "Rearrange failover handling:",
        "type": "rearrange",
        "words": [
            "Detect failure",
            "Switch to backup",
            "Apply fallback",
            "Notify ops",
            "Monitor recovery"
        ]
    },
    {
        "q": "What is rate limit circuit breaker?",
        "type": "mcq",
        "o": [
            "Stopping requests when service is failing",
            "Continuing requests",
            "Ignoring failures",
            "Speeding up"
        ]
    },
    {
        "q": "Circuit breakers prevent ______ failures.",
        "type": "fill_blank",
        "answers": [
            "cascading"
        ],
        "other_options": [
            "single",
            "random",
            "expected"
        ]
    },
    {
        "q": "Circuit breakers have open, closed, half-open states.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match circuit states:",
        "type": "match",
        "left": [
            "Closed",
            "Open",
            "Half-open",
            "Disabled"
        ],
        "right": [
            "Normal",
            "Blocked",
            "Testing",
            "Off"
        ]
    },
    {
        "q": "What is backpressure?",
        "type": "mcq",
        "o": [
            "Signaling upstream to slow down",
            "Speeding up",
            "Ignoring limits",
            "No signaling"
        ]
    },
    {
        "q": "Backpressure signals ______ to slow down.",
        "type": "fill_blank",
        "answers": [
            "producers"
        ],
        "other_options": [
            "consumers",
            "servers",
            "databases"
        ]
    },
    {
        "q": "Backpressure prevents system overload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match flow control:",
        "type": "match",
        "left": [
            "Backpressure",
            "Rate limit",
            "Throttle",
            "Buffer"
        ],
        "right": [
            "Signal source",
            "Cap rate",
            "Slow down",
            "Queue"
        ]
    },
    {
        "q": "Rearrange backpressure:",
        "type": "rearrange",
        "words": [
            "Detect overload",
            "Signal upstream",
            "Reduce intake",
            "Process queue",
            "Resume normal"
        ]
    },
    {
        "q": "What is load shedding?",
        "type": "mcq",
        "o": [
            "Dropping requests to maintain stability",
            "Accepting all requests",
            "Queuing requests",
            "Speeding up"
        ]
    },
    {
        "q": "Load shedding drops ______ requests.",
        "type": "fill_blank",
        "answers": [
            "excess"
        ],
        "other_options": [
            "all",
            "valid",
            "important"
        ]
    },
    {
        "q": "Load shedding is a last resort protection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match shedding strategies:",
        "type": "match",
        "left": [
            "Random",
            "Priority",
            "Age-based",
            "Size-based"
        ],
        "right": [
            "Drop randomly",
            "Keep important",
            "Drop old",
            "Drop large"
        ]
    },
    {
        "q": "What is priority rate limiting?",
        "type": "mcq",
        "o": [
            "Different limits based on priority",
            "Same limits for all",
            "No priorities",
            "Random limits"
        ]
    },
    {
        "q": "High priority requests get ______ limits.",
        "type": "fill_blank",
        "answers": [
            "higher"
        ],
        "other_options": [
            "lower",
            "same",
            "no"
        ]
    },
    {
        "q": "Priority queues process important requests first.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match priority levels:",
        "type": "match",
        "left": [
            "Critical",
            "High",
            "Normal",
            "Low"
        ],
        "right": [
            "Must process",
            "Important",
            "Standard",
            "Can wait"
        ]
    },
    {
        "q": "Rearrange priority handling:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Determine priority",
            "Check priority limit",
            "Process by priority",
            "Log result"
        ]
    },
    {
        "q": "What is request costing?",
        "type": "mcq",
        "o": [
            "Assigning different weights to requests",
            "Same cost for all",
            "No cost",
            "Free requests"
        ]
    },
    {
        "q": "Heavy requests cost more ______.",
        "type": "fill_blank",
        "answers": [
            "tokens"
        ],
        "other_options": [
            "money",
            "time",
            "space"
        ]
    },
    {
        "q": "Complex queries may consume more rate limit tokens.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match request costs:",
        "type": "match",
        "left": [
            "Simple read",
            "Complex query",
            "Bulk write",
            "Admin"
        ],
        "right": [
            "1 token",
            "5 tokens",
            "10 tokens",
            "20 tokens"
        ]
    },
    {
        "q": "What is concurrent request limiting?",
        "type": "mcq",
        "o": [
            "Limiting simultaneous requests",
            "Sequential only",
            "No limit on parallel",
            "Time-based limiting"
        ]
    },
    {
        "q": "Concurrency limits cap ______ requests.",
        "type": "fill_blank",
        "answers": [
            "simultaneous"
        ],
        "other_options": [
            "total",
            "daily",
            "hourly"
        ]
    },
    {
        "q": "Semaphores can implement concurrency limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match concurrency controls:",
        "type": "match",
        "left": [
            "Semaphore",
            "Mutex",
            "Connection pool",
            "Thread pool"
        ],
        "right": [
            "Counting lock",
            "Exclusive lock",
            "Connections",
            "Workers"
        ]
    },
    {
        "q": "Rearrange concurrency check:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check active count",
            "Acquire slot",
            "Process request",
            "Release slot"
        ]
    },
    {
        "q": "What is connection rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting new connections per client",
            "Request limiting",
            "Data limiting",
            "No connection limits"
        ]
    },
    {
        "q": "Connection limits prevent ______ attacks.",
        "type": "fill_blank",
        "answers": [
            "connection flood"
        ],
        "other_options": [
            "SQL injection",
            "XSS",
            "CSRF"
        ]
    },
    {
        "q": "TCP SYN flood is a connection-based attack.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match connection types:",
        "type": "match",
        "left": [
            "TCP",
            "HTTP",
            "WebSocket",
            "gRPC"
        ],
        "right": [
            "Transport",
            "Application",
            "Persistent",
            "RPC"
        ]
    },
    {
        "q": "What is bandwidth rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting data transfer rate",
            "Request limiting",
            "Connection limiting",
            "No bandwidth limits"
        ]
    },
    {
        "q": "Bandwidth limits are measured in ______.",
        "type": "fill_blank",
        "answers": [
            "bits per second"
        ],
        "other_options": [
            "requests",
            "connections",
            "users"
        ]
    },
    {
        "q": "Large file downloads may be bandwidth limited.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match bandwidth units:",
        "type": "match",
        "left": [
            "Kbps",
            "Mbps",
            "Gbps",
            "Tbps"
        ],
        "right": [
            "Kilobits",
            "Megabits",
            "Gigabits",
            "Terabits"
        ]
    },
    {
        "q": "Rearrange bandwidth limiting:",
        "type": "rearrange",
        "words": [
            "Measure transfer",
            "Check bandwidth",
            "Throttle if needed",
            "Continue transfer",
            "Log usage"
        ]
    },
    {
        "q": "What is geographic rate limiting?",
        "type": "mcq",
        "o": [
            "Different limits by location",
            "Same limits everywhere",
            "No location awareness",
            "Random limits"
        ]
    },
    {
        "q": "Geographic limits use ______ location.",
        "type": "fill_blank",
        "answers": [
            "IP-based"
        ],
        "other_options": [
            "GPS",
            "user-entered",
            "random"
        ]
    },
    {
        "q": "Different regions may have different capacity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match regional limits:",
        "type": "match",
        "left": [
            "Local region",
            "Cross-region",
            "Global",
            "Edge"
        ],
        "right": [
            "Same region",
            "Different region",
            "All regions",
            "CDN location"
        ]
    },
    {
        "q": "What is time-of-day rate limiting?",
        "type": "mcq",
        "o": [
            "Different limits at different times",
            "Same limits always",
            "No time awareness",
            "Random limits"
        ]
    },
    {
        "q": "Peak hours may have ______ limits.",
        "type": "fill_blank",
        "answers": [
            "lower"
        ],
        "other_options": [
            "higher",
            "no",
            "same"
        ]
    },
    {
        "q": "Off-peak times can allow higher rates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match time periods:",
        "type": "match",
        "left": [
            "Peak",
            "Off-peak",
            "Maintenance",
            "Holiday"
        ],
        "right": [
            "High traffic",
            "Low traffic",
            "Reduced capacity",
            "Special"
        ]
    },
    {
        "q": "Rearrange time-based limiting:",
        "type": "rearrange",
        "words": [
            "Get current time",
            "Determine period",
            "Look up limits",
            "Apply limits",
            "Log decision"
        ]
    },
    {
        "q": "What is retry behavior in rate limiting?",
        "type": "mcq",
        "o": [
            "How clients should retry after 429",
            "No retries",
            "Immediate retry",
            "Give up"
        ]
    },
    {
        "q": "Exponential backoff increases ______ between retries.",
        "type": "fill_blank",
        "answers": [
            "delay"
        ],
        "other_options": [
            "retries",
            "requests",
            "speed"
        ]
    },
    {
        "q": "Jitter adds randomness to retry timing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match retry strategies:",
        "type": "match",
        "left": [
            "Fixed",
            "Linear",
            "Exponential",
            "Decorrelated"
        ],
        "right": [
            "Same delay",
            "Increasing linear",
            "Doubling",
            "Random growth"
        ]
    },
    {
        "q": "What is rate limit testing?",
        "type": "mcq",
        "o": [
            "Verifying rate limits work correctly",
            "No testing",
            "Production testing only",
            "Manual testing only"
        ]
    },
    {
        "q": "Load testing verifies rate limit ______.",
        "type": "fill_blank",
        "answers": [
            "behavior"
        ],
        "other_options": [
            "color",
            "name",
            "size"
        ]
    },
    {
        "q": "Rate limits should be tested before production.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match testing types:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "Load",
            "Chaos"
        ],
        "right": [
            "Component",
            "Combined",
            "Volume",
            "Failure"
        ]
    },
    {
        "q": "Rearrange rate limit testing:",
        "type": "rearrange",
        "words": [
            "Define test cases",
            "Set up environment",
            "Run tests",
            "Verify behavior",
            "Document results"
        ]
    },
    {
        "q": "What is rate limit documentation?",
        "type": "mcq",
        "o": [
            "Explaining limits to API consumers",
            "No documentation",
            "Internal only",
            "Code comments only"
        ]
    },
    {
        "q": "Documentation helps developers ______ limits.",
        "type": "fill_blank",
        "answers": [
            "understand"
        ],
        "other_options": [
            "ignore",
            "bypass",
            "remove"
        ]
    },
    {
        "q": "API docs should include rate limit information.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match documentation elements:",
        "type": "match",
        "left": [
            "Limits",
            "Headers",
            "Errors",
            "Best practices"
        ],
        "right": [
            "Thresholds",
            "Response info",
            "429 handling",
            "Usage tips"
        ]
    },
    {
        "q": "What is rate limit analytics?",
        "type": "mcq",
        "o": [
            "Analyzing rate limit data",
            "No analysis",
            "Guessing",
            "Ignoring data"
        ]
    },
    {
        "q": "Analytics help optimize ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "code",
            "users",
            "servers"
        ]
    },
    {
        "q": "Usage patterns inform rate limit decisions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match analytics metrics:",
        "type": "match",
        "left": [
            "Peak usage",
            "Average rate",
            "Rejection rate",
            "Client distribution"
        ],
        "right": [
            "Maximum",
            "Mean",
            "Blocked",
            "Who uses"
        ]
    },
    {
        "q": "Rearrange analytics workflow:",
        "type": "rearrange",
        "words": [
            "Collect data",
            "Aggregate metrics",
            "Analyze patterns",
            "Generate insights",
            "Optimize limits"
        ]
    },
    {
        "q": "What is rate limit billing?",
        "type": "mcq",
        "o": [
            "Charging based on API usage",
            "Free unlimited",
            "No tracking",
            "Fixed price only"
        ]
    },
    {
        "q": "Usage-based pricing charges per ______.",
        "type": "fill_blank",
        "answers": [
            "request"
        ],
        "other_options": [
            "day",
            "user",
            "feature"
        ]
    },
    {
        "q": "Overage charges apply when exceeding quotas.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match billing models:",
        "type": "match",
        "left": [
            "Per request",
            "Subscription",
            "Tiered",
            "Overage"
        ],
        "right": [
            "Pay per call",
            "Monthly fee",
            "Level-based",
            "Extra charges"
        ]
    },
    {
        "q": "What is API gateway rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting at the gateway level",
            "Application level only",
            "No gateway",
            "Network level only"
        ]
    },
    {
        "q": "API gateways provide ______ rate limiting.",
        "type": "fill_blank",
        "answers": [
            "centralized"
        ],
        "other_options": [
            "distributed",
            "local",
            "no"
        ]
    },
    {
        "q": "API gateways can enforce limits before reaching backend.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match gateway features:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Authentication",
            "Routing",
            "Caching"
        ],
        "right": [
            "Traffic control",
            "Identity check",
            "Request flow",
            "Response storage"
        ]
    },
    {
        "q": "Rearrange gateway processing:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Authenticate",
            "Check rate limit",
            "Route to backend",
            "Return response"
        ]
    },
    {
        "q": "What is service mesh rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting between services",
            "Client-facing only",
            "No internal limits",
            "Database limits"
        ]
    },
    {
        "q": "Service mesh limits ______ traffic.",
        "type": "fill_blank",
        "answers": [
            "service-to-service"
        ],
        "other_options": [
            "external",
            "public",
            "database"
        ]
    },
    {
        "q": "Istio provides service mesh rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mesh concepts:",
        "type": "match",
        "left": [
            "Sidecar",
            "Control plane",
            "Data plane",
            "Envoy"
        ],
        "right": [
            "Proxy",
            "Management",
            "Traffic",
            "Proxy impl"
        ]
    },
    {
        "q": "What is CDN rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting at CDN edge",
            "Origin only",
            "No CDN limits",
            "Client limiting"
        ]
    },
    {
        "q": "CDN limits protect ______ servers.",
        "type": "fill_blank",
        "answers": [
            "origin"
        ],
        "other_options": [
            "edge",
            "DNS",
            "client"
        ]
    },
    {
        "q": "CDN rate limiting reduces origin load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match CDN layers:",
        "type": "match",
        "left": [
            "Edge",
            "Origin",
            "Cache",
            "WAF"
        ],
        "right": [
            "Closest server",
            "Source server",
            "Stored content",
            "Firewall"
        ]
    },
    {
        "q": "Rearrange CDN rate limiting:",
        "type": "rearrange",
        "words": [
            "Request hits edge",
            "Check edge cache",
            "Check rate limit",
            "Fetch from origin if needed",
            "Return to client"
        ]
    },
    {
        "q": "What is WAF rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting in web application firewall",
            "No WAF limits",
            "Application only",
            "Network only"
        ]
    },
    {
        "q": "WAF rate limiting blocks ______ traffic.",
        "type": "fill_blank",
        "answers": [
            "malicious"
        ],
        "other_options": [
            "all",
            "valid",
            "internal"
        ]
    },
    {
        "q": "WAF can detect and block attack patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match WAF rules:",
        "type": "match",
        "left": [
            "Rate rule",
            "IP rule",
            "Bot rule",
            "Geo rule"
        ],
        "right": [
            "Request volume",
            "Address block",
            "Automation",
            "Location"
        ]
    },
    {
        "q": "What is DDoS protection rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting during DDoS attacks",
            "Normal operation",
            "No DDoS limits",
            "Manual blocking"
        ]
    },
    {
        "q": "DDoS protection limits ______ traffic.",
        "type": "fill_blank",
        "answers": [
            "attack"
        ],
        "other_options": [
            "all",
            "normal",
            "internal"
        ]
    },
    {
        "q": "DDoS mitigation activates during attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DDoS layers:",
        "type": "match",
        "left": [
            "Layer 3",
            "Layer 4",
            "Layer 7",
            "Volumetric"
        ],
        "right": [
            "Network",
            "Transport",
            "Application",
            "High volume"
        ]
    },
    {
        "q": "Rearrange DDoS response:",
        "type": "rearrange",
        "words": [
            "Detect anomaly",
            "Activate mitigation",
            "Filter traffic",
            "Absorb attack",
            "Return to normal"
        ]
    },
    {
        "q": "What is rate limit caching?",
        "type": "mcq",
        "o": [
            "Caching rate limit counters",
            "No caching",
            "Content caching",
            "Session caching"
        ]
    },
    {
        "q": "Local cache reduces ______ lookups.",
        "type": "fill_blank",
        "answers": [
            "remote"
        ],
        "other_options": [
            "local",
            "fast",
            "slow"
        ]
    },
    {
        "q": "Caching can improve rate limit performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cache types:",
        "type": "match",
        "left": [
            "Local",
            "Distributed",
            "Hierarchical",
            "Write-through"
        ],
        "right": [
            "Single node",
            "Multiple nodes",
            "Levels",
            "Immediate sync"
        ]
    },
    {
        "q": "What is rate limit consistency?",
        "type": "mcq",
        "o": [
            "Ensuring accurate counts across nodes",
            "No consistency",
            "Eventual only",
            "Strong only"
        ]
    },
    {
        "q": "Strong consistency ensures ______ counts.",
        "type": "fill_blank",
        "answers": [
            "accurate"
        ],
        "other_options": [
            "approximate",
            "estimated",
            "random"
        ]
    },
    {
        "q": "Eventual consistency allows temporary inaccuracy.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match consistency levels:",
        "type": "match",
        "left": [
            "Strong",
            "Eventual",
            "Causal",
            "Session"
        ],
        "right": [
            "Immediate",
            "Eventually",
            "Ordered",
            "Per session"
        ]
    },
    {
        "q": "Rearrange consistency tradeoffs:",
        "type": "rearrange",
        "words": [
            "Define requirements",
            "Choose level",
            "Implement sync",
            "Monitor accuracy",
            "Adjust as needed"
        ]
    },
    {
        "q": "What is rate limit atomicity?",
        "type": "mcq",
        "o": [
            "Ensuring check and update are atomic",
            "Non-atomic operations",
            "No atomicity",
            "Manual locking"
        ]
    },
    {
        "q": "Atomic operations prevent ______ conditions.",
        "type": "fill_blank",
        "answers": [
            "race"
        ],
        "other_options": [
            "normal",
            "expected",
            "valid"
        ]
    },
    {
        "q": "Lua scripts in Redis provide atomicity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match atomic operations:",
        "type": "match",
        "left": [
            "INCR",
            "DECR",
            "SETNX",
            "CAS"
        ],
        "right": [
            "Add one",
            "Subtract one",
            "Set if not exists",
            "Compare and swap"
        ]
    },
    {
        "q": "What is rate limit scalability?",
        "type": "mcq",
        "o": [
            "Handling increased load",
            "Fixed capacity",
            "No scaling",
            "Manual scaling"
        ]
    },
    {
        "q": "Scalable rate limiting handles ______ traffic.",
        "type": "fill_blank",
        "answers": [
            "growing"
        ],
        "other_options": [
            "fixed",
            "decreasing",
            "random"
        ]
    },
    {
        "q": "Horizontal scaling adds more nodes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match scaling types:",
        "type": "match",
        "left": [
            "Horizontal",
            "Vertical",
            "Auto",
            "Manual"
        ],
        "right": [
            "Add nodes",
            "Upgrade node",
            "Automatic",
            "Human triggered"
        ]
    },
    {
        "q": "Rearrange scaling process:",
        "type": "rearrange",
        "words": [
            "Monitor load",
            "Detect threshold",
            "Trigger scaling",
            "Add capacity",
            "Rebalance"
        ]
    },
    {
        "q": "What is rate limit observability?",
        "type": "mcq",
        "o": [
            "Visibility into rate limiting behavior",
            "No visibility",
            "Logs only",
            "Metrics only"
        ]
    },
    {
        "q": "Observability includes logs, metrics, and ______.",
        "type": "fill_blank",
        "answers": [
            "traces"
        ],
        "other_options": [
            "code",
            "users",
            "requests"
        ]
    },
    {
        "q": "Dashboards visualize rate limit metrics.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match observability pillars:",
        "type": "match",
        "left": [
            "Logs",
            "Metrics",
            "Traces",
            "Events"
        ],
        "right": [
            "Text records",
            "Numbers",
            "Request flow",
            "Occurrences"
        ]
    },
    {
        "q": "What is rate limit alerting?",
        "type": "mcq",
        "o": [
            "Notifying on rate limit events",
            "No notifications",
            "Manual checking",
            "Logs only"
        ]
    },
    {
        "q": "Alerts notify on ______ conditions.",
        "type": "fill_blank",
        "answers": [
            "abnormal"
        ],
        "other_options": [
            "normal",
            "expected",
            "standard"
        ]
    },
    {
        "q": "PagerDuty can receive rate limit alerts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match alert types:",
        "type": "match",
        "left": [
            "Warning",
            "Critical",
            "Info",
            "Recovery"
        ],
        "right": [
            "Approaching",
            "Exceeded",
            "Normal",
            "Resolved"
        ]
    },
    {
        "q": "Rearrange alerting flow:",
        "type": "rearrange",
        "words": [
            "Define thresholds",
            "Monitor metrics",
            "Detect breach",
            "Send alert",
            "Respond"
        ]
    },
    {
        "q": "What is rate limit automation?",
        "type": "mcq",
        "o": [
            "Automating rate limit management",
            "Manual only",
            "No automation",
            "Human intervention required"
        ]
    },
    {
        "q": "Automation reduces ______ intervention.",
        "type": "fill_blank",
        "answers": [
            "manual"
        ],
        "other_options": [
            "automatic",
            "system",
            "code"
        ]
    },
    {
        "q": "Auto-remediation can adjust limits automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match automation types:",
        "type": "match",
        "left": [
            "Scaling",
            "Adjustment",
            "Recovery",
            "Deployment"
        ],
        "right": [
            "Add capacity",
            "Change limits",
            "Fix issues",
            "Release changes"
        ]
    },
    {
        "q": "Rate limiting is essential for API reliability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match reliability aspects:",
        "type": "match",
        "left": [
            "Availability",
            "Performance",
            "Stability",
            "Predictability"
        ],
        "right": [
            "Uptime",
            "Speed",
            "Consistency",
            "Expected behavior"
        ]
    },
    {
        "q": "Well-designed rate limiting improves user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match UX considerations:",
        "type": "match",
        "left": [
            "Fair limits",
            "Clear errors",
            "Retry guidance",
            "Documentation"
        ],
        "right": [
            "Equal access",
            "429 info",
            "How to retry",
            "Usage info"
        ]
    },
    {
        "q": "Rate limiting and throttling work together for API protection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match protection layers:",
        "type": "match",
        "left": [
            "Network",
            "Gateway",
            "Application",
            "Database"
        ],
        "right": [
            "Infrastructure",
            "Entry point",
            "Business logic",
            "Data store"
        ]
    },
    {
        "q": "What is GCRA algorithm?",
        "type": "mcq",
        "o": [
            "Generic Cell Rate Algorithm",
            "General Counter Rate Algorithm",
            "Global Control Rate Algorithm",
            "Generic Control Rate Algorithm"
        ]
    },
    {
        "q": "GCRA uses theoretical arrival ______.",
        "type": "fill_blank",
        "answers": [
            "time"
        ],
        "other_options": [
            "count",
            "rate",
            "size"
        ]
    },
    {
        "q": "GCRA is equivalent to token bucket.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GCRA terms:",
        "type": "match",
        "left": [
            "TAT",
            "Emission interval",
            "Limit",
            "Cell"
        ],
        "right": [
            "Theoretical arrival",
            "Time between",
            "Maximum",
            "Request"
        ]
    },
    {
        "q": "Rearrange GCRA check:",
        "type": "rearrange",
        "words": [
            "Get TAT",
            "Compare to now",
            "Calculate new TAT",
            "Update if allowed",
            "Return decision"
        ]
    },
    {
        "q": "What is rate limit warm-up?",
        "type": "mcq",
        "o": [
            "Gradually increasing limits for new clients",
            "Immediate full limits",
            "No limits initially",
            "Random limits"
        ]
    },
    {
        "q": "Warm-up prevents ______ from new clients.",
        "type": "fill_blank",
        "answers": [
            "abuse"
        ],
        "other_options": [
            "features",
            "data",
            "users"
        ]
    },
    {
        "q": "New API keys may have temporary lower limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match warm-up phases:",
        "type": "match",
        "left": [
            "Initial",
            "Growing",
            "Normal",
            "Premium"
        ],
        "right": [
            "Low limits",
            "Increasing",
            "Standard",
            "Enhanced"
        ]
    },
    {
        "q": "What is rate limit grace period?",
        "type": "mcq",
        "o": [
            "Temporary exemption after limit reached",
            "No exemption",
            "Permanent exemption",
            "Random exemption"
        ]
    },
    {
        "q": "Grace period allows brief ______.",
        "type": "fill_blank",
        "answers": [
            "overage"
        ],
        "other_options": [
            "reduction",
            "pause",
            "block"
        ]
    },
    {
        "q": "Grace periods improve user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match grace handling:",
        "type": "match",
        "left": [
            "Soft limit",
            "Hard limit",
            "Warning",
            "Block"
        ],
        "right": [
            "Allow briefly",
            "Strict block",
            "Notify only",
            "Deny access"
        ]
    },
    {
        "q": "Rearrange grace period:",
        "type": "rearrange",
        "words": [
            "Detect limit",
            "Start grace",
            "Allow requests",
            "Grace expires",
            "Enforce hard limit"
        ]
    },
    {
        "q": "What is rate limit rollover?",
        "type": "mcq",
        "o": [
            "Carrying unused quota to next period",
            "No carryover",
            "Reset to zero",
            "Random allocation"
        ]
    },
    {
        "q": "Rollover carries unused ______.",
        "type": "fill_blank",
        "answers": [
            "capacity"
        ],
        "other_options": [
            "data",
            "users",
            "errors"
        ]
    },
    {
        "q": "Some APIs allow rollover of unused quota.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match quota policies:",
        "type": "match",
        "left": [
            "Rollover",
            "Reset",
            "Cap",
            "Unlimited"
        ],
        "right": [
            "Carry forward",
            "Start fresh",
            "Maximum",
            "No limit"
        ]
    },
    {
        "q": "What is rate limit borrowing?",
        "type": "mcq",
        "o": [
            "Using future quota in advance",
            "Using past quota",
            "No borrowing",
            "Random allocation"
        ]
    },
    {
        "q": "Borrowing uses ______ quota.",
        "type": "fill_blank",
        "answers": [
            "future"
        ],
        "other_options": [
            "past",
            "current",
            "random"
        ]
    },
    {
        "q": "Borrowed quota reduces future availability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match credit policies:",
        "type": "match",
        "left": [
            "Borrow",
            "Rollover",
            "Credit",
            "Debit"
        ],
        "right": [
            "Use future",
            "Save unused",
            "Add to balance",
            "Subtract from"
        ]
    },
    {
        "q": "Rearrange borrowing:",
        "type": "rearrange",
        "words": [
            "Request exceeds limit",
            "Check borrowing policy",
            "Allow if permitted",
            "Deduct from future",
            "Track debt"
        ]
    },
    {
        "q": "What is multi-dimensional rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting on multiple criteria simultaneously",
            "Single dimension only",
            "No dimensions",
            "Fixed criteria"
        ]
    },
    {
        "q": "Multi-dimensional combines multiple ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "users",
            "servers",
            "data"
        ]
    },
    {
        "q": "Client may be limited by IP and API key together.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match limit dimensions:",
        "type": "match",
        "left": [
            "User",
            "IP",
            "Endpoint",
            "Region"
        ],
        "right": [
            "Account",
            "Address",
            "Path",
            "Geography"
        ]
    },
    {
        "q": "What is hierarchical rate limiting?",
        "type": "mcq",
        "o": [
            "Nested limits at different levels",
            "Flat limits",
            "No hierarchy",
            "Random structure"
        ]
    },
    {
        "q": "Hierarchy allows ______ at each level.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Organization can have limit shared by members.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match hierarchy levels:",
        "type": "match",
        "left": [
            "Organization",
            "Team",
            "User",
            "Application"
        ],
        "right": [
            "Top level",
            "Group",
            "Individual",
            "App level"
        ]
    },
    {
        "q": "Rearrange hierarchy check:",
        "type": "rearrange",
        "words": [
            "Check org limit",
            "Check team limit",
            "Check user limit",
            "Check app limit",
            "Allow if all pass"
        ]
    },
    {
        "q": "What is fair queuing?",
        "type": "mcq",
        "o": [
            "Equal allocation among clients",
            "Priority only",
            "No fairness",
            "Random allocation"
        ]
    },
    {
        "q": "Fair queuing ensures ______ access.",
        "type": "fill_blank",
        "answers": [
            "equal"
        ],
        "other_options": [
            "priority",
            "random",
            "fixed"
        ]
    },
    {
        "q": "Weighted fair queuing allocates by weight.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match queuing algorithms:",
        "type": "match",
        "left": [
            "FIFO",
            "Fair",
            "Weighted",
            "Priority"
        ],
        "right": [
            "First in",
            "Equal share",
            "By weight",
            "By importance"
        ]
    },
    {
        "q": "What is admission control?",
        "type": "mcq",
        "o": [
            "Deciding whether to accept new requests",
            "Always accept",
            "Always reject",
            "Random decision"
        ]
    },
    {
        "q": "Admission control protects system ______.",
        "type": "fill_blank",
        "answers": [
            "capacity"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Admission control can shed load proactively.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match admission decisions:",
        "type": "match",
        "left": [
            "Accept",
            "Reject",
            "Queue",
            "Redirect"
        ],
        "right": [
            "Allow in",
            "Deny",
            "Wait",
            "Send elsewhere"
        ]
    },
    {
        "q": "Rearrange admission control:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check capacity",
            "Evaluate priority",
            "Make decision",
            "Respond"
        ]
    },
    {
        "q": "What is token replenishment?",
        "type": "mcq",
        "o": [
            "Adding tokens back to bucket",
            "Removing tokens",
            "Counting tokens",
            "Storing tokens"
        ]
    },
    {
        "q": "Tokens replenish at a configured ______.",
        "type": "fill_blank",
        "answers": [
            "rate"
        ],
        "other_options": [
            "time",
            "count",
            "size"
        ]
    },
    {
        "q": "Replenishment rate determines sustained rate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match token operations:",
        "type": "match",
        "left": [
            "Add",
            "Remove",
            "Check",
            "Reset"
        ],
        "right": [
            "Replenish",
            "Consume",
            "Query",
            "Clear"
        ]
    },
    {
        "q": "What is request classification?",
        "type": "mcq",
        "o": [
            "Categorizing requests for different limits",
            "All same category",
            "No classification",
            "Random category"
        ]
    },
    {
        "q": "Classification assigns requests to ______.",
        "type": "fill_blank",
        "answers": [
            "categories"
        ],
        "other_options": [
            "users",
            "servers",
            "databases"
        ]
    },
    {
        "q": "Different categories may have different limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match classification criteria:",
        "type": "match",
        "left": [
            "By endpoint",
            "By method",
            "By user",
            "By content"
        ],
        "right": [
            "Path-based",
            "HTTP verb",
            "Requester",
            "Payload"
        ]
    },
    {
        "q": "Rearrange classification:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Extract attributes",
            "Match rules",
            "Assign category",
            "Apply category limit"
        ]
    },
    {
        "q": "What is rate limit header best practice?",
        "type": "mcq",
        "o": [
            "Include standard headers in responses",
            "No headers",
            "Custom headers only",
            "Hidden limits"
        ]
    },
    {
        "q": "Headers inform clients about ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "users",
            "data",
            "errors"
        ]
    },
    {
        "q": "RateLimit-Policy draft standardizes headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match standard headers:",
        "type": "match",
        "left": [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset",
            "Retry-After"
        ],
        "right": [
            "Max allowed",
            "Requests left",
            "When reset",
            "When to retry"
        ]
    },
    {
        "q": "What is rate limit policy?",
        "type": "mcq",
        "o": [
            "Rules defining rate limits",
            "No rules",
            "Random limits",
            "Fixed limits only"
        ]
    },
    {
        "q": "Policies define who, what, and ______.",
        "type": "fill_blank",
        "answers": [
            "how much"
        ],
        "other_options": [
            "where",
            "why",
            "when"
        ]
    },
    {
        "q": "Policies should be version controlled.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match policy components:",
        "type": "match",
        "left": [
            "Subject",
            "Resource",
            "Action",
            "Limit"
        ],
        "right": [
            "Who",
            "What",
            "How",
            "Threshold"
        ]
    },
    {
        "q": "Rearrange policy creation:",
        "type": "rearrange",
        "words": [
            "Define requirements",
            "Create policy",
            "Test policy",
            "Deploy policy",
            "Monitor compliance"
        ]
    },
    {
        "q": "What is rate limit exception handling?",
        "type": "mcq",
        "o": [
            "Special cases that bypass normal limits",
            "No exceptions",
            "All exceptions",
            "Random exceptions"
        ]
    },
    {
        "q": "Exceptions allow ______ for specific cases.",
        "type": "fill_blank",
        "answers": [
            "bypass"
        ],
        "other_options": [
            "reduction",
            "increase",
            "removal"
        ]
    },
    {
        "q": "Emergency access may need limit exceptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match exception types:",
        "type": "match",
        "left": [
            "Emergency",
            "Partner",
            "Internal",
            "Admin"
        ],
        "right": [
            "Crisis access",
            "Business critical",
            "Service calls",
            "Privileged"
        ]
    },
    {
        "q": "What is rate limit dashboard?",
        "type": "mcq",
        "o": [
            "Visual interface for rate limit metrics",
            "No visualization",
            "Text only",
            "Logs only"
        ]
    },
    {
        "q": "Dashboards show real-time ______.",
        "type": "fill_blank",
        "answers": [
            "metrics"
        ],
        "other_options": [
            "code",
            "users",
            "data"
        ]
    },
    {
        "q": "Grafana can display rate limit dashboards.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match dashboard widgets:",
        "type": "match",
        "left": [
            "Gauge",
            "Graph",
            "Table",
            "Alert"
        ],
        "right": [
            "Current value",
            "Trend",
            "Details",
            "Status"
        ]
    },
    {
        "q": "Rearrange dashboard setup:",
        "type": "rearrange",
        "words": [
            "Define metrics",
            "Create queries",
            "Design panels",
            "Arrange layout",
            "Set refresh"
        ]
    },
    {
        "q": "What is rate limit SLA?",
        "type": "mcq",
        "o": [
            "Service level agreement for rate limits",
            "No guarantees",
            "Random guarantees",
            "Verbal agreement"
        ]
    },
    {
        "q": "SLA defines guaranteed ______ limits.",
        "type": "fill_blank",
        "answers": [
            "minimum"
        ],
        "other_options": [
            "maximum",
            "average",
            "random"
        ]
    },
    {
        "q": "Enterprise SLAs may include rate limit guarantees.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match SLA terms:",
        "type": "match",
        "left": [
            "Guarantee",
            "Credits",
            "Exclusions",
            "Reporting"
        ],
        "right": [
            "Promised level",
            "Compensation",
            "Not covered",
            "How to measure"
        ]
    },
    {
        "q": "What is rate limit capacity planning?",
        "type": "mcq",
        "o": [
            "Planning for future limit needs",
            "No planning",
            "Only current needs",
            "Random allocation"
        ]
    },
    {
        "q": "Capacity planning considers ______ growth.",
        "type": "fill_blank",
        "answers": [
            "future"
        ],
        "other_options": [
            "past",
            "current",
            "random"
        ]
    },
    {
        "q": "Historical data informs capacity planning.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match planning inputs:",
        "type": "match",
        "left": [
            "Historical",
            "Growth rate",
            "Seasonality",
            "Business plans"
        ],
        "right": [
            "Past data",
            "Increase rate",
            "Patterns",
            "Strategy"
        ]
    },
    {
        "q": "Rearrange capacity planning:",
        "type": "rearrange",
        "words": [
            "Analyze history",
            "Predict growth",
            "Identify peaks",
            "Plan capacity",
            "Implement changes"
        ]
    },
    {
        "q": "What is rate limit cost optimization?",
        "type": "mcq",
        "o": [
            "Balancing limits with infrastructure costs",
            "Ignoring costs",
            "Maximum limits always",
            "Minimum limits always"
        ]
    },
    {
        "q": "Optimization balances ______ and capability.",
        "type": "fill_blank",
        "answers": [
            "cost"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Higher limits may require more infrastructure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cost factors:",
        "type": "match",
        "left": [
            "Infrastructure",
            "Bandwidth",
            "Storage",
            "Support"
        ],
        "right": [
            "Servers",
            "Network",
            "Data",
            "People"
        ]
    },
    {
        "q": "What is rate limit governance?",
        "type": "mcq",
        "o": [
            "Policies and processes for managing limits",
            "No governance",
            "Ad hoc management",
            "Random changes"
        ]
    },
    {
        "q": "Governance ensures consistent ______.",
        "type": "fill_blank",
        "answers": [
            "management"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Change management applies to rate limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match governance aspects:",
        "type": "match",
        "left": [
            "Policy",
            "Process",
            "Compliance",
            "Audit"
        ],
        "right": [
            "Rules",
            "Steps",
            "Following",
            "Checking"
        ]
    },
    {
        "q": "Rearrange governance process:",
        "type": "rearrange",
        "words": [
            "Define policies",
            "Implement controls",
            "Monitor compliance",
            "Audit regularly",
            "Improve continuously"
        ]
    },
    {
        "q": "What is rate limit versioning?",
        "type": "mcq",
        "o": [
            "Different limits for different API versions",
            "Same limits always",
            "No versioning",
            "Random limits"
        ]
    },
    {
        "q": "API versions may have different ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "New versions may have higher limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match version considerations:",
        "type": "match",
        "left": [
            "Legacy",
            "Current",
            "Beta",
            "Deprecated"
        ],
        "right": [
            "Old version",
            "Active version",
            "Testing",
            "Being removed"
        ]
    },
    {
        "q": "What is rate limit migration?",
        "type": "mcq",
        "o": [
            "Moving to new rate limit configurations",
            "No changes",
            "Random changes",
            "Immediate switch"
        ]
    },
    {
        "q": "Migration should be ______.",
        "type": "fill_blank",
        "answers": [
            "gradual"
        ],
        "other_options": [
            "instant",
            "random",
            "ignored"
        ]
    },
    {
        "q": "Clients should be notified of limit changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match migration phases:",
        "type": "match",
        "left": [
            "Announce",
            "Transition",
            "Switch",
            "Monitor"
        ],
        "right": [
            "Notify",
            "Gradual change",
            "Final cutover",
            "Watch effects"
        ]
    },
    {
        "q": "Rearrange migration process:",
        "type": "rearrange",
        "words": [
            "Plan changes",
            "Announce to clients",
            "Gradual rollout",
            "Complete switch",
            "Monitor results"
        ]
    },
    {
        "q": "What is rate limit API monetization?",
        "type": "mcq",
        "o": [
            "Using limits for revenue generation",
            "Free unlimited",
            "No monetization",
            "Random pricing"
        ]
    },
    {
        "q": "Tiered pricing based on ______.",
        "type": "fill_blank",
        "answers": [
            "usage"
        ],
        "other_options": [
            "color",
            "size",
            "random"
        ]
    },
    {
        "q": "Higher limits can be premium offerings.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match monetization models:",
        "type": "match",
        "left": [
            "Free tier",
            "Paid tier",
            "Enterprise",
            "Custom"
        ],
        "right": [
            "Low limits",
            "More limits",
            "High limits",
            "Negotiated"
        ]
    },
    {
        "q": "What is rate limit compliance?",
        "type": "mcq",
        "o": [
            "Meeting regulatory requirements with limits",
            "Ignoring regulations",
            "No compliance",
            "Random compliance"
        ]
    },
    {
        "q": "Compliance may require ______ limits.",
        "type": "fill_blank",
        "answers": [
            "specific"
        ],
        "other_options": [
            "no",
            "random",
            "variable"
        ]
    },
    {
        "q": "GDPR may affect rate limiting for data access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match compliance areas:",
        "type": "match",
        "left": [
            "Data access",
            "Audit trail",
            "Fair use",
            "Privacy"
        ],
        "right": [
            "Rate limits",
            "Logging",
            "Equal access",
            "Protection"
        ]
    },
    {
        "q": "Rearrange compliance check:",
        "type": "rearrange",
        "words": [
            "Identify requirements",
            "Map to limits",
            "Implement controls",
            "Document",
            "Audit regularly"
        ]
    },
    {
        "q": "What is rate limit security?",
        "type": "mcq",
        "o": [
            "Protecting rate limit mechanisms from abuse",
            "No protection",
            "Open access",
            "Random protection"
        ]
    },
    {
        "q": "Rate limit bypass is a ______ vulnerability.",
        "type": "fill_blank",
        "answers": [
            "security"
        ],
        "other_options": [
            "feature",
            "user",
            "data"
        ]
    },
    {
        "q": "Attackers may try to bypass rate limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match bypass techniques:",
        "type": "match",
        "left": [
            "IP rotation",
            "Key rotation",
            "Header spoofing",
            "Distributed attack"
        ],
        "right": [
            "Change source",
            "Use multiple keys",
            "Fake headers",
            "Many sources"
        ]
    },
    {
        "q": "What is rate limit fingerprinting?",
        "type": "mcq",
        "o": [
            "Identifying clients beyond IP/key",
            "IP only",
            "Key only",
            "No identification"
        ]
    },
    {
        "q": "Fingerprinting uses multiple ______.",
        "type": "fill_blank",
        "answers": [
            "signals"
        ],
        "other_options": [
            "IPs",
            "keys",
            "users"
        ]
    },
    {
        "q": "Device fingerprinting can identify unique clients.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match fingerprint signals:",
        "type": "match",
        "left": [
            "User agent",
            "Headers",
            "Timing",
            "Behavior"
        ],
        "right": [
            "Browser info",
            "Request info",
            "Pattern",
            "Actions"
        ]
    },
    {
        "q": "Rearrange fingerprinting:",
        "type": "rearrange",
        "words": [
            "Collect signals",
            "Generate fingerprint",
            "Track client",
            "Apply limits",
            "Update fingerprint"
        ]
    },
    {
        "q": "What is rate limit evasion detection?",
        "type": "mcq",
        "o": [
            "Detecting attempts to bypass limits",
            "Ignoring evasion",
            "Allowing evasion",
            "No detection"
        ]
    },
    {
        "q": "Evasion detection finds ______ behavior.",
        "type": "fill_blank",
        "answers": [
            "suspicious"
        ],
        "other_options": [
            "normal",
            "expected",
            "valid"
        ]
    },
    {
        "q": "Rapid key switching may indicate evasion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match evasion patterns:",
        "type": "match",
        "left": [
            "Key hopping",
            "IP rotation",
            "Timing patterns",
            "Distributed sources"
        ],
        "right": [
            "Many keys",
            "Many IPs",
            "Suspicious timing",
            "Many locations"
        ]
    },
    {
        "q": "What is rate limit abuse reporting?",
        "type": "mcq",
        "o": [
            "Reporting rate limit violations",
            "No reporting",
            "Hiding violations",
            "Ignoring abuse"
        ]
    },
    {
        "q": "Reports help identify ______.",
        "type": "fill_blank",
        "answers": [
            "abusers"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Abuse reports can trigger account review.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match report contents:",
        "type": "match",
        "left": [
            "Client ID",
            "Violation count",
            "Time period",
            "Actions taken"
        ],
        "right": [
            "Who",
            "How many",
            "When",
            "Response"
        ]
    },
    {
        "q": "Rearrange abuse handling:",
        "type": "rearrange",
        "words": [
            "Detect violation",
            "Generate report",
            "Review abuse",
            "Take action",
            "Document outcome"
        ]
    },
    {
        "q": "Rate limiting enables sustainable API usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match sustainability aspects:",
        "type": "match",
        "left": [
            "Resource protection",
            "Fair access",
            "Cost control",
            "Growth support"
        ],
        "right": [
            "Don't overload",
            "Everyone shares",
            "Manage spend",
            "Scale safely"
        ]
    },
    {
        "q": "Effective rate limiting requires continuous improvement.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match improvement areas:",
        "type": "match",
        "left": [
            "Configuration",
            "Monitoring",
            "Algorithms",
            "Integration"
        ],
        "right": [
            "Tune limits",
            "Better visibility",
            "Smarter methods",
            "More systems"
        ]
    },
    {
        "q": "Rate limiting is key to API platform success.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match success factors:",
        "type": "match",
        "left": [
            "Reliability",
            "Scalability",
            "Security",
            "User experience"
        ],
        "right": [
            "Works well",
            "Handles growth",
            "Prevents abuse",
            "Good for users"
        ]
    },
    {
        "q": "What is request deduplication?",
        "type": "mcq",
        "o": [
            "Preventing duplicate request processing",
            "Allowing duplicates",
            "Counting duplicates",
            "Ignoring duplicates"
        ]
    },
    {
        "q": "Idempotency keys help with ______.",
        "type": "fill_blank",
        "answers": [
            "deduplication"
        ],
        "other_options": [
            "authentication",
            "authorization",
            "encryption"
        ]
    },
    {
        "q": "Duplicate requests may not count against limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match dedup strategies:",
        "type": "match",
        "left": [
            "Idempotency key",
            "Request hash",
            "Timestamp",
            "Sequence"
        ],
        "right": [
            "Client provided",
            "Content hash",
            "Time based",
            "Order based"
        ]
    },
    {
        "q": "Rearrange deduplication:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check for duplicate",
            "If duplicate return cached",
            "Else process request",
            "Cache response"
        ]
    },
    {
        "q": "What is request prioritization?",
        "type": "mcq",
        "o": [
            "Processing requests by importance",
            "Random processing",
            "FIFO only",
            "LIFO only"
        ]
    },
    {
        "q": "Priority queues order by ______.",
        "type": "fill_blank",
        "answers": [
            "importance"
        ],
        "other_options": [
            "arrival",
            "size",
            "random"
        ]
    },
    {
        "q": "Critical requests should be processed first.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match priority sources:",
        "type": "match",
        "left": [
            "User tier",
            "Request type",
            "Business rule",
            "SLA"
        ],
        "right": [
            "Account level",
            "Endpoint",
            "Custom logic",
            "Agreement"
        ]
    },
    {
        "q": "What is request batching?",
        "type": "mcq",
        "o": [
            "Combining multiple requests into one",
            "Single requests only",
            "No batching",
            "Random batching"
        ]
    },
    {
        "q": "Batching reduces ______ overhead.",
        "type": "fill_blank",
        "answers": [
            "request"
        ],
        "other_options": [
            "response",
            "data",
            "user"
        ]
    },
    {
        "q": "Batch requests may have different rate costs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match batch considerations:",
        "type": "match",
        "left": [
            "Size limit",
            "Cost",
            "Timeout",
            "Error handling"
        ],
        "right": [
            "Max items",
            "Rate cost",
            "Max duration",
            "Partial failure"
        ]
    },
    {
        "q": "Rearrange batch handling:",
        "type": "rearrange",
        "words": [
            "Receive batch",
            "Count items",
            "Calculate cost",
            "Check limit",
            "Process batch"
        ]
    },
    {
        "q": "What is request pacing?",
        "type": "mcq",
        "o": [
            "Spreading requests over time",
            "All at once",
            "Random timing",
            "No pacing"
        ]
    },
    {
        "q": "Pacing smooths ______ distribution.",
        "type": "fill_blank",
        "answers": [
            "load"
        ],
        "other_options": [
            "data",
            "users",
            "errors"
        ]
    },
    {
        "q": "Pacing prevents burst traffic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match pacing methods:",
        "type": "match",
        "left": [
            "Fixed interval",
            "Random jitter",
            "Adaptive",
            "Token based"
        ],
        "right": [
            "Regular spacing",
            "Random delay",
            "Dynamic",
            "Token bucket"
        ]
    },
    {
        "q": "What is request shaping?",
        "type": "mcq",
        "o": [
            "Modifying traffic patterns",
            "No modification",
            "Random patterns",
            "Fixed patterns"
        ]
    },
    {
        "q": "Shaping adjusts traffic ______.",
        "type": "fill_blank",
        "answers": [
            "flow"
        ],
        "other_options": [
            "content",
            "users",
            "errors"
        ]
    },
    {
        "q": "Traffic shaping can smooth bursts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match shaping techniques:",
        "type": "match",
        "left": [
            "Delay",
            "Drop",
            "Mark",
            "Queue"
        ],
        "right": [
            "Slow down",
            "Remove",
            "Tag for later",
            "Hold"
        ]
    },
    {
        "q": "Rearrange traffic shaping:",
        "type": "rearrange",
        "words": [
            "Monitor traffic",
            "Identify patterns",
            "Apply shaping",
            "Measure results",
            "Adjust"
        ]
    },
    {
        "q": "What is request sampling?",
        "type": "mcq",
        "o": [
            "Processing subset of requests for analysis",
            "All requests",
            "No sampling",
            "Random only"
        ]
    },
    {
        "q": "Sampling reduces ______ processing.",
        "type": "fill_blank",
        "answers": [
            "analysis"
        ],
        "other_options": [
            "request",
            "response",
            "user"
        ]
    },
    {
        "q": "Sampling can estimate total traffic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match sampling rates:",
        "type": "match",
        "left": [
            "1%",
            "10%",
            "50%",
            "100%"
        ],
        "right": [
            "Very low",
            "Low",
            "Medium",
            "All"
        ]
    },
    {
        "q": "What is request hedging?",
        "type": "mcq",
        "o": [
            "Sending duplicate requests to multiple servers",
            "Single request",
            "No hedging",
            "Sequential retry"
        ]
    },
    {
        "q": "Hedging improves ______.",
        "type": "fill_blank",
        "answers": [
            "latency"
        ],
        "other_options": [
            "security",
            "features",
            "users"
        ]
    },
    {
        "q": "Hedging may count as multiple requests against limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match hedging strategies:",
        "type": "match",
        "left": [
            "Immediate",
            "Delayed",
            "Conditional",
            "Adaptive"
        ],
        "right": [
            "Send all now",
            "Wait then send",
            "Based on rule",
            "Dynamic threshold"
        ]
    },
    {
        "q": "Rearrange hedging:",
        "type": "rearrange",
        "words": [
            "Send primary",
            "Start timer",
            "Send backup if needed",
            "Use first response",
            "Cancel pending"
        ]
    },
    {
        "q": "What is request speculation?",
        "type": "mcq",
        "o": [
            "Pre-fetching likely needed data",
            "On-demand only",
            "No pre-fetch",
            "Random fetch"
        ]
    },
    {
        "q": "Speculation predicts ______ requests.",
        "type": "fill_blank",
        "answers": [
            "future"
        ],
        "other_options": [
            "past",
            "current",
            "random"
        ]
    },
    {
        "q": "Speculative requests may waste rate limit quota.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match speculation types:",
        "type": "match",
        "left": [
            "Prefetch",
            "Precompute",
            "Precache",
            "Preconnect"
        ],
        "right": [
            "Get ahead",
            "Calculate ahead",
            "Store ahead",
            "Connect ahead"
        ]
    },
    {
        "q": "What is request timeout handling?",
        "type": "mcq",
        "o": [
            "Managing requests that take too long",
            "No timeout",
            "Infinite wait",
            "Ignore timeout"
        ]
    },
    {
        "q": "Timeouts free up ______.",
        "type": "fill_blank",
        "answers": [
            "resources"
        ],
        "other_options": [
            "users",
            "data",
            "errors"
        ]
    },
    {
        "q": "Timed out requests may still count against limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match timeout types:",
        "type": "match",
        "left": [
            "Connection",
            "Read",
            "Total",
            "Idle"
        ],
        "right": [
            "Connecting",
            "Receiving",
            "Overall",
            "No activity"
        ]
    },
    {
        "q": "Rearrange timeout handling:",
        "type": "rearrange",
        "words": [
            "Start request",
            "Set timer",
            "Monitor timeout",
            "If timeout abort",
            "Return error"
        ]
    },
    {
        "q": "What is request retry storm?",
        "type": "mcq",
        "o": [
            "Many clients retrying simultaneously",
            "No retries",
            "Single retry",
            "Normal traffic"
        ]
    },
    {
        "q": "Retry storms can ______ systems.",
        "type": "fill_blank",
        "answers": [
            "overwhelm"
        ],
        "other_options": [
            "help",
            "improve",
            "fix"
        ]
    },
    {
        "q": "Exponential backoff helps prevent retry storms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match storm prevention:",
        "type": "match",
        "left": [
            "Backoff",
            "Jitter",
            "Limit retries",
            "Circuit break"
        ],
        "right": [
            "Wait longer",
            "Randomize",
            "Max attempts",
            "Stop trying"
        ]
    },
    {
        "q": "What is graceful degradation?",
        "type": "mcq",
        "o": [
            "Reducing functionality under load",
            "Full functionality always",
            "Complete failure",
            "No degradation"
        ]
    },
    {
        "q": "Degradation maintains ______ functionality.",
        "type": "fill_blank",
        "answers": [
            "core"
        ],
        "other_options": [
            "all",
            "no",
            "random"
        ]
    },
    {
        "q": "Rate limiting can trigger graceful degradation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match degradation levels:",
        "type": "match",
        "left": [
            "Full",
            "Reduced",
            "Minimal",
            "Offline"
        ],
        "right": [
            "All features",
            "Some features",
            "Core only",
            "Read only"
        ]
    },
    {
        "q": "Rearrange degradation:",
        "type": "rearrange",
        "words": [
            "Detect overload",
            "Identify non-essential",
            "Disable features",
            "Maintain core",
            "Monitor recovery"
        ]
    },
    {
        "q": "What is service mesh sidecar rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting in sidecar proxy",
            "Main container only",
            "No sidecar",
            "External only"
        ]
    },
    {
        "q": "Sidecars handle ______ limiting.",
        "type": "fill_blank",
        "answers": [
            "traffic"
        ],
        "other_options": [
            "user",
            "data",
            "feature"
        ]
    },
    {
        "q": "Envoy proxy supports rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match sidecar components:",
        "type": "match",
        "left": [
            "Envoy",
            "Linkerd",
            "Istio",
            "Consul"
        ],
        "right": [
            "Proxy",
            "Mesh",
            "Platform",
            "Connect"
        ]
    },
    {
        "q": "What is per-pod rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting per container instance",
            "Global only",
            "Per cluster",
            "No pod limits"
        ]
    },
    {
        "q": "Pod limits apply to individual ______.",
        "type": "fill_blank",
        "answers": [
            "instances"
        ],
        "other_options": [
            "clusters",
            "services",
            "users"
        ]
    },
    {
        "q": "Kubernetes pods can have rate limit annotations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match K8s rate limiting:",
        "type": "match",
        "left": [
            "Annotation",
            "ConfigMap",
            "CRD",
            "Operator"
        ],
        "right": [
            "Metadata",
            "Config",
            "Custom resource",
            "Controller"
        ]
    },
    {
        "q": "Rearrange K8s rate setup:",
        "type": "rearrange",
        "words": [
            "Define CRD",
            "Apply config",
            "Deploy sidecar",
            "Enable limiting",
            "Monitor metrics"
        ]
    },
    {
        "q": "What is serverless rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting in serverless functions",
            "Server-based only",
            "No serverless limits",
            "Container only"
        ]
    },
    {
        "q": "Serverless rate limits are per ______.",
        "type": "fill_blank",
        "answers": [
            "function"
        ],
        "other_options": [
            "server",
            "container",
            "cluster"
        ]
    },
    {
        "q": "AWS Lambda has concurrency limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match serverless limits:",
        "type": "match",
        "left": [
            "Concurrency",
            "Duration",
            "Memory",
            "Invocations"
        ],
        "right": [
            "Parallel runs",
            "Execution time",
            "RAM usage",
            "Call count"
        ]
    },
    {
        "q": "What is event-driven rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting event processing rate",
            "Request only",
            "No event limits",
            "Sync only"
        ]
    },
    {
        "q": "Event rates are measured in events per ______.",
        "type": "fill_blank",
        "answers": [
            "second"
        ],
        "other_options": [
            "day",
            "year",
            "never"
        ]
    },
    {
        "q": "Kafka has consumer rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match event systems:",
        "type": "match",
        "left": [
            "Kafka",
            "RabbitMQ",
            "SQS",
            "Pub/Sub"
        ],
        "right": [
            "Streaming",
            "Message broker",
            "AWS queue",
            "GCP messaging"
        ]
    },
    {
        "q": "Rearrange event throttling:",
        "type": "rearrange",
        "words": [
            "Events arrive",
            "Check rate",
            "Accept or queue",
            "Process at rate",
            "Acknowledge"
        ]
    },
    {
        "q": "What is webhook rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting outgoing webhook calls",
            "Incoming only",
            "No webhook limits",
            "All webhooks always"
        ]
    },
    {
        "q": "Webhook limits protect ______.",
        "type": "fill_blank",
        "answers": [
            "receivers"
        ],
        "other_options": [
            "senders",
            "data",
            "users"
        ]
    },
    {
        "q": "Webhook retries should use backoff.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match webhook concerns:",
        "type": "match",
        "left": [
            "Rate",
            "Retry",
            "Timeout",
            "Ordering"
        ],
        "right": [
            "Speed",
            "Failure handling",
            "Max wait",
            "Sequence"
        ]
    },
    {
        "q": "What is streaming rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting continuous data streams",
            "Batch only",
            "No stream limits",
            "Request/response only"
        ]
    },
    {
        "q": "Streaming limits apply to data ______.",
        "type": "fill_blank",
        "answers": [
            "flow"
        ],
        "other_options": [
            "storage",
            "users",
            "errors"
        ]
    },
    {
        "q": "WebSocket connections can be rate limited.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match streaming protocols:",
        "type": "match",
        "left": [
            "WebSocket",
            "SSE",
            "gRPC stream",
            "HTTP/2 stream"
        ],
        "right": [
            "Bidirectional",
            "Server push",
            "RPC stream",
            "Multiplexed"
        ]
    },
    {
        "q": "Rearrange stream limiting:",
        "type": "rearrange",
        "words": [
            "Open connection",
            "Track bandwidth",
            "Monitor message rate",
            "Throttle if needed",
            "Maintain connection"
        ]
    },
    {
        "q": "What is mobile API rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting for mobile app clients",
            "Web only",
            "No mobile limits",
            "Desktop only"
        ]
    },
    {
        "q": "Mobile clients may have different ______.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "features",
            "users",
            "data"
        ]
    },
    {
        "q": "Mobile networks may cause retry spikes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mobile considerations:",
        "type": "match",
        "left": [
            "Battery",
            "Network",
            "Offline",
            "Background"
        ],
        "right": [
            "Power usage",
            "Connectivity",
            "No connection",
            "Not active"
        ]
    },
    {
        "q": "What is IoT device rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting for IoT devices",
            "Web only",
            "No IoT limits",
            "Server only"
        ]
    },
    {
        "q": "IoT devices may have ______ constraints.",
        "type": "fill_blank",
        "answers": [
            "resource"
        ],
        "other_options": [
            "user",
            "feature",
            "network"
        ]
    },
    {
        "q": "IoT fleets can cause traffic spikes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match IoT concerns:",
        "type": "match",
        "left": [
            "Scale",
            "Battery",
            "Bandwidth",
            "Security"
        ],
        "right": [
            "Many devices",
            "Power limit",
            "Data limit",
            "Tamper proof"
        ]
    },
    {
        "q": "Rearrange IoT rate design:",
        "type": "rearrange",
        "words": [
            "Identify devices",
            "Set per-device limits",
            "Aggregate limits",
            "Monitor fleet",
            "Adjust as needed"
        ]
    },
    {
        "q": "What is partner API rate limiting?",
        "type": "mcq",
        "o": [
            "Special limits for business partners",
            "Same as public",
            "No partner limits",
            "Random limits"
        ]
    },
    {
        "q": "Partners may have ______ limits.",
        "type": "fill_blank",
        "answers": [
            "higher"
        ],
        "other_options": [
            "lower",
            "no",
            "same"
        ]
    },
    {
        "q": "Partner SLAs define rate guarantees.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match partner tiers:",
        "type": "match",
        "left": [
            "Bronze",
            "Silver",
            "Gold",
            "Platinum"
        ],
        "right": [
            "Basic",
            "Better",
            "High",
            "Custom"
        ]
    },
    {
        "q": "What is internal API rate limiting?",
        "type": "mcq",
        "o": [
            "Rate limiting between internal services",
            "External only",
            "No internal limits",
            "Public only"
        ]
    },
    {
        "q": "Internal limits prevent ______.",
        "type": "fill_blank",
        "answers": [
            "cascade failures"
        ],
        "other_options": [
            "external access",
            "user access",
            "public access"
        ]
    },
    {
        "q": "Service-to-service calls should have limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match internal patterns:",
        "type": "match",
        "left": [
            "Bulkhead",
            "Circuit breaker",
            "Rate limit",
            "Timeout"
        ],
        "right": [
            "Isolation",
            "Fail fast",
            "Cap rate",
            "Max wait"
        ]
    },
    {
        "q": "Rearrange internal protection:",
        "type": "rearrange",
        "words": [
            "Identify dependencies",
            "Set limits",
            "Implement checks",
            "Monitor health",
            "Adjust limits"
        ]
    },
    {
        "q": "What is database rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting database query rates",
            "No DB limits",
            "Unlimited queries",
            "Application only"
        ]
    },
    {
        "q": "Database limits protect ______.",
        "type": "fill_blank",
        "answers": [
            "resources"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Connection pools implement rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match database limits:",
        "type": "match",
        "left": [
            "Connections",
            "Queries",
            "Rows",
            "Duration"
        ],
        "right": [
            "Pool size",
            "QPS",
            "Result set",
            "Query time"
        ]
    },
    {
        "q": "What is cache rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting cache access rates",
            "No cache limits",
            "Unlimited access",
            "Database only"
        ]
    },
    {
        "q": "Cache limits protect ______ resources.",
        "type": "fill_blank",
        "answers": [
            "memory"
        ],
        "other_options": [
            "disk",
            "network",
            "CPU"
        ]
    },
    {
        "q": "Redis can be rate limited.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cache concerns:",
        "type": "match",
        "left": [
            "Connections",
            "Operations",
            "Memory",
            "Bandwidth"
        ],
        "right": [
            "Pool",
            "Commands",
            "RAM",
            "Network"
        ]
    },
    {
        "q": "Rearrange cache protection:",
        "type": "rearrange",
        "words": [
            "Identify hot keys",
            "Set access limits",
            "Monitor usage",
            "Evict as needed",
            "Scale if required"
        ]
    },
    {
        "q": "What is multi-region rate limiting?",
        "type": "mcq",
        "o": [
            "Coordinating limits across regions",
            "Single region",
            "No coordination",
            "Random limits"
        ]
    },
    {
        "q": "Multi-region requires ______.",
        "type": "fill_blank",
        "answers": [
            "synchronization"
        ],
        "other_options": [
            "isolation",
            "separation",
            "independence"
        ]
    },
    {
        "q": "Global rate limits are hard to implement.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match region strategies:",
        "type": "match",
        "left": [
            "Local only",
            "Regional",
            "Global",
            "Eventual"
        ],
        "right": [
            "Per region",
            "Coordinated region",
            "All regions",
            "Eventually consistent"
        ]
    },
    {
        "q": "What is quota management?",
        "type": "mcq",
        "o": [
            "Managing allocated usage quotas",
            "No management",
            "Unlimited quotas",
            "Fixed quotas"
        ]
    },
    {
        "q": "Quota management tracks ______.",
        "type": "fill_blank",
        "answers": [
            "usage"
        ],
        "other_options": [
            "users",
            "errors",
            "features"
        ]
    },
    {
        "q": "Quotas can be adjusted dynamically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match quota types:",
        "type": "match",
        "left": [
            "Hard",
            "Soft",
            "Burst",
            "Reserved"
        ],
        "right": [
            "Strict limit",
            "Warning",
            "Temporary",
            "Guaranteed"
        ]
    },
    {
        "q": "Rearrange quota management:",
        "type": "rearrange",
        "words": [
            "Define quotas",
            "Allocate to clients",
            "Track usage",
            "Alert on threshold",
            "Adjust as needed"
        ]
    },
    {
        "q": "What is usage metering?",
        "type": "mcq",
        "o": [
            "Measuring API usage",
            "No measurement",
            "Estimation only",
            "Random counting"
        ]
    },
    {
        "q": "Metering supports ______.",
        "type": "fill_blank",
        "answers": [
            "billing"
        ],
        "other_options": [
            "features",
            "users",
            "errors"
        ]
    },
    {
        "q": "Accurate metering is essential for monetization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match metering components:",
        "type": "match",
        "left": [
            "Counter",
            "Aggregator",
            "Reporter",
            "Alerter"
        ],
        "right": [
            "Count events",
            "Combine counts",
            "Generate reports",
            "Notify on threshold"
        ]
    },
    {
        "q": "Rate limiting mastery requires understanding all components.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mastery areas:",
        "type": "match",
        "left": [
            "Algorithms",
            "Infrastructure",
            "Monitoring",
            "Security"
        ],
        "right": [
            "How it works",
            "Where it runs",
            "How to observe",
            "How to protect"
        ]
    },
    {
        "q": "Effective rate limiting balances protection and usability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match balance factors:",
        "type": "match",
        "left": [
            "Protection",
            "Usability",
            "Cost",
            "Complexity"
        ],
        "right": [
            "Prevent abuse",
            "Good UX",
            "Affordable",
            "Maintainable"
        ]
    },
    {
        "q": "Rate limiting is fundamental to modern API platforms.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match platform aspects:",
        "type": "match",
        "left": [
            "Reliability",
            "Scalability",
            "Monetization",
            "Governance"
        ],
        "right": [
            "Works well",
            "Grows well",
            "Makes money",
            "Well managed"
        ]
    },
    {
        "q": "What is API quota enforcement?",
        "type": "mcq",
        "o": [
            "Ensuring quotas are not exceeded",
            "No enforcement",
            "Allowing unlimited",
            "Random enforcement"
        ]
    },
    {
        "q": "Enforcement blocks requests beyond ______.",
        "type": "fill_blank",
        "answers": [
            "quota"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Quota enforcement protects system resources.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match enforcement actions:",
        "type": "match",
        "left": [
            "Block",
            "Throttle",
            "Queue",
            "Warn"
        ],
        "right": [
            "Deny request",
            "Slow down",
            "Hold",
            "Notify only"
        ]
    },
    {
        "q": "Rearrange enforcement:",
        "type": "rearrange",
        "words": [
            "Check quota",
            "Compare usage",
            "Decide action",
            "Execute action",
            "Log result"
        ]
    },
    {
        "q": "What is rate limit token refresh?",
        "type": "mcq",
        "o": [
            "Adding tokens back periodically",
            "Removing tokens",
            "No refresh",
            "Manual only"
        ]
    },
    {
        "q": "Tokens refresh at configured ______.",
        "type": "fill_blank",
        "answers": [
            "intervals"
        ],
        "other_options": [
            "requests",
            "users",
            "errors"
        ]
    },
    {
        "q": "Token refresh enables sustained rate.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match refresh patterns:",
        "type": "match",
        "left": [
            "Continuous",
            "Periodic",
            "Event-based",
            "Manual"
        ],
        "right": [
            "Steady",
            "At intervals",
            "On trigger",
            "Human action"
        ]
    },
    {
        "q": "What is rate limit state management?",
        "type": "mcq",
        "o": [
            "Storing and managing limit counters",
            "No state",
            "Stateless only",
            "Random state"
        ]
    },
    {
        "q": "State stores current ______.",
        "type": "fill_blank",
        "answers": [
            "usage"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "State must be consistent for accurate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match state storage:",
        "type": "match",
        "left": [
            "In-memory",
            "Redis",
            "Database",
            "Distributed"
        ],
        "right": [
            "Local RAM",
            "Key-value",
            "Persistent",
            "Multiple nodes"
        ]
    },
    {
        "q": "Rearrange state update:",
        "type": "rearrange",
        "words": [
            "Get current state",
            "Check limit",
            "Update counter",
            "Save state",
            "Return result"
        ]
    },
    {
        "q": "What is rate limit key design?",
        "type": "mcq",
        "o": [
            "Designing identifiers for rate tracking",
            "No keys",
            "Random keys",
            "Fixed keys only"
        ]
    },
    {
        "q": "Keys identify unique ______.",
        "type": "fill_blank",
        "answers": [
            "clients"
        ],
        "other_options": [
            "servers",
            "data",
            "errors"
        ]
    },
    {
        "q": "Composite keys combine multiple identifiers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match key components:",
        "type": "match",
        "left": [
            "User ID",
            "API key",
            "IP",
            "Endpoint"
        ],
        "right": [
            "Account",
            "Application",
            "Source",
            "Path"
        ]
    },
    {
        "q": "What is rate limit window management?",
        "type": "mcq",
        "o": [
            "Managing time windows for counting",
            "No windows",
            "Fixed only",
            "Random windows"
        ]
    },
    {
        "q": "Windows define counting ______.",
        "type": "fill_blank",
        "answers": [
            "periods"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Window boundaries affect count accuracy.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match window strategies:",
        "type": "match",
        "left": [
            "Fixed",
            "Sliding",
            "Tumbling",
            "Hopping"
        ],
        "right": [
            "Set boundaries",
            "Continuous",
            "Non-overlap",
            "Overlap"
        ]
    },
    {
        "q": "Rearrange window check:",
        "type": "rearrange",
        "words": [
            "Get current time",
            "Determine window",
            "Get count",
            "Check limit",
            "Update count"
        ]
    },
    {
        "q": "What is rate limit counter overflow?",
        "type": "mcq",
        "o": [
            "Counter exceeding storage capacity",
            "Normal operation",
            "Counter reset",
            "No overflow"
        ]
    },
    {
        "q": "Overflow protection prevents ______ issues.",
        "type": "fill_blank",
        "answers": [
            "integer"
        ],
        "other_options": [
            "user",
            "data",
            "feature"
        ]
    },
    {
        "q": "Large counters need overflow protection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match overflow handling:",
        "type": "match",
        "left": [
            "Saturate",
            "Wrap",
            "Error",
            "Reset"
        ],
        "right": [
            "Stay at max",
            "Start over",
            "Fail",
            "Clear"
        ]
    },
    {
        "q": "What is rate limit cleanup?",
        "type": "mcq",
        "o": [
            "Removing old rate limit entries",
            "Keeping forever",
            "No cleanup",
            "Manual only"
        ]
    },
    {
        "q": "Cleanup removes ______ data.",
        "type": "fill_blank",
        "answers": [
            "expired"
        ],
        "other_options": [
            "current",
            "active",
            "new"
        ]
    },
    {
        "q": "TTL-based cleanup is automatic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cleanup strategies:",
        "type": "match",
        "left": [
            "TTL",
            "LRU",
            "Periodic",
            "On-demand"
        ],
        "right": [
            "Time-based",
            "Least recent",
            "Scheduled",
            "When needed"
        ]
    },
    {
        "q": "Rearrange cleanup process:",
        "type": "rearrange",
        "words": [
            "Identify expired",
            "Lock entries",
            "Delete entries",
            "Release locks",
            "Log cleanup"
        ]
    },
    {
        "q": "What is rate limit recovery?",
        "type": "mcq",
        "o": [
            "Restoring rate limit state after failure",
            "No recovery",
            "Manual only",
            "Start fresh"
        ]
    },
    {
        "q": "Recovery restores ______ state.",
        "type": "fill_blank",
        "answers": [
            "previous"
        ],
        "other_options": [
            "new",
            "empty",
            "random"
        ]
    },
    {
        "q": "Persistent storage enables recovery.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match recovery options:",
        "type": "match",
        "left": [
            "Restore",
            "Reset",
            "Estimate",
            "Default"
        ],
        "right": [
            "From backup",
            "Start zero",
            "Approximate",
            "Use fallback"
        ]
    },
    {
        "q": "What is rate limit benchmarking?",
        "type": "mcq",
        "o": [
            "Testing rate limit performance",
            "No testing",
            "Production only",
            "Manual only"
        ]
    },
    {
        "q": "Benchmarks measure ______.",
        "type": "fill_blank",
        "answers": [
            "throughput"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Benchmarking identifies bottlenecks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match benchmark metrics:",
        "type": "match",
        "left": [
            "Latency",
            "Throughput",
            "Memory",
            "CPU"
        ],
        "right": [
            "Response time",
            "Requests/sec",
            "RAM usage",
            "Processing"
        ]
    },
    {
        "q": "Rearrange benchmarking:",
        "type": "rearrange",
        "words": [
            "Define workload",
            "Run tests",
            "Collect metrics",
            "Analyze results",
            "Optimize"
        ]
    },
    {
        "q": "What is rate limit profiling?",
        "type": "mcq",
        "o": [
            "Analyzing rate limit code performance",
            "No profiling",
            "Guessing",
            "Manual only"
        ]
    },
    {
        "q": "Profiling finds ______ spots.",
        "type": "fill_blank",
        "answers": [
            "hot"
        ],
        "other_options": [
            "cold",
            "random",
            "empty"
        ]
    },
    {
        "q": "Profiling guides optimization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match profiling types:",
        "type": "match",
        "left": [
            "CPU",
            "Memory",
            "I/O",
            "Lock"
        ],
        "right": [
            "Processing",
            "Allocation",
            "Disk/network",
            "Contention"
        ]
    },
    {
        "q": "What is rate limit optimization?",
        "type": "mcq",
        "o": [
            "Improving rate limit efficiency",
            "No optimization",
            "Slower is better",
            "Random changes"
        ]
    },
    {
        "q": "Optimization improves ______.",
        "type": "fill_blank",
        "answers": [
            "performance"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Caching can optimize rate limit lookups.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match optimization techniques:",
        "type": "match",
        "left": [
            "Caching",
            "Batching",
            "Async",
            "Compression"
        ],
        "right": [
            "Store locally",
            "Group ops",
            "Non-blocking",
            "Reduce size"
        ]
    },
    {
        "q": "Rearrange optimization:",
        "type": "rearrange",
        "words": [
            "Profile code",
            "Identify issues",
            "Plan changes",
            "Implement",
            "Measure improvement"
        ]
    },
    {
        "q": "What is rate limit high availability?",
        "type": "mcq",
        "o": [
            "Ensuring rate limiting always works",
            "Single point of failure",
            "No redundancy",
            "Manual failover"
        ]
    },
    {
        "q": "HA requires ______.",
        "type": "fill_blank",
        "answers": [
            "redundancy"
        ],
        "other_options": [
            "single server",
            "no backup",
            "manual"
        ]
    },
    {
        "q": "Multiple replicas provide high availability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match HA components:",
        "type": "match",
        "left": [
            "Primary",
            "Replica",
            "Load balancer",
            "Health check"
        ],
        "right": [
            "Main",
            "Backup",
            "Distribution",
            "Monitoring"
        ]
    },
    {
        "q": "What is rate limit disaster recovery?",
        "type": "mcq",
        "o": [
            "Recovering from major failures",
            "No recovery plan",
            "Hope for best",
            "Manual only"
        ]
    },
    {
        "q": "DR ensures business ______.",
        "type": "fill_blank",
        "answers": [
            "continuity"
        ],
        "other_options": [
            "failure",
            "stopping",
            "waiting"
        ]
    },
    {
        "q": "Cross-region replication supports DR.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DR metrics:",
        "type": "match",
        "left": [
            "RTO",
            "RPO",
            "MTD",
            "WRT"
        ],
        "right": [
            "Recovery time",
            "Data loss",
            "Max down",
            "Work recovery"
        ]
    },
    {
        "q": "Rearrange DR planning:",
        "type": "rearrange",
        "words": [
            "Identify risks",
            "Define RTOs",
            "Design solution",
            "Test regularly",
            "Maintain plans"
        ]
    },
    {
        "q": "What is rate limit capacity modeling?",
        "type": "mcq",
        "o": [
            "Predicting rate limit capacity needs",
            "No modeling",
            "Guessing",
            "Random allocation"
        ]
    },
    {
        "q": "Modeling predicts ______ requirements.",
        "type": "fill_blank",
        "answers": [
            "resource"
        ],
        "other_options": [
            "user",
            "data",
            "feature"
        ]
    },
    {
        "q": "Capacity models inform infrastructure planning.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match model inputs:",
        "type": "match",
        "left": [
            "Traffic",
            "Growth",
            "Peaks",
            "SLA"
        ],
        "right": [
            "Current load",
            "Increase rate",
            "Maximum",
            "Guarantees"
        ]
    },
    {
        "q": "What is rate limit cost modeling?",
        "type": "mcq",
        "o": [
            "Calculating rate limit infrastructure costs",
            "Ignoring costs",
            "Free always",
            "Random pricing"
        ]
    },
    {
        "q": "Cost modeling informs ______.",
        "type": "fill_blank",
        "answers": [
            "budgeting"
        ],
        "other_options": [
            "coding",
            "testing",
            "debugging"
        ]
    },
    {
        "q": "Higher limits typically cost more.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cost components:",
        "type": "match",
        "left": [
            "Compute",
            "Storage",
            "Network",
            "Operations"
        ],
        "right": [
            "Processing",
            "Data",
            "Transfer",
            "People"
        ]
    },
    {
        "q": "Rearrange cost analysis:",
        "type": "rearrange",
        "words": [
            "Identify components",
            "Estimate usage",
            "Calculate costs",
            "Compare options",
            "Optimize spend"
        ]
    },
    {
        "q": "What is rate limit API design?",
        "type": "mcq",
        "o": [
            "Designing APIs with rate limiting in mind",
            "Ignoring limits",
            "No design",
            "Random limits"
        ]
    },
    {
        "q": "Good design considers ______ from start.",
        "type": "fill_blank",
        "answers": [
            "limits"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "APIs should document their rate limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design principles:",
        "type": "match",
        "left": [
            "Fairness",
            "Transparency",
            "Flexibility",
            "Predictability"
        ],
        "right": [
            "Equal access",
            "Clear communication",
            "Adjustable",
            "Consistent"
        ]
    },
    {
        "q": "What is rate limit developer experience?",
        "type": "mcq",
        "o": [
            "Making rate limits easy to understand and use",
            "Confusing developers",
            "Hiding limits",
            "No documentation"
        ]
    },
    {
        "q": "Good DX includes clear ______.",
        "type": "fill_blank",
        "answers": [
            "documentation"
        ],
        "other_options": [
            "confusion",
            "hiding",
            "complexity"
        ]
    },
    {
        "q": "Clear error messages improve DX.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DX elements:",
        "type": "match",
        "left": [
            "Docs",
            "SDKs",
            "Dashboards",
            "Support"
        ],
        "right": [
            "Written guide",
            "Code libraries",
            "Visualizations",
            "Help channels"
        ]
    },
    {
        "q": "Rearrange DX improvement:",
        "type": "rearrange",
        "words": [
            "Gather feedback",
            "Identify pain points",
            "Improve docs",
            "Update SDKs",
            "Measure satisfaction"
        ]
    },
    {
        "q": "Rate limiting expertise develops over time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match learning paths:",
        "type": "match",
        "left": [
            "Fundamentals",
            "Intermediate",
            "Advanced",
            "Expert"
        ],
        "right": [
            "Basics",
            "Patterns",
            "Architecture",
            "Optimization"
        ]
    },
    {
        "q": "Comprehensive rate limiting protects API ecosystems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match ecosystem protection:",
        "type": "match",
        "left": [
            "Producers",
            "Consumers",
            "Platform",
            "Users"
        ],
        "right": [
            "API providers",
            "API clients",
            "Infrastructure",
            "End users"
        ]
    },
    {
        "q": "Rate limiting mastery enables API success.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match success metrics:",
        "type": "match",
        "left": [
            "Uptime",
            "Performance",
            "Adoption",
            "Revenue"
        ],
        "right": [
            "Availability",
            "Speed",
            "Usage",
            "Income"
        ]
    },
    {
        "q": "What is API traffic management?",
        "type": "mcq",
        "o": [
            "Controlling API request flow",
            "No management",
            "Random traffic",
            "Unlimited traffic"
        ]
    },
    {
        "q": "Traffic management includes rate limiting and ______.",
        "type": "fill_blank",
        "answers": [
            "throttling"
        ],
        "other_options": [
            "coding",
            "testing",
            "debugging"
        ]
    },
    {
        "q": "Traffic management protects API infrastructure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match traffic controls:",
        "type": "match",
        "left": [
            "Rate limit",
            "Throttle",
            "Shape",
            "Shed"
        ],
        "right": [
            "Cap requests",
            "Slow down",
            "Smooth flow",
            "Drop excess"
        ]
    },
    {
        "q": "Rearrange traffic control:",
        "type": "rearrange",
        "words": [
            "Monitor traffic",
            "Apply policies",
            "Enforce limits",
            "Report metrics",
            "Adjust as needed"
        ]
    },
    {
        "q": "What is API capacity management?",
        "type": "mcq",
        "o": [
            "Managing available API resources",
            "No management",
            "Unlimited capacity",
            "Random allocation"
        ]
    },
    {
        "q": "Capacity management ensures ______ availability.",
        "type": "fill_blank",
        "answers": [
            "resource"
        ],
        "other_options": [
            "random",
            "no",
            "unlimited"
        ]
    },
    {
        "q": "Capacity planning prevents overload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match capacity types:",
        "type": "match",
        "left": [
            "Compute",
            "Memory",
            "Network",
            "Storage"
        ],
        "right": [
            "CPU",
            "RAM",
            "Bandwidth",
            "Disk"
        ]
    },
    {
        "q": "What is API request routing?",
        "type": "mcq",
        "o": [
            "Directing requests to appropriate backends",
            "Random routing",
            "No routing",
            "Single backend"
        ]
    },
    {
        "q": "Routing can distribute load across ______.",
        "type": "fill_blank",
        "answers": [
            "servers"
        ],
        "other_options": [
            "users",
            "data",
            "features"
        ]
    },
    {
        "q": "Load balancing is a form of routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match routing strategies:",
        "type": "match",
        "left": [
            "Round robin",
            "Least conn",
            "Weighted",
            "Hash"
        ],
        "right": [
            "Sequential",
            "Fewest connections",
            "By weight",
            "By key"
        ]
    },
    {
        "q": "Rearrange request routing:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Select backend",
            "Forward request",
            "Get response",
            "Return to client"
        ]
    },
    {
        "q": "What is API circuit breaking?",
        "type": "mcq",
        "o": [
            "Stopping calls to failing services",
            "Always call",
            "No protection",
            "Random behavior"
        ]
    },
    {
        "q": "Circuit breakers prevent ______ failures.",
        "type": "fill_blank",
        "answers": [
            "cascade"
        ],
        "other_options": [
            "single",
            "random",
            "all"
        ]
    },
    {
        "q": "Circuit breakers have open and closed states.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match circuit states:",
        "type": "match",
        "left": [
            "Closed",
            "Open",
            "Half-open",
            "Disabled"
        ],
        "right": [
            "Normal",
            "Blocking",
            "Testing",
            "Off"
        ]
    },
    {
        "q": "What is API retry logic?",
        "type": "mcq",
        "o": [
            "Automatically retrying failed requests",
            "No retries",
            "Manual only",
            "Immediate always"
        ]
    },
    {
        "q": "Retry logic uses ______ between attempts.",
        "type": "fill_blank",
        "answers": [
            "backoff"
        ],
        "other_options": [
            "speed",
            "no delay",
            "constant"
        ]
    },
    {
        "q": "Exponential backoff increases wait time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match retry patterns:",
        "type": "match",
        "left": [
            "Immediate",
            "Fixed",
            "Exponential",
            "Jitter"
        ],
        "right": [
            "No wait",
            "Constant wait",
            "Increasing wait",
            "Random wait"
        ]
    },
    {
        "q": "Rearrange retry flow:",
        "type": "rearrange",
        "words": [
            "Attempt request",
            "Check for failure",
            "Calculate backoff",
            "Wait",
            "Retry"
        ]
    },
    {
        "q": "What is API timeout management?",
        "type": "mcq",
        "o": [
            "Handling slow or stuck requests",
            "Wait forever",
            "No timeouts",
            "Random timeouts"
        ]
    },
    {
        "q": "Timeouts prevent ______ resource usage.",
        "type": "fill_blank",
        "answers": [
            "excessive"
        ],
        "other_options": [
            "normal",
            "expected",
            "minimum"
        ]
    },
    {
        "q": "Connection and read timeouts are different.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match timeout types:",
        "type": "match",
        "left": [
            "Connection",
            "Read",
            "Write",
            "Total"
        ],
        "right": [
            "Connecting",
            "Reading",
            "Writing",
            "Overall"
        ]
    },
    {
        "q": "What is API error handling?",
        "type": "mcq",
        "o": [
            "Managing API failures gracefully",
            "Ignore errors",
            "Crash on error",
            "No handling"
        ]
    },
    {
        "q": "Error handling improves ______.",
        "type": "fill_blank",
        "answers": [
            "reliability"
        ],
        "other_options": [
            "features",
            "speed",
            "size"
        ]
    },
    {
        "q": "429 errors indicate rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error codes:",
        "type": "match",
        "left": [
            "400",
            "401",
            "429",
            "503"
        ],
        "right": [
            "Bad request",
            "Unauthorized",
            "Rate limited",
            "Unavailable"
        ]
    },
    {
        "q": "Rearrange error handling:",
        "type": "rearrange",
        "words": [
            "Detect error",
            "Identify type",
            "Apply strategy",
            "Log error",
            "Return response"
        ]
    },
    {
        "q": "What is API health checking?",
        "type": "mcq",
        "o": [
            "Monitoring API availability",
            "No monitoring",
            "Manual only",
            "Ignore health"
        ]
    },
    {
        "q": "Health checks verify service ______.",
        "type": "fill_blank",
        "answers": [
            "status"
        ],
        "other_options": [
            "color",
            "size",
            "name"
        ]
    },
    {
        "q": "Liveness checks determine if service is running.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match health check types:",
        "type": "match",
        "left": [
            "Liveness",
            "Readiness",
            "Startup",
            "Deep"
        ],
        "right": [
            "Is alive",
            "Can serve",
            "Has started",
            "Full check"
        ]
    },
    {
        "q": "What is API observability?",
        "type": "mcq",
        "o": [
            "Understanding API behavior through data",
            "No observation",
            "Guessing",
            "Ignoring data"
        ]
    },
    {
        "q": "Observability includes logs, metrics, and ______.",
        "type": "fill_blank",
        "answers": [
            "traces"
        ],
        "other_options": [
            "code",
            "users",
            "features"
        ]
    },
    {
        "q": "Observability enables debugging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match observability pillars:",
        "type": "match",
        "left": [
            "Logs",
            "Metrics",
            "Traces",
            "Events"
        ],
        "right": [
            "Text records",
            "Measurements",
            "Request paths",
            "Occurrences"
        ]
    },
    {
        "q": "Rearrange observability setup:",
        "type": "rearrange",
        "words": [
            "Instrument code",
            "Collect data",
            "Store centrally",
            "Visualize",
            "Alert on issues"
        ]
    },
    {
        "q": "Rate limiting is essential for API reliability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match reliability factors:",
        "type": "match",
        "left": [
            "Uptime",
            "Performance",
            "Consistency",
            "Recovery"
        ],
        "right": [
            "Available",
            "Fast",
            "Predictable",
            "Resilient"
        ]
    },
    {
        "q": "Comprehensive rate limiting enables API success.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match success indicators:",
        "type": "match",
        "left": [
            "Adoption",
            "Satisfaction",
            "Revenue",
            "Growth"
        ],
        "right": [
            "Users",
            "Happy users",
            "Money",
            "Expansion"
        ]
    },
    {
        "q": "Rate limiting knowledge is valuable for API developers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match developer skills:",
        "type": "match",
        "left": [
            "Design",
            "Implementation",
            "Monitoring",
            "Optimization"
        ],
        "right": [
            "Plan limits",
            "Build limits",
            "Watch limits",
            "Improve limits"
        ]
    },
    {
        "q": "Rate limiting protects APIs from abuse.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match protection types:",
        "type": "match",
        "left": [
            "DDoS",
            "Scraping",
            "Brute force",
            "Spam"
        ],
        "right": [
            "Overwhelming",
            "Data theft",
            "Password guess",
            "Unwanted"
        ]
    },
    {
        "q": "Rate limiting is a core API security practice.",
        "type": "true_false",
        "correct": "True"
    }
]