[
    {
        "q": "What does GraphQL stand for?",
        "type": "mcq",
        "o": [
            "Graph Query Language",
            "Graphics Query Language",
            "Grouped Query Language",
            "General Query Language"
        ]
    },
    {
        "q": "GraphQL was developed by which company?",
        "type": "mcq",
        "o": [
            "Facebook (Meta)",
            "Google",
            "Microsoft",
            "Amazon"
        ]
    },
    {
        "q": "What year was GraphQL first released publicly?",
        "type": "mcq",
        "o": [
            "2015",
            "2012",
            "2018",
            "2010"
        ]
    },
    {
        "q": "GraphQL uses a single endpoint for all operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ operation is used to read data in GraphQL.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "mutation",
            "subscription",
            "fetch"
        ]
    },
    {
        "q": "Match GraphQL operation types:",
        "type": "match",
        "left": [
            "Query",
            "Mutation",
            "Subscription",
            "Fragment"
        ],
        "right": [
            "Read data",
            "Modify data",
            "Real-time updates",
            "Reusable fields"
        ]
    },
    {
        "q": "Which HTTP method is commonly used for GraphQL requests?",
        "type": "mcq",
        "o": [
            "POST",
            "GET",
            "PUT",
            "PATCH"
        ]
    },
    {
        "q": "GraphQL returns data in which format?",
        "type": "mcq",
        "o": [
            "JSON",
            "XML",
            "YAML",
            "CSV"
        ]
    },
    {
        "q": "The ______ defines the structure of a GraphQL API.",
        "type": "fill_blank",
        "answers": [
            "schema"
        ],
        "other_options": [
            "query",
            "resolver",
            "type"
        ]
    },
    {
        "q": "GraphQL allows clients to request exactly the fields they need.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange GraphQL request flow:",
        "type": "rearrange",
        "words": [
            "Write query",
            "Send to server",
            "Execute resolvers",
            "Return response"
        ]
    },
    {
        "q": "Which symbol denotes a non-nullable field in GraphQL?",
        "type": "mcq",
        "o": [
            "!",
            "*",
            "?",
            "@"
        ]
    },
    {
        "q": "The ______ type represents the entry point for queries.",
        "type": "fill_blank",
        "answers": [
            "Query"
        ],
        "other_options": [
            "Root",
            "Entry",
            "Main"
        ]
    },
    {
        "q": "GraphQL supports introspection of the schema.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL scalar types:",
        "type": "match",
        "left": [
            "Int",
            "Float",
            "String",
            "Boolean"
        ],
        "right": [
            "Whole number",
            "Decimal number",
            "Text",
            "True/False"
        ]
    },
    {
        "q": "Which scalar type represents unique identifiers in GraphQL?",
        "type": "mcq",
        "o": [
            "ID",
            "UUID",
            "Key",
            "Identifier"
        ]
    },
    {
        "q": "The ______ operation is used to modify data in GraphQL.",
        "type": "fill_blank",
        "answers": [
            "mutation"
        ],
        "other_options": [
            "update",
            "change",
            "modify"
        ]
    },
    {
        "q": "GraphQL can fetch related data in a single request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange GraphQL type definition:",
        "type": "rearrange",
        "words": [
            "type",
            "TypeName",
            "{",
            "field: Type",
            "}"
        ]
    },
    {
        "q": "Which keyword defines a new type in GraphQL?",
        "type": "mcq",
        "o": [
            "type",
            "class",
            "object",
            "define"
        ]
    },
    {
        "q": "Match GraphQL concepts:",
        "type": "match",
        "left": [
            "Schema",
            "Resolver",
            "Type",
            "Field"
        ],
        "right": [
            "API structure",
            "Data fetcher",
            "Object definition",
            "Property"
        ]
    },
    {
        "q": "The ______ function fetches data for a field.",
        "type": "fill_blank",
        "answers": [
            "resolver"
        ],
        "other_options": [
            "fetcher",
            "handler",
            "getter"
        ]
    },
    {
        "q": "GraphQL queries are validated against the schema.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which tool is commonly used to explore GraphQL APIs?",
        "type": "mcq",
        "o": [
            "GraphiQL",
            "Postman",
            "Swagger",
            "cURL"
        ]
    },
    {
        "q": "The ______ keyword makes a field required in GraphQL.",
        "type": "fill_blank",
        "answers": [
            "!"
        ],
        "other_options": [
            "required",
            "*",
            "must"
        ]
    },
    {
        "q": "GraphQL supports real-time subscriptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL tools:",
        "type": "match",
        "left": [
            "GraphiQL",
            "Apollo",
            "Relay",
            "Hasura"
        ],
        "right": [
            "IDE explorer",
            "Client library",
            "Facebook client",
            "Backend engine"
        ]
    },
    {
        "q": "Rearrange mutation structure:",
        "type": "rearrange",
        "words": [
            "mutation",
            "MutationName",
            "(",
            "input: InputType",
            ")",
            "{",
            "field",
            "}"
        ]
    },
    {
        "q": "Which is a valid GraphQL query?",
        "type": "mcq",
        "o": [
            "{ user { name } }",
            "SELECT name FROM user",
            "GET /user/name",
            "user.name"
        ]
    },
    {
        "q": "The ______ type represents list data in GraphQL.",
        "type": "fill_blank",
        "answers": [
            "[Type]"
        ],
        "other_options": [
            "Array",
            "List",
            "Collection"
        ]
    },
    {
        "q": "GraphQL prevents over-fetching of data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match query elements:",
        "type": "match",
        "left": [
            "Operation name",
            "Variables",
            "Fields",
            "Arguments"
        ],
        "right": [
            "Query identifier",
            "Dynamic values",
            "Requested data",
            "Filter criteria"
        ]
    },
    {
        "q": "Which argument passes dynamic values to a GraphQL query?",
        "type": "mcq",
        "o": [
            "Variables",
            "Parameters",
            "Inputs",
            "Args"
        ]
    },
    {
        "q": "The ______ prefix denotes a variable in GraphQL.",
        "type": "fill_blank",
        "answers": [
            "$"
        ],
        "other_options": [
            "@",
            "#",
            "&"
        ]
    },
    {
        "q": "GraphQL supports aliases to rename fields in responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange query with variables:",
        "type": "rearrange",
        "words": [
            "query GetUser($id: ID!)",
            "{",
            "user(id: $id)",
            "{ name }",
            "}"
        ]
    },
    {
        "q": "Which feature allows reusing field selections?",
        "type": "mcq",
        "o": [
            "Fragments",
            "Variables",
            "Aliases",
            "Directives"
        ]
    },
    {
        "q": "The ______ keyword defines a reusable set of fields.",
        "type": "fill_blank",
        "answers": [
            "fragment"
        ],
        "other_options": [
            "partial",
            "include",
            "mixin"
        ]
    },
    {
        "q": "Match fragment syntax:",
        "type": "match",
        "left": [
            "fragment",
            "on",
            "...FragmentName",
            "inline spread"
        ],
        "right": [
            "Define reusable",
            "Target type",
            "Use fragment",
            "Inline fields"
        ]
    },
    {
        "q": "Fragments must specify a target type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which directive conditionally includes a field?",
        "type": "mcq",
        "o": [
            "@include",
            "@if",
            "@show",
            "@when"
        ]
    },
    {
        "q": "The ______ directive excludes a field conditionally.",
        "type": "fill_blank",
        "answers": [
            "@skip"
        ],
        "other_options": [
            "@exclude",
            "@hide",
            "@omit"
        ]
    },
    {
        "q": "Directives can modify query execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match built-in directives:",
        "type": "match",
        "left": [
            "@include",
            "@skip",
            "@deprecated",
            "@specifiedBy"
        ],
        "right": [
            "Conditional include",
            "Conditional exclude",
            "Mark outdated",
            "Scalar spec"
        ]
    },
    {
        "q": "Rearrange directive usage:",
        "type": "rearrange",
        "words": [
            "fieldName",
            "@include(if: $condition)",
            "{",
            "subField",
            "}"
        ]
    },
    {
        "q": "Which type represents enumerated values?",
        "type": "mcq",
        "o": [
            "enum",
            "const",
            "list",
            "set"
        ]
    },
    {
        "q": "The ______ keyword defines an enumeration type.",
        "type": "fill_blank",
        "answers": [
            "enum"
        ],
        "other_options": [
            "enumeration",
            "constant",
            "option"
        ]
    },
    {
        "q": "Enum values are case-sensitive in GraphQL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match enum usage:",
        "type": "match",
        "left": [
            "Status",
            "Role",
            "Priority",
            "Category"
        ],
        "right": [
            "ACTIVE | INACTIVE",
            "ADMIN | USER",
            "HIGH | LOW",
            "TECH | NEWS"
        ]
    },
    {
        "q": "Which type allows different object types in one field?",
        "type": "mcq",
        "o": [
            "Union",
            "Mixed",
            "Any",
            "Multi"
        ]
    },
    {
        "q": "The ______ keyword defines a union type.",
        "type": "fill_blank",
        "answers": [
            "union"
        ],
        "other_options": [
            "combine",
            "or",
            "either"
        ]
    },
    {
        "q": "Union types require inline fragments to select fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match union syntax:",
        "type": "match",
        "left": [
            "union",
            "|",
            "...on Type",
            "__typename"
        ],
        "right": [
            "Define union",
            "Separator",
            "Type selection",
            "Type identifier"
        ]
    },
    {
        "q": "Which type defines a contract for objects to implement?",
        "type": "mcq",
        "o": [
            "interface",
            "abstract",
            "protocol",
            "contract"
        ]
    },
    {
        "q": "The ______ keyword creates an interface type.",
        "type": "fill_blank",
        "answers": [
            "interface"
        ],
        "other_options": [
            "abstract",
            "base",
            "template"
        ]
    },
    {
        "q": "Types implementing an interface must define all its fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange interface implementation:",
        "type": "rearrange",
        "words": [
            "type",
            "TypeName",
            "implements",
            "InterfaceName",
            "{",
            "fields",
            "}"
        ]
    },
    {
        "q": "Match interface concepts:",
        "type": "match",
        "left": [
            "Interface",
            "implements",
            "Shared fields",
            "Polymorphism"
        ],
        "right": [
            "Contract",
            "Adoption keyword",
            "Common structure",
            "Multiple types"
        ]
    },
    {
        "q": "Which type is used for mutation inputs?",
        "type": "mcq",
        "o": [
            "input",
            "param",
            "data",
            "args"
        ]
    },
    {
        "q": "The ______ keyword defines an input object type.",
        "type": "fill_blank",
        "answers": [
            "input"
        ],
        "other_options": [
            "params",
            "data",
            "args"
        ]
    },
    {
        "q": "Input types can only contain scalar and other input types.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match input type usage:",
        "type": "match",
        "left": [
            "CreateUserInput",
            "UpdatePostInput",
            "FilterInput",
            "PaginationInput"
        ],
        "right": [
            "New user data",
            "Post changes",
            "Query filters",
            "Page controls"
        ]
    },
    {
        "q": "Rearrange input type definition:",
        "type": "rearrange",
        "words": [
            "input",
            "CreateUserInput",
            "{",
            "name: String!",
            "email: String!",
            "}"
        ]
    },
    {
        "q": "Which feature enables real-time data updates?",
        "type": "mcq",
        "o": [
            "Subscription",
            "Polling",
            "WebHook",
            "Callback"
        ]
    },
    {
        "q": "The ______ type defines real-time operations.",
        "type": "fill_blank",
        "answers": [
            "Subscription"
        ],
        "other_options": [
            "Stream",
            "Live",
            "Realtime"
        ]
    },
    {
        "q": "Subscriptions typically use WebSocket connections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match subscription concepts:",
        "type": "match",
        "left": [
            "Subscribe",
            "Publish",
            "Event",
            "Unsubscribe"
        ],
        "right": [
            "Start listening",
            "Send update",
            "Data change",
            "Stop listening"
        ]
    },
    {
        "q": "Which protocol is commonly used for GraphQL subscriptions?",
        "type": "mcq",
        "o": [
            "WebSocket",
            "HTTP",
            "TCP",
            "UDP"
        ]
    },
    {
        "q": "The ______ pattern implements pub-sub for subscriptions.",
        "type": "fill_blank",
        "answers": [
            "publish-subscribe"
        ],
        "other_options": [
            "observer",
            "event",
            "listener"
        ]
    },
    {
        "q": "Subscriptions maintain persistent connections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange subscription flow:",
        "type": "rearrange",
        "words": [
            "Client subscribes",
            "Server listens for events",
            "Event occurs",
            "Server pushes data",
            "Client receives update"
        ]
    },
    {
        "q": "Which query asks GraphQL about its own schema?",
        "type": "mcq",
        "o": [
            "__schema",
            "getSchema",
            "schema()",
            "introspect"
        ]
    },
    {
        "q": "The ______ query returns type information.",
        "type": "fill_blank",
        "answers": [
            "__type"
        ],
        "other_options": [
            "getType",
            "typeInfo",
            "describe"
        ]
    },
    {
        "q": "Introspection can be disabled for production APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match introspection fields:",
        "type": "match",
        "left": [
            "__schema",
            "__type",
            "__typename",
            "__fields"
        ],
        "right": [
            "Full schema",
            "Specific type",
            "Current type name",
            "Type fields"
        ]
    },
    {
        "q": "Which tool generates documentation from GraphQL schemas?",
        "type": "mcq",
        "o": [
            "GraphQL Voyager",
            "Swagger",
            "Postman",
            "RAML"
        ]
    },
    {
        "q": "The ______ field returns the current object's type name.",
        "type": "fill_blank",
        "answers": [
            "__typename"
        ],
        "other_options": [
            "typeName",
            "objectType",
            "kind"
        ]
    },
    {
        "q": "Introspection is useful for client code generation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange introspection query:",
        "type": "rearrange",
        "words": [
            "{",
            "__schema",
            "{",
            "types { name }",
            "}",
            "}"
        ]
    },
    {
        "q": "Which argument limits the number of items returned?",
        "type": "mcq",
        "o": [
            "first",
            "limit",
            "count",
            "max"
        ]
    },
    {
        "q": "The ______ argument specifies the starting point for pagination.",
        "type": "fill_blank",
        "answers": [
            "after"
        ],
        "other_options": [
            "offset",
            "from",
            "start"
        ]
    },
    {
        "q": "Cursor-based pagination is preferred in GraphQL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match pagination arguments:",
        "type": "match",
        "left": [
            "first",
            "after",
            "last",
            "before"
        ],
        "right": [
            "Forward count",
            "Forward cursor",
            "Backward count",
            "Backward cursor"
        ]
    },
    {
        "q": "Which type wraps paginated results in Relay?",
        "type": "mcq",
        "o": [
            "Connection",
            "Page",
            "List",
            "Collection"
        ]
    },
    {
        "q": "The ______ type contains pagination metadata.",
        "type": "fill_blank",
        "answers": [
            "PageInfo"
        ],
        "other_options": [
            "PaginationInfo",
            "Meta",
            "Cursor"
        ]
    },
    {
        "q": "Edges contain both node data and cursor.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange connection structure:",
        "type": "rearrange",
        "words": [
            "Connection",
            "edges",
            "node",
            "cursor",
            "pageInfo"
        ]
    },
    {
        "q": "Match connection fields:",
        "type": "match",
        "left": [
            "edges",
            "node",
            "cursor",
            "pageInfo"
        ],
        "right": [
            "Item wrapper",
            "Actual data",
            "Position",
            "Page metadata"
        ]
    },
    {
        "q": "Which library implements the Relay connection specification?",
        "type": "mcq",
        "o": [
            "Relay",
            "Apollo",
            "URQL",
            "Vue Apollo"
        ]
    },
    {
        "q": "The ______ field indicates if more pages exist.",
        "type": "fill_blank",
        "answers": [
            "hasNextPage"
        ],
        "other_options": [
            "morePages",
            "hasMore",
            "nextExists"
        ]
    },
    {
        "q": "The Relay specification standardizes pagination.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which error type indicates an invalid query?",
        "type": "mcq",
        "o": [
            "Syntax error",
            "Runtime error",
            "Server error",
            "Network error"
        ]
    },
    {
        "q": "The ______ field contains error details in responses.",
        "type": "fill_blank",
        "answers": [
            "errors"
        ],
        "other_options": [
            "error",
            "messages",
            "problems"
        ]
    },
    {
        "q": "GraphQL can return partial data with errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error fields:",
        "type": "match",
        "left": [
            "message",
            "locations",
            "path",
            "extensions"
        ],
        "right": [
            "Error text",
            "Query position",
            "Field path",
            "Custom data"
        ]
    },
    {
        "q": "Rearrange error response structure:",
        "type": "rearrange",
        "words": [
            "{",
            "data: null",
            "errors:",
            "[",
            "{ message, path }",
            "]",
            "}"
        ]
    },
    {
        "q": "GraphQL always returns HTTP 200 even with errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles authorization in GraphQL?",
        "type": "mcq",
        "o": [
            "Resolver-level checks",
            "URL-based",
            "Method-based",
            "Path-based"
        ]
    },
    {
        "q": "The ______ context passes authentication info to resolvers.",
        "type": "fill_blank",
        "answers": [
            "context"
        ],
        "other_options": [
            "request",
            "session",
            "auth"
        ]
    },
    {
        "q": "Authorization should happen at the resolver level.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this resolver?",
        "type": "mcq",
        "c": "const resolvers = {\n    Query: {\n        user: (parent, args, context) => {\n            return context.db.findUser(args.id);\n        }\n    }\n};",
        "o": [
            "User object from database lookup",
            "All users",
            "Error response",
            "Null"
        ]
    },
    {
        "q": "Which library provides a GraphQL server for Node.js?",
        "type": "mcq",
        "o": [
            "Apollo Server",
            "Express",
            "Fastify",
            "Koa"
        ]
    },
    {
        "q": "The ______ object provides database access in resolvers.",
        "type": "fill_blank",
        "answers": [
            "context"
        ],
        "other_options": [
            "parent",
            "args",
            "info"
        ]
    },
    {
        "q": "Match resolver arguments:",
        "type": "match",
        "left": [
            "parent",
            "args",
            "context",
            "info"
        ],
        "right": [
            "Parent result",
            "Field arguments",
            "Shared state",
            "Query metadata"
        ]
    },
    {
        "q": "Resolvers can be async functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange resolver execution:",
        "type": "rearrange",
        "words": [
            "Parse query",
            "Validate schema",
            "Execute resolvers",
            "Format response"
        ]
    },
    {
        "q": "Which pattern prevents N+1 query problems?",
        "type": "mcq",
        "o": [
            "DataLoader",
            "Caching",
            "Indexing",
            "Prefetching"
        ]
    },
    {
        "q": "The ______ library batches and caches database requests.",
        "type": "fill_blank",
        "answers": [
            "DataLoader"
        ],
        "other_options": [
            "BatchLoader",
            "QueryBatcher",
            "LoaderJS"
        ]
    },
    {
        "q": "DataLoader deduplicates requests within a single request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DataLoader concepts:",
        "type": "match",
        "left": [
            "Batch",
            "Cache",
            "Keys",
            "Load"
        ],
        "right": [
            "Group requests",
            "Store results",
            "Request identifiers",
            "Fetch data"
        ]
    },
    {
        "q": "What is the output of this DataLoader usage?",
        "type": "mcq",
        "c": "const userLoader = new DataLoader(async (ids) => {\n    const users = await db.users.findByIds(ids);\n    return ids.map(id => users.find(u => u.id === id));\n});\n// Called: userLoader.load(1), userLoader.load(2), userLoader.load(1)",
        "o": [
            "Two database requests batched into one",
            "Three separate requests",
            "One request per unique ID",
            "No requests"
        ]
    },
    {
        "q": "Rearrange DataLoader flow:",
        "type": "rearrange",
        "words": [
            "Collect load calls",
            "Batch into single request",
            "Execute batch function",
            "Distribute results"
        ]
    },
    {
        "q": "Which approach validates GraphQL queries?",
        "type": "mcq",
        "o": [
            "Schema validation at parse time",
            "Runtime validation",
            "Client validation only",
            "No validation"
        ]
    },
    {
        "q": "The ______ phase checks query validity against schema.",
        "type": "fill_blank",
        "answers": [
            "validation"
        ],
        "other_options": [
            "parsing",
            "execution",
            "serialization"
        ]
    },
    {
        "q": "Validation happens before execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match validation error types:",
        "type": "match",
        "left": [
            "Syntax",
            "Semantic",
            "Type",
            "Field"
        ],
        "right": [
            "Invalid structure",
            "Invalid meaning",
            "Wrong data type",
            "Unknown field"
        ]
    },
    {
        "q": "Which tool generates TypeScript types from GraphQL?",
        "type": "mcq",
        "o": [
            "GraphQL Code Generator",
            "TypeScript Compiler",
            "Babel",
            "ESLint"
        ]
    },
    {
        "q": "The ______ plugin generates TypeScript interfaces.",
        "type": "fill_blank",
        "answers": [
            "typescript"
        ],
        "other_options": [
            "types",
            "interfaces",
            "typegen"
        ]
    },
    {
        "q": "Code generation improves type safety.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match codegen outputs:",
        "type": "match",
        "left": [
            "Types",
            "Operations",
            "Resolvers",
            "SDK"
        ],
        "right": [
            "Schema types",
            "Query functions",
            "Handler types",
            "Client library"
        ]
    },
    {
        "q": "Which approach handles file uploads in GraphQL?",
        "type": "mcq",
        "o": [
            "Multipart request specification",
            "Base64 encoding",
            "Separate REST endpoint",
            "Not supported"
        ]
    },
    {
        "q": "The ______ scalar type handles file uploads.",
        "type": "fill_blank",
        "answers": [
            "Upload"
        ],
        "other_options": [
            "File",
            "Binary",
            "Blob"
        ]
    },
    {
        "q": "File uploads use multipart form data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match upload handling:",
        "type": "match",
        "left": [
            "File stream",
            "Filename",
            "Mimetype",
            "Encoding"
        ],
        "right": [
            "Binary data",
            "Original name",
            "Content type",
            "Transfer encoding"
        ]
    },
    {
        "q": "Which client library is maintained by Apollo?",
        "type": "mcq",
        "o": [
            "Apollo Client",
            "Relay",
            "URQL",
            "GraphQL Request"
        ]
    },
    {
        "q": "The ______ hook fetches data in React with Apollo.",
        "type": "fill_blank",
        "answers": [
            "useQuery"
        ],
        "other_options": [
            "useFetch",
            "useData",
            "useGet"
        ]
    },
    {
        "q": "Apollo Client includes caching by default.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match Apollo Client hooks:",
        "type": "match",
        "left": [
            "useQuery",
            "useMutation",
            "useSubscription",
            "useLazyQuery"
        ],
        "right": [
            "Fetch data",
            "Modify data",
            "Real-time updates",
            "Manual fetch"
        ]
    },
    {
        "q": "Rearrange Apollo Client setup:",
        "type": "rearrange",
        "words": [
            "Create client",
            "Configure cache",
            "Add link chain",
            "Wrap with provider"
        ]
    },
    {
        "q": "Which caching strategy normalizes objects by ID?",
        "type": "mcq",
        "o": [
            "InMemoryCache",
            "HttpCache",
            "DiskCache",
            "NoCache"
        ]
    },
    {
        "q": "The ______ field uniquely identifies cached objects.",
        "type": "fill_blank",
        "answers": [
            "id"
        ],
        "other_options": [
            "key",
            "uid",
            "ref"
        ]
    },
    {
        "q": "Cache normalization prevents duplicate data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cache policies:",
        "type": "match",
        "left": [
            "cache-first",
            "network-only",
            "cache-and-network",
            "no-cache"
        ],
        "right": [
            "Cache priority",
            "Always fetch",
            "Both sources",
            "No caching"
        ]
    },
    {
        "q": "What is the output of this cache update?",
        "type": "mcq",
        "c": "cache.modify({\n    id: cache.identify(user),\n    fields: {\n        name() {\n            return 'Updated Name';\n        }\n    }\n});",
        "o": [
            "User name updated in cache",
            "User deleted",
            "No change",
            "Cache cleared"
        ]
    },
    {
        "q": "Rearrange cache update flow:",
        "type": "rearrange",
        "words": [
            "Identify object",
            "Specify fields",
            "Return new value",
            "Cache updates"
        ]
    },
    {
        "q": "Which approach handles optimistic updates?",
        "type": "mcq",
        "o": [
            "Immediate UI update before server response",
            "Wait for server",
            "Polling",
            "Refreshing"
        ]
    },
    {
        "q": "The ______ response is used for optimistic updates.",
        "type": "fill_blank",
        "answers": [
            "optimisticResponse"
        ],
        "other_options": [
            "immediateResponse",
            "fakeResponse",
            "tempResponse"
        ]
    },
    {
        "q": "Optimistic updates improve perceived performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match optimistic update flow:",
        "type": "match",
        "left": [
            "Prepare",
            "Apply",
            "Wait",
            "Reconcile"
        ],
        "right": [
            "Create fake result",
            "Update cache",
            "Server response",
            "Handle conflicts"
        ]
    },
    {
        "q": "Which approach handles GraphQL persisted queries?",
        "type": "mcq",
        "o": [
            "Hash queries and send hash instead of full query",
            "Store queries in database",
            "Compile to binary",
            "No persistence"
        ]
    },
    {
        "q": "The ______ approach reduces request size.",
        "type": "fill_blank",
        "answers": [
            "persisted queries"
        ],
        "other_options": [
            "compressed queries",
            "minified queries",
            "cached queries"
        ]
    },
    {
        "q": "Persisted queries improve security by limiting allowed queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match persisted query benefits:",
        "type": "match",
        "left": [
            "Smaller payload",
            "Security",
            "CDN caching",
            "Faster parsing"
        ],
        "right": [
            "Hash vs full query",
            "Allowlist queries",
            "GET requests",
            "Pre-validated"
        ]
    },
    {
        "q": "Which tool enforces schema conventions?",
        "type": "mcq",
        "o": [
            "GraphQL ESLint",
            "Prettier",
            "TSLint",
            "JSHint"
        ]
    },
    {
        "q": "The ______ tool formats GraphQL documents.",
        "type": "fill_blank",
        "answers": [
            "prettier"
        ],
        "other_options": [
            "graphql-format",
            "gql-lint",
            "schema-lint"
        ]
    },
    {
        "q": "Linting catches schema issues early.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match schema best practices:",
        "type": "match",
        "left": [
            "Naming",
            "Nullability",
            "Descriptions",
            "Deprecation"
        ],
        "right": [
            "Consistent casing",
            "Explicit non-null",
            "Documentation",
            "Migration support"
        ]
    },
    {
        "q": "Which approach prevents deeply nested queries?",
        "type": "mcq",
        "o": [
            "Query depth limiting",
            "No nested types",
            "Client validation",
            "POST size limit"
        ]
    },
    {
        "q": "The ______ limit restricts query nesting levels.",
        "type": "fill_blank",
        "answers": [
            "depth"
        ],
        "other_options": [
            "nesting",
            "level",
            "recursion"
        ]
    },
    {
        "q": "Depth limiting prevents DoS attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match query complexity controls:",
        "type": "match",
        "left": [
            "Depth limit",
            "Cost analysis",
            "Timeout",
            "Rate limiting"
        ],
        "right": [
            "Nesting levels",
            "Field weights",
            "Execution time",
            "Request count"
        ]
    },
    {
        "q": "What is the output of this complexity calculation?",
        "type": "mcq",
        "c": "// Query: { users { posts { comments } } }\n// Depth: 3, Field count: 3, List multiplier: 10\nconst complexity = 3 * 10 * 10;",
        "o": [
            "300",
            "30",
            "3",
            "1000"
        ]
    },
    {
        "q": "Rearrange query validation:",
        "type": "rearrange",
        "words": [
            "Parse query",
            "Check depth",
            "Calculate cost",
            "Reject if over limit"
        ]
    },
    {
        "q": "Which approach handles schema stitching?",
        "type": "mcq",
        "o": [
            "Combine multiple schemas into one",
            "Split single schema",
            "Clone schema",
            "Version schema"
        ]
    },
    {
        "q": "The ______ approach merges remote schemas.",
        "type": "fill_blank",
        "answers": [
            "schema stitching"
        ],
        "other_options": [
            "schema merging",
            "schema join",
            "schema combine"
        ]
    },
    {
        "q": "Schema stitching enables microservices with GraphQL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match stitching concepts:",
        "type": "match",
        "left": [
            "Remote schema",
            "Delegation",
            "Transforms",
            "Links"
        ],
        "right": [
            "External schema",
            "Forward requests",
            "Modify schema",
            "Connect types"
        ]
    },
    {
        "q": "Which specification standardizes GraphQL federation?",
        "type": "mcq",
        "o": [
            "Apollo Federation",
            "GraphQL Mesh",
            "Schema Stitching",
            "GraphQL Modules"
        ]
    },
    {
        "q": "The ______ directive marks a type as federated entity.",
        "type": "fill_blank",
        "answers": [
            "@key"
        ],
        "other_options": [
            "@entity",
            "@federated",
            "@shared"
        ]
    },
    {
        "q": "Federation allows independent service development.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match federation directives:",
        "type": "match",
        "left": [
            "@key",
            "@external",
            "@requires",
            "@provides"
        ],
        "right": [
            "Entity identifier",
            "External field",
            "Dependencies",
            "Guaranteed fields"
        ]
    },
    {
        "q": "Rearrange federation setup:",
        "type": "rearrange",
        "words": [
            "Define subgraphs",
            "Mark entities",
            "Configure gateway",
            "Compose supergraph"
        ]
    },
    {
        "q": "Which approach handles GraphQL subscriptions transport?",
        "type": "mcq",
        "o": [
            "graphql-ws protocol",
            "HTTP long polling",
            "REST webhooks",
            "Email notifications"
        ]
    },
    {
        "q": "The ______ protocol handles subscription connections.",
        "type": "fill_blank",
        "answers": [
            "graphql-ws"
        ],
        "other_options": [
            "ws-graphql",
            "subscription-ws",
            "gql-socket"
        ]
    },
    {
        "q": "Subscriptions require persistent connections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match subscription message types:",
        "type": "match",
        "left": [
            "connection_init",
            "subscribe",
            "next",
            "complete"
        ],
        "right": [
            "Start connection",
            "Begin subscription",
            "Data update",
            "End subscription"
        ]
    },
    {
        "q": "What is the output of this subscription resolver?",
        "type": "mcq",
        "c": "const resolvers = {\n    Subscription: {\n        newMessage: {\n            subscribe: () => pubsub.asyncIterator(['MESSAGE_ADDED'])\n        }\n    }\n};",
        "o": [
            "Async iterator for real-time messages",
            "Single message",
            "All messages",
            "No messages"
        ]
    },
    {
        "q": "Rearrange subscription resolver:",
        "type": "rearrange",
        "words": [
            "Define subscribe",
            "Return async iterator",
            "Publish events",
            "Push to clients"
        ]
    },
    {
        "q": "Which approach handles custom scalars?",
        "type": "mcq",
        "o": [
            "Define parsing and serialization functions",
            "Use string type",
            "JSON encode",
            "Not supported"
        ]
    },
    {
        "q": "The ______ function converts input to internal type.",
        "type": "fill_blank",
        "answers": [
            "parseValue"
        ],
        "other_options": [
            "parse",
            "convert",
            "deserialize"
        ]
    },
    {
        "q": "Custom scalars need serialize and parseValue functions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match scalar functions:",
        "type": "match",
        "left": [
            "serialize",
            "parseValue",
            "parseLiteral",
            "description"
        ],
        "right": [
            "Output format",
            "Variable input",
            "Query input",
            "Documentation"
        ]
    },
    {
        "q": "What is the output of this custom scalar?",
        "type": "mcq",
        "c": "const DateScalar = new GraphQLScalarType({\n    name: 'Date',\n    serialize(value) {\n        return value.toISOString();\n    },\n    parseValue(value) {\n        return new Date(value);\n    }\n});",
        "o": [
            "Date object serialized to ISO string",
            "Unix timestamp",
            "Formatted string",
            "Date array"
        ]
    },
    {
        "q": "Rearrange custom scalar definition:",
        "type": "rearrange",
        "words": [
            "Create GraphQLScalarType",
            "Define serialize",
            "Define parseValue",
            "Add to schema"
        ]
    },
    {
        "q": "Which approach handles schema directives?",
        "type": "mcq",
        "o": [
            "Custom directive transformers",
            "Built-in only",
            "Client-side",
            "Not customizable"
        ]
    },
    {
        "q": "The ______ class creates custom directive handlers.",
        "type": "fill_blank",
        "answers": [
            "SchemaDirectiveVisitor"
        ],
        "other_options": [
            "DirectiveHandler",
            "DirectiveTransformer",
            "SchemaTransformer"
        ]
    },
    {
        "q": "Custom directives can modify field resolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match directive locations:",
        "type": "match",
        "left": [
            "FIELD_DEFINITION",
            "OBJECT",
            "INPUT_FIELD_DEFINITION",
            "ARGUMENT_DEFINITION"
        ],
        "right": [
            "Field level",
            "Type level",
            "Input field",
            "Argument level"
        ]
    },
    {
        "q": "What is the output of this auth directive?",
        "type": "mcq",
        "c": "class AuthDirective extends SchemaDirectiveVisitor {\n    visitFieldDefinition(field) {\n        const { resolve = defaultFieldResolver } = field;\n        field.resolve = async (root, args, context, info) => {\n            if (!context.user) throw new Error('Not authenticated');\n            return resolve(root, args, context, info);\n        };\n    }\n}",
        "o": [
            "Field requires authentication",
            "Field is public",
            "Field is cached",
            "Field is deprecated"
        ]
    },
    {
        "q": "Rearrange directive implementation:",
        "type": "rearrange",
        "words": [
            "Extend SchemaDirectiveVisitor",
            "Override visit method",
            "Wrap resolver",
            "Apply to schema"
        ]
    },
    {
        "q": "Which approach handles GraphQL testing?",
        "type": "mcq",
        "o": [
            "Execute queries against test schema",
            "Mock HTTP",
            "UI testing only",
            "No testing needed"
        ]
    },
    {
        "q": "The ______ helper executes queries for testing.",
        "type": "fill_blank",
        "answers": [
            "graphql"
        ],
        "other_options": [
            "test",
            "run",
            "execute"
        ]
    },
    {
        "q": "Resolvers should be unit tested separately.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match testing strategies:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "E2E",
            "Schema"
        ],
        "right": [
            "Resolver logic",
            "Full query",
            "Client to server",
            "Type coverage"
        ]
    },
    {
        "q": "What is the output of this resolver test?",
        "type": "mcq",
        "c": "const result = await graphql({\n    schema,\n    source: '{ user(id: \"1\") { name } }',\n    contextValue: { db: mockDb }\n});\nconsole.log(result.data?.user?.name);",
        "o": [
            "User name from mock database",
            "Undefined",
            "Error",
            "Schema"
        ]
    },
    {
        "q": "Rearrange test setup:",
        "type": "rearrange",
        "words": [
            "Create mock context",
            "Define test query",
            "Execute against schema",
            "Assert result"
        ]
    },
    {
        "q": "Which approach handles GraphQL documentation?",
        "type": "mcq",
        "o": [
            "Schema descriptions and tools like GraphiQL",
            "Separate documentation",
            "README only",
            "No documentation"
        ]
    },
    {
        "q": "The ______ triple-quote adds descriptions in SDL.",
        "type": "fill_blank",
        "answers": [
            "\"\"\""
        ],
        "other_options": [
            "'''",
            "///",
            "###"
        ]
    },
    {
        "q": "GraphQL schemas are self-documenting through introspection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match documentation tools:",
        "type": "match",
        "left": [
            "GraphiQL",
            "Voyager",
            "Playground",
            "Altair"
        ],
        "right": [
            "Query IDE",
            "Schema visualization",
            "Prisma tool",
            "Alternative client"
        ]
    },
    {
        "q": "Which approach handles schema evolution?",
        "type": "mcq",
        "o": [
            "Add fields and deprecate old ones",
            "Remove fields immediately",
            "Version in URL",
            "New schema file"
        ]
    },
    {
        "q": "The ______ directive marks fields for removal.",
        "type": "fill_blank",
        "answers": [
            "@deprecated"
        ],
        "other_options": [
            "@old",
            "@remove",
            "@legacy"
        ]
    },
    {
        "q": "GraphQL encourages versionless evolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match evolution strategies:",
        "type": "match",
        "left": [
            "Add field",
            "Deprecate",
            "Migrate",
            "Remove"
        ],
        "right": [
            "Backward compatible",
            "Mark outdated",
            "Move clients",
            "After migration"
        ]
    },
    {
        "q": "Rearrange schema evolution:",
        "type": "rearrange",
        "words": [
            "Add new field",
            "Deprecate old field",
            "Migrate clients",
            "Remove old field"
        ]
    },
    {
        "q": "Which approach handles error masking?",
        "type": "mcq",
        "o": [
            "Hide internal errors from production responses",
            "Show all errors",
            "No errors returned",
            "Client filtering"
        ]
    },
    {
        "q": "The ______ handler formats errors for responses.",
        "type": "fill_blank",
        "answers": [
            "formatError"
        ],
        "other_options": [
            "errorFormatter",
            "handleError",
            "processError"
        ]
    },
    {
        "q": "Production should hide stack traces.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error handling:",
        "type": "match",
        "left": [
            "Validation",
            "Execution",
            "User",
            "System"
        ],
        "right": [
            "Invalid query",
            "Resolver error",
            "Business logic",
            "Server issue"
        ]
    },
    {
        "q": "Which approach handles tracing in GraphQL?",
        "type": "mcq",
        "o": [
            "Apollo Tracing extension",
            "HTTP headers",
            "Logging only",
            "No tracing"
        ]
    },
    {
        "q": "The ______ extension provides execution timing.",
        "type": "fill_blank",
        "answers": [
            "tracing"
        ],
        "other_options": [
            "timing",
            "metrics",
            "profiling"
        ]
    },
    {
        "q": "Tracing helps identify slow resolvers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match tracing metrics:",
        "type": "match",
        "left": [
            "startTime",
            "endTime",
            "duration",
            "path"
        ],
        "right": [
            "Begin time",
            "Finish time",
            "Total time",
            "Field location"
        ]
    },
    {
        "q": "Which approach handles response caching?",
        "type": "mcq",
        "o": [
            "Cache-Control header directive",
            "No HTTP caching",
            "Client only",
            "Session storage"
        ]
    },
    {
        "q": "The ______ scope indicates private caching.",
        "type": "fill_blank",
        "answers": [
            "private"
        ],
        "other_options": [
            "user",
            "personal",
            "individual"
        ]
    },
    {
        "q": "GET requests can be cached by CDNs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match caching approaches:",
        "type": "match",
        "left": [
            "CDN",
            "Client",
            "Server",
            "Resolver"
        ],
        "right": [
            "Edge caching",
            "Browser cache",
            "Redis/Memcached",
            "DataLoader"
        ]
    },
    {
        "q": "Rearrange caching hierarchy:",
        "type": "rearrange",
        "words": [
            "CDN cache",
            "Client cache",
            "Server cache",
            "Database query"
        ]
    },
    {
        "q": "Which approach handles batched HTTP requests?",
        "type": "mcq",
        "o": [
            "Send multiple queries in one HTTP request",
            "Multiple endpoints",
            "WebSocket only",
            "Not supported"
        ]
    },
    {
        "q": "The ______ request contains multiple operations.",
        "type": "fill_blank",
        "answers": [
            "batch"
        ],
        "other_options": [
            "array",
            "multi",
            "combined"
        ]
    },
    {
        "q": "Batching reduces HTTP overhead.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match batching benefits:",
        "type": "match",
        "left": [
            "Fewer requests",
            "Single connection",
            "Parallel execution",
            "Reduced latency"
        ],
        "right": [
            "Less overhead",
            "Reuse TCP",
            "Concurrent processing",
            "Faster response"
        ]
    },
    {
        "q": "Which approach handles query whitelisting?",
        "type": "mcq",
        "o": [
            "Allow only pre-approved queries",
            "Allow all queries",
            "Block by IP",
            "Rate limit only"
        ]
    },
    {
        "q": "The ______ approach restricts allowed operations.",
        "type": "fill_blank",
        "answers": [
            "whitelisting"
        ],
        "other_options": [
            "allowlist",
            "filtering",
            "blocking"
        ]
    },
    {
        "q": "Whitelisting improves security for production.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match security measures:",
        "type": "match",
        "left": [
            "Whitelist",
            "Depth limit",
            "Cost limit",
            "Rate limit"
        ],
        "right": [
            "Allowed queries",
            "Nesting control",
            "Complexity control",
            "Request count"
        ]
    },
    {
        "q": "Rearrange security implementation:",
        "type": "rearrange",
        "words": [
            "Generate query hashes",
            "Store in allowlist",
            "Validate incoming",
            "Reject unknown"
        ]
    },
    {
        "q": "Which approach handles CORS in GraphQL?",
        "type": "mcq",
        "o": [
            "Configure allowed origins on server",
            "Client configuration",
            "Not applicable",
            "Always allowed"
        ]
    },
    {
        "q": "The ______ header specifies allowed origins.",
        "type": "fill_blank",
        "answers": [
            "Access-Control-Allow-Origin"
        ],
        "other_options": [
            "Allow-Origin",
            "CORS-Origin",
            "Origin-Allow"
        ]
    },
    {
        "q": "GraphQL endpoints need CORS configuration for browser access.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match CORS headers:",
        "type": "match",
        "left": [
            "Allow-Origin",
            "Allow-Methods",
            "Allow-Headers",
            "Allow-Credentials"
        ],
        "right": [
            "Permitted domains",
            "Permitted methods",
            "Permitted headers",
            "Cookie support"
        ]
    },
    {
        "q": "Which approach handles field-level permissions?",
        "type": "mcq",
        "o": [
            "Check permissions in resolvers",
            "Schema-level only",
            "Client filtering",
            "No permissions"
        ]
    },
    {
        "q": "The ______ directive can enforce permissions.",
        "type": "fill_blank",
        "answers": [
            "@auth"
        ],
        "other_options": [
            "@permission",
            "@role",
            "@access"
        ]
    },
    {
        "q": "Authorization should be checked at the resolver level.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match authorization patterns:",
        "type": "match",
        "left": [
            "Role-based",
            "Resource-based",
            "Attribute-based",
            "Custom"
        ],
        "right": [
            "User roles",
            "Object ownership",
            "Dynamic rules",
            "Business logic"
        ]
    },
    {
        "q": "What is the output of this auth check?",
        "type": "mcq",
        "c": "const resolvers = {\n    Query: {\n        secretData: (parent, args, context) => {\n            if (!context.user?.roles.includes('admin')) {\n                throw new AuthError('Not authorized');\n            }\n            return context.db.getSecretData();\n        }\n    }\n};",
        "o": [
            "Data for admins, error for others",
            "Data for all users",
            "Error for all users",
            "Null for all"
        ]
    },
    {
        "q": "Rearrange authorization flow:",
        "type": "rearrange",
        "words": [
            "Extract user from context",
            "Check permissions",
            "Throw if unauthorized",
            "Execute resolver"
        ]
    },
    {
        "q": "Which approach handles GraphQL over HTTP GET?",
        "type": "mcq",
        "o": [
            "Query in URL parameters",
            "Not supported",
            "Different endpoint",
            "WebSocket only"
        ]
    },
    {
        "q": "The ______ parameter contains the query in GET requests.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "q",
            "gql",
            "operation"
        ]
    },
    {
        "q": "GET requests enable HTTP caching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match HTTP methods:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "persisted GET",
            "batched POST"
        ],
        "right": [
            "Query in URL",
            "Query in body",
            "Hash in URL",
            "Multiple in body"
        ]
    },
    {
        "q": "Rearrange GET request format:",
        "type": "rearrange",
        "words": [
            "Base URL",
            "?query=",
            "Encoded query",
            "&variables=",
            "Encoded variables"
        ]
    },
    {
        "q": "GraphQL provides a powerful query language for APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL vs REST:",
        "type": "match",
        "left": [
            "Single endpoint",
            "Client-driven",
            "Type system",
            "Introspection"
        ],
        "right": [
            "vs multiple URLs",
            "vs server-driven",
            "vs ad-hoc",
            "vs external docs"
        ]
    },
    {
        "q": "What is the output of this query complexity analyzer?",
        "type": "mcq",
        "c": "function calculateComplexity(field, depth = 0) {\n    const fieldCost = field.isList ? 10 : 1;\n    const childCost = field.children?.reduce((sum, c) => \n        sum + calculateComplexity(c, depth + 1), 0) || 0;\n    return fieldCost * (1 + childCost);\n}",
        "o": [
            "Weighted cost based on field type and nesting",
            "Simple count of fields",
            "Depth only",
            "Fixed cost"
        ]
    },
    {
        "q": "Which approach handles automatic persisted queries?",
        "type": "mcq",
        "o": [
            "Try hash first, send full query on miss",
            "Always send hash",
            "Always send full query",
            "Pre-register all queries"
        ]
    },
    {
        "q": "The ______ protocol handles APQ negotiation.",
        "type": "fill_blank",
        "answers": [
            "APQ"
        ],
        "other_options": [
            "PQ",
            "persist",
            "hash"
        ]
    },
    {
        "q": "Match APQ flow:",
        "type": "match",
        "left": [
            "Send hash",
            "Cache miss",
            "Send full query",
            "Persist and execute"
        ],
        "right": [
            "Try persisted",
            "Not found",
            "Fallback",
            "Store and run"
        ]
    },
    {
        "q": "APQ reduces bandwidth for repeated queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange APQ execution:",
        "type": "rearrange",
        "words": [
            "Client sends hash",
            "Server checks cache",
            "If miss send full query",
            "Server persists",
            "Execute query"
        ]
    },
    {
        "q": "Which approach handles schema registry?",
        "type": "mcq",
        "o": [
            "Centralized schema storage and versioning",
            "Git only",
            "File system",
            "In memory"
        ]
    },
    {
        "q": "The ______ stores and versions GraphQL schemas.",
        "type": "fill_blank",
        "answers": [
            "schema registry"
        ],
        "other_options": [
            "schema store",
            "type registry",
            "api registry"
        ]
    },
    {
        "q": "Schema registries enable federation management.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match registry features:",
        "type": "match",
        "left": [
            "Versioning",
            "Validation",
            "Composition",
            "History"
        ],
        "right": [
            "Track changes",
            "Check compatibility",
            "Merge subgraphs",
            "Audit trail"
        ]
    },
    {
        "q": "Which approach handles operation naming?",
        "type": "mcq",
        "o": [
            "Descriptive unique names for each operation",
            "Anonymous queries",
            "Auto-generated names",
            "Same name for all"
        ]
    },
    {
        "q": "The ______ name identifies operations for debugging.",
        "type": "fill_blank",
        "answers": [
            "operation"
        ],
        "other_options": [
            "query",
            "request",
            "call"
        ]
    },
    {
        "q": "Named operations improve debugging and analytics.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match naming conventions:",
        "type": "match",
        "left": [
            "Query",
            "Mutation",
            "Subscription",
            "Fragment"
        ],
        "right": [
            "GetUser",
            "CreatePost",
            "OnMessageAdded",
            "UserFields"
        ]
    },
    {
        "q": "What is the output of this resolver chain?",
        "type": "mcq",
        "c": "const resolvers = {\n    Query: {\n        user: () => ({ id: 1, name: 'John' })\n    },\n    User: {\n        posts: (parent) => db.posts.findByUserId(parent.id)\n    }\n};",
        "o": [
            "User with posts from parent.id",
            "All posts",
            "Empty posts",
            "Error"
        ]
    },
    {
        "q": "Rearrange resolver chain:",
        "type": "rearrange",
        "words": [
            "Execute root resolver",
            "Return parent object",
            "Execute field resolvers",
            "Use parent data"
        ]
    },
    {
        "q": "Which approach handles query batching on the server?",
        "type": "mcq",
        "o": [
            "Execute multiple queries in parallel",
            "Sequential execution",
            "Reject batches",
            "Single query only"
        ]
    },
    {
        "q": "The ______ parameter contains array of queries.",
        "type": "fill_blank",
        "answers": [
            "operations"
        ],
        "other_options": [
            "queries",
            "batch",
            "requests"
        ]
    },
    {
        "q": "Server batching can improve throughput.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match batching strategies:",
        "type": "match",
        "left": [
            "Parallel",
            "Sequential",
            "Limited",
            "Rejected"
        ],
        "right": [
            "Concurrent execution",
            "One at a time",
            "Max batch size",
            "No batching"
        ]
    },
    {
        "q": "Which approach handles query planning?",
        "type": "mcq",
        "o": [
            "Analyze and optimize query execution order",
            "Random execution",
            "Client-determined",
            "Fixed order"
        ]
    },
    {
        "q": "The ______ optimizes query execution.",
        "type": "fill_blank",
        "answers": [
            "query planner"
        ],
        "other_options": [
            "optimizer",
            "scheduler",
            "executor"
        ]
    },
    {
        "q": "Query planning can reduce database round trips.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match planning phases:",
        "type": "match",
        "left": [
            "Parse",
            "Validate",
            "Plan",
            "Execute"
        ],
        "right": [
            "Build AST",
            "Check schema",
            "Optimize order",
            "Run resolvers"
        ]
    },
    {
        "q": "What is the output of this deferred resolver?",
        "type": "mcq",
        "c": "const resolvers = {\n    Query: {\n        user: async () => {\n            const user = await db.users.findById(1);\n            return {\n                ...user,\n                posts: () => db.posts.findByUserId(user.id)\n            };\n        }\n    }\n};",
        "o": [
            "Posts fetched only if requested",
            "Posts always fetched",
            "Empty posts",
            "Error"
        ]
    },
    {
        "q": "Rearrange deferred execution:",
        "type": "rearrange",
        "words": [
            "Receive query",
            "Fetch only requested fields",
            "Defer non-requested",
            "Return partial result"
        ]
    },
    {
        "q": "Which approach handles live queries?",
        "type": "mcq",
        "o": [
            "Query that updates when data changes",
            "Single fetch",
            "Polling only",
            "Subscription only"
        ]
    },
    {
        "q": "The ______ directive marks a query as live.",
        "type": "fill_blank",
        "answers": [
            "@live"
        ],
        "other_options": [
            "@realtime",
            "@stream",
            "@watch"
        ]
    },
    {
        "q": "Live queries provide real-time data without subscriptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match real-time approaches:",
        "type": "match",
        "left": [
            "Subscription",
            "Live query",
            "Polling",
            "WebSocket"
        ],
        "right": [
            "Event-driven",
            "Data-driven",
            "Interval-based",
            "Protocol"
        ]
    },
    {
        "q": "Which approach handles incremental delivery?",
        "type": "mcq",
        "o": [
            "Stream results as they become available",
            "Wait for complete",
            "Client-side assembly",
            "Not supported"
        ]
    },
    {
        "q": "The ______ directive enables incremental delivery.",
        "type": "fill_blank",
        "answers": [
            "@defer"
        ],
        "other_options": [
            "@stream",
            "@lazy",
            "@async"
        ]
    },
    {
        "q": "Incremental delivery improves perceived performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match delivery directives:",
        "type": "match",
        "left": [
            "@defer",
            "@stream",
            "@live",
            "@connection"
        ],
        "right": [
            "Delay fragment",
            "Stream list",
            "Real-time update",
            "Pagination"
        ]
    },
    {
        "q": "Rearrange incremental delivery:",
        "type": "rearrange",
        "words": [
            "Identify deferred parts",
            "Send initial response",
            "Process deferred",
            "Stream updates"
        ]
    },
    {
        "q": "Which approach handles response streaming?",
        "type": "mcq",
        "o": [
            "Use chunked transfer for large responses",
            "Single response",
            "Multiple requests",
            "WebSocket only"
        ]
    },
    {
        "q": "The ______ directive streams list items.",
        "type": "fill_blank",
        "answers": [
            "@stream"
        ],
        "other_options": [
            "@list",
            "@chunk",
            "@batch"
        ]
    },
    {
        "q": "Streaming reduces time to first byte.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match streaming benefits:",
        "type": "match",
        "left": [
            "Faster initial",
            "Progressive",
            "Memory efficient",
            "Better UX"
        ],
        "right": [
            "Quick first data",
            "Incremental render",
            "Lower allocation",
            "Immediate feedback"
        ]
    },
    {
        "q": "Which approach handles schema composition?",
        "type": "mcq",
        "o": [
            "Merge multiple schemas into supergraph",
            "Single schema only",
            "Runtime merging",
            "Client composition"
        ]
    },
    {
        "q": "The ______ process combines federated schemas.",
        "type": "fill_blank",
        "answers": [
            "composition"
        ],
        "other_options": [
            "merging",
            "stitching",
            "combining"
        ]
    },
    {
        "q": "Composition validates schema compatibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match composition phases:",
        "type": "match",
        "left": [
            "Collect",
            "Validate",
            "Merge",
            "Publish"
        ],
        "right": [
            "Gather subgraphs",
            "Check compatibility",
            "Create supergraph",
            "Deploy schema"
        ]
    },
    {
        "q": "What is the output of this federated entity?",
        "type": "mcq",
        "c": "// User service\ntype User @key(fields: \"id\") {\n    id: ID!\n    name: String!\n}\n\n// Post service extends User\nextend type User @key(fields: \"id\") {\n    id: ID! @external\n    posts: [Post!]!\n}",
        "o": [
            "User with posts from different services",
            "Two separate users",
            "Error",
            "Empty user"
        ]
    },
    {
        "q": "Rearrange federation query flow:",
        "type": "rearrange",
        "words": [
            "Gateway receives query",
            "Plan execution",
            "Query subgraphs",
            "Merge responses",
            "Return result"
        ]
    },
    {
        "q": "Which approach handles subgraph health?",
        "type": "mcq",
        "o": [
            "Gateway health checks for each subgraph",
            "No health checks",
            "Client checks",
            "Manual monitoring"
        ]
    },
    {
        "q": "The ______ monitors subgraph availability.",
        "type": "fill_blank",
        "answers": [
            "gateway"
        ],
        "other_options": [
            "registry",
            "router",
            "proxy"
        ]
    },
    {
        "q": "Unhealthy subgraphs can be removed from routing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match health indicators:",
        "type": "match",
        "left": [
            "Response time",
            "Error rate",
            "Availability",
            "Latency"
        ],
        "right": [
            "Query duration",
            "Failure percentage",
            "Uptime",
            "Network delay"
        ]
    },
    {
        "q": "Which approach handles query cost analysis?",
        "type": "mcq",
        "o": [
            "Calculate weighted cost based on fields and depth",
            "Count characters",
            "Count fields only",
            "Fixed cost"
        ]
    },
    {
        "q": "The ______ assigns costs to types and fields.",
        "type": "fill_blank",
        "answers": [
            "cost directive"
        ],
        "other_options": [
            "weight directive",
            "limit directive",
            "cost function"
        ]
    },
    {
        "q": "Cost analysis prevents expensive queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cost factors:",
        "type": "match",
        "left": [
            "Field cost",
            "Depth multiplier",
            "List multiplier",
            "Connection cost"
        ],
        "right": [
            "Base weight",
            "Nesting penalty",
            "Items count",
            "Cursor overhead"
        ]
    },
    {
        "q": "Which approach handles query timing limits?",
        "type": "mcq",
        "o": [
            "Timeout for query execution",
            "No timeout",
            "Client-determined",
            "Fixed long timeout"
        ]
    },
    {
        "q": "The ______ limit kills slow queries.",
        "type": "fill_blank",
        "answers": [
            "timeout"
        ],
        "other_options": [
            "duration",
            "limit",
            "max"
        ]
    },
    {
        "q": "Timeouts protect against slow resolvers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match timeout strategies:",
        "type": "match",
        "left": [
            "Query timeout",
            "Resolver timeout",
            "Connection timeout",
            "Request timeout"
        ],
        "right": [
            "Total execution",
            "Single resolver",
            "Database",
            "HTTP"
        ]
    },
    {
        "q": "Rearrange timeout handling:",
        "type": "rearrange",
        "words": [
            "Start timer",
            "Execute query",
            "Check timeout",
            "Cancel if exceeded",
            "Return error"
        ]
    },
    {
        "q": "Which approach handles response size limits?",
        "type": "mcq",
        "o": [
            "Limit total response payload size",
            "No limits",
            "Client limits",
            "Fixed small limit"
        ]
    },
    {
        "q": "The ______ limit restricts response bytes.",
        "type": "fill_blank",
        "answers": [
            "maxResponseSize"
        ],
        "other_options": [
            "payloadLimit",
            "sizeLimit",
            "maxBytes"
        ]
    },
    {
        "q": "Response size limits prevent memory issues.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles request body limits?",
        "type": "mcq",
        "o": [
            "Limit incoming request body size",
            "No limits",
            "Client limits",
            "Unlimited"
        ]
    },
    {
        "q": "The ______ setting limits request payload.",
        "type": "fill_blank",
        "answers": [
            "bodyLimit"
        ],
        "other_options": [
            "requestLimit",
            "payloadMax",
            "inputLimit"
        ]
    },
    {
        "q": "Body limits prevent DoS attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match security limits:",
        "type": "match",
        "left": [
            "Depth",
            "Complexity",
            "Timeout",
            "Body size"
        ],
        "right": [
            "Nesting levels",
            "Field weights",
            "Execution time",
            "Request size"
        ]
    },
    {
        "q": "Which approach handles AST analysis?",
        "type": "mcq",
        "o": [
            "Parse and analyze query structure",
            "String analysis",
            "Regex matching",
            "No analysis"
        ]
    },
    {
        "q": "The ______ represents parsed query structure.",
        "type": "fill_blank",
        "answers": [
            "AST"
        ],
        "other_options": [
            "tree",
            "document",
            "structure"
        ]
    },
    {
        "q": "AST analysis enables query validation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match AST nodes:",
        "type": "match",
        "left": [
            "Document",
            "OperationDefinition",
            "Field",
            "Argument"
        ],
        "right": [
            "Root node",
            "Query/Mutation",
            "Field selection",
            "Field parameter"
        ]
    },
    {
        "q": "What is the output of this AST visitor?",
        "type": "mcq",
        "c": "let depth = 0;\nlet maxDepth = 0;\nconst visitor = {\n    Field: {\n        enter() { depth++; maxDepth = Math.max(maxDepth, depth); },\n        leave() { depth--; }\n    }\n};\nvisit(documentAST, visitor);",
        "o": [
            "Maximum nesting depth of query",
            "Field count",
            "Query size",
            "Error count"
        ]
    },
    {
        "q": "Rearrange AST processing:",
        "type": "rearrange",
        "words": [
            "Parse query string",
            "Build AST",
            "Visit nodes",
            "Analyze structure",
            "Make decisions"
        ]
    },
    {
        "q": "Which approach handles schema printing?",
        "type": "mcq",
        "o": [
            "Convert schema to SDL string",
            "JSON export",
            "Binary format",
            "No export"
        ]
    },
    {
        "q": "The ______ function converts schema to SDL.",
        "type": "fill_blank",
        "answers": [
            "printSchema"
        ],
        "other_options": [
            "exportSchema",
            "toSDL",
            "stringify"
        ]
    },
    {
        "q": "Schema printing enables documentation generation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match schema formats:",
        "type": "match",
        "left": [
            "SDL",
            "Introspection JSON",
            "GraphQL.js",
            "TypeScript"
        ],
        "right": [
            "Human readable",
            "Machine format",
            "Programmatic",
            "Typed definitions"
        ]
    },
    {
        "q": "Which approach handles schema building?",
        "type": "mcq",
        "o": [
            "Build schema from SDL or programmatically",
            "Manual construction",
            "JSON parsing",
            "No building needed"
        ]
    },
    {
        "q": "The ______ function creates schema from SDL.",
        "type": "fill_blank",
        "answers": [
            "buildSchema"
        ],
        "other_options": [
            "createSchema",
            "parseSchema",
            "loadSchema"
        ]
    },
    {
        "q": "Schema building can be done at build time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match schema building approaches:",
        "type": "match",
        "left": [
            "SDL first",
            "Code first",
            "Hybrid",
            "Generated"
        ],
        "right": [
            "Schema file",
            "Programmatic",
            "Both",
            "From DB"
        ]
    },
    {
        "q": "Which approach handles schema merging?",
        "type": "mcq",
        "o": [
            "Combine multiple schema modules",
            "Single file only",
            "No merging",
            "Runtime merge"
        ]
    },
    {
        "q": "The ______ function merges type definitions.",
        "type": "fill_blank",
        "answers": [
            "mergeTypeDefs"
        ],
        "other_options": [
            "combineTypes",
            "joinSchemas",
            "mergeSchemas"
        ]
    },
    {
        "q": "Schema merging enables modular design.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match merge strategies:",
        "type": "match",
        "left": [
            "Extend type",
            "Override",
            "Combine fields",
            "Namespace"
        ],
        "right": [
            "Add fields",
            "Replace type",
            "Merge all",
            "Prefix names"
        ]
    },
    {
        "q": "Rearrange modular schema:",
        "type": "rearrange",
        "words": [
            "Define base types",
            "Create feature modules",
            "Merge type definitions",
            "Merge resolvers",
            "Create final schema"
        ]
    },
    {
        "q": "Which approach handles executable schemas?",
        "type": "mcq",
        "o": [
            "Combine type definitions with resolvers",
            "Types only",
            "Resolvers only",
            "Generated schema"
        ]
    },
    {
        "q": "The ______ function creates executable schema.",
        "type": "fill_blank",
        "answers": [
            "makeExecutableSchema"
        ],
        "other_options": [
            "createSchema",
            "buildExecutable",
            "assembleSchema"
        ]
    },
    {
        "q": "Executable schemas include resolver logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match schema components:",
        "type": "match",
        "left": [
            "Type definitions",
            "Resolvers",
            "Directives",
            "Scalars"
        ],
        "right": [
            "Schema structure",
            "Data fetching",
            "Behavior modifiers",
            "Custom types"
        ]
    },
    {
        "q": "Which approach handles resolver composition?",
        "type": "mcq",
        "o": [
            "Combine resolver logic with middleware pattern",
            "Single resolver",
            "No composition",
            "Inheritance only"
        ]
    },
    {
        "q": "The ______ pattern wraps resolvers.",
        "type": "fill_blank",
        "answers": [
            "middleware"
        ],
        "other_options": [
            "decorator",
            "wrapper",
            "chain"
        ]
    },
    {
        "q": "Resolver middleware enables cross-cutting concerns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match resolver middleware:",
        "type": "match",
        "left": [
            "Auth",
            "Logging",
            "Caching",
            "Validation"
        ],
        "right": [
            "Check permissions",
            "Record calls",
            "Store results",
            "Check inputs"
        ]
    },
    {
        "q": "What is the output of this resolver middleware?",
        "type": "mcq",
        "c": "const loggingMiddleware = async (resolve, parent, args, context, info) => {\n    console.log(`Calling ${info.fieldName}`);\n    const result = await resolve(parent, args, context, info);\n    console.log(`Completed ${info.fieldName}`);\n    return result;\n};",
        "o": [
            "Logs before and after resolver execution",
            "Logs errors only",
            "No logging",
            "Logs arguments only"
        ]
    },
    {
        "q": "Rearrange middleware execution:",
        "type": "rearrange",
        "words": [
            "Intercept call",
            "Pre-process",
            "Call next/resolve",
            "Post-process",
            "Return result"
        ]
    },
    {
        "q": "Which approach handles resolver caching?",
        "type": "mcq",
        "o": [
            "Memoize resolver results per request",
            "No caching",
            "Database caching",
            "Client caching"
        ]
    },
    {
        "q": "The ______ caches per-request results.",
        "type": "fill_blank",
        "answers": [
            "DataLoader"
        ],
        "other_options": [
            "ResolverCache",
            "FieldCache",
            "QueryCache"
        ]
    },
    {
        "q": "Request-scoped caching prevents duplicate fetches.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match caching scopes:",
        "type": "match",
        "left": [
            "Request",
            "Application",
            "User",
            "Resolver"
        ],
        "right": [
            "Single query",
            "Global",
            "Per-user",
            "Per-field"
        ]
    },
    {
        "q": "Which approach handles response formatting?",
        "type": "mcq",
        "o": [
            "Custom response shape and metadata",
            "Fixed GraphQL format",
            "Client-determined",
            "No formatting"
        ]
    },
    {
        "q": "The ______ function formats execution results.",
        "type": "fill_blank",
        "answers": [
            "formatResponse"
        ],
        "other_options": [
            "shapeResponse",
            "transformResult",
            "buildResponse"
        ]
    },
    {
        "q": "Response formatting can add custom metadata.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match response parts:",
        "type": "match",
        "left": [
            "data",
            "errors",
            "extensions",
            "path"
        ],
        "right": [
            "Results",
            "Issues",
            "Metadata",
            "Error location"
        ]
    },
    {
        "q": "Which approach handles extensions in responses?",
        "type": "mcq",
        "o": [
            "Add custom data to extensions field",
            "No extensions",
            "Headers only",
            "Separate endpoint"
        ]
    },
    {
        "q": "The ______ field contains non-standard data.",
        "type": "fill_blank",
        "answers": [
            "extensions"
        ],
        "other_options": [
            "meta",
            "extra",
            "custom"
        ]
    },
    {
        "q": "Extensions can include tracing and caching hints.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match extension uses:",
        "type": "match",
        "left": [
            "Tracing",
            "Caching",
            "Metrics",
            "Deprecation"
        ],
        "right": [
            "Timing data",
            "Cache hints",
            "Performance stats",
            "Warnings"
        ]
    },
    {
        "q": "Rearrange response building:",
        "type": "rearrange",
        "words": [
            "Execute query",
            "Collect data",
            "Format errors",
            "Add extensions",
            "Return response"
        ]
    },
    {
        "q": "Which approach handles GraphQL mesh?",
        "type": "mcq",
        "o": [
            "Unified API from multiple sources",
            "Schema merging only",
            "REST only",
            "Database only"
        ]
    },
    {
        "q": "The ______ tool creates unified GraphQL layer.",
        "type": "fill_blank",
        "answers": [
            "GraphQL Mesh"
        ],
        "other_options": [
            "GraphQL Gateway",
            "GraphQL Proxy",
            "GraphQL Hub"
        ]
    },
    {
        "q": "GraphQL Mesh can consume REST APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match Mesh sources:",
        "type": "match",
        "left": [
            "REST",
            "GraphQL",
            "gRPC",
            "Database"
        ],
        "right": [
            "OpenAPI",
            "Subgraph",
            "Protobuf",
            "SQL/NoSQL"
        ]
    },
    {
        "q": "Which approach handles code-first schema?",
        "type": "mcq",
        "o": [
            "Define schema using programming language constructs",
            "SDL only",
            "Generated from DB",
            "Introspection"
        ]
    },
    {
        "q": "The ______ library enables TypeScript code-first.",
        "type": "fill_blank",
        "answers": [
            "TypeGraphQL"
        ],
        "other_options": [
            "GraphQL-JS",
            "Apollo Server",
            "Nexus"
        ]
    },
    {
        "q": "Code-first provides better type safety.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match code-first approaches:",
        "type": "match",
        "left": [
            "TypeGraphQL",
            "Nexus",
            "Pothos",
            "NestJS GraphQL"
        ],
        "right": [
            "Decorators",
            "Builder",
            "Plugin-based",
            "Module-based"
        ]
    },
    {
        "q": "What is the output of this TypeGraphQL resolver?",
        "type": "mcq",
        "c": "@Resolver()\nclass UserResolver {\n    @Query(() => User)\n    async user(@Arg('id') id: string): Promise<User> {\n        return await db.users.findById(id);\n    }\n}",
        "o": [
            "Type-safe resolver with decorators",
            "Plain JavaScript resolver",
            "SDL-based resolver",
            "Error"
        ]
    },
    {
        "q": "Rearrange code-first development:",
        "type": "rearrange",
        "words": [
            "Define TypeScript classes",
            "Add decorators",
            "Build schema",
            "Generate SDL if needed"
        ]
    },
    {
        "q": "Which approach handles field middleware?",
        "type": "mcq",
        "o": [
            "Per-field processing logic",
            "Global only",
            "No middleware",
            "Client-side"
        ]
    },
    {
        "q": "The ______ function wraps specific fields.",
        "type": "fill_blank",
        "answers": [
            "fieldMiddleware"
        ],
        "other_options": [
            "fieldWrapper",
            "fieldProcessor",
            "fieldHook"
        ]
    },
    {
        "q": "Field middleware enables granular control.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match middleware scope:",
        "type": "match",
        "left": [
            "Global",
            "Type",
            "Field",
            "Resolver"
        ],
        "right": [
            "All operations",
            "All type fields",
            "Specific field",
            "Single resolver"
        ]
    },
    {
        "q": "Which approach handles subscription filtering?",
        "type": "mcq",
        "o": [
            "Filter events before sending to client",
            "No filtering",
            "Client-side filter",
            "All events"
        ]
    },
    {
        "q": "The ______ function determines if event should be sent.",
        "type": "fill_blank",
        "answers": [
            "withFilter"
        ],
        "other_options": [
            "filterEvent",
            "checkEvent",
            "shouldPublish"
        ]
    },
    {
        "q": "Subscription filtering reduces unnecessary updates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match filter patterns:",
        "type": "match",
        "left": [
            "User filter",
            "Topic filter",
            "Payload filter",
            "Permission filter"
        ],
        "right": [
            "By user ID",
            "By event type",
            "By content",
            "By access"
        ]
    },
    {
        "q": "What is the output of this subscription filter?",
        "type": "mcq",
        "c": "const resolvers = {\n    Subscription: {\n        messageAdded: {\n            subscribe: withFilter(\n                () => pubsub.asyncIterator(['MESSAGE_ADDED']),\n                (payload, variables) => payload.roomId === variables.roomId\n            )\n        }\n    }\n};",
        "o": [
            "Messages only for subscribed room",
            "All messages",
            "No messages",
            "Error"
        ]
    },
    {
        "q": "Rearrange subscription with filter:",
        "type": "rearrange",
        "words": [
            "Define iterator",
            "Add filter function",
            "Check condition",
            "Send if matches"
        ]
    },
    {
        "q": "Which approach handles resolver testing?",
        "type": "mcq",
        "o": [
            "Unit test resolvers with mocked context",
            "Integration only",
            "Manual testing",
            "No testing"
        ]
    },
    {
        "q": "The ______ provides test context.",
        "type": "fill_blank",
        "answers": [
            "mockContext"
        ],
        "other_options": [
            "testContext",
            "fakeContext",
            "stubContext"
        ]
    },
    {
        "q": "Unit tests should isolate resolver logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match testing levels:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "Schema",
            "E2E"
        ],
        "right": [
            "Resolver",
            "Full query",
            "Type coverage",
            "Client to DB"
        ]
    },
    {
        "q": "Which approach handles error classification?",
        "type": "mcq",
        "o": [
            "Custom error types with extensions",
            "Generic errors",
            "HTTP codes",
            "No classification"
        ]
    },
    {
        "q": "The ______ field classifies errors.",
        "type": "fill_blank",
        "answers": [
            "code"
        ],
        "other_options": [
            "type",
            "category",
            "class"
        ]
    },
    {
        "q": "Error classification helps client error handling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error types:",
        "type": "match",
        "left": [
            "UNAUTHENTICATED",
            "FORBIDDEN",
            "BAD_USER_INPUT",
            "INTERNAL_SERVER_ERROR"
        ],
        "right": [
            "Not logged in",
            "No permission",
            "Invalid input",
            "Server failure"
        ]
    },
    {
        "q": "What is the output of this custom error?",
        "type": "mcq",
        "c": "class AuthenticationError extends ApolloError {\n    constructor(message) {\n        super(message, 'UNAUTHENTICATED');\n        Object.defineProperty(this, 'name', { value: 'AuthenticationError' });\n    }\n}",
        "o": [
            "Error with UNAUTHENTICATED code",
            "Generic error",
            "Validation error",
            "Network error"
        ]
    },
    {
        "q": "Rearrange error creation:",
        "type": "rearrange",
        "words": [
            "Extend base error",
            "Set error code",
            "Add custom properties",
            "Throw in resolver"
        ]
    },
    {
        "q": "Which approach handles type generation from database?",
        "type": "mcq",
        "o": [
            "Generate types from database schema",
            "Manual type definition",
            "No generation",
            "Client generation"
        ]
    },
    {
        "q": "The ______ tool generates types from DB.",
        "type": "fill_blank",
        "answers": [
            "Prisma"
        ],
        "other_options": [
            "Sequelize",
            "TypeORM",
            "Knex"
        ]
    },
    {
        "q": "Generated types ensure schema-DB alignment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match generation tools:",
        "type": "match",
        "left": [
            "Prisma",
            "Hasura",
            "PostGraphile",
            "Nexus-Prisma"
        ],
        "right": [
            "ORM + types",
            "Realtime engine",
            "PostGres API",
            "Type integration"
        ]
    },
    {
        "q": "Which approach handles GraphQL in microservices?",
        "type": "mcq",
        "o": [
            "Federation with gateway and subgraphs",
            "Single monolith",
            "Multiple endpoints",
            "REST gateway"
        ]
    },
    {
        "q": "The ______ coordinates requests across services.",
        "type": "fill_blank",
        "answers": [
            "gateway"
        ],
        "other_options": [
            "router",
            "proxy",
            "hub"
        ]
    },
    {
        "q": "Federation enables team independence.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match federation roles:",
        "type": "match",
        "left": [
            "Gateway",
            "Subgraph",
            "Entity",
            "Reference"
        ],
        "right": [
            "Query router",
            "Service schema",
            "Shared type",
            "Cross-service link"
        ]
    },
    {
        "q": "GraphQL provides flexible data fetching for modern applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL advantages:",
        "type": "match",
        "left": [
            "No over-fetching",
            "Strong typing",
            "Single endpoint",
            "Introspection"
        ],
        "right": [
            "Exact data",
            "Schema validation",
            "Simpler routing",
            "Self-documentation"
        ]
    },
    {
        "q": "What is the output of this entity resolver?",
        "type": "mcq",
        "c": "const resolvers = {\n    User: {\n        __resolveReference(user, context) {\n            return context.db.users.findById(user.id);\n        }\n    }\n};",
        "o": [
            "Resolves federated user from reference",
            "Creates new user",
            "Deletes user",
            "Error"
        ]
    },
    {
        "q": "Which approach handles entity references?",
        "type": "mcq",
        "o": [
            "__resolveReference for fetching entities",
            "Direct query",
            "Manual lookup",
            "No references"
        ]
    },
    {
        "q": "The ______ function fetches entity by key fields.",
        "type": "fill_blank",
        "answers": [
            "__resolveReference"
        ],
        "other_options": [
            "resolveEntity",
            "fetchEntity",
            "getReference"
        ]
    },
    {
        "q": "Entity references enable cross-service data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match entity resolution:",
        "type": "match",
        "left": [
            "@key",
            "@external",
            "__resolveReference",
            "representations"
        ],
        "right": [
            "Primary key",
            "Remote field",
            "Fetch handler",
            "Entity list"
        ]
    },
    {
        "q": "Which approach handles router configuration?",
        "type": "mcq",
        "o": [
            "Configure how gateway routes queries to subgraphs",
            "No configuration",
            "Client routing",
            "Random routing"
        ]
    },
    {
        "q": "The ______ determines query distribution.",
        "type": "fill_blank",
        "answers": [
            "query planner"
        ],
        "other_options": [
            "router",
            "dispatcher",
            "scheduler"
        ]
    },
    {
        "q": "Query planning optimizes subgraph requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match router features:",
        "type": "match",
        "left": [
            "Query planning",
            "Load balancing",
            "Caching",
            "Tracing"
        ],
        "right": [
            "Optimize path",
            "Distribute load",
            "Store results",
            "Track performance"
        ]
    },
    {
        "q": "Rearrange federation query execution:",
        "type": "rearrange",
        "words": [
            "Gateway receives query",
            "Analyze query",
            "Create execution plan",
            "Query subgraphs",
            "Merge results"
        ]
    },
    {
        "q": "Which approach handles supergraph composition?",
        "type": "mcq",
        "o": [
            "Combine all subgraph schemas into one",
            "Manual composition",
            "No composition",
            "Runtime composition"
        ]
    },
    {
        "q": "The ______ validates and composes subgraphs.",
        "type": "fill_blank",
        "answers": [
            "composition"
        ],
        "other_options": [
            "merger",
            "combiner",
            "assembler"
        ]
    },
    {
        "q": "Composition checks for schema conflicts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match composition errors:",
        "type": "match",
        "left": [
            "Type conflict",
            "Field conflict",
            "Directive conflict",
            "Missing key"
        ],
        "right": [
            "Same name, different definition",
            "Same field, different type",
            "Incompatible directive",
            "No @key"
        ]
    },
    {
        "q": "Which approach handles subgraph development?",
        "type": "mcq",
        "o": [
            "Independent development with federation directives",
            "Centralized development",
            "No independence",
            "Shared codebase"
        ]
    },
    {
        "q": "The ______ approach enables team autonomy.",
        "type": "fill_blank",
        "answers": [
            "federation"
        ],
        "other_options": [
            "stitching",
            "merging",
            "splitting"
        ]
    },
    {
        "q": "Teams can deploy subgraphs independently.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match subgraph benefits:",
        "type": "match",
        "left": [
            "Independence",
            "Ownership",
            "Isolation",
            "Flexibility"
        ],
        "right": [
            "Team autonomy",
            "Clear responsibility",
            "Contained changes",
            "Tech choice"
        ]
    },
    {
        "q": "What is the output of this @provides directive?",
        "type": "mcq",
        "c": "type Query {\n    topProducts(first: Int = 5): [Product]\n}\n\nextend type Product @key(fields: \"upc\") {\n    upc: String! @external\n    name: String @external\n    weight: Int @external\n    price: Int @external\n    inStock: Boolean\n    shippingEstimate: Int @requires(fields: \"price weight\")\n}",
        "o": [
            "Shipping estimate requires price and weight from Product service",
            "All fields are local",
            "No requirements",
            "Error"
        ]
    },
    {
        "q": "Rearrange @requires resolution:",
        "type": "rearrange",
        "words": [
            "Request field",
            "Check @requires",
            "Fetch required fields",
            "Execute resolver",
            "Return result"
        ]
    },
    {
        "q": "Which approach handles schema contracts?",
        "type": "mcq",
        "o": [
            "Define expected types and fields between services",
            "No contracts",
            "Runtime discovery",
            "Manual coordination"
        ]
    },
    {
        "q": "The ______ ensures schema compatibility.",
        "type": "fill_blank",
        "answers": [
            "contract"
        ],
        "other_options": [
            "agreement",
            "spec",
            "definition"
        ]
    },
    {
        "q": "Schema contracts prevent breaking changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match contract components:",
        "type": "match",
        "left": [
            "Type",
            "Field",
            "Nullability",
            "Arguments"
        ],
        "right": [
            "Object shape",
            "Property definition",
            "Required vs optional",
            "Input params"
        ]
    },
    {
        "q": "Which approach handles field deprecation in federation?",
        "type": "mcq",
        "o": [
            "Use @deprecated to mark fields for removal",
            "Remove immediately",
            "No deprecation",
            "Client notification"
        ]
    },
    {
        "q": "The ______ directive marks fields as deprecated.",
        "type": "fill_blank",
        "answers": [
            "@deprecated"
        ],
        "other_options": [
            "@old",
            "@legacy",
            "@removed"
        ]
    },
    {
        "q": "Deprecation warns clients about upcoming changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match deprecation flow:",
        "type": "match",
        "left": [
            "Mark deprecated",
            "Add replacement",
            "Monitor usage",
            "Remove field"
        ],
        "right": [
            "Add directive",
            "New field",
            "Track clients",
            "Final cleanup"
        ]
    },
    {
        "q": "Rearrange deprecation process:",
        "type": "rearrange",
        "words": [
            "Add new field",
            "Deprecate old field",
            "Monitor usage",
            "Migrate clients",
            "Remove deprecated"
        ]
    },
    {
        "q": "Which approach handles error boundaries in GraphQL?",
        "type": "mcq",
        "o": [
            "Isolate errors to specific fields",
            "Fail entire query",
            "No error handling",
            "Client-side only"
        ]
    },
    {
        "q": "The ______ approach contains errors to affected fields.",
        "type": "fill_blank",
        "answers": [
            "partial errors"
        ],
        "other_options": [
            "field errors",
            "isolated errors",
            "contained errors"
        ]
    },
    {
        "q": "Partial errors allow returning available data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error scopes:",
        "type": "match",
        "left": [
            "Query-level",
            "Type-level",
            "Field-level",
            "Argument-level"
        ],
        "right": [
            "Entire operation",
            "Object scope",
            "Single field",
            "Input validation"
        ]
    },
    {
        "q": "Which approach handles null propagation?",
        "type": "mcq",
        "o": [
            "Null bubbles up to nearest nullable parent",
            "Null stays local",
            "Error on null",
            "Replace with default"
        ]
    },
    {
        "q": "The ______ field stops null propagation.",
        "type": "fill_blank",
        "answers": [
            "nullable"
        ],
        "other_options": [
            "optional",
            "maybe",
            "undefined"
        ]
    },
    {
        "q": "Non-null fields cause parent to be null on error.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match null behavior:",
        "type": "match",
        "left": [
            "Non-null (!)",
            "Nullable",
            "List",
            "Non-null list"
        ],
        "right": [
            "Bubbles up",
            "Stops here",
            "Can contain nulls",
            "No null items"
        ]
    },
    {
        "q": "Rearrange null propagation:",
        "type": "rearrange",
        "words": [
            "Error in resolver",
            "Check field nullability",
            "If non-null propagate",
            "Find nullable parent",
            "Set to null"
        ]
    },
    {
        "q": "Which approach handles input validation?",
        "type": "mcq",
        "o": [
            "Validate inputs in resolvers or with directives",
            "No validation",
            "Client-side only",
            "Database constraints"
        ]
    },
    {
        "q": "The ______ directive enforces validation rules.",
        "type": "fill_blank",
        "answers": [
            "@constraint"
        ],
        "other_options": [
            "@validate",
            "@check",
            "@rule"
        ]
    },
    {
        "q": "Input validation prevents invalid data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match validation types:",
        "type": "match",
        "left": [
            "Format",
            "Range",
            "Length",
            "Pattern"
        ],
        "right": [
            "Email, URL",
            "Min/max values",
            "String length",
            "Regex match"
        ]
    },
    {
        "q": "What is the output of this validation directive?",
        "type": "mcq",
        "c": "input CreateUserInput {\n    email: String! @constraint(format: \"email\")\n    age: Int! @constraint(min: 18, max: 120)\n    password: String! @constraint(minLength: 8)\n}",
        "o": [
            "Validates email format, age range, and password length",
            "No validation",
            "Runtime error",
            "All strings pass"
        ]
    },
    {
        "q": "Rearrange validation flow:",
        "type": "rearrange",
        "words": [
            "Receive input",
            "Check constraints",
            "Return errors if invalid",
            "Execute resolver if valid"
        ]
    },
    {
        "q": "Which approach handles query aliases?",
        "type": "mcq",
        "o": [
            "Rename fields in response using aliases",
            "No renaming",
            "Server-side only",
            "Post-processing"
        ]
    },
    {
        "q": "The ______ syntax renames response fields.",
        "type": "fill_blank",
        "answers": [
            "alias:"
        ],
        "other_options": [
            "as:",
            "rename:",
            "map:"
        ]
    },
    {
        "q": "Aliases allow querying same field with different arguments.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match alias uses:",
        "type": "match",
        "left": [
            "Same field",
            "Different args",
            "Readable names",
            "Conflicts"
        ],
        "right": [
            "Multiple queries",
            "Different params",
            "Better response",
            "Avoid duplicates"
        ]
    },
    {
        "q": "Which approach handles default values?",
        "type": "mcq",
        "o": [
            "Specify defaults in schema for arguments",
            "No defaults",
            "Client provides",
            "Code-only"
        ]
    },
    {
        "q": "The ______ syntax sets argument defaults.",
        "type": "fill_blank",
        "answers": [
            "= value"
        ],
        "other_options": [
            "default:",
            "?:",
            "||"
        ]
    },
    {
        "q": "Default values reduce required arguments.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match default value types:",
        "type": "match",
        "left": [
            "Scalar",
            "Enum",
            "Input object",
            "List"
        ],
        "right": [
            "String, Int, etc.",
            "Named constant",
            "Object literal",
            "Array literal"
        ]
    },
    {
        "q": "Rearrange query execution with defaults:",
        "type": "rearrange",
        "words": [
            "Parse query",
            "Check arguments",
            "Apply defaults",
            "Execute resolver"
        ]
    },
    {
        "q": "Which approach handles query variables?",
        "type": "mcq",
        "o": [
            "Pass dynamic values separately from query",
            "Inline values",
            "No variables",
            "Server provides"
        ]
    },
    {
        "q": "The ______ section contains variable values.",
        "type": "fill_blank",
        "answers": [
            "variables"
        ],
        "other_options": [
            "params",
            "inputs",
            "data"
        ]
    },
    {
        "q": "Variables improve query reusability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match variable syntax:",
        "type": "match",
        "left": [
            "$name",
            "Type",
            "Default",
            "Non-null"
        ],
        "right": [
            "Variable name",
            "Expected type",
            "Fallback value",
            "Required"
        ]
    },
    {
        "q": "Which approach handles operation definitions?",
        "type": "mcq",
        "o": [
            "Define named operations with type and variables",
            "Anonymous only",
            "No names",
            "Auto-generated"
        ]
    },
    {
        "q": "The ______ keyword starts a query operation.",
        "type": "fill_blank",
        "answers": [
            "query"
        ],
        "other_options": [
            "get",
            "fetch",
            "read"
        ]
    },
    {
        "q": "Operation names aid debugging and analytics.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match operation types:",
        "type": "match",
        "left": [
            "query",
            "mutation",
            "subscription",
            "fragment"
        ],
        "right": [
            "Read data",
            "Write data",
            "Real-time",
            "Reusable fields"
        ]
    },
    {
        "q": "What is the output of this multi-operation document?",
        "type": "mcq",
        "c": "query GetUser($id: ID!) {\n    user(id: $id) { name }\n}\n\nquery GetPosts {\n    posts { title }\n}",
        "o": [
            "Two operations in one document, one executed per request",
            "Both execute together",
            "Error",
            "Only first executes"
        ]
    },
    {
        "q": "Rearrange operation execution:",
        "type": "rearrange",
        "words": [
            "Parse document",
            "Find operation by name",
            "Validate variables",
            "Execute operation"
        ]
    },
    {
        "q": "Which approach handles fragment spreading?",
        "type": "mcq",
        "o": [
            "Include fragment fields using ...FragmentName",
            "Copy fields",
            "No spreading",
            "Inline only"
        ]
    },
    {
        "q": "The ______ operator includes fragment fields.",
        "type": "fill_blank",
        "answers": [
            "..."
        ],
        "other_options": [
            "@",
            "~",
            "$"
        ]
    },
    {
        "q": "Fragment spreading reduces query duplication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match fragment types:",
        "type": "match",
        "left": [
            "Named",
            "Inline",
            "On union",
            "On interface"
        ],
        "right": [
            "Reusable",
            "Inline spread",
            "Type conditional",
            "Abstract type"
        ]
    },
    {
        "q": "Which approach handles type conditions?",
        "type": "mcq",
        "o": [
            "Conditionally include fields based on type",
            "No conditions",
            "Always include",
            "Client filtering"
        ]
    },
    {
        "q": "The ______ keyword specifies type condition.",
        "type": "fill_blank",
        "answers": [
            "on"
        ],
        "other_options": [
            "if",
            "when",
            "for"
        ]
    },
    {
        "q": "Type conditions enable polymorphic queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match type condition uses:",
        "type": "match",
        "left": [
            "Union",
            "Interface",
            "Object",
            "Inline"
        ],
        "right": [
            "Multiple types",
            "Shared fields",
            "Specific type",
            "Ad-hoc"
        ]
    },
    {
        "q": "Rearrange type-conditional query:",
        "type": "rearrange",
        "words": [
            "Query field",
            "Check __typename",
            "Apply type condition",
            "Include matching fields"
        ]
    },
    {
        "q": "Which approach handles directive arguments?",
        "type": "mcq",
        "o": [
            "Pass values to control directive behavior",
            "No arguments",
            "Fixed behavior",
            "Client-side"
        ]
    },
    {
        "q": "The ______ argument controls @include directive.",
        "type": "fill_blank",
        "answers": [
            "if"
        ],
        "other_options": [
            "when",
            "condition",
            "show"
        ]
    },
    {
        "q": "Directive arguments enable dynamic behavior.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match directive usage:",
        "type": "match",
        "left": [
            "@include(if:)",
            "@skip(if:)",
            "@deprecated",
            "@specifiedBy"
        ],
        "right": [
            "Conditional include",
            "Conditional skip",
            "Mark outdated",
            "Scalar URL"
        ]
    },
    {
        "q": "Which approach handles schema descriptions?",
        "type": "mcq",
        "o": [
            "Add documentation using triple-quote strings",
            "No descriptions",
            "External docs",
            "Comments only"
        ]
    },
    {
        "q": "The ______ documentation syntax adds descriptions.",
        "type": "fill_blank",
        "answers": [
            "\"\"\""
        ],
        "other_options": [
            "'''",
            "//",
            "/* */"
        ]
    },
    {
        "q": "Descriptions appear in introspection results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match description targets:",
        "type": "match",
        "left": [
            "Type",
            "Field",
            "Argument",
            "Enum value"
        ],
        "right": [
            "Object docs",
            "Property docs",
            "Param docs",
            "Constant docs"
        ]
    },
    {
        "q": "Which approach handles interface inheritance?",
        "type": "mcq",
        "o": [
            "Types can implement multiple interfaces",
            "Single interface",
            "No inheritance",
            "Class-based"
        ]
    },
    {
        "q": "The ______ keyword allows multiple interfaces.",
        "type": "fill_blank",
        "answers": [
            "&"
        ],
        "other_options": [
            ",",
            "+",
            "|"
        ]
    },
    {
        "q": "Types must implement all interface fields.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match interface patterns:",
        "type": "match",
        "left": [
            "Single",
            "Multiple",
            "Extending",
            "Hierarchical"
        ],
        "right": [
            "One interface",
            "implements A & B",
            "Interface extends",
            "Nested interfaces"
        ]
    },
    {
        "q": "What is the output of this interface query?",
        "type": "mcq",
        "c": "interface Node {\n    id: ID!\n}\n\ninterface Timestamped {\n    createdAt: DateTime!\n}\n\ntype User implements Node & Timestamped {\n    id: ID!\n    createdAt: DateTime!\n    name: String!\n}",
        "o": [
            "User implements both Node and Timestamped",
            "Only Node interface",
            "No interfaces",
            "Error"
        ]
    },
    {
        "q": "Rearrange interface implementation:",
        "type": "rearrange",
        "words": [
            "Define interfaces",
            "Create type",
            "Add implements clause",
            "Include all fields"
        ]
    },
    {
        "q": "Which approach handles union resolution?",
        "type": "mcq",
        "o": [
            "__resolveType determines concrete type",
            "No resolution needed",
            "Client determines",
            "Random selection"
        ]
    },
    {
        "q": "The ______ function determines union member type.",
        "type": "fill_blank",
        "answers": [
            "__resolveType"
        ],
        "other_options": [
            "resolveUnion",
            "getType",
            "determineType"
        ]
    },
    {
        "q": "Union types require type resolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match union patterns:",
        "type": "match",
        "left": [
            "Search result",
            "Notification",
            "Media",
            "Activity"
        ],
        "right": [
            "User | Post",
            "Email | Push",
            "Image | Video",
            "Comment | Like"
        ]
    },
    {
        "q": "Which approach handles enum serialization?",
        "type": "mcq",
        "o": [
            "Enums serialize to string values",
            "Numeric values",
            "Object values",
            "No serialization"
        ]
    },
    {
        "q": "The ______ value is the serialized enum output.",
        "type": "fill_blank",
        "answers": [
            "string"
        ],
        "other_options": [
            "number",
            "object",
            "array"
        ]
    },
    {
        "q": "Enum values are case-sensitive.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match enum uses:",
        "type": "match",
        "left": [
            "Status",
            "Priority",
            "Role",
            "Category"
        ],
        "right": [
            "State values",
            "Importance levels",
            "Permission sets",
            "Classification"
        ]
    },
    {
        "q": "Rearrange enum definition:",
        "type": "rearrange",
        "words": [
            "enum keyword",
            "EnumName",
            "Opening brace",
            "Value list",
            "Closing brace"
        ]
    },
    {
        "q": "Which approach handles list types?",
        "type": "mcq",
        "o": [
            "Square brackets define list types",
            "Array keyword",
            "List keyword",
            "No lists"
        ]
    },
    {
        "q": "The ______ syntax denotes a list type.",
        "type": "fill_blank",
        "answers": [
            "[Type]"
        ],
        "other_options": [
            "Array<Type>",
            "List<Type>",
            "Type[]"
        ]
    },
    {
        "q": "[String!]! means list and items are non-null.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match list nullability:",
        "type": "match",
        "left": [
            "[String]",
            "[String!]",
            "[String]!",
            "[String!]!"
        ],
        "right": [
            "Nullable list, nullable items",
            "Nullable list, non-null items",
            "Non-null list, nullable items",
            "Both non-null"
        ]
    },
    {
        "q": "Which approach handles field arguments?",
        "type": "mcq",
        "o": [
            "Pass named arguments to fields",
            "Positional arguments",
            "No arguments",
            "Global params"
        ]
    },
    {
        "q": "The ______ syntax defines field arguments.",
        "type": "fill_blank",
        "answers": [
            "(arg: Type)"
        ],
        "other_options": [
            "[arg: Type]",
            "{arg: Type}",
            "<arg: Type>"
        ]
    },
    {
        "q": "Field arguments enable filtering and pagination.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match argument patterns:",
        "type": "match",
        "left": [
            "id: ID!",
            "first: Int",
            "filter: Input",
            "orderBy: Enum"
        ],
        "right": [
            "Identify item",
            "Pagination",
            "Query filter",
            "Sorting"
        ]
    },
    {
        "q": "What is the output of this field with arguments?",
        "type": "mcq",
        "c": "type Query {\n    users(\n        first: Int = 10,\n        after: String,\n        filter: UserFilter\n    ): UserConnection!\n}",
        "o": [
            "Paginated users with optional filter",
            "All users",
            "Single user",
            "Error"
        ]
    },
    {
        "q": "Rearrange argument resolution:",
        "type": "rearrange",
        "words": [
            "Parse arguments",
            "Apply defaults",
            "Validate types",
            "Pass to resolver"
        ]
    },
    {
        "q": "Which approach handles root types?",
        "type": "mcq",
        "o": [
            "Query, Mutation, Subscription as entry points",
            "Any type",
            "No root types",
            "Custom roots"
        ]
    },
    {
        "q": "The ______ type is the read entry point.",
        "type": "fill_blank",
        "answers": [
            "Query"
        ],
        "other_options": [
            "Root",
            "Read",
            "Get"
        ]
    },
    {
        "q": "Every GraphQL API must have a Query type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match root types:",
        "type": "match",
        "left": [
            "Query",
            "Mutation",
            "Subscription",
            "schema"
        ],
        "right": [
            "Read operations",
            "Write operations",
            "Real-time",
            "Root config"
        ]
    },
    {
        "q": "Which approach handles schema extensions?",
        "type": "mcq",
        "o": [
            "Extend existing types with new fields",
            "Modify original",
            "New type",
            "No extensions"
        ]
    },
    {
        "q": "The ______ keyword adds fields to existing types.",
        "type": "fill_blank",
        "answers": [
            "extend"
        ],
        "other_options": [
            "add",
            "append",
            "merge"
        ]
    },
    {
        "q": "Extensions enable modular schema development.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match extension types:",
        "type": "match",
        "left": [
            "extend type",
            "extend interface",
            "extend union",
            "extend enum"
        ],
        "right": [
            "Add fields",
            "Add interface fields",
            "Add union members",
            "Add enum values"
        ]
    },
    {
        "q": "Rearrange schema extension:",
        "type": "rearrange",
        "words": [
            "Define base type",
            "Create extension",
            "Add new fields",
            "Merge at build"
        ]
    },
    {
        "q": "Which approach handles object type definitions?",
        "type": "mcq",
        "o": [
            "Define types with named fields",
            "No type definitions",
            "Dynamic types",
            "Any object"
        ]
    },
    {
        "q": "The ______ keyword defines object types.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "class",
            "object",
            "struct"
        ]
    },
    {
        "q": "Object types define the shape of data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match type components:",
        "type": "match",
        "left": [
            "Name",
            "Fields",
            "Implements",
            "Directives"
        ],
        "right": [
            "Type identifier",
            "Properties",
            "Interfaces",
            "Modifiers"
        ]
    },
    {
        "q": "Which approach handles recursive types?",
        "type": "mcq",
        "o": [
            "Types referencing themselves for tree structures",
            "No recursion",
            "Flatten only",
            "Limited depth"
        ]
    },
    {
        "q": "The ______ pattern models hierarchical data.",
        "type": "fill_blank",
        "answers": [
            "self-referential"
        ],
        "other_options": [
            "recursive",
            "nested",
            "tree"
        ]
    },
    {
        "q": "Recursive types need depth limits for queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match recursive examples:",
        "type": "match",
        "left": [
            "Comment",
            "Category",
            "Folder",
            "Organization"
        ],
        "right": [
            "replies: [Comment]",
            "children: [Category]",
            "subfolders: [Folder]",
            "divisions: [Org]"
        ]
    },
    {
        "q": "What is the output of this recursive query?",
        "type": "mcq",
        "c": "type Comment {\n    id: ID!\n    text: String!\n    replies: [Comment!]!\n}\n\nquery {\n    comment(id: \"1\") {\n        text\n        replies { text replies { text } }\n    }\n}",
        "o": [
            "Comment with nested replies to depth 2",
            "All replies",
            "No replies",
            "Error"
        ]
    },
    {
        "q": "Rearrange recursive resolution:",
        "type": "rearrange",
        "words": [
            "Fetch parent",
            "Fetch children",
            "Resolve recursively",
            "Check depth limit",
            "Return tree"
        ]
    },
    {
        "q": "Which approach handles abstract types?",
        "type": "mcq",
        "o": [
            "Interfaces and unions for polymorphism",
            "Concrete only",
            "No abstraction",
            "Class hierarchy"
        ]
    },
    {
        "q": "The ______ type groups unrelated types.",
        "type": "fill_blank",
        "answers": [
            "union"
        ],
        "other_options": [
            "interface",
            "abstract",
            "mixed"
        ]
    },
    {
        "q": "Abstract types require __resolveType.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match abstract patterns:",
        "type": "match",
        "left": [
            "Interface",
            "Union",
            "Type implements",
            "Inline fragment"
        ],
        "right": [
            "Shared fields",
            "Multiple types",
            "Adopts interface",
            "Type selection"
        ]
    },
    {
        "q": "GraphQL enables precise and efficient data fetching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL core concepts:",
        "type": "match",
        "left": [
            "Schema",
            "Type",
            "Field",
            "Resolver"
        ],
        "right": [
            "API contract",
            "Data shape",
            "Property",
            "Data fetcher"
        ]
    },
    {
        "q": "Which approach handles execution context?",
        "type": "mcq",
        "o": [
            "Share state across resolvers via context object",
            "Global state",
            "No sharing",
            "Resolver params"
        ]
    },
    {
        "q": "The ______ object passes shared data to resolvers.",
        "type": "fill_blank",
        "answers": [
            "context"
        ],
        "other_options": [
            "state",
            "globals",
            "shared"
        ]
    },
    {
        "q": "Context is created fresh per request.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match context contents:",
        "type": "match",
        "left": [
            "User",
            "DataLoaders",
            "Database",
            "Request"
        ],
        "right": [
            "Auth info",
            "Batch loaders",
            "DB connection",
            "HTTP request"
        ]
    },
    {
        "q": "Rearrange context setup:",
        "type": "rearrange",
        "words": [
            "Create context function",
            "Extract auth from request",
            "Initialize DataLoaders",
            "Return context object"
        ]
    },
    {
        "q": "Which approach handles field-level authorization?",
        "type": "mcq",
        "o": [
            "Check permissions per field in resolvers",
            "Global auth only",
            "No authorization",
            "Schema-level only"
        ]
    },
    {
        "q": "The ______ middleware enforces field permissions.",
        "type": "fill_blank",
        "answers": [
            "auth"
        ],
        "other_options": [
            "permission",
            "guard",
            "protect"
        ]
    },
    {
        "q": "Field authorization enables fine-grained access control.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match authorization checks:",
        "type": "match",
        "left": [
            "isAuthenticated",
            "hasRole",
            "ownsResource",
            "hasPermission"
        ],
        "right": [
            "Logged in",
            "Role-based",
            "Object ownership",
            "Specific permission"
        ]
    },
    {
        "q": "GraphQL provides a type-safe API layer for modern applications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL ecosystem:",
        "type": "match",
        "left": [
            "Apollo",
            "Relay",
            "Hasura",
            "Prisma"
        ],
        "right": [
            "Full-stack platform",
            "Facebook client",
            "Instant GraphQL engine",
            "Database toolkit"
        ]
    },
    {
        "q": "Which approach handles selective field resolution?",
        "type": "mcq",
        "o": [
            "Only resolve fields requested in query",
            "Resolve all fields",
            "Client selection",
            "No selection"
        ]
    },
    {
        "q": "The ______ parameter shows requested fields.",
        "type": "fill_blank",
        "answers": [
            "info"
        ],
        "other_options": [
            "args",
            "context",
            "parent"
        ]
    },
    {
        "q": "Selective resolution prevents unnecessary database queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match info object properties:",
        "type": "match",
        "left": [
            "fieldName",
            "fieldNodes",
            "returnType",
            "parentType"
        ],
        "right": [
            "Field name",
            "Selection set",
            "Return type",
            "Parent type"
        ]
    },
    {
        "q": "Which approach handles parallel resolver execution?",
        "type": "mcq",
        "o": [
            "Execute sibling resolvers concurrently",
            "Sequential only",
            "No parallelism",
            "Client controls"
        ]
    },
    {
        "q": "The ______ pattern batches parallel requests.",
        "type": "fill_blank",
        "answers": [
            "DataLoader"
        ],
        "other_options": [
            "Promise.all",
            "async",
            "batch"
        ]
    },
    {
        "q": "Parallel execution improves query performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match execution patterns:",
        "type": "match",
        "left": [
            "Sibling parallel",
            "Child sequential",
            "Batched",
            "Deferred"
        ],
        "right": [
            "Same level",
            "After parent",
            "Grouped requests",
            "Lazy load"
        ]
    },
    {
        "q": "Rearrange field execution:",
        "type": "rearrange",
        "words": [
            "Resolve parent",
            "Identify child fields",
            "Execute siblings in parallel",
            "Await results"
        ]
    },
    {
        "q": "Which approach handles result coercion?",
        "type": "mcq",
        "o": [
            "Convert resolver output to expected type",
            "No conversion",
            "Client conversion",
            "Error on mismatch"
        ]
    },
    {
        "q": "The ______ phase converts results to schema types.",
        "type": "fill_blank",
        "answers": [
            "coercion"
        ],
        "other_options": [
            "serialization",
            "formatting",
            "transformation"
        ]
    },
    {
        "q": "Coercion ensures type-safe responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match coercion types:",
        "type": "match",
        "left": [
            "Scalar",
            "Enum",
            "Object",
            "List"
        ],
        "right": [
            "Serialize value",
            "Validate constant",
            "Shape object",
            "Map array"
        ]
    },
    {
        "q": "Which approach handles lazy loading?",
        "type": "mcq",
        "o": [
            "Load data only when field is requested",
            "Eager loading",
            "No lazy loading",
            "Client-side"
        ]
    },
    {
        "q": "The ______ pattern defers data loading.",
        "type": "fill_blank",
        "answers": [
            "resolver"
        ],
        "other_options": [
            "loader",
            "fetcher",
            "getter"
        ]
    },
    {
        "q": "Lazy loading reduces initial load time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match loading strategies:",
        "type": "match",
        "left": [
            "Eager",
            "Lazy",
            "Batched",
            "Cached"
        ],
        "right": [
            "Load immediately",
            "Load on request",
            "Group loads",
            "Store results"
        ]
    },
    {
        "q": "Which approach handles lookahead?",
        "type": "mcq",
        "o": [
            "Analyze query to optimize data fetching",
            "No lookahead",
            "Fetch all",
            "Client hints"
        ]
    },
    {
        "q": "The ______ analyzes requested fields ahead.",
        "type": "fill_blank",
        "answers": [
            "lookahead"
        ],
        "other_options": [
            "preview",
            "analyze",
            "inspect"
        ]
    },
    {
        "q": "Lookahead enables SQL join optimization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match lookahead uses:",
        "type": "match",
        "left": [
            "Join planning",
            "Batch hints",
            "Caching",
            "Preloading"
        ],
        "right": [
            "Optimize SQL",
            "Group requests",
            "Cache hints",
            "Load ahead"
        ]
    },
    {
        "q": "Rearrange lookahead flow:",
        "type": "rearrange",
        "words": [
            "Receive query",
            "Analyze selections",
            "Determine data needs",
            "Optimize fetch",
            "Execute query"
        ]
    },
    {
        "q": "Which approach handles connection pattern?",
        "type": "mcq",
        "o": [
            "Edges with nodes and pageInfo for pagination",
            "Simple array",
            "Nested pages",
            "No pagination"
        ]
    },
    {
        "q": "The ______ object contains pagination metadata.",
        "type": "fill_blank",
        "answers": [
            "pageInfo"
        ],
        "other_options": [
            "meta",
            "pagination",
            "info"
        ]
    },
    {
        "q": "Connection pattern is the Relay specification standard.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match connection parts:",
        "type": "match",
        "left": [
            "edges",
            "node",
            "cursor",
            "pageInfo"
        ],
        "right": [
            "Item wrappers",
            "Actual data",
            "Position marker",
            "Has more info"
        ]
    },
    {
        "q": "Which approach handles node interface?",
        "type": "mcq",
        "o": [
            "Global object identification with ID",
            "Local IDs only",
            "No global ID",
            "UUID everywhere"
        ]
    },
    {
        "q": "The ______ interface provides global IDs.",
        "type": "fill_blank",
        "answers": [
            "Node"
        ],
        "other_options": [
            "Entity",
            "Object",
            "Base"
        ]
    },
    {
        "q": "Node interface enables refetching any object.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match node concepts:",
        "type": "match",
        "left": [
            "Global ID",
            "node query",
            "Type encoding",
            "Refetch"
        ],
        "right": [
            "Unique identifier",
            "Fetch by ID",
            "Type in ID",
            "Get fresh data"
        ]
    },
    {
        "q": "Rearrange global ID creation:",
        "type": "rearrange",
        "words": [
            "Get type name",
            "Get local ID",
            "Combine",
            "Base64 encode",
            "Return global ID"
        ]
    },
    {
        "q": "Which approach handles connection arguments?",
        "type": "mcq",
        "o": [
            "first, after, last, before for bidirectional pagination",
            "page and limit",
            "offset only",
            "No arguments"
        ]
    },
    {
        "q": "The ______ argument moves forward through pages.",
        "type": "fill_blank",
        "answers": [
            "after"
        ],
        "other_options": [
            "next",
            "from",
            "since"
        ]
    },
    {
        "q": "Cursor-based pagination handles real-time data better.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match pagination directions:",
        "type": "match",
        "left": [
            "first + after",
            "last + before",
            "first only",
            "last only"
        ],
        "right": [
            "Forward from cursor",
            "Backward from cursor",
            "First N items",
            "Last N items"
        ]
    },
    {
        "q": "Which approach handles plural identifying root fields?",
        "type": "mcq",
        "o": [
            "Fetch multiple items by IDs in one query",
            "Loop queries",
            "Separate queries",
            "No plural"
        ]
    },
    {
        "q": "The ______ query fetches multiple nodes.",
        "type": "fill_blank",
        "answers": [
            "nodes"
        ],
        "other_options": [
            "items",
            "objects",
            "entities"
        ]
    },
    {
        "q": "Plural root fields reduce request count.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match root field patterns:",
        "type": "match",
        "left": [
            "node(id)",
            "nodes(ids)",
            "viewer",
            "currentUser"
        ],
        "right": [
            "Single by ID",
            "Multiple by IDs",
            "Current context",
            "Logged in user"
        ]
    },
    {
        "q": "Rearrange plural fetch:",
        "type": "rearrange",
        "words": [
            "Receive IDs array",
            "Decode global IDs",
            "Group by type",
            "Batch fetch",
            "Return ordered results"
        ]
    },
    {
        "q": "Which approach handles mutation inputs?",
        "type": "mcq",
        "o": [
            "Single input type argument for mutations",
            "Multiple arguments",
            "No input type",
            "Inline arguments"
        ]
    },
    {
        "q": "The ______ type groups mutation arguments.",
        "type": "fill_blank",
        "answers": [
            "Input"
        ],
        "other_options": [
            "Args",
            "Params",
            "Data"
        ]
    },
    {
        "q": "Input types improve mutation signatures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mutation patterns:",
        "type": "match",
        "left": [
            "CreateUserInput",
            "UpdateUserInput",
            "DeleteUserInput",
            "BatchInput"
        ],
        "right": [
            "New user data",
            "Update fields",
            "Delete reference",
            "Multiple operations"
        ]
    },
    {
        "q": "Which approach handles mutation payloads?",
        "type": "mcq",
        "o": [
            "Return type with affected data and errors",
            "Simple response",
            "Boolean only",
            "No payload"
        ]
    },
    {
        "q": "The ______ type contains mutation results.",
        "type": "fill_blank",
        "answers": [
            "Payload"
        ],
        "other_options": [
            "Result",
            "Response",
            "Output"
        ]
    },
    {
        "q": "Payload types enable rich mutation responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match payload fields:",
        "type": "match",
        "left": [
            "user",
            "errors",
            "clientMutationId",
            "edge"
        ],
        "right": [
            "Created/updated",
            "Validation errors",
            "Client tracking",
            "For lists"
        ]
    },
    {
        "q": "Rearrange mutation flow:",
        "type": "rearrange",
        "words": [
            "Receive input",
            "Validate data",
            "Perform operation",
            "Build payload",
            "Return result"
        ]
    },
    {
        "q": "Which approach handles client mutation ID?",
        "type": "mcq",
        "o": [
            "Echo back client-provided ID for correlation",
            "Server generates",
            "No ID",
            "Auto-increment"
        ]
    },
    {
        "q": "The ______ field correlates request and response.",
        "type": "fill_blank",
        "answers": [
            "clientMutationId"
        ],
        "other_options": [
            "requestId",
            "correlationId",
            "trackingId"
        ]
    },
    {
        "q": "Client mutation ID aids optimistic updates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mutation tracking:",
        "type": "match",
        "left": [
            "clientMutationId",
            "optimistic",
            "rollback",
            "conflict"
        ],
        "right": [
            "Request tracking",
            "Immediate UI",
            "Undo on error",
            "Handle collision"
        ]
    },
    {
        "q": "Which approach handles subscription payloads?",
        "type": "mcq",
        "o": [
            "Return event-specific data structure",
            "Generic payload",
            "Raw event",
            "No structure"
        ]
    },
    {
        "q": "The ______ contains subscription event data.",
        "type": "fill_blank",
        "answers": [
            "payload"
        ],
        "other_options": [
            "event",
            "data",
            "message"
        ]
    },
    {
        "q": "Subscription payloads should include enough context.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match subscription events:",
        "type": "match",
        "left": [
            "created",
            "updated",
            "deleted",
            "connected"
        ],
        "right": [
            "New item",
            "Changed item",
            "Removed item",
            "Status change"
        ]
    },
    {
        "q": "Rearrange subscription event:",
        "type": "rearrange",
        "words": [
            "Event occurs",
            "Build payload",
            "Filter subscribers",
            "Publish to clients",
            "Handle acknowledgment"
        ]
    },
    {
        "q": "Which approach handles viewer pattern?",
        "type": "mcq",
        "o": [
            "Root field representing current user context",
            "No viewer",
            "Global user",
            "Session state"
        ]
    },
    {
        "q": "The ______ field represents the current user.",
        "type": "fill_blank",
        "answers": [
            "viewer"
        ],
        "other_options": [
            "me",
            "currentUser",
            "user"
        ]
    },
    {
        "q": "Viewer pattern encapsulates user-specific data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match viewer fields:",
        "type": "match",
        "left": [
            "id",
            "profile",
            "settings",
            "permissions"
        ],
        "right": [
            "User ID",
            "User data",
            "Preferences",
            "Access rights"
        ]
    },
    {
        "q": "Which approach handles mutation conventions?",
        "type": "mcq",
        "o": [
            "Verb + noun naming like createUser",
            "Generic names",
            "CRUD only",
            "No convention"
        ]
    },
    {
        "q": "The ______ prefix indicates write operations.",
        "type": "fill_blank",
        "answers": [
            "create/update/delete"
        ],
        "other_options": [
            "set/get",
            "put/post",
            "write/read"
        ]
    },
    {
        "q": "Consistent naming improves API discoverability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mutation naming:",
        "type": "match",
        "left": [
            "createUser",
            "updateUser",
            "deleteUser",
            "addUserToTeam"
        ],
        "right": [
            "Create new",
            "Modify existing",
            "Remove item",
            "Relationship"
        ]
    },
    {
        "q": "Rearrange mutation naming:",
        "type": "rearrange",
        "words": [
            "Choose verb",
            "Add resource noun",
            "CamelCase format",
            "Match input type name"
        ]
    },
    {
        "q": "Which approach handles enum naming?",
        "type": "mcq",
        "o": [
            "UPPER_SNAKE_CASE for values",
            "camelCase",
            "lowercase",
            "Mixed case"
        ]
    },
    {
        "q": "The ______ case is standard for enum values.",
        "type": "fill_blank",
        "answers": [
            "UPPER_SNAKE_CASE"
        ],
        "other_options": [
            "camelCase",
            "PascalCase",
            "lowercase"
        ]
    },
    {
        "q": "Enum naming conventions improve consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match naming conventions:",
        "type": "match",
        "left": [
            "Type",
            "Field",
            "Argument",
            "Enum value"
        ],
        "right": [
            "PascalCase",
            "camelCase",
            "camelCase",
            "UPPER_SNAKE"
        ]
    },
    {
        "q": "Which approach handles type naming?",
        "type": "mcq",
        "o": [
            "PascalCase for type names",
            "camelCase",
            "snake_case",
            "No convention"
        ]
    },
    {
        "q": "The ______ case is standard for type names.",
        "type": "fill_blank",
        "answers": [
            "PascalCase"
        ],
        "other_options": [
            "camelCase",
            "snake_case",
            "UPPERCASE"
        ]
    },
    {
        "q": "Consistent type naming improves schema readability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match type name patterns:",
        "type": "match",
        "left": [
            "User",
            "UserInput",
            "UserPayload",
            "UserConnection"
        ],
        "right": [
            "Entity type",
            "Input type",
            "Mutation result",
            "Paginated type"
        ]
    },
    {
        "q": "Rearrange type naming:",
        "type": "rearrange",
        "words": [
            "Choose base name",
            "Add suffix for role",
            "PascalCase format",
            "Document purpose"
        ]
    },
    {
        "q": "Which approach handles API evolution?",
        "type": "mcq",
        "o": [
            "Add fields, deprecate, then remove",
            "Break immediately",
            "Version everything",
            "Never change"
        ]
    },
    {
        "q": "The ______ strategy avoids breaking changes.",
        "type": "fill_blank",
        "answers": [
            "additive"
        ],
        "other_options": [
            "versioning",
            "replacement",
            "migration"
        ]
    },
    {
        "q": "GraphQL promotes versionless evolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match evolution phases:",
        "type": "match",
        "left": [
            "Add",
            "Deprecate",
            "Migrate",
            "Remove"
        ],
        "right": [
            "New field",
            "Mark old",
            "Move clients",
            "Clean up"
        ]
    },
    {
        "q": "GraphQL provides flexible and efficient data fetching.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL benefits:",
        "type": "match",
        "left": [
            "Type safety",
            "Single endpoint",
            "Introspection",
            "Client control"
        ],
        "right": [
            "Strong typing",
            "One URL",
            "Self-documenting",
            "Request only needed"
        ]
    },
    {
        "q": "Which approach handles operation complexity?",
        "type": "mcq",
        "o": [
            "Assign and limit total query cost",
            "No limits",
            "Fixed limits",
            "Client determines"
        ]
    },
    {
        "q": "The ______ analysis calculates query cost.",
        "type": "fill_blank",
        "answers": [
            "complexity"
        ],
        "other_options": [
            "cost",
            "weight",
            "size"
        ]
    },
    {
        "q": "Complexity analysis protects against abuse.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match complexity factors:",
        "type": "match",
        "left": [
            "Field weight",
            "List multiplier",
            "Depth penalty",
            "Resolver cost"
        ],
        "right": [
            "Base cost",
            "Item count",
            "Nesting level",
            "Database calls"
        ]
    },
    {
        "q": "Which approach handles client-side caching?",
        "type": "mcq",
        "o": [
            "Normalized cache with object identifiers",
            "No caching",
            "Local storage only",
            "Server-side only"
        ]
    },
    {
        "q": "The ______ stores normalized GraphQL data.",
        "type": "fill_blank",
        "answers": [
            "InMemoryCache"
        ],
        "other_options": [
            "LocalStore",
            "GraphQLCache",
            "DataStore"
        ]
    },
    {
        "q": "Normalized caching prevents duplicate data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match caching strategies:",
        "type": "match",
        "left": [
            "cache-first",
            "network-only",
            "cache-and-network",
            "standby"
        ],
        "right": [
            "Cache priority",
            "Always network",
            "Both sources",
            "No auto-fetch"
        ]
    },
    {
        "q": "Which approach handles local state management?",
        "type": "mcq",
        "o": [
            "Extend schema with local-only fields",
            "Separate state library",
            "Context API only",
            "No local state"
        ]
    },
    {
        "q": "The ______ directive marks client-only fields.",
        "type": "fill_blank",
        "answers": [
            "@client"
        ],
        "other_options": [
            "@local",
            "@state",
            "@ui"
        ]
    },
    {
        "q": "Local state can coexist with remote data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match state types:",
        "type": "match",
        "left": [
            "Remote",
            "Local",
            "Derived",
            "UI"
        ],
        "right": [
            "Server data",
            "Client-only",
            "Computed",
            "Interface state"
        ]
    },
    {
        "q": "Rearrange cache update:",
        "type": "rearrange",
        "words": [
            "Identify cached object",
            "Read current data",
            "Modify fields",
            "Write back to cache"
        ]
    },
    {
        "q": "Which approach handles reactive variables?",
        "type": "mcq",
        "o": [
            "Observable state outside cache",
            "Redux integration",
            "Context only",
            "No reactive state"
        ]
    },
    {
        "q": "The ______ creates reactive local state.",
        "type": "fill_blank",
        "answers": [
            "makeVar"
        ],
        "other_options": [
            "createVar",
            "reactive",
            "makeReactive"
        ]
    },
    {
        "q": "Reactive variables trigger component re-renders.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match reactive patterns:",
        "type": "match",
        "left": [
            "makeVar",
            "useReactiveVar",
            "@client",
            "cache.modify"
        ],
        "right": [
            "Create variable",
            "Read in component",
            "Mark local",
            "Update cache"
        ]
    },
    {
        "q": "Which approach handles server-side rendering?",
        "type": "mcq",
        "o": [
            "Prefetch and hydrate on client",
            "Client-only",
            "No SSR support",
            "Separate API"
        ]
    },
    {
        "q": "The ______ phase prepares data for SSR.",
        "type": "fill_blank",
        "answers": [
            "getDataFromTree"
        ],
        "other_options": [
            "prefetch",
            "preload",
            "serverFetch"
        ]
    },
    {
        "q": "SSR improves initial page load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match SSR phases:",
        "type": "match",
        "left": [
            "Prefetch",
            "Serialize",
            "Transfer",
            "Hydrate"
        ],
        "right": [
            "Load data",
            "To string",
            "To client",
            "Activate"
        ]
    },
    {
        "q": "Rearrange SSR flow:",
        "type": "rearrange",
        "words": [
            "Server receives request",
            "Execute GraphQL queries",
            "Render HTML",
            "Transfer state",
            "Client hydrates"
        ]
    },
    {
        "q": "GraphQL revolutionizes API development with its type system.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match GraphQL to alternatives:",
        "type": "match",
        "left": [
            "vs REST",
            "vs gRPC",
            "vs SOAP",
            "vs tRPC"
        ],
        "right": [
            "Flexible fetching",
            "Schema vs proto",
            "Modern vs legacy",
            "Full-stack TS"
        ]
    }
]