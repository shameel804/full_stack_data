[
    {
        "q": "What is API design?",
        "type": "mcq",
        "o": [
            "Planning how an API will work and be used",
            "Writing code",
            "Testing APIs",
            "Deploying APIs"
        ]
    },
    {
        "q": "API design focuses on usability and developer experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ defines how clients interact with an API.",
        "type": "fill_blank",
        "answers": [
            "contract"
        ],
        "other_options": [
            "code",
            "server",
            "database"
        ]
    },
    {
        "q": "Match API design elements:",
        "type": "match",
        "left": [
            "Endpoints",
            "Methods",
            "Parameters",
            "Responses"
        ],
        "right": [
            "URL paths",
            "HTTP verbs",
            "Input data",
            "Output data"
        ]
    },
    {
        "q": "Rearrange API design process:",
        "type": "rearrange",
        "words": [
            "Identify requirements",
            "Design endpoints",
            "Define data models",
            "Document API"
        ]
    },
    {
        "q": "What is a resource in API design?",
        "type": "mcq",
        "o": [
            "An entity that can be accessed via the API",
            "Server hardware",
            "API documentation",
            "Authentication token"
        ]
    },
    {
        "q": "Resources should be named using nouns, not verbs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ represents a collection of similar items.",
        "type": "fill_blank",
        "answers": [
            "collection resource"
        ],
        "other_options": [
            "single resource",
            "action resource",
            "meta resource"
        ]
    },
    {
        "q": "Match resource types:",
        "type": "match",
        "left": [
            "Collection",
            "Single",
            "Sub-resource",
            "Action"
        ],
        "right": [
            "/users",
            "/users/123",
            "/users/123/posts",
            "/users/123/activate"
        ]
    },
    {
        "q": "Which naming convention is recommended for API resources?",
        "type": "mcq",
        "o": [
            "Plural nouns like /users",
            "Singular verbs like /getUser",
            "CamelCase like /getUsers",
            "Random names"
        ]
    },
    {
        "q": "The ______ convention uses hyphens between words.",
        "type": "fill_blank",
        "answers": [
            "kebab-case"
        ],
        "other_options": [
            "camelCase",
            "snake_case",
            "PascalCase"
        ]
    },
    {
        "q": "Consistent naming improves API usability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match naming styles:",
        "type": "match",
        "left": [
            "kebab-case",
            "camelCase",
            "snake_case",
            "PascalCase"
        ],
        "right": [
            "user-profiles",
            "userProfiles",
            "user_profiles",
            "UserProfiles"
        ]
    },
    {
        "q": "Rearrange URL structure:",
        "type": "rearrange",
        "words": [
            "Protocol",
            "Domain",
            "Base path",
            "Resource",
            "Identifier"
        ]
    },
    {
        "q": "What is an endpoint?",
        "type": "mcq",
        "o": [
            "A specific URL where API can be accessed",
            "Server hardware",
            "Database table",
            "Code function"
        ]
    },
    {
        "q": "Each endpoint should have a single responsibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ identifies a specific resource instance.",
        "type": "fill_blank",
        "answers": [
            "path parameter"
        ],
        "other_options": [
            "query parameter",
            "header",
            "body"
        ]
    },
    {
        "q": "Match endpoint patterns:",
        "type": "match",
        "left": [
            "GET /users",
            "GET /users/1",
            "POST /users",
            "DELETE /users/1"
        ],
        "right": [
            "List all",
            "Get one",
            "Create",
            "Remove"
        ]
    },
    {
        "q": "What are query parameters?",
        "type": "mcq",
        "o": [
            "Key-value pairs after ? in URL",
            "Path segments",
            "Request body fields",
            "Response headers"
        ]
    },
    {
        "q": "Query parameters are used for filtering and pagination.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ parameter limits result count.",
        "type": "fill_blank",
        "answers": [
            "limit"
        ],
        "other_options": [
            "offset",
            "page",
            "sort"
        ]
    },
    {
        "q": "Match query parameter uses:",
        "type": "match",
        "left": [
            "filter",
            "sort",
            "page",
            "fields"
        ],
        "right": [
            "Narrow results",
            "Order results",
            "Paginate",
            "Select fields"
        ]
    },
    {
        "q": "Rearrange filter query:",
        "type": "rearrange",
        "words": [
            "Base URL",
            "Question mark",
            "Parameter name",
            "Equals sign",
            "Value"
        ]
    },
    {
        "q": "What is request body?",
        "type": "mcq",
        "o": [
            "Data sent with POST/PUT requests",
            "URL parameters",
            "Response data",
            "Authentication info"
        ]
    },
    {
        "q": "Request body is typically formatted as JSON.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header specifies request body format.",
        "type": "fill_blank",
        "answers": [
            "Content-Type"
        ],
        "other_options": [
            "Accept",
            "Authorization",
            "Cache-Control"
        ]
    },
    {
        "q": "Match content types:",
        "type": "match",
        "left": [
            "application/json",
            "application/xml",
            "multipart/form-data",
            "text/plain"
        ],
        "right": [
            "JSON data",
            "XML data",
            "File uploads",
            "Plain text"
        ]
    },
    {
        "q": "What is response structure?",
        "type": "mcq",
        "o": [
            "Format of data returned by API",
            "Request format",
            "URL structure",
            "Authentication flow"
        ]
    },
    {
        "q": "Consistent response structure improves client parsing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ field contains the main response data.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "result",
            "payload",
            "content"
        ]
    },
    {
        "q": "Match response fields:",
        "type": "match",
        "left": [
            "data",
            "error",
            "meta",
            "links"
        ],
        "right": [
            "Main content",
            "Error details",
            "Pagination info",
            "Related URLs"
        ]
    },
    {
        "q": "Rearrange response processing:",
        "type": "rearrange",
        "words": [
            "Receive response",
            "Check status code",
            "Parse body",
            "Handle data or error"
        ]
    },
    {
        "q": "What is pagination?",
        "type": "mcq",
        "o": [
            "Dividing results into pages",
            "Sorting data",
            "Filtering results",
            "Caching responses"
        ]
    },
    {
        "q": "Pagination prevents returning too much data at once.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ parameter specifies starting point.",
        "type": "fill_blank",
        "answers": [
            "offset"
        ],
        "other_options": [
            "limit",
            "page",
            "cursor"
        ]
    },
    {
        "q": "Match pagination types:",
        "type": "match",
        "left": [
            "Offset",
            "Cursor",
            "Page number",
            "Keyset"
        ],
        "right": [
            "Skip N items",
            "After marker",
            "Page N",
            "After ID"
        ]
    },
    {
        "q": "What is filtering?",
        "type": "mcq",
        "o": [
            "Narrowing results based on criteria",
            "Sorting results",
            "Paginating results",
            "Caching results"
        ]
    },
    {
        "q": "Filters reduce data transfer and processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ operator compares values.",
        "type": "fill_blank",
        "answers": [
            "eq"
        ],
        "other_options": [
            "and",
            "or",
            "not"
        ]
    },
    {
        "q": "Match filter operators:",
        "type": "match",
        "left": [
            "eq",
            "ne",
            "gt",
            "lt"
        ],
        "right": [
            "Equals",
            "Not equals",
            "Greater than",
            "Less than"
        ]
    },
    {
        "q": "Rearrange filter application:",
        "type": "rearrange",
        "words": [
            "Parse filter params",
            "Validate values",
            "Build query",
            "Execute filter"
        ]
    },
    {
        "q": "What is sorting?",
        "type": "mcq",
        "o": [
            "Ordering results by field",
            "Filtering results",
            "Paginating results",
            "Grouping results"
        ]
    },
    {
        "q": "Multiple sort fields can be specified.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ prefix indicates descending order.",
        "type": "fill_blank",
        "answers": [
            "-"
        ],
        "other_options": [
            "+",
            "!",
            "~"
        ]
    },
    {
        "q": "Match sort orders:",
        "type": "match",
        "left": [
            "asc",
            "desc",
            "name",
            "-created_at"
        ],
        "right": [
            "Ascending",
            "Descending",
            "By name ascending",
            "By date descending"
        ]
    },
    {
        "q": "What is field selection?",
        "type": "mcq",
        "o": [
            "Choosing which fields to return",
            "Filtering by field value",
            "Sorting by field",
            "Grouping by field"
        ]
    },
    {
        "q": "Field selection reduces response size.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ parameter specifies returned fields.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "select",
            "include",
            "columns"
        ]
    },
    {
        "q": "Match field selection syntax:",
        "type": "match",
        "left": [
            "fields=name,email",
            "exclude=password",
            "expand=profile",
            "embed=posts"
        ],
        "right": [
            "Include specific",
            "Exclude field",
            "Include related",
            "Nest related"
        ]
    },
    {
        "q": "Rearrange field selection:",
        "type": "rearrange",
        "words": [
            "Parse fields param",
            "Validate field names",
            "Filter response",
            "Return subset"
        ]
    },
    {
        "q": "What is error handling?",
        "type": "mcq",
        "o": [
            "Managing and communicating failures",
            "Logging messages",
            "Validating input",
            "Testing code"
        ]
    },
    {
        "q": "Errors should include helpful messages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ code indicates client error.",
        "type": "fill_blank",
        "answers": [
            "4xx"
        ],
        "other_options": [
            "2xx",
            "3xx",
            "5xx"
        ]
    },
    {
        "q": "Match error categories:",
        "type": "match",
        "left": [
            "400",
            "401",
            "404",
            "500"
        ],
        "right": [
            "Bad request",
            "Unauthorized",
            "Not found",
            "Server error"
        ]
    },
    {
        "q": "What is error response format?",
        "type": "mcq",
        "o": [
            "Structured error information",
            "Plain text message",
            "Stack trace",
            "Empty response"
        ]
    },
    {
        "q": "Error responses should be consistent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ field contains error code.",
        "type": "fill_blank",
        "answers": [
            "code"
        ],
        "other_options": [
            "status",
            "type",
            "id"
        ]
    },
    {
        "q": "Match error fields:",
        "type": "match",
        "left": [
            "code",
            "message",
            "details",
            "target"
        ],
        "right": [
            "Error identifier",
            "Human message",
            "Additional info",
            "Affected field"
        ]
    },
    {
        "q": "Rearrange error handling:",
        "type": "rearrange",
        "words": [
            "Catch exception",
            "Determine error type",
            "Build error response",
            "Set status code",
            "Return response"
        ]
    },
    {
        "q": "What is API documentation?",
        "type": "mcq",
        "o": [
            "Description of how to use an API",
            "Source code comments",
            "Error logs",
            "Test reports"
        ]
    },
    {
        "q": "Good documentation improves API adoption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ specification is widely used for API docs.",
        "type": "fill_blank",
        "answers": [
            "OpenAPI"
        ],
        "other_options": [
            "Swagger",
            "RAML",
            "Blueprint"
        ]
    },
    {
        "q": "Match documentation elements:",
        "type": "match",
        "left": [
            "Overview",
            "Authentication",
            "Endpoints",
            "Examples"
        ],
        "right": [
            "Introduction",
            "Auth methods",
            "API routes",
            "Code samples"
        ]
    },
    {
        "q": "What is versioning?",
        "type": "mcq",
        "o": [
            "Managing API changes over time",
            "Numbering releases",
            "Backing up code",
            "Testing changes"
        ]
    },
    {
        "q": "Versioning allows backward compatibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ approach puts version in URL.",
        "type": "fill_blank",
        "answers": [
            "URL versioning"
        ],
        "other_options": [
            "header versioning",
            "query versioning",
            "media type versioning"
        ]
    },
    {
        "q": "Match versioning strategies:",
        "type": "match",
        "left": [
            "/v1/users",
            "Accept: v2",
            "?version=1",
            "application/vnd.api.v1"
        ],
        "right": [
            "URL path",
            "Header",
            "Query param",
            "Media type"
        ]
    },
    {
        "q": "Rearrange version management:",
        "type": "rearrange",
        "words": [
            "Plan changes",
            "Create new version",
            "Migrate clients",
            "Deprecate old version",
            "Remove old version"
        ]
    },
    {
        "q": "What is hypermedia?",
        "type": "mcq",
        "o": [
            "Including links in API responses",
            "Rich media content",
            "Video streaming",
            "File uploads"
        ]
    },
    {
        "q": "HATEOAS includes links for navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ field contains related links.",
        "type": "fill_blank",
        "answers": [
            "_links"
        ],
        "other_options": [
            "links",
            "refs",
            "related"
        ]
    },
    {
        "q": "Match hypermedia elements:",
        "type": "match",
        "left": [
            "self",
            "next",
            "prev",
            "related"
        ],
        "right": [
            "Current resource",
            "Next page",
            "Previous page",
            "Related resources"
        ]
    },
    {
        "q": "What is idempotency?",
        "type": "mcq",
        "o": [
            "Same request produces same result",
            "Request always succeeds",
            "Request is cached",
            "Request is logged"
        ]
    },
    {
        "q": "GET and PUT are idempotent methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ key ensures idempotent requests.",
        "type": "fill_blank",
        "answers": [
            "Idempotency-Key"
        ],
        "other_options": [
            "Request-Id",
            "Transaction-Id",
            "Unique-Key"
        ]
    },
    {
        "q": "Match method idempotency:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Idempotent",
            "Not idempotent",
            "Idempotent",
            "Idempotent"
        ]
    },
    {
        "q": "Rearrange idempotent handling:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check idempotency key",
            "If duplicate return cached",
            "Process request",
            "Cache result"
        ]
    },
    {
        "q": "What is content negotiation?",
        "type": "mcq",
        "o": [
            "Selecting response format based on client request",
            "Compressing responses",
            "Encrypting data",
            "Validating content"
        ]
    },
    {
        "q": "Accept header specifies preferred response format.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header indicates supported formats.",
        "type": "fill_blank",
        "answers": [
            "Accept"
        ],
        "other_options": [
            "Content-Type",
            "Accept-Encoding",
            "Accept-Language"
        ]
    },
    {
        "q": "Match negotiation types:",
        "type": "match",
        "left": [
            "Accept",
            "Accept-Language",
            "Accept-Encoding",
            "Accept-Charset"
        ],
        "right": [
            "Media type",
            "Language",
            "Compression",
            "Character set"
        ]
    },
    {
        "q": "What is rate limiting?",
        "type": "mcq",
        "o": [
            "Limiting request frequency",
            "Limiting response size",
            "Limiting data types",
            "Limiting users"
        ]
    },
    {
        "q": "Rate limiting protects APIs from abuse.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header shows remaining requests.",
        "type": "fill_blank",
        "answers": [
            "X-RateLimit-Remaining"
        ],
        "other_options": [
            "X-RateLimit-Limit",
            "X-RateLimit-Reset",
            "Retry-After"
        ]
    },
    {
        "q": "Match rate limit headers:",
        "type": "match",
        "left": [
            "X-RateLimit-Limit",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset",
            "Retry-After"
        ],
        "right": [
            "Max requests",
            "Requests left",
            "Reset time",
            "Wait duration"
        ]
    },
    {
        "q": "Rearrange rate limiting:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Check limit",
            "If exceeded reject",
            "Process request",
            "Update counter"
        ]
    },
    {
        "q": "What is caching in API design?",
        "type": "mcq",
        "o": [
            "Storing responses for reuse",
            "Logging requests",
            "Validating data",
            "Compressing data"
        ]
    },
    {
        "q": "Caching improves API performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header controls caching behavior.",
        "type": "fill_blank",
        "answers": [
            "Cache-Control"
        ],
        "other_options": [
            "ETag",
            "Last-Modified",
            "Expires"
        ]
    },
    {
        "q": "Match cache headers:",
        "type": "match",
        "left": [
            "Cache-Control",
            "ETag",
            "Last-Modified",
            "Expires"
        ],
        "right": [
            "Cache directives",
            "Version tag",
            "Change time",
            "Expiry time"
        ]
    },
    {
        "q": "What is authentication in API design?",
        "type": "mcq",
        "o": [
            "Verifying client identity",
            "Encrypting data",
            "Logging access",
            "Validating input"
        ]
    },
    {
        "q": "APIs should require authentication for sensitive data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header carries authentication credentials.",
        "type": "fill_blank",
        "answers": [
            "Authorization"
        ],
        "other_options": [
            "Authentication",
            "X-Auth-Token",
            "Cookie"
        ]
    },
    {
        "q": "Match auth methods:",
        "type": "match",
        "left": [
            "API Key",
            "Bearer Token",
            "Basic Auth",
            "OAuth"
        ],
        "right": [
            "Simple key",
            "JWT or token",
            "Username:password",
            "Delegated access"
        ]
    },
    {
        "q": "Rearrange authentication:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Extract credentials",
            "Validate credentials",
            "Set user context",
            "Process request"
        ]
    },
    {
        "q": "What is authorization?",
        "type": "mcq",
        "o": [
            "Checking user permissions",
            "Verifying identity",
            "Encrypting data",
            "Logging access"
        ]
    },
    {
        "q": "Authorization determines what users can do.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ approach assigns permissions to roles.",
        "type": "fill_blank",
        "answers": [
            "RBAC"
        ],
        "other_options": [
            "ABAC",
            "ACL",
            "MAC"
        ]
    },
    {
        "q": "Match authorization models:",
        "type": "match",
        "left": [
            "RBAC",
            "ABAC",
            "ACL",
            "PBAC"
        ],
        "right": [
            "Role-based",
            "Attribute-based",
            "Access list",
            "Policy-based"
        ]
    },
    {
        "q": "API design should prioritize developer experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design principles:",
        "type": "match",
        "left": [
            "Consistency",
            "Simplicity",
            "Predictability",
            "Flexibility"
        ],
        "right": [
            "Same patterns",
            "Easy to use",
            "Expected behavior",
            "Multiple use cases"
        ]
    },
    {
        "q": "What is resource relationships in API design?",
        "type": "mcq",
        "o": [
            "Connections between different resources",
            "Database tables",
            "Server connections",
            "Client sessions"
        ]
    },
    {
        "q": "Nested resources represent parent-child relationships.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ pattern links related resources.",
        "type": "fill_blank",
        "answers": [
            "sub-resource"
        ],
        "other_options": [
            "reference",
            "join",
            "relation"
        ]
    },
    {
        "q": "Match relationship patterns:",
        "type": "match",
        "left": [
            "/users/1/posts",
            "/posts?userId=1",
            "/posts/1/author",
            "_embedded"
        ],
        "right": [
            "Nested",
            "Query filter",
            "Reverse lookup",
            "Embedded"
        ]
    },
    {
        "q": "Rearrange resource hierarchy:",
        "type": "rearrange",
        "words": [
            "Identify parent resource",
            "Create sub-resource path",
            "Define relationship",
            "Handle nested access"
        ]
    },
    {
        "q": "What is bulk operations?",
        "type": "mcq",
        "o": [
            "Processing multiple items in one request",
            "Large file uploads",
            "Batch logging",
            "Multiple servers"
        ]
    },
    {
        "q": "Bulk operations reduce network round trips.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ endpoint handles batch creates.",
        "type": "fill_blank",
        "answers": [
            "/batch"
        ],
        "other_options": [
            "/bulk",
            "/multi",
            "/many"
        ]
    },
    {
        "q": "Match bulk patterns:",
        "type": "match",
        "left": [
            "POST /users/batch",
            "PATCH /users",
            "DELETE /users?ids=1,2",
            "PUT /users"
        ],
        "right": [
            "Batch create",
            "Bulk update",
            "Bulk delete",
            "Bulk replace"
        ]
    },
    {
        "q": "What is asynchronous processing?",
        "type": "mcq",
        "o": [
            "Processing requests in background",
            "Real-time responses",
            "Synchronous calls",
            "Blocking operations"
        ]
    },
    {
        "q": "Long-running operations should be async.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ status indicates accepted for processing.",
        "type": "fill_blank",
        "answers": [
            "202"
        ],
        "other_options": [
            "200",
            "201",
            "204"
        ]
    },
    {
        "q": "Match async patterns:",
        "type": "match",
        "left": [
            "202 Accepted",
            "Location header",
            "Polling",
            "Webhooks"
        ],
        "right": [
            "Request accepted",
            "Status URL",
            "Check status",
            "Callback notify"
        ]
    },
    {
        "q": "Rearrange async flow:",
        "type": "rearrange",
        "words": [
            "Accept request",
            "Return 202",
            "Process in background",
            "Update status",
            "Notify completion"
        ]
    },
    {
        "q": "What is webhook design?",
        "type": "mcq",
        "o": [
            "Server-to-server event notifications",
            "Client polling",
            "WebSocket connections",
            "Email notifications"
        ]
    },
    {
        "q": "Webhooks push data to subscribers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ endpoint receives webhook events.",
        "type": "fill_blank",
        "answers": [
            "callback URL"
        ],
        "other_options": [
            "webhook URL",
            "event URL",
            "notify URL"
        ]
    },
    {
        "q": "Match webhook components:",
        "type": "match",
        "left": [
            "Event type",
            "Payload",
            "Signature",
            "Retry"
        ],
        "right": [
            "What happened",
            "Event data",
            "Verification",
            "Failed delivery"
        ]
    },
    {
        "q": "What is API gateway?",
        "type": "mcq",
        "o": [
            "Entry point for API requests",
            "Database server",
            "File storage",
            "Message queue"
        ]
    },
    {
        "q": "API gateways handle cross-cutting concerns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ layer provides rate limiting.",
        "type": "fill_blank",
        "answers": [
            "gateway"
        ],
        "other_options": [
            "proxy",
            "load balancer",
            "firewall"
        ]
    },
    {
        "q": "Match gateway features:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Authentication",
            "Load balancing",
            "Caching"
        ],
        "right": [
            "Request throttling",
            "Identity check",
            "Request distribution",
            "Response storage"
        ]
    },
    {
        "q": "Rearrange gateway processing:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Authenticate",
            "Rate limit check",
            "Route to service",
            "Return response"
        ]
    },
    {
        "q": "What is API composition?",
        "type": "mcq",
        "o": [
            "Combining multiple API calls into one",
            "API documentation",
            "API testing",
            "API versioning"
        ]
    },
    {
        "q": "Composition reduces client complexity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ pattern aggregates multiple services.",
        "type": "fill_blank",
        "answers": [
            "BFF"
        ],
        "other_options": [
            "API",
            "gateway",
            "proxy"
        ]
    },
    {
        "q": "Match composition patterns:",
        "type": "match",
        "left": [
            "BFF",
            "Aggregator",
            "Chained",
            "Branched"
        ],
        "right": [
            "Backend for Frontend",
            "Single response",
            "Sequential calls",
            "Parallel calls"
        ]
    },
    {
        "q": "What is API mocking?",
        "type": "mcq",
        "o": [
            "Simulating API responses for testing",
            "API documentation",
            "API monitoring",
            "API deployment"
        ]
    },
    {
        "q": "Mocking enables parallel development.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ server returns fake responses.",
        "type": "fill_blank",
        "answers": [
            "mock"
        ],
        "other_options": [
            "test",
            "stub",
            "fake"
        ]
    },
    {
        "q": "Match mocking tools:",
        "type": "match",
        "left": [
            "Postman",
            "WireMock",
            "JSON Server",
            "Mockoon"
        ],
        "right": [
            "Collection mock",
            "Java mock",
            "Static JSON",
            "Desktop mock"
        ]
    },
    {
        "q": "Rearrange mock workflow:",
        "type": "rearrange",
        "words": [
            "Define contract",
            "Create mock responses",
            "Configure mock server",
            "Test against mock"
        ]
    },
    {
        "q": "What is contract testing?",
        "type": "mcq",
        "o": [
            "Verifying API adheres to contract",
            "Unit testing",
            "Load testing",
            "Security testing"
        ]
    },
    {
        "q": "Contract tests prevent breaking changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tool enables consumer-driven contracts.",
        "type": "fill_blank",
        "answers": [
            "Pact"
        ],
        "other_options": [
            "Postman",
            "REST Assured",
            "SoapUI"
        ]
    },
    {
        "q": "Match contract types:",
        "type": "match",
        "left": [
            "Consumer-driven",
            "Provider-driven",
            "Schema-based",
            "Example-based"
        ],
        "right": [
            "Client defines",
            "Server defines",
            "From OpenAPI",
            "From samples"
        ]
    },
    {
        "q": "What is API design first?",
        "type": "mcq",
        "o": [
            "Designing API before implementation",
            "Code first development",
            "Testing first",
            "Documentation first"
        ]
    },
    {
        "q": "Design first promotes consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ approach creates contract before code.",
        "type": "fill_blank",
        "answers": [
            "API first"
        ],
        "other_options": [
            "code first",
            "test first",
            "doc first"
        ]
    },
    {
        "q": "Match design approaches:",
        "type": "match",
        "left": [
            "API first",
            "Code first",
            "Hybrid",
            "Schema first"
        ],
        "right": [
            "Contract then code",
            "Code then doc",
            "Both approaches",
            "Schema drives all"
        ]
    },
    {
        "q": "Rearrange API first workflow:",
        "type": "rearrange",
        "words": [
            "Define requirements",
            "Design API contract",
            "Review with stakeholders",
            "Generate code stubs",
            "Implement logic"
        ]
    },
    {
        "q": "What is input validation?",
        "type": "mcq",
        "o": [
            "Checking request data before processing",
            "Output formatting",
            "Error handling",
            "Authentication"
        ]
    },
    {
        "q": "Validation prevents invalid data processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ error indicates validation failure.",
        "type": "fill_blank",
        "answers": [
            "400"
        ],
        "other_options": [
            "401",
            "404",
            "500"
        ]
    },
    {
        "q": "Match validation types:",
        "type": "match",
        "left": [
            "Type",
            "Format",
            "Range",
            "Required"
        ],
        "right": [
            "Data type check",
            "Pattern match",
            "Value bounds",
            "Presence check"
        ]
    },
    {
        "q": "What is output formatting?",
        "type": "mcq",
        "o": [
            "Structuring response data",
            "Input validation",
            "Error handling",
            "Authentication"
        ]
    },
    {
        "q": "Formatted responses improve client parsing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ format wraps successful responses.",
        "type": "fill_blank",
        "answers": [
            "envelope"
        ],
        "other_options": [
            "wrapper",
            "container",
            "package"
        ]
    },
    {
        "q": "Match response patterns:",
        "type": "match",
        "left": [
            "Envelope",
            "Flat",
            "Wrapped error",
            "Pagination"
        ],
        "right": [
            "data/meta/links",
            "Direct data",
            "error object",
            "paged results"
        ]
    },
    {
        "q": "Rearrange response building:",
        "type": "rearrange",
        "words": [
            "Execute query",
            "Format data",
            "Add metadata",
            "Set headers",
            "Return response"
        ]
    },
    {
        "q": "What is deprecation handling?",
        "type": "mcq",
        "o": [
            "Managing removal of old features",
            "Adding new features",
            "Bug fixing",
            "Performance tuning"
        ]
    },
    {
        "q": "Deprecated endpoints should warn clients.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header indicates deprecation.",
        "type": "fill_blank",
        "answers": [
            "Deprecation"
        ],
        "other_options": [
            "Warning",
            "X-Deprecated",
            "Sunset"
        ]
    },
    {
        "q": "Match deprecation headers:",
        "type": "match",
        "left": [
            "Deprecation",
            "Sunset",
            "Link",
            "Warning"
        ],
        "right": [
            "Marked deprecated",
            "Removal date",
            "Replacement URL",
            "Alert message"
        ]
    },
    {
        "q": "What is API consistency?",
        "type": "mcq",
        "o": [
            "Using same patterns throughout API",
            "High availability",
            "Fast responses",
            "Secure connections"
        ]
    },
    {
        "q": "Consistency reduces learning curve.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ provides consistency rules.",
        "type": "fill_blank",
        "answers": [
            "style guide"
        ],
        "other_options": [
            "documentation",
            "tests",
            "reviews"
        ]
    },
    {
        "q": "Match consistency areas:",
        "type": "match",
        "left": [
            "Naming",
            "Error format",
            "Pagination",
            "Authentication"
        ],
        "right": [
            "Conventions",
            "Error structure",
            "Page patterns",
            "Auth methods"
        ]
    },
    {
        "q": "Rearrange style guide creation:",
        "type": "rearrange",
        "words": [
            "Document conventions",
            "Define patterns",
            "Create examples",
            "Review with team",
            "Enforce in CI"
        ]
    },
    {
        "q": "What is request tracing?",
        "type": "mcq",
        "o": [
            "Tracking request across services",
            "Logging errors",
            "Monitoring performance",
            "Authentication"
        ]
    },
    {
        "q": "Tracing helps debug distributed systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header carries trace ID.",
        "type": "fill_blank",
        "answers": [
            "X-Request-ID"
        ],
        "other_options": [
            "X-Trace-Id",
            "Trace-ID",
            "Request-Id"
        ]
    },
    {
        "q": "Match tracing concepts:",
        "type": "match",
        "left": [
            "Trace ID",
            "Span",
            "Parent span",
            "Baggage"
        ],
        "right": [
            "Overall request",
            "Single operation",
            "Calling operation",
            "Context data"
        ]
    },
    {
        "q": "What is API SDK design?",
        "type": "mcq",
        "o": [
            "Creating client libraries for the API",
            "API documentation",
            "API testing",
            "API security"
        ]
    },
    {
        "q": "SDKs simplify API integration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ pattern wraps API calls.",
        "type": "fill_blank",
        "answers": [
            "client"
        ],
        "other_options": [
            "wrapper",
            "sdk",
            "library"
        ]
    },
    {
        "q": "Match SDK features:",
        "type": "match",
        "left": [
            "Auth handling",
            "Error mapping",
            "Retry logic",
            "Type safety"
        ],
        "right": [
            "Token management",
            "Exception types",
            "Automatic retries",
            "Typed responses"
        ]
    },
    {
        "q": "Rearrange SDK call:",
        "type": "rearrange",
        "words": [
            "Create client",
            "Set credentials",
            "Make request",
            "Handle response",
            "Return typed data"
        ]
    },
    {
        "q": "What is resource expansion?",
        "type": "mcq",
        "o": [
            "Including related resources in response",
            "Filtering results",
            "Paginating results",
            "Sorting results"
        ]
    },
    {
        "q": "Expansion reduces additional API calls.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ parameter includes related data.",
        "type": "fill_blank",
        "answers": [
            "expand"
        ],
        "other_options": [
            "include",
            "embed",
            "join"
        ]
    },
    {
        "q": "Match expansion patterns:",
        "type": "match",
        "left": [
            "expand=profile",
            "include=posts",
            "embed=author",
            "fields[user]"
        ],
        "right": [
            "Expand related",
            "Include type",
            "Embed inline",
            "Sparse fields"
        ]
    },
    {
        "q": "What is data normalization?",
        "type": "mcq",
        "o": [
            "Avoiding data duplication in responses",
            "Data compression",
            "Data encryption",
            "Data validation"
        ]
    },
    {
        "q": "Normalized responses prevent inconsistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ approach references instead of duplicating.",
        "type": "fill_blank",
        "answers": [
            "ID reference"
        ],
        "other_options": [
            "embedding",
            "inlining",
            "copying"
        ]
    },
    {
        "q": "Match normalization strategies:",
        "type": "match",
        "left": [
            "Referenced",
            "Embedded",
            "Hybrid",
            "Denormalized"
        ],
        "right": [
            "ID only",
            "Full object",
            "Mixed",
            "Duplicated"
        ]
    },
    {
        "q": "Rearrange normalization:",
        "type": "rearrange",
        "words": [
            "Identify entities",
            "Assign IDs",
            "Reference by ID",
            "Collect unique entities",
            "Return normalized data"
        ]
    },
    {
        "q": "What is partial updates?",
        "type": "mcq",
        "o": [
            "Updating only specified fields",
            "Full replacement",
            "Delete and create",
            "Batch update"
        ]
    },
    {
        "q": "PATCH is used for partial updates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ method updates partial data.",
        "type": "fill_blank",
        "answers": [
            "PATCH"
        ],
        "other_options": [
            "PUT",
            "POST",
            "UPDATE"
        ]
    },
    {
        "q": "Match update methods:",
        "type": "match",
        "left": [
            "PUT",
            "PATCH",
            "POST",
            "DELETE + POST"
        ],
        "right": [
            "Full replace",
            "Partial update",
            "Create new",
            "Replace via delete"
        ]
    },
    {
        "q": "What is conditional requests?",
        "type": "mcq",
        "o": [
            "Requests depending on resource state",
            "Always execute",
            "Random execution",
            "Delayed execution"
        ]
    },
    {
        "q": "ETags enable conditional updates.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header prevents lost updates.",
        "type": "fill_blank",
        "answers": [
            "If-Match"
        ],
        "other_options": [
            "If-None-Match",
            "ETag",
            "Last-Modified"
        ]
    },
    {
        "q": "Match conditional headers:",
        "type": "match",
        "left": [
            "If-Match",
            "If-None-Match",
            "If-Modified-Since",
            "If-Unmodified-Since"
        ],
        "right": [
            "Update if matches",
            "Get if changed",
            "Get if newer",
            "Update if unchanged"
        ]
    },
    {
        "q": "Rearrange conditional update:",
        "type": "rearrange",
        "words": [
            "Get resource with ETag",
            "Modify data",
            "Send with If-Match",
            "Check ETag match",
            "Update or reject"
        ]
    },
    {
        "q": "What is optimistic concurrency?",
        "type": "mcq",
        "o": [
            "Assuming no conflicts until proven otherwise",
            "Locking resources",
            "Blocking updates",
            "Sequential access"
        ]
    },
    {
        "q": "Optimistic concurrency uses version checking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ field tracks resource version.",
        "type": "fill_blank",
        "answers": [
            "version"
        ],
        "other_options": [
            "etag",
            "revision",
            "timestamp"
        ]
    },
    {
        "q": "Match concurrency patterns:",
        "type": "match",
        "left": [
            "Optimistic",
            "Pessimistic",
            "Last write wins",
            "First write wins"
        ],
        "right": [
            "Check version",
            "Lock resource",
            "No check",
            "Reject duplicates"
        ]
    },
    {
        "q": "What is long polling?",
        "type": "mcq",
        "o": [
            "Holding request until data available",
            "Frequent short requests",
            "WebSocket connection",
            "Server-sent events"
        ]
    },
    {
        "q": "Long polling simulates push notifications.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header sets poll timeout.",
        "type": "fill_blank",
        "answers": [
            "Prefer: wait"
        ],
        "other_options": [
            "Timeout",
            "Wait",
            "Poll"
        ]
    },
    {
        "q": "Match real-time patterns:",
        "type": "match",
        "left": [
            "Polling",
            "Long polling",
            "WebSocket",
            "SSE"
        ],
        "right": [
            "Periodic requests",
            "Held request",
            "Bidirectional",
            "Server push"
        ]
    },
    {
        "q": "Rearrange long polling:",
        "type": "rearrange",
        "words": [
            "Client sends request",
            "Server holds connection",
            "Wait for data or timeout",
            "Return response",
            "Client repeats"
        ]
    },
    {
        "q": "What is server-sent events?",
        "type": "mcq",
        "o": [
            "Server pushing updates to client",
            "Client polling",
            "WebSocket",
            "HTTP POST"
        ]
    },
    {
        "q": "SSE uses HTTP for one-way streaming.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ content type is used for SSE.",
        "type": "fill_blank",
        "answers": [
            "text/event-stream"
        ],
        "other_options": [
            "application/stream",
            "text/stream",
            "event/stream"
        ]
    },
    {
        "q": "Match SSE features:",
        "type": "match",
        "left": [
            "data:",
            "event:",
            "id:",
            "retry:"
        ],
        "right": [
            "Message content",
            "Event name",
            "Event ID",
            "Reconnect delay"
        ]
    },
    {
        "q": "What is file upload design?",
        "type": "mcq",
        "o": [
            "Handling binary data upload",
            "Text data only",
            "JSON only",
            "XML only"
        ]
    },
    {
        "q": "Multipart form data supports file uploads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ type handles file uploads.",
        "type": "fill_blank",
        "answers": [
            "multipart/form-data"
        ],
        "other_options": [
            "application/octet-stream",
            "application/binary",
            "file/upload"
        ]
    },
    {
        "q": "Match upload patterns:",
        "type": "match",
        "left": [
            "Direct upload",
            "Pre-signed URL",
            "Chunked",
            "Base64"
        ],
        "right": [
            "To API",
            "To storage",
            "In parts",
            "Encoded body"
        ]
    },
    {
        "q": "Rearrange upload flow:",
        "type": "rearrange",
        "words": [
            "Request upload URL",
            "Upload to storage",
            "Create metadata",
            "Return resource"
        ]
    },
    {
        "q": "What is search API design?",
        "type": "mcq",
        "o": [
            "Endpoints for finding resources",
            "CRUD operations",
            "Auth endpoints",
            "Admin endpoints"
        ]
    },
    {
        "q": "Search should support multiple criteria.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ parameter contains search query.",
        "type": "fill_blank",
        "answers": [
            "q"
        ],
        "other_options": [
            "search",
            "query",
            "find"
        ]
    },
    {
        "q": "Match search features:",
        "type": "match",
        "left": [
            "Full text",
            "Facets",
            "Highlighting",
            "Suggestions"
        ],
        "right": [
            "Text search",
            "Categories",
            "Match marking",
            "Autocomplete"
        ]
    },
    {
        "q": "What is API introspection?",
        "type": "mcq",
        "o": [
            "API describing itself",
            "External documentation",
            "Manual inspection",
            "Code review"
        ]
    },
    {
        "q": "OpenAPI provides machine-readable descriptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ endpoint returns API description.",
        "type": "fill_blank",
        "answers": [
            "/openapi.json"
        ],
        "other_options": [
            "/swagger.json",
            "/api-docs",
            "/spec"
        ]
    },
    {
        "q": "Match introspection endpoints:",
        "type": "match",
        "left": [
            "/openapi.json",
            "/graphql",
            "/.well-known",
            "/api"
        ],
        "right": [
            "OpenAPI spec",
            "GraphQL introspection",
            "Discovery",
            "API root"
        ]
    },
    {
        "q": "Rearrange API discovery:",
        "type": "rearrange",
        "words": [
            "Fetch root endpoint",
            "Find links",
            "Get spec",
            "Parse endpoints",
            "Build client"
        ]
    },
    {
        "q": "What is response compression?",
        "type": "mcq",
        "o": [
            "Reducing response size for transfer",
            "Data encryption",
            "Data validation",
            "Error handling"
        ]
    },
    {
        "q": "Compression reduces bandwidth usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header requests compression.",
        "type": "fill_blank",
        "answers": [
            "Accept-Encoding"
        ],
        "other_options": [
            "Content-Encoding",
            "Compress",
            "Encoding"
        ]
    },
    {
        "q": "Match compression types:",
        "type": "match",
        "left": [
            "gzip",
            "deflate",
            "br",
            "identity"
        ],
        "right": [
            "GNU zip",
            "Zlib",
            "Brotli",
            "No compression"
        ]
    },
    {
        "q": "What is resource locking?",
        "type": "mcq",
        "o": [
            "Preventing concurrent modifications",
            "Access control",
            "Encryption",
            "Caching"
        ]
    },
    {
        "q": "Locking prevents data corruption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ pattern reserves resources.",
        "type": "fill_blank",
        "answers": [
            "lock"
        ],
        "other_options": [
            "reserve",
            "hold",
            "block"
        ]
    },
    {
        "q": "Match locking types:",
        "type": "match",
        "left": [
            "Exclusive",
            "Shared",
            "Advisory",
            "Mandatory"
        ],
        "right": [
            "Only one writer",
            "Multiple readers",
            "Optional hint",
            "Enforced lock"
        ]
    },
    {
        "q": "Rearrange lock workflow:",
        "type": "rearrange",
        "words": [
            "Acquire lock",
            "Set timeout",
            "Perform operation",
            "Release lock"
        ]
    },
    {
        "q": "What is API analytics?",
        "type": "mcq",
        "o": [
            "Collecting usage data",
            "API documentation",
            "API testing",
            "API security"
        ]
    },
    {
        "q": "Analytics help understand API usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tracks API calls.",
        "type": "fill_blank",
        "answers": [
            "metrics"
        ],
        "other_options": [
            "logs",
            "traces",
            "events"
        ]
    },
    {
        "q": "Match analytics types:",
        "type": "match",
        "left": [
            "Request count",
            "Latency",
            "Error rate",
            "Unique users"
        ],
        "right": [
            "Volume",
            "Speed",
            "Failures",
            "Adoption"
        ]
    },
    {
        "q": "What is API monitoring?",
        "type": "mcq",
        "o": [
            "Tracking API health and performance",
            "API documentation",
            "API design",
            "API versioning"
        ]
    },
    {
        "q": "Monitoring detects issues early.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ endpoint reports health.",
        "type": "fill_blank",
        "answers": [
            "/health"
        ],
        "other_options": [
            "/status",
            "/ping",
            "/check"
        ]
    },
    {
        "q": "Match monitoring aspects:",
        "type": "match",
        "left": [
            "Availability",
            "Latency",
            "Throughput",
            "Errors"
        ],
        "right": [
            "Uptime",
            "Response time",
            "Requests/sec",
            "Failure rate"
        ]
    },
    {
        "q": "Rearrange monitoring setup:",
        "type": "rearrange",
        "words": [
            "Define metrics",
            "Set thresholds",
            "Create alerts",
            "Build dashboards",
            "Review regularly"
        ]
    },
    {
        "q": "What is API throttling?",
        "type": "mcq",
        "o": [
            "Slowing down excessive requests",
            "Blocking requests",
            "Speeding up requests",
            "Caching requests"
        ]
    },
    {
        "q": "Throttling protects backend services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ response indicates throttling.",
        "type": "fill_blank",
        "answers": [
            "429"
        ],
        "other_options": [
            "503",
            "500",
            "403"
        ]
    },
    {
        "q": "Match throttling strategies:",
        "type": "match",
        "left": [
            "Token bucket",
            "Leaky bucket",
            "Fixed window",
            "Sliding window"
        ],
        "right": [
            "Burst allowed",
            "Steady rate",
            "Time periods",
            "Rolling window"
        ]
    },
    {
        "q": "What is quota management?",
        "type": "mcq",
        "o": [
            "Limiting total API usage",
            "Rate limiting",
            "Authentication",
            "Authorization"
        ]
    },
    {
        "q": "Quotas limit usage per billing period.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tracks usage against quota.",
        "type": "fill_blank",
        "answers": [
            "counter"
        ],
        "other_options": [
            "meter",
            "gauge",
            "tracker"
        ]
    },
    {
        "q": "Match quota types:",
        "type": "match",
        "left": [
            "Daily",
            "Monthly",
            "Per-user",
            "Per-app"
        ],
        "right": [
            "24 hours",
            "Calendar month",
            "User limit",
            "Application limit"
        ]
    },
    {
        "q": "Rearrange quota check:",
        "type": "rearrange",
        "words": [
            "Identify client",
            "Get current usage",
            "Check against limit",
            "Allow or reject",
            "Update usage"
        ]
    },
    {
        "q": "What is API tiering?",
        "type": "mcq",
        "o": [
            "Different service levels for clients",
            "API versioning",
            "API grouping",
            "API routing"
        ]
    },
    {
        "q": "Tiers enable different feature sets.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tier offers unlimited access.",
        "type": "fill_blank",
        "answers": [
            "enterprise"
        ],
        "other_options": [
            "free",
            "basic",
            "premium"
        ]
    },
    {
        "q": "Match tier features:",
        "type": "match",
        "left": [
            "Free",
            "Basic",
            "Premium",
            "Enterprise"
        ],
        "right": [
            "Limited features",
            "Standard access",
            "Priority support",
            "Custom limits"
        ]
    },
    {
        "q": "What is API documentation generation?",
        "type": "mcq",
        "o": [
            "Creating docs from code or spec",
            "Manual writing",
            "Video tutorials",
            "Blog posts"
        ]
    },
    {
        "q": "Generated docs stay in sync with code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tool generates interactive docs.",
        "type": "fill_blank",
        "answers": [
            "Swagger UI"
        ],
        "other_options": [
            "Postman",
            "Redoc",
            "Stoplight"
        ]
    },
    {
        "q": "Match doc generators:",
        "type": "match",
        "left": [
            "Swagger UI",
            "Redoc",
            "Stoplight",
            "ReadMe"
        ],
        "right": [
            "Interactive try",
            "Reference docs",
            "Design platform",
            "Developer hub"
        ]
    },
    {
        "q": "Rearrange doc generation:",
        "type": "rearrange",
        "words": [
            "Write OpenAPI spec",
            "Validate spec",
            "Generate HTML",
            "Deploy docs",
            "Keep in sync"
        ]
    },
    {
        "q": "What is API testing strategies?",
        "type": "mcq",
        "o": [
            "Methods to verify API correctness",
            "Documentation",
            "Deployment",
            "Monitoring"
        ]
    },
    {
        "q": "Testing should cover happy and error paths.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ tests verify individual endpoints.",
        "type": "fill_blank",
        "answers": [
            "unit"
        ],
        "other_options": [
            "integration",
            "e2e",
            "load"
        ]
    },
    {
        "q": "Match test types:",
        "type": "match",
        "left": [
            "Unit",
            "Integration",
            "Contract",
            "E2E"
        ],
        "right": [
            "Single endpoint",
            "Multiple services",
            "API agreement",
            "Full flow"
        ]
    },
    {
        "q": "What is API security headers?",
        "type": "mcq",
        "o": [
            "HTTP headers for security",
            "Body content",
            "URL parameters",
            "Cookie settings"
        ]
    },
    {
        "q": "Security headers prevent common attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header prevents clickjacking.",
        "type": "fill_blank",
        "answers": [
            "X-Frame-Options"
        ],
        "other_options": [
            "X-XSS-Protection",
            "X-Content-Type-Options",
            "CSP"
        ]
    },
    {
        "q": "Match security headers:",
        "type": "match",
        "left": [
            "CSP",
            "HSTS",
            "X-Frame-Options",
            "X-Content-Type-Options"
        ],
        "right": [
            "Content policy",
            "Force HTTPS",
            "Frame control",
            "MIME sniffing"
        ]
    },
    {
        "q": "Rearrange security setup:",
        "type": "rearrange",
        "words": [
            "Identify threats",
            "Choose headers",
            "Configure server",
            "Test headers",
            "Monitor violations"
        ]
    },
    {
        "q": "What is CORS in API design?",
        "type": "mcq",
        "o": [
            "Allowing cross-origin requests",
            "Blocking requests",
            "Caching responses",
            "Rate limiting"
        ]
    },
    {
        "q": "CORS enables browser access to APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ header specifies allowed origins.",
        "type": "fill_blank",
        "answers": [
            "Access-Control-Allow-Origin"
        ],
        "other_options": [
            "Origin",
            "Allow-Origin",
            "CORS-Origin"
        ]
    },
    {
        "q": "Match CORS headers:",
        "type": "match",
        "left": [
            "Allow-Origin",
            "Allow-Methods",
            "Allow-Headers",
            "Allow-Credentials"
        ],
        "right": [
            "Permitted origins",
            "Permitted methods",
            "Permitted headers",
            "Include cookies"
        ]
    },
    {
        "q": "API design requires balancing usability and security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design trade-offs:",
        "type": "match",
        "left": [
            "Simplicity vs Features",
            "Security vs Usability",
            "Flexibility vs Consistency",
            "Performance vs Accuracy"
        ],
        "right": [
            "Less vs more options",
            "Protection vs ease",
            "Adaptable vs predictable",
            "Speed vs correctness"
        ]
    },
    {
        "q": "What is the output of this middleware chain?",
        "type": "mcq",
        "c": "app.use(authenticate);\napp.use(rateLimit);\napp.use(validate);\napp.use(handler);",
        "o": [
            "Auth -> Rate limit -> Validate -> Handle",
            "Handle first",
            "Parallel execution",
            "Random order"
        ]
    },
    {
        "q": "Which approach handles circuit breaker pattern?",
        "type": "mcq",
        "o": [
            "Stop calling failing services temporarily",
            "Keep retrying",
            "Ignore failures",
            "No pattern"
        ]
    },
    {
        "q": "The ______ state prevents requests to failing service.",
        "type": "fill_blank",
        "answers": [
            "open"
        ],
        "other_options": [
            "closed",
            "half-open",
            "disabled"
        ]
    },
    {
        "q": "Match circuit breaker states:",
        "type": "match",
        "left": [
            "Closed",
            "Open",
            "Half-open",
            "Disabled"
        ],
        "right": [
            "Normal",
            "Blocking",
            "Testing",
            "Off"
        ]
    },
    {
        "q": "Rearrange circuit breaker flow:",
        "type": "rearrange",
        "words": [
            "Normal operation",
            "Failures exceed threshold",
            "Open circuit",
            "Wait timeout",
            "Test with half-open",
            "Close if success"
        ]
    },
    {
        "q": "Which approach handles retry with backoff?",
        "type": "mcq",
        "o": [
            "Increase wait time between retries",
            "Immediate retries",
            "Fixed delay",
            "No retries"
        ]
    },
    {
        "q": "The ______ backoff doubles delay each retry.",
        "type": "fill_blank",
        "answers": [
            "exponential"
        ],
        "other_options": [
            "linear",
            "fixed",
            "random"
        ]
    },
    {
        "q": "Exponential backoff prevents cascading failures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match backoff strategies:",
        "type": "match",
        "left": [
            "Fixed",
            "Linear",
            "Exponential",
            "Jitter"
        ],
        "right": [
            "Same delay",
            "Increasing",
            "Doubling",
            "Random variation"
        ]
    },
    {
        "q": "Which approach handles bulkhead pattern?",
        "type": "mcq",
        "o": [
            "Isolate resources to prevent cascade failures",
            "Share all resources",
            "Single pool",
            "No isolation"
        ]
    },
    {
        "q": "The ______ pattern limits concurrent requests per service.",
        "type": "fill_blank",
        "answers": [
            "bulkhead"
        ],
        "other_options": [
            "throttle",
            "limit",
            "pool"
        ]
    },
    {
        "q": "Bulkheads prevent one service from consuming all resources.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match resilience patterns:",
        "type": "match",
        "left": [
            "Circuit breaker",
            "Bulkhead",
            "Timeout",
            "Fallback"
        ],
        "right": [
            "Stop calling",
            "Isolate resources",
            "Limit wait",
            "Alternative response"
        ]
    },
    {
        "q": "Rearrange bulkhead implementation:",
        "type": "rearrange",
        "words": [
            "Define resource pools",
            "Assign per service",
            "Limit pool size",
            "Isolate failures"
        ]
    },
    {
        "q": "Which approach handles graceful degradation?",
        "type": "mcq",
        "o": [
            "Provide reduced functionality when components fail",
            "Full failure",
            "No degradation",
            "Error pages only"
        ]
    },
    {
        "q": "The ______ provides alternative when primary fails.",
        "type": "fill_blank",
        "answers": [
            "fallback"
        ],
        "other_options": [
            "backup",
            "alternative",
            "secondary"
        ]
    },
    {
        "q": "Graceful degradation maintains partial service.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match degradation strategies:",
        "type": "match",
        "left": [
            "Cached data",
            "Default values",
            "Feature flags",
            "Static pages"
        ],
        "right": [
            "Stale but available",
            "Placeholder",
            "Toggle features",
            "Pre-rendered"
        ]
    },
    {
        "q": "Which approach handles health endpoints?",
        "type": "mcq",
        "o": [
            "Endpoints reporting service status",
            "Business endpoints",
            "Auth endpoints",
            "Admin only"
        ]
    },
    {
        "q": "The ______ endpoint returns detailed component status.",
        "type": "fill_blank",
        "answers": [
            "/health/ready"
        ],
        "other_options": [
            "/health",
            "/status",
            "/ping"
        ]
    },
    {
        "q": "Liveness checks verify process is running.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match health check types:",
        "type": "match",
        "left": [
            "Liveness",
            "Readiness",
            "Startup",
            "Deep health"
        ],
        "right": [
            "Process alive",
            "Ready for traffic",
            "Init complete",
            "Dependencies check"
        ]
    },
    {
        "q": "Rearrange health check:",
        "type": "rearrange",
        "words": [
            "Define checks",
            "Check dependencies",
            "Aggregate status",
            "Return health",
            "Cache result"
        ]
    },
    {
        "q": "Which approach handles distributed tracing?",
        "type": "mcq",
        "o": [
            "Tracking requests across multiple services",
            "Single service logging",
            "Local debugging",
            "No tracing"
        ]
    },
    {
        "q": "The ______ standard defines tracing headers.",
        "type": "fill_blank",
        "answers": [
            "W3C Trace Context"
        ],
        "other_options": [
            "OpenTracing",
            "Zipkin",
            "Jaeger"
        ]
    },
    {
        "q": "Spans represent individual operations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match tracing concepts:",
        "type": "match",
        "left": [
            "Trace",
            "Span",
            "Baggage",
            "Sampler"
        ],
        "right": [
            "Full request",
            "Single operation",
            "Context data",
            "Trace selection"
        ]
    },
    {
        "q": "Which approach handles structured logging?",
        "type": "mcq",
        "o": [
            "JSON or key-value formatted logs",
            "Plain text",
            "No format",
            "Binary logs"
        ]
    },
    {
        "q": "The ______ format enables log parsing.",
        "type": "fill_blank",
        "answers": [
            "JSON"
        ],
        "other_options": [
            "text",
            "XML",
            "binary"
        ]
    },
    {
        "q": "Structured logs improve searchability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match log levels:",
        "type": "match",
        "left": [
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR"
        ],
        "right": [
            "Development",
            "Normal ops",
            "Potential issue",
            "Failure"
        ]
    },
    {
        "q": "Rearrange log processing:",
        "type": "rearrange",
        "words": [
            "Generate log",
            "Structure as JSON",
            "Add context",
            "Ship to aggregator",
            "Index and search"
        ]
    },
    {
        "q": "Which approach handles API metrics?",
        "type": "mcq",
        "o": [
            "Collecting numerical data about API behavior",
            "Logging only",
            "Tracing only",
            "No metrics"
        ]
    },
    {
        "q": "The ______ metric type counts occurrences.",
        "type": "fill_blank",
        "answers": [
            "counter"
        ],
        "other_options": [
            "gauge",
            "histogram",
            "summary"
        ]
    },
    {
        "q": "Histograms track request duration distribution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match metric types:",
        "type": "match",
        "left": [
            "Counter",
            "Gauge",
            "Histogram",
            "Summary"
        ],
        "right": [
            "Cumulative",
            "Current value",
            "Buckets",
            "Percentiles"
        ]
    },
    {
        "q": "Which approach handles SLA monitoring?",
        "type": "mcq",
        "o": [
            "Tracking service level compliance",
            "Feature monitoring",
            "User monitoring",
            "No SLA"
        ]
    },
    {
        "q": "The ______ measures error budget.",
        "type": "fill_blank",
        "answers": [
            "SLO"
        ],
        "other_options": [
            "SLA",
            "SLI",
            "KPI"
        ]
    },
    {
        "q": "SLIs are the actual measurements for SLOs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match SLA terms:",
        "type": "match",
        "left": [
            "SLA",
            "SLO",
            "SLI",
            "Error budget"
        ],
        "right": [
            "Agreement",
            "Objective",
            "Indicator",
            "Allowed failures"
        ]
    },
    {
        "q": "Rearrange SLA setup:",
        "type": "rearrange",
        "words": [
            "Define SLIs",
            "Set SLOs",
            "Create SLA",
            "Monitor metrics",
            "Alert on breach"
        ]
    },
    {
        "q": "Which approach handles canary deployments?",
        "type": "mcq",
        "o": [
            "Gradually rolling out changes to subset",
            "All at once",
            "Manual rollout",
            "No gradual"
        ]
    },
    {
        "q": "The ______ receives traffic first.",
        "type": "fill_blank",
        "answers": [
            "canary"
        ],
        "other_options": [
            "primary",
            "baseline",
            "control"
        ]
    },
    {
        "q": "Canary deployments reduce deployment risk.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match deployment strategies:",
        "type": "match",
        "left": [
            "Canary",
            "Blue-green",
            "Rolling",
            "Shadow"
        ],
        "right": [
            "Subset first",
            "Two environments",
            "Gradual replace",
            "Mirror traffic"
        ]
    },
    {
        "q": "Which approach handles feature flags?",
        "type": "mcq",
        "o": [
            "Toggle features without deployment",
            "Code changes only",
            "Config files",
            "No toggles"
        ]
    },
    {
        "q": "The ______ pattern enables runtime feature control.",
        "type": "fill_blank",
        "answers": [
            "feature flag"
        ],
        "other_options": [
            "config",
            "toggle",
            "switch"
        ]
    },
    {
        "q": "Feature flags enable progressive rollouts.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match flag types:",
        "type": "match",
        "left": [
            "Release",
            "Experiment",
            "Ops",
            "Permission"
        ],
        "right": [
            "New features",
            "A/B testing",
            "Kill switch",
            "User access"
        ]
    },
    {
        "q": "Rearrange feature flag lifecycle:",
        "type": "rearrange",
        "words": [
            "Create flag",
            "Test in dev",
            "Roll out gradually",
            "Monitor metrics",
            "Remove flag"
        ]
    },
    {
        "q": "Which approach handles API orchestration?",
        "type": "mcq",
        "o": [
            "Coordinating multiple service calls",
            "Single service",
            "Client orchestration",
            "No coordination"
        ]
    },
    {
        "q": "The ______ coordinates complex workflows.",
        "type": "fill_blank",
        "answers": [
            "orchestrator"
        ],
        "other_options": [
            "choreographer",
            "coordinator",
            "manager"
        ]
    },
    {
        "q": "Orchestration centralizes workflow logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match coordination patterns:",
        "type": "match",
        "left": [
            "Orchestration",
            "Choreography",
            "Saga",
            "Event-driven"
        ],
        "right": [
            "Central control",
            "Decentralized",
            "Compensating",
            "Reactive"
        ]
    },
    {
        "q": "Which approach handles saga pattern?",
        "type": "mcq",
        "o": [
            "Managing distributed transactions via compensations",
            "Single transaction",
            "No transactions",
            "Two-phase commit"
        ]
    },
    {
        "q": "The ______ action reverses failed steps.",
        "type": "fill_blank",
        "answers": [
            "compensating"
        ],
        "other_options": [
            "rollback",
            "undo",
            "reverse"
        ]
    },
    {
        "q": "Sagas ensure eventual consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match saga types:",
        "type": "match",
        "left": [
            "Orchestrated",
            "Choreographed",
            "Forward",
            "Backward"
        ],
        "right": [
            "Central saga",
            "Event saga",
            "Execute steps",
            "Compensate steps"
        ]
    },
    {
        "q": "Rearrange saga execution:",
        "type": "rearrange",
        "words": [
            "Start transaction",
            "Execute step",
            "If failure compensate",
            "Continue or rollback",
            "Complete transaction"
        ]
    },
    {
        "q": "Which approach handles event sourcing?",
        "type": "mcq",
        "o": [
            "Storing state as sequence of events",
            "Current state only",
            "Last update",
            "No history"
        ]
    },
    {
        "q": "The ______ stores all state changes.",
        "type": "fill_blank",
        "answers": [
            "event store"
        ],
        "other_options": [
            "database",
            "log",
            "queue"
        ]
    },
    {
        "q": "Event sourcing enables state reconstruction.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match event sourcing concepts:",
        "type": "match",
        "left": [
            "Event",
            "Aggregate",
            "Projection",
            "Snapshot"
        ],
        "right": [
            "State change",
            "Entity group",
            "Read model",
            "State checkpoint"
        ]
    },
    {
        "q": "Which approach handles CQRS pattern?",
        "type": "mcq",
        "o": [
            "Separate read and write models",
            "Single model",
            "Same queries",
            "No separation"
        ]
    },
    {
        "q": "The ______ model handles queries.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "query",
            "select",
            "view"
        ]
    },
    {
        "q": "CQRS optimizes for different access patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match CQRS components:",
        "type": "match",
        "left": [
            "Command",
            "Query",
            "Event",
            "Projection"
        ],
        "right": [
            "Write action",
            "Read action",
            "State change",
            "Read model update"
        ]
    },
    {
        "q": "Rearrange CQRS flow:",
        "type": "rearrange",
        "words": [
            "Receive command",
            "Process command",
            "Emit event",
            "Update read model",
            "Handle query"
        ]
    },
    {
        "q": "Which approach handles API backward compatibility?",
        "type": "mcq",
        "o": [
            "New version works with old clients",
            "Breaking changes",
            "No compatibility",
            "Always new clients"
        ]
    },
    {
        "q": "The ______ change removes existing functionality.",
        "type": "fill_blank",
        "answers": [
            "breaking"
        ],
        "other_options": [
            "additive",
            "compatible",
            "minor"
        ]
    },
    {
        "q": "Adding optional fields is backward compatible.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match change types:",
        "type": "match",
        "left": [
            "Add field",
            "Remove field",
            "Change type",
            "Rename field"
        ],
        "right": [
            "Compatible",
            "Breaking",
            "Breaking",
            "Breaking"
        ]
    },
    {
        "q": "Which approach handles semantic versioning?",
        "type": "mcq",
        "o": [
            "MAJOR.MINOR.PATCH version format",
            "Date-based",
            "Build numbers",
            "Random versions"
        ]
    },
    {
        "q": "The ______ version indicates breaking changes.",
        "type": "fill_blank",
        "answers": [
            "major"
        ],
        "other_options": [
            "minor",
            "patch",
            "build"
        ]
    },
    {
        "q": "Minor version adds backward-compatible features.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match semver parts:",
        "type": "match",
        "left": [
            "Major",
            "Minor",
            "Patch",
            "Pre-release"
        ],
        "right": [
            "Breaking",
            "Features",
            "Fixes",
            "Testing"
        ]
    },
    {
        "q": "Rearrange version bump:",
        "type": "rearrange",
        "words": [
            "Check changes",
            "Determine type",
            "Update version",
            "Update changelog",
            "Tag release"
        ]
    },
    {
        "q": "Which approach handles API pricing models?",
        "type": "mcq",
        "o": [
            "Different tiers and usage-based billing",
            "Free only",
            "Flat rate",
            "No monetization"
        ]
    },
    {
        "q": "The ______ model charges per request.",
        "type": "fill_blank",
        "answers": [
            "pay-per-use"
        ],
        "other_options": [
            "subscription",
            "freemium",
            "tiered"
        ]
    },
    {
        "q": "Usage tracking enables consumption billing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match pricing models:",
        "type": "match",
        "left": [
            "Freemium",
            "Tiered",
            "Pay-per-use",
            "Volume"
        ],
        "right": [
            "Free + paid",
            "Feature levels",
            "Per request",
            "Bulk discount"
        ]
    },
    {
        "q": "Which approach handles API key management?",
        "type": "mcq",
        "o": [
            "Generating and managing access keys",
            "No management",
            "Manual keys",
            "Shared keys"
        ]
    },
    {
        "q": "The ______ enables key rotation.",
        "type": "fill_blank",
        "answers": [
            "key management"
        ],
        "other_options": [
            "key service",
            "auth service",
            "token service"
        ]
    },
    {
        "q": "API keys should be rotated regularly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match key management features:",
        "type": "match",
        "left": [
            "Generation",
            "Rotation",
            "Revocation",
            "Scoping"
        ],
        "right": [
            "Create new",
            "Replace old",
            "Invalidate",
            "Limit access"
        ]
    },
    {
        "q": "Rearrange key lifecycle:",
        "type": "rearrange",
        "words": [
            "Generate key",
            "Assign permissions",
            "Distribute key",
            "Monitor usage",
            "Rotate key"
        ]
    },
    {
        "q": "Which approach handles webhook security?",
        "type": "mcq",
        "o": [
            "Signing payloads for verification",
            "No security",
            "IP filtering only",
            "Plain HTTP"
        ]
    },
    {
        "q": "The ______ header contains webhook signature.",
        "type": "fill_blank",
        "answers": [
            "X-Hub-Signature"
        ],
        "other_options": [
            "X-Signature",
            "Signature",
            "Authorization"
        ]
    },
    {
        "q": "Webhook signatures prevent spoofing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match webhook security:",
        "type": "match",
        "left": [
            "HMAC signature",
            "Timestamp",
            "Secret",
            "Replay protection"
        ],
        "right": [
            "Verify sender",
            "Freshness check",
            "Shared key",
            "Prevent reuse"
        ]
    },
    {
        "q": "Which approach handles idempotency implementation?",
        "type": "mcq",
        "o": [
            "Store and check idempotency keys",
            "No tracking",
            "Always re-execute",
            "Client-side only"
        ]
    },
    {
        "q": "The ______ stores idempotency results.",
        "type": "fill_blank",
        "answers": [
            "cache"
        ],
        "other_options": [
            "database",
            "queue",
            "log"
        ]
    },
    {
        "q": "Idempotency keys should expire after some time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match idempotency implementation:",
        "type": "match",
        "left": [
            "Key storage",
            "TTL",
            "Result caching",
            "Conflict handling"
        ],
        "right": [
            "Store keys",
            "Expiration",
            "Return cached",
            "Handle duplicates"
        ]
    },
    {
        "q": "Rearrange idempotency check:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Extract idempotency key",
            "Check if exists",
            "Return cached or process",
            "Store result"
        ]
    },
    {
        "q": "Which approach handles request coalescing?",
        "type": "mcq",
        "o": [
            "Combine identical concurrent requests",
            "Process all individually",
            "Reject duplicates",
            "No optimization"
        ]
    },
    {
        "q": "The ______ pattern batches similar requests.",
        "type": "fill_blank",
        "answers": [
            "request coalescing"
        ],
        "other_options": [
            "batching",
            "grouping",
            "combining"
        ]
    },
    {
        "q": "Coalescing reduces backend load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match optimization patterns:",
        "type": "match",
        "left": [
            "Coalescing",
            "Batching",
            "Caching",
            "Prefetching"
        ],
        "right": [
            "Same request",
            "Multiple requests",
            "Store result",
            "Load ahead"
        ]
    },
    {
        "q": "Which approach handles request prioritization?",
        "type": "mcq",
        "o": [
            "Process requests based on importance",
            "FIFO only",
            "Random order",
            "No prioritization"
        ]
    },
    {
        "q": "The ______ header indicates request priority.",
        "type": "fill_blank",
        "answers": [
            "Priority"
        ],
        "other_options": [
            "Importance",
            "Weight",
            "Level"
        ]
    },
    {
        "q": "Priority queues handle critical requests first.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match priority levels:",
        "type": "match",
        "left": [
            "Critical",
            "High",
            "Normal",
            "Low"
        ],
        "right": [
            "Immediate",
            "Soon",
            "Standard",
            "Background"
        ]
    },
    {
        "q": "Rearrange priority processing:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Extract priority",
            "Add to queue",
            "Process by priority",
            "Return response"
        ]
    },
    {
        "q": "Which approach handles API load shedding?",
        "type": "mcq",
        "o": [
            "Reject requests during overload",
            "Process all",
            "Queue forever",
            "No shedding"
        ]
    },
    {
        "q": "The ______ pattern drops low-priority requests.",
        "type": "fill_blank",
        "answers": [
            "load shedding"
        ],
        "other_options": [
            "throttling",
            "rate limiting",
            "queuing"
        ]
    },
    {
        "q": "Load shedding prevents system collapse.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match load management:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Throttling",
            "Load shedding",
            "Admission control"
        ],
        "right": [
            "Limit requests",
            "Slow down",
            "Drop requests",
            "Gate entry"
        ]
    },
    {
        "q": "Which approach handles data masking?",
        "type": "mcq",
        "o": [
            "Hide sensitive data in responses",
            "Show all data",
            "No masking",
            "Encryption only"
        ]
    },
    {
        "q": "The ______ pattern hides PII data.",
        "type": "fill_blank",
        "answers": [
            "masking"
        ],
        "other_options": [
            "redacting",
            "hiding",
            "obscuring"
        ]
    },
    {
        "q": "Data masking protects sensitive information.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match masking techniques:",
        "type": "match",
        "left": [
            "Nulling",
            "Substitution",
            "Shuffling",
            "Truncation"
        ],
        "right": [
            "Remove value",
            "Replace value",
            "Rearrange",
            "Partial hide"
        ]
    },
    {
        "q": "Rearrange data protection:",
        "type": "rearrange",
        "words": [
            "Identify sensitive fields",
            "Define masking rules",
            "Apply transformation",
            "Return sanitized data"
        ]
    },
    {
        "q": "Which approach handles audit logging?",
        "type": "mcq",
        "o": [
            "Recording who did what and when",
            "Error logging only",
            "No logging",
            "Debug logs"
        ]
    },
    {
        "q": "The ______ trail provides compliance evidence.",
        "type": "fill_blank",
        "answers": [
            "audit"
        ],
        "other_options": [
            "log",
            "trace",
            "record"
        ]
    },
    {
        "q": "Audit logs should be immutable.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match audit log fields:",
        "type": "match",
        "left": [
            "Actor",
            "Action",
            "Resource",
            "Timestamp"
        ],
        "right": [
            "Who",
            "What",
            "On what",
            "When"
        ]
    },
    {
        "q": "Which approach handles input sanitization?",
        "type": "mcq",
        "o": [
            "Clean input to prevent injection",
            "Accept all input",
            "Validation only",
            "No cleaning"
        ]
    },
    {
        "q": "The ______ removes dangerous characters.",
        "type": "fill_blank",
        "answers": [
            "sanitization"
        ],
        "other_options": [
            "validation",
            "escaping",
            "encoding"
        ]
    },
    {
        "q": "Sanitization prevents injection attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match input handling:",
        "type": "match",
        "left": [
            "Validation",
            "Sanitization",
            "Escaping",
            "Encoding"
        ],
        "right": [
            "Check format",
            "Clean input",
            "Neutralize special",
            "Transform format"
        ]
    },
    {
        "q": "Rearrange input processing:",
        "type": "rearrange",
        "words": [
            "Receive input",
            "Validate format",
            "Sanitize content",
            "Escape for output",
            "Use safely"
        ]
    },
    {
        "q": "Which approach handles content validation?",
        "type": "mcq",
        "o": [
            "Check file type and content match",
            "Trust file extension",
            "No validation",
            "Size only"
        ]
    },
    {
        "q": "The ______ bytes identify file type.",
        "type": "fill_blank",
        "answers": [
            "magic"
        ],
        "other_options": [
            "header",
            "signature",
            "prefix"
        ]
    },
    {
        "q": "MIME type should be validated server-side.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match file validation:",
        "type": "match",
        "left": [
            "Extension",
            "MIME type",
            "Magic bytes",
            "Content scan"
        ],
        "right": [
            "File suffix",
            "Header type",
            "File signature",
            "Virus check"
        ]
    },
    {
        "q": "API design enables building robust and scalable systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API design maturity:",
        "type": "match",
        "left": [
            "Level 0",
            "Level 1",
            "Level 2",
            "Level 3"
        ],
        "right": [
            "Single URL",
            "Resources",
            "HTTP verbs",
            "Hypermedia"
        ]
    },
    {
        "q": "Which approach handles API governance?",
        "type": "mcq",
        "o": [
            "Policies and standards for API management",
            "No governance",
            "Ad-hoc rules",
            "Developer choice"
        ]
    },
    {
        "q": "The ______ ensures API consistency.",
        "type": "fill_blank",
        "answers": [
            "governance"
        ],
        "other_options": [
            "policy",
            "standard",
            "guideline"
        ]
    },
    {
        "q": "Governance improves API quality.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match governance areas:",
        "type": "match",
        "left": [
            "Design",
            "Security",
            "Lifecycle",
            "Documentation"
        ],
        "right": [
            "Standards",
            "Policies",
            "Management",
            "Quality"
        ]
    },
    {
        "q": "Rearrange governance implementation:",
        "type": "rearrange",
        "words": [
            "Define standards",
            "Create guidelines",
            "Implement tooling",
            "Review APIs",
            "Enforce compliance"
        ]
    },
    {
        "q": "Which approach handles API discovery?",
        "type": "mcq",
        "o": [
            "Finding and understanding available APIs",
            "Hidden APIs",
            "Manual search",
            "No discovery"
        ]
    },
    {
        "q": "The ______ portal lists available APIs.",
        "type": "fill_blank",
        "answers": [
            "developer"
        ],
        "other_options": [
            "API",
            "service",
            "catalog"
        ]
    },
    {
        "q": "API catalogs improve discoverability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match discovery features:",
        "type": "match",
        "left": [
            "Catalog",
            "Search",
            "Categories",
            "Examples"
        ],
        "right": [
            "List APIs",
            "Find APIs",
            "Organize APIs",
            "Learn APIs"
        ]
    },
    {
        "q": "Good API design is essential for developer success.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design excellence:",
        "type": "match",
        "left": [
            "Intuitive",
            "Documented",
            "Consistent",
            "Performant"
        ],
        "right": [
            "Easy to understand",
            "Well explained",
            "Predictable",
            "Fast response"
        ]
    },
    {
        "q": "Which approach handles API product management?",
        "type": "mcq",
        "o": [
            "Treating APIs as products with lifecycle",
            "Technical only",
            "No management",
            "Project-based"
        ]
    },
    {
        "q": "The ______ defines API product roadmap.",
        "type": "fill_blank",
        "answers": [
            "product manager"
        ],
        "other_options": [
            "developer",
            "architect",
            "tester"
        ]
    },
    {
        "q": "API products require user-centric design.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API product concepts:",
        "type": "match",
        "left": [
            "Roadmap",
            "Metrics",
            "Feedback",
            "Iteration"
        ],
        "right": [
            "Future plans",
            "Success measures",
            "User input",
            "Continuous improvement"
        ]
    },
    {
        "q": "Rearrange API product lifecycle:",
        "type": "rearrange",
        "words": [
            "Ideation",
            "Design",
            "Build",
            "Launch",
            "Iterate",
            "Sunset"
        ]
    },
    {
        "q": "Which approach handles consumer-driven design?",
        "type": "mcq",
        "o": [
            "Design based on consumer needs",
            "Provider-centric",
            "Technology-first",
            "No consumer input"
        ]
    },
    {
        "q": "The ______ captures consumer requirements.",
        "type": "fill_blank",
        "answers": [
            "contract"
        ],
        "other_options": [
            "schema",
            "spec",
            "doc"
        ]
    },
    {
        "q": "Consumer feedback improves API usability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design approaches:",
        "type": "match",
        "left": [
            "Consumer-driven",
            "Provider-driven",
            "Spec-first",
            "Code-first"
        ],
        "right": [
            "User needs",
            "Server capabilities",
            "Contract first",
            "Implementation first"
        ]
    },
    {
        "q": "Which approach handles API abstraction levels?",
        "type": "mcq",
        "o": [
            "Different layers for different client types",
            "Single level",
            "No abstraction",
            "Direct database"
        ]
    },
    {
        "q": "The ______ API exposes domain operations.",
        "type": "fill_blank",
        "answers": [
            "business"
        ],
        "other_options": [
            "data",
            "system",
            "integration"
        ]
    },
    {
        "q": "Higher abstraction hides implementation details.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API layers:",
        "type": "match",
        "left": [
            "System",
            "Process",
            "Experience",
            "Partner"
        ],
        "right": [
            "Core services",
            "Orchestration",
            "Client-specific",
            "External access"
        ]
    },
    {
        "q": "Rearrange API layer design:",
        "type": "rearrange",
        "words": [
            "Identify capabilities",
            "Define system APIs",
            "Create process APIs",
            "Build experience APIs"
        ]
    },
    {
        "q": "Which approach handles domain-driven API design?",
        "type": "mcq",
        "o": [
            "Model APIs after business domain",
            "Technical model",
            "Database model",
            "No domain"
        ]
    },
    {
        "q": "The ______ language aligns API with business.",
        "type": "fill_blank",
        "answers": [
            "ubiquitous"
        ],
        "other_options": [
            "common",
            "standard",
            "shared"
        ]
    },
    {
        "q": "Bounded contexts define API boundaries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DDD concepts:",
        "type": "match",
        "left": [
            "Entity",
            "Value Object",
            "Aggregate",
            "Domain Event"
        ],
        "right": [
            "Identity",
            "No identity",
            "Consistency boundary",
            "State change"
        ]
    },
    {
        "q": "Which approach handles API evolution strategy?",
        "type": "mcq",
        "o": [
            "Planned approach to changing APIs",
            "Unplanned changes",
            "No evolution",
            "Break on change"
        ]
    },
    {
        "q": "The ______ strategy minimizes breaking changes.",
        "type": "fill_blank",
        "answers": [
            "additive"
        ],
        "other_options": [
            "replace",
            "version",
            "breaking"
        ]
    },
    {
        "q": "Sunset headers announce deprecation timeline.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match evolution strategies:",
        "type": "match",
        "left": [
            "Additive",
            "Versioned",
            "Extension",
            "Transformation"
        ],
        "right": [
            "Add only",
            "New version",
            "Custom fields",
            "Format change"
        ]
    },
    {
        "q": "Rearrange evolution process:",
        "type": "rearrange",
        "words": [
            "Announce change",
            "Add new field",
            "Deprecate old",
            "Migrate clients",
            "Remove deprecated"
        ]
    },
    {
        "q": "Which approach handles API monetization?",
        "type": "mcq",
        "o": [
            "Generating revenue from API usage",
            "Free only",
            "No monetization",
            "Cost center"
        ]
    },
    {
        "q": "The ______ model enables premium access.",
        "type": "fill_blank",
        "answers": [
            "freemium"
        ],
        "other_options": [
            "free",
            "paid",
            "enterprise"
        ]
    },
    {
        "q": "Usage metering enables billing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match monetization models:",
        "type": "match",
        "left": [
            "Direct",
            "Indirect",
            "Partner",
            "Internal"
        ],
        "right": [
            "Sell API",
            "Enable sales",
            "Revenue share",
            "Cost reduction"
        ]
    },
    {
        "q": "Which approach handles API marketplace?",
        "type": "mcq",
        "o": [
            "Platform for API discovery and consumption",
            "Internal only",
            "No marketplace",
            "Direct sales"
        ]
    },
    {
        "q": "The ______ portal enables API discovery.",
        "type": "fill_blank",
        "answers": [
            "developer"
        ],
        "other_options": [
            "admin",
            "user",
            "system"
        ]
    },
    {
        "q": "Marketplaces simplify API adoption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match marketplace features:",
        "type": "match",
        "left": [
            "Discovery",
            "Trial",
            "Subscribe",
            "Analytics"
        ],
        "right": [
            "Find APIs",
            "Test APIs",
            "Get access",
            "Track usage"
        ]
    },
    {
        "q": "Rearrange marketplace workflow:",
        "type": "rearrange",
        "words": [
            "Browse catalog",
            "View documentation",
            "Request access",
            "Get API key",
            "Start integrating"
        ]
    },
    {
        "q": "Which approach handles API developer experience?",
        "type": "mcq",
        "o": [
            "Optimizing for developer productivity",
            "Complex APIs",
            "No focus on DX",
            "Technical only"
        ]
    },
    {
        "q": "The ______ measures developer satisfaction.",
        "type": "fill_blank",
        "answers": [
            "DX"
        ],
        "other_options": [
            "UX",
            "CX",
            "NPS"
        ]
    },
    {
        "q": "Good DX increases API adoption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match DX elements:",
        "type": "match",
        "left": [
            "Documentation",
            "SDK",
            "Sandbox",
            "Support"
        ],
        "right": [
            "Guides",
            "Client library",
            "Testing env",
            "Help"
        ]
    },
    {
        "q": "Which approach handles API onboarding?",
        "type": "mcq",
        "o": [
            "Guiding new users to first success",
            "No onboarding",
            "Self-service only",
            "Manual process"
        ]
    },
    {
        "q": "The ______ time measures onboarding success.",
        "type": "fill_blank",
        "answers": [
            "time-to-first-call"
        ],
        "other_options": [
            "signup time",
            "learning time",
            "integration time"
        ]
    },
    {
        "q": "Quick onboarding improves adoption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match onboarding steps:",
        "type": "match",
        "left": [
            "Signup",
            "Credentials",
            "First call",
            "Integration"
        ],
        "right": [
            "Create account",
            "Get API key",
            "Test request",
            "Build app"
        ]
    },
    {
        "q": "Rearrange onboarding flow:",
        "type": "rearrange",
        "words": [
            "Register",
            "Read docs",
            "Get credentials",
            "Make first call",
            "Build integration"
        ]
    },
    {
        "q": "Which approach handles API support tiers?",
        "type": "mcq",
        "o": [
            "Different support levels for different plans",
            "Same for all",
            "No support",
            "Email only"
        ]
    },
    {
        "q": "The ______ tier offers 24/7 support.",
        "type": "fill_blank",
        "answers": [
            "enterprise"
        ],
        "other_options": [
            "basic",
            "premium",
            "free"
        ]
    },
    {
        "q": "SLAs define support response times.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match support levels:",
        "type": "match",
        "left": [
            "Community",
            "Standard",
            "Premium",
            "Enterprise"
        ],
        "right": [
            "Forums",
            "Email",
            "Priority",
            "Dedicated"
        ]
    },
    {
        "q": "Which approach handles error classification?",
        "type": "mcq",
        "o": [
            "Categorizing errors by type and severity",
            "Generic errors",
            "No classification",
            "Numbers only"
        ]
    },
    {
        "q": "The ______ codes provide error categories.",
        "type": "fill_blank",
        "answers": [
            "error"
        ],
        "other_options": [
            "status",
            "type",
            "class"
        ]
    },
    {
        "q": "Error codes help developers debug issues.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match error categories:",
        "type": "match",
        "left": [
            "Validation",
            "Authentication",
            "Authorization",
            "Server"
        ],
        "right": [
            "Bad input",
            "Who are you",
            "Not allowed",
            "System issue"
        ]
    },
    {
        "q": "Rearrange error handling:",
        "type": "rearrange",
        "words": [
            "Catch error",
            "Classify type",
            "Build response",
            "Log details",
            "Return to client"
        ]
    },
    {
        "q": "Which approach handles error localization?",
        "type": "mcq",
        "o": [
            "Returning errors in user language",
            "English only",
            "Codes only",
            "No localization"
        ]
    },
    {
        "q": "The ______ header specifies preferred language.",
        "type": "fill_blank",
        "answers": [
            "Accept-Language"
        ],
        "other_options": [
            "Language",
            "Locale",
            "Content-Language"
        ]
    },
    {
        "q": "Localized errors improve user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match localization aspects:",
        "type": "match",
        "left": [
            "Language",
            "Locale",
            "Timezone",
            "Currency"
        ],
        "right": [
            "Text",
            "Format",
            "Time",
            "Money"
        ]
    },
    {
        "q": "Which approach handles rate limit design?",
        "type": "mcq",
        "o": [
            "Defining limits per endpoint and client",
            "Same for all",
            "No limits",
            "Global only"
        ]
    },
    {
        "q": "The ______ identifies the limited entity.",
        "type": "fill_blank",
        "answers": [
            "key"
        ],
        "other_options": [
            "user",
            "client",
            "ip"
        ]
    },
    {
        "q": "Different endpoints may have different limits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match rate limit dimensions:",
        "type": "match",
        "left": [
            "Per user",
            "Per IP",
            "Per endpoint",
            "Per plan"
        ],
        "right": [
            "User identity",
            "Client address",
            "API path",
            "Subscription"
        ]
    },
    {
        "q": "Rearrange rate limit config:",
        "type": "rearrange",
        "words": [
            "Define limits",
            "Configure per endpoint",
            "Set per plan",
            "Implement enforcement",
            "Return headers"
        ]
    },
    {
        "q": "Which approach handles cache design?",
        "type": "mcq",
        "o": [
            "Strategic caching for performance",
            "Cache everything",
            "No caching",
            "Client only"
        ]
    },
    {
        "q": "The ______ determines cache duration.",
        "type": "fill_blank",
        "answers": [
            "max-age"
        ],
        "other_options": [
            "expires",
            "etag",
            "cache"
        ]
    },
    {
        "q": "Caching reduces backend load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match cache strategies:",
        "type": "match",
        "left": [
            "Public",
            "Private",
            "No-cache",
            "No-store"
        ],
        "right": [
            "Shared cache",
            "User only",
            "Revalidate",
            "Never cache"
        ]
    },
    {
        "q": "Which approach handles compression design?",
        "type": "mcq",
        "o": [
            "Reducing response size for transfer",
            "No compression",
            "Client only",
            "Always compress"
        ]
    },
    {
        "q": "The ______ compression is most common.",
        "type": "fill_blank",
        "answers": [
            "gzip"
        ],
        "other_options": [
            "deflate",
            "brotli",
            "zip"
        ]
    },
    {
        "q": "Compression reduces bandwidth usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match compression considerations:",
        "type": "match",
        "left": [
            "Text content",
            "Binary content",
            "Small payload",
            "Large payload"
        ],
        "right": [
            "Compress",
            "Usually compressed",
            "Skip",
            "Always compress"
        ]
    },
    {
        "q": "Rearrange compression flow:",
        "type": "rearrange",
        "words": [
            "Check Accept-Encoding",
            "Generate response",
            "Compress if supported",
            "Set Content-Encoding",
            "Send response"
        ]
    },
    {
        "q": "Which approach handles retry design?",
        "type": "mcq",
        "o": [
            "Client retry with exponential backoff",
            "No retries",
            "Infinite retries",
            "Immediate retry"
        ]
    },
    {
        "q": "The ______ header suggests retry timing.",
        "type": "fill_blank",
        "answers": [
            "Retry-After"
        ],
        "other_options": [
            "Wait",
            "Delay",
            "Backoff"
        ]
    },
    {
        "q": "Jitter prevents thundering herd.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match retry considerations:",
        "type": "match",
        "left": [
            "Max retries",
            "Backoff",
            "Jitter",
            "Circuit breaker"
        ],
        "right": [
            "Limit attempts",
            "Increase delay",
            "Randomize",
            "Stop after threshold"
        ]
    },
    {
        "q": "Which approach handles timeout design?",
        "type": "mcq",
        "o": [
            "Setting appropriate time limits",
            "No timeouts",
            "Very long timeout",
            "Client decides"
        ]
    },
    {
        "q": "The ______ timeout protects against slow clients.",
        "type": "fill_blank",
        "answers": [
            "read"
        ],
        "other_options": [
            "connect",
            "write",
            "idle"
        ]
    },
    {
        "q": "Timeouts prevent resource exhaustion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match timeout types:",
        "type": "match",
        "left": [
            "Connect",
            "Read",
            "Write",
            "Idle"
        ],
        "right": [
            "Establish connection",
            "Read response",
            "Send request",
            "No activity"
        ]
    },
    {
        "q": "Rearrange timeout handling:",
        "type": "rearrange",
        "words": [
            "Set timeout",
            "Start timer",
            "Check progress",
            "Cancel if exceeded",
            "Return error"
        ]
    },
    {
        "q": "Which approach handles request validation?",
        "type": "mcq",
        "o": [
            "Validating all input against schema",
            "Trust input",
            "Partial validation",
            "No validation"
        ]
    },
    {
        "q": "The ______ validates request structure.",
        "type": "fill_blank",
        "answers": [
            "JSON schema"
        ],
        "other_options": [
            "regex",
            "custom code",
            "manual"
        ]
    },
    {
        "q": "Early validation prevents processing errors.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match validation stages:",
        "type": "match",
        "left": [
            "Syntax",
            "Schema",
            "Business",
            "Security"
        ],
        "right": [
            "Format check",
            "Structure check",
            "Rule check",
            "Threat check"
        ]
    },
    {
        "q": "Which approach handles response validation?",
        "type": "mcq",
        "o": [
            "Ensuring responses match contract",
            "No validation",
            "Client validates",
            "Trust output"
        ]
    },
    {
        "q": "The ______ tests verify response structure.",
        "type": "fill_blank",
        "answers": [
            "contract"
        ],
        "other_options": [
            "unit",
            "integration",
            "e2e"
        ]
    },
    {
        "q": "Response validation catches breaking changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match response checks:",
        "type": "match",
        "left": [
            "Schema",
            "Status",
            "Headers",
            "Content"
        ],
        "right": [
            "Structure",
            "Code",
            "Metadata",
            "Body data"
        ]
    },
    {
        "q": "Rearrange response validation:",
        "type": "rearrange",
        "words": [
            "Get response",
            "Check status",
            "Validate headers",
            "Parse body",
            "Validate schema"
        ]
    },
    {
        "q": "Which approach handles API testing automation?",
        "type": "mcq",
        "o": [
            "Automated tests in CI/CD pipeline",
            "Manual testing",
            "No testing",
            "Production testing"
        ]
    },
    {
        "q": "The ______ tests run on every commit.",
        "type": "fill_blank",
        "answers": [
            "CI"
        ],
        "other_options": [
            "manual",
            "scheduled",
            "release"
        ]
    },
    {
        "q": "Automated testing catches regressions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match test automation:",
        "type": "match",
        "left": [
            "Smoke",
            "Regression",
            "Performance",
            "Security"
        ],
        "right": [
            "Basic health",
            "Prevent breaks",
            "Load testing",
            "Vulnerability scan"
        ]
    },
    {
        "q": "Which approach handles API load testing?",
        "type": "mcq",
        "o": [
            "Testing API under expected load",
            "No load testing",
            "Production only",
            "Manual load"
        ]
    },
    {
        "q": "The ______ test finds breaking point.",
        "type": "fill_blank",
        "answers": [
            "stress"
        ],
        "other_options": [
            "load",
            "soak",
            "spike"
        ]
    },
    {
        "q": "Load testing identifies bottlenecks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match load test types:",
        "type": "match",
        "left": [
            "Load",
            "Stress",
            "Soak",
            "Spike"
        ],
        "right": [
            "Normal load",
            "Beyond limit",
            "Extended time",
            "Sudden increase"
        ]
    },
    {
        "q": "Rearrange load test process:",
        "type": "rearrange",
        "words": [
            "Define scenarios",
            "Configure load",
            "Run test",
            "Collect metrics",
            "Analyze results"
        ]
    },
    {
        "q": "Which approach handles security testing?",
        "type": "mcq",
        "o": [
            "Testing for vulnerabilities",
            "No security testing",
            "Production only",
            "Manual review"
        ]
    },
    {
        "q": "The ______ testing finds security issues.",
        "type": "fill_blank",
        "answers": [
            "penetration"
        ],
        "other_options": [
            "load",
            "unit",
            "integration"
        ]
    },
    {
        "q": "Security testing should be automated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match security tests:",
        "type": "match",
        "left": [
            "SAST",
            "DAST",
            "IAST",
            "Fuzz"
        ],
        "right": [
            "Static code",
            "Running app",
            "Instrumented",
            "Random input"
        ]
    },
    {
        "q": "Which approach handles chaos engineering?",
        "type": "mcq",
        "o": [
            "Testing resilience by injecting failures",
            "No chaos",
            "Avoid failures",
            "Production only"
        ]
    },
    {
        "q": "The ______ principle guides chaos experiments.",
        "type": "fill_blank",
        "answers": [
            "steady state"
        ],
        "other_options": [
            "failure",
            "chaos",
            "resilience"
        ]
    },
    {
        "q": "Chaos testing improves system reliability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match chaos types:",
        "type": "match",
        "left": [
            "Latency",
            "Failure",
            "Resource",
            "Network"
        ],
        "right": [
            "Delay",
            "Error",
            "Exhaust",
            "Partition"
        ]
    },
    {
        "q": "Rearrange chaos experiment:",
        "type": "rearrange",
        "words": [
            "Define steady state",
            "Hypothesize impact",
            "Inject failure",
            "Observe behavior",
            "Learn and improve"
        ]
    },
    {
        "q": "Which approach handles API observability?",
        "type": "mcq",
        "o": [
            "Logs, metrics, and traces combined",
            "Logs only",
            "Metrics only",
            "No observability"
        ]
    },
    {
        "q": "The ______ pillars define observability.",
        "type": "fill_blank",
        "answers": [
            "three"
        ],
        "other_options": [
            "two",
            "four",
            "five"
        ]
    },
    {
        "q": "Observability enables debugging production issues.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match observability pillars:",
        "type": "match",
        "left": [
            "Logs",
            "Metrics",
            "Traces",
            "Events"
        ],
        "right": [
            "What happened",
            "How much",
            "Request flow",
            "State changes"
        ]
    },
    {
        "q": "Which approach handles incident response?",
        "type": "mcq",
        "o": [
            "Structured process for handling outages",
            "Ad-hoc response",
            "No process",
            "Ignore issues"
        ]
    },
    {
        "q": "The ______ manages incident coordination.",
        "type": "fill_blank",
        "answers": [
            "incident commander"
        ],
        "other_options": [
            "developer",
            "manager",
            "support"
        ]
    },
    {
        "q": "Runbooks document incident procedures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match incident phases:",
        "type": "match",
        "left": [
            "Detection",
            "Response",
            "Resolution",
            "Postmortem"
        ],
        "right": [
            "Find issue",
            "Coordinate",
            "Fix problem",
            "Learn"
        ]
    },
    {
        "q": "Rearrange incident flow:",
        "type": "rearrange",
        "words": [
            "Alert triggered",
            "Acknowledge",
            "Investigate",
            "Mitigate",
            "Resolve",
            "Document"
        ]
    },
    {
        "q": "Which approach handles API change management?",
        "type": "mcq",
        "o": [
            "Controlled process for API changes",
            "No process",
            "Ad-hoc changes",
            "Direct to production"
        ]
    },
    {
        "q": "The ______ reviews proposed changes.",
        "type": "fill_blank",
        "answers": [
            "change board"
        ],
        "other_options": [
            "developer",
            "manager",
            "architect"
        ]
    },
    {
        "q": "Change management reduces risk.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match change categories:",
        "type": "match",
        "left": [
            "Standard",
            "Normal",
            "Emergency",
            "Major"
        ],
        "right": [
            "Pre-approved",
            "Reviewed",
            "Urgent fix",
            "High impact"
        ]
    },
    {
        "q": "Which approach handles capacity planning?",
        "type": "mcq",
        "o": [
            "Planning resources for expected demand",
            "No planning",
            "Reactive scaling",
            "Over-provision"
        ]
    },
    {
        "q": "The ______ analysis predicts future needs.",
        "type": "fill_blank",
        "answers": [
            "trend"
        ],
        "other_options": [
            "load",
            "capacity",
            "demand"
        ]
    },
    {
        "q": "Capacity planning prevents outages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match capacity metrics:",
        "type": "match",
        "left": [
            "Throughput",
            "Latency",
            "Error rate",
            "Utilization"
        ],
        "right": [
            "Requests/sec",
            "Response time",
            "Failure %",
            "Resource use"
        ]
    },
    {
        "q": "Rearrange capacity workflow:",
        "type": "rearrange",
        "words": [
            "Collect metrics",
            "Analyze trends",
            "Forecast demand",
            "Plan resources",
            "Implement scaling"
        ]
    },
    {
        "q": "API design principles create maintainable systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design principles:",
        "type": "match",
        "left": [
            "KISS",
            "DRY",
            "YAGNI",
            "SOLID"
        ],
        "right": [
            "Keep simple",
            "No repetition",
            "No premature",
            "Object design"
        ]
    },
    {
        "q": "Which approach handles API complexity management?",
        "type": "mcq",
        "o": [
            "Breaking complex APIs into simpler parts",
            "Monolithic API",
            "No management",
            "Add complexity"
        ]
    },
    {
        "q": "The ______ pattern decomposes complexity.",
        "type": "fill_blank",
        "answers": [
            "microservices"
        ],
        "other_options": [
            "monolith",
            "modular",
            "layered"
        ]
    },
    {
        "q": "Modular APIs are easier to maintain.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match complexity patterns:",
        "type": "match",
        "left": [
            "Modular",
            "Layered",
            "Hexagonal",
            "Microservices"
        ],
        "right": [
            "Components",
            "Tiers",
            "Ports/adapters",
            "Services"
        ]
    },
    {
        "q": "API design excellence delivers business value.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API success metrics:",
        "type": "match",
        "left": [
            "Adoption",
            "Retention",
            "Revenue",
            "Satisfaction"
        ],
        "right": [
            "New users",
            "Active users",
            "Monetization",
            "NPS score"
        ]
    },
    {
        "q": "Which approach handles backwards compatibility?",
        "type": "mcq",
        "o": [
            "New versions support old clients",
            "Break clients",
            "Force upgrade",
            "No compatibility"
        ]
    },
    {
        "q": "The ______ ensures old clients still work.",
        "type": "fill_blank",
        "answers": [
            "compatibility"
        ],
        "other_options": [
            "version",
            "migration",
            "upgrade"
        ]
    },
    {
        "q": "Match compatibility types:",
        "type": "match",
        "left": [
            "Forward",
            "Backward",
            "Full",
            "None"
        ],
        "right": [
            "Old reads new",
            "New reads old",
            "Both ways",
            "Neither"
        ]
    },
    {
        "q": "API design creates lasting value for organizations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API value creation:",
        "type": "match",
        "left": [
            "Efficiency",
            "Innovation",
            "Integration",
            "Revenue"
        ],
        "right": [
            "Process improvement",
            "New products",
            "Partner ecosystem",
            "Monetization"
        ]
    },
    {
        "q": "Which approach handles multi-tenant API design?",
        "type": "mcq",
        "o": [
            "Single API serving multiple customers",
            "Separate per customer",
            "Shared everything",
            "No isolation"
        ]
    },
    {
        "q": "The ______ isolates tenant data.",
        "type": "fill_blank",
        "answers": [
            "partition"
        ],
        "other_options": [
            "database",
            "schema",
            "table"
        ]
    },
    {
        "q": "Multi-tenancy requires data isolation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match multi-tenancy models:",
        "type": "match",
        "left": [
            "Shared DB",
            "Shared schema",
            "Separate schema",
            "Separate DB"
        ],
        "right": [
            "Same tables",
            "Same structure",
            "Tenant schema",
            "Tenant database"
        ]
    },
    {
        "q": "Rearrange tenant request:",
        "type": "rearrange",
        "words": [
            "Identify tenant",
            "Validate access",
            "Set context",
            "Process request",
            "Return response"
        ]
    },
    {
        "q": "Which approach handles API edge computing?",
        "type": "mcq",
        "o": [
            "Processing closer to users",
            "Centralized only",
            "No edge",
            "Client processing"
        ]
    },
    {
        "q": "The ______ reduces latency for users.",
        "type": "fill_blank",
        "answers": [
            "edge"
        ],
        "other_options": [
            "center",
            "cloud",
            "server"
        ]
    },
    {
        "q": "Edge computing improves response times.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match edge patterns:",
        "type": "match",
        "left": [
            "CDN",
            "Edge functions",
            "Edge cache",
            "Edge compute"
        ],
        "right": [
            "Static content",
            "Serverless edge",
            "Data cache",
            "Full processing"
        ]
    },
    {
        "q": "Which approach handles API serverless design?",
        "type": "mcq",
        "o": [
            "Functions triggered by events",
            "Always-on servers",
            "Manual scaling",
            "No serverless"
        ]
    },
    {
        "q": "The ______ triggers serverless functions.",
        "type": "fill_blank",
        "answers": [
            "event"
        ],
        "other_options": [
            "request",
            "timer",
            "message"
        ]
    },
    {
        "q": "Serverless scales automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match serverless concepts:",
        "type": "match",
        "left": [
            "Cold start",
            "Warm instance",
            "Concurrency",
            "Duration"
        ],
        "right": [
            "Init delay",
            "Ready function",
            "Parallel runs",
            "Execution time"
        ]
    },
    {
        "q": "Rearrange serverless flow:",
        "type": "rearrange",
        "words": [
            "Event triggers",
            "Platform provisions",
            "Function executes",
            "Response returns",
            "Instance may terminate"
        ]
    },
    {
        "q": "Which approach handles API container orchestration?",
        "type": "mcq",
        "o": [
            "Managing containerized APIs at scale",
            "Single container",
            "Manual management",
            "No containers"
        ]
    },
    {
        "q": "The ______ orchestrates containers.",
        "type": "fill_blank",
        "answers": [
            "Kubernetes"
        ],
        "other_options": [
            "Docker",
            "Compose",
            "Swarm"
        ]
    },
    {
        "q": "Container orchestration enables scaling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match orchestration features:",
        "type": "match",
        "left": [
            "Deployment",
            "Service",
            "Ingress",
            "ConfigMap"
        ],
        "right": [
            "Pod management",
            "Network exposure",
            "External access",
            "Configuration"
        ]
    },
    {
        "q": "Which approach handles API mesh architecture?",
        "type": "mcq",
        "o": [
            "Dedicated infrastructure for service communication",
            "Direct calls",
            "No mesh",
            "Single proxy"
        ]
    },
    {
        "q": "The ______ handles service-to-service traffic.",
        "type": "fill_blank",
        "answers": [
            "service mesh"
        ],
        "other_options": [
            "proxy",
            "gateway",
            "load balancer"
        ]
    },
    {
        "q": "Service mesh provides observability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match mesh features:",
        "type": "match",
        "left": [
            "Traffic management",
            "Security",
            "Observability",
            "Resilience"
        ],
        "right": [
            "Routing",
            "mTLS",
            "Tracing",
            "Retries"
        ]
    },
    {
        "q": "Rearrange mesh setup:",
        "type": "rearrange",
        "words": [
            "Install mesh",
            "Inject sidecars",
            "Configure policies",
            "Enable features",
            "Monitor traffic"
        ]
    },
    {
        "q": "Which approach handles API contract evolution?",
        "type": "mcq",
        "o": [
            "Carefully managing schema changes",
            "Break at will",
            "No changes",
            "Version everything"
        ]
    },
    {
        "q": "The ______ validates contract compatibility.",
        "type": "fill_blank",
        "answers": [
            "schema registry"
        ],
        "other_options": [
            "contract test",
            "linter",
            "validator"
        ]
    },
    {
        "q": "Contract evolution prevents breaking changes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match evolution rules:",
        "type": "match",
        "left": [
            "Add optional",
            "Remove optional",
            "Change required",
            "Rename field"
        ],
        "right": [
            "Safe",
            "Potentially breaking",
            "Breaking",
            "Breaking"
        ]
    },
    {
        "q": "Which approach handles API performance optimization?",
        "type": "mcq",
        "o": [
            "Systematic performance improvement",
            "No optimization",
            "Hardware only",
            "Ignore performance"
        ]
    },
    {
        "q": "The ______ identifies performance bottlenecks.",
        "type": "fill_blank",
        "answers": [
            "profiling"
        ],
        "other_options": [
            "logging",
            "monitoring",
            "testing"
        ]
    },
    {
        "q": "Performance optimization requires measurement.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match optimization areas:",
        "type": "match",
        "left": [
            "Database",
            "Network",
            "Application",
            "Infrastructure"
        ],
        "right": [
            "Query tuning",
            "Reduce calls",
            "Code optimization",
            "Resource sizing"
        ]
    },
    {
        "q": "Rearrange optimization cycle:",
        "type": "rearrange",
        "words": [
            "Measure baseline",
            "Identify bottleneck",
            "Implement fix",
            "Validate improvement",
            "Iterate"
        ]
    },
    {
        "q": "Which approach handles API scalability design?",
        "type": "mcq",
        "o": [
            "Designing for growth",
            "Fixed capacity",
            "Scale when fails",
            "No scaling"
        ]
    },
    {
        "q": "The ______ scaling adds more instances.",
        "type": "fill_blank",
        "answers": [
            "horizontal"
        ],
        "other_options": [
            "vertical",
            "manual",
            "fixed"
        ]
    },
    {
        "q": "Stateless design enables scaling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match scaling patterns:",
        "type": "match",
        "left": [
            "Horizontal",
            "Vertical",
            "Auto",
            "Manual"
        ],
        "right": [
            "More instances",
            "Bigger instance",
            "Demand-based",
            "Human triggered"
        ]
    },
    {
        "q": "Which approach handles API reliability design?",
        "type": "mcq",
        "o": [
            "Designing for uptime and consistency",
            "Hope for best",
            "No reliability",
            "Single point"
        ]
    },
    {
        "q": "The ______ ensures data durability.",
        "type": "fill_blank",
        "answers": [
            "replication"
        ],
        "other_options": [
            "backup",
            "cache",
            "copy"
        ]
    },
    {
        "q": "Redundancy improves reliability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match reliability patterns:",
        "type": "match",
        "left": [
            "Redundancy",
            "Failover",
            "Load balancing",
            "Health checks"
        ],
        "right": [
            "Multiple copies",
            "Switch on failure",
            "Distribute load",
            "Detect issues"
        ]
    },
    {
        "q": "Rearrange reliability design:",
        "type": "rearrange",
        "words": [
            "Identify failures",
            "Add redundancy",
            "Implement failover",
            "Monitor health",
            "Test recovery"
        ]
    },
    {
        "q": "Which approach handles API maintainability design?",
        "type": "mcq",
        "o": [
            "Designing for easy updates",
            "Complex code",
            "No documentation",
            "Tight coupling"
        ]
    },
    {
        "q": "The ______ principle promotes maintainability.",
        "type": "fill_blank",
        "answers": [
            "separation of concerns"
        ],
        "other_options": [
            "coupling",
            "complexity",
            "monolith"
        ]
    },
    {
        "q": "Clean code improves maintainability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match maintainability factors:",
        "type": "match",
        "left": [
            "Modularity",
            "Documentation",
            "Testing",
            "Standards"
        ],
        "right": [
            "Components",
            "Guides",
            "Coverage",
            "Conventions"
        ]
    },
    {
        "q": "Which approach handles API extensibility design?",
        "type": "mcq",
        "o": [
            "Designing for future additions",
            "Fixed features",
            "No extension",
            "Rebuild for changes"
        ]
    },
    {
        "q": "The ______ pattern enables extensions.",
        "type": "fill_blank",
        "answers": [
            "plugin"
        ],
        "other_options": [
            "fixed",
            "hardcoded",
            "static"
        ]
    },
    {
        "q": "Extensible APIs support customization.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match extensibility patterns:",
        "type": "match",
        "left": [
            "Plugins",
            "Webhooks",
            "Custom fields",
            "Middleware"
        ],
        "right": [
            "Add features",
            "External notify",
            "Extra data",
            "Process chain"
        ]
    },
    {
        "q": "Rearrange extension design:",
        "type": "rearrange",
        "words": [
            "Define extension points",
            "Create interfaces",
            "Document APIs",
            "Enable registration",
            "Load extensions"
        ]
    },
    {
        "q": "API design is a continuous learning journey.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API design evolution:",
        "type": "match",
        "left": [
            "RPC",
            "REST",
            "GraphQL",
            "gRPC"
        ],
        "right": [
            "Procedure calls",
            "Resources",
            "Flexible queries",
            "High performance"
        ]
    },
    {
        "q": "Which approach handles API security by design?",
        "type": "mcq",
        "o": [
            "Building security into API from start",
            "Add security later",
            "No security",
            "Client security"
        ]
    },
    {
        "q": "The ______ principle limits permissions.",
        "type": "fill_blank",
        "answers": [
            "least privilege"
        ],
        "other_options": [
            "all access",
            "admin default",
            "open access"
        ]
    },
    {
        "q": "Security by design reduces vulnerabilities.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match security principles:",
        "type": "match",
        "left": [
            "Defense in depth",
            "Least privilege",
            "Zero trust",
            "Secure default"
        ],
        "right": [
            "Multiple layers",
            "Minimal access",
            "Verify always",
            "Safe starting point"
        ]
    },
    {
        "q": "Excellent API design creates exceptional developer experiences.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match API design excellence:",
        "type": "match",
        "left": [
            "Intuitive",
            "Reliable",
            "Secure",
            "Performant"
        ],
        "right": [
            "Easy to use",
            "Always works",
            "Safe to use",
            "Fast responses"
        ]
    },
    {
        "q": "Which approach handles API interoperability?",
        "type": "mcq",
        "o": [
            "Enabling different systems to work together",
            "Isolated systems",
            "No interop",
            "Single platform"
        ]
    },
    {
        "q": "The ______ standard enables interoperability.",
        "type": "fill_blank",
        "answers": [
            "open"
        ],
        "other_options": [
            "proprietary",
            "closed",
            "custom"
        ]
    },
    {
        "q": "Standards improve API interoperability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match interop standards:",
        "type": "match",
        "left": [
            "OpenAPI",
            "JSON Schema",
            "OAuth",
            "OpenID Connect"
        ],
        "right": [
            "API spec",
            "Data validation",
            "Authorization",
            "Authentication"
        ]
    },
    {
        "q": "Rearrange integration setup:",
        "type": "rearrange",
        "words": [
            "Review API docs",
            "Create credentials",
            "Implement client",
            "Test integration",
            "Deploy"
        ]
    },
    {
        "q": "Which approach handles API composition patterns?",
        "type": "mcq",
        "o": [
            "Combining multiple APIs into unified experience",
            "Single API only",
            "No composition",
            "Client composition"
        ]
    },
    {
        "q": "The ______ layer combines multiple APIs.",
        "type": "fill_blank",
        "answers": [
            "aggregation"
        ],
        "other_options": [
            "presentation",
            "business",
            "data"
        ]
    },
    {
        "q": "API composition reduces client complexity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match composition patterns:",
        "type": "match",
        "left": [
            "Aggregation",
            "Chaining",
            "Branching",
            "Parallel"
        ],
        "right": [
            "Combine results",
            "Sequential calls",
            "Conditional paths",
            "Concurrent calls"
        ]
    },
    {
        "q": "Which approach handles API data transformation?",
        "type": "mcq",
        "o": [
            "Converting data between formats",
            "Same format only",
            "No transformation",
            "Client transforms"
        ]
    },
    {
        "q": "The ______ layer handles data conversion.",
        "type": "fill_blank",
        "answers": [
            "transformation"
        ],
        "other_options": [
            "routing",
            "validation",
            "authentication"
        ]
    },
    {
        "q": "Data transformation enables format flexibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match transformation types:",
        "type": "match",
        "left": [
            "Format",
            "Schema",
            "Protocol",
            "Encoding"
        ],
        "right": [
            "JSON to XML",
            "v1 to v2",
            "REST to gRPC",
            "UTF-8 to binary"
        ]
    },
    {
        "q": "Rearrange transformation pipeline:",
        "type": "rearrange",
        "words": [
            "Receive input",
            "Parse format",
            "Map fields",
            "Transform values",
            "Serialize output"
        ]
    },
    {
        "q": "Which approach handles API error recovery?",
        "type": "mcq",
        "o": [
            "Automatically recovering from failures",
            "Fail immediately",
            "Manual recovery",
            "No recovery"
        ]
    },
    {
        "q": "The ______ enables automatic error recovery.",
        "type": "fill_blank",
        "answers": [
            "retry"
        ],
        "other_options": [
            "log",
            "alert",
            "ignore"
        ]
    },
    {
        "q": "Error recovery improves system resilience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match recovery strategies:",
        "type": "match",
        "left": [
            "Retry",
            "Fallback",
            "Cache",
            "Queue"
        ],
        "right": [
            "Try again",
            "Alternative",
            "Cached data",
            "Deferred processing"
        ]
    },
    {
        "q": "Which approach handles API state management?",
        "type": "mcq",
        "o": [
            "Managing state across API calls",
            "Stateless only",
            "Client state",
            "No state"
        ]
    },
    {
        "q": "The ______ enables stateful interactions.",
        "type": "fill_blank",
        "answers": [
            "session"
        ],
        "other_options": [
            "cookie",
            "token",
            "cache"
        ]
    },
    {
        "q": "Stateless APIs are easier to scale.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match state approaches:",
        "type": "match",
        "left": [
            "Stateless",
            "Server session",
            "Client token",
            "Distributed cache"
        ],
        "right": [
            "No server state",
            "Server memory",
            "JWT",
            "Redis"
        ]
    },
    {
        "q": "Rearrange state handling:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Validate token",
            "Load state",
            "Process request",
            "Update state"
        ]
    },
    {
        "q": "Which approach handles API resource lifecycle?",
        "type": "mcq",
        "o": [
            "Managing resource creation to deletion",
            "Create only",
            "No lifecycle",
            "Manual management"
        ]
    },
    {
        "q": "The ______ operation initializes resources.",
        "type": "fill_blank",
        "answers": [
            "create"
        ],
        "other_options": [
            "read",
            "update",
            "delete"
        ]
    },
    {
        "q": "CRUD operations define resource lifecycle.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match lifecycle operations:",
        "type": "match",
        "left": [
            "Create",
            "Read",
            "Update",
            "Delete"
        ],
        "right": [
            "POST",
            "GET",
            "PUT/PATCH",
            "DELETE"
        ]
    },
    {
        "q": "API design excellence is achieved through iteration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match design iteration:",
        "type": "match",
        "left": [
            "Design",
            "Implement",
            "Test",
            "Improve"
        ],
        "right": [
            "Plan API",
            "Build API",
            "Verify",
            "Refine"
        ]
    }
]