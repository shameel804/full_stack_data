[
    {
        "q": "What does REST stand for?",
        "type": "mcq",
        "o": [
            "Representational State Transfer",
            "Remote State Transfer",
            "Resource State Transfer",
            "Request State Transfer"
        ]
    },
    {
        "q": "Which HTTP method is typically used to create a new resource?",
        "type": "mcq",
        "o": [
            "POST",
            "GET",
            "PUT",
            "DELETE"
        ]
    },
    {
        "q": "REST APIs are ______ meaning each request contains all information needed.",
        "type": "fill_blank",
        "answers": [
            "stateless"
        ],
        "other_options": [
            "stateful",
            "persistent",
            "cached"
        ]
    },
    {
        "q": "Which HTTP method retrieves a resource without modifying it?",
        "type": "mcq",
        "o": [
            "GET",
            "POST",
            "PUT",
            "PATCH"
        ]
    },
    {
        "q": "Match REST HTTP methods with operations:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Read",
            "Create",
            "Update/Replace",
            "Remove"
        ]
    },
    {
        "q": "REST uses HTTP as its communication protocol.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which status code indicates a successful resource creation?",
        "type": "mcq",
        "o": [
            "201 Created",
            "200 OK",
            "204 No Content",
            "202 Accepted"
        ]
    },
    {
        "q": "A REST ______ is an addressable entity in the API.",
        "type": "fill_blank",
        "answers": [
            "resource"
        ],
        "other_options": [
            "endpoint",
            "method",
            "header"
        ]
    },
    {
        "q": "What is the purpose of the URI in REST?",
        "type": "mcq",
        "o": [
            "Identify and locate resources",
            "Define HTTP methods",
            "Store session data",
            "Handle authentication"
        ]
    },
    {
        "q": "Match REST concepts with definitions:",
        "type": "match",
        "left": [
            "Resource",
            "Endpoint",
            "URI",
            "Representation"
        ],
        "right": [
            "Data entity",
            "API access point",
            "Resource identifier",
            "Resource format"
        ]
    },
    {
        "q": "Rearrange a typical REST URL structure:",
        "type": "rearrange",
        "words": [
            "https://",
            "api.example.com",
            "/v1",
            "/users",
            "/123"
        ]
    },
    {
        "q": "REST APIs should use ______ to represent resources.",
        "type": "fill_blank",
        "answers": [
            "nouns"
        ],
        "other_options": [
            "verbs",
            "adjectives",
            "actions"
        ]
    },
    {
        "q": "Which HTTP method is used to update an entire resource?",
        "type": "mcq",
        "o": [
            "PUT",
            "PATCH",
            "POST",
            "GET"
        ]
    },
    {
        "q": "REST APIs should be stateless.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct endpoint for getting all users?",
        "type": "mcq",
        "o": [
            "GET /users",
            "POST /getUsers",
            "GET /getAllUsers",
            "POST /users/list"
        ]
    },
    {
        "q": "Match HTTP status codes with meanings:",
        "type": "match",
        "left": [
            "200",
            "201",
            "204",
            "404"
        ],
        "right": [
            "OK",
            "Created",
            "No Content",
            "Not Found"
        ]
    },
    {
        "q": "The ______ header specifies the format of the request body.",
        "type": "fill_blank",
        "answers": [
            "Content-Type"
        ],
        "other_options": [
            "Accept",
            "Authorization",
            "Host"
        ]
    },
    {
        "q": "Which format is most commonly used for REST API responses?",
        "type": "mcq",
        "o": [
            "JSON",
            "XML",
            "HTML",
            "Plain text"
        ]
    },
    {
        "q": "Rearrange the steps to make a REST API call:",
        "type": "rearrange",
        "words": [
            "Choose HTTP method",
            "Construct URL",
            "Add headers",
            "Send request",
            "Handle response"
        ]
    },
    {
        "q": "REST APIs can return multiple representations of the same resource.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct endpoint to delete a user with ID 5?",
        "type": "mcq",
        "o": [
            "DELETE /users/5",
            "POST /users/delete/5",
            "GET /users/5/delete",
            "DELETE /deleteUser/5"
        ]
    },
    {
        "q": "The Accept header indicates the ______ the client can process.",
        "type": "fill_blank",
        "answers": [
            "media types"
        ],
        "other_options": [
            "methods",
            "status codes",
            "credentials"
        ]
    },
    {
        "q": "Which HTTP method is idempotent?",
        "type": "mcq",
        "o": [
            "PUT",
            "POST",
            "Neither",
            "Both"
        ]
    },
    {
        "q": "Match REST principles with descriptions:",
        "type": "match",
        "left": [
            "Stateless",
            "Cacheable",
            "Uniform Interface",
            "Layered System"
        ],
        "right": [
            "No session state",
            "Responses can be cached",
            "Consistent API design",
            "Multiple architectural layers"
        ]
    },
    {
        "q": "What does CRUD stand for?",
        "type": "mcq",
        "o": [
            "Create, Read, Update, Delete",
            "Connect, Read, Update, Delete",
            "Create, Request, Update, Delete",
            "Create, Read, Upload, Delete"
        ]
    },
    {
        "q": "The path /users/123/orders represents a ______ resource.",
        "type": "fill_blank",
        "answers": [
            "nested"
        ],
        "other_options": [
            "flat",
            "root",
            "singleton"
        ]
    },
    {
        "q": "Which status code indicates the request was successful but no content is returned?",
        "type": "mcq",
        "o": [
            "204 No Content",
            "200 OK",
            "201 Created",
            "202 Accepted"
        ]
    },
    {
        "q": "REST APIs must use HTTP.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "Rearrange the CRUD operations in order:",
        "type": "rearrange",
        "words": [
            "Create",
            "Read",
            "Update",
            "Delete"
        ]
    },
    {
        "q": "Match HTTP methods with idempotency:",
        "type": "match",
        "left": [
            "GET",
            "POST",
            "PUT",
            "DELETE"
        ],
        "right": [
            "Idempotent",
            "Not idempotent",
            "Idempotent",
            "Idempotent"
        ]
    },
    {
        "q": "What is the correct way to filter users by status?",
        "type": "mcq",
        "o": [
            "GET /users?status=active",
            "GET /users/filter/active",
            "POST /users/search",
            "GET /getUsersByStatus/active"
        ]
    },
    {
        "q": "Query parameters are used to ______ collection resources.",
        "type": "fill_blank",
        "answers": [
            "filter"
        ],
        "other_options": [
            "create",
            "delete",
            "identify"
        ]
    },
    {
        "q": "Which status code indicates a client error?",
        "type": "mcq",
        "o": [
            "400 Bad Request",
            "200 OK",
            "500 Internal Server Error",
            "201 Created"
        ]
    },
    {
        "q": "REST APIs should use plural nouns for collections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match resource types with examples:",
        "type": "match",
        "left": [
            "Collection",
            "Singleton",
            "Sub-resource",
            "Controller"
        ],
        "right": [
            "/users",
            "/users/123",
            "/users/123/orders",
            "/users/123/activate"
        ]
    },
    {
        "q": "The Location header is used with ______ responses.",
        "type": "fill_blank",
        "answers": [
            "201 Created"
        ],
        "other_options": [
            "200 OK",
            "204 No Content",
            "404 Not Found"
        ]
    },
    {
        "q": "Which HTTP method partially updates a resource?",
        "type": "mcq",
        "o": [
            "PATCH",
            "PUT",
            "POST",
            "UPDATE"
        ]
    },
    {
        "q": "Rearrange REST API design steps:",
        "type": "rearrange",
        "words": [
            "Identify resources",
            "Define URIs",
            "Choose representations",
            "Implement methods",
            "Document API"
        ]
    },
    {
        "q": "REST is an architectural style not a protocol.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What status code indicates a resource was not found?",
        "type": "mcq",
        "o": [
            "404 Not Found",
            "400 Bad Request",
            "403 Forbidden",
            "500 Internal Server Error"
        ]
    },
    {
        "q": "A ______ is a collection of related resources.",
        "type": "fill_blank",
        "answers": [
            "collection resource"
        ],
        "other_options": [
            "singleton resource",
            "sub-resource",
            "root resource"
        ]
    },
    {
        "q": "Match response codes with appropriate actions:",
        "type": "match",
        "left": [
            "200 OK",
            "201 Created",
            "204 No Content",
            "202 Accepted"
        ],
        "right": [
            "GET success",
            "POST success",
            "DELETE success",
            "Async processing"
        ]
    },
    {
        "q": "Which is better REST endpoint design?",
        "type": "mcq",
        "o": [
            "/users/123",
            "/getUser?id=123",
            "/users/get/123",
            "/getUserById/123"
        ]
    },
    {
        "q": "REST APIs should expose ______ not implementation details.",
        "type": "fill_blank",
        "answers": [
            "resources"
        ],
        "other_options": [
            "functions",
            "methods",
            "procedures"
        ]
    },
    {
        "q": "Rearrange HTTP status code categories:",
        "type": "rearrange",
        "words": [
            "1xx Informational",
            "2xx Success",
            "3xx Redirection",
            "4xx Client Error",
            "5xx Server Error"
        ]
    },
    {
        "q": "The OPTIONS method returns allowed methods for a resource.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of the HEAD method?",
        "type": "mcq",
        "o": [
            "Get response headers without body",
            "Create a new resource",
            "Delete a resource",
            "Update a resource"
        ]
    },
    {
        "q": "Match REST constraints:",
        "type": "match",
        "left": [
            "Client-Server",
            "Stateless",
            "Cacheable",
            "Code on Demand"
        ],
        "right": [
            "Separation of concerns",
            "No session state",
            "Response caching",
            "Optional downloadable code"
        ]
    },
    {
        "q": "The ______ method is safe and idempotent.",
        "type": "fill_blank",
        "answers": [
            "GET"
        ],
        "other_options": [
            "POST",
            "PATCH",
            "DELETE"
        ]
    },
    {
        "q": "Which approach is better for updating a user's email only?",
        "type": "mcq",
        "o": [
            "PATCH /users/123 with partial data",
            "PUT /users/123 with full resource",
            "POST /users/123/update",
            "GET /users/123/updateEmail"
        ]
    },
    {
        "q": "REST APIs should version their endpoints.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is a safe HTTP method?",
        "type": "mcq",
        "o": [
            "One that doesn't modify the resource",
            "One that uses HTTPS",
            "One that requires authentication",
            "One that is encrypted"
        ]
    },
    {
        "q": "Rearrange the resource hierarchy:",
        "type": "rearrange",
        "words": [
            "/api",
            "/v1",
            "/organizations",
            "/{orgId}",
            "/users"
        ]
    },
    {
        "q": "Match endpoint patterns with use cases:",
        "type": "match",
        "left": [
            "/users",
            "/users/123",
            "/users/123/orders",
            "/search"
        ],
        "right": [
            "List all users",
            "Get specific user",
            "User's orders",
            "Search action"
        ]
    },
    {
        "q": "The ______ status code indicates the server understood but refuses to authorize.",
        "type": "fill_blank",
        "answers": [
            "403"
        ],
        "other_options": [
            "401",
            "404",
            "500"
        ]
    },
    {
        "q": "Which is the correct pagination query?",
        "type": "mcq",
        "o": [
            "GET /users?page=2&limit=10",
            "POST /users/page/2",
            "GET /users/paginate/2/10",
            "POST /getPage?users=2"
        ]
    },
    {
        "q": "REST APIs should use hypermedia for discoverability.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What does HATEOAS stand for?",
        "type": "mcq",
        "o": [
            "Hypermedia as the Engine of Application State",
            "HTTP as the Engine of Application State",
            "Hypertext as the Engine of Application State",
            "Hypermedia and the Extension of Application State"
        ]
    },
    {
        "q": "Match HTTP methods with safety:",
        "type": "match",
        "left": [
            "GET",
            "HEAD",
            "POST",
            "DELETE"
        ],
        "right": [
            "Safe",
            "Safe",
            "Not safe",
            "Not safe"
        ]
    },
    {
        "q": "The ______ header indicates authentication is required.",
        "type": "fill_blank",
        "answers": [
            "WWW-Authenticate"
        ],
        "other_options": [
            "Authorization",
            "Authentication",
            "Auth-Required"
        ]
    },
    {
        "q": "Which status code indicates unauthorized access?",
        "type": "mcq",
        "o": [
            "401 Unauthorized",
            "403 Forbidden",
            "404 Not Found",
            "400 Bad Request"
        ]
    },
    {
        "q": "Rearrange REST maturity levels:",
        "type": "rearrange",
        "words": [
            "Level 0: Single URI",
            "Level 1: Resources",
            "Level 2: HTTP Methods",
            "Level 3: HATEOAS"
        ]
    },
    {
        "q": "REST APIs should return meaningful error messages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the best practice for error responses?",
        "type": "mcq",
        "o": [
            "Include error code message and details",
            "Return only status code",
            "Return stack trace",
            "Return generic error"
        ]
    },
    {
        "q": "Match error codes with meanings:",
        "type": "match",
        "left": [
            "400",
            "401",
            "403",
            "422"
        ],
        "right": [
            "Bad Request",
            "Unauthorized",
            "Forbidden",
            "Unprocessable Entity"
        ]
    },
    {
        "q": "The ______ method checks if a resource exists.",
        "type": "fill_blank",
        "answers": [
            "HEAD"
        ],
        "other_options": [
            "GET",
            "OPTIONS",
            "TRACE"
        ]
    },
    {
        "q": "Which approach handles bulk operations in REST?",
        "type": "mcq",
        "o": [
            "POST /users/batch with array of users",
            "Multiple POST /users calls",
            "PUT /users with all users",
            "GET /users/createMultiple"
        ]
    },
    {
        "q": "REST APIs should use consistent naming conventions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is content negotiation?",
        "type": "mcq",
        "o": [
            "Selecting response format based on client preference",
            "Negotiating price of API access",
            "Determining request size limits",
            "Authentication handshake"
        ]
    },
    {
        "q": "Rearrange the API request flow:",
        "type": "rearrange",
        "words": [
            "Client request",
            "Server receives",
            "Process request",
            "Generate response",
            "Return to client"
        ]
    },
    {
        "q": "Match content types with formats:",
        "type": "match",
        "left": [
            "application/json",
            "application/xml",
            "text/html",
            "text/plain"
        ],
        "right": [
            "JSON data",
            "XML data",
            "HTML document",
            "Plain text"
        ]
    },
    {
        "q": "The ______ principle means GET requests should not change resources.",
        "type": "fill_blank",
        "answers": [
            "safe method"
        ],
        "other_options": [
            "idempotent",
            "stateless",
            "cacheable"
        ]
    },
    {
        "q": "Which is the correct way to include related resources?",
        "type": "mcq",
        "o": [
            "GET /users/123?include=orders",
            "GET /users/123/withOrders",
            "POST /users/123/expand",
            "GET /usersWithOrders/123"
        ]
    },
    {
        "q": "REST APIs should support filtering on collections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of API versioning?",
        "type": "mcq",
        "o": [
            "Allow backwards-incompatible changes",
            "Track API usage",
            "Limit API access",
            "Authenticate users"
        ]
    },
    {
        "q": "Match versioning strategies:",
        "type": "match",
        "left": [
            "URI path",
            "Query parameter",
            "Header",
            "Media type"
        ],
        "right": [
            "/v1/users",
            "/users?version=1",
            "X-API-Version: 1",
            "application/vnd.api.v1+json"
        ]
    },
    {
        "q": "The ______ status code indicates a server error.",
        "type": "fill_blank",
        "answers": [
            "500"
        ],
        "other_options": [
            "400",
            "404",
            "401"
        ]
    },
    {
        "q": "Which is the most common way to version REST APIs?",
        "type": "mcq",
        "o": [
            "URI path versioning",
            "Header versioning",
            "Query parameter versioning",
            "No versioning"
        ]
    },
    {
        "q": "Rearrange pagination parameters:",
        "type": "rearrange",
        "words": [
            "page",
            "limit",
            "offset",
            "cursor",
            "sort"
        ]
    },
    {
        "q": "REST APIs should support sorting on collections.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the correct way to sort users by name descending?",
        "type": "mcq",
        "o": [
            "GET /users?sort=-name",
            "GET /users/sortByName/desc",
            "POST /users/sort",
            "GET /sortUsers?field=name&order=desc"
        ]
    },
    {
        "q": "Match query parameters with purposes:",
        "type": "match",
        "left": [
            "filter",
            "sort",
            "page",
            "fields"
        ],
        "right": [
            "Narrow results",
            "Order results",
            "Paginate results",
            "Select fields"
        ]
    },
    {
        "q": "The ______ query parameter limits returned fields.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "select",
            "columns",
            "attributes"
        ]
    },
    {
        "q": "Which approach handles search in REST APIs?",
        "type": "mcq",
        "o": [
            "GET /users?q=john or GET /search?q=john",
            "POST /users/search with body",
            "GET /searchUsers/john",
            "POST /search/users/john"
        ]
    },
    {
        "q": "REST APIs should return total count for paginated results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What header indicates total items in a collection?",
        "type": "mcq",
        "o": [
            "X-Total-Count",
            "Content-Length",
            "Total-Items",
            "Collection-Size"
        ]
    },
    {
        "q": "Rearrange the resource naming hierarchy:",
        "type": "rearrange",
        "words": [
            "api",
            "version",
            "resource collection",
            "resource id",
            "sub-resource"
        ]
    },
    {
        "q": "Match Link header relations:",
        "type": "match",
        "left": [
            "self",
            "next",
            "prev",
            "first"
        ],
        "right": [
            "Current page",
            "Next page",
            "Previous page",
            "First page"
        ]
    },
    {
        "q": "The ______ relation links to the current resource.",
        "type": "fill_blank",
        "answers": [
            "self"
        ],
        "other_options": [
            "current",
            "this",
            "here"
        ]
    },
    {
        "q": "Which is the correct approach for action endpoints?",
        "type": "mcq",
        "o": [
            "POST /users/123/activate",
            "PUT /users/123/active/true",
            "GET /activateUser/123",
            "PATCH /users/123/status/active"
        ]
    },
    {
        "q": "REST APIs can use custom HTTP methods.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What should a DELETE request return on success?",
        "type": "mcq",
        "o": [
            "204 No Content or 200 OK with deleted resource",
            "201 Created",
            "202 Accepted always",
            "Nothing specific"
        ]
    },
    {
        "q": "Match response patterns with operations:",
        "type": "match",
        "left": [
            "Return created resource",
            "Return updated resource",
            "Return nothing",
            "Return confirmation"
        ],
        "right": [
            "POST",
            "PUT/PATCH",
            "DELETE",
            "Action endpoint"
        ]
    },
    {
        "q": "The ______ HTTP method sends the same request as GET but without body.",
        "type": "fill_blank",
        "answers": [
            "HEAD"
        ],
        "other_options": [
            "OPTIONS",
            "TRACE",
            "CONNECT"
        ]
    },
    {
        "q": "Which header is used for caching?",
        "type": "mcq",
        "o": [
            "Cache-Control",
            "Content-Type",
            "Authorization",
            "Accept"
        ]
    },
    {
        "q": "Rearrange the response body structure:",
        "type": "rearrange",
        "words": [
            "data",
            "meta",
            "links",
            "errors",
            "included"
        ]
    },
    {
        "q": "REST APIs should use HTTPS for security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which authentication method sends credentials with every request?",
        "type": "mcq",
        "o": [
            "Bearer token authentication",
            "Session-based authentication",
            "Cookie authentication",
            "OAuth code flow"
        ]
    },
    {
        "q": "The ______ header contains the authentication credentials.",
        "type": "fill_blank",
        "answers": [
            "Authorization"
        ],
        "other_options": [
            "Authentication",
            "Credentials",
            "Auth"
        ]
    },
    {
        "q": "Match authentication schemes:",
        "type": "match",
        "left": [
            "Basic",
            "Bearer",
            "Digest",
            "API Key"
        ],
        "right": [
            "Base64 encoded credentials",
            "Token-based",
            "Hashed credentials",
            "Simple key header"
        ]
    },
    {
        "q": "Which status code indicates rate limiting?",
        "type": "mcq",
        "o": [
            "429 Too Many Requests",
            "403 Forbidden",
            "503 Service Unavailable",
            "400 Bad Request"
        ]
    },
    {
        "q": "REST APIs should implement rate limiting.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The X-Rate-Limit-Remaining header indicates ______ requests left.",
        "type": "fill_blank",
        "answers": [
            "remaining"
        ],
        "other_options": [
            "total",
            "used",
            "maximum"
        ]
    },
    {
        "q": "What is the purpose of ETag in REST APIs?",
        "type": "mcq",
        "o": [
            "Enable conditional requests and caching",
            "Authenticate requests",
            "Rate limit clients",
            "Version the API"
        ]
    },
    {
        "q": "Match caching headers:",
        "type": "match",
        "left": [
            "ETag",
            "Last-Modified",
            "Cache-Control",
            "Expires"
        ],
        "right": [
            "Resource version",
            "Modification time",
            "Caching directives",
            "Expiration date"
        ]
    },
    {
        "q": "Rearrange the conditional request flow:",
        "type": "rearrange",
        "words": [
            "Send request with If-None-Match",
            "Server compares ETag",
            "Return 304 if unchanged",
            "Return 200 with new data if changed"
        ]
    },
    {
        "q": "Which header is sent with conditional GET requests?",
        "type": "mcq",
        "o": [
            "If-None-Match",
            "If-Match",
            "ETag",
            "Last-Modified"
        ]
    },
    {
        "q": "The ______ status code indicates the resource has not changed.",
        "type": "fill_blank",
        "answers": [
            "304"
        ],
        "other_options": [
            "200",
            "204",
            "302"
        ]
    },
    {
        "q": "REST APIs should support conditional requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is optimistic locking in REST?",
        "type": "mcq",
        "o": [
            "Using ETag or version to prevent concurrent update conflicts",
            "Locking resources before modification",
            "Requiring authentication for updates",
            "Caching responses optimistically"
        ]
    },
    {
        "q": "Match HTTP headers with purposes:",
        "type": "match",
        "left": [
            "If-Match",
            "If-None-Match",
            "If-Modified-Since",
            "If-Unmodified-Since"
        ],
        "right": [
            "Update only if matches",
            "Get only if changed",
            "Get if modified after",
            "Update if not modified"
        ]
    },
    {
        "q": "The ______ header prevents lost updates in concurrent modifications.",
        "type": "fill_blank",
        "answers": [
            "If-Match"
        ],
        "other_options": [
            "If-None-Match",
            "ETag",
            "Version"
        ]
    },
    {
        "q": "Which status code indicates a conflict in resource state?",
        "type": "mcq",
        "o": [
            "409 Conflict",
            "400 Bad Request",
            "422 Unprocessable Entity",
            "412 Precondition Failed"
        ]
    },
    {
        "q": "Rearrange optimistic locking flow:",
        "type": "rearrange",
        "words": [
            "GET resource with ETag",
            "Modify locally",
            "PUT with If-Match header",
            "Handle conflict if 412"
        ]
    },
    {
        "q": "REST APIs should handle concurrent modifications gracefully.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of CORS in REST APIs?",
        "type": "mcq",
        "o": [
            "Allow cross-origin browser requests",
            "Encrypt API communication",
            "Cache API responses",
            "Rate limit API access"
        ]
    },
    {
        "q": "Match CORS headers:",
        "type": "match",
        "left": [
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Methods",
            "Access-Control-Allow-Headers",
            "Access-Control-Max-Age"
        ],
        "right": [
            "Allowed origins",
            "Allowed methods",
            "Allowed headers",
            "Preflight cache time"
        ]
    },
    {
        "q": "The ______ HTTP method is used for CORS preflight requests.",
        "type": "fill_blank",
        "answers": [
            "OPTIONS"
        ],
        "other_options": [
            "HEAD",
            "GET",
            "POST"
        ]
    },
    {
        "q": "Which header allows credentials in CORS requests?",
        "type": "mcq",
        "o": [
            "Access-Control-Allow-Credentials",
            "Access-Control-Allow-Origin",
            "Authorization",
            "Cookie"
        ]
    },
    {
        "q": "Rearrange CORS preflight flow:",
        "type": "rearrange",
        "words": [
            "Browser sends OPTIONS",
            "Server returns CORS headers",
            "Browser validates headers",
            "Browser sends actual request"
        ]
    },
    {
        "q": "Simple CORS requests do not require preflight.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What makes a request a simple CORS request?",
        "type": "mcq",
        "o": [
            "GET POST HEAD with standard headers and content types",
            "Any request to same origin",
            "Requests without body",
            "Authenticated requests"
        ]
    },
    {
        "q": "Match request types with CORS behavior:",
        "type": "match",
        "left": [
            "Simple request",
            "Preflighted request",
            "Credentialed request",
            "Same-origin request"
        ],
        "right": [
            "No preflight needed",
            "OPTIONS sent first",
            "Requires Allow-Credentials",
            "No CORS needed"
        ]
    },
    {
        "q": "The ______ value for Access-Control-Allow-Origin allows any origin.",
        "type": "fill_blank",
        "answers": [
            "*"
        ],
        "other_options": [
            "all",
            "any",
            "true"
        ]
    },
    {
        "q": "Which is the correct way to handle file uploads in REST?",
        "type": "mcq",
        "o": [
            "POST with multipart/form-data",
            "PUT with application/json",
            "GET with file parameter",
            "POST with text/plain"
        ]
    },
    {
        "q": "Rearrange file upload handling:",
        "type": "rearrange",
        "words": [
            "Receive multipart request",
            "Parse file parts",
            "Validate file type and size",
            "Store file",
            "Return file URL"
        ]
    },
    {
        "q": "REST APIs should validate uploaded file types.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of the Content-Disposition header?",
        "type": "mcq",
        "o": [
            "Indicate if content should be displayed inline or downloaded",
            "Specify content encoding",
            "Define content type",
            "Set content length"
        ]
    },
    {
        "q": "Match file handling patterns:",
        "type": "match",
        "left": [
            "Upload",
            "Download",
            "Stream",
            "Delete"
        ],
        "right": [
            "POST multipart",
            "GET with Accept",
            "Chunked transfer",
            "DELETE resource"
        ]
    },
    {
        "q": "The ______ header specifies the filename for downloads.",
        "type": "fill_blank",
        "answers": [
            "Content-Disposition"
        ],
        "other_options": [
            "Content-Type",
            "Content-Name",
            "Filename"
        ]
    },
    {
        "q": "Which approach handles large file downloads?",
        "type": "mcq",
        "o": [
            "Range requests with Accept-Ranges header",
            "Single GET request",
            "Multiple POST requests",
            "WebSocket streaming"
        ]
    },
    {
        "q": "Rearrange range request flow:",
        "type": "rearrange",
        "words": [
            "Send HEAD to check Accept-Ranges",
            "Request Range header",
            "Receive 206 Partial Content",
            "Combine chunks"
        ]
    },
    {
        "q": "REST APIs should support resumable uploads for large files.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What status code indicates partial content?",
        "type": "mcq",
        "o": [
            "206 Partial Content",
            "200 OK",
            "204 No Content",
            "202 Accepted"
        ]
    },
    {
        "q": "Match streaming patterns:",
        "type": "match",
        "left": [
            "Chunked encoding",
            "Server-Sent Events",
            "WebSocket",
            "Long polling"
        ],
        "right": [
            "Transfer-Encoding chunked",
            "One-way server push",
            "Bidirectional",
            "Repeated requests"
        ]
    },
    {
        "q": "The ______ header enables chunked transfer encoding.",
        "type": "fill_blank",
        "answers": [
            "Transfer-Encoding"
        ],
        "other_options": [
            "Content-Encoding",
            "Content-Length",
            "Accept-Encoding"
        ]
    },
    {
        "q": "Which approach handles async operations in REST?",
        "type": "mcq",
        "o": [
            "Return 202 Accepted with status endpoint",
            "Block until completion",
            "Return 200 immediately",
            "Use WebSocket"
        ]
    },
    {
        "q": "Rearrange async operation flow:",
        "type": "rearrange",
        "words": [
            "Submit request",
            "Receive 202 with Location",
            "Poll status endpoint",
            "Get result when complete"
        ]
    },
    {
        "q": "Long-running operations should return 202 Accepted.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should the Location header contain for async operations?",
        "type": "mcq",
        "o": [
            "URL to check operation status",
            "URL of the created resource",
            "URL of the original request",
            "URL of the API documentation"
        ]
    },
    {
        "q": "Match async status responses:",
        "type": "match",
        "left": [
            "pending",
            "processing",
            "completed",
            "failed"
        ],
        "right": [
            "Not started",
            "In progress",
            "Done successfully",
            "Error occurred"
        ]
    },
    {
        "q": "The ______ header indicates when to retry async status check.",
        "type": "fill_blank",
        "answers": [
            "Retry-After"
        ],
        "other_options": [
            "Retry-Delay",
            "Poll-Interval",
            "Wait-Time"
        ]
    },
    {
        "q": "Which is the correct webhook pattern?",
        "type": "mcq",
        "o": [
            "Server POSTs to client callback URL",
            "Client polls server endpoint",
            "Server GETs from client",
            "Client subscribes via WebSocket"
        ]
    },
    {
        "q": "Rearrange webhook flow:",
        "type": "rearrange",
        "words": [
            "Register callback URL",
            "Event occurs",
            "Server POSTs to callback",
            "Client processes webhook",
            "Client returns 200"
        ]
    },
    {
        "q": "Webhooks should be verified with signatures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What header typically contains webhook signatures?",
        "type": "mcq",
        "o": [
            "X-Signature or X-Hub-Signature",
            "Authorization",
            "Content-Type",
            "Accept"
        ]
    },
    {
        "q": "Match callback patterns:",
        "type": "match",
        "left": [
            "Webhook",
            "Callback URL",
            "Event subscription",
            "Retry policy"
        ],
        "right": [
            "Server push notification",
            "Client endpoint",
            "Event filtering",
            "Failure handling"
        ]
    },
    {
        "q": "The ______ pattern allows clients to receive real-time updates.",
        "type": "fill_blank",
        "answers": [
            "webhook"
        ],
        "other_options": [
            "polling",
            "caching",
            "batching"
        ]
    },
    {
        "q": "Which approach handles batch operations in REST?",
        "type": "mcq",
        "o": [
            "Single endpoint accepting array of operations",
            "Multiple parallel requests",
            "Sequential individual requests",
            "WebSocket batch protocol"
        ]
    },
    {
        "q": "Rearrange batch request handling:",
        "type": "rearrange",
        "words": [
            "Receive batch request",
            "Validate all items",
            "Process each item",
            "Collect results",
            "Return batch response"
        ]
    },
    {
        "q": "Batch responses should include individual operation results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What status code indicates partial batch success?",
        "type": "mcq",
        "o": [
            "207 Multi-Status",
            "200 OK",
            "202 Accepted",
            "206 Partial Content"
        ]
    },
    {
        "q": "Match batch operation patterns:",
        "type": "match",
        "left": [
            "Atomic batch",
            "Non-atomic batch",
            "Bulk create",
            "Bulk delete"
        ],
        "right": [
            "All or nothing",
            "Partial success",
            "POST array",
            "DELETE with body"
        ]
    },
    {
        "q": "The ______ approach processes all batch items or none.",
        "type": "fill_blank",
        "answers": [
            "atomic"
        ],
        "other_options": [
            "sequential",
            "parallel",
            "async"
        ]
    },
    {
        "q": "Which is the correct way to implement search in REST?",
        "type": "mcq",
        "o": [
            "GET /resources?q=term or POST /resources/search with body",
            "GET /search/resources/term",
            "PUT /resources/search with body",
            "DELETE /resources?search=term"
        ]
    },
    {
        "q": "Rearrange search implementation:",
        "type": "rearrange",
        "words": [
            "Parse search query",
            "Build filter criteria",
            "Execute search",
            "Sort results",
            "Paginate and return"
        ]
    },
    {
        "q": "Complex searches may use POST with request body.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of faceted search?",
        "type": "mcq",
        "o": [
            "Provide category counts for filtering",
            "Search multiple fields",
            "Full-text search",
            "Fuzzy matching"
        ]
    },
    {
        "q": "Match search features:",
        "type": "match",
        "left": [
            "Full-text",
            "Faceted",
            "Fuzzy",
            "Autocomplete"
        ],
        "right": [
            "Content search",
            "Category counts",
            "Approximate match",
            "Suggestions"
        ]
    },
    {
        "q": "The ______ query parameter typically contains the search term.",
        "type": "fill_blank",
        "answers": [
            "q"
        ],
        "other_options": [
            "search",
            "query",
            "term"
        ]
    },
    {
        "q": "Which approach handles field selection in REST?",
        "type": "mcq",
        "o": [
            "Query parameter like fields=id,name,email",
            "Different endpoints for each field set",
            "Always return all fields",
            "POST with field list in body"
        ]
    },
    {
        "q": "Rearrange partial response handling:",
        "type": "rearrange",
        "words": [
            "Parse fields parameter",
            "Validate requested fields",
            "Fetch full resource",
            "Filter fields",
            "Return partial response"
        ]
    },
    {
        "q": "Field selection reduces response payload size.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of resource expansion?",
        "type": "mcq",
        "o": [
            "Include related resources in the response",
            "Expand shortened URLs",
            "Increase response size limits",
            "Expand query parameters"
        ]
    },
    {
        "q": "Match response customization:",
        "type": "match",
        "left": [
            "Fields",
            "Expand",
            "Embed",
            "Include"
        ],
        "right": [
            "Limit properties",
            "Add related resources",
            "Inline nested data",
            "Reference additional data"
        ]
    },
    {
        "q": "The ______ parameter requests related resources inline.",
        "type": "fill_blank",
        "answers": [
            "expand"
        ],
        "other_options": [
            "include",
            "embed",
            "with"
        ]
    },
    {
        "q": "Which is the correct error response format?",
        "type": "mcq",
        "o": [
            "JSON with error code message and details",
            "Plain text error message",
            "HTML error page",
            "Empty response with status code only"
        ]
    },
    {
        "q": "Rearrange error handling flow:",
        "type": "rearrange",
        "words": [
            "Catch exception",
            "Map to error code",
            "Build error response",
            "Set status code",
            "Return response"
        ]
    },
    {
        "q": "Error responses should include machine-readable codes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should validation errors include?",
        "type": "mcq",
        "o": [
            "Field name and specific validation message",
            "Generic validation failed message",
            "Stack trace",
            "Only status code"
        ]
    },
    {
        "q": "Match error types with status codes:",
        "type": "match",
        "left": [
            "Validation error",
            "Not found",
            "Server error",
            "Rate limited"
        ],
        "right": [
            "400 or 422",
            "404",
            "500",
            "429"
        ]
    },
    {
        "q": "The ______ status code indicates unprocessable request body.",
        "type": "fill_blank",
        "answers": [
            "422"
        ],
        "other_options": [
            "400",
            "404",
            "500"
        ]
    },
    {
        "q": "Which approach handles API documentation?",
        "type": "mcq",
        "o": [
            "OpenAPI/Swagger specification",
            "README file only",
            "Inline code comments",
            "No documentation needed"
        ]
    },
    {
        "q": "Rearrange API documentation sections:",
        "type": "rearrange",
        "words": [
            "Overview",
            "Authentication",
            "Endpoints",
            "Examples",
            "Error codes"
        ]
    },
    {
        "q": "API documentation should include request and response examples.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is OpenAPI used for?",
        "type": "mcq",
        "o": [
            "Describe REST API structure and behavior",
            "Authenticate API users",
            "Rate limit API access",
            "Cache API responses"
        ]
    },
    {
        "q": "Match documentation tools:",
        "type": "match",
        "left": [
            "Swagger",
            "Postman",
            "Redoc",
            "Stoplight"
        ],
        "right": [
            "API spec and UI",
            "Collection testing",
            "Beautiful docs",
            "Visual API design"
        ]
    },
    {
        "q": "The ______ specification is used to document REST APIs.",
        "type": "fill_blank",
        "answers": [
            "OpenAPI"
        ],
        "other_options": [
            "WSDL",
            "RAML",
            "Blueprint"
        ]
    },
    {
        "q": "Which approach handles API testing?",
        "type": "mcq",
        "o": [
            "Automated tests for each endpoint",
            "Manual testing only",
            "No testing needed",
            "Client-side testing only"
        ]
    },
    {
        "q": "Rearrange test pyramid for APIs:",
        "type": "rearrange",
        "words": [
            "Unit tests",
            "Integration tests",
            "Contract tests",
            "End-to-end tests"
        ]
    },
    {
        "q": "Contract tests verify API consumer expectations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of mocking in API testing?",
        "type": "mcq",
        "o": [
            "Simulate external dependencies",
            "Speed up production API",
            "Validate request format",
            "Generate documentation"
        ]
    },
    {
        "q": "Match testing types:",
        "type": "match",
        "left": [
            "Unit test",
            "Integration test",
            "Contract test",
            "Load test"
        ],
        "right": [
            "Single component",
            "Multiple components",
            "Consumer agreement",
            "Performance"
        ]
    },
    {
        "q": "The ______ pattern uses saved responses for testing.",
        "type": "fill_blank",
        "answers": [
            "stubbing"
        ],
        "other_options": [
            "mocking",
            "faking",
            "spying"
        ]
    },
    {
        "q": "Which is the correct approach for API deprecation?",
        "type": "mcq",
        "o": [
            "Announce deprecation with sunset date and migration path",
            "Remove endpoint immediately",
            "Silently change behavior",
            "Never deprecate"
        ]
    },
    {
        "q": "Rearrange API deprecation process:",
        "type": "rearrange",
        "words": [
            "Announce deprecation",
            "Add deprecation headers",
            "Provide migration guide",
            "Monitor usage",
            "Remove endpoint"
        ]
    },
    {
        "q": "Deprecated endpoints should return warning headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What header indicates an API endpoint is deprecated?",
        "type": "mcq",
        "o": [
            "Deprecation or Sunset header",
            "Warning header only",
            "X-Deprecated header",
            "No standard header"
        ]
    },
    {
        "q": "Match deprecation stages:",
        "type": "match",
        "left": [
            "Active",
            "Deprecated",
            "Sunset",
            "Removed"
        ],
        "right": [
            "Fully supported",
            "Will be removed",
            "End of life date",
            "Not available"
        ]
    },
    {
        "q": "The ______ header indicates when an API will be removed.",
        "type": "fill_blank",
        "answers": [
            "Sunset"
        ],
        "other_options": [
            "Deprecation",
            "Expires",
            "End-Of-Life"
        ]
    },
    {
        "q": "Which approach handles API rate limiting?",
        "type": "mcq",
        "o": [
            "Token bucket or sliding window algorithm",
            "Random delay",
            "Block all requests",
            "No rate limiting"
        ]
    },
    {
        "q": "Rearrange rate limiting check:",
        "type": "rearrange",
        "words": [
            "Identify client",
            "Check current usage",
            "Compare to limit",
            "Allow or reject",
            "Update usage"
        ]
    },
    {
        "q": "Rate limits should be communicated in response headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What headers indicate rate limit status?",
        "type": "mcq",
        "o": [
            "X-RateLimit-Limit Remaining and Reset",
            "Rate-Limit only",
            "Retry-After only",
            "No standard headers"
        ]
    },
    {
        "q": "Match rate limiting algorithms:",
        "type": "match",
        "left": [
            "Token bucket",
            "Sliding window",
            "Fixed window",
            "Leaky bucket"
        ],
        "right": [
            "Token replenishment",
            "Rolling time frame",
            "Reset at interval",
            "Constant output rate"
        ]
    },
    {
        "q": "The ______ header tells clients when to retry after rate limiting.",
        "type": "fill_blank",
        "answers": [
            "Retry-After"
        ],
        "other_options": [
            "X-Retry-At",
            "Wait-Time",
            "Delay"
        ]
    },
    {
        "q": "Which approach handles input validation in REST?",
        "type": "mcq",
        "o": [
            "Validate all input with schema validation",
            "Trust client input",
            "Validate on client side only",
            "No validation needed"
        ]
    },
    {
        "q": "Rearrange validation flow:",
        "type": "rearrange",
        "words": [
            "Parse request body",
            "Validate against schema",
            "Check business rules",
            "Return errors or proceed"
        ]
    },
    {
        "q": "Input validation should happen server-side.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is JSON Schema used for?",
        "type": "mcq",
        "o": [
            "Define and validate JSON structure",
            "Compress JSON data",
            "Encrypt JSON data",
            "Style JSON responses"
        ]
    },
    {
        "q": "Match validation types:",
        "type": "match",
        "left": [
            "Format",
            "Type",
            "Range",
            "Pattern"
        ],
        "right": [
            "Email or URL",
            "String or number",
            "Min/max values",
            "Regex match"
        ]
    },
    {
        "q": "The ______ validation checks data format like email or URL.",
        "type": "fill_blank",
        "answers": [
            "format"
        ],
        "other_options": [
            "type",
            "pattern",
            "schema"
        ]
    },
    {
        "q": "Which approach handles request logging?",
        "type": "mcq",
        "o": [
            "Log request and response with correlation ID",
            "No logging",
            "Log only errors",
            "Log to console only"
        ]
    },
    {
        "q": "Rearrange logging best practices:",
        "type": "rearrange",
        "words": [
            "Generate request ID",
            "Log request details",
            "Process request",
            "Log response details",
            "Include timing"
        ]
    },
    {
        "q": "API logs should include correlation IDs for tracing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What should NOT be logged in API requests?",
        "type": "mcq",
        "o": [
            "Passwords and sensitive credentials",
            "Request URL",
            "Response status",
            "Request timestamp"
        ]
    },
    {
        "q": "Match logging levels:",
        "type": "match",
        "left": [
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR"
        ],
        "right": [
            "Detailed troubleshooting",
            "Normal operation",
            "Potential issues",
            "Failures"
        ]
    },
    {
        "q": "The ______ header propagates trace context across services.",
        "type": "fill_blank",
        "answers": [
            "X-Request-ID"
        ],
        "other_options": [
            "X-Trace",
            "X-Correlation",
            "Request-ID"
        ]
    },
    {
        "q": "Which is the correct approach for API monitoring?",
        "type": "mcq",
        "o": [
            "Track latency error rates and throughput",
            "Monitor only errors",
            "No monitoring needed",
            "Client-side monitoring only"
        ]
    },
    {
        "q": "Rearrange monitoring setup:",
        "type": "rearrange",
        "words": [
            "Define metrics",
            "Instrument endpoints",
            "Collect data",
            "Set alerts",
            "Create dashboards"
        ]
    },
    {
        "q": "API health checks should be automated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What endpoint is commonly used for health checks?",
        "type": "mcq",
        "o": [
            "/health or /status",
            "/api/check",
            "/ping/pong",
            "/monitoring"
        ]
    },
    {
        "q": "Match monitoring metrics:",
        "type": "match",
        "left": [
            "Latency",
            "Throughput",
            "Error rate",
            "Availability"
        ],
        "right": [
            "Response time",
            "Requests per second",
            "Failure percentage",
            "Uptime percentage"
        ]
    },
    {
        "q": "The ______ pattern checks if all dependencies are healthy.",
        "type": "fill_blank",
        "answers": [
            "health check"
        ],
        "other_options": [
            "ping",
            "heartbeat",
            "status"
        ]
    },
    {
        "q": "Which approach handles API security?",
        "type": "mcq",
        "o": [
            "Defense in depth with multiple security layers",
            "HTTPS only",
            "Authentication only",
            "No security needed for internal APIs"
        ]
    },
    {
        "q": "Rearrange security implementation:",
        "type": "rearrange",
        "words": [
            "Enable HTTPS",
            "Implement authentication",
            "Add authorization",
            "Validate input",
            "Rate limit"
        ]
    },
    {
        "q": "Internal APIs should also be secured.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the principle of least privilege?",
        "type": "mcq",
        "o": [
            "Grant only minimum required access",
            "Give admin access to all users",
            "Allow all requests by default",
            "Deny all requests by default"
        ]
    },
    {
        "q": "Match security concerns:",
        "type": "match",
        "left": [
            "Injection",
            "Broken auth",
            "Data exposure",
            "Rate limiting"
        ],
        "right": [
            "Input validation",
            "Strong authentication",
            "Encryption",
            "Throttling"
        ]
    },
    {
        "q": "The ______ security model checks permissions at each layer.",
        "type": "fill_blank",
        "answers": [
            "defense in depth"
        ],
        "other_options": [
            "perimeter",
            "zero trust",
            "castle and moat"
        ]
    },
    {
        "q": "Which HTTP header prevents XSS attacks?",
        "type": "mcq",
        "o": [
            "Content-Security-Policy",
            "X-Frame-Options",
            "X-Content-Type-Options",
            "Strict-Transport-Security"
        ]
    },
    {
        "q": "Match security headers:",
        "type": "match",
        "left": [
            "CSP",
            "HSTS",
            "X-Frame-Options",
            "X-Content-Type-Options"
        ],
        "right": [
            "Script sources",
            "Force HTTPS",
            "Clickjacking",
            "MIME sniffing"
        ]
    },
    {
        "q": "HTTPS should be enforced with the ______ header.",
        "type": "fill_blank",
        "answers": [
            "Strict-Transport-Security"
        ],
        "other_options": [
            "X-HTTPS-Only",
            "Force-SSL",
            "Secure-Transport"
        ]
    },
    {
        "q": "Which approach handles API key management?",
        "type": "mcq",
        "o": [
            "Secure storage with rotation and revocation",
            "Store in source code",
            "Share across environments",
            "Never rotate keys"
        ]
    },
    {
        "q": "Rearrange key management lifecycle:",
        "type": "rearrange",
        "words": [
            "Generate key",
            "Store securely",
            "Distribute safely",
            "Monitor usage",
            "Rotate periodically"
        ]
    },
    {
        "q": "API keys should be rotated regularly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of key scoping?",
        "type": "mcq",
        "o": [
            "Limit access to specific resources or actions",
            "Make keys longer",
            "Encrypt keys",
            "Share keys across services"
        ]
    },
    {
        "q": "Match key management practices:",
        "type": "match",
        "left": [
            "Rotation",
            "Revocation",
            "Scoping",
            "Expiration"
        ],
        "right": [
            "Regular key changes",
            "Immediate disable",
            "Limited access",
            "Time-based validity"
        ]
    },
    {
        "q": "Compromised API keys should be ______ immediately.",
        "type": "fill_blank",
        "answers": [
            "revoked"
        ],
        "other_options": [
            "rotated",
            "expired",
            "logged"
        ]
    },
    {
        "q": "Which OAuth flow is used for server-to-server?",
        "type": "mcq",
        "o": [
            "Client credentials flow",
            "Authorization code flow",
            "Implicit flow",
            "Resource owner password flow"
        ]
    },
    {
        "q": "Rearrange OAuth authorization code flow:",
        "type": "rearrange",
        "words": [
            "Redirect to auth server",
            "User authenticates",
            "Receive auth code",
            "Exchange for tokens",
            "Access resources"
        ]
    },
    {
        "q": "OAuth refresh tokens should be stored securely.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the purpose of OAuth scopes?",
        "type": "mcq",
        "o": [
            "Define permissions for access tokens",
            "Set token expiration",
            "Encrypt tokens",
            "Validate token format"
        ]
    },
    {
        "q": "Match OAuth components:",
        "type": "match",
        "left": [
            "Access token",
            "Refresh token",
            "ID token",
            "Authorization code"
        ],
        "right": [
            "API access",
            "Get new tokens",
            "User identity",
            "Exchange for tokens"
        ]
    },
    {
        "q": "OAuth tokens should have ______ lifetimes.",
        "type": "fill_blank",
        "answers": [
            "limited"
        ],
        "other_options": [
            "unlimited",
            "random",
            "fixed"
        ]
    },
    {
        "q": "Which is the correct JWT structure?",
        "type": "mcq",
        "o": [
            "Header.Payload.Signature",
            "Payload.Header.Signature",
            "Signature.Header.Payload",
            "Header.Signature.Payload"
        ]
    },
    {
        "q": "Rearrange JWT validation:",
        "type": "rearrange",
        "words": [
            "Decode token",
            "Verify signature",
            "Check expiration",
            "Validate claims",
            "Grant access"
        ]
    },
    {
        "q": "JWT tokens are self-contained and stateless.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What claim indicates JWT expiration?",
        "type": "mcq",
        "o": [
            "exp",
            "iat",
            "nbf",
            "ttl"
        ]
    },
    {
        "q": "Match JWT claims:",
        "type": "match",
        "left": [
            "iss",
            "sub",
            "aud",
            "exp"
        ],
        "right": [
            "Issuer",
            "Subject",
            "Audience",
            "Expiration"
        ]
    },
    {
        "q": "The ______ claim identifies the token issuer.",
        "type": "fill_blank",
        "answers": [
            "iss"
        ],
        "other_options": [
            "sub",
            "aud",
            "jti"
        ]
    },
    {
        "q": "Which encoding is used for JWT header and payload?",
        "type": "mcq",
        "o": [
            "Base64URL",
            "Base64",
            "Hex",
            "UTF-8"
        ]
    },
    {
        "q": "Match JWT signing algorithms:",
        "type": "match",
        "left": [
            "HS256",
            "RS256",
            "ES256",
            "none"
        ],
        "right": [
            "HMAC symmetric",
            "RSA asymmetric",
            "ECDSA asymmetric",
            "No signature"
        ]
    },
    {
        "q": "Never use the ______ algorithm in JWT production.",
        "type": "fill_blank",
        "answers": [
            "none"
        ],
        "other_options": [
            "HS256",
            "RS256",
            "ES256"
        ]
    },
    {
        "q": "Rearrange REST API design best practices:",
        "type": "rearrange",
        "words": [
            "Use nouns for resources",
            "Apply proper HTTP methods",
            "Return appropriate status codes",
            "Version your API",
            "Document thoroughly"
        ]
    },
    {
        "q": "REST APIs should follow consistent design patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which is the correct approach for collection filtering?",
        "type": "mcq",
        "o": [
            "Query parameters with clear naming",
            "URL path segments for each filter",
            "Request body for simple filters",
            "Headers for filtering"
        ]
    },
    {
        "q": "Match API design elements:",
        "type": "match",
        "left": [
            "Base URL",
            "Resource path",
            "Query params",
            "Fragment"
        ],
        "right": [
            "API domain",
            "Resource identifier",
            "Filtering/sorting",
            "Client-side only"
        ]
    },
    {
        "q": "The ______ separates resource path from query parameters.",
        "type": "fill_blank",
        "answers": [
            "?"
        ],
        "other_options": [
            "&",
            "/",
            "#"
        ]
    },
    {
        "q": "What is the output of this resource validator?",
        "type": "mcq",
        "c": "class ResourceValidator {\n    constructor(schema) {\n        this.schema = schema;\n    }\n    validate(resource) {\n        const errors = [];\n        for (const [field, rules] of Object.entries(this.schema)) {\n            if (rules.required && !resource[field]) {\n                errors.push({ field, message: 'Required field missing' });\n            }\n        }\n        return { valid: errors.length === 0, errors };\n    }\n}",
        "o": [
            "Schema validation with detailed error collection",
            "No validation logic",
            "Type checking only",
            "Length validation only"
        ]
    },
    {
        "q": "Which approach handles hypermedia links in REST?",
        "type": "mcq",
        "o": [
            "HAL or JSON-API format with embedded links",
            "Plain text links",
            "Links in headers only",
            "External link document"
        ]
    },
    {
        "q": "The ______ link relation indicates the collection a resource belongs to.",
        "type": "fill_blank",
        "answers": [
            "collection"
        ],
        "other_options": [
            "parent",
            "list",
            "index"
        ]
    },
    {
        "q": "Match HATEOAS link relations:",
        "type": "match",
        "left": [
            "self",
            "collection",
            "next",
            "edit"
        ],
        "right": [
            "Current resource",
            "Parent collection",
            "Next page",
            "Editable form"
        ]
    },
    {
        "q": "What is the output of this pagination handler?",
        "type": "mcq",
        "c": "class Paginator {\n    constructor(items, pageSize = 10) {\n        this.items = items;\n        this.pageSize = pageSize;\n    }\n    getPage(page) {\n        const start = (page - 1) * this.pageSize;\n        const end = start + this.pageSize;\n        return {\n            data: this.items.slice(start, end),\n            meta: {\n                total: this.items.length,\n                page,\n                pages: Math.ceil(this.items.length / this.pageSize)\n            }\n        };\n    }\n}",
        "o": [
            "Paginated response with metadata",
            "All items at once",
            "Single item only",
            "No pagination support"
        ]
    },
    {
        "q": "Cursor-based pagination is more efficient than offset for large datasets.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The ______ pagination approach uses encoded position tokens.",
        "type": "fill_blank",
        "answers": [
            "cursor"
        ],
        "other_options": [
            "offset",
            "page",
            "limit"
        ]
    },
    {
        "q": "Which is the correct cursor pagination response?",
        "type": "mcq",
        "o": [
            "Include next_cursor and previous_cursor tokens",
            "Include page numbers only",
            "Include total count only",
            "No pagination metadata"
        ]
    },
    {
        "q": "Match pagination strategies:",
        "type": "match",
        "left": [
            "Offset",
            "Cursor",
            "Keyset",
            "Time-based"
        ],
        "right": [
            "Skip and limit",
            "Encoded position",
            "Last seen key",
            "Timestamp range"
        ]
    },
    {
        "q": "Rearrange cursor pagination flow:",
        "type": "rearrange",
        "words": [
            "Request without cursor",
            "Return data with next_cursor",
            "Request with cursor",
            "Continue until no cursor"
        ]
    },
    {
        "q": "What is the output of this rate limiter?",
        "type": "mcq",
        "c": "class TokenBucket {\n    constructor(capacity, refillRate) {\n        this.capacity = capacity;\n        this.tokens = capacity;\n        this.refillRate = refillRate;\n        this.lastRefill = Date.now();\n    }\n    tryConsume(tokens = 1) {\n        this.refill();\n        if (this.tokens >= tokens) {\n            this.tokens -= tokens;\n            return true;\n        }\n        return false;\n    }\n    refill() {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000;\n        this.tokens = Math.min(this.capacity, this.tokens + elapsed * this.refillRate);\n        this.lastRefill = now;\n    }\n}",
        "o": [
            "Token bucket rate limiting with auto-refill",
            "Fixed window rate limiting",
            "No rate limiting",
            "Random delay limiting"
        ]
    },
    {
        "q": "Which header indicates rate limit reset time?",
        "type": "mcq",
        "o": [
            "X-RateLimit-Reset",
            "X-RateLimit-Remaining",
            "X-RateLimit-Limit",
            "Retry-After"
        ]
    },
    {
        "q": "The sliding window algorithm tracks requests in a ______ time frame.",
        "type": "fill_blank",
        "answers": [
            "rolling"
        ],
        "other_options": [
            "fixed",
            "random",
            "expanding"
        ]
    },
    {
        "q": "Match rate limiting responses:",
        "type": "match",
        "left": [
            "429",
            "Retry-After",
            "X-RateLimit-Remaining",
            "X-RateLimit-Reset"
        ],
        "right": [
            "Too many requests",
            "Wait duration",
            "Available requests",
            "Reset timestamp"
        ]
    },
    {
        "q": "What is the output of this circuit breaker?",
        "type": "mcq",
        "c": "class CircuitBreaker {\n    constructor(threshold = 5, timeout = 30000) {\n        this.failures = 0;\n        this.threshold = threshold;\n        this.timeout = timeout;\n        this.state = 'closed';\n        this.nextAttempt = 0;\n    }\n    async execute(fn) {\n        if (this.state === 'open' && Date.now() < this.nextAttempt) {\n            throw new Error('Circuit open');\n        }\n        try {\n            const result = await fn();\n            this.onSuccess();\n            return result;\n        } catch (e) {\n            this.onFailure();\n            throw e;\n        }\n    }\n}",
        "o": [
            "Circuit breaker preventing cascade failures",
            "Simple retry mechanism",
            "No failure handling",
            "Load balancer"
        ]
    },
    {
        "q": "Rearrange circuit breaker states:",
        "type": "rearrange",
        "words": [
            "Closed",
            "Half-open",
            "Open",
            "Back to closed or open"
        ]
    },
    {
        "q": "Circuit breakers prevent cascade failures in distributed systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The half-open state allows ______ requests to test recovery.",
        "type": "fill_blank",
        "answers": [
            "limited"
        ],
        "other_options": [
            "all",
            "no",
            "batch"
        ]
    },
    {
        "q": "Which pattern handles API retries?",
        "type": "mcq",
        "o": [
            "Exponential backoff with jitter",
            "Immediate retry",
            "Fixed delay retry",
            "No retry"
        ]
    },
    {
        "q": "Match resilience patterns:",
        "type": "match",
        "left": [
            "Circuit breaker",
            "Retry",
            "Bulkhead",
            "Timeout"
        ],
        "right": [
            "Fail fast",
            "Try again",
            "Isolate resources",
            "Limit wait time"
        ]
    },
    {
        "q": "What is the output of this request retry handler?",
        "type": "mcq",
        "c": "async function retryWithBackoff(fn, maxRetries = 3) {\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n            return await fn();\n        } catch (e) {\n            if (attempt === maxRetries) throw e;\n            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;\n            await new Promise(r => setTimeout(r, delay));\n        }\n    }\n}",
        "o": [
            "Exponential backoff with jitter",
            "Linear retry",
            "No retry",
            "Immediate retry"
        ]
    },
    {
        "q": "Jitter in retries prevents the ______ effect.",
        "type": "fill_blank",
        "answers": [
            "thundering herd"
        ],
        "other_options": [
            "retry storm",
            "cascade",
            "deadlock"
        ]
    },
    {
        "q": "Rearrange retry backoff calculation:",
        "type": "rearrange",
        "words": [
            "Calculate base delay",
            "Apply exponential factor",
            "Add random jitter",
            "Wait before retry"
        ]
    },
    {
        "q": "Which approach handles API response caching?",
        "type": "mcq",
        "o": [
            "Cache-Control headers with appropriate directives",
            "No caching headers",
            "Cache everything forever",
            "Disable all caching"
        ]
    },
    {
        "q": "Match caching strategies:",
        "type": "match",
        "left": [
            "Stale-while-revalidate",
            "Cache-aside",
            "Write-through",
            "Read-through"
        ],
        "right": [
            "Serve stale during refresh",
            "App manages cache",
            "Write to both",
            "Load on miss"
        ]
    },
    {
        "q": "The stale-while-revalidate directive serves ______ content during refresh.",
        "type": "fill_blank",
        "answers": [
            "stale"
        ],
        "other_options": [
            "fresh",
            "expired",
            "new"
        ]
    },
    {
        "q": "What is the output of this cache manager?",
        "type": "mcq",
        "c": "class CacheManager {\n    constructor(ttl = 3600) {\n        this.cache = new Map();\n        this.ttl = ttl * 1000;\n    }\n    get(key) {\n        const entry = this.cache.get(key);\n        if (!entry) return null;\n        if (Date.now() > entry.expires) {\n            this.cache.delete(key);\n            return null;\n        }\n        return entry.value;\n    }\n    set(key, value) {\n        this.cache.set(key, { value, expires: Date.now() + this.ttl });\n    }\n}",
        "o": [
            "TTL-based cache with expiration check",
            "Permanent cache",
            "No cache logic",
            "LRU cache"
        ]
    },
    {
        "q": "Rearrange cache invalidation strategies:",
        "type": "rearrange",
        "words": [
            "Time-based expiration",
            "Event-based invalidation",
            "Manual purge",
            "Version-based refresh"
        ]
    },
    {
        "q": "Cache invalidation is one of the hard problems in computer science.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API versioning evolution?",
        "type": "mcq",
        "o": [
            "Semantic versioning with deprecation notices",
            "Random version numbers",
            "No versioning",
            "Date-based naming only"
        ]
    },
    {
        "q": "The ______ principle allows backward-compatible additions.",
        "type": "fill_blank",
        "answers": [
            "additive"
        ],
        "other_options": [
            "subtractive",
            "breaking",
            "neutral"
        ]
    },
    {
        "q": "Match version change types:",
        "type": "match",
        "left": [
            "Major",
            "Minor",
            "Patch",
            "Pre-release"
        ],
        "right": [
            "Breaking changes",
            "New features",
            "Bug fixes",
            "Testing version"
        ]
    },
    {
        "q": "What is the output of this version negotiator?",
        "type": "mcq",
        "c": "class VersionNegotiator {\n    constructor(supportedVersions) {\n        this.versions = supportedVersions;\n    }\n    negotiate(requested) {\n        if (this.versions.includes(requested)) return requested;\n        const parts = requested.split('.');\n        const major = parts[0];\n        const compatible = this.versions.filter(v => v.startsWith(major + '.')).sort().pop();\n        return compatible || this.versions[this.versions.length - 1];\n    }\n}",
        "o": [
            "Version fallback with compatibility matching",
            "Exact version only",
            "Latest version always",
            "No version negotiation"
        ]
    },
    {
        "q": "Rearrange API version evolution:",
        "type": "rearrange",
        "words": [
            "Design new version",
            "Implement changes",
            "Deploy alongside old",
            "Migrate consumers",
            "Deprecate old version"
        ]
    },
    {
        "q": "Breaking changes require a major version bump.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API error standardization?",
        "type": "mcq",
        "o": [
            "RFC 7807 Problem Details for HTTP APIs",
            "Custom error format",
            "Plain text errors",
            "Status code only"
        ]
    },
    {
        "q": "The ______ field in Problem Details indicates the error type.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "title",
            "detail",
            "status"
        ]
    },
    {
        "q": "Match Problem Details fields:",
        "type": "match",
        "left": [
            "type",
            "title",
            "status",
            "detail"
        ],
        "right": [
            "Error type URI",
            "Short summary",
            "HTTP status",
            "Specific explanation"
        ]
    },
    {
        "q": "What is the output of this error formatter?",
        "type": "mcq",
        "c": "class ProblemDetails {\n    static create(status, title, detail, type = 'about:blank') {\n        return {\n            type,\n            title,\n            status,\n            detail,\n            instance: `/errors/${Date.now()}`\n        };\n    }\n}\nconsole.log(Object.keys(ProblemDetails.create(400, 'Bad Request', 'Invalid input')).length);",
        "o": [
            "5",
            "4",
            "3",
            "6"
        ]
    },
    {
        "q": "Rearrange error response creation:",
        "type": "rearrange",
        "words": [
            "Catch exception",
            "Determine status code",
            "Format error body",
            "Add trace ID",
            "Return response"
        ]
    },
    {
        "q": "Error responses should include correlation IDs for debugging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request throttling?",
        "type": "mcq",
        "o": [
            "Priority queuing with fair scheduling",
            "FIFO only",
            "Random processing",
            "No throttling"
        ]
    },
    {
        "q": "The ______ pattern limits concurrent requests to a resource.",
        "type": "fill_blank",
        "answers": [
            "bulkhead"
        ],
        "other_options": [
            "throttle",
            "queue",
            "buffer"
        ]
    },
    {
        "q": "Match throttling techniques:",
        "type": "match",
        "left": [
            "Rate limiting",
            "Concurrency limiting",
            "Queue depth",
            "Load shedding"
        ],
        "right": [
            "Requests per time",
            "Simultaneous requests",
            "Pending requests",
            "Dropping excess"
        ]
    },
    {
        "q": "What is the output of this concurrency limiter?",
        "type": "mcq",
        "c": "class Semaphore {\n    constructor(limit) {\n        this.limit = limit;\n        this.current = 0;\n        this.queue = [];\n    }\n    async acquire() {\n        if (this.current < this.limit) {\n            this.current++;\n            return true;\n        }\n        return new Promise(resolve => this.queue.push(resolve));\n    }\n    release() {\n        this.current--;\n        if (this.queue.length > 0) {\n            this.current++;\n            this.queue.shift()(true);\n        }\n    }\n}",
        "o": [
            "Semaphore-based concurrency limiting",
            "Unlimited concurrency",
            "No queue handling",
            "Fixed delay"
        ]
    },
    {
        "q": "Rearrange load shedding priority:",
        "type": "rearrange",
        "words": [
            "VIP requests",
            "Authenticated requests",
            "Anonymous requests",
            "Health checks",
            "Monitoring"
        ]
    },
    {
        "q": "Load shedding protects services under extreme load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles content negotiation?",
        "type": "mcq",
        "o": [
            "Accept header with quality values",
            "Query parameter only",
            "URL extension only",
            "Fixed format"
        ]
    },
    {
        "q": "The ______ quality value indicates preference strength.",
        "type": "fill_blank",
        "answers": [
            "q"
        ],
        "other_options": [
            "p",
            "v",
            "w"
        ]
    },
    {
        "q": "Match content negotiation headers:",
        "type": "match",
        "left": [
            "Accept",
            "Accept-Language",
            "Accept-Encoding",
            "Accept-Charset"
        ],
        "right": [
            "Media type",
            "Language",
            "Compression",
            "Character set"
        ]
    },
    {
        "q": "What is the output of this content negotiator?",
        "type": "mcq",
        "c": "function negotiate(accept, supported) {\n    const types = accept.split(',').map(t => {\n        const [type, ...params] = t.trim().split(';');\n        const q = params.find(p => p.startsWith('q='));\n        return { type, q: q ? parseFloat(q.split('=')[1]) : 1 };\n    }).sort((a, b) => b.q - a.q);\n    return types.find(t => supported.includes(t.type))?.type || null;\n}\nconsole.log(negotiate('text/html, application/json;q=0.9', ['application/json']));",
        "o": [
            "application/json",
            "text/html",
            "null",
            "undefined"
        ]
    },
    {
        "q": "Rearrange content negotiation process:",
        "type": "rearrange",
        "words": [
            "Parse Accept header",
            "Extract quality values",
            "Sort by preference",
            "Match against supported",
            "Return best match"
        ]
    },
    {
        "q": "Content negotiation allows serving different formats from the same URL.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request validation?",
        "type": "mcq",
        "o": [
            "JSON Schema validation with custom error messages",
            "No validation",
            "Client-side only",
            "Basic type checking"
        ]
    },
    {
        "q": "The ______ keyword in JSON Schema requires all specified properties.",
        "type": "fill_blank",
        "answers": [
            "required"
        ],
        "other_options": [
            "mandatory",
            "needed",
            "must"
        ]
    },
    {
        "q": "Match JSON Schema keywords:",
        "type": "match",
        "left": [
            "type",
            "required",
            "properties",
            "additionalProperties"
        ],
        "right": [
            "Data type",
            "Mandatory fields",
            "Object structure",
            "Extra fields allowed"
        ]
    },
    {
        "q": "What is the output of this schema validator?",
        "type": "mcq",
        "c": "const schema = {\n    type: 'object',\n    required: ['name', 'email'],\n    properties: {\n        name: { type: 'string', minLength: 1 },\n        email: { type: 'string', format: 'email' }\n    }\n};\n// Validates { name: 'John', email: 'john@example.com' }",
        "o": [
            "Valid - all required fields present with correct types",
            "Invalid - missing fields",
            "Invalid - wrong types",
            "No validation performed"
        ]
    },
    {
        "q": "Rearrange validation error response:",
        "type": "rearrange",
        "words": [
            "Status 400 or 422",
            "Error type field",
            "Field-specific messages",
            "Invalid value details"
        ]
    },
    {
        "q": "Schema validation should happen before business logic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request compression?",
        "type": "mcq",
        "o": [
            "Content-Encoding with gzip or brotli",
            "No compression support",
            "Client-side compression only",
            "ZIP file format"
        ]
    },
    {
        "q": "The ______ encoding provides better compression than gzip.",
        "type": "fill_blank",
        "answers": [
            "br (brotli)"
        ],
        "other_options": [
            "deflate",
            "compress",
            "lz4"
        ]
    },
    {
        "q": "Match compression headers:",
        "type": "match",
        "left": [
            "Accept-Encoding",
            "Content-Encoding",
            "Transfer-Encoding",
            "Vary"
        ],
        "right": [
            "Client preference",
            "Response encoding",
            "Chunked transfer",
            "Cache variation"
        ]
    },
    {
        "q": "Which is the correct way to request compressed content?",
        "type": "mcq",
        "o": [
            "Accept-Encoding: gzip, deflate, br",
            "Content-Encoding: gzip",
            "Compress: true",
            "X-Compression: enabled"
        ]
    },
    {
        "q": "Rearrange compression handling:",
        "type": "rearrange",
        "words": [
            "Check Accept-Encoding",
            "Compress response",
            "Set Content-Encoding",
            "Set Vary header",
            "Send response"
        ]
    },
    {
        "q": "Vary header should include Accept-Encoding for cached compressed responses.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response streaming?",
        "type": "mcq",
        "o": [
            "Chunked transfer encoding with event streams",
            "Single large response",
            "Multiple small requests",
            "WebSocket only"
        ]
    },
    {
        "q": "The ______ content type is used for server-sent events.",
        "type": "fill_blank",
        "answers": [
            "text/event-stream"
        ],
        "other_options": [
            "application/stream",
            "text/stream",
            "application/events"
        ]
    },
    {
        "q": "Match streaming patterns:",
        "type": "match",
        "left": [
            "SSE",
            "WebSocket",
            "Chunked",
            "gRPC streaming"
        ],
        "right": [
            "Server push events",
            "Bidirectional",
            "HTTP chunks",
            "Protocol buffers"
        ]
    },
    {
        "q": "What is the output of this stream handler?",
        "type": "mcq",
        "c": "function* generateEvents() {\n    yield 'event: message\\n';\n    yield 'data: {\"type\":\"update\"}\\n\\n';\n    yield 'event: ping\\n';\n    yield 'data: {}\\n\\n';\n}",
        "o": [
            "Server-sent events format with event types",
            "Plain text stream",
            "JSON stream",
            "Binary stream"
        ]
    },
    {
        "q": "Rearrange SSE event format:",
        "type": "rearrange",
        "words": [
            "event: type",
            "id: identifier",
            "data: payload",
            "retry: milliseconds",
            "Empty line"
        ]
    },
    {
        "q": "Server-sent events support automatic reconnection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API transaction handling?",
        "type": "mcq",
        "o": [
            "Saga pattern with compensating transactions",
            "Distributed locks",
            "Two-phase commit everywhere",
            "No transaction support"
        ]
    },
    {
        "q": "The ______ pattern handles distributed transaction failures with rollbacks.",
        "type": "fill_blank",
        "answers": [
            "saga"
        ],
        "other_options": [
            "two-phase",
            "chain",
            "pipeline"
        ]
    },
    {
        "q": "Match transaction patterns:",
        "type": "match",
        "left": [
            "Saga",
            "TCC",
            "Outbox",
            "Idempotency"
        ],
        "right": [
            "Compensating actions",
            "Try-Confirm-Cancel",
            "Event publishing",
            "Duplicate handling"
        ]
    },
    {
        "q": "What is the output of this saga coordinator?",
        "type": "mcq",
        "c": "class SagaCoordinator {\n    constructor(steps) {\n        this.steps = steps;\n        this.completed = [];\n    }\n    async execute() {\n        for (const step of this.steps) {\n            try {\n                await step.execute();\n                this.completed.push(step);\n            } catch (e) {\n                await this.compensate();\n                throw e;\n            }\n        }\n    }\n    async compensate() {\n        for (const step of this.completed.reverse()) {\n            await step.compensate();\n        }\n    }\n}",
        "o": [
            "Saga with automatic compensation on failure",
            "No rollback support",
            "All-or-nothing transaction",
            "Eventually consistent only"
        ]
    },
    {
        "q": "Rearrange saga execution:",
        "type": "rearrange",
        "words": [
            "Execute step",
            "Record completion",
            "On failure compensate",
            "Rollback completed",
            "Report outcome"
        ]
    },
    {
        "q": "Sagas provide eventual consistency in distributed systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API audit logging?",
        "type": "mcq",
        "o": [
            "Immutable audit log with user and action metadata",
            "Regular application logs",
            "No audit trail",
            "Client-side logging"
        ]
    },
    {
        "q": "The ______ field identifies who performed an action.",
        "type": "fill_blank",
        "answers": [
            "actor"
        ],
        "other_options": [
            "user",
            "subject",
            "agent"
        ]
    },
    {
        "q": "Match audit log fields:",
        "type": "match",
        "left": [
            "actor",
            "action",
            "resource",
            "timestamp"
        ],
        "right": [
            "Who performed",
            "What was done",
            "What was affected",
            "When it happened"
        ]
    },
    {
        "q": "What is the output of this audit logger?",
        "type": "mcq",
        "c": "class AuditLogger {\n    constructor(store) {\n        this.store = store;\n    }\n    log(entry) {\n        return this.store.append({\n            ...entry,\n            id: crypto.randomUUID(),\n            timestamp: new Date().toISOString(),\n            version: 1\n        });\n    }\n}",
        "o": [
            "Immutable audit entry with UUID and timestamp",
            "Mutable log entry",
            "No timestamp tracking",
            "Overwritable logs"
        ]
    },
    {
        "q": "Rearrange audit log requirements:",
        "type": "rearrange",
        "words": [
            "Capture all changes",
            "Record actor identity",
            "Preserve timestamps",
            "Ensure immutability",
            "Enable querying"
        ]
    },
    {
        "q": "Audit logs should be tamper-proof.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API metric collection?",
        "type": "mcq",
        "o": [
            "Prometheus-style metrics with labels",
            "Log file analysis only",
            "Manual counting",
            "No metrics"
        ]
    },
    {
        "q": "The ______ metric type tracks rates over time.",
        "type": "fill_blank",
        "answers": [
            "counter"
        ],
        "other_options": [
            "gauge",
            "histogram",
            "summary"
        ]
    },
    {
        "q": "Match metric types:",
        "type": "match",
        "left": [
            "Counter",
            "Gauge",
            "Histogram",
            "Summary"
        ],
        "right": [
            "Monotonic total",
            "Current value",
            "Value distribution",
            "Percentiles"
        ]
    },
    {
        "q": "What is the output of this metrics collector?",
        "type": "mcq",
        "c": "class MetricsCollector {\n    constructor() {\n        this.counters = new Map();\n        this.histograms = new Map();\n    }\n    increment(name, labels = {}) {\n        const key = this.makeKey(name, labels);\n        this.counters.set(key, (this.counters.get(key) || 0) + 1);\n    }\n    observe(name, value, labels = {}) {\n        const key = this.makeKey(name, labels);\n        if (!this.histograms.has(key)) this.histograms.set(key, []);\n        this.histograms.get(key).push(value);\n    }\n}",
        "o": [
            "Counter and histogram metrics with labels",
            "Only counters",
            "Only histograms",
            "No metric collection"
        ]
    },
    {
        "q": "Rearrange metrics pipeline:",
        "type": "rearrange",
        "words": [
            "Instrument code",
            "Collect metrics",
            "Aggregate data",
            "Export to backend",
            "Visualize dashboards"
        ]
    },
    {
        "q": "Histograms are useful for latency measurements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API distributed tracing?",
        "type": "mcq",
        "o": [
            "OpenTelemetry with trace context propagation",
            "Log correlation only",
            "Single service tracing",
            "No tracing"
        ]
    },
    {
        "q": "The ______ header propagates trace context across services.",
        "type": "fill_blank",
        "answers": [
            "traceparent"
        ],
        "other_options": [
            "X-Trace-ID",
            "Trace-Context",
            "Span-ID"
        ]
    },
    {
        "q": "Match tracing concepts:",
        "type": "match",
        "left": [
            "Trace",
            "Span",
            "Context",
            "Baggage"
        ],
        "right": [
            "Full request path",
            "Single operation",
            "Propagated state",
            "Custom values"
        ]
    },
    {
        "q": "What is the output of this span creator?",
        "type": "mcq",
        "c": "class Tracer {\n    constructor(serviceName) {\n        this.serviceName = serviceName;\n    }\n    startSpan(operationName, parentContext = null) {\n        return {\n            traceId: parentContext?.traceId || this.generateId(),\n            spanId: this.generateId(),\n            parentSpanId: parentContext?.spanId,\n            operationName,\n            startTime: Date.now(),\n            tags: { service: this.serviceName }\n        };\n    }\n}",
        "o": [
            "Span with trace and parent context",
            "Isolated span only",
            "No trace correlation",
            "Log entry only"
        ]
    },
    {
        "q": "Rearrange distributed trace flow:",
        "type": "rearrange",
        "words": [
            "Create root span",
            "Propagate context",
            "Create child spans",
            "Record timings",
            "Export traces"
        ]
    },
    {
        "q": "Distributed tracing helps identify latency bottlenecks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API contract testing?",
        "type": "mcq",
        "o": [
            "Consumer-driven contract tests with Pact",
            "Integration tests only",
            "Manual testing",
            "No contract testing"
        ]
    },
    {
        "q": "The ______ party publishes the API contract in CDC.",
        "type": "fill_blank",
        "answers": [
            "consumer"
        ],
        "other_options": [
            "provider",
            "broker",
            "tester"
        ]
    },
    {
        "q": "Match CDC testing phases:",
        "type": "match",
        "left": [
            "Consumer tests",
            "Pact file",
            "Provider verification",
            "Pact broker"
        ],
        "right": [
            "Define expectations",
            "Contract artifact",
            "Validate against contract",
            "Store and share"
        ]
    },
    {
        "q": "Rearrange CDC workflow:",
        "type": "rearrange",
        "words": [
            "Consumer writes expectations",
            "Generate pact file",
            "Publish to broker",
            "Provider verifies",
            "Deploy with confidence"
        ]
    },
    {
        "q": "Contract tests catch breaking changes before deployment.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API feature flags?",
        "type": "mcq",
        "o": [
            "Dynamic feature toggles with user targeting",
            "Toggle in code only",
            "Environment variables only",
            "No feature flags"
        ]
    },
    {
        "q": "The ______ pattern allows gradual feature rollout.",
        "type": "fill_blank",
        "answers": [
            "progressive rollout"
        ],
        "other_options": [
            "big bang",
            "instant deploy",
            "full release"
        ]
    },
    {
        "q": "Match feature flag types:",
        "type": "match",
        "left": [
            "Release toggle",
            "Experiment toggle",
            "Ops toggle",
            "Permission toggle"
        ],
        "right": [
            "Gradual rollout",
            "A/B testing",
            "System behavior",
            "User access"
        ]
    },
    {
        "q": "What is the output of this feature flag evaluator?",
        "type": "mcq",
        "c": "class FeatureFlags {\n    constructor(config) {\n        this.flags = config;\n    }\n    isEnabled(flagName, context = {}) {\n        const flag = this.flags[flagName];\n        if (!flag) return false;\n        if (flag.enabled === false) return false;\n        if (flag.users?.includes(context.userId)) return true;\n        if (flag.percentage) {\n            return this.hash(context.userId) < flag.percentage;\n        }\n        return flag.enabled;\n    }\n}",
        "o": [
            "User and percentage-based feature targeting",
            "Boolean flags only",
            "No user targeting",
            "Random selection"
        ]
    },
    {
        "q": "Rearrange feature flag lifecycle:",
        "type": "rearrange",
        "words": [
            "Define flag",
            "Deploy with flag off",
            "Enable for testing",
            "Gradual rollout",
            "Remove flag"
        ]
    },
    {
        "q": "Feature flags should be cleaned up after full rollout.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request deduplication?",
        "type": "mcq",
        "o": [
            "Idempotency keys with server-side storage",
            "Client-side only",
            "No deduplication",
            "Timestamp-based"
        ]
    },
    {
        "q": "The ______ header contains the client-provided deduplication key.",
        "type": "fill_blank",
        "answers": [
            "Idempotency-Key"
        ],
        "other_options": [
            "X-Request-ID",
            "Dedup-Key",
            "Request-Token"
        ]
    },
    {
        "q": "Match idempotency strategies:",
        "type": "match",
        "left": [
            "Client key",
            "Content hash",
            "Request ID",
            "Time-based"
        ],
        "right": [
            "Client-provided",
            "Body fingerprint",
            "Unique identifier",
            "Timestamp window"
        ]
    },
    {
        "q": "What is the output of this idempotency handler?",
        "type": "mcq",
        "c": "class IdempotencyStore {\n    constructor(ttl = 24 * 3600) {\n        this.store = new Map();\n        this.ttl = ttl * 1000;\n    }\n    async processRequest(key, handler) {\n        const cached = this.store.get(key);\n        if (cached && Date.now() < cached.expires) {\n            return cached.response;\n        }\n        const response = await handler();\n        this.store.set(key, { response, expires: Date.now() + this.ttl });\n        return response;\n    }\n}",
        "o": [
            "Cache and return previous response for duplicate requests",
            "Process all requests",
            "Reject duplicates",
            "No caching"
        ]
    },
    {
        "q": "Rearrange idempotency flow:",
        "type": "rearrange",
        "words": [
            "Receive request with key",
            "Check for existing response",
            "If found return cached",
            "If new process and store",
            "Return response"
        ]
    },
    {
        "q": "Idempotency is critical for financial transactions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request queuing?",
        "type": "mcq",
        "o": [
            "Message queue with async processing",
            "Synchronous processing only",
            "Drop excess requests",
            "No queuing"
        ]
    },
    {
        "q": "The ______ pattern processes requests in order.",
        "type": "fill_blank",
        "answers": [
            "FIFO"
        ],
        "other_options": [
            "LIFO",
            "random",
            "priority"
        ]
    },
    {
        "q": "Match queue patterns:",
        "type": "match",
        "left": [
            "Work queue",
            "Pub/sub",
            "Priority queue",
            "Delayed queue"
        ],
        "right": [
            "Worker processing",
            "Multiple subscribers",
            "Ordered by importance",
            "Future execution"
        ]
    },
    {
        "q": "What is the output of this request queue?",
        "type": "mcq",
        "c": "class RequestQueue {\n    constructor(maxSize = 1000) {\n        this.queue = [];\n        this.maxSize = maxSize;\n    }\n    enqueue(request) {\n        if (this.queue.length >= this.maxSize) {\n            return { accepted: false, reason: 'Queue full' };\n        }\n        this.queue.push({ request, timestamp: Date.now() });\n        return { accepted: true, position: this.queue.length };\n    }\n    dequeue() {\n        return this.queue.shift();\n    }\n}",
        "o": [
            "Bounded queue with size limit",
            "Unlimited queue",
            "No queue management",
            "Stack (LIFO)"
        ]
    },
    {
        "q": "Rearrange async processing pattern:",
        "type": "rearrange",
        "words": [
            "Accept request",
            "Queue for processing",
            "Return 202 Accepted",
            "Process async",
            "Notify completion"
        ]
    },
    {
        "q": "Dead letter queues store failed messages for inspection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API load balancing?",
        "type": "mcq",
        "o": [
            "Round-robin or weighted distribution",
            "Single server only",
            "Random selection",
            "Client-side balancing only"
        ]
    },
    {
        "q": "The ______ algorithm directs requests to the least busy server.",
        "type": "fill_blank",
        "answers": [
            "least connections"
        ],
        "other_options": [
            "round robin",
            "random",
            "weighted"
        ]
    },
    {
        "q": "Match load balancing algorithms:",
        "type": "match",
        "left": [
            "Round robin",
            "Least connections",
            "Weighted",
            "IP hash"
        ],
        "right": [
            "Equal distribution",
            "Lowest load",
            "Capacity-based",
            "Session affinity"
        ]
    },
    {
        "q": "Health checks ensure unhealthy servers are removed from the pool.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange load balancer health check:",
        "type": "rearrange",
        "words": [
            "Send health request",
            "Wait for response",
            "Check status code",
            "Update server state",
            "Remove if unhealthy"
        ]
    },
    {
        "q": "Which approach handles API request routing?",
        "type": "mcq",
        "o": [
            "Path-based routing with regex patterns",
            "Single route only",
            "Query parameter routing",
            "Header-only routing"
        ]
    },
    {
        "q": "The ______ pattern routes requests based on content.",
        "type": "fill_blank",
        "answers": [
            "content-based routing"
        ],
        "other_options": [
            "round robin",
            "random",
            "fixed"
        ]
    },
    {
        "q": "Match routing strategies:",
        "type": "match",
        "left": [
            "Path-based",
            "Host-based",
            "Header-based",
            "Method-based"
        ],
        "right": [
            "URL path patterns",
            "Domain routing",
            "Custom headers",
            "HTTP method"
        ]
    },
    {
        "q": "API gateways can route to different backends.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange gateway routing:",
        "type": "rearrange",
        "words": [
            "Receive request",
            "Match route pattern",
            "Apply transformations",
            "Forward to backend",
            "Return response"
        ]
    },
    {
        "q": "Which approach handles API request transformation?",
        "type": "mcq",
        "o": [
            "Request and response modification at gateway",
            "No transformation",
            "Client-side only",
            "Backend only"
        ]
    },
    {
        "q": "The ______ pattern converts request format between protocols.",
        "type": "fill_blank",
        "answers": [
            "protocol translation"
        ],
        "other_options": [
            "format conversion",
            "data mapping",
            "type casting"
        ]
    },
    {
        "q": "Match transformation types:",
        "type": "match",
        "left": [
            "Header injection",
            "Body transformation",
            "URL rewrite",
            "Protocol translation"
        ],
        "right": [
            "Add/modify headers",
            "Change payload format",
            "Modify path",
            "REST to gRPC"
        ]
    },
    {
        "q": "Request transformation can add authentication headers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange request transformation pipeline:",
        "type": "rearrange",
        "words": [
            "Parse incoming request",
            "Apply header changes",
            "Transform body",
            "Rewrite URL",
            "Forward to backend"
        ]
    },
    {
        "q": "Which approach handles microservices discovery?",
        "type": "mcq",
        "o": [
            "Service registry with health-based discovery",
            "Hardcoded URLs",
            "DNS only",
            "Manual configuration"
        ]
    },
    {
        "q": "The ______ pattern maintains a list of available service instances.",
        "type": "fill_blank",
        "answers": [
            "service registry"
        ],
        "other_options": [
            "load balancer",
            "API gateway",
            "config server"
        ]
    },
    {
        "q": "Match service discovery patterns:",
        "type": "match",
        "left": [
            "Client-side",
            "Server-side",
            "Self-registration",
            "Third-party registration"
        ],
        "right": [
            "Client queries registry",
            "Load balancer queries",
            "Service registers itself",
            "External agent registers"
        ]
    },
    {
        "q": "Service instances should deregister on shutdown.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange service registration:",
        "type": "rearrange",
        "words": [
            "Service starts",
            "Register with registry",
            "Send heartbeats",
            "Handle requests",
            "Deregister on shutdown"
        ]
    },
    {
        "q": "Which approach handles API blue-green deployment?",
        "type": "mcq",
        "o": [
            "Two identical environments with traffic switching",
            "Single environment updates",
            "Rolling updates only",
            "Downtime deployment"
        ]
    },
    {
        "q": "The ______ environment receives the new deployment first.",
        "type": "fill_blank",
        "answers": [
            "green"
        ],
        "other_options": [
            "blue",
            "staging",
            "production"
        ]
    },
    {
        "q": "Match deployment strategies:",
        "type": "match",
        "left": [
            "Blue-green",
            "Canary",
            "Rolling",
            "Recreate"
        ],
        "right": [
            "Full environment swap",
            "Gradual traffic shift",
            "Instance by instance",
            "All at once"
        ]
    },
    {
        "q": "Blue-green deployments enable instant rollback.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange blue-green deployment:",
        "type": "rearrange",
        "words": [
            "Deploy to green",
            "Test green environment",
            "Switch traffic to green",
            "Monitor for issues",
            "Retire blue"
        ]
    },
    {
        "q": "Which approach handles API canary releases?",
        "type": "mcq",
        "o": [
            "Gradual traffic percentage increase with monitoring",
            "Instant 100% traffic",
            "Feature flags only",
            "A/B testing only"
        ]
    },
    {
        "q": "The ______ metric determines canary success.",
        "type": "fill_blank",
        "answers": [
            "error rate"
        ],
        "other_options": [
            "requests",
            "users",
            "time"
        ]
    },
    {
        "q": "Match canary stages:",
        "type": "match",
        "left": [
            "1% traffic",
            "10% traffic",
            "50% traffic",
            "100% traffic"
        ],
        "right": [
            "Initial test",
            "Small group",
            "Majority",
            "Full rollout"
        ]
    },
    {
        "q": "Canary deployments catch issues before full rollout.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange canary release process:",
        "type": "rearrange",
        "words": [
            "Deploy canary",
            "Route 1% traffic",
            "Monitor metrics",
            "Increase percentage",
            "Complete rollout"
        ]
    },
    {
        "q": "Which REST API documentation approach is most comprehensive?",
        "type": "mcq",
        "o": [
            "OpenAPI specification with examples and schemas",
            "README only",
            "Code comments",
            "Wiki pages"
        ]
    },
    {
        "q": "The ______ section in OpenAPI describes endpoint inputs.",
        "type": "fill_blank",
        "answers": [
            "parameters"
        ],
        "other_options": [
            "responses",
            "schemas",
            "security"
        ]
    },
    {
        "q": "Match OpenAPI sections:",
        "type": "match",
        "left": [
            "paths",
            "components",
            "security",
            "servers"
        ],
        "right": [
            "Endpoints",
            "Reusable schemas",
            "Authentication",
            "Base URLs"
        ]
    },
    {
        "q": "OpenAPI can generate client SDKs automatically.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Rearrange API-first development:",
        "type": "rearrange",
        "words": [
            "Design API spec",
            "Review and iterate",
            "Generate server stubs",
            "Implement logic",
            "Generate client SDKs"
        ]
    },
    {
        "q": "Which approach handles REST API testing automation?",
        "type": "mcq",
        "o": [
            "CI/CD pipeline with automated test suites",
            "Manual testing only",
            "Production testing",
            "No testing"
        ]
    },
    {
        "q": "The ______ test type validates API contracts.",
        "type": "fill_blank",
        "answers": [
            "contract"
        ],
        "other_options": [
            "unit",
            "load",
            "security"
        ]
    },
    {
        "q": "Match test automation layers:",
        "type": "match",
        "left": [
            "Unit tests",
            "Integration tests",
            "Contract tests",
            "E2E tests"
        ],
        "right": [
            "Function level",
            "Component interaction",
            "Consumer contracts",
            "Full workflows"
        ]
    },
    {
        "q": "Test environments should mirror production configuration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "REST APIs represent the stateless, resource-based architectural style for web services.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match REST best practices:",
        "type": "match",
        "left": [
            "Use nouns",
            "Version APIs",
            "Handle errors",
            "Document thoroughly"
        ],
        "right": [
            "Resource naming",
            "Evolution support",
            "Meaningful responses",
            "Developer experience"
        ]
    },
    {
        "q": "What is the output of this resource serializer?",
        "type": "mcq",
        "c": "class ResourceSerializer {\n    constructor(fields = null) {\n        this.fields = fields;\n    }\n    serialize(resource) {\n        if (!this.fields) return resource;\n        return Object.fromEntries(\n            Object.entries(resource).filter(([key]) => this.fields.includes(key))\n        );\n    }\n}\nconst serializer = new ResourceSerializer(['id', 'name']);\nconsole.log(Object.keys(serializer.serialize({id: 1, name: 'test', email: 'test@test.com'})).length);",
        "o": [
            "2",
            "3",
            "1",
            "0"
        ]
    },
    {
        "q": "Which HTTP method should be used for partial updates to a resource?",
        "type": "mcq",
        "o": [
            "PATCH",
            "PUT",
            "POST",
            "UPDATE"
        ]
    },
    {
        "q": "The ______ response format includes hypermedia controls.",
        "type": "fill_blank",
        "answers": [
            "HAL"
        ],
        "other_options": [
            "JSON",
            "XML",
            "CSV"
        ]
    },
    {
        "q": "Match REST response patterns:",
        "type": "match",
        "left": [
            "Envelope",
            "Flat",
            "HAL",
            "JSON:API"
        ],
        "right": [
            "Wrapper with metadata",
            "Direct data only",
            "Hypermedia links",
            "Standardized format"
        ]
    },
    {
        "q": "What is the output of this URL builder?",
        "type": "mcq",
        "c": "class URLBuilder {\n    constructor(baseURL) {\n        this.url = new URL(baseURL);\n    }\n    path(segment) {\n        this.url.pathname += `/${segment}`;\n        return this;\n    }\n    query(key, value) {\n        this.url.searchParams.set(key, value);\n        return this;\n    }\n    build() {\n        return this.url.toString();\n    }\n}\nconsole.log(new URLBuilder('https://api.example.com').path('users').path('123').query('include', 'orders').build().includes('?'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Rearrange URL components:",
        "type": "rearrange",
        "words": [
            "scheme://",
            "host",
            ":port",
            "/path",
            "?query",
            "#fragment"
        ]
    },
    {
        "q": "REST APIs should use consistent URL patterns.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response transformation?",
        "type": "mcq",
        "o": [
            "Middleware pipeline for request/response modification",
            "No transformation",
            "Client-side only",
            "Database triggers"
        ]
    },
    {
        "q": "The ______ pattern chains request processors.",
        "type": "fill_blank",
        "answers": [
            "middleware"
        ],
        "other_options": [
            "filter",
            "handler",
            "router"
        ]
    },
    {
        "q": "Match middleware responsibilities:",
        "type": "match",
        "left": [
            "Authentication",
            "Logging",
            "Compression",
            "CORS"
        ],
        "right": [
            "Verify identity",
            "Record requests",
            "Reduce size",
            "Cross-origin"
        ]
    },
    {
        "q": "What is the output of this middleware chain?",
        "type": "mcq",
        "c": "class MiddlewareChain {\n    constructor() {\n        this.middlewares = [];\n    }\n    use(middleware) {\n        this.middlewares.push(middleware);\n        return this;\n    }\n    async execute(request, response) {\n        let index = 0;\n        const next = async () => {\n            if (index < this.middlewares.length) {\n                await this.middlewares[index++](request, response, next);\n            }\n        };\n        await next();\n    }\n}",
        "o": [
            "Async middleware chain with next() callbacks",
            "Synchronous middleware",
            "Single middleware",
            "No chaining"
        ]
    },
    {
        "q": "Rearrange middleware execution:",
        "type": "rearrange",
        "words": [
            "Request received",
            "Authentication",
            "Validation",
            "Handler",
            "Response formatting"
        ]
    },
    {
        "q": "Middleware should be ordered by processing requirements.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response pagination metadata?",
        "type": "mcq",
        "o": [
            "Include total count and page links in response",
            "No pagination info",
            "Headers only",
            "Separate endpoint"
        ]
    },
    {
        "q": "The ______ link relation points to the last page.",
        "type": "fill_blank",
        "answers": [
            "last"
        ],
        "other_options": [
            "end",
            "final",
            "tail"
        ]
    },
    {
        "q": "Match pagination metadata:",
        "type": "match",
        "left": [
            "total",
            "page",
            "per_page",
            "total_pages"
        ],
        "right": [
            "Total items",
            "Current page",
            "Items per page",
            "Total pages"
        ]
    },
    {
        "q": "What is the output of this pagination metadata generator?",
        "type": "mcq",
        "c": "function generatePaginationLinks(baseUrl, page, totalPages) {\n    const links = { self: `${baseUrl}?page=${page}` };\n    if (page > 1) links.prev = `${baseUrl}?page=${page - 1}`;\n    if (page < totalPages) links.next = `${baseUrl}?page=${page + 1}`;\n    links.first = `${baseUrl}?page=1`;\n    links.last = `${baseUrl}?page=${totalPages}`;\n    return links;\n}\nconsole.log(Object.keys(generatePaginationLinks('/users', 2, 5)).length);",
        "o": [
            "5",
            "4",
            "3",
            "6"
        ]
    },
    {
        "q": "Rearrange pagination response structure:",
        "type": "rearrange",
        "words": [
            "data array",
            "meta object",
            "links object",
            "included resources"
        ]
    },
    {
        "q": "Pagination metadata improves client navigation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request timeout?",
        "type": "mcq",
        "o": [
            "Configurable timeout with graceful handling",
            "No timeout",
            "Infinite wait",
            "Fixed timeout only"
        ]
    },
    {
        "q": "The ______ header indicates request timeout preference.",
        "type": "fill_blank",
        "answers": [
            "Request-Timeout"
        ],
        "other_options": [
            "Timeout",
            "Max-Wait",
            "Deadline"
        ]
    },
    {
        "q": "Match timeout handling:",
        "type": "match",
        "left": [
            "Client timeout",
            "Server timeout",
            "Gateway timeout",
            "Connection timeout"
        ],
        "right": [
            "Request deadline",
            "Processing limit",
            "504 response",
            "TCP connection"
        ]
    },
    {
        "q": "What is the output of this timeout wrapper?",
        "type": "mcq",
        "c": "async function withTimeout(promise, ms) {\n    const timeout = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Timeout')), ms)\n    );\n    return Promise.race([promise, timeout]);\n}",
        "o": [
            "Race between promise and timeout",
            "Sequential execution",
            "Always timeout",
            "No timeout handling"
        ]
    },
    {
        "q": "Rearrange timeout handling flow:",
        "type": "rearrange",
        "words": [
            "Start request",
            "Set timeout timer",
            "Race with processing",
            "Return result or timeout",
            "Clean up resources"
        ]
    },
    {
        "q": "Long-running requests should return 408 on timeout.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request coalescing?",
        "type": "mcq",
        "o": [
            "Batch similar requests within a time window",
            "Process all individually",
            "Drop duplicates",
            "Random batching"
        ]
    },
    {
        "q": "The ______ pattern combines multiple requests into one.",
        "type": "fill_blank",
        "answers": [
            "request coalescing"
        ],
        "other_options": [
            "batching",
            "merging",
            "combining"
        ]
    },
    {
        "q": "Match request optimization patterns:",
        "type": "match",
        "left": [
            "Coalescing",
            "Batching",
            "Caching",
            "Prefetching"
        ],
        "right": [
            "Combine similar",
            "Group operations",
            "Store responses",
            "Load ahead"
        ]
    },
    {
        "q": "Request coalescing reduces backend load.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response envelope?",
        "type": "mcq",
        "o": [
            "Consistent wrapper with data and metadata",
            "Raw data only",
            "Different format per endpoint",
            "No standard format"
        ]
    },
    {
        "q": "The ______ field contains the primary response data.",
        "type": "fill_blank",
        "answers": [
            "data"
        ],
        "other_options": [
            "result",
            "body",
            "content"
        ]
    },
    {
        "q": "Match envelope fields:",
        "type": "match",
        "left": [
            "data",
            "meta",
            "errors",
            "links"
        ],
        "right": [
            "Primary content",
            "Request metadata",
            "Error details",
            "Navigation"
        ]
    },
    {
        "q": "What is the output of this response envelope?",
        "type": "mcq",
        "c": "class ResponseEnvelope {\n    static success(data, meta = {}) {\n        return {\n            success: true,\n            data,\n            meta: { ...meta, timestamp: new Date().toISOString() }\n        };\n    }\n    static error(message, code, details = null) {\n        return {\n            success: false,\n            error: { message, code, details }\n        };\n    }\n}\nconsole.log(ResponseEnvelope.success({id: 1}).success);",
        "o": [
            "true",
            "false",
            "{id: 1}",
            "undefined"
        ]
    },
    {
        "q": "Rearrange response envelope structure:",
        "type": "rearrange",
        "words": [
            "success indicator",
            "data field",
            "meta information",
            "error details if any"
        ]
    },
    {
        "q": "Consistent response envelopes improve client parsing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API field aliasing?",
        "type": "mcq",
        "o": [
            "Allow clients to rename fields in response",
            "Fixed field names only",
            "Different endpoints per format",
            "No aliasing support"
        ]
    },
    {
        "q": "The ______ parameter specifies field name mappings.",
        "type": "fill_blank",
        "answers": [
            "alias"
        ],
        "other_options": [
            "rename",
            "map",
            "convert"
        ]
    },
    {
        "q": "Field aliasing supports legacy client compatibility.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response filtering?",
        "type": "mcq",
        "o": [
            "Query parameters for complex filter expressions",
            "No filtering",
            "Client-side only",
            "Predefined filters only"
        ]
    },
    {
        "q": "The ______ operator compares values for equality.",
        "type": "fill_blank",
        "answers": [
            "eq"
        ],
        "other_options": [
            "equals",
            "is",
            "match"
        ]
    },
    {
        "q": "Match filter operators:",
        "type": "match",
        "left": [
            "eq",
            "ne",
            "gt",
            "lt"
        ],
        "right": [
            "Equal",
            "Not equal",
            "Greater than",
            "Less than"
        ]
    },
    {
        "q": "What is the output of this filter parser?",
        "type": "mcq",
        "c": "function parseFilter(filterString) {\n    const parts = filterString.split(':');\n    return {\n        field: parts[0],\n        operator: parts[1] || 'eq',\n        value: parts[2] || parts[1]\n    };\n}\nconsole.log(parseFilter('age:gt:18').operator);",
        "o": [
            "gt",
            "age",
            "18",
            "eq"
        ]
    },
    {
        "q": "Rearrange filter expression parsing:",
        "type": "rearrange",
        "words": [
            "Parse query string",
            "Extract field name",
            "Determine operator",
            "Parse value",
            "Build filter object"
        ]
    },
    {
        "q": "Complex filters may require POST requests.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API sorting?",
        "type": "mcq",
        "o": [
            "Query parameter with field and direction",
            "No sorting support",
            "Fixed sort order",
            "Random order"
        ]
    },
    {
        "q": "The ______ prefix indicates descending sort order.",
        "type": "fill_blank",
        "answers": [
            "-"
        ],
        "other_options": [
            "+",
            "desc:",
            "!"
        ]
    },
    {
        "q": "Match sort specifications:",
        "type": "match",
        "left": [
            "name",
            "-name",
            "name,-age",
            "-created_at"
        ],
        "right": [
            "Ascending",
            "Descending",
            "Multiple fields",
            "Newest first"
        ]
    },
    {
        "q": "Multiple sort fields should be comma-separated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API sparse fieldsets?",
        "type": "mcq",
        "o": [
            "Client-specified fields to reduce payload",
            "All fields always",
            "Server-decided fields",
            "No field selection"
        ]
    },
    {
        "q": "The ______ parameter limits returned fields.",
        "type": "fill_blank",
        "answers": [
            "fields"
        ],
        "other_options": [
            "select",
            "columns",
            "include"
        ]
    },
    {
        "q": "Sparse fieldsets reduce bandwidth usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource embedding?",
        "type": "mcq",
        "o": [
            "Include related resources in single request",
            "Separate requests only",
            "No embedding support",
            "Server decides always"
        ]
    },
    {
        "q": "The ______ parameter requests nested resources.",
        "type": "fill_blank",
        "answers": [
            "include"
        ],
        "other_options": [
            "embed",
            "expand",
            "with"
        ]
    },
    {
        "q": "Match embedding approaches:",
        "type": "match",
        "left": [
            "Inline",
            "Sideloading",
            "Links only",
            "On demand"
        ],
        "right": [
            "Nested in parent",
            "Separate array",
            "Hypermedia references",
            "Client requests"
        ]
    },
    {
        "q": "Resource embedding reduces N+1 query problems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API action resources?",
        "type": "mcq",
        "o": [
            "POST to action endpoint with verb noun",
            "PUT to resource",
            "GET with action parameter",
            "Custom HTTP method"
        ]
    },
    {
        "q": "The ______ pattern handles non-CRUD operations.",
        "type": "fill_blank",
        "answers": [
            "controller"
        ],
        "other_options": [
            "action",
            "command",
            "procedure"
        ]
    },
    {
        "q": "Match action patterns:",
        "type": "match",
        "left": [
            "/users/123/activate",
            "/orders/123/cancel",
            "/documents/123/publish",
            "/accounts/123/lock"
        ],
        "right": [
            "Activate user",
            "Cancel order",
            "Publish document",
            "Lock account"
        ]
    },
    {
        "q": "Action endpoints should use POST method.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API sub-resources?",
        "type": "mcq",
        "o": [
            "Nested URL structure showing hierarchy",
            "Flat URLs only",
            "Query parameters",
            "Header-based routing"
        ]
    },
    {
        "q": "The path /users/123/orders represents user's ______ resources.",
        "type": "fill_blank",
        "answers": [
            "child"
        ],
        "other_options": [
            "parent",
            "sibling",
            "root"
        ]
    },
    {
        "q": "Match resource relationships:",
        "type": "match",
        "left": [
            "/users/123/orders",
            "/orders/456/items",
            "/posts/789/comments",
            "/teams/101/members"
        ],
        "right": [
            "User orders",
            "Order items",
            "Post comments",
            "Team members"
        ]
    },
    {
        "q": "Nested resources should not exceed 2-3 levels.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API singleton resources?",
        "type": "mcq",
        "o": [
            "Direct resource access without ID",
            "ID required always",
            "List endpoint only",
            "Query parameter"
        ]
    },
    {
        "q": "The ______ resource exists only once per parent.",
        "type": "fill_blank",
        "answers": [
            "singleton"
        ],
        "other_options": [
            "unique",
            "single",
            "sole"
        ]
    },
    {
        "q": "Match singleton examples:",
        "type": "match",
        "left": [
            "/users/me",
            "/settings",
            "/profile",
            "/dashboard"
        ],
        "right": [
            "Current user",
            "App settings",
            "User profile",
            "User dashboard"
        ]
    },
    {
        "q": "Singleton resources use GET and PUT without ID.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API collection actions?",
        "type": "mcq",
        "o": [
            "POST to collection action endpoint",
            "GET with action parameter",
            "PUT to collection",
            "DELETE collection"
        ]
    },
    {
        "q": "The ______ verb suggests bulk operations.",
        "type": "fill_blank",
        "answers": [
            "batch"
        ],
        "other_options": [
            "bulk",
            "multi",
            "group"
        ]
    },
    {
        "q": "Match collection actions:",
        "type": "match",
        "left": [
            "/users/batch-create",
            "/orders/bulk-delete",
            "/emails/send-all",
            "/tasks/archive-completed"
        ],
        "right": [
            "Create multiple",
            "Delete multiple",
            "Send to all",
            "Archive filtered"
        ]
    },
    {
        "q": "Bulk operations should return individual results.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API composite resources?",
        "type": "mcq",
        "o": [
            "Aggregate multiple resources in single response",
            "Separate requests only",
            "Hardcoded combinations",
            "Client-side composition"
        ]
    },
    {
        "q": "The ______ pattern combines related resources.",
        "type": "fill_blank",
        "answers": [
            "aggregate"
        ],
        "other_options": [
            "composite",
            "combined",
            "merged"
        ]
    },
    {
        "q": "Aggregate endpoints reduce round trips.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource versioning?",
        "type": "mcq",
        "o": [
            "Version field or header in resource representation",
            "No resource versioning",
            "Timestamp only",
            "ID-based versioning"
        ]
    },
    {
        "q": "The ______ field tracks resource modifications.",
        "type": "fill_blank",
        "answers": [
            "version"
        ],
        "other_options": [
            "revision",
            "sequence",
            "update"
        ]
    },
    {
        "q": "Match versioning strategies:",
        "type": "match",
        "left": [
            "ETag",
            "Version field",
            "Timestamp",
            "Revision number"
        ],
        "right": [
            "Content hash",
            "Integer counter",
            "Last modified",
            "Sequential ID"
        ]
    },
    {
        "q": "Resource versioning enables optimistic locking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource soft deletion?",
        "type": "mcq",
        "o": [
            "Mark as deleted without physical removal",
            "Physical delete only",
            "No delete support",
            "Archive to separate table"
        ]
    },
    {
        "q": "The ______ flag indicates soft-deleted resources.",
        "type": "fill_blank",
        "answers": [
            "deleted"
        ],
        "other_options": [
            "removed",
            "archived",
            "hidden"
        ]
    },
    {
        "q": "Match deletion patterns:",
        "type": "match",
        "left": [
            "Hard delete",
            "Soft delete",
            "Archive",
            "Tombstone"
        ],
        "right": [
            "Physical removal",
            "Mark as deleted",
            "Move to archive",
            "Keep reference"
        ]
    },
    {
        "q": "Soft deleted resources should not appear in normal queries.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource restoration?",
        "type": "mcq",
        "o": [
            "POST to restore action endpoint",
            "PUT to update deleted flag",
            "GET to restore",
            "DELETE again"
        ]
    },
    {
        "q": "The ______ action reverses soft deletion.",
        "type": "fill_blank",
        "answers": [
            "restore"
        ],
        "other_options": [
            "undelete",
            "recover",
            "resurrect"
        ]
    },
    {
        "q": "Restoration should be available for soft-deleted resources.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource history?",
        "type": "mcq",
        "o": [
            "Event sourcing or audit trail",
            "No history tracking",
            "Database triggers only",
            "Client-side tracking"
        ]
    },
    {
        "q": "The ______ pattern stores all state changes.",
        "type": "fill_blank",
        "answers": [
            "event sourcing"
        ],
        "other_options": [
            "change tracking",
            "audit logging",
            "version control"
        ]
    },
    {
        "q": "Match history approaches:",
        "type": "match",
        "left": [
            "Event sourcing",
            "Audit trail",
            "Change log",
            "Snapshot"
        ],
        "right": [
            "Store events",
            "Track who/what/when",
            "Record changes",
            "Point-in-time state"
        ]
    },
    {
        "q": "History tracking enables point-in-time recovery.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource cloning?",
        "type": "mcq",
        "o": [
            "POST to clone action with modifications",
            "GET and POST manually",
            "PUT with new ID",
            "Copy endpoint"
        ]
    },
    {
        "q": "The ______ action creates a duplicate resource.",
        "type": "fill_blank",
        "answers": [
            "clone"
        ],
        "other_options": [
            "copy",
            "duplicate",
            "replicate"
        ]
    },
    {
        "q": "Cloning should create independent resource copies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource linking?",
        "type": "mcq",
        "o": [
            "Hypermedia links in response",
            "ID references only",
            "No linking",
            "External link document"
        ]
    },
    {
        "q": "The ______ format standardizes hypermedia.",
        "type": "fill_blank",
        "answers": [
            "HAL"
        ],
        "other_options": [
            "JSON",
            "XML",
            "Link"
        ]
    },
    {
        "q": "Match link relations:",
        "type": "match",
        "left": [
            "self",
            "related",
            "collection",
            "item"
        ],
        "right": [
            "Current resource",
            "Related resource",
            "Parent collection",
            "Collection member"
        ]
    },
    {
        "q": "Hypermedia links enable discoverable APIs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API resource state machines?",
        "type": "mcq",
        "o": [
            "State field with allowed transitions",
            "Any state change allowed",
            "No state tracking",
            "Client manages state"
        ]
    },
    {
        "q": "The ______ diagram shows allowed state transitions.",
        "type": "fill_blank",
        "answers": [
            "state machine"
        ],
        "other_options": [
            "flow chart",
            "process map",
            "decision tree"
        ]
    },
    {
        "q": "Match order states:",
        "type": "match",
        "left": [
            "pending",
            "confirmed",
            "shipped",
            "delivered"
        ],
        "right": [
            "Awaiting action",
            "Order accepted",
            "In transit",
            "Received"
        ]
    },
    {
        "q": "State transitions should be validated server-side.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API tenant isolation?",
        "type": "mcq",
        "o": [
            "Path or header-based tenant identification",
            "No multi-tenancy",
            "Separate deployments only",
            "Database-level only"
        ]
    },
    {
        "q": "The ______ header identifies the current tenant.",
        "type": "fill_blank",
        "answers": [
            "X-Tenant-ID"
        ],
        "other_options": [
            "Tenant",
            "Organization",
            "Account"
        ]
    },
    {
        "q": "Match multi-tenancy strategies:",
        "type": "match",
        "left": [
            "Shared database",
            "Schema per tenant",
            "Database per tenant",
            "Path-based"
        ],
        "right": [
            "Column filtering",
            "Separate schemas",
            "Isolated databases",
            "URL segment"
        ]
    },
    {
        "q": "Tenant data should never leak to other tenants.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request prioritization?",
        "type": "mcq",
        "o": [
            "Priority queuing based on client tier",
            "FIFO only",
            "Random processing",
            "No prioritization"
        ]
    },
    {
        "q": "The ______ header indicates request priority.",
        "type": "fill_blank",
        "answers": [
            "Priority"
        ],
        "other_options": [
            "X-Priority",
            "Urgency",
            "Level"
        ]
    },
    {
        "q": "VIP clients may receive higher priority.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API geographic routing?",
        "type": "mcq",
        "o": [
            "Route to nearest data center based on location",
            "Single location",
            "Random routing",
            "Client-chosen"
        ]
    },
    {
        "q": "The ______ header indicates client location.",
        "type": "fill_blank",
        "answers": [
            "X-Forwarded-For"
        ],
        "other_options": [
            "Location",
            "Geo",
            "Region"
        ]
    },
    {
        "q": "Geographic routing reduces latency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request signing?",
        "type": "mcq",
        "o": [
            "HMAC signature in Authorization header",
            "Plain text credentials",
            "No signing",
            "Client certificate only"
        ]
    },
    {
        "q": "The ______ algorithm creates request signatures.",
        "type": "fill_blank",
        "answers": [
            "HMAC-SHA256"
        ],
        "other_options": [
            "MD5",
            "SHA1",
            "Base64"
        ]
    },
    {
        "q": "Match signature components:",
        "type": "match",
        "left": [
            "Canonical request",
            "Signing key",
            "Signature",
            "Timestamp"
        ],
        "right": [
            "Normalized request",
            "Secret key",
            "Final hash",
            "Prevent replay"
        ]
    },
    {
        "q": "Request signing prevents tampering.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response signing?",
        "type": "mcq",
        "o": [
            "Signature header for response verification",
            "No response signing",
            "Client signs response",
            "Separate signature endpoint"
        ]
    },
    {
        "q": "The ______ header contains the response signature.",
        "type": "fill_blank",
        "answers": [
            "X-Response-Signature"
        ],
        "other_options": [
            "Signature",
            "Hash",
            "Digest"
        ]
    },
    {
        "q": "Response signing ensures data integrity.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request encryption?",
        "type": "mcq",
        "o": [
            "End-to-end encryption with client public key",
            "HTTPS only",
            "No encryption",
            "Server-side only"
        ]
    },
    {
        "q": "The ______ encryption protects data end-to-end.",
        "type": "fill_blank",
        "answers": [
            "E2E"
        ],
        "other_options": [
            "SSL",
            "TLS",
            "HTTPS"
        ]
    },
    {
        "q": "Field-level encryption protects sensitive data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API data masking?",
        "type": "mcq",
        "o": [
            "Replace sensitive data with masked values",
            "Remove sensitive fields",
            "No masking",
            "Client-side masking"
        ]
    },
    {
        "q": "The ______ pattern hides sensitive data portions.",
        "type": "fill_blank",
        "answers": [
            "data masking"
        ],
        "other_options": [
            "data hiding",
            "data removal",
            "data encryption"
        ]
    },
    {
        "q": "Match masking examples:",
        "type": "match",
        "left": [
            "****1234",
            "*****@****.com",
            "****-****-****-1234",
            "***-**-1234"
        ],
        "right": [
            "Phone last 4",
            "Masked email",
            "Credit card",
            "SSN last 4"
        ]
    },
    {
        "q": "Data masking should be based on user permissions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API data anonymization?",
        "type": "mcq",
        "o": [
            "Remove or generalize identifying information",
            "Encrypt only",
            "No anonymization",
            "Hash everything"
        ]
    },
    {
        "q": "The ______ technique generalizes specific values.",
        "type": "fill_blank",
        "answers": [
            "k-anonymity"
        ],
        "other_options": [
            "encryption",
            "hashing",
            "masking"
        ]
    },
    {
        "q": "Anonymization prevents re-identification.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API access control lists?",
        "type": "mcq",
        "o": [
            "Resource-level permissions for users and roles",
            "All-or-nothing access",
            "No ACLs",
            "Client-managed permissions"
        ]
    },
    {
        "q": "The ______ model checks object-level permissions.",
        "type": "fill_blank",
        "answers": [
            "ACL"
        ],
        "other_options": [
            "RBAC",
            "ABAC",
            "MAC"
        ]
    },
    {
        "q": "Match access control models:",
        "type": "match",
        "left": [
            "ACL",
            "RBAC",
            "ABAC",
            "ReBAC"
        ],
        "right": [
            "Per-resource",
            "Role-based",
            "Attribute-based",
            "Relationship-based"
        ]
    },
    {
        "q": "Fine-grained access control improves security.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API quota management?",
        "type": "mcq",
        "o": [
            "Track and enforce usage quotas per client",
            "Unlimited usage",
            "Rate limiting only",
            "No quota tracking"
        ]
    },
    {
        "q": "The ______ header shows remaining quota.",
        "type": "fill_blank",
        "answers": [
            "X-Quota-Remaining"
        ],
        "other_options": [
            "Quota",
            "Usage",
            "Limit"
        ]
    },
    {
        "q": "Match quota types:",
        "type": "match",
        "left": [
            "Daily",
            "Monthly",
            "Per-request",
            "Concurrent"
        ],
        "right": [
            "Resets daily",
            "Resets monthly",
            "Per API call",
            "Simultaneous"
        ]
    },
    {
        "q": "Quota management prevents abuse.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API billing integration?",
        "type": "mcq",
        "o": [
            "Usage tracking with billing system integration",
            "No billing integration",
            "Manual billing",
            "Client-reported usage"
        ]
    },
    {
        "q": "The ______ model charges per API call.",
        "type": "fill_blank",
        "answers": [
            "pay-per-use"
        ],
        "other_options": [
            "subscription",
            "flat-rate",
            "tiered"
        ]
    },
    {
        "q": "Usage-based billing requires accurate tracking.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API developer portal?",
        "type": "mcq",
        "o": [
            "Self-service portal with docs and key management",
            "Email-based access",
            "No developer portal",
            "Manual provisioning"
        ]
    },
    {
        "q": "The ______ section shows getting started guides.",
        "type": "fill_blank",
        "answers": [
            "quickstart"
        ],
        "other_options": [
            "tutorial",
            "guide",
            "intro"
        ]
    },
    {
        "q": "Match portal features:",
        "type": "match",
        "left": [
            "Documentation",
            "API keys",
            "Usage analytics",
            "Support"
        ],
        "right": [
            "Reference docs",
            "Credential management",
            "Usage metrics",
            "Help resources"
        ]
    },
    {
        "q": "Developer portals improve API adoption.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API SDK generation?",
        "type": "mcq",
        "o": [
            "Auto-generate from OpenAPI specification",
            "Manual SDK development",
            "No SDKs",
            "Client-generated"
        ]
    },
    {
        "q": "The ______ tool generates client libraries.",
        "type": "fill_blank",
        "answers": [
            "OpenAPI Generator"
        ],
        "other_options": [
            "Swagger Codegen",
            "Postman",
            "Insomnia"
        ]
    },
    {
        "q": "Generated SDKs reduce integration time.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API changelog?",
        "type": "mcq",
        "o": [
            "Detailed changelog with breaking changes highlighted",
            "No changelog",
            "Git history only",
            "Internal changelog"
        ]
    },
    {
        "q": "The ______ section lists breaking changes.",
        "type": "fill_blank",
        "answers": [
            "breaking changes"
        ],
        "other_options": [
            "removed",
            "deprecated",
            "changed"
        ]
    },
    {
        "q": "Match changelog sections:",
        "type": "match",
        "left": [
            "Added",
            "Changed",
            "Deprecated",
            "Removed"
        ],
        "right": [
            "New features",
            "Modifications",
            "Future removal",
            "Deleted features"
        ]
    },
    {
        "q": "Changelogs help developers track API evolution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API design review?",
        "type": "mcq",
        "o": [
            "Formal review process before implementation",
            "Post-implementation review",
            "No review",
            "Client feedback only"
        ]
    },
    {
        "q": "The ______ spec enables design-first development.",
        "type": "fill_blank",
        "answers": [
            "OpenAPI"
        ],
        "other_options": [
            "RAML",
            "Blueprint",
            "WSDL"
        ]
    },
    {
        "q": "Design reviews catch issues early.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API style guide?",
        "type": "mcq",
        "o": [
            "Documented standards for consistent API design",
            "Ad-hoc design",
            "Copy from others",
            "No standards"
        ]
    },
    {
        "q": "The ______ tool lints API specifications.",
        "type": "fill_blank",
        "answers": [
            "Spectral"
        ],
        "other_options": [
            "ESLint",
            "Prettier",
            "JSHint"
        ]
    },
    {
        "q": "Match style guide topics:",
        "type": "match",
        "left": [
            "Naming",
            "Versioning",
            "Errors",
            "Pagination"
        ],
        "right": [
            "Resource names",
            "Version strategy",
            "Error format",
            "Collection navigation"
        ]
    },
    {
        "q": "Style guides ensure API consistency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "RESTful APIs provide a flexible, scalable approach to web service design.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match REST architectural constraints:",
        "type": "match",
        "left": [
            "Client-Server",
            "Stateless",
            "Uniform Interface",
            "Layered System"
        ],
        "right": [
            "Separation",
            "No session",
            "Consistent",
            "Architecture layers"
        ]
    },
    {
        "q": "What is the output of this API router?",
        "type": "mcq",
        "c": "class Router {\n    constructor() {\n        this.routes = [];\n    }\n    get(path, handler) {\n        this.routes.push({ method: 'GET', path, handler });\n        return this;\n    }\n    match(method, path) {\n        return this.routes.find(r => r.method === method && r.path === path);\n    }\n}\nconst router = new Router();\nrouter.get('/users', () => 'list').get('/users/:id', () => 'show');\nconsole.log(router.routes.length);",
        "o": [
            "2",
            "1",
            "0",
            "3"
        ]
    },
    {
        "q": "Which approach handles API request correlation?",
        "type": "mcq",
        "o": [
            "Unique request ID throughout request lifecycle",
            "No correlation",
            "Timestamp only",
            "IP-based tracking"
        ]
    },
    {
        "q": "The ______ ID links related log entries.",
        "type": "fill_blank",
        "answers": [
            "correlation"
        ],
        "other_options": [
            "request",
            "session",
            "trace"
        ]
    },
    {
        "q": "Match correlation patterns:",
        "type": "match",
        "left": [
            "Request ID",
            "Trace ID",
            "Span ID",
            "Session ID"
        ],
        "right": [
            "Single request",
            "Distributed trace",
            "Operation span",
            "User session"
        ]
    },
    {
        "q": "Correlation IDs help debug distributed systems.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request replay?",
        "type": "mcq",
        "o": [
            "Store and replay idempotent requests",
            "No replay support",
            "Client-side replay",
            "Manual reprocessing"
        ]
    },
    {
        "q": "The ______ pattern stores requests for replay.",
        "type": "fill_blank",
        "answers": [
            "event store"
        ],
        "other_options": [
            "queue",
            "cache",
            "buffer"
        ]
    },
    {
        "q": "Request replay requires idempotent endpoints.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request batching?",
        "type": "mcq",
        "o": [
            "Combine multiple operations in single request",
            "Individual requests only",
            "Server-side batching",
            "No batching"
        ]
    },
    {
        "q": "The ______ endpoint accepts multiple operations.",
        "type": "fill_blank",
        "answers": [
            "batch"
        ],
        "other_options": [
            "bulk",
            "multi",
            "array"
        ]
    },
    {
        "q": "Match batch patterns:",
        "type": "match",
        "left": [
            "Sequential",
            "Parallel",
            "Transaction",
            "Partial"
        ],
        "right": [
            "In order",
            "Concurrent",
            "All or none",
            "Partial success"
        ]
    },
    {
        "q": "Batch operations reduce network overhead.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response caching headers?",
        "type": "mcq",
        "o": [
            "Cache-Control with appropriate max-age",
            "No caching headers",
            "Always no-cache",
            "CDN decides"
        ]
    },
    {
        "q": "The ______ directive indicates maximum cache time.",
        "type": "fill_blank",
        "answers": [
            "max-age"
        ],
        "other_options": [
            "s-maxage",
            "expires",
            "cache-time"
        ]
    },
    {
        "q": "Match Cache-Control directives:",
        "type": "match",
        "left": [
            "no-cache",
            "no-store",
            "private",
            "public"
        ],
        "right": [
            "Revalidate always",
            "Never cache",
            "Client only",
            "Shared caches"
        ]
    },
    {
        "q": "Private resources should not be cached by CDNs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API compression?",
        "type": "mcq",
        "o": [
            "Content-Encoding with gzip or br",
            "No compression",
            "Client compresses",
            "Custom compression"
        ]
    },
    {
        "q": "The ______ algorithm provides best compression ratio.",
        "type": "fill_blank",
        "answers": [
            "brotli"
        ],
        "other_options": [
            "gzip",
            "deflate",
            "lz4"
        ]
    },
    {
        "q": "Compression reduces bandwidth usage.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API connection pooling?",
        "type": "mcq",
        "o": [
            "Reuse HTTP connections for multiple requests",
            "New connection each request",
            "Single connection",
            "Client manages"
        ]
    },
    {
        "q": "The ______ header controls connection persistence.",
        "type": "fill_blank",
        "answers": [
            "Connection"
        ],
        "other_options": [
            "Keep-Alive",
            "Persist",
            "Reuse"
        ]
    },
    {
        "q": "Connection pooling reduces latency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request queuing?",
        "type": "mcq",
        "o": [
            "Queue requests during overload",
            "Reject all excess",
            "No queuing",
            "Client queues"
        ]
    },
    {
        "q": "The ______ queue handles async processing.",
        "type": "fill_blank",
        "answers": [
            "message"
        ],
        "other_options": [
            "task",
            "job",
            "work"
        ]
    },
    {
        "q": "Match queue priorities:",
        "type": "match",
        "left": [
            "High",
            "Normal",
            "Low",
            "Batch"
        ],
        "right": [
            "Urgent",
            "Standard",
            "Background",
            "Deferred"
        ]
    },
    {
        "q": "Priority queuing improves responsiveness.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API graceful degradation?",
        "type": "mcq",
        "o": [
            "Provide reduced functionality under load",
            "Fail completely",
            "No degradation",
            "Client handles"
        ]
    },
    {
        "q": "The ______ pattern reduces features during overload.",
        "type": "fill_blank",
        "answers": [
            "graceful degradation"
        ],
        "other_options": [
            "failover",
            "fallback",
            "backup"
        ]
    },
    {
        "q": "Graceful degradation maintains partial service.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API circuit breaker state?",
        "type": "mcq",
        "o": [
            "Closed, Open, Half-Open states",
            "On/Off only",
            "No states",
            "Client-side state"
        ]
    },
    {
        "q": "The ______ state tests if service recovered.",
        "type": "fill_blank",
        "answers": [
            "half-open"
        ],
        "other_options": [
            "test",
            "probe",
            "check"
        ]
    },
    {
        "q": "Match circuit states:",
        "type": "match",
        "left": [
            "Closed",
            "Open",
            "Half-Open",
            "Forced"
        ],
        "right": [
            "Normal",
            "Failing",
            "Testing",
            "Manual override"
        ]
    },
    {
        "q": "Circuit breakers prevent cascade failures.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API fallback responses?",
        "type": "mcq",
        "o": [
            "Return cached or default response on failure",
            "Error only",
            "No fallback",
            "Client provides"
        ]
    },
    {
        "q": "The ______ response provides minimum functionality.",
        "type": "fill_blank",
        "answers": [
            "fallback"
        ],
        "other_options": [
            "default",
            "backup",
            "cache"
        ]
    },
    {
        "q": "Fallback responses improve user experience.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API health endpoints?",
        "type": "mcq",
        "o": [
            "Dedicated health check endpoint",
            "No health check",
            "Root path",
            "Header-based"
        ]
    },
    {
        "q": "The ______ endpoint checks service health.",
        "type": "fill_blank",
        "answers": [
            "/health"
        ],
        "other_options": [
            "/status",
            "/ping",
            "/check"
        ]
    },
    {
        "q": "Match health check types:",
        "type": "match",
        "left": [
            "Liveness",
            "Readiness",
            "Startup",
            "Deep health"
        ],
        "right": [
            "Process running",
            "Ready for traffic",
            "Initial warmup",
            "Dependencies healthy"
        ]
    },
    {
        "q": "Health checks should verify all critical dependencies.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API request deduplication?",
        "type": "mcq",
        "o": [
            "Idempotency key for duplicate detection",
            "No deduplication",
            "Client handles",
            "Timestamp-based"
        ]
    },
    {
        "q": "The ______ key prevents duplicate processing.",
        "type": "fill_blank",
        "answers": [
            "idempotency"
        ],
        "other_options": [
            "unique",
            "request",
            "dedup"
        ]
    },
    {
        "q": "Idempotency prevents double-processing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API response metadata?",
        "type": "mcq",
        "o": [
            "Meta object with request context",
            "Headers only",
            "No metadata",
            "Separate endpoint"
        ]
    },
    {
        "q": "The ______ field contains timing information.",
        "type": "fill_blank",
        "answers": [
            "timing"
        ],
        "other_options": [
            "time",
            "duration",
            "elapsed"
        ]
    },
    {
        "q": "Match metadata fields:",
        "type": "match",
        "left": [
            "request_id",
            "timestamp",
            "version",
            "deprecated"
        ],
        "right": [
            "Correlation ID",
            "Response time",
            "API version",
            "Sunset warning"
        ]
    },
    {
        "q": "Response metadata aids debugging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API error handling?",
        "type": "mcq",
        "o": [
            "Structured error responses with codes",
            "Plain text errors",
            "Status code only",
            "No error handling"
        ]
    },
    {
        "q": "The ______ format standardizes errors.",
        "type": "fill_blank",
        "answers": [
            "Problem Details"
        ],
        "other_options": [
            "Error",
            "Exception",
            "Fault"
        ]
    },
    {
        "q": "Match error response fields:",
        "type": "match",
        "left": [
            "type",
            "title",
            "status",
            "detail"
        ],
        "right": [
            "Error URI",
            "Short summary",
            "HTTP code",
            "Full explanation"
        ]
    },
    {
        "q": "Error responses should be consistent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API input sanitization?",
        "type": "mcq",
        "o": [
            "Clean and validate all input data",
            "Trust input",
            "Client sanitizes",
            "No sanitization"
        ]
    },
    {
        "q": "The ______ attack exploits unsanitized input.",
        "type": "fill_blank",
        "answers": [
            "injection"
        ],
        "other_options": [
            "XSS",
            "CSRF",
            "overflow"
        ]
    },
    {
        "q": "Input sanitization prevents injection attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API output encoding?",
        "type": "mcq",
        "o": [
            "Encode output to prevent XSS",
            "Raw output",
            "Client encodes",
            "No encoding"
        ]
    },
    {
        "q": "The ______ encoding prevents script injection.",
        "type": "fill_blank",
        "answers": [
            "HTML"
        ],
        "other_options": [
            "URL",
            "Base64",
            "Unicode"
        ]
    },
    {
        "q": "Output encoding prevents XSS attacks.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API secrets management?",
        "type": "mcq",
        "o": [
            "Secure vault with rotation",
            "Environment variables only",
            "Hardcoded secrets",
            "No secret management"
        ]
    },
    {
        "q": "The ______ pattern securely stores credentials.",
        "type": "fill_blank",
        "answers": [
            "secrets vault"
        ],
        "other_options": [
            "config file",
            "env var",
            "database"
        ]
    },
    {
        "q": "Secrets should never be logged.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which approach handles API configuration management?",
        "type": "mcq",
        "o": [
            "External configuration with hot reload",
            "Hardcoded config",
            "Recompile to change",
            "No configuration"
        ]
    },
    {
        "q": "The ______ pattern externalizes configuration.",
        "type": "fill_blank",
        "answers": [
            "12-factor"
        ],
        "other_options": [
            "config",
            "settings",
            "options"
        ]
    },
    {
        "q": "Configuration should be separate from code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "REST is the most widely used API architectural style.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match REST API security best practices:",
        "type": "match",
        "left": [
            "HTTPS",
            "Authentication",
            "Authorization",
            "Input validation"
        ],
        "right": [
            "Transport security",
            "Identity verification",
            "Access control",
            "Data integrity"
        ]
    }
]