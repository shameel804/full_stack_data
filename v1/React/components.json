[
    {
        "q": "Which of the following is a valid way to define a functional component in React?",
        "o": [
            "function MyComponent() { return <div>Hello</div>; }",
            "class MyComponent { render() { return <div>Hello</div>; } }",
            "const MyComponent = React.Component { return <div>Hello</div>; }",
            "React.createComponent(MyComponent)"
        ]
    },
    {
        "q": "Which of the following keywords is used to create a class component in React?",
        "o": [
            "class",
            "function",
            "component",
            "object"
        ]
    },
    {
        "q": "Which of the following correctly shows props being passed into a functional component?",
        "o": [
            "const Greeting = (props) => <h1>Hello {props.name}</h1>;",
            "const Greeting = () => <h1>Hello name</h1>;",
            "function Greeting(name) { return <h1>Hello {name}</h1>; }",
            "function Greeting = {props} => <h1>Hello {props.name}</h1>;"
        ]
    },
    {
        "q": "What is the correct way to access children passed into a component?",
        "o": [
            "props.children",
            "this.children",
            "children.props",
            "component.children"
        ]
    },
    {
        "q": "What will be rendered by the following component?",
        "c": "function Welcome(props) {\n  return <h1>Hello, {props.user}</h1>;\n}\n\n<Welcome user=\"Alice\" />",
        "o": [
            "Hello, Alice",
            "Hello, {props.user}",
            "Hello, user",
            "Error: props not defined"
        ]
    },
    {
        "q": "Which of the following lifecycle methods is available only in class components?",
        "o": [
            "componentDidMount",
            "useEffect",
            "render",
            "componentFunction"
        ]
    },
    {
        "q": "Which of the following is a key difference between functional and class components in React?",
        "o": [
            "Functional components can use hooks, while class components use lifecycle methods",
            "Class components cannot render JSX, functional components can",
            "Functional components require state, class components do not",
            "Class components cannot receive props, functional components can"
        ]
    },
    {
        "q": "What will the following code output?",
        "c": "function Container(props) {\n  return <div>{props.children}</div>;\n}\n\n<Container>\n  <p>First</p>\n  <p>Second</p>\n</Container>",
        "o": [
            "Both 'First' and 'Second' paragraphs inside a div",
            "Only 'First' paragraph inside a div",
            "Only 'Second' paragraph inside a div",
            "Error: Cannot use props.children"
        ]
    },
    {
        "q": "Which of the following is true about props in React?",
        "o": [
            "Props are read-only",
            "Props can be modified directly",
            "Props must always be numbers",
            "Props can only be used in class components"
        ]
    },
    {
        "q": "What will be displayed when the following code runs?",
        "c": "class Greeting extends React.Component {\n  render() {\n    return <h2>Welcome, {this.props.name}!</h2>;\n  }\n}\n\n<Greeting name=\"Bob\" />",
        "o": [
            "Welcome, Bob!",
            "Welcome, {this.props.name}!",
            "Welcome, name!",
            "Error: props not accessible"
        ]
    },
    {
        "q": "Which of the following is the correct syntax to create a class component in React?",
        "o": [
            "class MyComponent extends React.Component { render() { return <div>Hello</div>; } }",
            "function MyComponent() { return <div>Hello</div>; }",
            "const MyComponent = () => <div>Hello</div>;",
            "class MyComponent = React.Component { return <div>Hello</div>; }"
        ]
    },
    {
        "q": "Which of the following is NOT true about functional components?",
        "o": [
            "They can use lifecycle methods without hooks",
            "They are plain JavaScript functions",
            "They can accept props as arguments",
            "They return JSX"
        ]
    },
    {
        "q": "Which keyword is used to access props in a class component?",
        "o": [
            "this.props",
            "props",
            "component.props",
            "getProps()"
        ]
    },
    {
        "q": "What will be the output of the following code?",
        "c": "function Title(props) {\n  return <h1>{props.text}</h1>;\n}\n\n<Title text=\"React Quiz\" />",
        "o": [
            "React Quiz",
            "{props.text}",
            "text",
            "Error: props not defined"
        ]
    },
    {
        "q": "Which of the following is the correct way to pass children into a component?",
        "o": [
            "<Box><p>Inside Box</p></Box>",
            "<Box children={<p>Inside Box</p>} />",
            "<Box: <p>Inside Box</p> />",
            "<Box><children>Inside Box</children></Box>"
        ]
    },
    {
        "q": "What will be displayed by the following code?",
        "c": "class Hello extends React.Component {\n  render() {\n    return <p>Hello {this.props.name}</p>;\n  }\n}\n\n<Hello name=\"React\" />",
        "o": [
            "Hello React",
            "Hello {this.props.name}",
            "Hello name",
            "Error: Invalid component"
        ]
    },
    {
        "q": "Which of the following is a benefit of using functional components with hooks?",
        "o": [
            "They allow state management and side effects without class components",
            "They automatically optimize rendering",
            "They cannot accept props",
            "They are faster than all class components"
        ]
    },
    {
        "q": "What will the following code output?",
        "c": "function Wrapper(props) {\n  return <section>{props.children}</section>;\n}\n\n<Wrapper>\n  <h2>Header</h2>\n  <p>Paragraph</p>\n</Wrapper>",
        "o": [
            "Both 'Header' and 'Paragraph' inside a section",
            "Only 'Header' inside a section",
            "Only 'Paragraph' inside a section",
            "Error: Cannot render multiple children"
        ]
    },
    {
        "q": "Which of the following is correct about props?",
        "o": [
            "Props are immutable",
            "Props are mutable",
            "Props are used only in functional components",
            "Props cannot hold strings"
        ]
    },
    {
        "q": "What will happen if you try to modify props directly inside a component?",
        "o": [
            "It will cause an error or unexpected behavior",
            "It will update the parent component",
            "It will work as expected",
            "It will convert props into state automatically"
        ]
    },
    {
        "q": "Which of the following statements about React components is TRUE?",
        "o": [
            "Components help split the UI into independent, reusable pieces",
            "Components must always be written as class components",
            "Components cannot accept props",
            "Components must return plain strings"
        ]
    },
    {
        "q": "Which of the following is the correct way to export a functional component?",
        "o": [
            "export default MyComponent;",
            "export function = MyComponent;",
            "exports MyComponent;",
            "component.export(MyComponent)"
        ]
    },
    {
        "q": "What will the following code render?",
        "c": "function Button(props) {\n  return <button>{props.label}</button>;\n}\n\n<Button label=\"Click Me\" />",
        "o": [
            "Click Me",
            "{props.label}",
            "label",
            "Error: props not defined"
        ]
    },
    {
        "q": "Which method is mandatory inside a React class component?",
        "o": [
            "render()",
            "constructor()",
            "componentDidMount()",
            "componentWillUnmount()"
        ]
    },
    {
        "q": "Which of the following is a correct JSX expression inside a component?",
        "o": [
            "<h1>{2 + 2}</h1>",
            "<h1>2 + 2</h1>",
            "<h1>{{2 + 2}}</h1>",
            "<h1>(2 + 2)</h1>"
        ]
    },
    {
        "q": "What will the following component display?",
        "c": "class Message extends React.Component {\n  render() {\n    return <div>{this.props.children}</div>;\n  }\n}\n\n<Message><p>Hello World</p></Message>",
        "o": [
            "Hello World",
            "{this.props.children}",
            "Message",
            "Error: Cannot use children in class components"
        ]
    },
    {
        "q": "Which of the following best describes children in React?",
        "o": [
            "They represent the content nested between opening and closing component tags",
            "They are a special type of prop that holds numeric values",
            "They are lifecycle methods",
            "They are automatically generated keys for lists"
        ]
    },
    {
        "q": "What will the following code output?",
        "c": "function Card(props) {\n  return <div><h3>{props.title}</h3>{props.children}</div>;\n}\n\n<Card title=\"Profile\">\n  <p>Name: John</p>\n</Card>",
        "o": [
            "A div with 'Profile' as heading and 'Name: John' as paragraph",
            "Only 'Profile' inside a div",
            "Only 'Name: John' inside a div",
            "Error: Cannot mix props and children"
        ]
    },
    {
        "q": "Which of the following is the correct way to pass multiple props into a component?",
        "o": [
            "<User name=\"Alice\" age={25} />",
            "<User: name=Alice, age=25 />",
            "<User(name: 'Alice', age: 25) />",
            "<User props={name: 'Alice', age: 25} />"
        ]
    },
    {
        "q": "In a functional component, how can you access props?",
        "o": [
            "By using the function parameter, e.g. function Comp(props)",
            "By using this.props",
            "By importing Props from React",
            "By calling props()"
        ]
    },
    {
        "q": "Which of the following is the correct way to create a functional component using an arrow function?",
        "o": [
            "const Greeting = () => <h1>Hello</h1>;",
            "const Greeting() => { return <h1>Hello</h1>; };",
            "Greeting = function => <h1>Hello</h1>;",
            "function => Greeting() { return <h1>Hello</h1>; }"
        ]
    },
    {
        "q": "Which of the following is TRUE about class components?",
        "o": [
            "They must extend React.Component",
            "They cannot receive props",
            "They do not need a render method",
            "They are written only in plain JavaScript without JSX"
        ]
    },
    {
        "q": "What will the following code render?",
        "c": "function Info(props) {\n  return <p>{props.text}</p>;\n}\n\n<Info text=\"Learning React\" />",
        "o": [
            "Learning React",
            "{props.text}",
            "text",
            "Error: props not accessible"
        ]
    },
    {
        "q": "Which of the following is correct about props.children?",
        "o": [
            "It allows a component to render whatever is placed between its opening and closing tags",
            "It only works with class components",
            "It automatically converts strings to numbers",
            "It is the same as state"
        ]
    },
    {
        "q": "What will this code output?",
        "c": "class App extends React.Component {\n  render() {\n    return <div>{this.props.title}</div>;\n  }\n}\n\n<App title=\"My App\" />",
        "o": [
            "My App",
            "{this.props.title}",
            "title",
            "Error: Cannot use props in class"
        ]
    },
    {
        "q": "Which of the following is TRUE about functional and class components?",
        "o": [
            "Functional components can use hooks, class components use lifecycle methods",
            "Functional components cannot return JSX",
            "Class components cannot have state",
            "Class components do not accept props"
        ]
    },
    {
        "q": "Which of the following will render both 'Header' and 'Footer'?",
        "c": "function Layout(props) {\n  return <div>{props.children}</div>;\n}\n\n<Layout>\n  <h1>Header</h1>\n  <h2>Footer</h2>\n</Layout>",
        "o": [
            "Both 'Header' and 'Footer' inside a div",
            "Only 'Header' inside a div",
            "Only 'Footer' inside a div",
            "Error: props.children cannot render multiple elements"
        ]
    },
    {
        "q": "Which of the following is TRUE about props in React?",
        "o": [
            "They are used to pass data from parent to child component",
            "They can only be strings",
            "They must always be numbers",
            "They are mutable like state"
        ]
    },
    {
        "q": "What is the correct way to define default props in a functional component?",
        "o": [
            "MyComponent.defaultProps = { title: 'Default' };",
            "defaultProps(MyComponent) { title: 'Default' };",
            "function defaultProps() { return { title: 'Default' }; }",
            "props.default = { title: 'Default' };"
        ]
    },
    {
        "q": "What will the following code display?",
        "c": "function Welcome(props) {\n  return <h2>Welcome {props.name}</h2>;\n}\n\n<Welcome name=\"Developer\" />",
        "o": [
            "Welcome Developer",
            "Welcome {props.name}",
            "Welcome name",
            "Error: props not defined"
        ]
    },
    {
        "q": "If a component does not receive any props, how will props be represented inside it?",
        "o": [
            "An empty object",
            "null",
            "undefined",
            "false"
        ]
    },
    {
        "q": "Which of the following best describes the difference between props and state?",
        "o": [
            "Props are external and immutable, state is internal and mutable",
            "Props and state are the same in React",
            "State is passed from parent to child, props are managed inside a component",
            "Props can only store numbers, state can store strings"
        ]
    },
    {
        "q": "What will be logged in the console?",
        "c": "function Item(props) {\n  console.log(props);\n  return <li>{props.value}</li>;\n}\n\n<Item value=\"Book\" />",
        "o": [
            "{ value: \"Book\" }",
            "{ props: { value: \"Book\" } }",
            "Book",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is NOT a valid way to define a React component?",
        "o": [
            "const Comp = <div>Hello</div>;",
            "function Comp() { return <div>Hello</div>; }",
            "class Comp extends React.Component { render() { return <div>Hello</div>; } }",
            "const Comp = () => <div>Hello</div>;"
        ]
    },
    {
        "q": "What happens if you forget to extend React.Component in a class component?",
        "o": [
            "The component will not have access to lifecycle methods and render()",
            "It will still work the same",
            "It will automatically become a functional component",
            "React will convert it into props.children"
        ]
    },
    {
        "q": "Which of the following correctly represents nested components?",
        "o": [
            "<Parent><Child /></Parent>",
            "<Parent><Child></Parent></Child>",
            "<Parent><Child><Parent></Child>",
            "<Parent.Child />"
        ]
    },
    {
        "q": "What will this code render?",
        "c": "function Label(props) {\n  return <span>{props.children}</span>;\n}\n\n<Label>React Rocks!</Label>",
        "o": [
            "React Rocks!",
            "{props.children}",
            "Label",
            "Error: children not supported in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React components?",
        "o": [
            "Every React component must return a single root element",
            "React components can return multiple root elements without a wrapper",
            "React components cannot return JSX",
            "React components must always be written as classes"
        ]
    },
    {
        "q": "Which of the following is the correct way to pass a JavaScript variable as a prop?",
        "o": [
            "<User age={25} />",
            "<User age=\"{25}\" />",
            "<User age='25' />",
            "<User {age:25} />"
        ]
    },
    {
        "q": "What is the purpose of the render() method in class components?",
        "o": [
            "To return the JSX to be displayed",
            "To update state directly",
            "To declare lifecycle methods",
            "To define props"
        ]
    },
    {
        "q": "Which of the following is TRUE about props validation in React?",
        "o": [
            "PropTypes can be used to enforce type checking on props",
            "Props are automatically type-checked by React",
            "Props must always be strings unless validated",
            "Prop validation is only available in functional components"
        ]
    },
    {
        "q": "What will happen if a prop is not passed and no defaultProp is defined?",
        "o": [
            "The prop will be undefined",
            "React will throw an error",
            "The prop will be null",
            "React assigns an empty string as default"
        ]
    },
    {
        "q": "Which of the following is a correct example of using props.children?",
        "o": [
            "function Panel(props) { return <div>{props.children}</div>; }",
            "function Panel(props) { return <div>{children}</div>; }",
            "function Panel(children) { return <div>{children.props}</div>; }",
            "function Panel() { return <div>{this.children}</div>; }"
        ]
    },
    {
        "q": "What will the following code display?",
        "c": "function User(props) {\n  return <h3>{props.name ? props.name : 'Guest'}</h3>;\n}\n\n<User />",
        "o": [
            "Guest",
            "{props.name}",
            "undefined",
            "Error: Missing prop"
        ]
    },
    {
        "q": "Which of the following statements about children in React is FALSE?",
        "o": [
            "Children must always be plain text",
            "Children can be other components",
            "Children can be JSX elements",
            "Children are passed through props"
        ]
    },
    {
        "q": "Which of the following will cause a syntax error in JSX?",
        "o": [
            "<div><h1>Hello</h1><p>World</p></div>",
            "<div>Hello</div>",
            "<h1>Hello</h1><p>World</p>",
            "<Fragment><h1>Hello</h1></Fragment>"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "class Status extends React.Component {\n  render() {\n    return <p>{this.props.online ? 'Online' : 'Offline'}</p>;\n  }\n}\n\n<Status online={true} />",
        "o": [
            "Online",
            "Offline",
            "{this.props.online}",
            "Error: props cannot hold boolean values"
        ]
    },
    {
        "q": "Which of the following is the correct way to destructure props in a functional component?",
        "o": [
            "function Welcome({ name }) { return <h1>Hello {name}</h1>; }",
            "function Welcome(props.name) { return <h1>Hello {name}</h1>; }",
            "function Welcome() { return <h1>Hello {props.name}</h1>; }",
            "function Welcome(props) { let { name } = props.name; return <h1>{name}</h1>; }"
        ]
    },
    {
        "q": "Which of the following is TRUE about React class components?",
        "o": [
            "They require a render() method to return JSX",
            "They cannot accept props",
            "They do not support lifecycle methods",
            "They must be written as arrow functions"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function Container() {\n  return (\n    <div>\n      <span>One</span>\n      <span>Two</span>\n    </div>\n  );\n}\n\n<Container />",
        "o": [
            "A div containing 'One' and 'Two'",
            "Only 'One'",
            "Only 'Two'",
            "Error: Multiple children are not allowed"
        ]
    },
    {
        "q": "Which of the following describes a pure functional component?",
        "o": [
            "It returns the same output given the same props",
            "It manages its own state",
            "It must extend React.Component",
            "It always re-renders regardless of props"
        ]
    },
    {
        "q": "What is the correct way to pass a function as a prop?",
        "o": [
            "<Button onClick={handleClick} />",
            "<Button onClick='handleClick' />",
            "<Button {onClick: handleClick} />",
            "<Button onClick()>"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Profile(props) {\n  return <h2>{props.age >= 18 ? 'Adult' : 'Minor'}</h2>;\n}\n\n<Profile age={20} />",
        "o": [
            "Adult",
            "Minor",
            "{props.age}",
            "Error: age must be a string"
        ]
    },
    {
        "q": "Which of the following is TRUE about keys in React lists?",
        "o": [
            "They help React identify which items have changed",
            "They must always be globally unique across the app",
            "They are optional and only for styling",
            "They can only be numbers"
        ]
    },
    {
        "q": "What happens if you return multiple adjacent JSX elements without a parent wrapper?",
        "o": [
            "It causes a syntax error",
            "It automatically wraps them in a div",
            "React ignores the extra elements",
            "It returns only the first element"
        ]
    },
    {
        "q": "What will be the output?",
        "c": "function Display(props) {\n  return <p>{props.items.length} items</p>;\n}\n\n<Display items={[1,2,3]} />",
        "o": [
            "3 items",
            "{props.items.length} items",
            "items",
            "Error: props cannot hold arrays"
        ]
    },
    {
        "q": "Which of the following is a valid way to use a React Fragment?",
        "o": [
            "<><p>One</p><p>Two</p></>",
            "<Fragment><p>One</p><p>Two</p></Fragment>",
            "<fragment><p>One</p></fragment>",
            "<F><p>One</p><p>Two</p></F>"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "class Title extends React.Component {\n  render() {\n    return <h1>{this.props.text.toUpperCase()}</h1>;\n  }\n}\n\n<Title text=\"hello\" />",
        "o": [
            "HELLO",
            "hello",
            "{this.props.text}",
            "Error: props cannot call string methods"
        ]
    },
    {
        "q": "Which of the following is a difference between props and children?",
        "o": [
            "Props are explicitly passed, children are implicitly passed content",
            "Children can only be strings, props can be anything",
            "Props are immutable, children are mutable",
            "Props can only be used in class components, children only in functional components"
        ]
    },
    {
        "q": "What will be rendered?",
        "c": "function Badge(props) {\n  return <span>{props.label || 'Default'}</span>;\n}\n\n<Badge />",
        "o": [
            "Default",
            "undefined",
            "label",
            "Error: Missing prop"
        ]
    },
    {
        "q": "Which of the following is TRUE about the constructor method in class components?",
        "o": [
            "It is typically used to initialize state and bind methods",
            "It is mandatory in every class component",
            "It replaces the render method",
            "It cannot access props"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 5 };\n  }\n  render() {\n    return <p>{this.state.count}</p>;\n  }\n}\n\n<App />",
        "o": [
            "5",
            "{this.state.count}",
            "undefined",
            "Error: state not available in class components"
        ]
    },
    {
        "q": "Which lifecycle method runs immediately after a component is mounted?",
        "o": [
            "componentDidMount",
            "componentWillUnmount",
            "render",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "What is the main purpose of shouldComponentUpdate in class components?",
        "o": [
            "To control whether the component should re-render or not",
            "To reset the component state",
            "To initialize props",
            "To mount children components"
        ]
    },
    {
        "q": "What will happen?",
        "c": "class Counter extends React.Component {\n  render() {\n    return <h1>{this.state.value}</h1>;\n  }\n}\n\n<Counter />",
        "o": [
            "Error: state is undefined unless initialized",
            "0",
            "null",
            "{this.state.value}"
        ]
    },
    {
        "q": "Which of the following is TRUE about defaultProps?",
        "o": [
            "They define fallback values for props when none are provided",
            "They override explicitly passed props",
            "They are required for every component",
            "They only work in functional components"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "class Greeting extends React.Component {\n  static defaultProps = { name: 'Guest' };\n  render() {\n    return <h2>Hello {this.props.name}</h2>;\n  }\n}\n\n<Greeting />",
        "o": [
            "Hello Guest",
            "Hello",
            "undefined",
            "Error: defaultProps not allowed in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about render() in class components?",
        "o": [
            "It must return a React element or null",
            "It can directly modify props",
            "It is called only once during the component's lifetime",
            "It cannot contain JSX"
        ]
    },
    {
        "q": "What is the purpose of super(props) in a class component constructor?",
        "o": [
            "It allows access to this.props inside the constructor",
            "It initializes state automatically",
            "It defines default values for children",
            "It binds methods to the class instance"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "class Display extends React.Component {\n  render() {\n    return Array.isArray(this.props.items) ? <p>Array received</p> : <p>No array</p>;\n  }\n}\n\n<Display items={[10, 20]} />",
        "o": [
            "Array received",
            "No array",
            "[10,20]",
            "Error: props cannot hold arrays"
        ]
    },
    {
        "q": "Which of the following is TRUE about componentWillUnmount in class components?",
        "o": [
            "It is used for cleanup like removing event listeners",
            "It is called before the first render",
            "It is used to initialize state",
            "It prevents a component from unmounting"
        ]
    },
    {
        "q": "What will be logged?",
        "c": "class Logger extends React.Component {\n  componentDidMount() {\n    console.log('Mounted');\n  }\n  render() {\n    return <p>Logger</p>;\n  }\n}\n\n<Logger />",
        "o": [
            "Mounted",
            "Logger",
            "Mounted Logger",
            "Nothing"
        ]
    },
    {
        "q": "Which of the following is TRUE about props in React?",
        "o": [
            "They flow in one direction, from parent to child",
            "They can be passed both from child to parent and parent to child",
            "They are used to manage internal state",
            "They can only be passed into class components"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "class Welcome extends React.Component {\n  render() {\n    return <h1>{this.props.greeting}, {this.props.name}</h1>;\n  }\n}\n\n<Welcome greeting=\"Hi\" name=\"Sam\" />",
        "o": [
            "Hi, Sam",
            "greeting, name",
            "Hi, {this.props.name}",
            "Error: Cannot use multiple props"
        ]
    },
    {
        "q": "Which of the following is TRUE about state in class components?",
        "o": [
            "State must be updated using setState()",
            "State can be updated directly like this.state.value = 1",
            "State is immutable",
            "State cannot hold objects"
        ]
    },
    {
        "q": "What happens when setState() is called in a class component?",
        "o": [
            "The component re-renders with the new state",
            "The state is updated immediately and synchronously",
            "Props are automatically updated",
            "The component unmounts and mounts again"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return <h2>{this.state.count + 5}</h2>;\n  }\n}\n\n<Counter />",
        "o": [
            "5",
            "0",
            "{this.state.count + 5}",
            "Error: Cannot perform arithmetic on state"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component naming?",
        "o": [
            "Component names must start with a capital letter",
            "Component names must always be lowercase",
            "Component names must be stored in a string",
            "Component names must match their file name"
        ]
    },
    {
        "q": "What will the following component render?",
        "c": "function Wrapper(props) {\n  return <div>{props.children || 'Empty'}</div>;\n}\n\n<Wrapper />",
        "o": [
            "Empty",
            "{props.children}",
            "undefined",
            "Error: children must be passed"
        ]
    },
    {
        "q": "Which of the following is TRUE about React's render() method?",
        "o": [
            "It should be a pure function of props and state",
            "It should modify state directly before returning JSX",
            "It can return multiple root elements without a wrapper",
            "It is executed only once during the lifecycle"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component re-rendering?",
        "o": [
            "A component re-renders when its props or state change",
            "A component re-renders only once after mounting",
            "A component re-renders when its file name changes",
            "A component re-renders only if children are updated"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function InfoBox(props) {\n  return <div>{props.title}: {props.value}</div>;\n}\n\n<InfoBox title=\"Age\" value={30} />",
        "o": [
            "Age: 30",
            "title: value",
            "Age: {props.value}",
            "Error: Numbers not allowed in props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Fragment?",
        "o": [
            "It allows grouping multiple elements without adding extra DOM nodes",
            "It works the same as a div",
            "It automatically adds a span wrapper",
            "It can only be used in class components"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "class Note extends React.Component {\n  render() {\n    return <p>{this.props.text || 'No note'}</p>;\n  }\n}\n\n<Note />",
        "o": [
            "No note",
            "undefined",
            "text",
            "Error: Missing required prop"
        ]
    },
    {
        "q": "Which of the following is a correct use of defaultProps with a functional component?",
        "o": [
            "MyComp.defaultProps = { msg: 'Hello' };",
            "function.defaultProps = { msg: 'Hello' };",
            "defaultProps.MyComp = { msg: 'Hello' };",
            "props.default = { msg: 'Hello' };"
        ]
    },
    {
        "q": "Which of the following is TRUE about props immutability?",
        "o": [
            "Props cannot be changed by the receiving component",
            "Props can only be changed inside componentDidMount",
            "Props can be reassigned like state",
            "Props change automatically when state updates"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function ItemList(props) {\n  return <p>{props.items.join(', ')}</p>;\n}\n\n<ItemList items={[\"Pen\", \"Book\"]} />",
        "o": [
            "Pen, Book",
            "[\"Pen\", \"Book\"]",
            "items",
            "Error: Cannot render arrays in props"
        ]
    },
    {
        "q": "Which of the following is a difference between state and props?",
        "o": [
            "State is managed inside the component, props are passed from outside",
            "State is immutable, props are mutable",
            "Props must always be numbers, state must be strings",
            "Props update automatically when state changes"
        ]
    },
    {
        "q": "What will be rendered?",
        "c": "class Title extends React.Component {\n  render() {\n    return <h1>{this.props.heading.toLowerCase()}</h1>;\n  }\n}\n\n<Title heading=\"REACT\" />",
        "o": [
            "react",
            "REACT",
            "{this.props.heading}",
            "Error: Cannot call string methods on props"
        ]
    },
    {
        "q": "Which of the following is TRUE about component composition in React?",
        "o": [
            "Components can be nested inside each other",
            "Components must always be standalone",
            "Only class components can contain other components",
            "Children cannot be passed into components"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX?",
        "o": [
            "JSX allows embedding JavaScript expressions inside curly braces",
            "JSX can only contain plain text",
            "JSX must be compiled manually before use",
            "JSX cannot include function calls"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function Double(props) {\n  return <h2>{props.num * 2}</h2>;\n}\n\n<Double num={4} />",
        "o": [
            "8",
            "4",
            "num * 2",
            "Error: Numbers not supported in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about component keys?",
        "o": [
            "Keys must be unique among siblings in a list",
            "Keys must always be globally unique",
            "Keys are optional and do not affect rendering",
            "Keys are automatically generated by React for all lists"
        ]
    },
    {
        "q": "What happens if two sibling components in a list share the same key?",
        "o": [
            "React may reuse or misidentify elements, causing rendering issues",
            "React will throw a syntax error",
            "React automatically renames the keys",
            "React will ignore one of the elements"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Greeting(props) {\n  return <h1>{`Hello, ${props.name}`}</h1>;\n}\n\n<Greeting name=\"Alex\" />",
        "o": [
            "Hello, Alex",
            "Hello, {props.name}",
            "Alex",
            "Error: Template literals not supported in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about render() method side effects?",
        "o": [
            "Render should remain pure and not cause side effects",
            "Render can directly update state safely",
            "Render can call APIs",
            "Render is executed only when the app starts"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "class Length extends React.Component {\n  render() {\n    return <p>{this.props.text.length}</p>;\n  }\n}\n\n<Length text=\"React\" />",
        "o": [
            "5",
            "React",
            "{this.props.text.length}",
            "Error: Cannot use length on props"
        ]
    },
    {
        "q": "Which of the following is TRUE about inline styles in JSX?",
        "o": [
            "They are written as objects with camelCase property names",
            "They must be written as plain strings like in HTML",
            "They can only be applied to class components",
            "They are not supported in React"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function PriceTag(props) {\n  return <p>${props.amount.toFixed(2)}</p>;\n}\n\n<PriceTag amount={9} />",
        "o": [
            "$9.00",
            "$9",
            "9.00",
            "Error: Cannot use toFixed in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about returning null in a component?",
        "o": [
            "It means the component renders nothing but stays in the tree",
            "It unmounts the component completely",
            "It throws an error",
            "It prevents child components from rendering"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component composition?",
        "o": [
            "It allows building complex UIs by combining smaller components",
            "It only works with class components",
            "It requires using higher-order components",
            "It prevents passing children"
        ]
    },
    {
        "q": "What will the following code display?",
        "c": "function Avatar(props) {\n  return <img src={props.src} alt={props.alt} />;\n}\n\n<Avatar src=\"profile.png\" alt=\"User Avatar\" />",
        "o": [
            "An image with source 'profile.png' and alt text 'User Avatar'",
            "profile.png",
            "User Avatar",
            "Error: props cannot hold strings"
        ]
    },
    {
        "q": "Which of the following is TRUE about higher-order components (HOC)?",
        "o": [
            "They are functions that take a component and return a new component",
            "They are special types of JSX elements",
            "They are lifecycle methods in class components",
            "They are children passed into a component"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function Highlight(props) {\n  return <mark>{props.children}</mark>;\n}\n\n<Highlight>Important</Highlight>",
        "o": [
            "Important highlighted with <mark>",
            "Important",
            "{props.children}",
            "Error: mark is not a valid JSX element"
        ]
    },
    {
        "q": "Which of the following is TRUE about conditional rendering in React?",
        "o": [
            "It can be done using JavaScript operators like && or ternary inside JSX",
            "It requires a special React keyword",
            "It can only be done inside class components",
            "It does not work with props"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Show(props) {\n  return <p>{props.visible && 'Visible'}</p>;\n}\n\n<Show visible={false} />",
        "o": [
            "An empty paragraph",
            "Visible",
            "false",
            "Error: Cannot use && in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about props spreading?",
        "o": [
            "It allows passing all properties of an object to a component at once",
            "It overwrites React's default props behavior",
            "It is only available in class components",
            "It automatically converts state into props"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "const details = { title: 'Book', price: 20 };\n\nfunction Product(props) {\n  return <h2>{props.title} - ${props.price}</h2>;\n}\n\n<Product {...details} />",
        "o": [
            "Book - $20",
            "{title} - {price}",
            "Book - price",
            "Error: Cannot spread props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys in lists?",
        "o": [
            "Keys help React identify which items changed, added, or removed",
            "Keys are visible as props to the component",
            "Keys must always be random numbers",
            "Keys are required only when rendering images"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Item(props) {\n  return <li>{props.name}</li>;\n}\n\n<ul>\n  {['Pen', 'Book'].map((x, i) => <Item key={i} name={x} />)}\n</ul>",
        "o": [
            "A list with 'Pen' and 'Book'",
            "Only 'Pen'",
            "Only 'Book'",
            "Error: Cannot use map in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about defaultProps in React?",
        "o": [
            "They provide fallback values when props are not passed",
            "They override explicitly passed props",
            "They can only be used in class components",
            "They are required for every component"
        ]
    },
    {
        "q": "What will the following code display?",
        "c": "function Banner(props) {\n  return <h1>{props.message}</h1>;\n}\n\nBanner.defaultProps = {\n  message: 'Welcome!'\n};\n\n<Banner />",
        "o": [
            "Welcome!",
            "message",
            "undefined",
            "Error: defaultProps not supported in functions"
        ]
    },
    {
        "q": "Which of the following is TRUE about children prop?",
        "o": [
            "It automatically contains any elements nested inside a component",
            "It must always be a string",
            "It can only be used in class components",
            "It prevents props from being used"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Wrapper(props) {\n  return <div>{props.children}</div>;\n}\n\n<Wrapper><p>Inside</p></Wrapper>",
        "o": [
            "<div><p>Inside</p></div>",
            "<div>children</div>",
            "Inside",
            "Error: Cannot use children in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about functional components?",
        "o": [
            "They are plain JavaScript functions that return JSX",
            "They must always manage state",
            "They cannot accept props",
            "They are required to extend React.Component"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Multiply(props) {\n  return <span>{props.a * props.b}</span>;\n}\n\n<Multiply a={3} b={4} />",
        "o": [
            "12",
            "7",
            "a * b",
            "Error: Cannot multiply props"
        ]
    },
    {
        "q": "Which of the following is TRUE about component props validation?",
        "o": [
            "PropTypes can be used to specify expected prop types",
            "React automatically validates props at runtime",
            "Only state can be validated, not props",
            "Props must always be numbers unless validated"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Label(props) {\n  return <p>{props.text || 'Default'}</p>;\n}\n\n<Label />",
        "o": [
            "Default",
            "undefined",
            "text",
            "Error: Missing prop"
        ]
    },
    {
        "q": "Which of the following is TRUE about React components returning arrays?",
        "o": [
            "Components can return arrays of elements if each has a key",
            "Components cannot return arrays",
            "Arrays must always be wrapped in a div",
            "Arrays can only be returned by class components"
        ]
    },
    {
        "q": "What will the following render?",
        "c": "function List() {\n  return [<li key=\"1\">One</li>, <li key=\"2\">Two</li>];\n}\n\n<ul><List /></ul>",
        "o": [
            "A list with 'One' and 'Two'",
            "One",
            "Two",
            "Error: Arrays not supported"
        ]
    },
    {
        "q": "Which of the following is TRUE about component reusability?",
        "o": [
            "Components can be reused by passing different props",
            "Components can only be reused if they are class components",
            "Components cannot be reused once rendered",
            "Components must have the same props every time they are used"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Card(props) {\n  return <div>{props.title}: {props.children}</div>;\n}\n\n<Card title=\"Note\">Read later</Card>",
        "o": [
            "Note: Read later",
            "Note",
            "Read later",
            "Error: Cannot mix props and children"
        ]
    },
    {
        "q": "Which of the following is TRUE about inline event handlers in React?",
        "o": [
            "They are written in camelCase, e.g., onClick",
            "They must always be lowercase like in HTML",
            "They can only be attached to buttons",
            "They cannot call custom functions"
        ]
    },
    {
        "q": "What will the following code do when the button is clicked?",
        "c": "function App() {\n  return <button onClick={() => alert('Clicked!')}>Press</button>;\n}",
        "o": [
            "Show an alert with 'Clicked!'",
            "Do nothing",
            "Throw an error",
            "Render 'Clicked!' on the page"
        ]
    },
    {
        "q": "Which of the following is TRUE about component naming conventions?",
        "o": [
            "Component names should start with a capital letter",
            "Component names must always be lowercase",
            "Component names must match their file names exactly",
            "Component names can contain spaces"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Hello(props) {\n  return <h1>Hello {props.name.toUpperCase()}</h1>;\n}\n\n<Hello name=\"tom\" />",
        "o": [
            "Hello TOM",
            "Hello tom",
            "Hello {props.name}",
            "Error: Cannot use toUpperCase in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about component props default behavior?",
        "o": [
            "If a prop is not passed, its value is undefined unless defaultProps are defined",
            "If a prop is not passed, React throws an error",
            "Props must always have default values",
            "Props default to null if not passed"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function ShowCount(props) {\n  return <p>{props.count ?? 'No count'}</p>;\n}\n\n<ShowCount />",
        "o": [
            "No count",
            "undefined",
            "count",
            "Error: Cannot use ?? in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React functional components with arrow functions?",
        "o": [
            "They are commonly written as const MyComp = (props) => JSX",
            "They cannot accept props",
            "They must always return null",
            "They are only valid inside class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "const Info = (props) => <span>{props.label}: {props.value}</span>;\n\n<Info label=\"Age\" value={25} />",
        "o": [
            "Age: 25",
            "label: value",
            "25",
            "Error: Arrow functions cannot return JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component return values?",
        "o": [
            "A component must return a single root element or null",
            "A component can return multiple sibling elements without keys",
            "A component can return any type including numbers directly",
            "A component must always return a div"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status(props) {\n  return <p>{props.online ? 'Online' : 'Offline'}</p>;\n}\n\n<Status online={true} />",
        "o": [
            "Online",
            "Offline",
            "true",
            "Error: Cannot use ternary operator in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React children prop?",
        "o": [
            "It can contain elements, strings, or even functions",
            "It must always be a string",
            "It only works inside class components",
            "It cannot be combined with other props"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Box(props) {\n  return <div style={{ border: '1px solid black' }}>{props.children}</div>;\n}\n\n<Box><p>Inside box</p></Box>",
        "o": [
            "A bordered div containing 'Inside box'",
            "Inside box",
            "children",
            "Error: Cannot apply styles in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about props destructuring in functional components?",
        "o": [
            "Props can be destructured directly in the function parameter list",
            "Props must always be accessed via props.key",
            "Props destructuring only works in class components",
            "Props destructuring removes the need to pass props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function User({ name, role }) {\n  return <h2>{name} - {role}</h2>;\n}\n\n<User name=\"Alice\" role=\"Admin\" />",
        "o": [
            "Alice - Admin",
            "name - role",
            "Alice",
            "Error: Cannot destructure props"
        ]
    },
    {
        "q": "Which of the following is TRUE about conditional component rendering?",
        "o": [
            "Components can return null to render nothing",
            "Components must always render something",
            "Components must throw an error if they return null",
            "Conditional rendering only works in class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Notice(props) {\n  if (!props.show) return null;\n  return <p>Visible Notice</p>;\n}\n\n<Notice show={false} />",
        "o": [
            "Nothing is rendered",
            "Visible Notice",
            "false",
            "Error: Components cannot return null"
        ]
    },
    {
        "q": "Which of the following is TRUE about React functional components compared to class components?",
        "o": [
            "Functional components are simpler and do not use lifecycle methods",
            "Functional components cannot receive props",
            "Class components cannot render JSX",
            "Functional components are slower than class components by design"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Add(props) {\n  return <p>{props.x + props.y}</p>;\n}\n\n<Add x={10} y={15} />",
        "o": [
            "25",
            "10",
            "15",
            "Error: Cannot add props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React props?",
        "o": [
            "Props are read-only and cannot be modified by the child component",
            "Props can be reassigned inside the child component",
            "Props always require default values",
            "Props can only pass strings, not numbers or objects"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Title(props) {\n  return <h1>{props.text}</h1>;\n}\n\n<Title text={42} />",
        "o": [
            "42",
            "text",
            "{props.text}",
            "Error: Cannot pass number as prop"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component rendering performance?",
        "o": [
            "Using keys in lists helps React optimize rendering",
            "Using keys in lists makes components run slower",
            "Keys are used only for styling",
            "Keys are optional and never recommended"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Badge(props) {\n  return <span>{props.label || 'Default Badge'}</span>;\n}\n\n<Badge label=\"New\" />",
        "o": [
            "New",
            "Default Badge",
            "label",
            "Error: Cannot use || in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX attributes?",
        "o": [
            "They use camelCase naming convention like onClick or className",
            "They must be lowercase like in HTML",
            "They cannot take JavaScript expressions",
            "They are limited to strings only"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Item(props) {\n  return <li>{props.name.toLowerCase()}</li>;\n}\n\n<Item name=\"BOOK\" />",
        "o": [
            "book",
            "BOOK",
            "{props.name}",
            "Error: Cannot call string methods in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React functional components without props?",
        "o": [
            "They are valid and can still return JSX",
            "They must always accept props as a parameter",
            "They must extend React.Component",
            "They cannot be used in modern React"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Message() {\n  return <p>Hello World</p>;\n}\n\n<Message />",
        "o": [
            "Hello World",
            "Message",
            "{Hello World}",
            "Error: Missing props"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing functions as props?",
        "o": [
            "Functions can be passed as props and invoked in child components",
            "Functions cannot be passed as props",
            "Functions passed as props are automatically executed",
            "Functions must be converted to strings before passing"
        ]
    },
    {
        "q": "What will happen when the button is clicked?",
        "c": "function Button(props) {\n  return <button onClick={props.onPress}>Click</button>;\n}\n\n<Button onPress={() => alert('Pressed!')} />",
        "o": [
            "An alert saying 'Pressed!' will appear",
            "The button will display 'Pressed!' text",
            "Nothing happens",
            "Error: Cannot pass functions as props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component trees?",
        "o": [
            "Props flow from parent components to child components",
            "Props flow bidirectionally between parent and child",
            "State and props are interchangeable",
            "Children components cannot receive props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting(props) {\n  return <h2>{props.msg}, {props.user}</h2>;\n}\n\n<Greeting msg=\"Hi\" user=\"Sam\" />",
        "o": [
            "Hi, Sam",
            "msg, user",
            "Hi",
            "Error: Multiple props not allowed"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys?",
        "o": [
            "Keys must be unique only among siblings",
            "Keys must be globally unique across the entire app",
            "Keys can be duplicated without issue",
            "Keys are optional in lists and have no effect"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Items(props) {\n  return <ul>{props.list.map((x, i) => <li key={i}>{x}</li>)}</ul>;\n}\n\n<Items list={[\"Pen\", \"Book\", \"Bag\"]} />",
        "o": [
            "A list with 'Pen', 'Book', and 'Bag'",
            "[\"Pen\", \"Book\", \"Bag\"]",
            "PenBookBag",
            "Error: Cannot render lists with map"
        ]
    },
    {
        "q": "Which of the following is TRUE about props.children?",
        "o": [
            "It allows components to display nested JSX passed to them",
            "It only accepts text values",
            "It only works in class components",
            "It replaces defaultProps when used"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Wrapper(props) {\n  return <div>{props.children}</div>;\n}\n\n<Wrapper><h3>Inside</h3></Wrapper>",
        "o": [
            "<div><h3>Inside</h3></div>",
            "Inside",
            "{props.children}",
            "Error: Cannot nest elements"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop types?",
        "o": [
            "They help document expected types of props in a component",
            "They are required in every React component",
            "They prevent passing arrays as props",
            "They automatically convert types at runtime"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function ShowName(props) {\n  return <p>{props.first + ' ' + props.last}</p>;\n}\n\n<ShowName first=\"John\" last=\"Doe\" />",
        "o": [
            "John Doe",
            "first last",
            "John",
            "Error: Cannot concatenate props"
        ]
    },
    {
        "q": "Which of the following is TRUE about props immutability?",
        "o": [
            "Props cannot be modified by the component that receives them",
            "Props can be directly reassigned inside the child",
            "Props are mutable like state",
            "Props update automatically when state changes"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Note(props) {\n  props.text = 'Changed';\n  return <p>{props.text}</p>;\n}\n\n<Note text=\"Original\" />",
        "o": [
            "Error: Cannot reassign props",
            "Changed",
            "Original",
            "{props.text}"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component export?",
        "o": [
            "Components can be exported as default or named exports",
            "Components must always be default exports",
            "Components cannot be exported from a file",
            "Only class components can be exported"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function AlertBox(props) {\n  return <div>{props.type}: {props.message}</div>;\n}\n\n<AlertBox type=\"Error\" message=\"Something went wrong\" />",
        "o": [
            "Error: Something went wrong",
            "type: message",
            "Error message",
            "Something went wrong"
        ]
    },
    {
        "q": "Which of the following is TRUE about inline conditional rendering?",
        "o": [
            "It can be done using logical && inside JSX",
            "It requires a special React keyword",
            "It cannot be done in functional components",
            "It is only valid inside render() of class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Info(props) {\n  return <p>{props.show && 'Details Available'}</p>;\n}\n\n<Info show={true} />",
        "o": [
            "Details Available",
            "true",
            "show",
            "Error: Cannot use && in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component naming?",
        "o": [
            "Components should start with a capital letter to be recognized",
            "Components must always match their file name",
            "Components can be lowercase without issues",
            "Components must include 'Comp' in the name"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Footer(props) {\n  return <footer>{props.year}</footer>;\n}\n\n<Footer year={2025} />",
        "o": [
            "2025",
            "year",
            "{props.year}",
            "Error: Numbers cannot be props"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX expressions?",
        "o": [
            "Any valid JavaScript expression can be embedded inside curly braces",
            "Only strings can be used inside curly braces",
            "Curly braces are only valid in class components",
            "Curly braces cannot be used in JSX at all"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function DoubleValue(props) {\n  return <p>{props.num * 2}</p>;\n}\n\n<DoubleValue num={7} />",
        "o": [
            "14",
            "7",
            "num * 2",
            "Error: Arithmetic not allowed in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React props with objects?",
        "o": [
            "Objects can be passed as props and accessed inside the component",
            "Objects cannot be passed as props",
            "Objects must be converted to strings before passing",
            "Objects can only be passed to class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Profile(props) {\n  return <h3>{props.user.name}</h3>;\n}\n\n<Profile user={{ name: 'Emma' }} />",
        "o": [
            "Emma",
            "user.name",
            "{props.user.name}",
            "Error: Cannot pass objects as props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React functional components?",
        "o": [
            "They are simpler and often used for UI without lifecycle methods",
            "They cannot return JSX",
            "They must always have state",
            "They cannot use props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Quote(props) {\n  return <blockquote>{props.text}</blockquote>;\n}\n\n<Quote text=\"Stay positive\" />",
        "o": [
            "Stay positive",
            "text",
            "{props.text}",
            "Error: blockquote not supported in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing arrays as props?",
        "o": [
            "Arrays can be passed as props and rendered using map",
            "Arrays cannot be used as props",
            "Arrays must be converted to strings before passing",
            "Arrays only work in class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function ListItems(props) {\n  return <ul>{props.items.map((x, i) => <li key={i}>{x}</li>)}</ul>;\n}\n\n<ListItems items={[\"A\", \"B\"]} />",
        "o": [
            "A list with A and B",
            "[\"A\", \"B\"]",
            "AB",
            "Error: Arrays not allowed in props"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX attributes like className?",
        "o": [
            "className is used instead of class in JSX",
            "class must always be used like in HTML",
            "className only works in class components",
            "className must be wrapped in curly braces"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Styled() {\n  return <p className=\"highlight\">Text</p>;\n}\n\n<Styled />",
        "o": [
            "<p class=\"highlight\">Text</p>",
            "highlight",
            "Text",
            "Error: className not supported"
        ]
    },
    {
        "q": "Which of the following is TRUE about returning multiple elements?",
        "o": [
            "You can wrap multiple elements inside React.Fragment",
            "You cannot return multiple elements at all",
            "You must always wrap them in a div",
            "You must return them as strings"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Pair() {\n  return (\n    <>\n      <span>One</span>\n      <span>Two</span>\n    </>\n  );\n}\n\n<Pair />",
        "o": [
            "OneTwo",
            "One Two",
            "<>One Two</>",
            "Error: <> not supported"
        ]
    },
    {
        "q": "Which of the following is TRUE about props default behavior?",
        "o": [
            "If a prop is missing, it will be undefined unless defaultProps is set",
            "If a prop is missing, React throws an error",
            "Props must always be provided for a component",
            "Props automatically fallback to empty string"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Label(props) {\n  return <span>{props.value || 'N/A'}</span>;\n}\n\n<Label />",
        "o": [
            "N/A",
            "undefined",
            "value",
            "Error: Missing prop not allowed"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing functions as props in React?",
        "o": [
            "Functions can be passed from parent to child and invoked in the child component",
            "Functions cannot be passed as props",
            "Functions passed as props are automatically executed",
            "Only arrow functions can be passed as props"
        ]
    },
    {
        "q": "What will happen when the button is clicked?",
        "c": "function Clicker(props) {\n  return <button onClick={props.onClick}>Click Me</button>;\n}\n\n<Clicker onClick={() => alert('Button clicked!')} />",
        "o": [
            "An alert with 'Button clicked!' appears",
            "Nothing happens",
            "Click Me is displayed as an alert",
            "Error: Functions cannot be passed as props"
        ]
    },
    {
        "q": "Which of the following is TRUE about component composition?",
        "o": [
            "Components can be nested to create more complex UIs",
            "Components cannot include other components",
            "Only class components can be composed",
            "Composition prevents the use of props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Card(props) {\n  return <div><h2>{props.title}</h2>{props.children}</div>;\n}\n\n<Card title=\"Hello\"><p>Content</p></Card>",
        "o": [
            "<div><h2>Hello</h2><p>Content</p></div>",
            "Hello Content",
            "Content",
            "Error: Cannot use children with props"
        ]
    },
    {
        "q": "Which of the following is TRUE about functional component props destructuring?",
        "o": [
            "Props can be destructured directly in the parameter list",
            "Props must always be accessed via props.key",
            "Destructuring only works in class components",
            "Destructuring removes the need to pass props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function User({ name, age }) {\n  return <p>{name} is {age} years old</p>;\n}\n\n<User name=\"Alice\" age={25} />",
        "o": [
            "Alice is 25 years old",
            "name is age years old",
            "{name} is {age}",
            "Error: Cannot destructure props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component state in class components?",
        "o": [
            "State is managed inside the component and can change over time",
            "State must always be passed from parent as props",
            "State cannot be an object",
            "State is immutable like props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return <p>{this.state.count + 1}</p>;\n  }\n}\n\n<Counter />",
        "o": [
            "1",
            "0",
            "{this.state.count + 1}",
            "Error: Cannot use state in render"
        ]
    },
    {
        "q": "Which of the following is TRUE about React fragments?",
        "o": [
            "They allow grouping multiple elements without adding extra nodes to the DOM",
            "They must always have a key",
            "They can only be used in class components",
            "They automatically wrap content in a div"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Pair() {\n  return (\n    <>\n      <span>First</span>\n      <span>Second</span>\n    </>\n  );\n}\n\n<Pair />",
        "o": [
            "FirstSecond",
            "First Second",
            "<>First Second</>",
            "Error: Fragments not supported"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing props to child components?",
        "o": [
            "Props are used to pass data from parent to child components",
            "Props can only pass strings",
            "Props are only available in class components",
            "Props can be modified by the child component"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Welcome(props) {\n  return <h1>Welcome, {props.name}</h1>;\n}\n\n<Welcome name=\"John\" />",
        "o": [
            "Welcome, John",
            "Welcome, {props.name}",
            "John",
            "Error: Cannot pass props to functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about component lifecycle methods in class components?",
        "o": [
            "They allow you to hook into different stages like mounting and unmounting",
            "They are only used in functional components",
            "They replace the render() method",
            "They are required for every component"
        ]
    },
    {
        "q": "What will this render after componentDidMount?",
        "c": "class Demo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { text: 'Initial' };\n  }\n  componentDidMount() {\n    this.setState({ text: 'Mounted' });\n  }\n  render() {\n    return <p>{this.state.text}</p>;\n  }\n}\n\n<Demo />",
        "o": [
            "Mounted",
            "Initial",
            "{this.state.text}",
            "Error: Cannot use state in componentDidMount"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing children to a component?",
        "o": [
            "Children can be any valid JSX, including elements and text",
            "Children must always be strings",
            "Children only work in class components",
            "Children cannot be combined with other props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Container(props) {\n  return <div>{props.children}</div>;\n}\n\n<Container><p>Content</p></Container>",
        "o": [
            "<div><p>Content</p></div>",
            "Content",
            "{props.children}",
            "Error: Cannot render children"
        ]
    },
    {
        "q": "Which of the following is TRUE about using setState in class components?",
        "o": [
            "setState schedules an update to the component state and triggers a re-render",
            "setState immediately updates state synchronously",
            "setState can only be called in render()",
            "setState replaces the props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 2 };\n  }\n  render() {\n    return <p>{this.state.count * 2}</p>;\n  }\n}\n\n<Counter />",
        "o": [
            "4",
            "2",
            "{this.state.count * 2}",
            "Error: Cannot use arithmetic in render"
        ]
    },
    {
        "q": "Which of the following is TRUE about React event handling?",
        "o": [
            "Event handlers in JSX use camelCase like onClick and can call functions",
            "Event handlers must always be lowercase like in HTML",
            "Event handlers can only be used on buttons",
            "Event handlers cannot use arrow functions"
        ]
    },
    {
        "q": "What will happen when the button is clicked?",
        "c": "function ClickMe() {\n  return <button onClick={() => console.log('Clicked!')}>Click</button>;\n}\n\n<ClickMe />",
        "o": [
            "Logs 'Clicked!' to the console",
            "Displays 'Clicked!' on screen",
            "Nothing happens",
            "Error: Cannot use arrow functions in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about using fragments in React?",
        "o": [
            "Fragments let you group multiple elements without adding extra DOM nodes",
            "Fragments automatically create a div wrapper",
            "Fragments can only be used in class components",
            "Fragments require a key even if there is only one child"
        ]
    },
    {
        "q": "Which of the following is TRUE about component re-rendering in React?",
        "o": [
            "A component re-renders when its state or props change",
            "A component re-renders only once after mounting",
            "A component re-renders automatically every second",
            "A component never re-renders unless manually forced"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter(props) {\n  return <p>{props.start + 5}</p>;\n}\n\n<Counter start={10} />",
        "o": [
            "15",
            "10",
            "{props.start + 5}",
            "Error: Cannot do arithmetic in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about defaultProps in functional components?",
        "o": [
            "They provide default values for props if not passed",
            "They override values passed from the parent",
            "They can only be used in class components",
            "They are required for every prop"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Button(props) {\n  return <button>{props.label}</button>;\n}\n\nButton.defaultProps = { label: 'Click Me' };\n\n<Button />",
        "o": [
            "Click Me",
            "label",
            "{props.label}",
            "Error: defaultProps not allowed in functions"
        ]
    },
    {
        "q": "Which of the following is TRUE about conditional rendering?",
        "o": [
            "You can use ternary operators or && in JSX to conditionally render elements",
            "You must always use if-else outside of JSX",
            "Conditional rendering is not supported in functional components",
            "You cannot render null conditionally"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Show(props) {\n  return <p>{props.isVisible ? 'Visible' : 'Hidden'}</p>;\n}\n\n<Show isVisible={false} />",
        "o": [
            "Hidden",
            "Visible",
            "false",
            "Error: Cannot use ternary in JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component state?",
        "o": [
            "State is used to store data that changes over time within the component",
            "State must always be passed as props",
            "State is read-only and cannot be updated",
            "State is shared globally across all components by default"
        ]
    },
    {
        "q": "What will this render?",
        "c": "class Name extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: 'React' };\n  }\n  render() {\n    return <p>{this.state.name}</p>;\n  }\n}\n\n<Name />",
        "o": [
            "React",
            "{this.state.name}",
            "name",
            "Error: Cannot use state in render"
        ]
    },
    {
        "q": "Which of the following is TRUE about passing objects as props?",
        "o": [
            "Objects can be passed as props and their properties accessed inside the component",
            "Objects cannot be passed as props",
            "Objects must always be converted to JSON strings",
            "Objects automatically become state in the child component"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Profile(props) {\n  return <p>{props.user.name} is {props.user.age}</p>;\n}\n\n<Profile user={{ name: 'Emma', age: 30 }} />",
        "o": [
            "Emma is 30",
            "user.name is user.age",
            "{props.user.name} is {props.user.age}",
            "Error: Cannot pass objects as props"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component memoization?",
        "o": [
            "React.memo prevents unnecessary re-renders for functional components when props don’t change",
            "React.memo is used to manage state in class components",
            "React.memo automatically updates the DOM for all components",
            "React.memo can only be used with class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "const Greeting = React.memo(function Greeting(props) {\n  return <h1>Hello {props.name}</h1>;\n});\n\n<Greeting name=\"Sam\" />",
        "o": [
            "Hello Sam",
            "Hello {props.name}",
            "Sam",
            "Error: React.memo cannot wrap functions"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop type validation in React?",
        "o": [
            "PropTypes allow you to validate the type of props passed to a component",
            "PropTypes automatically convert types at runtime",
            "PropTypes are required for all props",
            "PropTypes replace defaultProps"
        ]
    },
    {
        "q": "What will happen if a prop type validation fails?",
        "o": [
            "A warning will appear in the console in development mode",
            "React will throw an error and stop rendering",
            "The prop value will be automatically corrected",
            "Nothing happens in any environment"
        ]
    },
    {
        "q": "Which of the following is TRUE about React refs?",
        "o": [
            "Refs provide a way to access DOM nodes or React elements directly",
            "Refs are used to store state in functional components",
            "Refs automatically trigger re-render when updated",
            "Refs can only be used with functional components"
        ]
    },
    {
        "q": "What will this do?",
        "c": "class Input extends React.Component {\n  constructor(props) {\n    super(props);\n    this.inputRef = React.createRef();\n  }\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n  render() {\n    return <input ref={this.inputRef} />;\n  }\n}\n\n<Input />",
        "o": [
            "The input will automatically be focused when the component mounts",
            "Nothing will happen",
            "The input value will be set to null",
            "Error: Refs cannot be used with input elements"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys in dynamic lists?",
        "o": [
            "Keys help React identify which items have changed, added, or removed",
            "Keys are used to set CSS class names",
            "Keys are required only for functional components",
            "Keys automatically assign unique IDs in the DOM"
        ]
    },
    {
        "q": "Which of the following is TRUE about controlled components?",
        "o": [
            "The form data is handled by React state rather than the DOM",
            "The DOM handles the form state independently",
            "Controlled components cannot use onChange handlers",
            "Controlled components cannot have default values"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function TextInput() {\n  const [value, setValue] = React.useState('');\n  return <input value={value} onChange={e => setValue(e.target.value)} />;\n}\n\n<TextInput />",
        "o": [
            "An input field controlled by React state",
            "An uncontrolled input field",
            "A disabled input field",
            "Error: Cannot use useState in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about uncontrolled components?",
        "o": [
            "The form data is handled by the DOM instead of React",
            "The form data is always managed by React state",
            "Uncontrolled components cannot use refs",
            "Uncontrolled components require onChange handlers"
        ]
    },
    {
        "q": "Which of the following is TRUE about React forwardRef?",
        "o": [
            "It allows passing a ref from parent to a child component",
            "It automatically manages state for child components",
            "It converts a functional component into a class component",
            "It prevents the child component from receiving props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "const FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref}>{props.label}</button>\n));\n\n<FancyButton label=\"Click\" />",
        "o": [
            "A button with the label 'Click' that can receive a ref",
            "Just the label 'Click'",
            "A div wrapping the label",
            "Error: forwardRef cannot be used with functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.lazy?",
        "o": [
            "React.lazy allows dynamic import of components for code-splitting",
            "React.lazy automatically preloads all components at once",
            "React.lazy is used to handle state in functional components",
            "React.lazy is only used for class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about Suspense in React?",
        "o": [
            "Suspense allows showing a fallback UI while lazy-loaded components are being loaded",
            "Suspense automatically renders all child components instantly",
            "Suspense replaces the need for state in functional components",
            "Suspense is only for class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React portals?",
        "o": [
            "Portals allow rendering children into a DOM node outside the parent component hierarchy",
            "Portals prevent props from being passed to children",
            "Portals automatically move state to the root component",
            "Portals can only be used with class components"
        ]
    },
    {
        "q": "What will this do?",
        "c": "ReactDOM.createPortal(<div>Modal</div>, document.getElementById('modal-root'))",
        "o": [
            "Render the div inside the DOM node with id 'modal-root'",
            "Render the div normally inside the parent component",
            "Prevent the div from rendering",
            "Throw an error because portals cannot be used"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.StrictMode?",
        "o": [
            "StrictMode helps identify potential problems by activating additional checks and warnings",
            "StrictMode renders components only once in production",
            "StrictMode replaces the need for PropTypes",
            "StrictMode automatically handles state updates"
        ]
    },
    {
        "q": "Which of the following is TRUE about error boundaries?",
        "o": [
            "Error boundaries catch JavaScript errors in child components and display a fallback UI",
            "Error boundaries can catch errors in their own component code",
            "Error boundaries prevent errors from occurring",
            "Error boundaries can only be used in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.memo with custom comparison function?",
        "o": [
            "You can pass a function to compare previous and next props to control re-rendering",
            "React.memo automatically compares nested object props deeply",
            "React.memo prevents all re-renders regardless of props changes",
            "React.memo is only used with class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useImperativeHandle hook?",
        "o": [
            "It customizes the instance value that is exposed when using ref in functional components",
            "It replaces useState for managing state",
            "It allows bypassing props validation",
            "It is only available in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about the useCallback hook?",
        "o": [
            "useCallback returns a memoized version of a function to prevent unnecessary re-creations",
            "useCallback is used to manage state directly",
            "useCallback automatically triggers re-render when props change",
            "useCallback is only used in class components"
        ]
    },
    {
        "q": "What will this do?",
        "c": "const memoizedFn = React.useCallback(() => console.log('Hello'), []);",
        "o": [
            "Create a memoized function that does not change between renders",
            "Immediately execute the function",
            "Replace the state variable with the function",
            "Cause an error because useCallback cannot be used outside render"
        ]
    },
    {
        "q": "Which of the following is TRUE about the useMemo hook?",
        "o": [
            "useMemo memoizes the result of a computation to optimize performance",
            "useMemo manages component state",
            "useMemo triggers re-renders automatically",
            "useMemo can only be used in class components"
        ]
    },
    {
        "q": "What will this return?",
        "c": "const result = React.useMemo(() => 2 + 3, []);",
        "o": [
            "5",
            "2+3",
            "undefined",
            "Error: Cannot use useMemo outside a component"
        ]
    },
    {
        "q": "Which of the following is TRUE about useRef hook?",
        "o": [
            "useRef returns a mutable ref object which persists across renders",
            "useRef automatically triggers re-renders when updated",
            "useRef replaces component state",
            "useRef can only store DOM nodes"
        ]
    },
    {
        "q": "What will this do?",
        "c": "const countRef = React.useRef(0);\ncountRef.current += 1;",
        "o": [
            "Increment the ref value without causing a re-render",
            "Increment state and re-render the component",
            "Throw an error because useRef is immutable",
            "Reset countRef to 0"
        ]
    },
    {
        "q": "Which of the following is TRUE about useLayoutEffect?",
        "o": [
            "useLayoutEffect fires synchronously after all DOM mutations",
            "useLayoutEffect runs asynchronously like useEffect",
            "useLayoutEffect is only for class components",
            "useLayoutEffect cannot access the DOM"
        ]
    },
    {
        "q": "Which of the following is TRUE about lazy loading components in React?",
        "o": [
            "React.lazy allows loading components dynamically to reduce bundle size",
            "React.lazy loads all components upfront",
            "React.lazy cannot be used with Suspense",
            "React.lazy is only valid in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useReducer hook?",
        "o": [
            "useReducer is used to manage complex state logic in functional components",
            "useReducer automatically replaces useState in class components",
            "useReducer cannot be used with props",
            "useReducer triggers state updates in parent components"
        ]
    },
    {
        "q": "What will this do?",
        "c": "const [state, dispatch] = React.useReducer((state, action) => state + action, 0);\ndispatch(5);",
        "o": [
            "Update state to 5 (0 + 5)",
            "Set state to 0",
            "Throw an error because dispatch cannot be called directly",
            "Do nothing"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.StrictMode in development?",
        "o": [
            "It activates additional checks and warnings for its descendants",
            "It disables rendering of child components",
            "It automatically fixes deprecated API usage",
            "It only runs in production builds"
        ]
    },
    {
        "q": "What will this do?",
        "c": "<React.StrictMode>\n  <App />\n</React.StrictMode>",
        "o": [
            "Render <App /> while enabling extra development checks and warnings",
            "Prevent <App /> from rendering",
            "Render <App /> only in production",
            "Automatically update deprecated lifecycle methods"
        ]
    },
    {
        "q": "Which of the following is TRUE about React context?",
        "o": [
            "Context provides a way to pass data through the component tree without passing props manually at every level",
            "Context replaces state management entirely",
            "Context can only pass strings",
            "Context can only be used in class components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "const ThemeContext = React.createContext('light');\nfunction Display() {\n  const theme = React.useContext(ThemeContext);\n  return <p>{theme}</p>;\n}\n\n<Display />",
        "o": [
            "light",
            "ThemeContext",
            "{theme}",
            "Error: Cannot use useContext outside provider"
        ]
    },
    {
        "q": "Which of the following is TRUE about error boundaries in React?",
        "o": [
            "They catch JavaScript errors in child components and show a fallback UI",
            "They catch errors in their own component code",
            "They prevent errors from occurring",
            "They are only used in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React defaultProps?",
        "o": [
            "They provide default values for props that are not passed",
            "They override props passed from parent",
            "They are mandatory for every prop",
            "They only work in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about the useDebugValue hook?",
        "o": [
            "It allows you to display debug information for custom hooks in React DevTools",
            "It manages component state",
            "It triggers re-render of components",
            "It replaces PropTypes for validation"
        ]
    },
    {
        "q": "Which of the following is TRUE about React event delegation?",
        "o": [
            "React uses a synthetic event system and delegates events at the root level",
            "React attaches events directly to each DOM element",
            "React cannot handle native events",
            "React events do not support stopPropagation or preventDefault"
        ]
    },
    {
        "q": "Which of the following is TRUE about React children map utilities?",
        "o": [
            "React.Children.map allows iterating over props.children safely even if it’s a single child",
            "props.children cannot be iterated",
            "React.Children.map modifies the original children array in place",
            "React.Children.map can only work with arrays, not single elements"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Wrapper(props) {\n  return React.Children.map(props.children, child => <div>{child}</div>);\n}\n\n<Wrapper><span>Test</span></Wrapper>",
        "o": [
            "<div><span>Test</span></div>",
            "Test",
            "{props.children}",
            "Error: Cannot map single child"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Portals?",
        "o": [
            "Portals allow rendering a component’s children into a DOM node outside the parent component hierarchy",
            "Portals replace the need for props in a component",
            "Portals automatically manage component state",
            "Portals can only be used inside class components"
        ]
    },
    {
        "q": "What will this do?",
        "c": "ReactDOM.createPortal(<div>Modal</div>, document.getElementById('modal-root'))",
        "o": [
            "Render the div inside the DOM node with id 'modal-root' outside the parent component hierarchy",
            "Render the div normally inside the parent component",
            "Prevent the div from rendering",
            "Throw an error because portals cannot be used in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useImperativeHandle hook?",
        "o": [
            "It customizes the instance value exposed when using refs in functional components",
            "It replaces useState for state management",
            "It automatically triggers re-renders",
            "It is only valid in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Profiler?",
        "o": [
            "React Profiler measures the performance of components by tracking render times",
            "React Profiler automatically optimizes component re-renders",
            "React Profiler replaces useEffect for side effects",
            "React Profiler is only available in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React batching updates?",
        "o": [
            "React batches multiple state updates inside event handlers to improve performance",
            "React always re-renders after each setState call individually",
            "Batching only works in class components",
            "Batching prevents props from being passed to children"
        ]
    },
    {
        "q": "Which of the following is TRUE about lazy-loaded components and Suspense?",
        "o": [
            "Suspense allows displaying a fallback UI while a lazy-loaded component is being fetched",
            "Suspense prevents the component from rendering until all lazy components load",
            "Suspense only works in class components",
            "Suspense replaces state management"
        ]
    },
    {
        "q": "Which of the following is TRUE about useTransition hook?",
        "o": [
            "useTransition lets you mark state updates as non-urgent to avoid blocking the UI",
            "useTransition replaces useState entirely",
            "useTransition triggers re-renders synchronously",
            "useTransition is only used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about the key prop in React lists?",
        "o": [
            "Keys help React identify which items have changed, been added, or removed",
            "Keys are optional and have no impact",
            "Keys can only be numbers",
            "Keys are automatically generated for nested components"
        ]
    },
    {
        "q": "Which of the following is TRUE about default exports of React components?",
        "o": [
            "A component exported as default can be imported with any name",
            "Default exports cannot be used with functional components",
            "A default export requires named import",
            "Default exports can only be used for class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about named exports of React components?",
        "o": [
            "Named exports must be imported using the exact exported name inside curly braces",
            "Named exports can be imported with any name without braces",
            "Named exports automatically become default exports",
            "Named exports cannot be used with functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about memoizing expensive computations in React?",
        "o": [
            "useMemo caches the result of a function and recalculates it only when dependencies change",
            "useMemo automatically triggers re-render of the component every time",
            "useMemo replaces state management",
            "useMemo can only be used in class components"
        ]
    },
    {
        "q": "What will this return?",
        "c": "const computed = React.useMemo(() => 10 * 10, []);",
        "o": [
            "100",
            "10 * 10",
            "undefined",
            "Error: Cannot use useMemo outside component"
        ]
    },
    {
        "q": "Which of the following is TRUE about React key usage with fragments?",
        "o": [
            "Keys can be applied to fragments when mapping over a list to help React identify elements",
            "Fragments do not support keys at all",
            "Keys in fragments automatically propagate to children",
            "Keys are not necessary in any fragment usage"
        ]
    },
    {
        "q": "Which of the following is TRUE about context provider value updates?",
        "o": [
            "All consuming components re-render whenever the provider value changes",
            "Context provider value cannot change after initialization",
            "Only newly mounted components receive the updated value",
            "Consumers automatically block updates unless useState is used"
        ]
    },
    {
        "q": "Which of the following is TRUE about nested context providers?",
        "o": [
            "Inner providers override the values of outer providers for their subtree",
            "Outer providers always take precedence over inner providers",
            "Nested providers cause an error",
            "Context values are merged automatically"
        ]
    },
    {
        "q": "Which of the following is TRUE about React defaultProps in functional components?",
        "o": [
            "defaultProps provide default values if a prop is not passed by the parent",
            "defaultProps override props passed by the parent",
            "defaultProps are required for every prop",
            "defaultProps cannot be used with functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useEffect cleanup function?",
        "o": [
            "The cleanup function runs before the component unmounts or before the effect re-runs",
            "Cleanup function is optional and never runs automatically",
            "Cleanup function replaces useState entirely",
            "Cleanup function can only run after unmount in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useEffect dependency array?",
        "o": [
            "Specifying dependencies ensures the effect runs only when they change",
            "Empty array causes the effect to run on every render",
            "Omitting the array triggers the effect only once",
            "Dependency arrays are only used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about nested functional components?",
        "o": [
            "Functional components can be defined inside other functional components and can access props of the parent if passed",
            "Nested components automatically inherit all state from the parent",
            "Nested components cannot be used with JSX",
            "Nested components cannot be rendered conditionally"
        ]
    },
    {
        "q": "Which of the following is TRUE about controlled vs uncontrolled components?",
        "o": [
            "Controlled components have their value managed by React state, while uncontrolled components rely on the DOM",
            "Controlled components cannot use state",
            "Uncontrolled components always block user input",
            "Controlled components are only used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Portals event propagation?",
        "o": [
            "Events from a portal propagate to ancestors in the React tree, not the DOM tree",
            "Events from a portal do not propagate at all",
            "Events propagate only to the DOM parent, not React components",
            "Portals block all event propagation"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.lazy and code splitting?",
        "o": [
            "React.lazy allows dynamic import of components to split bundles and improve performance",
            "React.lazy automatically preloads all components",
            "React.lazy is only for class components",
            "React.lazy replaces useEffect for asynchronous calls"
        ]
    },
    {
        "q": "Which of the following is TRUE about useSyncExternalStore hook?",
        "o": [
            "It subscribes to external stores and ensures consistent state updates across components",
            "It replaces useState entirely",
            "It can only be used in class components",
            "It automatically fetches data from APIs"
        ]
    },
    {
        "q": "Which of the following is TRUE about React's unstable_batchedUpdates?",
        "o": [
            "It allows multiple state updates to be batched outside React event handlers for performance optimization",
            "It triggers immediate re-render after every state update",
            "It replaces the need for useReducer",
            "It is only used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Profiler timings?",
        "o": [
            "Profiler measures render durations and commit times for components",
            "Profiler prevents unnecessary re-renders automatically",
            "Profiler replaces useEffect for performance tracking",
            "Profiler only works in production builds"
        ]
    },
    {
        "q": "Which of the following is TRUE about memoization of child components?",
        "o": [
            "React.memo prevents re-rendering of child components if their props have not changed",
            "React.memo triggers a re-render every time the parent renders",
            "React.memo can only be applied to class components",
            "React.memo replaces useEffect"
        ]
    },
    {
        "q": "Which of the following is TRUE about updating context in React?",
        "o": [
            "Updating context value triggers re-render of all consuming components below the provider",
            "Updating context only affects newly mounted components",
            "Context updates are asynchronous and cannot trigger renders",
            "Context cannot be updated once created"
        ]
    },
    {
        "q": "Which of the following is TRUE about React defaultProps with TypeScript?",
        "o": [
            "defaultProps can provide default values for missing props even in TypeScript components",
            "defaultProps are ignored when using TypeScript",
            "defaultProps override explicitly passed props in TypeScript",
            "defaultProps can only be used with class components in TypeScript"
        ]
    },
    {
        "q": "Which of the following is TRUE about forwarding refs through higher-order components?",
        "o": [
            "React.forwardRef can be used in HOCs to allow parent components to access refs",
            "Refs cannot be forwarded through HOCs",
            "Forwarding refs replaces the need for state",
            "Forwarding refs only works for DOM elements, not components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useId hook in React?",
        "o": [
            "useId generates unique IDs for accessibility attributes or lists to prevent collisions",
            "useId replaces state management in functional components",
            "useId automatically updates DOM elements",
            "useId can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useDeferredValue hook in React?",
        "o": [
            "useDeferredValue allows deferring a value to avoid blocking the UI during heavy computations",
            "useDeferredValue replaces useState for all updates",
            "useDeferredValue forces synchronous re-rendering",
            "useDeferredValue is only available in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React StrictMode double-invoking in development?",
        "o": [
            "In development, StrictMode double-invokes certain lifecycle methods and effects to help detect side-effects",
            "StrictMode double-invokes only in production builds",
            "Double-invoking breaks state management in class components",
            "StrictMode disables re-renders to improve performance"
        ]
    },
    {
        "q": "Which of the following is TRUE about useId hook for accessibility?",
        "o": [
            "useId can generate unique IDs that can be used for form inputs and labels",
            "useId automatically binds labels to inputs",
            "useId replaces the need for props",
            "useId is only valid in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React lazy fallback UI?",
        "o": [
            "Suspense fallback can display a loader or placeholder while the lazy component is being loaded",
            "Fallback is displayed permanently instead of the lazy component",
            "Fallback replaces state management for the component",
            "Fallback only works in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about useImperativeHandle customization?",
        "o": [
            "It allows a parent component with a ref to access a custom interface of a child component",
            "It automatically exposes all internal state to parent",
            "It replaces props for passing data to child",
            "It only works in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about memoizing callback functions in React?",
        "o": [
            "useCallback memoizes functions to prevent them from being recreated unnecessarily on re-renders",
            "useCallback triggers the function automatically",
            "useCallback replaces state management",
            "useCallback can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about error boundaries and lifecycle methods?",
        "o": [
            "Error boundaries can only catch errors in child components, not in themselves",
            "Error boundaries catch errors in all sibling components",
            "Error boundaries prevent all runtime errors",
            "Error boundaries only work with functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Profiler nested components?",
        "o": [
            "Profiler can measure render times for individual components including nested children",
            "Profiler prevents re-rendering of nested components",
            "Profiler replaces the need for useEffect for performance monitoring",
            "Profiler is only available in production builds"
        ]
    },
    {
        "q": "Which of the following is TRUE about batching state updates with useState?",
        "o": [
            "React batches multiple setState calls inside event handlers to optimize rendering",
            "setState calls are always applied immediately without batching",
            "Batching only works in class components",
            "Batching prevents props from updating"
        ]
    },
    {
        "q": "Which of the following is TRUE about nested providers in React Context?",
        "o": [
            "Inner providers override the context value of outer providers for their subtree",
            "Outer providers always take precedence regardless of inner provider",
            "Nested providers cannot be used",
            "Context values are automatically merged without explicit overriding"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Fragments?",
        "o": [
            "Fragments let you group multiple children without adding extra nodes to the DOM",
            "Fragments automatically add a div around elements",
            "Fragments can only contain a single child",
            "Fragments cannot be used with lists"
        ]
    },
    {
        "q": "What will this render?",
        "c": "return (\n  <>\n    <h1>Hello</h1>\n    <p>World</p>\n  </>\n);",
        "o": [
            "Both h1 and p elements without an extra wrapper",
            "Error: Adjacent JSX elements must be wrapped",
            "<div><h1>Hello</h1><p>World</p></div>",
            "Only the h1 element"
        ]
    },
    {
        "q": "Which of the following is TRUE about React controlled components?",
        "o": [
            "Their value is controlled by React state and updated via props/state",
            "Their value is stored only in the DOM",
            "They cannot use onChange handlers",
            "They are only supported in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about uncontrolled components?",
        "o": [
            "They store their state in the DOM rather than in React state",
            "They are the same as controlled components",
            "They cannot use refs",
            "They automatically sync with React state"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop drilling?",
        "o": [
            "It refers to passing props through multiple intermediate components that don’t use them",
            "It refers to validating props with PropTypes",
            "It is a way to avoid using React Context",
            "It is used only in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about default values for props in functional components?",
        "o": [
            "Default values can be set by destructuring props in the function parameter list",
            "Default values cannot be used in functional components",
            "Default values override explicitly passed props",
            "Default values are mandatory for every prop"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.only?",
        "o": [
            "It verifies that props.children contains exactly one child element",
            "It maps over all children and wraps them in an array",
            "It automatically flattens nested children arrays",
            "It prevents children from rendering"
        ]
    },
    {
        "q": "What will this do?",
        "c": "React.Children.only(<div>One</div>);",
        "o": [
            "Return the child element <div>One</div>",
            "Throw an error: only works for multiple children",
            "Wrap it inside an array",
            "Prevent the element from rendering"
        ]
    },
    {
        "q": "Which of the following is TRUE about React default export vs named export?",
        "o": [
            "A default export can be imported with any name, while a named export must use the same name",
            "Both default and named exports must be imported with curly braces",
            "Default exports cannot be used with functional components",
            "Named exports automatically become default when compiled"
        ]
    },
    {
        "q": "Which of the following is TRUE about useState setter functions?",
        "o": [
            "The setter function can accept a callback that receives the previous state",
            "The setter function always replaces state immediately without batching",
            "The setter function cannot handle functional updates",
            "The setter function is only valid inside class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React displayName?",
        "o": [
            "displayName is a string used by React DevTools to identify components",
            "displayName automatically sets the component’s HTML tag name",
            "displayName is required for every functional component",
            "displayName can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX keys?",
        "o": [
            "Keys help React identify which list items have changed, been added, or removed",
            "Keys are optional and have no effect",
            "Keys must always be globally unique across the entire app",
            "Keys are only needed in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.cloneElement?",
        "o": [
            "It creates a clone of a React element with new props merged in",
            "It creates a new DOM node by copying attributes",
            "It prevents child components from receiving new props",
            "It only works on functional components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "const child = <button>Click</button>;\nconst cloned = React.cloneElement(child, { type: 'submit' });\n\ncloned",
        "o": [
            "<button type=\"submit\">Click</button>",
            "<button>Click</button>",
            "Error: Cannot clone functional elements",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is TRUE about propTypes?",
        "o": [
            "PropTypes validate the types of props at runtime in development mode",
            "PropTypes enforce type safety at compile time",
            "PropTypes are required for every component",
            "PropTypes can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React defaultProps and ES6 default parameters?",
        "o": [
            "ES6 default parameters can be used instead of defaultProps in functional components",
            "defaultProps is required even if default parameters are used",
            "default parameters only work for class components",
            "Both cannot be used in the same project"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.toArray?",
        "o": [
            "It returns children as a flat array, assigning keys if they are missing",
            "It prevents children from being iterated",
            "It converts children into a string",
            "It only works when children are arrays"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.PureComponent?",
        "o": [
            "PureComponent performs a shallow comparison of props and state to avoid unnecessary re-renders",
            "PureComponent automatically deep compares nested objects",
            "PureComponent cannot have lifecycle methods",
            "PureComponent is only valid in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about getDerivedStateFromProps?",
        "o": [
            "It allows updating state based on prop changes before rendering",
            "It is called after the component renders",
            "It triggers re-render automatically on every state update",
            "It is only available in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React render props pattern?",
        "o": [
            "It involves passing a function as a prop to determine what a component renders",
            "It replaces the need for React Context",
            "It prevents child components from using props",
            "It can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about higher-order components (HOCs) in React?",
        "o": [
            "A higher-order component is a function that takes a component and returns a new component",
            "HOCs replace the need for hooks",
            "HOCs can only be applied to class components",
            "HOCs directly modify the DOM elements"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.forwardRef?",
        "o": [
            "It lets parent components pass refs down to child components",
            "It automatically manages state across components",
            "It prevents props from being passed to children",
            "It can only be used with class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about lifting state up?",
        "o": [
            "Lifting state up involves moving state to the closest common ancestor to share between components",
            "Lifting state up copies state from child components into parent",
            "Lifting state up eliminates the need for props",
            "Lifting state up automatically creates React Context"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Context with multiple providers?",
        "o": [
            "Multiple providers can be nested, and inner providers override values of outer providers",
            "Multiple providers automatically merge their values",
            "Only one provider can exist per app",
            "Nested providers cause React to throw an error"
        ]
    },
    {
        "q": "Which of the following is TRUE about custom hooks?",
        "o": [
            "A custom hook is a function that uses React hooks to encapsulate reusable logic",
            "Custom hooks must return JSX",
            "Custom hooks can only be used inside class components",
            "Custom hooks automatically replace state management"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.StrictMode?",
        "o": [
            "It activates additional checks like identifying unsafe lifecycles and double-invoking effects in development",
            "It prevents all side effects from running",
            "It disables rendering of components",
            "It automatically optimizes production builds"
        ]
    },
    {
        "q": "Which of the following is TRUE about default exports vs named exports in React?",
        "o": [
            "A default export can be imported with any name, while a named export must be imported using the same name in curly braces",
            "Both default and named exports must use curly braces during import",
            "Default exports are only allowed for class components",
            "Named exports automatically override default exports"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys in lists?",
        "o": [
            "Keys should be unique among siblings to help React efficiently re-render lists",
            "Keys must always be globally unique across the entire application",
            "Keys can be reused freely without consequences",
            "Keys are only required when rendering components, not DOM elements"
        ]
    },
    {
        "q": "Which of the following is TRUE about useReducer hook?",
        "o": [
            "useReducer is useful for managing more complex state logic compared to useState",
            "useReducer prevents state updates from re-rendering",
            "useReducer can only be used in class components",
            "useReducer automatically merges object state"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component composition?",
        "o": [
            "Composition involves building complex UIs by combining smaller components",
            "Composition replaces props and state",
            "Composition is only available in class components",
            "Composition prevents reusability of logic"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Suspense boundaries?",
        "o": [
            "Suspense boundaries let you show a fallback while waiting for lazy-loaded components",
            "Suspense boundaries prevent components from re-rendering",
            "Suspense boundaries are only used with class components",
            "Suspense boundaries automatically fetch API data"
        ]
    },
    {
        "q": "Which of the following is TRUE about useContext hook?",
        "o": [
            "useContext allows functional components to subscribe to context without using a Consumer component",
            "useContext creates a new context automatically",
            "useContext is only valid in class components",
            "useContext prevents context updates from propagating"
        ]
    },
    {
        "q": "Which of the following is TRUE about getSnapshotBeforeUpdate lifecycle?",
        "o": [
            "It lets you capture DOM information before changes are applied in class components",
            "It automatically updates state before render",
            "It runs after the component has updated",
            "It is available in functional components with hooks"
        ]
    },
    {
        "q": "Which of the following is TRUE about componentDidCatch lifecycle?",
        "o": [
            "It is used to catch errors in child components during rendering",
            "It prevents errors from propagating to the browser console",
            "It replaces all lifecycle methods in class components",
            "It is available in functional components by default"
        ]
    },
    {
        "q": "Which of the following is TRUE about React DevTools highlighting?",
        "o": [
            "React DevTools can highlight components that re-render to help with performance debugging",
            "React DevTools automatically optimizes components",
            "React DevTools disables strict mode warnings",
            "React DevTools only works for class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component keys?",
        "o": [
            "Keys should be stable, predictable, and unique among siblings",
            "Keys can change on every render without affecting performance",
            "Keys are automatically generated by React",
            "Keys are required only for class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about render props pattern?",
        "o": [
            "A component with render props takes a function that returns React elements to control rendering",
            "Render props automatically provide context to all children",
            "Render props can only be used in class components",
            "Render props replace the need for hooks"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.lazy with dynamic imports?",
        "o": [
            "React.lazy expects a function that dynamically imports a module and returns a component",
            "React.lazy automatically preloads all components",
            "React.lazy works without Suspense fallback",
            "React.lazy can only import default exports, not named exports"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Fragment short syntax?",
        "o": [
            "The shorthand <>...</> can be used instead of <React.Fragment>...</React.Fragment>",
            "Short syntax fragments must always include a key",
            "Short syntax fragments automatically wrap elements in a div",
            "Short syntax fragments can only contain one element"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.memo and props comparison?",
        "o": [
            "React.memo does a shallow comparison of props to decide if re-rendering is needed",
            "React.memo does a deep comparison of all props by default",
            "React.memo prevents re-rendering regardless of props",
            "React.memo only works with class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Portals?",
        "o": [
            "Portals allow rendering children into a different part of the DOM outside the parent hierarchy",
            "Portals automatically create new React roots",
            "Portals can only be used with class components",
            "Portals always require React Context to work"
        ]
    },
    {
        "q": "Which of the following is TRUE about shouldComponentUpdate?",
        "o": [
            "shouldComponentUpdate lets you control whether a component re-renders when props or state change",
            "shouldComponentUpdate forces re-rendering on every update",
            "shouldComponentUpdate is automatically applied to all class components",
            "shouldComponentUpdate is available as a hook in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about error boundaries?",
        "o": [
            "Error boundaries catch JavaScript errors in child components and display a fallback UI",
            "Error boundaries prevent all rendering errors from occurring",
            "Error boundaries work in functional components without extra setup",
            "Error boundaries automatically retry rendering failed components"
        ]
    },
    {
        "q": "Which of the following is TRUE about the useImperativeHandle hook?",
        "o": [
            "useImperativeHandle customizes the instance value exposed when using React.forwardRef",
            "useImperativeHandle replaces useRef entirely",
            "useImperativeHandle prevents refs from being passed to DOM nodes",
            "useImperativeHandle can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.StrictMode double rendering?",
        "o": [
            "React.StrictMode intentionally double-invokes certain functions in development to help detect side effects",
            "React.StrictMode double renders in production builds",
            "React.StrictMode prevents state updates from working",
            "React.StrictMode automatically optimizes re-renders"
        ]
    },
    {
        "q": "Which of the following is TRUE about the useLayoutEffect hook?",
        "o": [
            "useLayoutEffect runs synchronously after all DOM mutations but before the browser paints",
            "useLayoutEffect always runs after useEffect",
            "useLayoutEffect is identical to useEffect in all cases",
            "useLayoutEffect can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React hydration?",
        "o": [
            "Hydration is the process of attaching event listeners to a server-rendered HTML structure",
            "Hydration always re-renders the DOM from scratch",
            "Hydration works only with class components",
            "Hydration removes server-rendered markup before rendering"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys when reordering a list?",
        "o": [
            "Stable keys prevent React from unnecessarily destroying and recreating DOM nodes",
            "Changing keys on every render improves performance",
            "Keys are only important when deleting items from a list",
            "Keys can be safely replaced by array indexes in all cases"
        ]
    },
    {
        "q": "Which of the following is TRUE about React Context default values?",
        "o": [
            "A context can provide a default value that is used when no matching Provider is found",
            "Default values are required for every context",
            "Default values override all Provider values",
            "Default values can only be strings"
        ]
    },
    {
        "q": "Which of the following is TRUE about forwardRef with function components?",
        "o": [
            "forwardRef allows a function component to expose a ref to its parent",
            "forwardRef automatically makes a component stateful",
            "forwardRef prevents props from being passed",
            "forwardRef only works on class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys and array indexes?",
        "o": [
            "Array indexes can be used as keys only if the list is static and will not change",
            "Array indexes are always the best choice for keys",
            "Using array indexes as keys prevents re-rendering",
            "Keys are ignored when array indexes are used"
        ]
    },
    {
        "q": "Which of the following is TRUE about React defaultProps in functional components?",
        "o": [
            "defaultProps are not natively supported on modern functional components when using ES6 classes, but default parameters can be used instead",
            "defaultProps are required for every functional component",
            "defaultProps are automatically applied even when values are passed",
            "defaultProps override explicit props passed by the parent"
        ]
    },
    {
        "q": "Which of the following is TRUE about the children prop?",
        "o": [
            "children is a special prop automatically passed to components to render nested elements",
            "children must always be a string",
            "children must always be a function",
            "children is only available in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop drilling?",
        "o": [
            "Prop drilling is the process of passing props through multiple layers of components to reach a deeply nested child",
            "Prop drilling automatically optimizes performance",
            "Prop drilling can only occur in class components",
            "Prop drilling removes the need for context"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Fragment?",
        "o": [
            "React.Fragment lets you group multiple elements without adding extra nodes to the DOM",
            "React.Fragment always creates a <div> in the DOM",
            "React.Fragment can only wrap one child element",
            "React.Fragment automatically adds keys when missing"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX?",
        "o": [
            "JSX is syntactic sugar for React.createElement calls",
            "JSX is required for all React components",
            "JSX compiles directly into HTML",
            "JSX cannot contain JavaScript expressions"
        ]
    },
    {
        "q": "Which of the following is TRUE about controlled components?",
        "o": [
            "Controlled components are form inputs that derive their value from React state",
            "Controlled components manage their own state internally",
            "Controlled components cannot update state with onChange",
            "Controlled components are only valid in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about uncontrolled components?",
        "o": [
            "Uncontrolled components store their state in the DOM rather than React state",
            "Uncontrolled components cannot be used in forms",
            "Uncontrolled components are always faster than controlled components",
            "Uncontrolled components cannot accept refs"
        ]
    },
    {
        "q": "Which of the following is TRUE about the key prop?",
        "o": [
            "The key prop helps React identify which elements have changed, improving re-render efficiency",
            "The key prop is available inside component props by default",
            "The key prop must always be globally unique",
            "The key prop prevents state updates"
        ]
    },
    {
        "q": "Which of the following is TRUE about React components reusability?",
        "o": [
            "Components are reusable building blocks that encapsulate UI and logic",
            "Components cannot be reused across different projects",
            "Components must always be class-based to be reusable",
            "Components become reusable only when wrapped in Context"
        ]
    },
    {
        "q": "Which of the following is TRUE about displayName in React?",
        "o": [
            "displayName is useful for debugging as it changes the name shown in React DevTools",
            "displayName is required for every component",
            "displayName sets the HTML id of a component",
            "displayName can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.map?",
        "o": [
            "React.Children.map lets you iterate over children even if there is only one child",
            "React.Children.map works only if children are arrays",
            "React.Children.map always converts children into strings",
            "React.Children.map ignores keys when provided"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX expressions?",
        "o": [
            "Any valid JavaScript expression can be embedded inside JSX using curly braces",
            "Only numbers and strings can be used inside JSX expressions",
            "JSX expressions cannot be used inside props",
            "JSX expressions must always return strings"
        ]
    },
    {
        "q": "Which of the following is TRUE about React refs?",
        "o": [
            "Refs provide a way to access DOM nodes or React elements directly",
            "Refs are required for every component",
            "Refs automatically trigger re-renders",
            "Refs can only be created in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.StrictMode?",
        "o": [
            "StrictMode checks for potential problems in an application during development",
            "StrictMode disables all lifecycle methods",
            "StrictMode prevents effects from running",
            "StrictMode is required in production"
        ]
    },
    {
        "q": "Which of the following is TRUE about React function components?",
        "o": [
            "Function components are simple JavaScript functions that return JSX",
            "Function components must always manage state",
            "Function components cannot accept props",
            "Function components require a render method"
        ]
    },
    {
        "q": "Which of the following is TRUE about getDerivedStateFromError?",
        "o": [
            "getDerivedStateFromError is used in error boundaries to update state when an error is thrown",
            "getDerivedStateFromError replaces componentDidMount",
            "getDerivedStateFromError runs after successful rendering",
            "getDerivedStateFromError can only be used in functional components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.memo?",
        "o": [
            "React.memo is a higher-order component that memoizes functional components to avoid unnecessary re-renders",
            "React.memo works only with class components",
            "React.memo performs a deep comparison of all props automatically",
            "React.memo forces components to always re-render"
        ]
    },
    {
        "q": "Which of the following is TRUE about setState in class components?",
        "o": [
            "setState is asynchronous and may batch multiple updates for performance",
            "setState updates the state immediately and synchronously",
            "setState can be called only once per component",
            "setState completely replaces the existing state object"
        ]
    },
    {
        "q": "Which of the following is TRUE about component composition?",
        "o": [
            "Composition allows building complex UIs by combining smaller components",
            "Composition prevents components from receiving props",
            "Composition is only possible with class components",
            "Composition automatically manages state sharing"
        ]
    },
    {
        "q": "Which of the following is TRUE about React keys in dynamic lists?",
        "o": [
            "Keys should remain stable across renders to help React identify elements correctly",
            "Keys should change every render for better reconciliation",
            "Keys must always be globally unique across the app",
            "Keys can only be numbers"
        ]
    },
    {
        "q": "Which of the following is TRUE about React functional components with default parameters?",
        "o": [
            "Default parameters can be used to define default prop values",
            "Default parameters override explicitly passed props",
            "Default parameters are only available in class components",
            "Default parameters require React.PropTypes"
        ]
    },
    {
        "q": "Which of the following is TRUE about React context consumers?",
        "o": [
            "Consumers allow components to subscribe to context values",
            "Consumers can only be used once per tree",
            "Consumers automatically provide defaultProps",
            "Consumers are only available in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.count?",
        "o": [
            "React.Children.count returns the total number of children passed to a component",
            "React.Children.count only works if children are arrays",
            "React.Children.count ignores fragments",
            "React.Children.count always returns zero if there is one child"
        ]
    },
    {
        "q": "Which of the following is TRUE about PureComponent?",
        "o": [
            "PureComponent implements shouldComponentUpdate with a shallow prop and state comparison",
            "PureComponent always prevents re-rendering",
            "PureComponent is only available in functional components",
            "PureComponent performs deep comparisons by default"
        ]
    },
    {
        "q": "Which of the following is TRUE about componentWillUnmount?",
        "o": [
            "componentWillUnmount is used for cleanup before a component is removed from the DOM",
            "componentWillUnmount triggers every time props change",
            "componentWillUnmount can schedule state updates",
            "componentWillUnmount runs after the DOM node is removed"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.only?",
        "o": [
            "React.Children.only verifies that a component has exactly one child",
            "React.Children.only automatically wraps children into an array",
            "React.Children.only can handle multiple children gracefully",
            "React.Children.only is used to clone children"
        ]
    },
    {
        "q": "Which of the following is TRUE about the key prop availability?",
        "o": [
            "Keys are not passed as props to components, they are only used internally by React",
            "Keys are always available inside component props",
            "Keys must always be accessed through React.Children.map",
            "Keys are automatically converted into id attributes"
        ]
    },
    {
        "q": "Which of the following is TRUE about static getDerivedStateFromProps?",
        "o": [
            "It is a static method that allows syncing state with props in class components",
            "It can access instance methods via this",
            "It replaces setState entirely",
            "It is available in functional components by default"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop spreading?",
        "o": [
            "Prop spreading allows passing all properties of an object to a component with {...props}",
            "Prop spreading automatically validates prop types",
            "Prop spreading prevents overriding existing props",
            "Prop spreading can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is TRUE about React’s component re-rendering?",
        "o": [
            "A component re-renders when its state or props change",
            "A component re-renders only when manually triggered",
            "A component re-renders only if it is a class component",
            "A component re-renders every second automatically"
        ]
    },
    {
        "q": "Which of the following is TRUE about React event handling?",
        "o": [
            "React events are named using camelCase, such as onClick",
            "React events must always be written in lowercase, such as onclick",
            "React events map directly to native browser events without modification",
            "React events must always call event.persist() to work"
        ]
    },
    {
        "q": "Which of the following is TRUE about functional component returns?",
        "o": [
            "A functional component must return a single React element or null",
            "A functional component can return multiple elements without a wrapper",
            "A functional component must always return a string",
            "A functional component must return undefined to render nothing"
        ]
    },
    {
        "q": "Which of the following is TRUE about React component props immutability?",
        "o": [
            "Props are read-only and should never be modified by the child component",
            "Props can be freely reassigned inside a child component",
            "Props are mutable only in class components",
            "Props are always deep cloned before being passed down"
        ]
    },
    {
        "q": "Which of the following is TRUE about JSX attributes?",
        "o": [
            "JSX attributes use camelCase naming, like className instead of class",
            "JSX attributes must always match HTML attributes exactly",
            "JSX attributes cannot accept JavaScript expressions",
            "JSX attributes are always optional"
        ]
    },
    {
        "q": "Which of the following is TRUE about componentWillMount?",
        "o": [
            "componentWillMount is deprecated and should not be used in modern React",
            "componentWillMount is required in every class component",
            "componentWillMount runs after render",
            "componentWillMount is equivalent to componentDidMount"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Fragment with keys?",
        "o": [
            "Fragments can accept keys when used in lists to help React identify them",
            "Fragments cannot accept keys at all",
            "Fragments automatically generate unique keys",
            "Fragments with keys are invalid JSX"
        ]
    },
    {
        "q": "Which of the following is TRUE about default exports?",
        "o": [
            "A module can only have one default export",
            "A module can have multiple default exports",
            "Default exports must always be classes",
            "Default exports must always be functions"
        ]
    },
    {
        "q": "Which of the following is TRUE about prop type validation?",
        "o": [
            "PropTypes help catch bugs by validating the types of props in development",
            "PropTypes are enforced in production at runtime",
            "PropTypes are required for every component",
            "PropTypes automatically fix type mismatches"
        ]
    },
    {
        "q": "Which of the following is TRUE about React.Children.forEach?",
        "o": [
            "It invokes a function on each child without returning a new array",
            "It returns a mapped array of children",
            "It converts all children to strings",
            "It throws an error if children are not arrays"
        ]
    },
    {
        "q": "Which of the following is a correct way to define a functional component in React?",
        "o": [
            "function Greeting() { return <h1>Hello</h1>; }",
            "class Greeting extends React.Component { render() { return <h1>Hello</h1>; } }",
            "const Greeting = new Component(<h1>Hello</h1>);",
            "React.createComponent('Greeting', () => <h1>Hello</h1>)"
        ]
    },
    {
        "q": "What is the correct way to access props in a class component?",
        "c": "class Welcome extends React.Component {\n  render() {\n    return <h1>{/* access props here */}</h1>;\n  }\n}",
        "o": [
            "this.props.name",
            "props.name",
            "this.name",
            "props(this).name"
        ]
    },
    {
        "q": "Which of the following best describes the difference between functional and class components?",
        "o": [
            "Functional components are stateless by default, while class components can hold state",
            "Class components cannot accept props, but functional components can",
            "Functional components must extend React.Component, while class components do not",
            "Class components are only used for rendering static markup"
        ]
    },
    {
        "q": "What will be rendered by the following component?",
        "c": "function Wrapper(props) {\n  return <div>{props.children}</div>;\n}\n\nfunction App() {\n  return (\n    <Wrapper>\n      <p>Hello</p>\n      <p>World</p>\n    </Wrapper>\n  );\n}",
        "o": [
            "<div><p>Hello</p><p>World</p></div>",
            "<div>HelloWorld</div>",
            "<p>Hello</p><p>World</p>",
            "Error: props.children is not iterable"
        ]
    },
    {
        "q": "Which of the following is true about props in React?",
        "o": [
            "Props are immutable inside the receiving component",
            "Props can be modified using setState",
            "Props are global variables in React",
            "Props must always be strings"
        ]
    },
    {
        "q": "What is the correct way to define default props for a functional component?",
        "o": [
            "MyComponent.defaultProps = { title: 'Hello' };",
            "defaultProps(MyComponent, { title: 'Hello' });",
            "const MyComponent = (props = { title: 'Hello' }) => <h1>{props.title}</h1>;",
            "React.defaultProps(MyComponent, { title: 'Hello' });"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "function Display({value = 'Default'}) {\n  return <p>{value}</p>;\n}\n\nfunction App() {\n  return <Display />;\n}",
        "o": [
            "<p>Default</p>",
            "<p></p>",
            "<p>undefined</p>",
            "Error: value prop is required"
        ]
    },
    {
        "q": "Which lifecycle method is unique to class components and not available in functional components with hooks?",
        "o": [
            "componentDidCatch",
            "useEffect",
            "getSnapshotBeforeUpdate",
            "useLayoutEffect"
        ]
    },
    {
        "q": "How can you pass multiple children to a component?",
        "o": [
            "By nesting elements inside the component's opening and closing tags",
            "By using a special prop named childrenArray",
            "By passing them as an array prop",
            "By calling this.children() in the parent"
        ]
    },
    {
        "q": "Which of the following will throw an error in React?",
        "c": "function MyComponent(props) {\n  props.title = 'Changed';\n  return <h1>{props.title}</h1>;\n}",
        "o": [
            "Directly modifying props inside a component",
            "Rendering JSX without a parent element",
            "Returning null from a component",
            "Using a function name starting with lowercase"
        ]
    },
    {
        "q": "Which of the following is a correct way to define a class component in React?",
        "o": [
            "class Greeting extends React.Component { render() { return <h1>Hello</h1>; } }",
            "function Greeting() { return <h1>Hello</h1>; }",
            "const Greeting = new React.Component(<h1>Hello</h1>);",
            "React.createComponent('Greeting', () => <h1>Hello</h1>)"
        ]
    },
    {
        "q": "What will be rendered by the following code?",
        "c": "function App() {\n  return <Button text=\"Click Me\" />;\n}\n\nfunction Button(props) {\n  return <div>{props.text}</div>;\n}",
        "o": [
            "<div>Click Me</div>",
            "<Button text=\"Click Me\" />",
            "<div>{props.text}</div>",
            "undefined"
        ]
    },
    {
        "q": "Which statement is true regarding children in React components?",
        "o": [
            "props.children can hold a single element, multiple elements, or even functions",
            "props.children must always be a string",
            "props.children can only contain one child element",
            "props.children is only available in class components"
        ]
    },
    {
        "q": "What is the correct way to destructure props in a functional component?",
        "c": "function User({ name, age }) {\n  return <p>{name} - {age}</p>;\n}",
        "o": [
            "By using object destructuring in the function parameter",
            "By accessing props.name and props.age directly in JSX",
            "By using this.name and this.age",
            "By calling props.get('name') and props.get('age')"
        ]
    },
    {
        "q": "Which of the following will correctly render multiple children elements?",
        "c": "function Container() {\n  return (\n    <div>\n      <p>First</p>\n      <p>Second</p>\n    </div>\n  );\n}",
        "o": [
            "<div><p>First</p><p>Second</p></div>",
            "<p>First</p><p>Second</p>",
            "Error: Only one child allowed",
            "Error: Unexpected JSX nesting"
        ]
    },
    {
        "q": "Which of the following statements about props is false?",
        "o": [
            "Props can be directly mutated inside child components",
            "Props are passed from parent to child",
            "Props are read-only",
            "Props help make components reusable"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "function Title(props) {\n  return <h1>{props.heading || 'Untitled'}</h1>;\n}\n\nfunction App() {\n  return <Title />;\n}",
        "o": [
            "<h1>Untitled</h1>",
            "<h1></h1>",
            "<h1>undefined</h1>",
            "Error: heading prop missing"
        ]
    },
    {
        "q": "Which of the following is a valid way to pass JSX as children?",
        "o": [
            "<Wrapper><span>Inside</span></Wrapper>",
            "<Wrapper children={<span>Inside</span>} />",
            "<Wrapper>{children: <span>Inside</span>}</Wrapper>",
            "<Wrapper child={<span>Inside</span>} />"
        ]
    },
    {
        "q": "What is the difference between props.children and a regular prop?",
        "o": [
            "props.children automatically contains anything passed between opening and closing tags, while regular props are explicitly defined",
            "props.children must always be an array, while regular props cannot",
            "props.children is available only in functional components",
            "props.children can only hold text nodes"
        ]
    },
    {
        "q": "What is the output of this component?",
        "c": "function App() {\n  return <Message text={42} />;\n}\n\nfunction Message({ text }) {\n  return <p>{typeof text}</p>;\n}",
        "o": [
            "<p>number</p>",
            "<p>string</p>",
            "<p>object</p>",
            "<p>undefined</p>"
        ]
    },
    {
        "q": "Which of the following is a key difference between defaultProps and props with default values in function parameters?",
        "o": [
            "defaultProps work for both functional and class components, while function parameter defaults only work in functional components",
            "Function parameter defaults override defaultProps if both are defined",
            "defaultProps can only accept primitive values, while function parameter defaults can accept objects",
            "defaultProps must always be defined inside the constructor"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "class Hello extends React.Component {\n  render() {\n    return <p>{this.props.msg || 'Hi'}</p>;\n  }\n}\n\nfunction App() {\n  return <Hello msg={null} />;\n}",
        "o": [
            "<p>Hi</p>",
            "<p>null</p>",
            "<p>undefined</p>",
            "<p></p>"
        ]
    },
    {
        "q": "Which of the following is true about props.children?",
        "o": [
            "It can be a single element, an array of elements, text, or even a function",
            "It must always be wrapped in a fragment",
            "It is only accessible using this.children",
            "It is automatically converted to a string"
        ]
    },
    {
        "q": "What will be rendered by this component?",
        "c": "function Card(props) {\n  return <div>{props.children}</div>;\n}\n\nfunction App() {\n  return (\n    <Card>\n      {false}\n      <h1>Hello</h1>\n      {null}\n      {0}\n    </Card>\n  );\n}",
        "o": [
            "<div><h1>Hello</h1>0</div>",
            "<div><h1>Hello</h1></div>",
            "<div>false<h1>Hello</h1>null0</div>",
            "<div></div>"
        ]
    },
    {
        "q": "Which of the following is the correct way to forward children props?",
        "o": [
            "function Wrapper({ children }) { return <section>{children}</section>; }",
            "function Wrapper(props) { return <section>{props.child}</section>; }",
            "function Wrapper(children) { return <section>{children}</section>; }",
            "function Wrapper({ children }) { return <section children={children} />; }"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "function Display({ items }) {\n  return <p>{items.length}</p>;\n}\n\nfunction App() {\n  return <Display items={['a', 'b', 'c']} />;\n}",
        "o": [
            "<p>3</p>",
            "<p>abc</p>",
            "<p>undefined</p>",
            "Error: items is not iterable"
        ]
    },
    {
        "q": "Which statement is correct regarding functional and class components?",
        "o": [
            "Class components provide lifecycle methods, while functional components rely on hooks for similar behavior",
            "Functional components cannot accept props, while class components can",
            "Class components are faster than functional components in modern React",
            "Functional components must always return a single string element"
        ]
    },
    {
        "q": "What will be the output of this code?",
        "c": "function Info({ data }) {\n  return <span>{Array.isArray(data) ? 'Array' : typeof data}</span>;\n}\n\nfunction App() {\n  return <Info data={{ name: 'React' }} />;\n}",
        "o": [
            "<span>object</span>",
            "<span>Array</span>",
            "<span>string</span>",
            "<span>undefined</span>"
        ]
    },
    {
        "q": "Which of the following is NOT a valid way to pass props?",
        "o": [
            "<Component {spread} />",
            "<Component data={value} />",
            "<Component {...props} />",
            "<Component key=\"unique\" />"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "function Header({ title = 'Default Title' }) {\n  return <h2>{title.toUpperCase()}</h2>;\n}\n\nfunction App() {\n  return <Header />;\n}",
        "o": [
            "<h2>DEFAULT TITLE</h2>",
            "<h2>Default Title</h2>",
            "<h2></h2>",
            "Error: title is undefined"
        ]
    },
    {
        "q": "Which of the following is the correct way to render multiple sibling elements without an extra DOM wrapper?",
        "o": [
            "<>\n  <li>One</li>\n  <li>Two</li>\n</>",
            "<div><li>One</li><li>Two</li></div>",
            "<container><li>One</li><li>Two</li></container>",
            "<ReactDOM><li>One</li><li>Two</li></ReactDOM>"
        ]
    },
    {
        "q": "What will be rendered by this component?",
        "c": "function App() {\n  const element = <span>React</span>;\n  return <div>{[element, element]}</div>;\n}",
        "o": [
            "<div><span>React</span><span>React</span></div>",
            "<div><span>React</span></div>",
            "<div>React</div>",
            "Error: element cannot be repeated"
        ]
    },
    {
        "q": "Which of the following is true about React class components?",
        "o": [
            "They must extend React.Component or React.PureComponent",
            "They can be defined without extending any base class",
            "They cannot have state",
            "They cannot accept props"
        ]
    },
    {
        "q": "What is the output of the following component?",
        "c": "function Child({ children }) {\n  return <section>{children}</section>;\n}\n\nfunction App() {\n  return <Child>{42}</Child>;\n}",
        "o": [
            "<section>42</section>",
            "<section>{42}</section>",
            "<section></section>",
            "Error: numbers are not valid children"
        ]
    },
    {
        "q": "Which of the following is a valid reason to use props.children?",
        "o": [
            "To make a reusable wrapper component that can render arbitrary nested content",
            "To prevent props mutation",
            "To define static default values for props",
            "To handle component lifecycle events"
        ]
    },
    {
        "q": "What will be rendered by this component?",
        "c": "function Label({ text }) {\n  return <p>{text ?? 'No label'}</p>;\n}\n\nfunction App() {\n  return <Label text={undefined} />;\n}",
        "o": [
            "<p>No label</p>",
            "<p>undefined</p>",
            "<p></p>",
            "Error: text is required"
        ]
    },
    {
        "q": "Which statement is true about functional components and hooks?",
        "o": [
            "Hooks allow functional components to use state and lifecycle features",
            "Hooks are only available in class components",
            "Hooks are mandatory in every functional component",
            "Hooks replace props in functional components"
        ]
    },
    {
        "q": "What is the output of this code?",
        "c": "class Info extends React.Component {\n  render() {\n    return <h4>{this.props.value + 5}</h4>;\n  }\n}\n\nfunction App() {\n  return <Info value={10} />;\n}",
        "o": [
            "<h4>15</h4>",
            "<h4>10</h4>",
            "<h4>NaN</h4>",
            "Error: props cannot be numbers"
        ]
    },
    {
        "q": "Which of the following correctly passes an object as a prop?",
        "o": [
            "<Profile user={{ name: 'Alex', age: 25 }} />",
            "<Profile user=(name: 'Alex', age: 25) />",
            "<Profile {user: { name: 'Alex' }} />",
            "<Profile user={name: 'Alex'} />"
        ]
    },
    {
        "q": "What will be rendered by this component?",
        "c": "function ItemList({ items }) {\n  return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;\n}\n\nfunction App() {\n  return <ItemList items={[1, 2, 3]} />;\n}",
        "o": [
            "<ul><li>1</li><li>2</li><li>3</li></ul>",
            "<ul>123</ul>",
            "<ul><li>[1,2,3]</li></ul>",
            "Error: numbers cannot be keys"
        ]
    },
    {
        "q": "In React, what happens if you attempt to return multiple sibling elements from a component without wrapping them?",
        "o": [
            "It throws a syntax error",
            "React automatically wraps them in a <div>",
            "The elements are concatenated into a string",
            "They are ignored during rendering"
        ]
    },
    {
        "q": "Why is it considered a bad practice to mutate props inside a component?",
        "o": [
            "Because props are meant to be immutable and controlled by the parent component",
            "Because mutating props will throw a runtime error",
            "Because props are automatically deep-frozen by React",
            "Because props cannot hold non-primitive values"
        ]
    },
    {
        "q": "If a component receives no children, what will props.children evaluate to?",
        "o": [
            "undefined",
            "null",
            "an empty array",
            "an empty string"
        ]
    },
    {
        "q": "What is the main advantage of using functional components over class components in modern React?",
        "o": [
            "They are simpler and can leverage hooks for state and side effects",
            "They can handle more lifecycle methods than class components",
            "They are automatically memoized without extra code",
            "They do not require importing React at all"
        ]
    },
    {
        "q": "When using props.children, how can you safely transform them?",
        "o": [
            "By using React.Children.map to iterate and transform children",
            "By directly calling props.children.map without checks",
            "By wrapping props.children in JSON.stringify",
            "By converting props.children into an object first"
        ]
    },
    {
        "q": "Which of the following correctly describes how props differ from state?",
        "o": [
            "Props are passed from parent to child, while state is managed within the component",
            "Props are mutable, while state is immutable",
            "Props can only hold primitive values, while state can hold objects",
            "Props exist only in class components, while state exists only in functional components"
        ]
    },
    {
        "q": "If you pass a function as a prop, how should it typically be used inside the child component?",
        "o": [
            "Call it like a regular function, e.g., props.onClick()",
            "Wrap it in a useEffect hook automatically",
            "Assign it directly to props without invoking",
            "Bind it with this before calling"
        ]
    },
    {
        "q": "What happens if you try to render an object directly inside JSX?",
        "o": [
            "It throws an error because objects are not valid React children",
            "It renders '[object Object]'",
            "It renders null silently",
            "It stringifies the object automatically"
        ]
    },
    {
        "q": "What is the correct way to ensure a component accepts only a specific type of prop value?",
        "o": [
            "Using PropTypes to validate prop types",
            "Defining prop types in the constructor",
            "Checking prop values inside render and throwing errors",
            "Declaring them as final inside the parent"
        ]
    },
    {
        "q": "What is the result of passing JSX elements as props instead of children?",
        "o": [
            "They become accessible through the named prop instead of props.children",
            "They are automatically merged into props.children",
            "They are ignored and replaced by defaultProps",
            "They must always be wrapped in a fragment"
        ]
    },
    {
        "q": "When does a class component in React require a constructor?",
        "o": [
            "Only when initializing state or binding event handlers",
            "Always, because React calls it before render",
            "When you want to define props",
            "Whenever you return JSX"
        ]
    },
    {
        "q": "Why is it common to use arrow functions for functional components?",
        "o": [
            "They provide a concise syntax and avoid issues with 'this'",
            "They automatically bind lifecycle methods",
            "They execute faster than normal functions",
            "They are the only functions that React can render"
        ]
    },
    {
        "q": "What happens if two props with the same name are passed to a component?",
        "o": [
            "The last prop value overrides the previous one",
            "React merges both into an array",
            "React throws a compilation error",
            "The component receives both values in an object"
        ]
    },
    {
        "q": "Which statement about React.Fragment is correct?",
        "o": [
            "It lets you group multiple children without adding extra nodes to the DOM",
            "It works only with class components",
            "It must always be imported as 'Fragment' from 'react-dom'",
            "It forces children to render in an array"
        ]
    },
    {
        "q": "What will happen if you forget to return JSX in a functional component?",
        "o": [
            "The component will render nothing (null)",
            "React will throw a runtime error",
            "The component will render undefined visibly",
            "React will automatically insert an empty <div>"
        ]
    },
    {
        "q": "Why should keys be used when rendering a list of elements in React?",
        "o": [
            "To help React efficiently identify which items changed, were added, or removed",
            "To provide default IDs to each DOM node",
            "To automatically sort the list before rendering",
            "To prevent props from being mutated"
        ]
    },
    {
        "q": "What is the correct way to conditionally render JSX?",
        "o": [
            "{condition && <p>Visible</p>}",
            "if (condition) { <p>Visible</p> }",
            "<p visible={condition}>Visible</p>",
            "{condition ? <p>Visible</p>}"
        ]
    },
    {
        "q": "What happens if props.children is a function?",
        "o": [
            "It can be invoked inside the component to implement render prop patterns",
            "React throws an error because children must be elements",
            "React automatically executes it before rendering",
            "It is ignored during rendering"
        ]
    },
    {
        "q": "What is the primary purpose of using React.PureComponent?",
        "o": [
            "It implements a shallow comparison of props and state to avoid unnecessary renders",
            "It forces components to re-render on every update",
            "It prevents components from receiving props",
            "It disables lifecycle methods by default"
        ]
    },
    {
        "q": "In JSX, how are JavaScript expressions embedded?",
        "o": [
            "By wrapping them in curly braces {}",
            "By writing them directly inside quotes",
            "By using parentheses ()",
            "By placing them inside double curly braces {{}}"
        ]
    },
    {
        "q": "Which of the following best describes the role of `key` when rendering lists in React?",
        "o": [
            "Keys give React a way to uniquely identify elements across renders",
            "Keys act as IDs that are exposed to child components as props",
            "Keys are used to sort the list before rendering",
            "Keys prevent React from re-rendering any list items"
        ]
    },
    {
        "q": "What happens if you assign the array index as the key when rendering lists?",
        "o": [
            "It may cause inefficient re-rendering when list items are reordered",
            "It throws a React warning and prevents rendering",
            "It forces React to duplicate DOM nodes",
            "It prevents state from being updated inside the list"
        ]
    },
    {
        "q": "Which of the following is true about `propTypes`?",
        "o": [
            "They allow runtime type-checking of props in development mode",
            "They are required for every React component",
            "They enforce type safety at compile-time",
            "They automatically provide default values for missing props"
        ]
    },
    {
        "q": "What is the effect of `defaultProps` in class components?",
        "o": [
            "They provide fallback values for props that were not supplied",
            "They override any values passed from the parent",
            "They prevent props from being passed at runtime",
            "They convert props into state variables automatically"
        ]
    },
    {
        "q": "Which of the following scenarios is a valid use case for render props (function as children)?",
        "o": [
            "Sharing logic between components by passing a function as children",
            "Defining inline styles for elements inside JSX",
            "Avoiding the use of hooks entirely in functional components",
            "Replacing lifecycle methods in class components"
        ]
    },
    {
        "q": "In React, what is the main difference between `props.children` and explicitly named props?",
        "o": [
            "props.children captures everything between a component’s opening and closing tags, while named props must be passed explicitly",
            "props.children must always be a string, while named props can be any type",
            "props.children is automatically cloned into state, while named props are not",
            "props.children is available only in class components"
        ]
    },
    {
        "q": "Which of the following is true about higher-order components (HOCs)?",
        "o": [
            "They are functions that take a component and return a new component with additional props or logic",
            "They replace the need for props.children",
            "They must always be defined inside a class component",
            "They directly modify the prototype of the wrapped component"
        ]
    },
    {
        "q": "What will React render if a component explicitly returns `null`?",
        "o": [
            "Nothing will be rendered for that component",
            "It will render the text 'null'",
            "It will throw an error during render",
            "It will render an empty <div></div>"
        ]
    },
    {
        "q": "Why is `children` considered a special prop in React?",
        "o": [
            "Because it is automatically populated with the elements inside a component’s tags",
            "Because it must always be passed explicitly",
            "Because it cannot be combined with other props",
            "Because it only works with class components"
        ]
    },
    {
        "q": "What happens if you pass a boolean value as children?",
        "o": [
            "It will be ignored and render nothing",
            "It will render the word 'true' or 'false'",
            "It will throw an error",
            "It will convert to '1' or '0'"
        ]
    },
    {
        "q": "Which of the following describes the difference between `React.Fragment` and a normal `<div>` wrapper?",
        "o": [
            "Fragments do not add extra nodes to the DOM, unlike `<div>`",
            "Fragments can only contain text nodes",
            "Fragments automatically optimize rendering performance",
            "Fragments can only be used with class components"
        ]
    },
    {
        "q": "What is the main purpose of `React.Children.toArray`?",
        "o": [
            "To flatten children into an array and assign keys if they are missing",
            "To convert children into strings",
            "To wrap each child with a fragment",
            "To deep-clone children into a new component"
        ]
    },
    {
        "q": "If you pass `null` as a prop, how is it treated inside a component?",
        "o": [
            "As a valid value distinct from `undefined`",
            "As the same as an empty string",
            "As if the prop was never passed",
            "As an error that throws at runtime"
        ]
    },
    {
        "q": "Which of the following is true about spreading props with `{...props}`?",
        "o": [
            "It forwards all received props to a child component or element",
            "It automatically filters out invalid HTML attributes",
            "It deep-merges props objects before passing",
            "It prevents overriding any existing props"
        ]
    },
    {
        "q": "What is the significance of `displayName` in React components?",
        "o": [
            "It customizes the name shown in React DevTools",
            "It changes how props are passed to children",
            "It determines the default value of props.children",
            "It defines the HTML tag name of the root element"
        ]
    },
    {
        "q": "Which of the following correctly describes controlled vs uncontrolled components?",
        "o": [
            "Controlled components have their value managed by React state, while uncontrolled components rely on the DOM",
            "Controlled components cannot accept props, while uncontrolled ones can",
            "Controlled components only work in class components",
            "Uncontrolled components cannot have default values"
        ]
    },
    {
        "q": "What happens if you render `{true}` inside JSX?",
        "o": [
            "Nothing will be rendered",
            "The word 'true' will appear",
            "It throws an error",
            "It renders '1'"
        ]
    },
    {
        "q": "Why might you use `React.memo` with a functional component?",
        "o": [
            "To memoize the component and prevent unnecessary re-renders when props do not change",
            "To automatically convert props into state",
            "To allow the component to use lifecycle methods",
            "To enforce type checking on props"
        ]
    },
    {
        "q": "Which of the following is NOT a valid way to pass children?",
        "o": [
            "<Box child={<p>Content</p>} />",
            "<Box><p>Content</p></Box>",
            "<Box children={<p>Content</p>} />",
            "<Box>{[<p key='1'>A</p>, <p key='2'>B</p>]}</Box>"
        ]
    },
    {
        "q": "What happens if you define `defaultProps` for a prop that is explicitly passed as `undefined`?",
        "o": [
            "The default value is used",
            "The prop remains undefined",
            "React throws a warning",
            "React ignores both values"
        ]
    },
    {
        "q": "Why should you avoid using array indexes as keys in dynamic lists?",
        "o": [
            "Because it can cause incorrect component reuse when items are added, removed, or reordered",
            "Because React does not allow numbers as keys",
            "Because indexes create duplicate DOM nodes",
            "Because keys must always be strings"
        ]
    },
    {
        "q": "What is the purpose of `React.cloneElement`?",
        "o": [
            "To clone a React element and optionally override its props or children",
            "To duplicate a DOM node into the document",
            "To create a deep copy of props for immutability",
            "To generate a new key for an existing element"
        ]
    },
    {
        "q": "Which of the following is true about `this.props.children` in class components?",
        "o": [
            "It behaves the same as props.children in functional components",
            "It must always be manually bound in the constructor",
            "It is only available when defaultProps are defined",
            "It automatically flattens nested arrays of children"
        ]
    },
    {
        "q": "What happens if a child component tries to modify its props?",
        "o": [
            "React prevents it and props remain unchanged",
            "Props update locally but not in the parent",
            "The change propagates back to the parent automatically",
            "The component crashes at runtime"
        ]
    },
    {
        "q": "Which of the following is true about `key` prop in React?",
        "o": [
            "It is used internally by React and is not accessible as a normal prop",
            "It is passed down to the child as props.key",
            "It must always be a string, never a number",
            "It defines the tab index for rendered elements"
        ]
    },
    {
        "q": "How does React handle boolean attributes in JSX, such as `disabled={true}`?",
        "o": [
            "They are rendered as the attribute without a value (e.g., `<button disabled>`)",
            "They are ignored and not rendered",
            "They are rendered as strings (`disabled=\"true\"`)",
            "They require explicit string values like `disabled=\"disabled\"`"
        ]
    },
    {
        "q": "What is the behavior of children when they are conditional values like `false`, `null`, or `undefined`?",
        "o": [
            "They are ignored and not rendered",
            "They render as the text 'false', 'null', or 'undefined'",
            "They render as empty <span> elements",
            "They throw an error during reconciliation"
        ]
    },
    {
        "q": "Which of the following is a limitation of props?",
        "o": [
            "Props cannot be modified by the child component",
            "Props cannot hold arrays or objects",
            "Props cannot be passed between functional components",
            "Props are only supported in class components"
        ]
    },
    {
        "q": "What happens if you spread invalid attributes on a DOM element in React?",
        "o": [
            "React filters them out and ignores them",
            "React throws a compile-time error",
            "The browser renders them as custom attributes",
            "React automatically renames them to `data-*` attributes"
        ]
    },
    {
        "q": "Which of the following best describes JSX under the hood?",
        "o": [
            "It is syntactic sugar for React.createElement calls",
            "It is an HTML templating language parsed by the browser",
            "It compiles into plain strings appended to the DOM",
            "It runs directly in the browser without transpilation"
        ]
    },
    {
        "q": "Which of the following is true about `props` in React?",
        "o": [
            "They are passed in from the parent and are immutable inside the child",
            "They are shared globally across all components",
            "They can only be accessed in class components using this.props",
            "They must always be primitive values like strings or numbers"
        ]
    },
    {
        "q": "What will React render if you return an empty string `\"\"` from a component?",
        "o": [
            "It renders nothing in the DOM",
            "It renders a blank text node",
            "It throws an error",
            "It replaces it with `null` automatically"
        ]
    },
    {
        "q": "Which of the following is the purpose of `React.Children.only`?",
        "o": [
            "It verifies that children has exactly one element and returns it",
            "It filters children to only text nodes",
            "It removes duplicate children elements",
            "It merges multiple children into a single fragment"
        ]
    },
    {
        "q": "How does React handle `className` prop in JSX?",
        "o": [
            "It sets the HTML `class` attribute on the element",
            "It creates a scoped CSS class automatically",
            "It ignores it and requires inline styles",
            "It renames it to `classname` in the DOM"
        ]
    },
    {
        "q": "What is the result of rendering `{[null, <p key='1'>Hi</p>, false]}` as children?",
        "o": [
            "<p>Hi</p>",
            "nullfalse<p>Hi</p>",
            "Error: invalid array of children",
            "Nothing will be rendered"
        ]
    },
    {
        "q": "Which of the following correctly describes a stateless functional component?",
        "o": [
            "A component that receives props and returns JSX without managing internal state",
            "A component that has no render method",
            "A component that can only return strings",
            "A component that does not support children"
        ]
    },
    {
        "q": "Which of the following is the effect of using `dangerouslySetInnerHTML`?",
        "o": [
            "It allows setting raw HTML inside a component, bypassing React's escaping",
            "It sanitizes and encodes user input automatically",
            "It prevents XSS vulnerabilities in React by default",
            "It replaces JSX rendering entirely with HTML strings"
        ]
    },
    {
        "q": "What happens if a component does not return anything from its render method?",
        "o": [
            "It renders nothing (equivalent to returning null)",
            "It renders an empty string",
            "It throws a runtime error",
            "It renders the text 'undefined'"
        ]
    },
    {
        "q": "Which of the following is true about `children` when you pass an array of elements?",
        "o": [
            "They are rendered in the same order as they appear in the array",
            "React automatically flattens them into a string",
            "React ignores all but the first child",
            "They must always be wrapped in a fragment"
        ]
    },
    {
        "q": "Which of the following best describes JSX expressions inside `{}`?",
        "o": [
            "They can be any valid JavaScript expression, but not statements",
            "They can only be variables and strings",
            "They allow both expressions and statements",
            "They are executed at runtime as eval()"
        ]
    },
    {
        "q": "What happens if you pass a component itself (not JSX) as a prop?",
        "o": [
            "It can be invoked or rendered inside the child using JSX, e.g. `<PropComponent />`",
            "React throws an error since props cannot contain components",
            "It is converted into a string representation of the component function",
            "It renders as `[object Component]`"
        ]
    },
    {
        "q": "Which of the following best explains why React keys should be stable and unique?",
        "o": [
            "Because React uses keys to track element identity across re-renders",
            "Because keys are used as DOM IDs for accessibility",
            "Because keys are exposed to the child as a prop",
            "Because React requires them to apply CSS classes"
        ]
    },
    {
        "q": "What is the purpose of `React.Children.count`?",
        "o": [
            "It returns the total number of children, regardless of whether they are null, undefined, or false",
            "It counts only the valid JSX elements in children",
            "It counts only text nodes in children",
            "It throws an error if children is not an array"
        ]
    },
    {
        "q": "Which of the following is true about `this.props` in class components?",
        "o": [
            "It is read-only and should never be reassigned",
            "It can be directly mutated to update parent state",
            "It must be defined manually in the constructor",
            "It is only accessible inside lifecycle methods"
        ]
    },
    {
        "q": "What happens when you spread an object into JSX that contains invalid DOM attributes?",
        "o": [
            "React ignores unknown attributes and does not add them to the DOM",
            "React throws a compile-time error",
            "The attributes are converted into `data-*` attributes automatically",
            "React renders them as plain strings"
        ]
    },
    {
        "q": "Which of the following is NOT true about `defaultProps`?",
        "o": [
            "They override explicitly passed `undefined` props",
            "They apply only when a prop is not passed",
            "They can be defined for both functional and class components",
            "They act as fallback values for missing props"
        ]
    },
    {
        "q": "If you pass JSX as a named prop (e.g., `<Box footer={<p>Hi</p>} />`), how is it accessed inside the child?",
        "o": [
            "Via `props.footer`",
            "Via `props.children`",
            "Via `this.footer`",
            "Via `props[0]`"
        ]
    },
    {
        "q": "What is the output when rendering an array of strings as children, e.g., `{['A', 'B']}`?",
        "o": [
            "AB",
            "<p>A</p><p>B</p>",
            "['A', 'B']",
            "Error: strings must be wrapped in elements"
        ]
    },
    {
        "q": "Why is `key` not passed to child components as a normal prop?",
        "o": [
            "Because React reserves it for internal reconciliation only",
            "Because it would override the child’s props.id automatically",
            "Because keys must always be global identifiers",
            "Because props.children already contains it"
        ]
    },
    {
        "q": "What happens if you return a number directly from a component’s render?",
        "o": [
            "The number is rendered as text in the DOM",
            "It throws an error since only elements are allowed",
            "It gets ignored and nothing is rendered",
            "It is coerced into a string automatically"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` when no children are passed?",
        "o": [
            "It is `undefined`",
            "It is `null`",
            "It is an empty array",
            "It throws an error when accessed"
        ]
    },
    {
        "q": "How does React handle style attributes in JSX?",
        "o": [
            "They are passed as an object with camelCased properties",
            "They are written as a string exactly like in HTML",
            "They must always use CSS modules",
            "They are applied only through className"
        ]
    },
    {
        "q": "What happens when multiple children are returned without being wrapped in a single parent element or fragment?",
        "o": [
            "React throws an error because JSX expressions must have one root element",
            "React automatically wraps them in a `<div>`",
            "React renders only the first element",
            "React merges them into a single text node"
        ]
    },
    {
        "q": "Which of the following correctly describes `children` when you pass a function instead of JSX?",
        "o": [
            "It is treated as a render prop and can be invoked inside the component",
            "It throws an error because children must be valid elements",
            "It is ignored by React",
            "It is coerced into a string"
        ]
    },
    {
        "q": "What will be the result of rendering `{[<li key='1'>A</li>, null, <li key='2'>B</li>]}` inside a `<ul>`?",
        "o": [
            "<ul><li>A</li><li>B</li></ul>",
            "<ul><li>A</li>null<li>B</li></ul>",
            "<ul><li>A</li><li>undefined</li><li>B</li></ul>",
            "Error: null values are not allowed in lists"
        ]
    },
    {
        "q": "Which of the following is true about prop type validation in React?",
        "o": [
            "It is optional and only runs in development mode",
            "It is required for all props to avoid runtime errors",
            "It automatically enforces type safety at runtime",
            "It only works in functional components"
        ]
    },
    {
        "q": "What happens when you render a component that returns `false`?",
        "o": [
            "Nothing is rendered in the DOM",
            "The word 'false' appears",
            "React throws a runtime error",
            "It is replaced with an empty `<span>`"
        ]
    },
    {
        "q": "What is the result of returning `null` inside a class component’s render method?",
        "o": [
            "It renders nothing to the DOM",
            "It throws an error because render must return an element",
            "It renders 'null' as text",
            "It renders an empty object"
        ]
    },
    {
        "q": "Which of the following is true about passing functions as props?",
        "o": [
            "It allows parent components to control child behavior via callbacks",
            "It forces the child to re-render on every function call",
            "It is only supported in class components",
            "It is restricted to event handler props only"
        ]
    },
    {
        "q": "Which of the following best describes the difference between JSX attributes and HTML attributes?",
        "o": [
            "JSX attributes use camelCase (e.g., onClick) while HTML uses lowercase",
            "They are identical in both syntax and behavior",
            "JSX attributes are automatically validated by the browser",
            "HTML attributes cannot accept JavaScript expressions"
        ]
    },
    {
        "q": "What is the main benefit of using `children` instead of a dedicated prop like `content`?",
        "o": [
            "It makes components more flexible and composable by allowing arbitrary nested elements",
            "It enforces strict type-checking of child components",
            "It automatically memoizes children for performance",
            "It prevents passing functions as props"
        ]
    },
    {
        "q": "Which of the following happens if you forget to add `key` to elements in a list?",
        "o": [
            "React will still render the list but may re-render inefficiently",
            "React throws an error and stops rendering",
            "The browser automatically assigns DOM IDs as keys",
            "React duplicates elements to maintain uniqueness"
        ]
    },
    {
        "q": "What happens if you pass an object directly as a child in JSX, e.g., `<div>{{a: 1}}</div>`?",
        "o": [
            "It throws an error because objects are not valid React children",
            "It stringifies the object and displays `[object Object]`",
            "It silently ignores the object and renders nothing",
            "It spreads the object as attributes on the element"
        ]
    },
    {
        "q": "Which of the following is a difference between defaultProps and destructuring with default values?",
        "o": [
            "defaultProps apply when a prop is missing, while destructuring defaults only apply inside the component",
            "They are identical and interchangeable",
            "Destructuring defaults work in class components, defaultProps do not",
            "defaultProps can override props set to `null`"
        ]
    },
    {
        "q": "Which of the following is true about JSX comments?",
        "o": [
            "They must be wrapped in curly braces inside JSX",
            "They are written exactly like HTML comments (`<!-- -->`)",
            "They can only appear at the top of a component",
            "They automatically strip whitespace around them"
        ]
    },
    {
        "q": "What happens when two components share the same key inside a list?",
        "o": [
            "React may incorrectly reuse or replace elements, leading to unpredictable rendering",
            "React throws a compile-time error",
            "React automatically generates a new unique key",
            "The DOM ignores the duplicate key but renders correctly"
        ]
    },
    {
        "q": "What is the difference between `{props.children}` and `{...props}`?",
        "o": [
            "`props.children` represents nested content, while `{...props}` spreads all props onto an element",
            "They are interchangeable ways of rendering props",
            "`props.children` only works in functional components, `{...props}` only in class components",
            "Both are required together for React to handle children"
        ]
    },
    {
        "q": "If a parent passes `<Child>{() => 'Hello'}</Child>`, what does the child receive in `props.children`?",
        "o": [
            "A function that can be invoked to return 'Hello'",
            "A string directly equal to 'Hello'",
            "An array containing the string 'Hello'",
            "An error because children must be elements"
        ]
    },
    {
        "q": "Which of the following is true about inline functions as props (e.g., `onClick={() => setCount(count+1)}`)?",
        "o": [
            "They create a new function on every render, which may affect performance",
            "They are automatically memoized by React",
            "They cannot be used in functional components",
            "They override the parent’s event system"
        ]
    },
    {
        "q": "What is the behavior of fragments (`<>...</>`) with multiple children?",
        "o": [
            "They allow grouping elements without adding an extra DOM node",
            "They always compile into a `<div>` wrapper",
            "They are only supported inside class components",
            "They automatically assign unique keys to children"
        ]
    },
    {
        "q": "What happens if you render a boolean prop directly, e.g., `<div>{true}</div>`?",
        "o": [
            "Nothing is rendered in the DOM",
            "The text 'true' is rendered",
            "React throws an error",
            "It renders as `1`"
        ]
    },
    {
        "q": "Which of the following best describes a higher-order component (HOC)?",
        "o": [
            "A function that takes a component and returns a new component",
            "A component that renders another component’s children",
            "A React component that wraps multiple class components",
            "A fragment-like component that avoids extra DOM nodes"
        ]
    },
    {
        "q": "What is the difference between `null` and `undefined` in props?",
        "o": [
            "`undefined` triggers defaultProps while `null` overrides them",
            "They are treated the same in all cases",
            "`null` throws a warning in React DevTools",
            "Both prevent a prop from being passed to children"
        ]
    },
    {
        "q": "What does `React.isValidElement` check?",
        "o": [
            "If the value is a valid React element",
            "If the value is a valid DOM node",
            "If the value is a valid JSX string",
            "If the value is a mounted component"
        ]
    },
    {
        "q": "Which of the following is true about returning arrays in React render?",
        "o": [
            "They are supported as long as each element has a key",
            "They are not supported and must be wrapped in a `<div>`",
            "They automatically flatten into a string",
            "They must always be wrapped inside `React.Children.map`"
        ]
    },
    {
        "q": "What will React render for `{undefined}` or `{null}` inside JSX?",
        "o": [
            "Nothing is rendered",
            "The text 'undefined' or 'null'",
            "It throws an error",
            "It replaces them with an empty string"
        ]
    },
    {
        "q": "Which of the following is true about passing numbers as props?",
        "o": [
            "They must be wrapped in curly braces like `count={5}`",
            "They are always converted into strings",
            "They cannot be used as prop values",
            "They must be explicitly parsed with `Number()`"
        ]
    },
    {
        "q": "Which of the following best describes the difference between `props` and `state`?",
        "o": [
            "Props are passed from parent, state is managed internally within a component",
            "Both props and state are mutable by child components",
            "Props can hold functions, state cannot",
            "State persists across unmounts, props do not"
        ]
    },
    {
        "q": "What is the purpose of `React.forwardRef`?",
        "o": [
            "To pass refs through a component to a child DOM element",
            "To create a new ref object",
            "To automatically memoize a component",
            "To expose lifecycle methods from functional components"
        ]
    },
    {
        "q": "What happens if you render `{0}` inside JSX?",
        "o": [
            "It renders the number 0 as text",
            "It renders nothing",
            "It throws a runtime error",
            "It is coerced into a string '0' automatically"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` when multiple children are passed?",
        "o": [
            "It can be a single element, an array, or even a function depending on usage",
            "It is always an array",
            "It is always a single React element",
            "It throws an error unless wrapped in a fragment"
        ]
    },
    {
        "q": "What is the purpose of `React.Children.map`?",
        "o": [
            "It safely iterates over children, even if they are not an array",
            "It only works when children are arrays",
            "It converts children into plain JavaScript arrays",
            "It clones children with keys automatically"
        ]
    },
    {
        "q": "Which of the following is true about defaultProps in functional components after React 18?",
        "o": [
            "They are deprecated in favor of default values in parameter destructuring",
            "They are required to define prop types",
            "They must be explicitly defined as a static property",
            "They only apply when using TypeScript"
        ]
    },
    {
        "q": "What will be rendered for `{['A', null, 'B']}` inside a `<span>`?",
        "o": [
            "<span>AB</span>",
            "<span>A null B</span>",
            "<span>AundefinedB</span>",
            "Error: invalid child"
        ]
    },
    {
        "q": "Which of the following is true about spreading props onto DOM elements?",
        "o": [
            "React will ignore invalid DOM attributes",
            "React throws a runtime error if invalid attributes are spread",
            "All attributes are passed to the browser, even invalid ones",
            "React automatically prefixes them with `data-`"
        ]
    },
    {
        "q": "What is the behavior of React when a component returns a string, e.g., `return 'Hello'`?",
        "o": [
            "It renders the string as a text node in the DOM",
            "It throws an error since only JSX is valid",
            "It coerces the string into `<p>Hello</p>`",
            "It ignores the return value and renders nothing"
        ]
    },
    {
        "q": "What happens when a component’s render method returns an array without keys?",
        "o": [
            "React will render but throw a warning about missing keys",
            "React automatically assigns indexes as keys without warning",
            "React throws an error and fails to render",
            "React wraps them in a fragment silently"
        ]
    },
    {
        "q": "What is the main reason to avoid mutating props inside a child?",
        "o": [
            "Because props are read-only and React will not re-render correctly if mutated",
            "Because props are shallow-cloned before being passed",
            "Because mutation breaks JSX compilation",
            "Because mutated props are ignored by the parent"
        ]
    },
    {
        "q": "Which of the following is true about conditional rendering with logical AND (`&&`) in JSX?",
        "o": [
            "If the left-hand side is falsy, nothing is rendered",
            "It always renders both sides regardless of condition",
            "It throws an error if the left-hand side is `false`",
            "It converts `false` into a string and renders it"
        ]
    },
    {
        "q": "Why might you wrap multiple children in `React.Fragment` instead of a `<div>`?",
        "o": [
            "To avoid unnecessary DOM nodes while grouping children",
            "To automatically assign unique keys to children",
            "To enable conditional rendering of only the first child",
            "To provide scoped styling across children"
        ]
    },
    {
        "q": "What is the behavior of `React.cloneElement` when overriding props?",
        "o": [
            "It merges the new props with the original element’s props",
            "It replaces all props with the new ones",
            "It ignores children when cloning",
            "It strips out defaultProps from the cloned element"
        ]
    },
    {
        "q": "What is the main use case of `React.Children.forEach`?",
        "o": [
            "To iterate through children without returning a new array",
            "To enforce keys on child elements",
            "To filter children based on type",
            "To convert children into a string"
        ]
    },
    {
        "q": "Which of the following is true about inline conditional rendering using the ternary operator?",
        "o": [
            "It allows rendering one of two elements based on a condition",
            "It only works when returning strings",
            "It must always return a fragment",
            "It automatically memoizes both branches"
        ]
    },
    {
        "q": "What will React render if a component returns `[]`?",
        "o": [
            "Nothing will be rendered",
            "It renders `[]` as text",
            "It throws an error",
            "It renders a placeholder `<div>`"
        ]
    },
    {
        "q": "Which of the following is true about using functions as children?",
        "o": [
            "They allow components to use the render props pattern",
            "They are automatically invoked by React before rendering",
            "They are treated as invalid children",
            "They only work in class components"
        ]
    },
    {
        "q": "Why is `key` important when rendering dynamic lists?",
        "o": [
            "It helps React identify which items have changed, added, or removed",
            "It is required for applying inline styles",
            "It allows children to access their index in the list",
            "It automatically sets the `id` attribute on elements"
        ]
    },
    {
        "q": "What is the default value of `props.children` when no children are passed?",
        "o": [
            "undefined",
            "null",
            "[]",
            "An empty string"
        ]
    },
    {
        "q": "Which of the following describes how React handles invalid DOM attributes?",
        "o": [
            "They are ignored and not added to the DOM",
            "They are passed as-is to the DOM",
            "They are converted into `data-*` attributes",
            "They throw an error during reconciliation"
        ]
    },
    {
        "q": "What happens when you render `{false}` inside JSX?",
        "o": [
            "Nothing is rendered",
            "The word 'false' is rendered",
            "It throws a runtime error",
            "It coerces into the string '0'"
        ]
    },
    {
        "q": "Which of the following is true about `displayName` in React components?",
        "o": [
            "It customizes how the component appears in React DevTools",
            "It changes the DOM tag name of the rendered component",
            "It enforces type checking of props",
            "It automatically applies a CSS class name to the root element"
        ]
    },
    {
        "q": "What happens when you return multiple top-level JSX elements without wrapping them?",
        "o": [
            "React throws an error because JSX must have one parent element",
            "React automatically wraps them in a fragment",
            "React renders only the first element",
            "React merges them into a single node"
        ]
    },
    {
        "q": "Which of the following best describes the `children` prop in React?",
        "o": [
            "It is a special prop automatically passed to components that represents nested content",
            "It must be explicitly defined in the component’s prop list",
            "It only works in class components",
            "It is always an array of elements"
        ]
    },
    {
        "q": "What is the main purpose of `React.Fragment`?",
        "o": [
            "To group multiple elements without adding extra nodes to the DOM",
            "To automatically memoize children",
            "To enforce type checking on child elements",
            "To add a unique key to all children"
        ]
    },
    {
        "q": "Which of the following is true about returning numbers from a React component?",
        "o": [
            "Numbers are rendered as text nodes in the DOM",
            "Numbers throw an error unless wrapped in `<span>`",
            "Numbers are ignored and nothing renders",
            "Numbers must be converted to strings before returning"
        ]
    },
    {
        "q": "What happens when you spread props onto a component with `{...props}`?",
        "o": [
            "All props are forwarded to the component or element",
            "Only string props are forwarded",
            "Children are excluded automatically",
            "React throws a warning for non-primitive props"
        ]
    },
    {
        "q": "Which of the following is NOT true about React keys?",
        "o": [
            "They are accessible inside child components via props",
            "They must be unique among siblings",
            "They help React identify elements during reconciliation",
            "They prevent unnecessary re-renders when used correctly"
        ]
    },
    {
        "q": "What is the default behavior when you render an array of strings as children?",
        "o": [
            "They are concatenated and rendered as text",
            "They are each wrapped in `<span>`",
            "They throw an error unless keys are provided",
            "They are ignored unless explicitly mapped"
        ]
    },
    {
        "q": "Which of the following is true about conditional rendering using `null`?",
        "o": [
            "Returning `null` means the component renders nothing",
            "Returning `null` throws an error in React 18",
            "Returning `null` automatically renders an empty `<div>`",
            "Returning `null` shows a warning in the console"
        ]
    },
    {
        "q": "What happens when a component explicitly returns `false`?",
        "o": [
            "It renders nothing, same as returning `null`",
            "The text 'false' is rendered",
            "It throws a runtime error",
            "It renders an empty string"
        ]
    },
    {
        "q": "Which of the following describes render props?",
        "o": [
            "A technique where a prop is a function that controls rendering",
            "A prop that always renders its children first",
            "A lifecycle method in class components",
            "A reserved keyword in JSX for default rendering"
        ]
    },
    {
        "q": "What is the behavior of `React.Children.toArray` with children missing keys?",
        "o": [
            "It assigns keys automatically to children without keys",
            "It throws an error for missing keys",
            "It ignores children without keys",
            "It merges children into a single fragment"
        ]
    },
    {
        "q": "Which of the following is true about functional components?",
        "o": [
            "They are plain JavaScript functions that return JSX",
            "They must always extend `React.Component`",
            "They can only accept primitive props",
            "They cannot render children"
        ]
    },
    {
        "q": "What happens when you pass a number as a child, e.g., `<div>{42}</div>`?",
        "o": [
            "It renders the number as text in the DOM",
            "It throws an error since children must be strings or elements",
            "It is ignored by React",
            "It coerces into a boolean value"
        ]
    },
    {
        "q": "Which of the following best describes the difference between `props.children` and named props?",
        "o": [
            "children is implicit and passed between opening and closing tags, named props are explicit",
            "They are identical and interchangeable",
            "children must always be a string, named props can be JSX",
            "children cannot be used in class components"
        ]
    },
    {
        "q": "What is the purpose of `React.PureComponent`?",
        "o": [
            "It implements a shallow comparison of props and state to avoid unnecessary renders",
            "It prevents any children from rendering unless explicitly allowed",
            "It converts all props into immutable values",
            "It automatically memoizes all function props"
        ]
    },
    {
        "q": "What happens if you provide a `key` prop to a normal DOM element like `<div key='1' />`?",
        "o": [
            "React uses it internally but it does not appear in the DOM",
            "It renders as a `key` attribute on the DOM element",
            "It throws a runtime error",
            "It is converted into a `data-key` attribute"
        ]
    },
    {
        "q": "Which of the following is true about `defaultProps` with `undefined` values?",
        "o": [
            "Default props are applied when a prop is `undefined`",
            "Default props are ignored if a prop is `undefined`",
            "They only apply if the prop is `null`",
            "They only work in class components"
        ]
    },
    {
        "q": "What happens if you return an empty fragment `<> </>` from a component?",
        "o": [
            "Nothing is rendered in the DOM",
            "It throws an error since fragments must have children",
            "It automatically renders an empty `<div>`",
            "It renders a whitespace node"
        ]
    },
    {
        "q": "Which of the following best describes `React.forwardRef`?",
        "o": [
            "It allows passing a ref through a component to a child DOM element",
            "It creates a new ref object tied to state",
            "It memoizes a component’s output",
            "It forwards props between unrelated components"
        ]
    },
    {
        "q": "What is the difference between `null` and `false` as return values in a component?",
        "o": [
            "Both cause React to render nothing",
            "null renders nothing, but false renders 'false'",
            "false throws a runtime error while null does not",
            "They are treated differently in lists but the same in single components"
        ]
    },
    {
        "q": "What will React render if a component returns `true`?",
        "o": [
            "Nothing will be rendered",
            "The text `true`",
            "An error is thrown",
            "It renders a placeholder <div>"
        ]
    },
    {
        "q": "Which of the following is true about spreading `{...props}` onto a DOM element?",
        "o": [
            "It can accidentally pass non-DOM attributes, which React ignores",
            "It throws a runtime error if invalid attributes exist",
            "It automatically filters attributes based on HTML spec",
            "It renames unknown props into data-* attributes"
        ]
    },
    {
        "q": "What is the main purpose of `React.memo`?",
        "o": [
            "To prevent re-rendering of a component when its props have not changed",
            "To memoize event handlers automatically",
            "To make props immutable inside the child",
            "To prevent children from rendering"
        ]
    },
    {
        "q": "What happens if you return a JavaScript array of numbers from a component?",
        "o": [
            "They are concatenated and rendered as text",
            "They are ignored silently",
            "It throws an error because numbers cannot be rendered",
            "They are automatically wrapped in <span>"
        ]
    },
    {
        "q": "Which of the following is true about using fragments (`<>...</>`)?",
        "o": [
            "They allow grouping of children without extra DOM nodes",
            "They are equivalent to using <div>",
            "They automatically assign keys to children",
            "They can only contain text nodes"
        ]
    },
    {
        "q": "Why should you avoid mutating props directly?",
        "o": [
            "Because props are immutable and mutations are ignored",
            "Because React will throw an error immediately",
            "Because mutations always overwrite defaultProps",
            "Because mutated props become part of component state"
        ]
    },
    {
        "q": "What happens if you render `{NaN}` inside JSX?",
        "o": [
            "It renders 'NaN' as text",
            "It renders nothing",
            "It throws a runtime error",
            "It renders 0"
        ]
    },
    {
        "q": "Which of the following is true about conditional rendering using `&&` in JSX?",
        "o": [
            "It renders the right-hand side only if the left-hand side is truthy",
            "It always renders both sides",
            "It throws an error if left-hand side is false",
            "It coerces false into a string 'false'"
        ]
    },
    {
        "q": "What is the purpose of `propTypes` in React?",
        "o": [
            "To validate props at runtime and warn in development",
            "To enforce compile-time type checking",
            "To provide default values for props",
            "To prevent children from being passed"
        ]
    },
    {
        "q": "What happens when you render `{Infinity}` inside JSX?",
        "o": [
            "It renders 'Infinity' as text",
            "It throws an error",
            "It renders nothing",
            "It renders 0"
        ]
    },
    {
        "q": "What happens when you return a plain JavaScript object from a functional component?",
        "o": [
            "React throws an error because objects are not valid as React children",
            "It renders the object as JSON",
            "It coerces the object into a string",
            "It silently ignores the return value"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` when multiple elements are passed?",
        "o": [
            "It becomes an array of elements",
            "It becomes a string",
            "It is always a single React element",
            "It is automatically wrapped in a fragment"
        ]
    },
    {
        "q": "What will React render if a component returns an empty string `\"\"`?",
        "o": [
            "Nothing will be rendered",
            "A blank text node",
            "It throws a runtime error",
            "It renders a <div> with no text"
        ]
    },
    {
        "q": "Which of the following is true about using `key` in fragments?",
        "o": [
            "Keys can be added to fragments just like other elements",
            "Keys are not supported on fragments",
            "Keys on fragments are automatically generated",
            "Keys in fragments are ignored during reconciliation"
        ]
    },
    {
        "q": "What happens when you render a boolean `true` in JSX?",
        "o": [
            "Nothing is rendered",
            "The text 'true' is displayed",
            "It throws an error",
            "It coerces into 1"
        ]
    },
    {
        "q": "Which of the following is true about higher-order components (HOCs)?",
        "o": [
            "They are functions that take a component and return a new component",
            "They are components that can contain multiple children",
            "They are always implemented as class components",
            "They automatically provide state management"
        ]
    },
    {
        "q": "What happens if you render `{undefined}` inside JSX?",
        "o": [
            "Nothing is rendered",
            "It renders 'undefined' as text",
            "It throws a runtime error",
            "It coerces into null"
        ]
    },
    {
        "q": "Which of the following is true about `defaultProps` in functional components?",
        "o": [
            "They can still be defined as a static property on the function",
            "They are ignored completely",
            "They must be defined using `propTypes`",
            "They only work when wrapped with `React.memo`"
        ]
    },
    {
        "q": "What is the purpose of `React.Children.only`?",
        "o": [
            "It verifies that a component has exactly one child",
            "It returns the first child, ignoring others",
            "It concatenates multiple children into one string",
            "It enforces keys on children"
        ]
    },
    {
        "q": "What happens if you pass a function as a child but don’t call it?",
        "o": [
            "React renders the function’s source code as text",
            "React throws a runtime error",
            "React renders nothing",
            "React automatically invokes the function"
        ]
    },
    {
        "q": "Which of the following is true about `React.forwardRef` usage?",
        "o": [
            "It allows a parent component to pass a ref through a component to a child DOM node",
            "It automatically converts class components into functional components",
            "It creates a new state variable accessible to the parent",
            "It prevents re-rendering of the child component"
        ]
    },
    {
        "q": "What is the difference between a controlled and an uncontrolled component?",
        "o": [
            "Controlled components have their value managed by React state, uncontrolled rely on the DOM",
            "Controlled components cannot have children, uncontrolled can",
            "Uncontrolled components automatically sync with Redux",
            "Controlled components cannot use defaultProps"
        ]
    },
    {
        "q": "Which of the following is true about `React.lazy`?",
        "o": [
            "It allows code-splitting by loading components lazily",
            "It automatically memoizes components to prevent re-rendering",
            "It is used to forward refs to children",
            "It converts class components into functional components"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries?",
        "o": [
            "They catch JavaScript errors in child components and render a fallback UI",
            "They automatically retry rendering failed components",
            "They can catch errors inside event handlers",
            "They work only with functional components"
        ]
    },
    {
        "q": "What is the purpose of `React.Suspense`?",
        "o": [
            "To provide a fallback UI while lazy-loaded components are loading",
            "To suspend state updates temporarily",
            "To delay re-rendering of all children",
            "To memoize children components automatically"
        ]
    },
    {
        "q": "Which of the following statements about refs is correct?",
        "o": [
            "Refs provide a way to access DOM nodes or React elements directly",
            "Refs are always read-only and cannot be updated",
            "Refs can only be used in class components",
            "Refs are automatically passed to children via props"
        ]
    },
    {
        "q": "What is the effect of calling `React.createRef()` in a functional component?",
        "o": [
            "It creates a ref object that can be attached to DOM elements or components",
            "It automatically updates the component state",
            "It converts the functional component into a class component",
            "It memoizes all props passed to the component"
        ]
    },
    {
        "q": "Which of the following is true about memoization with `React.memo`?",
        "o": [
            "It prevents re-rendering if the component’s props do not change shallowly",
            "It caches state values across unmounts",
            "It replaces the need for `useCallback`",
            "It is required for all functional components for performance"
        ]
    },
    {
        "q": "Which of the following is true about `useImperativeHandle` in functional components?",
        "o": [
            "It customizes the instance value exposed to parent refs",
            "It replaces `useState` for managing internal state",
            "It automatically forwards props to children",
            "It memoizes the component output"
        ]
    },
    {
        "q": "Which of the following statements about portaling with `ReactDOM.createPortal` is correct?",
        "o": [
            "It allows rendering children into a different part of the DOM tree",
            "It duplicates children across multiple DOM nodes automatically",
            "It prevents children from receiving props",
            "It converts class components into functional components"
        ]
    },
    {
        "q": "Which of the following is true about `useCallback`?",
        "o": [
            "It memoizes a function so that it does not get recreated on every render unless dependencies change",
            "It automatically memoizes component state",
            "It converts a class method into a functional component",
            "It delays rendering of a child component until needed"
        ]
    },
    {
        "q": "Which of the following is true about `useMemo`?",
        "o": [
            "It memoizes a computed value to avoid expensive recalculations",
            "It memoizes component props automatically",
            "It replaces `useEffect` for side effects",
            "It automatically deep clones objects passed as dependencies"
        ]
    },
    {
        "q": "Which of the following is true about `React.PureComponent`?",
        "o": [
            "It implements a shallow comparison of props and state to avoid unnecessary re-renders",
            "It automatically memoizes function props",
            "It can only be used with functional components",
            "It forces a component to always re-render"
        ]
    },
    {
        "q": "Which of the following is true about `React.StrictMode`?",
        "o": [
            "It helps detect potential problems in an application by adding extra checks in development",
            "It automatically prevents re-rendering of children",
            "It disables all console warnings",
            "It only works in production mode"
        ]
    },
    {
        "q": "Which of the following is true about lazy-loaded components in React?",
        "o": [
            "They are loaded dynamically when rendered, often wrapped in `React.Suspense`",
            "They are preloaded during the first render automatically",
            "They do not support children",
            "They must be class components"
        ]
    },
    {
        "q": "Which of the following is true about `useRef` in functional components?",
        "o": [
            "It can hold a mutable value that persists across renders without causing re-renders",
            "It automatically updates the DOM when the value changes",
            "It is the only way to manage state in functional components",
            "It replaces `useState` for all variables"
        ]
    },
    {
        "q": "What is the purpose of `React.unstable_ConcurrentMode`?",
        "o": [
            "It enables experimental concurrent rendering to improve responsiveness",
            "It guarantees synchronous rendering of all components",
            "It automatically memoizes components for performance",
            "It is used to defer rendering of all children indefinitely"
        ]
    },
    {
        "q": "Which of the following is true about `React.lazy` and code-splitting?",
        "o": [
            "It allows components to be loaded on demand to reduce initial bundle size",
            "It preloads all components during initial render",
            "It only works with class components",
            "It automatically converts JSX into plain HTML"
        ]
    },
    {
        "q": "Which of the following is true about context in React?",
        "o": [
            "It allows passing data through the component tree without explicitly passing props at every level",
            "It automatically triggers re-renders for all children regardless of usage",
            "It can only be used with class components",
            "It is the same as passing props manually"
        ]
    },
    {
        "q": "Which of the following is true about the `React.lazy` fallback property?",
        "o": [
            "It is used with `React.Suspense` to show a fallback while the component loads",
            "It automatically delays the first render of the parent component",
            "It is used to provide defaultProps for lazy-loaded components",
            "It is required for all children inside the component"
        ]
    },
    {
        "q": "Which of the following is true about `useLayoutEffect`?",
        "o": [
            "It runs synchronously after all DOM mutations but before the browser paints",
            "It runs asynchronously after the component renders",
            "It replaces `useEffect` for all side effects",
            "It only works in class components"
        ]
    },
    {
        "q": "What is the difference between `useEffect` and `useLayoutEffect`?",
        "o": [
            "useLayoutEffect fires synchronously before the browser paints, while useEffect runs after painting",
            "useEffect runs synchronously before painting, useLayoutEffect after painting",
            "Both run at the same time but useLayoutEffect blocks re-renders",
            "There is no difference; they are interchangeable"
        ]
    },
    {
        "q": "Which of the following is true about `React.memo` when used with a custom comparison function?",
        "o": [
            "It only re-renders the component when the comparison function returns false",
            "It always prevents re-rendering",
            "It replaces the need for `useEffect`",
            "It automatically deep compares all props"
        ]
    },
    {
        "q": "Which of the following best describes `React.useImperativeHandle`?",
        "o": [
            "It allows customizing the instance value exposed to parent refs",
            "It is used to manage state imperatively",
            "It automatically memoizes children elements",
            "It replaces `forwardRef` completely"
        ]
    },
    {
        "q": "Which of the following is true about context consumers?",
        "o": [
            "They subscribe to context changes and re-render when context value changes",
            "They only read the context once and never update",
            "They automatically memoize context values",
            "They cannot be nested inside other components"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries regarding event handlers?",
        "o": [
            "They do NOT catch errors in event handlers",
            "They catch errors in event handlers automatically",
            "They prevent event propagation entirely",
            "They convert errors into warnings in the console"
        ]
    },
    {
        "q": "Which of the following best describes `React.unstable_useTransition`?",
        "o": [
            "It allows marking updates as non-urgent to improve UI responsiveness",
            "It synchronously blocks rendering until the state is updated",
            "It automatically debounces state changes",
            "It replaces `useEffect` for side effects"
        ]
    },
    {
        "q": "What is the primary difference between `React.Component` and `React.PureComponent`?",
        "o": [
            "PureComponent implements shallow comparison for props and state, while Component does not",
            "Component automatically memoizes output, PureComponent does not",
            "PureComponent cannot have state",
            "Component cannot render children"
        ]
    },
    {
        "q": "Which of the following is true about `React.SuspenseList`?",
        "o": [
            "It coordinates the reveal order of multiple Suspense components",
            "It automatically lazy-loads all child components",
            "It prevents fallback UI from showing",
            "It replaces `React.Suspense` entirely"
        ]
    },
    {
        "q": "Which of the following is true about `useDebugValue`?",
        "o": [
            "It allows displaying custom labels for hooks in React DevTools",
            "It automatically logs all state changes",
            "It replaces `console.log` for debugging",
            "It only works in class components"
        ]
    },
    {
        "q": "Which of the following is true about `React.unstable_useId`?",
        "o": [
            "It generates unique IDs that are consistent across server and client for accessibility",
            "It automatically assigns unique keys to children",
            "It replaces `useRef` for DOM references",
            "It generates random IDs for each render"
        ]
    },
    {
        "q": "What is the main advantage of using `React.lazy` with dynamic imports?",
        "o": [
            "It reduces initial bundle size by loading components only when needed",
            "It improves CSS performance automatically",
            "It ensures components are always memoized",
            "It converts class components to functional components"
        ]
    },
    {
        "q": "Which of the following is true about `React.memo` and state updates?",
        "o": [
            "It prevents re-rendering only when props are shallowly equal, state updates inside the component still trigger render",
            "It prevents all re-renders including state changes",
            "It only works with class components",
            "It automatically memoizes children"
        ]
    },
    {
        "q": "Which of the following best describes `useDeferredValue`?",
        "o": [
            "It allows deferring a value so that urgent updates are prioritized for smoother UI",
            "It immediately updates the value on every render",
            "It memoizes values permanently",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about `ReactDOM.createPortal`?",
        "o": [
            "It renders children into a DOM node outside the parent component’s hierarchy",
            "It clones children with new props automatically",
            "It forces all children to re-render every time",
            "It converts functional components into class components"
        ]
    },
    {
        "q": "Which of the following is true about `useSyncExternalStore`?",
        "o": [
            "It provides a way to subscribe to external stores while ensuring consistent UI updates",
            "It automatically stores state externally",
            "It replaces `useState` entirely",
            "It only works in class components"
        ]
    },
    {
        "q": "Which of the following statements about error boundaries is correct?",
        "o": [
            "They catch errors during rendering, lifecycle methods, and constructors of child components, but not in event handlers",
            "They catch all errors in the entire application automatically",
            "They only work with functional components",
            "They prevent props from changing unexpectedly"
        ]
    },
    {
        "q": "Which of the following is true about the new `useInsertionEffect` hook?",
        "o": [
            "It is intended for injecting styles before DOM mutations happen",
            "It is used to replace `useEffect` for all side effects",
            "It automatically optimizes component rendering",
            "It only works with memoized components"
        ]
    },
    {
        "q": "Which of the following is true about server components in React?",
        "o": [
            "They allow components to render on the server without sending client-side JavaScript",
            "They must be class components",
            "They automatically load all client-side dependencies",
            "They can modify browser DOM directly from the server"
        ]
    },
    {
        "q": "Which of the following is true about the difference between `React.StrictMode` and production mode?",
        "o": [
            "StrictMode adds extra checks and warnings in development but has no effect in production",
            "StrictMode enforces synchronous rendering in production",
            "StrictMode prevents re-renders in production",
            "StrictMode automatically memoizes all components in production"
        ]
    },
    {
        "q": "Which of the following is true about `useTransition`?",
        "o": [
            "It allows marking state updates as non-urgent so the UI remains responsive during heavy rendering",
            "It synchronously updates state immediately",
            "It automatically memoizes all children components",
            "It replaces `useEffect` for side effects"
        ]
    },
    {
        "q": "Which of the following is true about `React.useDebugValue`?",
        "o": [
            "It allows you to display a label for custom hooks in React DevTools for easier debugging",
            "It automatically logs all prop changes in development",
            "It forces re-rendering when a hook value changes",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about server-side rendering (SSR) in React?",
        "o": [
            "It renders React components on the server and sends HTML to the client for faster initial load",
            "It disables React reconciliation on the client",
            "It converts all components into class components",
            "It prevents usage of hooks entirely"
        ]
    },
    {
        "q": "Which of the following is true about `useId`?",
        "o": [
            "It generates unique IDs that are stable across server and client renders for accessibility attributes",
            "It automatically sets keys on list elements",
            "It generates a new unique ID on every render",
            "It replaces refs for DOM elements"
        ]
    },
    {
        "q": "Which of the following is true about `React.SuspenseList`?",
        "o": [
            "It coordinates the reveal order of multiple Suspense components for better UX",
            "It automatically lazy-loads all children",
            "It disables fallback UI for Suspense components",
            "It is used only for server components"
        ]
    },
    {
        "q": "Which of the following is true about `useId` versus `useRef`?",
        "o": [
            "useId is for generating stable unique IDs, while useRef is for holding mutable values or DOM references",
            "useId is for DOM references, useRef for IDs",
            "Both are identical and can be used interchangeably",
            "useId can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is true about controlled components?",
        "o": [
            "Their form values are controlled by React state, providing a single source of truth",
            "They can only use defaultProps for their value",
            "They cannot update their own state",
            "They automatically use memoization for inputs"
        ]
    },
    {
        "q": "Which of the following is true about uncontrolled components?",
        "o": [
            "Their form values are handled by the DOM and accessed via refs when needed",
            "They automatically sync with React state",
            "They cannot have initial values",
            "They throw errors if you try to access value via ref"
        ]
    },
    {
        "q": "Which of the following is true about `useDeferredValue`?",
        "o": [
            "It allows deferring an update so that urgent updates render first for smoother UI",
            "It immediately applies the value in state",
            "It automatically memoizes the value permanently",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about event handling in React?",
        "o": [
            "React wraps native events in SyntheticEvent for cross-browser compatibility",
            "All events are automatically delegated to the window object",
            "React requires you to use addEventListener manually for all events",
            "SyntheticEvent automatically converts all events into promises"
        ]
    },
    {
        "q": "Which of the following is true about `React.Suspense` when used with data fetching libraries?",
        "o": [
            "It can show a fallback UI while waiting for asynchronous data to load",
            "It automatically caches fetched data",
            "It blocks all components from rendering until all data is fetched",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about `useTransition` when updating state?",
        "o": [
            "It allows marking updates as low-priority to keep the interface responsive",
            "It forces updates to block rendering until completed",
            "It memoizes state permanently",
            "It can only be used inside class components"
        ]
    },
    {
        "q": "Which of the following is true about `useImperativeHandle`?",
        "o": [
            "It customizes the instance value exposed to parent refs when using `forwardRef`",
            "It automatically forwards props to children",
            "It memoizes the component output",
            "It replaces `useEffect` for side effects"
        ]
    },
    {
        "q": "Which of the following is true about lazy-loaded components using `React.lazy`?",
        "o": [
            "They are dynamically imported only when rendered, reducing initial bundle size",
            "They are preloaded during the first render automatically",
            "They do not support children",
            "They must be class components"
        ]
    },
    {
        "q": "Which of the following is true about React Portals?",
        "o": [
            "They allow rendering children into a DOM node outside of the parent hierarchy",
            "They automatically memoize all child elements",
            "They prevent updates to the parent component",
            "They convert functional components to class components"
        ]
    },
    {
        "q": "Which of the following is true about `useDebugValue`?",
        "o": [
            "It helps display custom hook values in React DevTools for easier debugging",
            "It automatically logs all state changes",
            "It replaces `console.log` entirely",
            "It can only be used in class components"
        ]
    },
    {
        "q": "Which of the following is true about server components in React?",
        "o": [
            "They allow rendering components on the server without sending client-side JavaScript",
            "They must be class components",
            "They automatically load client-side dependencies",
            "They directly modify browser DOM from the server"
        ]
    },
    {
        "q": "Which of the following is true about `useSyncExternalStore`?",
        "o": [
            "It allows subscribing to external stores while ensuring consistent UI updates",
            "It automatically stores state externally",
            "It replaces `useState` entirely",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about `React.StrictMode` in development?",
        "o": [
            "It activates additional checks and warnings to detect potential problems",
            "It prevents re-rendering of children",
            "It disables all console warnings",
            "It forces synchronous rendering in production"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries catching errors?",
        "o": [
            "They catch errors during rendering, lifecycle methods, and constructors of child components, but not in event handlers",
            "They catch all errors globally",
            "They only work with functional components",
            "They prevent prop changes from causing errors"
        ]
    },
    {
        "q": "Which of the following is true about `useEffect` cleanup functions?",
        "o": [
            "They run before the component unmounts or before the effect runs again",
            "They run after the component renders for the first time only",
            "They run synchronously with every render",
            "They automatically cancel state updates"
        ]
    },
    {
        "q": "Which of the following is true about `useLayoutEffect` in contrast to `useEffect`?",
        "o": [
            "It fires synchronously after DOM mutations but before the browser paints",
            "It fires asynchronously after painting like useEffect",
            "It automatically memoizes values returned from the effect",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.map`?",
        "o": [
            "It safely iterates over children even if they are not an array",
            "It always returns a flat array of child elements",
            "It modifies children in-place",
            "It only works with string children"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.only`?",
        "o": [
            "It verifies that a component has exactly one child and returns it",
            "It automatically wraps multiple children in a fragment",
            "It converts children into strings",
            "It only works with arrays of children"
        ]
    },
    {
        "q": "Which of the following is true about context providers in React?",
        "o": [
            "They supply a context value to all descendant consumers",
            "They automatically memoize context values",
            "They can only be used in class components",
            "They prevent child components from receiving props"
        ]
    },
    {
        "q": "Which of the following is true about `React.useImperativeHandle` usage?",
        "o": [
            "It allows customizing what is exposed to the parent ref when using forwardRef",
            "It automatically forwards all props to the child",
            "It memoizes component outputs for performance",
            "It replaces useState for managing local state"
        ]
    },
    {
        "q": "Which of the following is true about controlled input components?",
        "o": [
            "Their value is driven by React state and updated via onChange",
            "They rely entirely on the DOM to manage their value",
            "They cannot have default values",
            "They automatically memoize input values"
        ]
    },
    {
        "q": "Which of the following is true about uncontrolled input components?",
        "o": [
            "Their value is managed by the DOM and accessed via refs when needed",
            "They require onChange handlers to update state",
            "They cannot have initial values",
            "They automatically sync with React state"
        ]
    },
    {
        "q": "Which of the following is true about `React.forwardRef`?",
        "o": [
            "It allows passing a ref from a parent component to a child DOM node or component",
            "It automatically converts class components to functional components",
            "It memoizes props passed to the child",
            "It only works for DOM elements, not custom components"
        ]
    },
    {
        "q": "Which of the following is true about `React.lazy` fallback UI?",
        "o": [
            "It is shown while the lazy-loaded component is being fetched",
            "It is only displayed after the component is fully loaded",
            "It replaces defaultProps for the component",
            "It automatically memoizes the lazy component"
        ]
    },
    {
        "q": "Which of the following is true about `React.useDeferredValue`?",
        "o": [
            "It allows deferring updates to a value to prioritize more urgent renders for smoother UI",
            "It immediately applies state updates synchronously",
            "It automatically memoizes the value permanently",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about the difference between `React.Component` and `React.PureComponent`?",
        "o": [
            "PureComponent implements shallow comparison of props and state to reduce unnecessary re-renders",
            "Component automatically memoizes outputs, PureComponent does not",
            "PureComponent cannot have state or lifecycle methods",
            "Component forces shallow comparison on every render"
        ]
    },
    {
        "q": "Which of the following is true about server-side rendering (SSR) in React?",
        "o": [
            "It renders React components to HTML on the server and sends it to the client for faster initial load",
            "It disables React reconciliation on the client",
            "It converts all components into class components",
            "It prevents the use of hooks entirely"
        ]
    },
    {
        "q": "Which of the following is true about `React.SuspenseList`?",
        "o": [
            "It coordinates the reveal order of multiple Suspense components for better user experience",
            "It automatically lazy-loads all child components",
            "It disables fallback UI for all Suspense components",
            "It replaces React.Suspense entirely"
        ]
    },
    {
        "q": "Which of the following is true about `React.unstable_useId`?",
        "o": [
            "It generates stable unique IDs that are consistent across server and client renders",
            "It automatically assigns keys to list elements",
            "It generates a new random ID on every render",
            "It replaces refs for DOM elements"
        ]
    },
    {
        "q": "Which of the following is true about `React.unstable_ConcurrentMode`?",
        "o": [
            "It enables experimental concurrent rendering to improve UI responsiveness",
            "It forces synchronous rendering of all components",
            "It automatically memoizes components",
            "It defers rendering of all children indefinitely"
        ]
    },
    {
        "q": "Which of the following is true about `useSyncExternalStore`?",
        "o": [
            "It provides a safe way to subscribe to external stores while ensuring consistent UI updates",
            "It automatically stores state externally",
            "It replaces useState entirely",
            "It only works in class components"
        ]
    },
    {
        "q": "Which of the following is true about `React.useDebugValue`?",
        "o": [
            "It allows displaying custom labels for hooks in React DevTools for easier debugging",
            "It automatically logs all state changes to the console",
            "It replaces console.log entirely",
            "It only works with class components"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries?",
        "o": [
            "They catch errors during rendering, lifecycle methods, and constructors of child components, but not in event handlers",
            "They catch all errors in the entire application automatically",
            "They only work with functional components",
            "They prevent props from changing unexpectedly"
        ]
    },
    {
        "q": "Which of the following is true about `React.StrictMode`?",
        "o": [
            "It adds extra checks and warnings in development mode to detect potential problems",
            "It prevents re-rendering of children",
            "It disables all console warnings",
            "It forces synchronous rendering in production"
        ]
    },
    {
        "q": "Which of the following is true about the `children` prop in React?",
        "o": [
            "It represents the content nested between a component’s opening and closing tags and can be any renderable element",
            "It must always be a single React element",
            "It can only contain strings or numbers",
            "It is automatically converted into an array of elements"
        ]
    },
    {
        "q": "Which of the following is true about passing props in React?",
        "o": [
            "Props are read-only and cannot be modified by the child component",
            "Props can be mutated by the child component without side effects",
            "Props are automatically converted into state in the child",
            "Props must always be strings"
        ]
    },
    {
        "q": "Which of the following is true about default props (`defaultProps`) in class components?",
        "o": [
            "They provide default values for props if the parent does not pass them",
            "They override any props passed from the parent",
            "They can only be used with functional components",
            "They automatically memoize props"
        ]
    },
    {
        "q": "Which of the following is true about class components in React?",
        "o": [
            "They extend `React.Component` and can use lifecycle methods",
            "They cannot have state",
            "They are automatically memoized",
            "They must return only a single string or number"
        ]
    },
    {
        "q": "Which of the following is true about functional components in React?",
        "o": [
            "They are plain JavaScript functions that return JSX and can use hooks",
            "They must extend `React.Component`",
            "They cannot accept props",
            "They cannot return fragments"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.toArray`?",
        "o": [
            "It converts children into a flat array and assigns keys if missing",
            "It only works with string children",
            "It automatically wraps children in a fragment",
            "It modifies the original children in place"
        ]
    },
    {
        "q": "Which of the following is true about rendering multiple children without keys?",
        "o": [
            "React renders them but warns about missing keys for stable identity",
            "React throws an error and stops rendering",
            "React automatically assigns meaningful unique IDs",
            "React merges all children into a single string"
        ]
    },
    {
        "q": "Which of the following is true about conditional rendering in JSX?",
        "o": [
            "You can use ternary operators or logical && to conditionally render elements",
            "You cannot use JavaScript expressions in JSX",
            "You must always wrap conditional content in fragments",
            "Returning false or null will throw a runtime error"
        ]
    },
    {
        "q": "Which of the following is true about passing functions as props?",
        "o": [
            "Functions can be passed as props to allow callbacks from child components",
            "Functions cannot be passed as props",
            "Functions are automatically executed when passed as props",
            "Functions passed as props cannot access state"
        ]
    },
    {
        "q": "Which of the following is true about memoization of components?",
        "o": [
            "Using `React.memo` prevents unnecessary re-renders when props are shallowly equal",
            "It automatically memoizes state updates",
            "It only works with class components",
            "It prevents children from updating their state"
        ]
    },
    {
        "q": "Which of the following is true about fragments in React?",
        "o": [
            "They let you group multiple children without adding extra DOM nodes",
            "They automatically add a `<div>` wrapper around children",
            "They can only contain text nodes",
            "They prevent re-renders of children"
        ]
    },
    {
        "q": "Which of the following is true about inline conditional rendering using `&&`?",
        "o": [
            "If the left side is truthy, React renders the right side; otherwise, it renders nothing",
            "It always renders both sides regardless of the condition",
            "It requires the right side to be a function",
            "It throws an error if the left side is false"
        ]
    },
    {
        "q": "Which of the following is true about `key` props in React lists?",
        "o": [
            "They help React identify elements and optimize re-renders",
            "They are passed as normal props to child components",
            "They must always be globally unique across the entire app",
            "They prevent state updates inside the list items"
        ]
    },
    {
        "q": "Which of the following is true about the `children` prop type?",
        "o": [
            "It can be a single element, multiple elements, strings, numbers, or even functions",
            "It must always be an array of elements",
            "It only accepts primitive values like string or number",
            "It cannot be passed explicitly as a prop"
        ]
    },
    {
        "q": "Which of the following is true about spreading props using `{...props}`?",
        "o": [
            "It spreads all properties of the props object onto a component or DOM element",
            "It only spreads functions from props",
            "It automatically validates prop types",
            "It prevents overriding existing attributes"
        ]
    },
    {
        "q": "Which of the following is true about `defaultProps` in functional components (before React 17)?",
        "o": [
            "They can be used to define default values for props if none are provided",
            "They override props even when a value is explicitly passed",
            "They are required for every functional component",
            "They prevent the component from receiving children"
        ]
    },
    {
        "q": "Which of the following is true about `React.cloneElement`?",
        "o": [
            "It clones a React element and allows you to modify or add props",
            "It creates a deep clone of the entire component tree",
            "It automatically wraps children in fragments",
            "It converts JSX into plain strings"
        ]
    },
    {
        "q": "Which of the following is true about `PropTypes`?",
        "o": [
            "They provide runtime type checking for props in development",
            "They enforce strict compile-time type checking",
            "They are required in every component",
            "They prevent props from being optional"
        ]
    },
    {
        "q": "Which of the following is true about higher-order components (HOCs)?",
        "o": [
            "They are functions that take a component and return a new component with additional behavior",
            "They are lifecycle methods available only in class components",
            "They automatically memoize wrapped components",
            "They can only be applied to DOM elements"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` with function-as-children pattern?",
        "o": [
            "Children can be functions, and the parent component can call them with arguments to render dynamic content",
            "Children must always be plain JSX elements",
            "Function-as-children only works with class components",
            "It prevents re-rendering of children automatically"
        ]
    },
    {
        "q": "Which of the following is true about `displayName` in React components?",
        "o": [
            "It is used to label components in debugging tools like React DevTools",
            "It forces React to memoize the component",
            "It is required for all functional components",
            "It automatically sets the name of props"
        ]
    },
    {
        "q": "Which of the following is true about JSX?",
        "o": [
            "It is syntactic sugar for `React.createElement` calls",
            "It is a separate templating language outside of JavaScript",
            "It must always compile to HTML directly",
            "It can only contain HTML-like tags"
        ]
    },
    {
        "q": "Which of the following is true about rendering `null` in a React component?",
        "o": [
            "It renders nothing and produces no DOM output",
            "It throws an error at runtime",
            "It is automatically converted to an empty string",
            "It unmounts the entire component tree"
        ]
    },
    {
        "q": "Which of the following is true about functional component return values?",
        "o": [
            "They must return either JSX, null, or a React element",
            "They must always return a single DOM node",
            "They cannot return fragments",
            "They must return strings or numbers"
        ]
    },
    {
        "q": "Which of the following is true about `prop drilling`?",
        "o": [
            "It happens when props are passed down through multiple layers of components unnecessarily",
            "It is a pattern to optimize performance by drilling props into state",
            "It refers to mutating props directly in child components",
            "It only occurs with class components"
        ]
    },
    {
        "q": "Which of the following is true about `React.PureComponent`?",
        "o": [
            "It implements a shallow comparison of props and state to avoid unnecessary re-renders",
            "It disables lifecycle methods",
            "It automatically memoizes children",
            "It forces deep equality checks for props"
        ]
    },
    {
        "q": "Which of the following is true about the `children` prop combined with `React.cloneElement`?",
        "o": [
            "You can enhance or modify the props of children before rendering them",
            "It automatically converts children into arrays",
            "It prevents children from having refs",
            "It only works if children are strings"
        ]
    },
    {
        "q": "Which of the following is true about `key` reuse in lists?",
        "o": [
            "Reusing keys incorrectly can cause React to reuse elements and lead to bugs in UI state",
            "Reusing keys is always safe because React recalculates the DOM",
            "Keys are automatically generated and cannot be reused",
            "Keys are required to be globally unique across the application"
        ]
    },
    {
        "q": "Which of the following is true about inline styles in React?",
        "o": [
            "They are written as objects with camelCased properties instead of strings",
            "They must be written as strings of CSS rules",
            "They only work with functional components",
            "They automatically add vendor prefixes"
        ]
    },
    {
        "q": "Which of the following is true about the `contextType` property in class components?",
        "o": [
            "It allows accessing a single context value directly via `this.context`",
            "It provides access to multiple contexts simultaneously",
            "It can only be used in functional components",
            "It automatically memoizes context values"
        ]
    },
    {
        "q": "Which of the following is true about `React.forwardRef` combined with `useImperativeHandle`?",
        "o": [
            "It lets you expose a custom API from a child component to its parent via refs",
            "It forces all child state to be exposed to the parent automatically",
            "It only works for DOM elements, not custom components",
            "It prevents props from being passed down"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` when multiple children are passed?",
        "o": [
            "They are received as an array-like object that can be traversed with React.Children utilities",
            "They are always a flat array of React elements",
            "They are automatically wrapped inside a fragment",
            "They can only contain primitive values"
        ]
    },
    {
        "q": "Which of the following is true about `render props` pattern?",
        "o": [
            "It involves passing a function as a prop that a component uses to determine what to render",
            "It is only valid inside class components",
            "It prevents re-rendering of children",
            "It forces all children to be wrapped in fragments"
        ]
    },
    {
        "q": "Which of the following is true about `key` props when rendering dynamic lists?",
        "o": [
            "Keys must be stable, predictable, and unique within their list to help React identify items",
            "Keys are passed down as normal props to children",
            "Keys must always be globally unique across the app",
            "Keys can only be numbers, not strings"
        ]
    },
    {
        "q": "Which of the following is true about `JSX expressions` inside curly braces?",
        "o": [
            "They can contain any valid JavaScript expression, such as variables, functions, or ternaries",
            "They can only contain strings and numbers",
            "They must always return DOM elements",
            "They cannot be used with conditional operators"
        ]
    },
    {
        "q": "Which of the following is true about `React.Fragment` shorthand syntax (`<>...</>`) ?",
        "o": [
            "It allows grouping children without adding extra DOM nodes",
            "It automatically adds a `<div>` wrapper",
            "It only works with a single child",
            "It prevents passing props to children"
        ]
    },
    {
        "q": "Which of the following is true about the difference between props and state?",
        "o": [
            "Props are passed from parent to child and are immutable, while state is managed within the component and can change",
            "Props and state are both mutable and interchangeable",
            "Props are only available in functional components, while state is only in class components",
            "Props automatically sync with state in child components"
        ]
    },
    {
        "q": "Which of the following is true about `defaultProps` in class components?",
        "o": [
            "They define fallback values for props if none are provided by the parent",
            "They override values even if a parent explicitly passes a prop",
            "They prevent the component from receiving children",
            "They can only be used with functional components"
        ]
    },
    {
        "q": "Which of the following is true about `React.cloneElement` compared to JSX spread attributes?",
        "o": [
            "cloneElement creates a new element with additional props while preserving existing ones, whereas JSX spread directly copies props",
            "cloneElement always replaces all props with new ones",
            "cloneElement works only with primitive children",
            "cloneElement removes keys from children automatically"
        ]
    },
    {
        "q": "Which of the following is true about inline event handlers in React?",
        "o": [
            "They are written in camelCase and passed as functions (e.g., `onClick={() => ...}`)",
            "They must always be lowercase (e.g., `onclick`)",
            "They must be strings like in plain HTML",
            "They can only be attached to native DOM elements, not custom components"
        ]
    },
    {
        "q": "Which of the following is true about `getDerivedStateFromProps` in class components?",
        "o": [
            "It is a static method that lets a component update its state based on changes in props",
            "It runs after every render and can access `this` directly",
            "It is only used for side effects like API calls",
            "It replaces the need for constructor initialization"
        ]
    },
    {
        "q": "Which of the following is true about `shouldComponentUpdate`?",
        "o": [
            "It allows you to control whether a component should re-render based on changes in props or state",
            "It forces a re-render regardless of props or state",
            "It only works with functional components",
            "It prevents state from updating when returning false"
        ]
    },
    {
        "q": "Which of the following is true about the `componentDidMount` lifecycle method?",
        "o": [
            "It is invoked immediately after a component is mounted and is often used for side effects like fetching data",
            "It runs before the first render",
            "It is only available in functional components via hooks",
            "It prevents child components from rendering"
        ]
    },
    {
        "q": "Which of the following is true about `componentWillUnmount`?",
        "o": [
            "It is called right before a component is removed from the DOM and is used for cleanup",
            "It is called before every re-render",
            "It is used to initialize state values",
            "It prevents unmounting if it returns false"
        ]
    },
    {
        "q": "Which of the following is true about controlled form inputs?",
        "o": [
            "Their value is controlled by React state and updated through onChange handlers",
            "Their value is managed directly by the DOM",
            "They do not support initial default values",
            "They are automatically memoized by React"
        ]
    },
    {
        "q": "Which of the following is true about uncontrolled form inputs?",
        "o": [
            "Their value is managed by the DOM and accessed using refs when needed",
            "They cannot have default values",
            "They must always sync with React state",
            "They automatically rerender when the DOM changes"
        ]
    },
    {
        "q": "Which of the following is true about `static propTypes` in class components?",
        "o": [
            "They are used to define runtime type checking for props in development mode",
            "They enforce compile-time type safety",
            "They prevent props from being optional",
            "They are required for all components"
        ]
    },
    {
        "q": "Which of the following is true about passing functions as children?",
        "o": [
            "It enables the render props pattern, where children can be a function that returns elements",
            "It automatically executes the function on every render and passes state as arguments",
            "It only works with class components",
            "It disables props.children when used"
        ]
    },
    {
        "q": "Which of the following is true about inline conditional rendering with ternary operators?",
        "o": [
            "They allow choosing between two JSX elements or values directly inside JSX",
            "They can only be used inside class methods",
            "They throw errors if used with fragments",
            "They are not valid inside curly braces in JSX"
        ]
    },
    {
        "q": "Which of the following is true about `React.Fragment` with keys?",
        "o": [
            "Fragments can accept a `key` prop when used inside lists for stable identity",
            "Fragments cannot accept any props at all",
            "Keys in fragments are automatically generated by React",
            "Fragments with keys automatically wrap children in divs"
        ]
    },
    {
        "q": "Which of the following is true about `React.memo` with a custom comparison function?",
        "o": [
            "It allows you to define custom logic to determine if a component should re-render",
            "It prevents all re-renders regardless of prop changes",
            "It only works with class components",
            "It forces deep equality checks by default"
        ]
    },
    {
        "q": "Which of the following is true about the `contextType` property in class components?",
        "o": [
            "It allows a class component to read a single context value directly via `this.context`",
            "It allows subscribing to multiple contexts simultaneously",
            "It automatically memoizes context values",
            "It replaces the need for Context.Provider"
        ]
    },
    {
        "q": "Which of the following is true about `React.forwardRef`?",
        "o": [
            "It allows passing refs from parent components down to child DOM elements or components",
            "It automatically creates new refs for children",
            "It can only be used with class components",
            "It replaces the need for keys in lists"
        ]
    },
    {
        "q": "Which of the following is true about static `defaultProps` in class components?",
        "o": [
            "They provide fallback values for props if none are supplied by the parent",
            "They override parent-supplied values",
            "They are required for every prop in a component",
            "They prevent the component from receiving children"
        ]
    },
    {
        "q": "Which of the following is true about `React.cloneElement`?",
        "o": [
            "It clones a React element and allows you to pass new props or override existing ones",
            "It creates a new independent copy of a component instance",
            "It automatically assigns unique keys to cloned elements",
            "It can only clone primitive values like strings and numbers"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` when no children are passed?",
        "o": [
            "It is undefined by default",
            "It is always an empty array",
            "It automatically defaults to null",
            "It throws a runtime error"
        ]
    },
    {
        "q": "Which of the following is true about `render props` compared to higher-order components (HOCs)?",
        "o": [
            "Render props use a function as a child, while HOCs wrap a component to add behavior",
            "Render props and HOCs are identical patterns",
            "Render props can only be used with class components",
            "HOCs require render props internally"
        ]
    },
    {
        "q": "Which of the following is true about returning multiple elements from a React component?",
        "o": [
            "They must be wrapped in a fragment or a parent element",
            "They can be returned directly without a wrapper",
            "They must always be arrays of strings",
            "They can only be used inside class components"
        ]
    },
    {
        "q": "Which of the following is true about the `displayName` property of React components?",
        "o": [
            "It is used to label components in debugging tools like React DevTools",
            "It forces React to cache component outputs",
            "It is required for all functional components",
            "It prevents components from receiving props"
        ]
    },
    {
        "q": "Which of the following is true about `propTypes`?",
        "o": [
            "They provide runtime type-checking for props in development mode",
            "They enforce compile-time type safety",
            "They are required in every React component",
            "They automatically generate default props"
        ]
    },
    {
        "q": "Which of the following is true about `constructor` in class components?",
        "o": [
            "It is typically used to initialize state and bind event handlers",
            "It must always call `super()` with props and state",
            "It automatically defines lifecycle methods",
            "It is required in every class component"
        ]
    },
    {
        "q": "Which of the following is true about `super(props)` in class component constructors?",
        "o": [
            "It makes `this.props` available inside the constructor",
            "It initializes state automatically from props",
            "It binds methods to the component automatically",
            "It is optional in every scenario"
        ]
    },
    {
        "q": "Which of the following is true about `componentDidUpdate`?",
        "o": [
            "It is invoked after the component updates and can be used to respond to prop or state changes",
            "It prevents re-rendering if state does not change",
            "It runs before the render method executes",
            "It can only be used in functional components"
        ]
    },
    {
        "q": "Which of the following is true about `getSnapshotBeforeUpdate`?",
        "o": [
            "It runs right before DOM updates and lets you capture information like scroll position",
            "It updates state values before render is called",
            "It prevents the component from unmounting",
            "It automatically reverts the DOM back to its previous state"
        ]
    },
    {
        "q": "Which of the following is true about `componentWillReceiveProps`?",
        "o": [
            "It is deprecated and replaced by `getDerivedStateFromProps`",
            "It is still recommended for syncing state with props",
            "It runs before props are initially set",
            "It can only be used with functional components"
        ]
    },
    {
        "q": "Which of the following is true about `static getDerivedStateFromError`?",
        "o": [
            "It allows class components to update state in response to errors thrown by descendants",
            "It catches errors in event handlers",
            "It prevents components from rendering children",
            "It automatically retries failed renders"
        ]
    },
    {
        "q": "Which of the following is true about `componentDidCatch`?",
        "o": [
            "It logs error information and is part of error boundaries",
            "It prevents errors from bubbling to the root of the app",
            "It replaces try-catch in event handlers",
            "It automatically restores the previous state"
        ]
    },
    {
        "q": "Which of the following is true about updating state in class components?",
        "o": [
            "State updates using `setState` are asynchronous and may be batched for performance",
            "Calling `this.state = ...` is the recommended way to update state",
            "setState immediately mutates `this.state` synchronously",
            "setState can only be called inside lifecycle methods"
        ]
    },
    {
        "q": "Which of the following is true about `static getDerivedStateFromProps`?",
        "o": [
            "It should return an object to update state or null to do nothing",
            "It can access `this` to read instance values",
            "It is triggered only during unmounting",
            "It can be used for side effects like API calls"
        ]
    },
    {
        "q": "Which of the following is true about `forceUpdate()` in class components?",
        "o": [
            "It forces a re-render of the component without changing the state",
            "It resets state values to their initial defaults",
            "It prevents children from rendering",
            "It is the preferred method to update state in modern React"
        ]
    },
    {
        "q": "Which of the following is true about passing JSX as `props.children`?",
        "o": [
            "Children can be any renderable element, including JSX, strings, numbers, or arrays",
            "Children must always be plain text",
            "Children cannot be arrays of elements",
            "Children automatically convert into strings before rendering"
        ]
    },
    {
        "q": "Which of the following is true about `key` in React lists?",
        "o": [
            "Keys help React identify which items have changed, are added, or are removed",
            "Keys are passed down to child components as regular props",
            "Keys must always be generated using array index",
            "Keys are optional in lists and don’t affect performance"
        ]
    },
    {
        "q": "Which of the following is true about `PureComponent` compared to `Component`?",
        "o": [
            "PureComponent implements a shallow comparison of props and state in `shouldComponentUpdate`",
            "PureComponent prevents all updates by default",
            "PureComponent can only be used in functional components",
            "PureComponent automatically deep compares objects"
        ]
    },
    {
        "q": "Which of the following is true about inline functions passed as props?",
        "o": [
            "They create a new function instance on every render and may affect performance if overused",
            "They are automatically memoized by React",
            "They are only valid for event handlers",
            "They prevent children from re-rendering"
        ]
    },
    {
        "q": "Which of the following is true about `this.props.children` when rendering nested JSX?",
        "o": [
            "It can represent deeply nested JSX trees passed between component tags",
            "It only represents direct text values",
            "It flattens children automatically into a single string",
            "It can only contain primitive values"
        ]
    },
    {
        "q": "Which of the following is true about using functions as children?",
        "o": [
            "They enable render prop patterns where the function decides what JSX to render",
            "They are executed only once during component mounting",
            "They cannot access parent props",
            "They are automatically memoized across renders"
        ]
    },
    {
        "q": "Which of the following is true about prop destructuring in functional components?",
        "o": [
            "It allows accessing specific props directly in function parameters",
            "It automatically assigns default values",
            "It prevents extra props from being accessed",
            "It is only valid in class components"
        ]
    },
    {
        "q": "Which of the following is true about passing components as props?",
        "o": [
            "You can pass a component type as a prop and render it dynamically inside another component",
            "You must always wrap components in fragments before passing them",
            "Only functional components can be passed as props",
            "It automatically converts class components to functions"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.only`?",
        "o": [
            "It verifies that a component has exactly one child and returns it",
            "It merges multiple children into a fragment",
            "It renders children without validation",
            "It converts children into an array automatically"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.map`?",
        "o": [
            "It works like Array.map but safely iterates over children regardless of their structure",
            "It only works when children are arrays",
            "It automatically assigns new keys to children",
            "It flattens nested fragments automatically"
        ]
    },
    {
        "q": "Which of the following is true about `defaultProps` in functional components?",
        "o": [
            "They can be defined by assigning a `defaultProps` property to the function object",
            "They are not supported in functional components at all",
            "They override explicitly passed props from the parent",
            "They are required for all props without defaults"
        ]
    },
    {
        "q": "Which of the following is true about `this.props` in class components?",
        "o": [
            "It provides read-only access to the props passed from a parent component",
            "It allows updating props directly inside the child",
            "It is undefined until componentDidMount",
            "It automatically merges with state when updated"
        ]
    },
    {
        "q": "Which of the following is true about `state` updates in class components?",
        "o": [
            "They may be batched and applied asynchronously for performance",
            "They are always applied immediately",
            "They can be mutated directly without using `setState`",
            "They always trigger a full app re-render"
        ]
    },
    {
        "q": "Which of the following is true about spreading props (`{...props}`) in JSX?",
        "o": [
            "It copies all key-value pairs from the props object into the child element",
            "It prevents passing children implicitly",
            "It forces React to ignore defaultProps",
            "It automatically validates props against propTypes"
        ]
    },
    {
        "q": "Which of the following is true about conditional rendering with `&&` operator in JSX?",
        "o": [
            "It renders the right-hand expression only if the left-hand expression evaluates to true",
            "It is invalid syntax inside JSX",
            "It must always return a string or number",
            "It renders `false` as a visible string when condition fails"
        ]
    },
    {
        "q": "Which of the following is true about string literals as children?",
        "o": [
            "They are rendered as text nodes directly inside the DOM element",
            "They must always be wrapped in curly braces",
            "They are automatically converted into arrays of characters",
            "They cannot be nested inside fragments"
        ]
    },
    {
        "q": "Which of the following is true about custom component names in JSX?",
        "o": [
            "They must start with an uppercase letter for React to treat them as components",
            "They can freely use lowercase names like HTML tags",
            "They must always match the file name",
            "They cannot be imported from other files"
        ]
    },
    {
        "q": "Which of the following is true about `null` returned from a React component?",
        "o": [
            "It means the component renders nothing but still participates in the lifecycle",
            "It throws an error and prevents rendering",
            "It is equivalent to rendering an empty string",
            "It forces React to unmount the parent component"
        ]
    },
    {
        "q": "Which of the following is true about passing booleans as props?",
        "o": [
            "Using only the prop name (e.g., `<Button disabled />`) sets the prop to true",
            "Boolean props must always be written explicitly as true or false",
            "They are automatically converted to strings",
            "They cannot be combined with other prop types"
        ]
    },
    {
        "q": "Which of the following is true about fragments with multiple children?",
        "o": [
            "They let you return multiple children without adding extra DOM elements",
            "They must always have a key prop",
            "They are only valid inside lists",
            "They automatically merge all child props"
        ]
    },
    {
        "q": "Which of the following is true about `prop drilling`?",
        "o": [
            "It refers to passing props through multiple levels of components even if intermediate components don’t need them",
            "It prevents parent components from sharing state",
            "It automatically syncs state across all children",
            "It only occurs in class components"
        ]
    },
    {
        "q": "Which of the following is true about `children` as a function in React?",
        "o": [
            "It enables dynamic rendering where children are functions that return elements",
            "It prevents children from receiving props",
            "It can only be used with lists of children",
            "It disables fragments when used"
        ]
    },
    {
        "q": "Which of the following is true about inline style props in React?",
        "o": [
            "They are written as objects with camelCase property names",
            "They accept standard CSS strings exactly as in HTML",
            "They must always be applied through className",
            "They are automatically scoped to the component"
        ]
    },
    {
        "q": "Which of the following is true about `propTypes.arrayOf`?",
        "o": [
            "It validates that a prop is an array of a specific type",
            "It ensures a prop is a generic array",
            "It prevents arrays of objects from being passed",
            "It automatically converts values to arrays"
        ]
    },
    {
        "q": "Which of the following is true about `React.Children.toArray`?",
        "o": [
            "It flattens children and adds keys if missing",
            "It converts children to plain strings",
            "It removes null values from children automatically",
            "It merges all children into a single fragment"
        ]
    },
    {
        "q": "Which of the following is true about `componentDidCatch` compared to `try...catch`?",
        "o": [
            "It catches errors during rendering, lifecycle methods, and constructors of child components",
            "It catches errors inside async functions",
            "It replaces the need for error boundaries",
            "It handles event handler exceptions automatically"
        ]
    },
    {
        "q": "Which of the following is true about `props` immutability?",
        "o": [
            "Props should never be modified inside a child component",
            "Props can be reassigned safely inside the component",
            "Props automatically merge with state when changed",
            "Props are mutable only in class components"
        ]
    },
    {
        "q": "Which of the following is true about `render()` method in class components?",
        "o": [
            "It must return React elements, fragments, strings, numbers, null, or booleans",
            "It can directly modify state values",
            "It can only return a single root element",
            "It executes only once during component mounting"
        ]
    },
    {
        "q": "Which of the following is true about functional components before hooks?",
        "o": [
            "They were stateless and could only accept props",
            "They could manage local state like class components",
            "They supported lifecycle methods directly",
            "They were considered legacy and unsupported"
        ]
    },
    {
        "q": "Which of the following is true about `props` vs `children`?",
        "o": [
            "Children are a special prop automatically passed to components, representing nested content",
            "Children always override other props when passed",
            "Children cannot be combined with other props",
            "Children must always be functions"
        ]
    },
    {
        "q": "Which of the following is true about `ref` forwarding?",
        "o": [
            "It allows a parent component to access a child’s DOM node or instance via `React.forwardRef`",
            "It automatically exposes all child props to the parent",
            "It only works with class components by default",
            "It prevents passing additional props to the child"
        ]
    },
    {
        "q": "Which of the following is true about inline conditional rendering with `null`?",
        "o": [
            "Returning `null` from a component or expression means rendering nothing without causing errors",
            "It throws an error because React does not support `null` return values",
            "It forces React to unmount the entire parent tree",
            "It automatically defaults to rendering an empty div"
        ]
    },
    {
        "q": "Which of the following is true about `this.setState` with a function argument?",
        "o": [
            "It ensures state updates are based on the most recent state and props",
            "It immediately mutates state synchronously",
            "It bypasses the component lifecycle methods",
            "It prevents batching of multiple updates"
        ]
    },
    {
        "q": "Which of the following is true about `props.children` type?",
        "o": [
            "It can be a single element, multiple elements, a string, a number, null, or a function",
            "It must always be an array",
            "It must always be a string or text",
            "It automatically defaults to an empty array if not provided"
        ]
    },
    {
        "q": "Which of the following is true about `key` usage with fragments?",
        "o": [
            "Fragments can have keys when returned inside a list",
            "Fragments never accept keys",
            "Keys are irrelevant for fragments since they don’t render DOM nodes",
            "Keys in fragments automatically propagate to child elements"
        ]
    },
    {
        "q": "Which of the following is true about `static contextType` in class components?",
        "o": [
            "It allows consuming a single context value using `this.context`",
            "It automatically subscribes to all available contexts",
            "It enables context consumption only in lifecycle methods",
            "It replaces the need for Context.Provider"
        ]
    },
    {
        "q": "Which of the following is true about function components returning arrays?",
        "o": [
            "They can return arrays of elements directly if each child has a key",
            "They must always wrap elements in a fragment or div",
            "They throw errors unless wrapped in JSX tags",
            "They automatically merge elements into a fragment"
        ]
    },
    {
        "q": "Which of the following is true about `props` default values in destructuring?",
        "o": [
            "Default values can be assigned directly in the destructuring pattern of functional component arguments",
            "Default values must always be defined with `defaultProps`",
            "Default values only work in class components",
            "Default values prevent propTypes validation"
        ]
    },
    {
        "q": "Which of the following is true about `React.PureComponent` shallow comparison?",
        "o": [
            "It only does a shallow comparison of props and state to decide re-rendering",
            "It performs a deep comparison of nested objects automatically",
            "It disables shouldComponentUpdate completely",
            "It makes state updates synchronous"
        ]
    },
    {
        "q": "Which of the following is true about boolean props in JSX?",
        "o": [
            "Writing `<Button disabled />` sets `disabled` to true, while omitting it makes it undefined",
            "Boolean props must always be written explicitly like `disabled={true}`",
            "Boolean props are converted into string literals internally",
            "Boolean props are not supported in JSX"
        ]
    }
]