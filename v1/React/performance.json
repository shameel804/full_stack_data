[
    {
        "q": "What is the primary cause of performance issues in React?",
        "type": "mcq",
        "o": [
            "Unnecessary re-renders",
            "Using too many hooks",
            "Using CSS-in-JS",
            "Using Typescript"
        ]
    },
    {
        "q": "What does `React.memo` do?",
        "type": "mcq",
        "o": [
            "Memoizes a component, preventing re-renders if props haven't changed",
            "Memoizes state",
            "Memoizes functions",
            "Memoizes context"
        ]
    },
    {
        "q": "What is the default comparison in `React.memo`?",
        "type": "mcq",
        "o": [
            "Shallow comparison of props",
            "Deep comparison",
            "Reference check only",
            "No comparison"
        ]
    },
    {
        "q": "When does a child component re-render by default?",
        "type": "mcq",
        "o": [
            "Whenever its parent re-renders",
            "Only when props change",
            "Only when state changes",
            "Never"
        ]
    },
    {
        "q": "What is the `key` prop used for in lists?",
        "type": "mcq",
        "o": [
            "To identify which items have changed, are added, or are removed (reconciliation)",
            "Style hook",
            "Access control",
            "Sorting"
        ]
    },
    {
        "q": "Why is using index as `key` discouraged?",
        "type": "mcq",
        "o": [
            "It can cause issues with component state and performance if list order changes",
            "It throws error",
            "It is slow",
            "It is invalid HTML"
        ]
    },
    {
        "q": "What does `useMemo` do?",
        "type": "mcq",
        "o": [
            "Memoizes a value so it is only recomputed when dependencies change",
            "Memoizes component",
            "Memoizes function",
            "Memoizes style"
        ]
    },
    {
        "q": "What does `useCallback` do?",
        "type": "mcq",
        "o": [
            "Memoizes a callback function definition to maintain stable reference",
            "Calls back immediately",
            "Run async",
            "Runs on mount"
        ]
    },
    {
        "q": "When should you use `useMemo`?",
        "type": "mcq",
        "o": [
            "For expensive calculations or referential equality stability",
            "Always",
            "Never",
            "For primitives"
        ]
    },
    {
        "q": "Does `useCallback(fn, deps)` equal `useMemo(() => fn, deps)`?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Sometimes",
            "Only in Class components"
        ]
    },
    {
        "q": "What is Code Splitting?",
        "type": "mcq",
        "o": [
            "Splitting code into smaller bundles to be loaded on demand",
            "Deleting code",
            "Formatting code",
            "Linting code"
        ]
    },
    {
        "q": "How to implement Code Splitting in React?",
        "type": "mcq",
        "o": [
            "Using `React.lazy` and dynamic imports `import()`",
            "Using split()",
            "Using slice()",
            "Using Lodash"
        ]
    },
    {
        "q": "What component is required to wrap `React.lazy` components?",
        "type": "mcq",
        "o": [
            "`Suspense`",
            "`Fragment`",
            "`StrictMode`",
            "`Provider`"
        ]
    },
    {
        "q": "What does `Suspense` fallback prop do?",
        "type": "mcq",
        "o": [
            "Shows loading indicator while lazy component or data is loading",
            "Shows error",
            "Shows nothing",
            "Shows previous screen"
        ]
    },
    {
        "q": "What is `Virtualization` (Windowing)?",
        "type": "mcq",
        "o": [
            "Rendering only the items currently visible in the viewport",
            "Running in VM",
            "VR Mode",
            "Server rendering"
        ]
    },
    {
        "q": "Popular library for virtualization?",
        "type": "mcq",
        "o": [
            "`react-window` or `react-virtualized`",
            "`react-scroll`",
            "`react-list`",
            "`react-vr`"
        ]
    },
    {
        "q": "Does defining a component inside another component affect performance?",
        "type": "mcq",
        "o": [
            "Yes, it creates a new component type on every render, causing full unmount/remount of child",
            "No",
            "Improves it",
            "Neutral"
        ]
    },
    {
        "q": "What is `React.Profiler`?",
        "type": "mcq",
        "o": [
            "Component to measure rendering performance of React tree",
            "Terminal tool",
            "Browser extension only",
            "Linter"
        ]
    },
    {
        "q": "What implies 'lifting state up' for performance?",
        "type": "mcq",
        "o": [
            "Sometimes implies *pushing state down* is better to isolate re-renders. Lifting is for sharing.",
            "Always better",
            "Always worse",
            "Neutral"
        ]
    },
    {
        "q": "Does passing object literals as props cause re-renders?",
        "type": "mcq",
        "o": [
            "Yes, if the child is memoized (breaks shallow equality), otherwise child re-renders anyway",
            "No",
            "Always crashes",
            "Never"
        ]
    },
    {
        "q": "Does passing inline functions as props cause re-renders?",
        "type": "mcq",
        "o": [
            "Yes, new reference every time. Breaks `React.memo` optimization on child.",
            "No",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'Throttling'?",
        "type": "mcq",
        "o": [
            "Limiting rate of function execution to once per time interval",
            "Delaying until stop",
            "Speeding up",
            "Stopping"
        ]
    },
    {
        "q": "What is 'Debouncing'?",
        "type": "mcq",
        "o": [
            "Delaying execution until a pause in events (e.g. typing stops)",
            "Limiting rate",
            "Running immediately",
            "Running twice"
        ]
    },
    {
        "q": "Which is better for search input: Throttle or Debounce?",
        "type": "mcq",
        "o": [
            "Debounce (wait for user to stop typing)",
            "Throttle",
            "Neither",
            "Both"
        ]
    },
    {
        "q": "Which is better for scroll listener: Throttle or Debounce?",
        "type": "mcq",
        "o": [
            "Throttle (update regularly e.g. every 100ms)",
            "Debounce",
            "Neither",
            "Raw"
        ]
    },
    {
        "q": "What implies `production` build?",
        "type": "mcq",
        "o": [
            "Minified code, stripped dev warnings, optimized react build",
            "Debug mode",
            "Test mode",
            "Slow mode"
        ]
    },
    {
        "q": "Does `console.log` affect performance?",
        "type": "mcq",
        "o": [
            "Yes, especially if logging heavy objects or high frequency. Should be removed in prod.",
            "No",
            "Minimal",
            "Speeds up"
        ]
    },
    {
        "q": "What is rendering 'waterfall'?",
        "type": "mcq",
        "o": [
            "Sequence of data fetches where one waits for another (e.g. Parent fetch -> Child render -> Child fetch)",
            "CSS effect",
            "Fluid layout",
            "Streaming"
        ]
    },
    {
        "q": "How to avoid waterfall?",
        "type": "mcq",
        "o": [
            "Parallel fetching (Promise.all) or fetching early (layout loader)",
            "Use timeout",
            "Use cascade",
            "Use grid"
        ]
    },
    {
        "q": "What is 'Layout Thrashing'?",
        "type": "mcq",
        "o": [
            "Repeatedly reading and writing DOM properties (read-write cycle) forcing browser to recalculate layout often",
            "CSS animation",
            "Js error",
            "Network lag"
        ]
    },
    {
        "q": "Is reading `offsetWidth` expensive?",
        "type": "mcq",
        "o": [
            "Yes, it forces a synchronous layout (reflow)",
            "No",
            "Only on mobile",
            "Only on desktop"
        ]
    },
    {
        "q": "How to optimize large images?",
        "type": "mcq",
        "o": [
            "Lazy load, use modern formats (WebP), responsive sizes (srcset)",
            "Use PNG",
            "Use BMP",
            "Preload all"
        ]
    },
    {
        "q": "What is CLS (Cumulative Layout Shift)?",
        "type": "mcq",
        "o": [
            "Metric measuring visual stability (unexpected movement of page content)",
            "Clear Screen",
            "Console Log",
            "CSS Logic"
        ]
    },
    {
        "q": "Does defining `styles` object inside render affect performance?",
        "type": "mcq",
        "o": [
            "Yes, new object reference every render. Can break pure component checks.",
            "No",
            "Maybe",
            "It is optimized"
        ]
    },
    {
        "q": "What is `PureComponent`?",
        "type": "mcq",
        "o": [
            "Class component that implements `shouldComponentUpdate` with shallow prop/state comparison",
            "Function component",
            "HOC",
            "Hook"
        ]
    },
    {
        "q": "Function equivalent of `PureComponent`?",
        "type": "mcq",
        "o": [
            "`React.memo`",
            "`useMemo`",
            "`useCallback`",
            "`useEffect`"
        ]
    },
    {
        "q": "Does context update cause all consumers to re-render?",
        "type": "mcq",
        "o": [
            "Yes, unless optimized (splitting context, memoizing value)",
            "No",
            "Only direct children",
            "Only leaf nodes"
        ]
    },
    {
        "q": "Best practice for Context value?",
        "type": "mcq",
        "o": [
            "Memoize the value object: `useMemo(() => ({ a, b }), [a, b])`",
            "Create inline",
            "Use state directly",
            "Use reducer"
        ]
    },
    {
        "q": "What is 'Keep Alive' in React?",
        "type": "mcq",
        "o": [
            "Caching component state when unmounted (not native yet, often emulated)",
            "HTTP Header",
            "Socket",
            "Ping"
        ]
    },
    {
        "q": "Does strict mode run renders twice?",
        "type": "mcq",
        "o": [
            "Yes, in development to detect side effects",
            "No",
            "In production too",
            "Only for classes"
        ]
    },
    {
        "q": "Is double invoke in Strict Mode performance issue?",
        "type": "mcq",
        "o": [
            "No, dev only. Does not happen in production.",
            "Yes",
            "Huge issue",
            "Memory leak"
        ]
    },
    {
        "q": "What is `lazy` initial state?",
        "type": "mcq",
        "o": [
            "Passing function to `useState(() => expensiveComputation())` runs only on mount",
            "Lazy loading",
            "Deferred value",
            "Slow state"
        ]
    },
    {
        "q": "If you pass `expensiveComputation()` directly to `useState`?",
        "type": "mcq",
        "o": [
            "It runs on every render (result ignored after first, but cost paid)",
            "It runs once",
            "It never runs",
            "It errors"
        ]
    },
    {
        "q": "What is a major performance benefit of Service Workers?",
        "type": "mcq",
        "o": [
            "Caching assets and API responses for offline/fast load",
            "Running heavy logic",
            "Accessing DOM",
            "Animation"
        ]
    },
    {
        "q": "What is Preloading?",
        "type": "mcq",
        "o": [
            "Loading resources (like fonts, scripts) before they are discovered by parser",
            "Loading after render",
            "Lazy loading",
            "Code splitting"
        ]
    },
    {
        "q": "What is Prefetching?",
        "type": "mcq",
        "o": [
            "Loading resources for *next* navigation/action (lower priority)",
            "High priority",
            "Blocking",
            "Sync"
        ]
    },
    {
        "q": "Can `refs` improve performance?",
        "type": "mcq",
        "o": [
            "Yes, by avoiding state updates for uncontrolled inputs or imperative animations",
            "No",
            "Always",
            "Never"
        ]
    },
    {
        "q": "What is 'Jank'?",
        "type": "mcq",
        "o": [
            "Stuttering or non-smooth animation (dropped frames)",
            "Fast animation",
            "Smooth scroll",
            "Blur"
        ]
    },
    {
        "q": "Ideal frame rate?",
        "type": "mcq",
        "o": [
            "60fps (16.6ms per frame)",
            "30fps",
            "100fps",
            "10fps"
        ]
    },
    {
        "q": "What causes dropped frames?",
        "type": "mcq",
        "o": [
            "Main thread blocked by long JS execution tasks (>16ms)",
            "Network wait",
            "Idle time",
            "CSS"
        ]
    },
    {
        "q": "What is Web Worker?",
        "type": "mcq",
        "o": [
            "Background thread to run JS off main thread",
            "Service Worker",
            "Worklet",
            "Lambda"
        ]
    },
    {
        "q": "Can Web Workers access DOM?",
        "type": "mcq",
        "o": [
            "No",
            "Yes",
            "Partially",
            "Yes via Ref"
        ]
    },
    {
        "q": "What is `requestAnimationFrame`?",
        "type": "mcq",
        "o": [
            "API to schedule function before next repaint",
            "timeout",
            "interval",
            "promise"
        ]
    },
    {
        "q": "Why use `requestAnimationFrame` for animation?",
        "type": "mcq",
        "o": [
            "Syncs with browser refresh rate, saves battery when hidden, prevents layout thrashing",
            "Faster than light",
            "Simpler syntax",
            "Works in background"
        ]
    },
    {
        "q": "Is `setTimeout` accurate for animation?",
        "type": "mcq",
        "o": [
            "No, prone to drift and jitter",
            "Yes",
            "Usually",
            "Perfect"
        ]
    },
    {
        "q": "What is 'Tree Shaking'?",
        "type": "mcq",
        "o": [
            "Removing unused code (dead code elimination) during build",
            "shaking DOM",
            "shaking state",
            "moving files"
        ]
    },
    {
        "q": "What enables Tree Shaking?",
        "type": "mcq",
        "o": [
            "ES Modules (static import/export structure) and tools like Webpack/Rollup",
            "CommonJS",
            "AMD",
            "IIFE"
        ]
    },
    {
        "q": "Does `CommonJS` tree shake well?",
        "type": "mcq",
        "o": [
            "Generally no, dynamic nature makes it hard",
            "Yes",
            "Perfectly",
            "Better than ESM"
        ]
    },
    {
        "q": "What is `dynamic` import?",
        "type": "mcq",
        "o": [
            "`import('./module')` returning promise",
            "`require`",
            "`include`",
            "`fetch`"
        ]
    },
    {
        "q": "What does `Bundle Analyzer` do?",
        "type": "mcq",
        "o": [
            "Visualizes size of output files and their dependencies",
            "Analyzes code quality",
            "Analyzes speed",
            "Analyzes SEO"
        ]
    },
    {
        "q": "Why avoid large libraries like full `lodash`?",
        "type": "mcq",
        "o": [
            "Increases bundle size unnecessarily. Import specific methods `lodash/debounce`.",
            "Security risk",
            "Slow execution",
            "Deprecated"
        ]
    },
    {
        "q": "What is 'Code Blooming'?",
        "type": "mcq",
        "o": [
            "Unintentional bundle size increase (made up term, usually 'Bloat')",
            "Flower power",
            "Color syntax",
            "Nice code"
        ]
    },
    {
        "q": "Does `className` vs `style` prop matter for perf?",
        "type": "mcq",
        "o": [
            "`className` (CSS classes) generally faster/better optimized than inline styles",
            "Style is faster",
            "Same",
            "CSS is slow"
        ]
    },
    {
        "q": "What is 'CSS containment'?",
        "type": "mcq",
        "o": [
            "`contain` property to isolate subtree layout/paint for performance",
            "Container query",
            "Box model",
            "Flexbox"
        ]
    },
    {
        "q": "What is `will-change` property?",
        "type": "mcq",
        "o": [
            "Hint to browser to optimize for expected changes (create new layer)",
            "Forces change",
            "Prevents change",
            "Animation"
        ]
    },
    {
        "q": "Should `will-change` be used everywhere?",
        "type": "mcq",
        "o": [
            "No, consumes memory/GPU. Use sparingly.",
            "Yes",
            "On all divs",
            "On all images"
        ]
    },
    {
        "q": "What is 'Composite' layer?",
        "type": "mcq",
        "o": [
            "GPU-accelerated layer. Transforming it is cheap (no layout/paint).",
            "DOM layer",
            "Logic layer",
            "Network layer"
        ]
    },
    {
        "q": "Which properties trigger only Composite?",
        "type": "mcq",
        "o": [
            "`transform`, `opacity`",
            "`width`, `height`",
            "`margin`, `padding`",
            "`color`, `background`"
        ]
    },
    {
        "q": "Does `display: none` render contents?",
        "type": "mcq",
        "o": [
            "It is in DOM but not in Render Tree. Not painted.",
            "Rendered fully",
            "Removed from DOM",
            "Visible"
        ]
    },
    {
        "q": "Does `visibility: hidden` affect layout?",
        "type": "mcq",
        "o": [
            "Yes, takes up space.",
            "No",
            "Removes from DOM",
            "Stops script"
        ]
    },
    {
        "q": "What is `IntersectionObserver` used for?",
        "type": "mcq",
        "o": [
            "Detecting visibility of element (scrolling into view). Better than scroll listener.",
            "Click detection",
            "Hover detection",
            "Mouse detection"
        ]
    },
    {
        "q": "What is `ResizeObserver`?",
        "type": "mcq",
        "o": [
            "Detects element size changes",
            "Window resize",
            "Image resize",
            "Font resize"
        ]
    },
    {
        "q": "What is 'Initial Load Time'?",
        "type": "mcq",
        "o": [
            "Time until TTI (Time to Interactive) or FCP (First Contentful Paint)",
            "Time to download",
            "Time to shut down",
            "Time to compile"
        ]
    },
    {
        "q": "What is SSR benefits for perf?",
        "type": "mcq",
        "o": [
            "Faster FCP (content visible sooner) and SEO. TTI might lag behind.",
            "Faster TTI",
            "No JS needed",
            "Smaller bundle"
        ]
    },
    {
        "q": "What is 'Hydration'?",
        "type": "mcq",
        "o": [
            "Attaching event listeners to server-rendered HTML to make it interactive",
            "Drinking water",
            "Downloading HTML",
            "Styling"
        ]
    },
    {
        "q": "Is Hydration expensive?",
        "type": "mcq",
        "o": [
            "Yes, requires re-running component logic on client",
            "No, free",
            "Instant",
            "Skipped"
        ]
    },
    {
        "q": "What is 'Selective Hydration' (React 18)?",
        "type": "mcq",
        "o": [
            "Hydrating parts of the tree based on interaction priority rather than all at once",
            "Hydrate only images",
            "Hydrate only text",
            "Watering plants"
        ]
    },
    {
        "q": "What is `useTransition`?",
        "type": "mcq",
        "o": [
            "Hook to mark state updates as non-blocking (transitions), keeping UI responsive",
            "Animation hook",
            "CSS transition",
            "Router transition"
        ]
    },
    {
        "q": "What is `startTransition`?",
        "type": "mcq",
        "o": [
            "Function to wrap low-priority updates",
            "Start app",
            "Start timer",
            "Start server"
        ]
    },
    {
        "q": "Difference between `useDeferredValue` and `debounce`?",
        "type": "mcq",
        "o": [
            "DeferredValue works with React's scheduling (interruptible rendering), debounce just delays",
            "Same",
            "Deferred is slower",
            "Debounce is native"
        ]
    },
    {
        "q": "What is `Lighthouse`?",
        "type": "mcq",
        "o": [
            "Tool to audit web apps performance, accessibility, SEO",
            "Database",
            "Server",
            "Framework"
        ]
    },
    {
        "q": "What is `FCP`?",
        "type": "mcq",
        "o": [
            "First Contentful Paint (first DOM content rendered)",
            "First Click",
            "Fast Caching",
            "Full Paint"
        ]
    },
    {
        "q": "What is `LCP`?",
        "type": "mcq",
        "o": [
            "Largest Contentful Paint (loading performance of main content)",
            "Last Paint",
            "Least Paint",
            "Long Paint"
        ]
    },
    {
        "q": "What is `FID` (or `INP`)?",
        "type": "mcq",
        "o": [
            "First Input Delay / Interaction to Next Paint (responsiveness metrics)",
            "Input data",
            "ID",
            "Find ID"
        ]
    },
    {
        "q": "What is `gzip`/`brotli`?",
        "type": "mcq",
        "o": [
            "Compression algorithms to reduce transfer size of assets",
            "Images",
            "CSS",
            "JS"
        ]
    },
    {
        "q": "What is CDN?",
        "type": "mcq",
        "o": [
            "Content Delivery Network (distributing assets closer to user)",
            "Code Network",
            "Central Data",
            "Create Domain"
        ]
    },
    {
        "q": "Why HTTP/2 matters for perf?",
        "type": "mcq",
        "o": [
            "Multiplexing (multiple requests over single connection), header compression",
            "Slower",
            "Less secure",
            "One request only"
        ]
    },
    {
        "q": "What is `React.Fragment` perf benefit?",
        "type": "mcq",
        "o": [
            "Avoids extra DOM node wrapping (div soup)",
            "None",
            "Smaller code",
            "Faster state"
        ]
    },
    {
        "q": "Does `key` prop work on Fragments?",
        "type": "mcq",
        "o": [
            "Yes, `<React.Fragment key={...}>` (not shorthand `<>`)",
            "No",
            "Automatic",
            "Never needed"
        ]
    },
    {
        "q": "What is 'Overscan' in virtualization?",
        "type": "mcq",
        "o": [
            "Rendering a few extra items outside viewport to prevent blank space during fast scroll",
            "Scanning QR",
            "Looking hard",
            "Zooming"
        ]
    },
    {
        "q": "What is 'Memoization' generally?",
        "type": "mcq",
        "o": [
            "Caching result of expensive function calls based on arguments",
            "Memory loss",
            "Writing memos",
            "Recording"
        ]
    },
    {
        "q": "Cost of `useMemo`?",
        "type": "mcq",
        "o": [
            "Memory overhead and comparison cost. Don't use for cheap calcs.",
            "Free",
            "None",
            "High CPU only"
        ]
    },
    {
        "q": "What is `React.StrictMode` double render?",
        "type": "mcq",
        "o": [
            "Intentional stress test to finding impure render logic",
            "Bug",
            "Error",
            "Warning"
        ]
    },
    {
        "q": "What is 'Tearing' in React 18?",
        "type": "mcq",
        "o": [
            "Inconsistent UI state during concurrent render",
            "Ripping paper",
            "Crying",
            "Breaking DOM"
        ]
    },
    {
        "q": "Is `setState` synchronous or asynchronous?",
        "type": "mcq",
        "o": [
            "Asynchronous (batched) generally",
            "Sync always",
            "Async only in promise",
            "Sync in timeout"
        ]
    },
    {
        "q": "Why is `setState` async?",
        "type": "mcq",
        "o": [
            "Performance (batching updates)",
            "Bug",
            "Legacy",
            "Accident"
        ]
    },
    {
        "q": "How to debounce a handler in function component?",
        "type": "mcq",
        "o": [
            "Use `useCallback(debounce(fn), [])` (stable ref)",
            "Just debounce(fn)",
            "Inside render",
            "As prop"
        ]
    },
    {
        "q": "What happens if you debounce inside render without memo?",
        "type": "mcq",
        "o": [
            "New debounced function created every render, clearing timer. Debounce won't work.",
            "Works fine",
            "Throws error",
            "Is faster"
        ]
    },
    {
        "q": "What is 'Image Sprint'?",
        "type": "mcq",
        "o": [
            "Optimizing image delivery",
            "CSS Sprite (combining images to reduce requests)",
            "Fast image",
            "Running"
        ]
    }
]