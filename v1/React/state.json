[
    {
        "q": "Which hook is used to add state to a functional component in React?",
        "o": [
            "useState",
            "useEffect",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the correct way to declare a state variable called 'count' with initial value 0?",
        "c": "const [count, setCount] = ____",
        "o": [
            "useState(0)",
            "useState()",
            "useEffect(0)",
            "React.state(0)"
        ]
    },
    {
        "q": "Which of the following is true about React props?",
        "o": [
            "Props are read-only",
            "Props can be directly modified",
            "Props are mutable",
            "Props replace state"
        ]
    },
    {
        "q": "What will happen when setState is called multiple times synchronously in a class component?",
        "o": [
            "React may batch updates for performance",
            "Each call updates the state immediately",
            "It always triggers re-render immediately for each call",
            "It ignores all updates except the last one"
        ]
    },
    {
        "q": "Which lifecycle method is called after a component is first rendered?",
        "o": [
            "componentDidMount",
            "componentWillUnmount",
            "componentDidUpdate",
            "render"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isVisible, setIsVisible] = useState(false);\nreturn (\n  <div>\n    {isVisible && <p>Hello World</p>}\n  </div>\n);",
        "o": [
            "Nothing is rendered",
            "Hello World",
            "Error: Invalid JSX",
            "Undefined"
        ]
    },
    {
        "q": "Which of the following best describes conditional rendering in React?",
        "o": [
            "Rendering UI based on certain conditions",
            "Rendering multiple components at once",
            "Rendering only class components",
            "Using if statements outside components"
        ]
    },
    {
        "q": "What is the correct way to pass a prop named 'title' to a component?",
        "o": [
            "<MyComponent title=\"Hello\" />",
            "<MyComponent {title} />",
            "<MyComponent props.title=\"Hello\" />",
            "<MyComponent>title=\"Hello\"</MyComponent>"
        ]
    },
    {
        "q": "Which hook would you use for running side effects like data fetching?",
        "o": [
            "useEffect",
            "useState",
            "useReducer",
            "useMemo"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count}</p>;\n}",
        "o": [
            "0",
            "undefined",
            "count",
            "null"
        ]
    },
    {
        "q": "Which of the following correctly updates state based on the previous value?",
        "c": "setCount(____);",
        "o": [
            "prev => prev + 1",
            "count + 1",
            "this.state.count + 1",
            "increment(count)"
        ]
    },
    {
        "q": "Which lifecycle method is used for cleanup tasks like removing event listeners?",
        "o": [
            "componentWillUnmount",
            "componentDidMount",
            "componentDidUpdate",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "What is the correct way to provide a default value for props in a functional component?",
        "o": [
            "MyComponent.defaultProps = { title: 'Default' }",
            "props.title = 'Default'",
            "useState('Default')",
            "setDefaultProps({ title: 'Default' })"
        ]
    },
    {
        "q": "In React, why is state considered immutable?",
        "o": [
            "Because it should never be modified directly",
            "Because JavaScript prevents reassignment",
            "Because React automatically freezes objects",
            "Because props and state are the same"
        ]
    },
    {
        "q": "What will be displayed on screen?",
        "c": "function Message({ text }) {\n  return <h1>{text || 'Hello React'}</h1>;\n}\n<Message text=\"\" />",
        "o": [
            "Hello React",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook is the equivalent of componentDidMount, componentDidUpdate, and componentWillUnmount combined?",
        "o": [
            "useEffect",
            "useState",
            "useRef",
            "useMemo"
        ]
    },
    {
        "q": "What will be rendered?",
        "c": "function App() {\n  const [show, setShow] = useState(true);\n  return (\n    <div>\n      {show ? <p>Visible</p> : <p>Hidden</p>}\n    </div>\n  );\n}",
        "o": [
            "Visible",
            "Hidden",
            "Nothing",
            "Error"
        ]
    },
    {
        "q": "Which of the following is NOT a valid way to conditionally render content in React?",
        "o": [
            "Using switch statements directly inside JSX",
            "Using ternary operators",
            "Using logical AND (&&)",
            "Using if statements outside JSX"
        ]
    },
    {
        "q": "What is the correct way to update state when it depends on the previous state?",
        "o": [
            "setCount(prev => prev + 1)",
            "setCount(count + 1)",
            "count++",
            "this.count = this.count + 1"
        ]
    },
    {
        "q": "Which lifecycle method is invoked immediately after a component is updated?",
        "o": [
            "componentDidUpdate",
            "componentDidMount",
            "componentWillUnmount",
            "render"
        ]
    },
    {
        "q": "Which of the following is the correct way to pass a function as a prop?",
        "o": [
            "<Child onClick={handleClick} />",
            "<Child onClick='handleClick' />",
            "<Child onClick=handleClick()>",
            "<Child onClick={{handleClick}} />"
        ]
    },
    {
        "q": "What is the main difference between state and props?",
        "o": [
            "State is managed inside a component, while props are passed from parent",
            "Props can change over time, but state cannot",
            "State is read-only, but props are mutable",
            "Props and state are exactly the same"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [count, setCount] = useState(5);\n  return <h2>{count > 3 ? 'High' : 'Low'}</h2>;\n}",
        "o": [
            "High",
            "Low",
            "5",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about setState in class components?",
        "o": [
            "It is asynchronous and may batch multiple updates",
            "It always updates the state immediately",
            "It blocks rendering until completed",
            "It can only be called inside lifecycle methods"
        ]
    },
    {
        "q": "Which hook would you use to store a value that persists between renders but does not trigger re-renders?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will be displayed on screen?",
        "c": "function Greeting({ name }) {\n  return <p>Hello, {name}</p>;\n}\n<Greeting />",
        "o": [
            "Hello, undefined",
            "Hello, null",
            "Hello,",
            "Error"
        ]
    },
    {
        "q": "Which lifecycle method is the best place for AJAX calls in a class component?",
        "o": [
            "componentDidMount",
            "componentWillUnmount",
            "constructor",
            "render"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const [count, setCount] = useState(0);\nsetCount(count + 1);\nsetCount(count + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is NOT true about props?",
        "o": [
            "Props can be modified by child components",
            "Props are read-only",
            "Props allow data to flow from parent to child",
            "Props can be objects or functions"
        ]
    },
    {
        "q": "What is the correct way to perform conditional rendering with a variable?",
        "c": "const isLoggedIn = true;\nreturn (\n  <div>\n    {____ && <p>Welcome</p>}\n  </div>\n);",
        "o": [
            "isLoggedIn",
            "!isLoggedIn",
            "false",
            "null"
        ]
    },
    {
        "q": "Which hook is used to optimize expensive calculations by memoizing results?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useReducer"
        ]
    },
    {
        "q": "What is the correct way to lift state up in React?",
        "o": [
            "Move the state to the nearest common ancestor and pass it down via props",
            "Duplicate state in both child components",
            "Use local storage to share state between components",
            "Update props directly in child components"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle() {\n  const [on, setOn] = useState(false);\n  return <p>{on ? 'ON' : 'OFF'}</p>;\n}",
        "o": [
            "OFF",
            "ON",
            "true",
            "Error"
        ]
    },
    {
        "q": "Which lifecycle method is used to compare new props with old props before updating?",
        "o": [
            "shouldComponentUpdate",
            "componentDidUpdate",
            "componentWillUnmount",
            "componentDidMount"
        ]
    },
    {
        "q": "What is the correct way to provide a fallback UI when state indicates an error?",
        "o": [
            "{hasError ? <Error /> : <App />}",
            "{if(hasError) <Error /> else <App />}",
            "{<Error /> || <App />}",
            "{showError: <Error />, showApp: <App />}"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [count, setCount] = useState(1);\n  return <h1>{count * 2}</h1>;\n}",
        "o": [
            "2",
            "1",
            "count * 2",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is NOT a characteristic of state?",
        "o": [
            "State is passed down like props",
            "State is local to the component",
            "State changes can trigger re-renders",
            "State is mutable only through setState or updater functions"
        ]
    },
    {
        "q": "Which hook would you use to handle component lifecycle in a functional component?",
        "o": [
            "useEffect",
            "useState",
            "useReducer",
            "useRef"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [value, setValue] = useState('Hi');\nsetValue('Hello');\nconsole.log(value);",
        "o": [
            "Hi",
            "Hello",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which of the following best describes unidirectional data flow in React?",
        "o": [
            "Data flows from parent to child via props",
            "Data flows from child to parent via props",
            "Data flows in both directions between components",
            "Data flows only within the same component"
        ]
    },
    {
        "q": "Which of the following is the correct way to initialize multiple state variables?",
        "c": "function App() {\n  const [name, setName] = useState('');\n  const [age, setAge] = useState(0);\n  return <p>{name} - {age}</p>;\n}",
        "o": [
            "Using separate useState calls",
            "Using one useState with two arguments",
            "Using setState({name, age})",
            "Using useEffect for both"
        ]
    },
    {
        "q": "Which lifecycle method is called right before a component is removed from the DOM?",
        "o": [
            "componentWillUnmount",
            "componentDidUpdate",
            "componentDidMount",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function App() {\n  const [visible, setVisible] = useState(true);\n  return <div>{visible && <span>Show</span>}</div>;\n}",
        "o": [
            "Show",
            "",
            "true",
            "Error"
        ]
    },
    {
        "q": "What is the recommended way to prevent unnecessary re-renders of a child component?",
        "o": [
            "Wrap it with React.memo",
            "Use multiple states instead of one",
            "Pass fewer props",
            "Use more lifecycle methods"
        ]
    },
    {
        "q": "Which hook returns a function to update the current state value?",
        "o": [
            "useState",
            "useEffect",
            "useMemo",
            "useContext"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Counter() {\n  const [count, setCount] = useState(2);\n  return <h3>{count === 2 ? 'Two' : 'Other'}</h3>;\n}",
        "o": [
            "Two",
            "Other",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is true about props drilling?",
        "o": [
            "It happens when props are passed through many levels of components",
            "It happens when props are modified directly",
            "It happens when state is updated deeply",
            "It happens only in class components"
        ]
    },
    {
        "q": "What will be logged?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  setCount(prev => prev + 1);\n  console.log(count);\n  return null;\n}",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook can help avoid recalculating derived values unless dependencies change?",
        "o": [
            "useMemo",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "Which of the following best describes lifting state up?",
        "o": [
            "Moving shared state to the closest common ancestor",
            "Passing functions down as props",
            "Creating state in every child component",
            "Using Redux for global state"
        ]
    },
    {
        "q": "Which of the following correctly updates state based on the previous state in a functional component?",
        "o": [
            "setValue(prev => prev + 1)",
            "setValue(value++)",
            "value = value + 1",
            "this.setState(value + 1)"
        ]
    },
    {
        "q": "Which lifecycle method is invoked immediately after a component is inserted into the DOM?",
        "o": [
            "componentDidMount",
            "componentWillUnmount",
            "componentDidUpdate",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Greeting({ name }) {\n  return <h1>{name || 'Guest'}</h1>;\n}\n<Greeting name={null} />",
        "o": [
            "Guest",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook is useful for storing a mutable value that does not cause re-rendering when changed?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What is the correct way to conditionally render a component only when `isLoggedIn` is false?",
        "o": [
            "{!isLoggedIn && <Login />}",
            "{isLoggedIn ? <Login /> : null}",
            "{if(!isLoggedIn) <Login />}",
            "{isLoggedIn || <Login />}"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status() {\n  const [active, setActive] = useState(false);\n  return <p>{active ? 'Active' : 'Inactive'}</p>;\n}",
        "o": [
            "Inactive",
            "Active",
            "false",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about state updates in React?",
        "o": [
            "They may be batched for performance optimization",
            "They always update immediately and synchronously",
            "They block rendering until completed",
            "They can only be triggered inside lifecycle methods"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [msg, setMsg] = useState('Hi');\nsetMsg('Hello');\nconsole.log(msg);",
        "o": [
            "Hi",
            "Hello",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which lifecycle method is used for performing updates after the component’s props or state change?",
        "o": [
            "componentDidUpdate",
            "componentDidMount",
            "componentWillUnmount",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "Which of the following is the correct way to pass multiple props into a component?",
        "o": [
            "<Profile name=\"John\" age={30} />",
            "<Profile {name, age} />",
            "<Profile props={{name: 'John', age: 30}} />",
            "<Profile>name=\"John\" age=30</Profile>"
        ]
    },
    {
        "q": "If you try to modify props directly inside a child component, what will happen?",
        "o": [
            "The change will not persist and React may show a warning",
            "The props will update the parent component immediately",
            "The app will crash with a runtime error",
            "React will silently convert it to state"
        ]
    },
    {
        "q": "Why is it recommended to use functional updates with setState when the new value depends on the old one?",
        "o": [
            "Because React batches updates and the old value might be stale",
            "Because it prevents memory leaks",
            "Because props cannot be accessed inside setState",
            "Because it avoids conditional rendering"
        ]
    },
    {
        "q": "What problem does React’s unidirectional data flow solve?",
        "o": [
            "It makes it easier to track how data changes over time",
            "It allows data to be shared between unrelated components automatically",
            "It ensures that child components can always modify parent state",
            "It replaces the need for lifecycle methods"
        ]
    },
    {
        "q": "Which of the following is a disadvantage of lifting state up?",
        "o": [
            "It can cause props drilling across many components",
            "It makes components reusable",
            "It reduces duplication of state",
            "It simplifies debugging"
        ]
    },
    {
        "q": "Imagine you want to show a loading spinner until data is fetched. Which React concept would you use?",
        "o": [
            "Conditional rendering",
            "Default props",
            "React.memo",
            "PureComponent"
        ]
    },
    {
        "q": "Why should you avoid storing derived values directly in state?",
        "o": [
            "Because they can always be computed from existing props or state",
            "Because React does not allow derived state",
            "Because state updates are immutable",
            "Because it breaks the unidirectional data flow"
        ]
    },
    {
        "q": "If a component does not depend on any state or props, what is the best practice?",
        "o": [
            "Write it as a pure functional component",
            "Use useEffect for rendering",
            "Use class component with empty state",
            "Add default props to simulate state"
        ]
    },
    {
        "q": "What happens if you call setState (class component) or setCount (useState) with the same value it already has?",
        "o": [
            "React skips re-rendering for optimization",
            "React always re-renders regardless",
            "React throws a warning",
            "The component unmounts and remounts"
        ]
    },
    {
        "q": "Why is componentWillUnmount important?",
        "o": [
            "It is used to clean up side effects like timers or subscriptions",
            "It prevents re-renders of child components",
            "It is the only method where state can be updated",
            "It initializes props for the component"
        ]
    },
    {
        "q": "Which pattern helps avoid deeply nested props drilling?",
        "o": [
            "React Context API",
            "Conditional rendering",
            "Pure components",
            "Lifecycle methods"
        ]
    },
    {
        "q": "Why should keys be provided when rendering a list of components?",
        "o": [
            "To help React identify which items have changed, added, or removed",
            "To pass data as props to each list item",
            "To prevent re-rendering of the entire list",
            "To make the component pure"
        ]
    },
    {
        "q": "What happens if two elements in a React list have the same key?",
        "o": [
            "React may render them incorrectly or reuse the wrong DOM nodes",
            "React will automatically generate unique keys",
            "React throws a compile-time error",
            "The last element always overwrites the first"
        ]
    },
    {
        "q": "What does the second argument of useEffect represent?",
        "o": [
            "An array of dependencies that determine when the effect runs",
            "The cleanup function",
            "The initial state value",
            "The function that updates state"
        ]
    },
    {
        "q": "Why should you never call hooks inside loops or conditions?",
        "o": [
            "Because hooks must be called in the same order on every render",
            "Because React cannot recognize custom hooks otherwise",
            "Because it causes props to reset",
            "Because it blocks state updates"
        ]
    },
    {
        "q": "When using useEffect, how do you run an effect only once after the initial render?",
        "o": [
            "Pass an empty dependency array []",
            "Do not provide any dependency array",
            "Pass null as dependency",
            "Use useMemo instead of useEffect"
        ]
    },
    {
        "q": "Why is setState in class components asynchronous?",
        "o": [
            "To allow React to batch multiple state updates for performance",
            "To prevent state from being changed directly",
            "Because JavaScript promises are used internally",
            "Because lifecycle methods must run first"
        ]
    },
    {
        "q": "How can you prevent a component from re-rendering when props change?",
        "o": [
            "Wrap it with React.memo",
            "Use useEffect with empty dependency",
            "Remove all props from the component",
            "Call setState with the same value"
        ]
    },
    {
        "q": "What is the difference between useMemo and useCallback?",
        "o": [
            "useMemo memoizes a computed value, useCallback memoizes a function",
            "useMemo is only for primitive values, useCallback is for objects",
            "useCallback is faster than useMemo",
            "useMemo always re-renders, useCallback prevents rendering"
        ]
    },
    {
        "q": "What happens if a component returns null from its render method?",
        "o": [
            "Nothing is rendered but the component still runs lifecycle methods",
            "React throws an error",
            "React automatically renders an empty div",
            "The component is unmounted"
        ]
    },
    {
        "q": "Why is it recommended to keep components pure?",
        "o": [
            "Because pure components make the UI predictable and easier to debug",
            "Because React requires components to be pure",
            "Because impure components break JSX",
            "Because lifecycle methods cannot run in impure components"
        ]
    },
    {
        "q": "What is the default behavior of React when a component's state changes?",
        "o": [
            "It re-renders the component",
            "It refreshes the entire page",
            "It only updates props",
            "It unmounts the component"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Hello({ name }) {\n  return <h1>Hello, {name ?? 'Anonymous'}</h1>;\n}\n<Hello />",
        "o": [
            "Hello, Anonymous",
            "Hello, undefined",
            "Hello, null",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about the dependency array in useEffect?",
        "o": [
            "If omitted, the effect runs after every render",
            "If empty, the effect never runs",
            "If empty, the effect runs on every update",
            "It can only contain state variables"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    setCount(5);\n  }, []);\n  return <p>{count}</p>;\n}",
        "o": [
            "5",
            "0",
            "Error",
            "undefined"
        ]
    },
    {
        "q": "Why are controlled components preferred in React forms?",
        "o": [
            "Because React manages the form state via state variables",
            "Because uncontrolled components cannot be used with props",
            "Because controlled components do not require handlers",
            "Because controlled components are faster"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function Show({ flag }) {\n  return <div>{flag && 'Active'}</div>;\n}\n<Show flag={false} />",
        "o": [
            "",
            "Active",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is it important to provide a cleanup function in useEffect?",
        "o": [
            "To avoid memory leaks when a component unmounts",
            "To prevent props from being reset",
            "To initialize state variables",
            "To optimize rendering speed"
        ]
    },
    {
        "q": "What will be logged to the console?",
        "c": "function App() {\n  const [value, setValue] = useState('A');\n  useEffect(() => {\n    console.log(value);\n  }, [value]);\n  setValue('B');\n  return null;\n}",
        "o": [
            "A",
            "A then B",
            "B",
            "Nothing"
        ]
    },
    {
        "q": "What is the main purpose of React.Fragment?",
        "o": [
            "To group multiple elements without adding extra DOM nodes",
            "To replace useState",
            "To optimize rendering performance",
            "To delay rendering until state updates"
        ]
    },
    {
        "q": "What will be displayed on the screen?",
        "c": "function App() {\n  const [visible, setVisible] = useState(false);\n  return (\n    <div>\n      {visible ? <p>Now Visible</p> : <p>Hidden</p>}\n    </div>\n  );\n}",
        "o": [
            "Hidden",
            "Now Visible",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What happens if you call useState inside a conditional block?",
        "o": [
            "It breaks the rules of hooks and may cause errors",
            "It initializes state only when the condition is true",
            "It creates local state for that block",
            "It works the same as calling useState at the top level"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ online }) {\n  return <span>{online ? 'Online' : 'Offline'}</span>;\n}\n<Status online={true} />",
        "o": [
            "Online",
            "Offline",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Which hook would you use to persist a value across renders without causing a re-render when updated?",
        "o": [
            "useRef",
            "useMemo",
            "useEffect",
            "useState"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [count, setCount] = useState(1);\n  return <h1>{count > 2 ? 'Big' : 'Small'}</h1>;\n}",
        "o": [
            "Small",
            "Big",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of useReducer compared to useState?",
        "o": [
            "It manages more complex state logic using reducers",
            "It is faster than useState",
            "It replaces lifecycle methods",
            "It avoids conditional rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Display() {\n  const [text] = useState('Hello');\n  return <div>{text && 'World'}</div>;\n}",
        "o": [
            "World",
            "Hello",
            "HelloWorld",
            "undefined"
        ]
    },
    {
        "q": "Which lifecycle method is typically used to fetch data in a class component?",
        "o": [
            "componentDidMount",
            "render",
            "componentWillUnmount",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "class App extends React.Component {\n  state = { count: 0 };\n  componentDidMount() {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count);\n  }\n  render() { return null; }\n}",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why should you avoid copying props directly into state?",
        "o": [
            "Because it can cause state to get out of sync with props",
            "Because props cannot be used inside state",
            "Because React does not allow props inside state",
            "Because it prevents re-rendering"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [show, setShow] = useState(false);\n  return <div>{show ? <p>Visible</p> : null}</div>;\n}",
        "o": [
            "",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is it discouraged to use array indexes as keys when rendering lists?",
        "o": [
            "Because it can cause inefficient re-renders and bugs when items are reordered",
            "Because React does not allow numeric keys",
            "Because array indexes slow down the virtual DOM",
            "Because it prevents child components from receiving props"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function App() {\n  const [items] = useState(['A', 'B']);\n  return (\n    <ul>\n      {items.map((item, index) => <li key={index}>{item}</li>)}\n    </ul>\n  );\n}",
        "o": [
            "A and B as list items",
            "Error: keys must not use index",
            "Only A",
            "Only B"
        ]
    },
    {
        "q": "What does React.StrictMode do?",
        "o": [
            "It activates additional checks and warnings for its descendants",
            "It prevents components from re-rendering unnecessarily",
            "It makes all components pure automatically",
            "It disables deprecated lifecycle methods"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log('Effect runs');\n  }, [count]);\n  return <button onClick={() => setCount(count + 1)}>Click</button>;\n}",
        "o": [
            "Effect runs after every count update",
            "Effect runs only once on mount",
            "Effect never runs",
            "Effect runs before render"
        ]
    },
    {
        "q": "Why might you use useLayoutEffect instead of useEffect?",
        "o": [
            "To run effects synchronously after DOM mutations but before the browser paints",
            "To improve rendering speed automatically",
            "To fetch data asynchronously",
            "To memoize calculated values"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Label() {\n  const [value] = useState('React');\n  return <>{value}</>;\n}",
        "o": [
            "React",
            "<></>",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the difference between React.PureComponent and React.Component?",
        "o": [
            "PureComponent does a shallow comparison of props and state to avoid unnecessary re-renders",
            "PureComponent cannot use lifecycle methods",
            "PureComponent automatically manages state",
            "They are exactly the same"
        ]
    },
    {
        "q": "What will happen here?",
        "c": "function App() {\n  const [val, setVal] = useState(0);\n  setVal(val);\n  return <p>{val}</p>;\n}",
        "o": [
            "It may cause an infinite render loop",
            "It will display 0 without issues",
            "It will display undefined",
            "It will throw an error"
        ]
    },
    {
        "q": "Why should functions passed as props often be wrapped with useCallback?",
        "o": [
            "To prevent unnecessary re-renders of child components",
            "To ensure the function is pure",
            "To delay execution of the function",
            "To automatically bind this to the function"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Message() {\n  const [text, setText] = useState('Hello');\n  return <p>{text && 'World'}</p>;\n}",
        "o": [
            "World",
            "Hello",
            "HelloWorld",
            "undefined"
        ]
    },
    {
        "q": "What is the correct way to handle multiple input fields with a single state object in React?",
        "c": "const [form, setForm] = useState({ name: '', email: '' });",
        "o": [
            "Use a single state object and update properties using spread syntax",
            "Create separate useState calls for each input field",
            "Use props instead of state for inputs",
            "Directly modify the DOM input values"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  return <div>{count || 'Zero'}</div>;\n}",
        "o": [
            "Zero",
            "0",
            "count",
            "undefined"
        ]
    },
    {
        "q": "Which hook can help you memorize a callback to prevent unnecessary re-creation of functions?",
        "o": [
            "useCallback",
            "useEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What is the purpose of useImperativeHandle?",
        "o": [
            "To customize the instance value exposed to parent refs",
            "To replace useState in functional components",
            "To perform cleanup before unmount",
            "To memoize computed values"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <p>Visible</p> : null}</>;\n}\n<Toggle show={false} />",
        "o": [
            "",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which scenario requires using useReducer over useState?",
        "o": [
            "When state logic is complex or depends on previous state",
            "When the component has only one simple state value",
            "When no state is required",
            "When props are immutable"
        ]
    },
    {
        "q": "What will this code output?",
        "c": "const [count, setCount] = useState(0);\nsetCount(prev => prev + 1);\nsetCount(prev => prev + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid side effects directly inside the render method?",
        "o": [
            "Because it can cause unexpected behavior and violates React’s rules",
            "Because render method cannot access state",
            "Because props cannot be used inside render",
            "Because it will prevent conditional rendering"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Status({ online }) {\n  return <p>{online === undefined ? 'Unknown' : online ? 'Online' : 'Offline'}</p>;\n}\n<Status />",
        "o": [
            "Unknown",
            "Online",
            "Offline",
            "Error"
        ]
    },
    {
        "q": "Which of the following best describes a controlled component?",
        "o": [
            "A form input element whose value is controlled by React state",
            "An input element without state",
            "A component that cannot be updated",
            "A component that automatically updates the DOM"
        ]
    },
    {
        "q": "What will happen if you forget to include a dependency in the useEffect dependency array?",
        "o": [
            "The effect may use stale values and not update correctly",
            "The effect will throw a runtime error",
            "React will automatically add the missing dependency",
            "The component will unmount immediately"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  const [display, setDisplay] = useState(true);\n  return <>{display && <h1>Hello, {name}</h1>}</>;\n}\n<Greeting name={null} />",
        "o": [
            "Hello, null",
            "Hello, undefined",
            "Hello",
            "Error"
        ]
    },
    {
        "q": "Which hook allows you to synchronize a component with an external system, like subscribing to a data source?",
        "o": [
            "useEffect",
            "useState",
            "useRef",
            "useMemo"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why is it recommended to avoid creating new objects or arrays inside the render method?",
        "o": [
            "Because it causes child components to re-render unnecessarily if used as props",
            "Because React cannot handle objects in JSX",
            "Because state cannot hold arrays",
            "Because it breaks the virtual DOM"
        ]
    },
    {
        "q": "What will be logged?",
        "c": "const [value, setValue] = useState(1);\nsetValue(prev => prev + 1);\nsetValue(prev => prev + 1);\nconsole.log(value);",
        "o": [
            "1",
            "2",
            "3",
            "undefined"
        ]
    },
    {
        "q": "Which hook is suitable for performing expensive calculations only when dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useReducer"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Visibility({ show }) {\n  return <>{show ? <p>Visible</p> : <p>Hidden</p>}</>;\n}\n<Visibility show={true} />",
        "o": [
            "Visible",
            "Hidden",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is true about useRef?",
        "o": [
            "It can store a mutable value that persists across renders without causing re-renders",
            "It triggers a re-render whenever the value changes",
            "It replaces useState for primitive values",
            "It cannot hold objects or DOM elements"
        ]
    },
    {
        "q": "What will happen if you call setState in a loop inside a functional component?",
        "o": [
            "It may cause multiple renders and potentially an infinite loop",
            "It updates the state only once",
            "It merges the updates automatically without re-rendering",
            "It throws a syntax error"
        ]
    },
    {
        "q": "What will happen if a parent component re-renders but the child is wrapped in React.memo and its props have not changed?",
        "o": [
            "The child will not re-render",
            "The child will always re-render",
            "React will throw an error",
            "The child will unmount and remount"
        ]
    },
    {
        "q": "What is the purpose of the key prop when rendering a list of components in React?",
        "o": [
            "To help React identify which items have changed, been added, or removed",
            "To set a unique ID in the DOM",
            "To automatically pass props to children",
            "To trigger lifecycle methods in the child components"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count < 5 ? 'Low' : 'High'}</p>;\n}",
        "o": [
            "Low",
            "High",
            "0",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid creating inline functions as props inside a component's render?",
        "o": [
            "Because it can cause unnecessary re-renders of child components",
            "Because React does not allow inline functions",
            "Because it will break conditional rendering",
            "Because it will reset state values"
        ]
    },
    {
        "q": "Which hook can be used to read the previous value of a state or prop?",
        "o": [
            "useRef",
            "useEffect",
            "useState",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <p>{text?.length ? text : 'No message'}</p>;\n}\n<Message text='' />",
        "o": [
            "No message",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why would you use a reducer instead of multiple useState calls?",
        "o": [
            "To manage complex state logic in a single place",
            "To avoid using useEffect",
            "To eliminate the need for props",
            "To automatically memoize the component"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle() {\n  const [flag, setFlag] = useState(true);\n  return <>{flag && <span>ON</span>}</>;\n}",
        "o": [
            "ON",
            "",
            "true",
            "undefined"
        ]
    },
    {
        "q": "What happens if you pass an empty array as the dependency to useEffect?",
        "o": [
            "The effect runs only once after the initial render",
            "The effect runs on every render",
            "The effect never runs",
            "The effect runs only when state changes"
        ]
    },
    {
        "q": "Which of the following is true about derived state?",
        "o": [
            "It should usually be computed from props or other state rather than stored directly",
            "It must always be stored in state",
            "It cannot depend on props",
            "It automatically updates without re-renders"
        ]
    },
    {
        "q": "What will this code render?",
        "c": "function App() {\n  const [status, setStatus] = useState(null);\n  return <p>{status ?? 'Unknown'}</p>;\n}",
        "o": [
            "Unknown",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about useEffect cleanup function?",
        "o": [
            "It runs before the component unmounts or before the effect runs again",
            "It runs only once after the component mounts",
            "It replaces componentDidMount",
            "It automatically updates state"
        ]
    },
    {
        "q": "What is the advantage of using useMemo in a component?",
        "o": [
            "It avoids expensive recalculations when dependencies haven't changed",
            "It triggers a re-render of the component automatically",
            "It replaces useState",
            "It prevents all child components from re-rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function List() {\n  const items = ['A', 'B'];\n  return <ul>{items.map(item => <li key={item}>{item}</li>)}</ul>;\n}",
        "o": [
            "A and B as list items",
            "Error due to missing key",
            "Only A",
            "Only B"
        ]
    },
    {
        "q": "Why is it important to keep state updates immutable?",
        "o": [
            "Because React relies on object references to detect changes for re-rendering",
            "Because JavaScript forbids mutable objects",
            "Because props cannot be mutable",
            "Because immutable state avoids syntax errors"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which hook can be used to expose imperative methods to parent components?",
        "o": [
            "useImperativeHandle",
            "useState",
            "useRef",
            "useCallback"
        ]
    },
    {
        "q": "What happens if you call setState multiple times in the same function in a class component?",
        "o": [
            "React may batch the updates and re-render only once",
            "React re-renders immediately for each call",
            "The last call overwrites previous calls without re-rendering",
            "It causes a runtime error"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Conditional({ show }) {\n  return <>{show ? <span>Yes</span> : <span>No</span>}</>;\n}\n<Conditional show={false} />",
        "o": [
            "No",
            "Yes",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is lifting state up considered a good practice?",
        "o": [
            "It allows shared state to be managed in a common ancestor and passed via props",
            "It prevents the need for useEffect",
            "It automatically memoizes child components",
            "It avoids the use of keys in lists"
        ]
    },
    {
        "q": "What will happen if you call a state updater (setState or setCount) with a function inside useEffect without a dependency array?",
        "o": [
            "The effect will run after every render, potentially causing an infinite loop",
            "The state will never update",
            "The component will skip the render phase",
            "React automatically stops the loop"
        ]
    },
    {
        "q": "What is the main difference between controlled and uncontrolled components in React?",
        "o": [
            "Controlled components store their value in React state, uncontrolled components rely on the DOM",
            "Controlled components cannot have props, uncontrolled components can",
            "Uncontrolled components update the state automatically, controlled components do not",
            "Controlled components are class components, uncontrolled are functional components"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ online }) {\n  return <p>{online === true ? 'Online' : online === false ? 'Offline' : 'Unknown'}</p>;\n}\n<Status />",
        "o": [
            "Unknown",
            "Online",
            "Offline",
            "Error"
        ]
    },
    {
        "q": "Why is it generally a bad idea to derive state directly from props?",
        "o": [
            "Because it can lead to inconsistent or stale state if props change",
            "Because props are immutable",
            "Because it breaks conditional rendering",
            "Because React does not allow it"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Which hook is best suited to store a reference to a DOM element?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [show, setShow] = useState(false);\n  return <>{show ? <p>Visible</p> : null}</>;\n}",
        "o": [
            "",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is React's state considered immutable?",
        "o": [
            "Because direct modifications do not trigger re-renders and can cause unpredictable UI",
            "Because JavaScript does not allow object modification",
            "Because React automatically freezes all state objects",
            "Because props and state share the same memory"
        ]
    },
    {
        "q": "What will this code output?",
        "c": "function App() {\n  const [value, setValue] = useState(1);\n  setValue(prev => prev + 1);\n  setValue(prev => prev + 1);\n  console.log(value);\n  return null;\n}",
        "o": [
            "1",
            "2",
            "3",
            "undefined"
        ]
    },
    {
        "q": "What is the main reason for using React.memo?",
        "o": [
            "To prevent unnecessary re-renders of a functional component when props do not change",
            "To replace useEffect in functional components",
            "To memoize state values",
            "To automatically pass props to child components"
        ]
    },
    {
        "q": "What will happen if a component returns multiple adjacent JSX elements without a wrapper?",
        "o": [
            "It will cause a syntax error; React requires a single root element or a fragment",
            "It will render correctly without issues",
            "It automatically wraps elements in a div",
            "It ignores all elements except the first one"
        ]
    },
    {
        "q": "Which of the following is true about the useState hook?",
        "o": [
            "It allows you to add state to functional components",
            "It can only be used in class components",
            "It automatically triggers componentWillUnmount",
            "It replaces useEffect"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function ShowMessage({ message }) {\n  return <>{message ?? 'No message available'}</>;\n}\n<ShowMessage message={null} />",
        "o": [
            "No message available",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it recommended to use useCallback when passing functions as props?",
        "o": [
            "To prevent child components from re-rendering unnecessarily",
            "To automatically memoize state values",
            "To replace useEffect",
            "To allow direct mutation of props"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [count, setCount] = useState(0);\nsetCount(prev => prev + 1);\nsetCount(prev => prev + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Which hook would you use to store a value that should persist across renders but not trigger a re-render when changed?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will be displayed?",
        "c": "function App() {\n  const [flag, setFlag] = useState(false);\n  return <>{flag ? <p>ON</p> : <p>OFF</p>}</>;\n}",
        "o": [
            "OFF",
            "ON",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why should derived values usually not be stored in state?",
        "o": [
            "Because they can be computed from existing state or props when needed",
            "Because React does not allow objects in state",
            "Because derived values cannot trigger re-renders",
            "Because derived values always cause infinite loops"
        ]
    },
    {
        "q": "What is the main purpose of the useLayoutEffect hook?",
        "o": [
            "To perform DOM updates synchronously before the browser paints",
            "To replace useEffect for asynchronous operations",
            "To automatically update state",
            "To memoize values"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function App() {\n  const [num, setNum] = useState(0);\n  return <p>{num > 0 ? 'Positive' : num < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of React Context?",
        "o": [
            "To share state across multiple components without passing props manually",
            "To replace useState in functional components",
            "To automatically trigger re-renders of all components",
            "To memoize expensive calculations"
        ]
    },
    {
        "q": "Which of the following is true about defaultProps in React?",
        "o": [
            "They provide default values for props if none are passed",
            "They override state values",
            "They trigger re-renders when updated",
            "They can only be used in functional components"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "const ThemeContext = React.createContext('light');\nfunction App() {\n  return <ThemeContext.Provider value='dark'><Child /></ThemeContext.Provider>;\n}\nfunction Child() {\n  const theme = React.useContext(ThemeContext);\n  return <p>{theme}</p>;\n}",
        "o": [
            "dark",
            "light",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why would you use a custom hook in React?",
        "o": [
            "To reuse stateful logic across multiple components",
            "To replace lifecycle methods",
            "To define JSX elements",
            "To automatically optimize performance"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Timer() {\n  const [seconds, setSeconds] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(() => setSeconds(s => s + 1), 1000);\n    return () => clearInterval(interval);\n  }, []);\n  return <p>{seconds}</p>;\n}",
        "o": [
            "0 initially, then increments every second",
            "Always 0",
            "Error due to setInterval",
            "Undefined"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries in React?",
        "o": [
            "They catch JavaScript errors in the component tree and display a fallback UI",
            "They prevent all re-renders in the application",
            "They replace try/catch blocks inside components",
            "They can be used in functional components using hooks"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "function App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => { console.log('Count changed', count); }, [count]);\n  setCount(1);\n  return null;\n}",
        "o": [
            "Count changed 0",
            "Count changed 1",
            "Count changed 0 then 1",
            "Nothing"
        ]
    },
    {
        "q": "Which scenario is ideal for using React.lazy and Suspense?",
        "o": [
            "To load components lazily for code-splitting and improve performance",
            "To memoize state values",
            "To replace useEffect",
            "To automatically lift state up"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name={undefined} />",
        "o": [
            "ANONYMOUS",
            "undefined",
            "Error",
            "name"
        ]
    },
    {
        "q": "Why would you use the useDebugValue hook?",
        "o": [
            "To display a label for custom hooks in React DevTools for easier debugging",
            "To optimize re-renders",
            "To memoize state values",
            "To replace useEffect"
        ]
    },
    {
        "q": "What is the main benefit of splitting a component into smaller sub-components?",
        "o": [
            "It improves readability, reusability, and maintainability of code",
            "It automatically improves performance",
            "It removes the need for state",
            "It allows direct DOM manipulation"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting({ name }) {\n  return <h1>{name && `Hello, ${name}`}</h1>;\n}\n<Greeting name='' />",
        "o": [
            "",
            "Hello, ",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to trigger a side effect only when a specific prop changes?",
        "o": [
            "useEffect with the prop in the dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What is the main advantage of using the useReducer hook?",
        "o": [
            "It centralizes complex state logic and makes state transitions predictable",
            "It automatically prevents re-renders",
            "It replaces props",
            "It initializes the DOM"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ active }) {\n  return <>{active === false ? 'Inactive' : 'Active'}</>;\n}\n<Status active={false} />",
        "o": [
            "Inactive",
            "Active",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is it generally recommended to avoid deep nested state objects?",
        "o": [
            "Because updating nested state can be complex and may require immutability handling",
            "Because React cannot handle nested objects",
            "Because nested objects do not trigger re-renders",
            "Because it breaks props"
        ]
    },
    {
        "q": "What will happen if a component uses useEffect without a cleanup function to set up an interval?",
        "o": [
            "The interval will continue running even after the component unmounts, causing memory leaks",
            "The interval automatically stops on unmount",
            "The component will fail to mount",
            "The interval will run only once"
        ]
    },
    {
        "q": "Which of the following is true about useDeferredValue?",
        "o": [
            "It allows React to defer updating a non-urgent value to improve responsiveness",
            "It replaces useState",
            "It triggers immediate re-render of the component",
            "It memoizes callback functions"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Toggle({ isOn }) {\n  return <>{isOn ? 'ON' : 'OFF'}</>;\n}\n<Toggle isOn={true} />",
        "o": [
            "ON",
            "OFF",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid passing new object or array literals as props directly?",
        "o": [
            "Because it creates a new reference on every render, causing unnecessary re-renders",
            "Because React cannot handle objects or arrays as props",
            "Because it breaks conditional rendering",
            "Because it prevents useEffect from running"
        ]
    },
    {
        "q": "What is the primary purpose of the React Profiler API?",
        "o": [
            "To measure the performance of React components and detect slow renders",
            "To replace useEffect for side effects",
            "To automatically memoize state values",
            "To catch errors in child components"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text?.length > 0 ? text : 'No message'}</>;\n}\n<Message text='' />",
        "o": [
            "No message",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to defer updating a value to reduce rendering cost in large lists?",
        "o": [
            "useDeferredValue",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [count, setCount] = useState(0);\nsetCount(c => c + 1);\nsetCount(c => c + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Why is the key prop crucial when rendering dynamic lists in React?",
        "o": [
            "It helps React efficiently update and re-order items without re-rendering unchanged elements",
            "It automatically sorts the list",
            "It prevents state updates",
            "It is required for conditional rendering"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function App({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<App active={0} />",
        "o": [
            "0",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why would you use the useTransition hook?",
        "o": [
            "To mark state updates as non-urgent and improve UI responsiveness",
            "To replace useEffect",
            "To memoize computed values",
            "To automatically clean up effects"
        ]
    },
    {
        "q": "Which of the following is true about useImperativeHandle?",
        "o": [
            "It customizes the ref value exposed to parent components",
            "It replaces useEffect for side effects",
            "It triggers re-render automatically",
            "It cannot be used with functional components"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function App() {\n  const [val, setVal] = useState(false);\n  return <>{val && 'True'}</>;\n}",
        "o": [
            "",
            "True",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid calling hooks conditionally inside a component?",
        "o": [
            "Because hooks must be called in the same order on every render",
            "Because it prevents props from updating",
            "Because it breaks JSX syntax",
            "Because it prevents state updates"
        ]
    },
    {
        "q": "Which of the following best describes React Portals?",
        "o": [
            "They allow rendering a child component into a DOM node outside the parent component's hierarchy",
            "They automatically memoize a component",
            "They replace useEffect for side effects",
            "They provide context to all child components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function App({ name }) {\n  return <>{name?.toLowerCase() ?? 'anonymous'}</>;\n}\n<App name={undefined} />",
        "o": [
            "anonymous",
            "undefined",
            "Error",
            "name"
        ]
    },
    {
        "q": "Why is useDebugValue useful in custom hooks?",
        "o": [
            "It helps display helpful labels for custom hooks in React DevTools",
            "It triggers re-renders automatically",
            "It memoizes state values",
            "It replaces useEffect for side effects"
        ]
    },
    {
        "q": "What will happen if you pass a function directly as a prop to a child component without useCallback?",
        "o": [
            "The child may re-render unnecessarily on each parent render",
            "The function will be executed automatically",
            "The function cannot be called in the child",
            "The parent component will not render"
        ]
    },
    {
        "q": "Which hook would you use to optimize performance by memoizing expensive computations?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this code render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <p>Visible</p> : <p>Hidden</p>}</>;\n}\n<Toggle show={true} />",
        "o": [
            "Visible",
            "Hidden",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why should derived state usually be computed from props or other state instead of being stored directly?",
        "o": [
            "To avoid stale or inconsistent state when props change",
            "Because React does not allow derived state",
            "Because it causes errors in useEffect",
            "Because it automatically triggers infinite loops"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is true about lazy-loaded components in React?",
        "o": [
            "They allow code-splitting by loading components only when needed",
            "They replace useEffect for asynchronous operations",
            "They automatically memoize child components",
            "They prevent state updates"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function App({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<App active={false} />",
        "o": [
            "false",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to perform an action only once when a component mounts?",
        "o": [
            "useEffect with an empty dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status({ online }) {\n  return <>{online ? 'Online' : 'Offline'}</>;\n}\n<Status online={false} />",
        "o": [
            "Offline",
            "Online",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is it recommended to memoize callback functions with useCallback?",
        "o": [
            "To prevent unnecessary re-renders of child components receiving the callback as a prop",
            "To replace useEffect in functional components",
            "To memoize state values",
            "To automatically update props"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name ?? 'Guest'}</>;\n}\n<Greeting name={null} />",
        "o": [
            "Guest",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about the useLayoutEffect hook?",
        "o": [
            "It fires synchronously after all DOM mutations but before the browser paints",
            "It fires asynchronously after paint",
            "It replaces useState",
            "It memoizes computed values"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [count, setCount] = useState(0);\nsetCount(c => c + 1);\nsetCount(c => c + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Why is lifting state up a recommended practice in React?",
        "o": [
            "To share state between multiple components via a common ancestor",
            "To eliminate the need for props",
            "To avoid using useEffect",
            "To automatically memoize child components"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [num, setNum] = useState(0);\n  return <p>{num % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Which of the following is true about React Context?",
        "o": [
            "It allows sharing data across components without manually passing props",
            "It automatically memoizes child components",
            "It replaces useState",
            "It triggers re-renders for all components unconditionally"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name={undefined} />",
        "o": [
            "ANONYMOUS",
            "undefined",
            "Error",
            "name"
        ]
    },
    {
        "q": "What is the main purpose of React Portals?",
        "o": [
            "To render children into a DOM node outside the parent hierarchy",
            "To replace useState in functional components",
            "To memoize expensive computations",
            "To automatically manage state across components"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function App({ show }) {\n  return <>{show ? <p>Visible</p> : <p>Hidden</p>}</>;\n}\n<App show={false} />",
        "o": [
            "Hidden",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook can be used to access the previous value of a state or prop?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "Why is it important to use keys when rendering lists in React?",
        "o": [
            "To help React identify which items have changed, added, or removed for efficient re-renders",
            "To set default props for each item",
            "To trigger state updates automatically",
            "To prevent conditional rendering"
        ]
    },
    {
        "q": "What will this code display?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message'}</>;\n}\n<Message text='' />",
        "o": [
            "No message",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to defer updating a non-urgent value to improve UI responsiveness?",
        "o": [
            "useDeferredValue",
            "useEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ active }) {\n  return <>{active === false ? 'Inactive' : 'Active'}</>;\n}\n<Status active={true} />",
        "o": [
            "Active",
            "Inactive",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why is it generally recommended to avoid deep nested state objects?",
        "o": [
            "Because updating deeply nested state is complex and may require immutability handling",
            "Because React cannot handle nested objects",
            "Because nested objects prevent useEffect from running",
            "Because nested objects cannot be passed as props"
        ]
    },
    {
        "q": "What will happen if you forget to clean up intervals or subscriptions in useEffect?",
        "o": [
            "It can cause memory leaks and unexpected behavior after the component unmounts",
            "React will automatically clean up intervals",
            "Nothing, the component unmounts safely",
            "It will throw a runtime error"
        ]
    },
    {
        "q": "Which of the following is true about custom hooks?",
        "o": [
            "They allow you to reuse stateful logic across multiple components",
            "They automatically replace useState",
            "They can only be used in class components",
            "They cannot return values"
        ]
    },
    {
        "q": "Which hook would you use to synchronize a component with an external event or API?",
        "o": [
            "useEffect",
            "useState",
            "useRef",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle({ isOn }) {\n  return <>{isOn ? 'ON' : 'OFF'}</>;\n}\n<Toggle isOn={false} />",
        "o": [
            "OFF",
            "ON",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why would you use React.memo on a functional component?",
        "o": [
            "To prevent unnecessary re-renders when props do not change",
            "To replace useEffect",
            "To memoize state values",
            "To automatically lift state up"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting({ name }) {\n  return <>{name ?? 'Guest'}</>;\n}\n<Greeting name={null} />",
        "o": [
            "Guest",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook can help prevent expensive recalculations unless dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this code log?",
        "c": "const [count, setCount] = useState(0);\nsetCount(c => c + 1);\nsetCount(c => c + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "2",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid calling hooks conditionally inside a component?",
        "o": [
            "Because hooks must be called in the same order on every render",
            "Because it prevents state updates",
            "Because it breaks JSX syntax",
            "Because it prevents props from updating"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Counter() {\n  const [num, setNum] = useState(0);\n  return <p>{num % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries in React?",
        "o": [
            "They catch JavaScript errors in the component tree and display a fallback UI",
            "They prevent re-renders of all components",
            "They replace try/catch blocks inside components",
            "They can be used in functional components using hooks"
        ]
    },
    {
        "q": "What is the purpose of React.lazy and Suspense?",
        "o": [
            "To implement code-splitting and load components lazily",
            "To replace useEffect",
            "To memoize state values",
            "To automatically lift state up"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message available'}</>;\n}\n<Message text={null} />",
        "o": [
            "No message available",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook can be used to hold a mutable value that does not trigger re-renders?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Visibility({ show }) {\n  return <>{show ? <span>Visible</span> : <span>Hidden</span>}</>;\n}\n<Visibility show={true} />",
        "o": [
            "Visible",
            "Hidden",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why is it recommended to avoid mutating state directly?",
        "o": [
            "Because it can lead to unexpected behavior and React may not re-render components",
            "Because JavaScript does not allow object mutation",
            "Because it prevents props from updating",
            "Because it causes syntax errors in JSX"
        ]
    },
    {
        "q": "Which hook can be used to perform expensive calculations only when certain dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useReducer"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ active }) {\n  return <>{active === false ? 'Inactive' : 'Active'}</>;\n}\n<Status active={false} />",
        "o": [
            "Inactive",
            "Active",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why would you lift state up in React?",
        "o": [
            "To share state between multiple components via a common ancestor",
            "To avoid using props",
            "To automatically memoize child components",
            "To replace useEffect"
        ]
    },
    {
        "q": "What is the main purpose of the React Profiler API?",
        "o": [
            "To measure the performance of components and detect slow renders",
            "To replace useEffect",
            "To memoize state values",
            "To catch errors in child components"
        ]
    },
    {
        "q": "What will happen if you forget to clean up subscriptions in useEffect?",
        "o": [
            "It can cause memory leaks and unexpected behavior",
            "React will automatically clean up subscriptions",
            "The component will not mount",
            "Nothing will happen"
        ]
    },
    {
        "q": "Which of the following is true about custom hooks?",
        "o": [
            "They allow reusing stateful logic across multiple components",
            "They can only be used in class components",
            "They automatically prevent re-renders",
            "They cannot return values"
        ]
    },
    {
        "q": "Which hook would you use to force a re-render in a functional component?",
        "o": [
            "useState (by updating state)",
            "useEffect",
            "useRef",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() ?? 'Guest'}</>;\n}\n<Greeting name='  ' />",
        "o": [
            "",
            "Guest",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it important to provide keys when rendering lists in React?",
        "o": [
            "To help React identify which items changed, added, or removed for efficient re-rendering",
            "To automatically sort the list",
            "To trigger useEffect for each item",
            "To prevent state updates"
        ]
    },
    {
        "q": "What will happen if you call setState multiple times synchronously in a function component?",
        "o": [
            "React may batch the updates and re-render only once",
            "Each setState call will trigger a separate render immediately",
            "The last setState call is ignored",
            "It will throw a runtime error"
        ]
    },
    {
        "q": "Which hook can you use to perform layout updates synchronously before the browser paints?",
        "o": [
            "useLayoutEffect",
            "useEffect",
            "useState",
            "useMemo"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Why is React Context often used?",
        "o": [
            "To share state across multiple components without prop drilling",
            "To replace useState",
            "To automatically memoize child components",
            "To trigger re-renders for all components"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name={undefined} />",
        "o": [
            "ANONYMOUS",
            "undefined",
            "Error",
            "name"
        ]
    },
    {
        "q": "Which hook would you use to defer updating a non-urgent value to improve responsiveness?",
        "o": [
            "useDeferredValue",
            "useEffect",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "Why is it recommended to avoid passing new object or array literals directly as props?",
        "o": [
            "Because it creates a new reference on every render, causing unnecessary child re-renders",
            "Because React cannot handle objects or arrays as props",
            "Because it breaks JSX syntax",
            "Because it prevents useEffect from running"
        ]
    },
    {
        "q": "Which of the following is true about `useImperativeHandle`?",
        "o": [
            "It allows customizing the instance value exposed to parent components when using refs",
            "It replaces useEffect for side effects",
            "It triggers re-renders automatically",
            "It can only be used in class components"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle({ isOn }) {\n  return <>{isOn ? 'ON' : 'OFF'}</>;\n}\n<Toggle isOn={true} />",
        "o": [
            "ON",
            "OFF",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why would you use a custom hook in React?",
        "o": [
            "To reuse stateful logic across multiple components",
            "To replace JSX",
            "To automatically update state",
            "To memoize props"
        ]
    },
    {
        "q": "What is the main purpose of `useTransition`?",
        "o": [
            "To mark certain state updates as non-urgent and improve UI responsiveness",
            "To memoize expensive calculations",
            "To replace useEffect",
            "To automatically trigger re-renders"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<Status active={0} />",
        "o": [
            "0",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which of the following is true about React error boundaries?",
        "o": [
            "They catch JavaScript errors in child components and display a fallback UI",
            "They prevent re-renders for all components",
            "They replace try/catch inside components",
            "They can be used in functional components with hooks"
        ]
    },
    {
        "q": "What will happen if you forget the dependency array in useEffect?",
        "o": [
            "The effect will run after every render, potentially causing performance issues",
            "The effect will never run",
            "React will throw a syntax error",
            "It will run only once"
        ]
    },
    {
        "q": "Why should derived state usually not be stored in the component's state?",
        "o": [
            "Because it can be computed from props or other state, avoiding stale or inconsistent values",
            "Because React does not allow derived state",
            "Because it automatically triggers infinite loops",
            "Because it prevents re-renders"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() || 'Guest'}</>;\n}\n<Greeting name='  ' />",
        "o": [
            "Guest",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to measure render performance in a component?",
        "o": [
            "React Profiler",
            "useEffect",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "Which of the following is a correct use of the useEffect cleanup function?",
        "o": [
            "To clean up subscriptions or timers before the component unmounts or before the effect runs again",
            "To update state variables asynchronously",
            "To prevent the component from rendering",
            "To memoize expensive computations"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message'}</>;\n}\n<Message text='Hello World' />",
        "o": [
            "Hello World",
            "No message",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook can be used to optimize performance by memoizing a function definition?",
        "o": [
            "useCallback",
            "useEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why is it recommended to avoid mutating state directly?",
        "o": [
            "Because direct mutation may prevent React from detecting changes and trigger unexpected behavior",
            "Because JavaScript forbids object mutation",
            "Because props cannot be mutated",
            "Because it breaks conditional rendering"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name='John' />",
        "o": [
            "JOHN",
            "ANONYMOUS",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook would you use to perform an action only once when a component mounts?",
        "o": [
            "useEffect with an empty dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will happen if a parent component re-renders but the child component is wrapped in React.memo and props have not changed?",
        "o": [
            "The child component will not re-render",
            "The child component will always re-render",
            "React will throw an error",
            "The child component will unmount and remount"
        ]
    },
    {
        "q": "Why would you use React.lazy and Suspense?",
        "o": [
            "To load components lazily for code-splitting and improve performance",
            "To replace useEffect",
            "To memoize state values",
            "To automatically lift state up"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <span>Visible</span> : <span>Hidden</span>}</>;\n}\n<Toggle show={false} />",
        "o": [
            "Hidden",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook is used to store a mutable reference that persists across renders without causing re-renders?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.length ? name : 'Guest'}</>;\n}\n<Greeting name='' />",
        "o": [
            "Guest",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it important to include dependencies in useEffect?",
        "o": [
            "To control when the effect runs and avoid unnecessary executions or stale values",
            "Because React will throw an error otherwise",
            "To automatically memoize state values",
            "To prevent the component from mounting"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Counter() {\n  const [num, setNum] = useState(0);\n  return <p>{num > 0 ? 'Positive' : num < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which hook would you use to optimize expensive calculations that depend on state or props?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What is the purpose of the key prop when rendering lists in React?",
        "o": [
            "To help React identify which items changed, were added, or removed for efficient re-rendering",
            "To automatically sort list items",
            "To trigger useEffect for each item",
            "To prevent state updates"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Status({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<Status active={false} />",
        "o": [
            "false",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why should you lift state up in React?",
        "o": [
            "To share state between multiple components via a common ancestor",
            "To avoid using props",
            "To automatically memoize child components",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which of the following is true about React error boundaries?",
        "o": [
            "They catch JavaScript errors in child components and display a fallback UI",
            "They prevent re-renders for all components",
            "They replace try/catch inside components",
            "They can be used in functional components with hooks"
        ]
    },
    {
        "q": "What will happen if you call a state updater in useEffect without a proper dependency array?",
        "o": [
            "It may cause an infinite loop of renders",
            "The state will never update",
            "The component will mount once and stop",
            "It automatically triggers cleanup"
        ]
    },
    {
        "q": "Which hook allows you to memoize a value so it only recalculates when dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text ?? 'No message'}</>;\n}\n<Message text={undefined} />",
        "o": [
            "No message",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "Why would you use useCallback in a component?",
        "o": [
            "To memoize a function so that it does not get recreated on every render",
            "To automatically update state",
            "To replace useEffect",
            "To trigger conditional rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ active }) {\n  return <>{active ? 'ON' : 'OFF'}</>;\n}\n<Toggle active={false} />",
        "o": [
            "OFF",
            "ON",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook can be used to run side effects after every render?",
        "o": [
            "useEffect without a dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why is React Context useful?",
        "o": [
            "It allows sharing data across multiple components without passing props manually",
            "It replaces useState",
            "It automatically memoizes components",
            "It triggers re-renders for all child components"
        ]
    },
    {
        "q": "Which hook should be used to store a value that persists across renders but does not trigger re-renders?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name='' />",
        "o": [
            "ANONYMOUS",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it recommended to avoid mutating state directly?",
        "o": [
            "Direct mutation may prevent React from detecting changes, causing unexpected UI behavior",
            "Because JavaScript forbids object mutation",
            "Because props cannot be mutated",
            "Because it breaks JSX syntax"
        ]
    },
    {
        "q": "Which hook allows you to perform side effects only when a component mounts?",
        "o": [
            "useEffect with an empty dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() || 'Guest'}</>;\n}\n<Greeting name='  ' />",
        "o": [
            "Guest",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why should you include dependencies in useEffect?",
        "o": [
            "To ensure the effect runs only when specific values change and prevent stale data",
            "Because React will throw an error otherwise",
            "To automatically memoize state",
            "To prevent component mounting"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [num, setNum] = useState(0);\n  return <p>{num > 0 ? 'Positive' : num < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which hook helps to prevent unnecessary recalculation of values?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What is the purpose of the key prop in lists?",
        "o": [
            "To help React identify which items changed, added, or removed efficiently",
            "To automatically sort the list",
            "To trigger useEffect for each item",
            "To prevent state updates"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<Status active={false} />",
        "o": [
            "false",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why lift state up in React?",
        "o": [
            "To share state between multiple components via a common ancestor",
            "To avoid using props",
            "To automatically memoize child components",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which of the following is true about React error boundaries?",
        "o": [
            "They catch JavaScript errors in child components and display a fallback UI",
            "They prevent re-renders for all components",
            "They replace try/catch inside components",
            "They can be used in functional components with hooks"
        ]
    },
    {
        "q": "What will happen if a state updater is called in useEffect without dependencies?",
        "o": [
            "It may cause an infinite loop of renders",
            "The state will never update",
            "The component will mount once and stop",
            "It automatically triggers cleanup"
        ]
    },
    {
        "q": "Which hook would you use to defer a value update for non-urgent UI updates?",
        "o": [
            "useDeferredValue",
            "useEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Toggle({ active }) {\n  return <>{active ? 'ON' : 'OFF'}</>;\n}\n<Toggle active={true} />",
        "o": [
            "ON",
            "OFF",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why is React.memo useful?",
        "o": [
            "It prevents unnecessary re-renders of a functional component when props do not change",
            "It automatically memoizes state",
            "It replaces useEffect",
            "It lifts state up to a parent component"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message available'}</>;\n}\n<Message text='' />",
        "o": [
            "No message available",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook is best for performing side effects such as API calls or subscriptions?",
        "o": [
            "useEffect",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name={null} />",
        "o": [
            "ANONYMOUS",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why should you avoid passing new objects or arrays as props on every render?",
        "o": [
            "Because it creates new references each time, causing unnecessary re-renders in child components",
            "Because React cannot handle objects as props",
            "Because it prevents useEffect from running",
            "Because it causes syntax errors"
        ]
    },
    {
        "q": "Which hook would you use to store a value that persists across renders but does not trigger re-render?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why is it recommended to avoid direct mutation of state?",
        "o": [
            "Because React may not detect changes and the UI may not update correctly",
            "Because JavaScript forbids mutation",
            "Because props cannot be mutated",
            "Because it triggers infinite loops"
        ]
    },
    {
        "q": "Which hook would you use to get the previous value of a prop or state?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ online }) {\n  return <>{online ? 'Online' : 'Offline'}</>;\n}\n<Status online={true} />",
        "o": [
            "Online",
            "Offline",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid calling hooks conditionally inside a component?",
        "o": [
            "Because hooks must be called in the same order on every render",
            "Because it prevents state updates",
            "Because it breaks JSX syntax",
            "Because it prevents props from updating"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() || 'Guest'}</>;\n}\n<Greeting name='John' />",
        "o": [
            "John",
            "Guest",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook helps prevent expensive recalculations of values unless dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What is the main purpose of the key prop in dynamic lists?",
        "o": [
            "To help React identify which items changed, were added, or removed for efficient re-rendering",
            "To sort the list automatically",
            "To trigger useEffect for each item",
            "To prevent state updates"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ active }) {\n  return <>{active === false ? 'Inactive' : 'Active'}</>;\n}\n<Toggle active={true} />",
        "o": [
            "Active",
            "Inactive",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why lift state up in React?",
        "o": [
            "To share state between multiple components via a common ancestor",
            "To avoid using props",
            "To automatically memoize child components",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which of the following is true about error boundaries?",
        "o": [
            "They catch JavaScript errors in child components and display a fallback UI",
            "They prevent re-renders for all components",
            "They replace try/catch inside components",
            "They can be used in functional components with hooks"
        ]
    },
    {
        "q": "What happens if a state updater is called in useEffect without specifying dependencies?",
        "o": [
            "It may cause an infinite loop of renders",
            "The state will never update",
            "The component will mount once and stop",
            "It triggers cleanup automatically"
        ]
    },
    {
        "q": "Which hook allows you to execute a side effect only when a specific prop or state changes?",
        "o": [
            "useEffect with dependency array",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text ?? 'No message available'}</>;\n}\n<Message text='Hello React' />",
        "o": [
            "Hello React",
            "No message available",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why use useCallback in React?",
        "o": [
            "To memoize a function so it does not get recreated on each render",
            "To automatically update state",
            "To replace useEffect",
            "To memoize props"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which hook allows you to perform actions before the browser paints the UI?",
        "o": [
            "useLayoutEffect",
            "useEffect",
            "useState",
            "useMemo"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name='Alice' />",
        "o": [
            "ALICE",
            "ANONYMOUS",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it recommended to avoid creating new objects or arrays directly in props?",
        "o": [
            "Because it creates new references on every render, causing unnecessary re-renders",
            "Because React cannot handle objects in props",
            "Because it prevents useEffect from running",
            "Because it causes syntax errors"
        ]
    },
    {
        "q": "Which hook would you use to store a value that persists across renders without triggering a re-render?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <span>Visible</span> : <span>Hidden</span>}</>;\n}\n<Toggle show={false} />",
        "o": [
            "Hidden",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is it important to avoid direct state mutation in React?",
        "o": [
            "Because React may not detect changes and the UI may not update correctly",
            "Because JavaScript forbids mutation",
            "Because props cannot be mutated",
            "Because it triggers infinite loops"
        ]
    },
    {
        "q": "Which hook allows you to manage complex state logic using a reducer function?",
        "o": [
            "useReducer",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Status({ online }) {\n  return <>{online ? 'Online' : 'Offline'}</>;\n}\n<Status online={false} />",
        "o": [
            "Offline",
            "Online",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why is useLayoutEffect different from useEffect?",
        "o": [
            "It runs synchronously after DOM mutations but before the browser paints",
            "It runs asynchronously after the browser paints",
            "It replaces useState",
            "It memoizes expensive calculations"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() || 'Guest'}</>;\n}\n<Greeting name='' />",
        "o": [
            "Guest",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Which hook can you use to perform cleanup of subscriptions or timers?",
        "o": [
            "useEffect with a cleanup function",
            "useState",
            "useMemo",
            "useRef"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why use React.lazy with Suspense?",
        "o": [
            "To load components lazily for code-splitting and improve performance",
            "To replace useEffect",
            "To memoize state values",
            "To automatically lift state up"
        ]
    },
    {
        "q": "Which hook can help avoid unnecessary re-rendering of child components when passing callbacks?",
        "o": [
            "useCallback",
            "useMemo",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message'}</>;\n}\n<Message text='Hi!' />",
        "o": [
            "Hi!",
            "No message",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why should you lift state up to a common ancestor?",
        "o": [
            "To allow multiple components to share and synchronize state",
            "To avoid using props",
            "To prevent re-renders",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which hook allows a component to read and subscribe to context changes?",
        "o": [
            "useContext",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.toUpperCase() ?? 'Guest'}</>;\n}\n<Greeting name='React' />",
        "o": [
            "REACT",
            "Guest",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it important to clean up side effects in useEffect?",
        "o": [
            "To prevent memory leaks and unintended behavior when a component unmounts or updates",
            "Because React throws an error if cleanup is not done",
            "To automatically memoize state",
            "To prevent the component from rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ active }) {\n  return <>{active ? 'ON' : 'OFF'}</>;\n}\n<Toggle active={false} />",
        "o": [
            "OFF",
            "ON",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook is used to persist values across renders without causing re-renders?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Status({ online }) {\n  return <>{online ?? 'Offline'}</>;\n}\n<Status online={0} />",
        "o": [
            "0",
            "Offline",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why use React.memo for a functional component?",
        "o": [
            "To prevent unnecessary re-renders when props have not changed",
            "To replace useState",
            "To memoize state values",
            "To trigger conditional rendering automatically"
        ]
    },
    {
        "q": "Which hook is used to optimize expensive computations?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Why is it not recommended to mutate state directly in React?",
        "o": [
            "Direct mutation may not trigger a re-render, causing UI inconsistencies",
            "Because JavaScript forbids it",
            "Because props cannot be mutated",
            "Because it breaks JSX syntax"
        ]
    },
    {
        "q": "Which hook can be used to access and modify a DOM element directly?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text?.trim() || 'No message'}</>;\n}\n<Message text='  ' />",
        "o": [
            "No message",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it important to include a dependency array in useEffect?",
        "o": [
            "To control when the effect runs and avoid unnecessary executions",
            "Because React will throw an error otherwise",
            "To automatically memoize state values",
            "To prevent the component from rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ active }) {\n  return <>{active === false ? 'Inactive' : 'Active'}</>;\n}\n<Toggle active={false} />",
        "o": [
            "Inactive",
            "Active",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook is used to perform expensive calculations only when dependencies change?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.toUpperCase() ?? 'ANONYMOUS'}</>;\n}\n<User name={undefined} />",
        "o": [
            "ANONYMOUS",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "Why should you lift state up in React?",
        "o": [
            "To share state between multiple components through a common ancestor",
            "To avoid using props",
            "To prevent re-renders",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which hook is used to memoize a function definition?",
        "o": [
            "useCallback",
            "useMemo",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status({ online }) {\n  return <>{online ? 'Online' : 'Offline'}</>;\n}\n<Status online={true} />",
        "o": [
            "Online",
            "Offline",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid mutating state directly?",
        "o": [
            "Because it may not trigger a re-render, causing unexpected UI behavior",
            "Because JavaScript forbids object mutation",
            "Because props cannot be mutated",
            "Because it causes syntax errors"
        ]
    },
    {
        "q": "Which hook allows you to subscribe to context changes in functional components?",
        "o": [
            "useContext",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.trim() || 'Guest'}</>;\n}\n<Greeting name='Alice' />",
        "o": [
            "Alice",
            "Guest",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is useLayoutEffect different from useEffect?",
        "o": [
            "It runs synchronously after DOM mutations but before the browser paints",
            "It runs asynchronously after the browser paints",
            "It replaces useState",
            "It memoizes expensive calculations"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Which hook helps to defer a non-urgent update for better UI responsiveness?",
        "o": [
            "useDeferredValue",
            "useEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Message({ text }) {\n  return <>{text ?? 'No message available'}</>;\n}\n<Message text={null} />",
        "o": [
            "No message available",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it recommended to wrap components with React.memo?",
        "o": [
            "To prevent unnecessary re-renders when props do not change",
            "To replace useEffect",
            "To memoize state values",
            "To trigger re-renders automatically"
        ]
    },
    {
        "q": "Which hook allows storing a mutable reference that does not trigger a re-render?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <span>Visible</span> : <span>Hidden</span>}</>;\n}\n<Toggle show={true} />",
        "o": [
            "Visible",
            "Hidden",
            "true",
            "undefined"
        ]
    },
    {
        "q": "Why should state not be mutated directly in React?",
        "o": [
            "Direct mutation can prevent React from detecting changes, causing UI inconsistencies",
            "Because JavaScript forbids object mutation",
            "Because props cannot be mutated",
            "Because it triggers syntax errors"
        ]
    },
    {
        "q": "Which hook is ideal for managing global state without prop drilling?",
        "o": [
            "useContext",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Greeting({ name }) {\n  return <>{name?.toUpperCase() ?? 'Guest'}</>;\n}\n<Greeting name='' />",
        "o": [
            "Guest",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is it important to provide a dependency array in useEffect?",
        "o": [
            "To control when the effect runs and avoid unnecessary executions or infinite loops",
            "Because React will throw an error otherwise",
            "To automatically memoize state values",
            "To prevent the component from rendering"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count > 0 ? 'Positive' : count < 0 ? 'Negative' : 'Zero'}</p>;\n}",
        "o": [
            "Zero",
            "Positive",
            "Negative",
            "undefined"
        ]
    },
    {
        "q": "Which hook is used to memoize a value to avoid expensive recalculations?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function User({ name }) {\n  return <>{name?.trim() || 'ANONYMOUS'}</>;\n}\n<User name={null} />",
        "o": [
            "ANONYMOUS",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why lift state up in React?",
        "o": [
            "To share state between multiple components through a common ancestor",
            "To avoid using props",
            "To prevent re-renders",
            "To replace useEffect"
        ]
    },
    {
        "q": "Which hook is used to memoize a function definition to avoid unnecessary re-creations?",
        "o": [
            "useCallback",
            "useMemo",
            "useState",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Status({ online }) {\n  return <>{online ? 'Online' : 'Offline'}</>;\n}\n<Status online={false} />",
        "o": [
            "Offline",
            "Online",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Why should you avoid direct mutation of state in React?",
        "o": [
            "Direct mutation may not trigger re-renders and can cause unexpected UI behavior",
            "Because JavaScript forbids object mutation",
            "Because props cannot be mutated",
            "Because it triggers syntax errors"
        ]
    },
    {
        "q": "Which hook is used to handle side effects like fetching data in functional components?",
        "o": [
            "useEffect",
            "useState",
            "useRef",
            "useMemo"
        ]
    },
    {
        "q": "What will this component render?",
        "c": "function Message({ text }) {\n  return <>{text?.length ? text : 'No message'}</>;\n}\n<Message text='Hello World' />",
        "o": [
            "Hello World",
            "No message",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is useRef useful in React?",
        "o": [
            "It allows storing a mutable value that persists across renders without causing re-renders",
            "It automatically updates state",
            "It memoizes a function",
            "It replaces useEffect"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Toggle({ show }) {\n  return <>{show ? <span>Visible</span> : <span>Hidden</span>}</>;\n}\n<Toggle show={false} />",
        "o": [
            "Hidden",
            "Visible",
            "false",
            "undefined"
        ]
    },
    {
        "q": "Which hook is useful to defer updates for non-urgent UI changes?",
        "o": [
            "useDeferredValue",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What will this component display?",
        "c": "function Status({ active }) {\n  return <>{active ?? 'Inactive'}</>;\n}\n<Status active={0} />",
        "o": [
            "0",
            "Inactive",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why use React.memo?",
        "o": [
            "To prevent unnecessary re-renders of functional components when props do not change",
            "To automatically update state",
            "To replace useEffect",
            "To memoize state values"
        ]
    },
    {
        "q": "Which hook helps to perform expensive calculations only when certain dependencies change?",
        "o": [
            "useMemo",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "What will this render?",
        "c": "function Counter() {\n  const [count, setCount] = useState(0);\n  return <p>{count % 2 === 0 ? 'Even' : 'Odd'}</p>;\n}",
        "o": [
            "Even",
            "Odd",
            "0",
            "Undefined"
        ]
    },
    {
        "q": "Why should state not be mutated directly in React?",
        "o": [
            "Because it may not trigger re-renders, leading to inconsistent UI",
            "Because JavaScript forbids mutation",
            "Because props cannot be mutated",
            "Because it triggers syntax errors"
        ]
    },
  {
    "q": "What will be the initial value of 'count' in the following React code?",
    "c": "const [count, setCount] = React.useState(() => 5 * 2);",
    "o": [
      "10",
      "5",
      "undefined",
      "NaN"
    ]
  },
  {
    "q": "Which lifecycle method in class components is most similar to useEffect(() => {}, []) in functional components?",
    "o": [
      "componentDidMount",
      "componentWillUnmount",
      "shouldComponentUpdate",
      "getDerivedStateFromProps"
    ]
  },
  {
    "q": "In React, which of the following statements about state updates is true?",
    "o": [
      "State updates are asynchronous and may be batched for performance.",
      "State updates always happen immediately and synchronously.",
      "State updates cannot be batched by React.",
      "State can only be updated once per component render."
    ]
  },
  {
    "q": "What is the correct way to conditionally render a component in React?",
    "c": "{isVisible && <MyComponent />}",
    "o": [
      "Renders MyComponent if isVisible is true",
      "Always renders MyComponent",
      "Throws an error if isVisible is false",
      "Returns null if isVisible is true"
    ]
  },
  {
    "q": "What will happen when calling setState multiple times synchronously inside a function?",
    "o": [
      "React may batch them into a single update for performance.",
      "Each call will update the state immediately one after another.",
      "The last call will be ignored by React.",
      "It will cause an infinite render loop."
    ]
  },
  {
    "q": "Which hook would you use to replicate componentWillUnmount behavior in a functional component?",
    "c": "useEffect(() => { return () => { console.log('cleanup'); }; }, []);",
    "o": [
      "useEffect with a cleanup function",
      "useLayoutEffect without dependencies",
      "useState with an initial callback",
      "useMemo with an empty dependency array"
    ]
  },
  {
    "q": "Which of the following best describes props in React?",
    "o": [
      "Props are immutable inputs passed from parent to child components.",
      "Props are mutable values stored inside the component itself.",
      "Props are global variables accessible by all components.",
      "Props can only be used in class components, not in functional components."
    ]
  },
  {
    "q": "What will be logged in the console after the following code runs?",
    "c": "const [count, setCount] = React.useState(0);\nsetCount(count + 1);\nconsole.log(count);",
    "o": [
      "0",
      "1",
      "undefined",
      "It will throw an error"
    ]
  },
  {
    "q": "Which lifecycle method is invoked right before the component is removed from the DOM?",
    "o": [
      "componentWillUnmount",
      "componentDidMount",
      "componentDidUpdate",
      "getSnapshotBeforeUpdate"
    ]
  },
  {
    "q": "Which of the following is the correct way to update state based on previous state?",
    "c": "setCount(prev => prev + 1);",
    "o": [
      "Using a functional updater",
      "Directly mutating the state object",
      "Using setCount(count + 1) inside a loop always",
      "Using Object.assign on the state"
    ]
  },
  {
    "q": "Which of the following correctly initializes state with useState in React?",
    "o": [
      "const [value, setValue] = useState('hello');",
      "const value = useState('hello');",
      "const {value, setValue} = useState('hello');",
      "const [value] = useState('hello', setValue);"
    ]
  },
  {
    "q": "What is the key difference between useEffect and useLayoutEffect?",
    "o": [
      "useEffect runs asynchronously after paint, while useLayoutEffect runs synchronously before paint.",
      "useEffect always blocks the paint until finished, while useLayoutEffect does not.",
      "useEffect can only be used in class components, while useLayoutEffect can only be used in functional components.",
      "There is no difference; they behave identically."
    ]
  },
  {
    "q": "What will be rendered by this code snippet?",
    "c": "function App() {\n  const [visible, setVisible] = React.useState(false);\n  return (\n    <div>\n      {visible ? <p>Visible</p> : <p>Hidden</p>}\n    </div>\n  );\n}",
    "o": [
      "Hidden",
      "Visible",
      "Nothing",
      "Error: visible is not defined"
    ]
  },
  {
    "q": "Which method in class components is invoked after a component has been rendered to the DOM?",
    "o": [
      "componentDidMount",
      "componentDidUpdate",
      "componentWillUnmount",
      "constructor"
    ]
  },
  {
    "q": "When passing props to a component, how should default values be set?",
    "o": [
      "By defining defaultProps or using default function parameters",
      "By assigning them inside the render method",
      "By mutating props directly inside the component",
      "By adding them to the component’s state automatically"
    ]
  },
  {
    "q": "What will happen in this example?",
    "c": "const [count, setCount] = React.useState(0);\nsetCount(count + 1);\nsetCount(count + 1);\nconsole.log(count);",
    "o": [
      "0",
      "1",
      "2",
      "It will throw an error"
    ]
  },
  {
    "q": "Which of the following is true about conditional rendering in React?",
    "o": [
      "It can be achieved using JavaScript logical operators, ternary operators, or if statements.",
      "It requires a special React API for conditional rendering.",
      "It can only be done inside class components.",
      "It forces a full re-render of all components."
    ]
  },
  {
    "q": "What will the following code render?",
    "c": "function Greeting({ name }) {\n  return <h1>Hello, {name}</h1>;\n}\n<Greeting name={undefined} />",
    "o": [
      "Hello, ",
      "Hello, undefined",
      "Error: name is not defined",
      "Nothing"
    ]
  },
  {
    "q": "Which hook would you use to persist a value across renders without causing re-renders?",
    "o": [
      "useRef",
      "useState",
      "useEffect",
      "useMemo"
    ]
  },
  {
    "q": "What happens if you call setState with the same value as the current state?",
    "o": [
      "React will bail out and not trigger a re-render.",
      "React will always re-render regardless.",
      "React will throw a warning about redundant updates.",
      "It causes an infinite loop."
    ]
  },
  {
    "q": "What is the correct way to pass a callback function as a prop in React?",
    "o": [
      "<Child onClick={handleClick} />",
      "<Child onClick={handleClick()} />",
      "<Child onClick='handleClick' />",
      "<Child onClick={function handleClick} />"
    ]
  },
  {
    "q": "Which lifecycle method in class components is called after state or props change and the component re-renders?",
    "o": [
      "componentDidUpdate",
      "componentDidMount",
      "componentWillUnmount",
      "getDerivedStateFromProps"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount(count + 1);\n  }, []);\n  return <p>{count}</p>;\n}",
    "o": [
      "1",
      "0",
      "It will keep incrementing infinitely",
      "Error: Too many re-renders"
    ]
  },
  {
    "q": "Which of the following is true about props and state in React?",
    "o": [
      "Props are read-only, while state can be updated using setState or hooks.",
      "Both props and state are mutable values owned by the component.",
      "State is passed from parent to child, while props are managed internally.",
      "Props and state are identical and interchangeable."
    ]
  },
  {
    "q": "What will be rendered here?",
    "c": "function App() {\n  const [flag, setFlag] = React.useState(true);\n  return (\n    <div>{flag && 'Hello World'}</div>\n  );\n}",
    "o": [
      "Hello World",
      "true",
      "Nothing",
      "Error: invalid conditional"
    ]
  },
  {
    "q": "What happens if you update state inside useEffect without providing a dependency array?",
    "o": [
      "It may cause an infinite loop of renders.",
      "It will update state only once after mount.",
      "It will throw an error because dependencies are required.",
      "It will never update the state."
    ]
  },
  {
    "q": "Which hook is best suited for memoizing expensive calculations?",
    "o": [
      "useMemo",
      "useCallback",
      "useRef",
      "useReducer"
    ]
  },
  {
    "q": "What will this code log to the console?",
    "c": "const [value, setValue] = React.useState(0);\nsetValue(prev => prev + 1);\nsetValue(prev => prev + 1);\nconsole.log(value);",
    "o": [
      "0",
      "1",
      "2",
      "undefined"
    ]
  },
  {
    "q": "Which lifecycle method is invoked before the latest render output is committed to the DOM?",
    "o": [
      "getSnapshotBeforeUpdate",
      "componentDidUpdate",
      "componentDidMount",
      "componentWillUnmount"
    ]
  },
  {
    "q": "What will be displayed in this example?",
    "c": "function User({name}) {\n  return <p>{name || 'Guest'}</p>;\n}\n<User />",
    "o": [
      "Guest",
      "undefined",
      "Error: name is not defined",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following best describes the relationship between useState and re-rendering?",
    "o": [
      "Calling the state setter triggers a re-render of the component.",
      "useState updates the variable directly without re-rendering.",
      "useState can only update values inside useEffect, not during render.",
      "The state setter only updates after all children finish rendering."
    ]
  },
  {
    "q": "What will the following component render initially?",
    "c": "function App() {\n  const [text] = React.useState(() => 'Hello' + ' React');\n  return <h1>{text}</h1>;\n}",
    "o": [
      "Hello React",
      "Hello",
      "React",
      "undefined"
    ]
  },
  {
    "q": "Which lifecycle method is the best place to add event listeners in a class component?",
    "o": [
      "componentDidMount",
      "constructor",
      "componentWillUnmount",
      "render"
    ]
  },
  {
    "q": "What is the effect of passing an empty array as the second argument to useEffect?",
    "o": [
      "The effect runs only once after the initial render.",
      "The effect runs after every render.",
      "The effect never runs.",
      "The effect runs only when state changes."
    ]
  },
  {
    "q": "What will the following code display?",
    "c": "function App() {\n  const [num, setNum] = React.useState(5);\n  return <p>{num > 10 ? 'Big' : 'Small'}</p>;\n}",
    "o": [
      "Small",
      "Big",
      "5",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is true about state updates using setState in class components?",
    "o": [
      "Multiple setState calls may be batched together for performance.",
      "setState is always synchronous.",
      "setState must be called only once in a lifecycle method.",
      "setState completely replaces the component instance."
    ]
  },
  {
    "q": "What will the following snippet render?",
    "c": "function App() {\n  const [flag, setFlag] = React.useState(false);\n  return <div>{flag ? <span>Yes</span> : <span>No</span>}</div>;\n}",
    "o": [
      "No",
      "Yes",
      "Nothing",
      "true"
    ]
  },
  {
    "q": "Which hook helps memoize callback functions to prevent unnecessary re-creations?",
    "o": [
      "useCallback",
      "useMemo",
      "useEffect",
      "useRef"
    ]
  },
  {
    "q": "What is the correct way to pass multiple props to a React component?",
    "o": [
      "<MyComponent title='Hello' count={5} />",
      "<MyComponent {title='Hello', count=5} />",
      "<MyComponent props={{title: 'Hello', count: 5}} />",
      "<MyComponent: title='Hello', count=5 />"
    ]
  },
  {
    "q": "What happens if you forget to clean up side effects (e.g., event listeners) in useEffect?",
    "o": [
      "It may cause memory leaks and unexpected behavior.",
      "React will automatically clean up all side effects.",
      "The app will not compile.",
      "It will only affect server-side rendering."
    ]
  },
  {
    "q": "Which of the following correctly describes how props differ from state in React?",
    "o": [
      "Props are passed from parent to child, while state is managed within the component.",
      "Props are mutable values, while state is immutable.",
      "Props are only available in functional components, while state is only in class components.",
      "Props and state are both mutable values that persist across re-renders."
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function App() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => setCount(5), []);\n  return <p>{count}</p>;\n}",
    "o": [
      "5",
      "0",
      "undefined",
      "It will keep updating infinitely"
    ]
  },
  {
    "q": "Which lifecycle method is used in class components to perform cleanup logic such as removing subscriptions?",
    "o": [
      "componentWillUnmount",
      "componentDidMount",
      "componentDidUpdate",
      "getSnapshotBeforeUpdate"
    ]
  },
  {
    "q": "What will be displayed when rendering this component?",
    "c": "function Greeting({ name }) {\n  return <h2>{name ?? 'Anonymous'}</h2>;\n}\n<Greeting name={null} />",
    "o": [
      "Anonymous",
      "null",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about conditional rendering in React?",
    "o": [
      "It can use ternary operators, logical &&, or standard if statements inside JSX.",
      "It requires a special conditionalRender() method provided by React.",
      "It only works with boolean values and cannot use expressions.",
      "It forces React to re-render the entire tree."
    ]
  },
  {
    "q": "What happens if you call setState in componentDidUpdate without a condition?",
    "o": [
      "It causes an infinite re-render loop.",
      "It will throw an error at runtime.",
      "React will ignore the update automatically.",
      "It only updates once and stops."
    ]
  },
  {
    "q": "What will be displayed when rendering this code?",
    "c": "function App() {\n  const [val] = React.useState(() => 42);\n  return <div>{val > 50 ? 'High' : 'Low'}</div>;\n}",
    "o": [
      "Low",
      "High",
      "42",
      "undefined"
    ]
  },
  {
    "q": "Which hook would you use to reduce complex state logic into a predictable state machine?",
    "o": [
      "useReducer",
      "useState",
      "useMemo",
      "useCallback"
    ]
  },
  {
    "q": "What will the following log?",
    "c": "const [count, setCount] = React.useState(1);\nsetCount(count + 1);\nsetCount(count + 1);\nconsole.log(count);",
    "o": [
      "1",
      "2",
      "3",
      "undefined"
    ]
  },
  {
    "q": "Which lifecycle method runs immediately before the component is removed from the DOM?",
    "o": [
      "componentWillUnmount",
      "componentDidMount",
      "componentDidUpdate",
      "render"
    ]
  },
  {
    "q": "Which of the following best describes how React handles state updates?",
    "o": [
      "React batches state updates and applies them before re-rendering.",
      "React applies each state update immediately in sequence.",
      "React always ignores duplicate setState calls.",
      "React prevents multiple state updates within a single render cycle."
    ]
  },
  {
    "q": "What will be rendered here?",
    "c": "function App() {\n  const [msg, setMsg] = React.useState('Hi');\n  return <div>{msg && 'Hello'}</div>;\n}",
    "o": [
      "Hello",
      "Hi",
      "Nothing",
      "Error"
    ]
  },
  {
    "q": "Which lifecycle method is invoked when props change but before rendering?",
    "o": [
      "getDerivedStateFromProps",
      "componentDidUpdate",
      "componentWillUnmount",
      "componentDidMount"
    ]
  },
  {
    "q": "What is the main purpose of useMemo in React?",
    "o": [
      "To memoize expensive calculations and avoid recalculating on every render.",
      "To store mutable references across renders without causing re-renders.",
      "To perform side effects after render.",
      "To reduce complex state transitions into actions."
    ]
  },
  {
    "q": "What will the following code render?",
    "c": "function Show({ number }) {\n  return <span>{number || 'Zero'}</span>;\n}\n<Show number={0} />",
    "o": [
      "Zero",
      "0",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about props in React?",
    "o": [
      "Props are immutable and should not be modified inside the component.",
      "Props can be reassigned within the component for optimization.",
      "Props behave exactly like useState variables.",
      "Props can only be strings or numbers."
    ]
  },
  {
    "q": "What happens when you call setCount(count + 1) twice inside the same render cycle?",
    "o": [
      "React may batch them and update the state only once.",
      "React guarantees the state will be incremented twice.",
      "React will throw a duplicate update error.",
      "The component will crash."
    ]
  },
  {
    "q": "Which lifecycle method is used to execute logic right after a component’s update is flushed to the DOM?",
    "o": [
      "componentDidUpdate",
      "getDerivedStateFromProps",
      "componentWillUnmount",
      "constructor"
    ]
  },
  {
    "q": "What will this code render?",
    "c": "function App() {\n  const [ready] = React.useState(false);\n  return <div>{ready ? 'Go' : 'Stop'}</div>;\n}",
    "o": [
      "Stop",
      "Go",
      "true",
      "Nothing"
    ]
  },
  {
    "q": "Which hook should be used to store a value that persists across renders but does not trigger a re-render?",
    "o": [
      "useRef",
      "useState",
      "useEffect",
      "useMemo"
    ]
  },
  {
    "q": "Which of the following best describes how functional components handle state?",
    "o": [
      "They use hooks like useState and useReducer to manage state.",
      "They rely entirely on class lifecycle methods to manage state.",
      "They cannot handle state directly and must always use props.",
      "They store state in global variables by default."
    ]
  },
  {
    "q": "What will be rendered by this component?",
    "c": "function App() {\n  const [value] = React.useState('');\n  return <p>{value || 'Empty'}</p>;\n}",
    "o": [
      "Empty",
      "''",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which lifecycle method is commonly used to fetch data after the component is mounted?",
    "o": [
      "componentDidMount",
      "componentWillUnmount",
      "getDerivedStateFromProps",
      "render"
    ]
  },
  {
    "q": "What is the result of calling setState with an object in a class component?",
    "o": [
      "The provided object is shallow merged with the existing state.",
      "The provided object completely replaces the entire state.",
      "It throws an error because state must be updated immutably.",
      "It queues the update but does not affect state."
    ]
  },
  {
    "q": "What will be displayed here?",
    "c": "function Status({ online }) {\n  return <h3>{online ? 'Online' : 'Offline'}</h3>;\n}\n<Status online={false} />",
    "o": [
      "Offline",
      "Online",
      "false",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about useEffect with dependencies?",
    "o": [
      "The effect runs again whenever one of the dependencies changes.",
      "The effect runs only once no matter what.",
      "The effect ignores dependencies unless explicitly cleaned up.",
      "Dependencies can only be primitive values, not objects."
    ]
  },
  {
    "q": "What will be displayed by this code?",
    "c": "function App() {\n  const [num, setNum] = React.useState(10);\n  return <span>{num === 10 && 'Ten'}</span>;\n}",
    "o": [
      "Ten",
      "10",
      "true",
      "Nothing"
    ]
  },
  {
    "q": "Which hook is specifically designed to optimize performance by memoizing event handlers?",
    "o": [
      "useCallback",
      "useMemo",
      "useReducer",
      "useRef"
    ]
  },
  {
    "q": "Which lifecycle method is executed right before the DOM updates with new values?",
    "o": [
      "getSnapshotBeforeUpdate",
      "componentDidUpdate",
      "componentWillUnmount",
      "componentDidMount"
    ]
  },
  {
    "q": "What happens if you directly mutate the state object instead of using setState or the updater function?",
    "o": [
      "React will not detect the change and the component will not re-render.",
      "React will automatically re-render with the new value.",
      "It causes a runtime error immediately.",
      "It forces React to re-render the entire application."
    ]
  },
  {
    "q": "A parent passes a prop `items` (an array) to a child. The child sorts `items` directly with `items.sort()`. What is the main issue?",
    "o": [
      "Props should be treated as immutable and must not be mutated.",
      "Sorting will cause React to re-render infinitely.",
      "Arrays cannot be passed as props in React.",
      "Props are copied, so mutating them has no effect."
    ]
  },
  {
    "q": "If a component uses `useState` inside a loop or conditional, what happens?",
    "o": [
      "It breaks the Rules of Hooks and React will throw an error.",
      "It works only if the loop executes once.",
      "It creates a new hook instance each iteration safely.",
      "It is allowed as long as the state setter is not called."
    ]
  },
  {
    "q": "Which of the following can cause 'Too many re-renders' error in React?",
    "o": [
      "Calling a state setter unconditionally inside the render body.",
      "Using useEffect with an empty dependency array.",
      "Passing props without default values.",
      "Rendering a component without returning JSX."
    ]
  },
  {
    "q": "A component re-renders even though props and state have not changed. What is the MOST likely cause?",
    "o": [
      "The parent re-rendered and passed a new object/array reference as a prop.",
      "React has a bug in its reconciliation process.",
      "The component has no key assigned.",
      "The component uses useEffect with [] dependencies."
    ]
  },
  {
    "q": "Given a component with `useEffect(() => { setCount(count + 1); }, [count]);`, what happens?",
    "o": [
      "It causes an infinite re-render loop.",
      "It updates count once after mount and then stops.",
      "It throws an error because setCount is not allowed inside useEffect.",
      "It ignores the update because count is already tracked."
    ]
  },
  {
    "q": "Why is using index as a key in a list generally discouraged?",
    "o": [
      "It can cause incorrect component reuse and lead to UI bugs when the list changes.",
      "It throws a runtime error immediately.",
      "It prevents React from rendering any items.",
      "It forces React to re-render all items regardless of changes."
    ]
  },
  {
    "q": "Which statement is TRUE about `useReducer` compared to `useState`?",
    "o": [
      "useReducer is preferable when state transitions are complex and involve multiple actions.",
      "useReducer is faster in all cases and should always replace useState.",
      "useReducer can only be used inside class components.",
      "useReducer automatically prevents re-renders."
    ]
  },
  {
    "q": "When passing a callback function to a child via props, why might you wrap it with useCallback?",
    "o": [
      "To prevent the child from receiving a new function reference on every render.",
      "To execute the function only once.",
      "To force the function to always run synchronously.",
      "To ensure the callback always has the latest state."
    ]
  },
  {
    "q": "Which of the following will NOT trigger a re-render in React?",
    "o": [
      "Updating a value stored in useRef",
      "Updating state with setState",
      "Receiving new props from a parent",
      "Calling the state setter from useReducer"
    ]
  },
  {
    "q": "Why does React batch multiple state updates inside event handlers?",
    "o": [
      "To improve performance by minimizing re-renders.",
      "To ensure setState always updates synchronously.",
      "To prevent React from updating state variables.",
      "To allow state updates only once per render cycle."
    ]
  },
  {
    "q": "What problem does 'lifting state up' in React primarily solve?",
    "o": [
      "Sharing a single source of truth across multiple child components.",
      "Avoiding the need to pass props from parent to child.",
      "Preventing unnecessary re-renders by freezing state.",
      "Allowing state to persist after a component unmounts."
    ]
  },
  {
    "q": "Why is it considered an anti-pattern to copy props into state without a specific reason?",
    "o": [
      "It can cause the state to become out of sync with props.",
      "It causes React to throw a runtime error.",
      "It prevents the component from re-rendering when props change.",
      "Props cannot be read inside useState."
    ]
  },
  {
    "q": "In a controlled input component, what determines the input's displayed value?",
    "o": [
      "The React state variable passed to its value prop.",
      "The user's keyboard input directly.",
      "The defaultValue prop on the input.",
      "The DOM manages the value independently of React."
    ]
  },
  {
    "q": "What issue arises when passing props through multiple layers of components unnecessarily?",
    "o": [
      "Prop drilling, which makes components harder to maintain.",
      "State duplication, which React disallows.",
      "Memory leaks, since props cannot be garbage-collected.",
      "Circular dependencies between parent and child."
    ]
  },
  {
    "q": "Which of the following is TRUE about lazy initialization with useState?",
    "o": [
      "If you pass a function to useState, it runs only once to calculate the initial state.",
      "The initializer function runs every time the component re-renders.",
      "Lazy initialization only works with primitive values, not objects.",
      "It prevents re-renders entirely."
    ]
  },
  {
    "q": "When using React.StrictMode in development, how does it affect state initialization?",
    "o": [
      "React intentionally calls state initializer functions twice to help detect side effects.",
      "React prevents setState from being called until after mount.",
      "React disables the use of lazy initialization.",
      "React forces all state variables to reset on every render."
    ]
  },
  {
    "q": "Which statement about defaultProps in React is correct?",
    "o": [
      "They provide fallback values for props when none are passed.",
      "They override explicitly passed props with defaults.",
      "They can only be used in class components, not functional components.",
      "They are required for every component by React."
    ]
  },
  {
    "q": "What is the key difference between controlled and uncontrolled form components?",
    "o": [
      "Controlled components store form data in React state, uncontrolled components rely on the DOM.",
      "Uncontrolled components support validation, controlled components do not.",
      "Controlled components cannot use event handlers, uncontrolled components must.",
      "There is no difference; the terms are interchangeable."
    ]
  },
  {
    "q": "Which of the following is a safe way to update deeply nested state in React?",
    "o": [
      "Creating a new copy using spread operators or immutability helpers.",
      "Mutating the object directly before calling setState.",
      "Using Object.assign to overwrite the nested state in place.",
      "Calling JSON.stringify and JSON.parse to clone state."
    ]
  },
  {
    "q": "Why should you avoid deriving state directly from props unless absolutely necessary?",
    "o": [
      "Because props may change while the derived state remains stale.",
      "Because React throws a warning for derived state.",
      "Because it prevents React from reconciling DOM nodes properly.",
      "Because props are always undefined inside useState."
    ]
  },
  {
    "q": "What happens when you provide a different `key` prop to the same component type in React?",
    "o": [
      "React unmounts the old instance and mounts a new one, resetting its state.",
      "React preserves the state and only updates props.",
      "React ignores the key change and reuses the old component.",
      "React throws an error because keys cannot change."
    ]
  },
  {
    "q": "What will be displayed by this component?",
    "c": "function InputBox() {\n  const [text, setText] = React.useState('Hello');\n  return <input value={text} />;\n}",
    "o": [
      "An input box showing 'Hello' that cannot be edited",
      "An empty input box",
      "An editable input box with 'Hello'",
      "Nothing will render"
    ]
  },
  {
    "q": "Why might uncontrolled inputs be easier to integrate with third-party libraries?",
    "o": [
      "Because their value is managed by the DOM, not React state.",
      "Because they use fewer hooks internally.",
      "Because they always run faster than controlled components.",
      "Because they bypass React’s reconciliation."
    ]
  },
  {
    "q": "What happens if you mutate state directly instead of using the state setter?",
    "o": [
      "The component will not re-render, leading to stale UI.",
      "React automatically detects mutation and re-renders.",
      "React throws a runtime error immediately.",
      "State updates are applied only after componentDidUpdate."
    ]
  },
  {
    "q": "What will this code render?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  setCount(count + 1);\n  return <p>{count}</p>;\n}",
    "o": [
      "It will throw 'Too many re-renders' error",
      "0",
      "1",
      "Infinite loop of increasing numbers"
    ]
  },
  {
    "q": "Which of the following is TRUE about prop drilling?",
    "o": [
      "It happens when props are passed through many intermediate components unnecessarily.",
      "It refers to mutating props directly in a child.",
      "It occurs when props are converted into state.",
      "It means assigning props to default values."
    ]
  },
  {
    "q": "What will this code log?",
    "c": "function App() {\n  const [num, setNum] = React.useState(() => 5);\n  React.useEffect(() => {\n    setNum(num + 1);\n  }, []);\n  console.log(num);\n  return <p>{num}</p>;\n}",
    "o": [
      "5 in the console, UI shows 6",
      "6 in the console, UI shows 6",
      "6 in the console, UI shows 5",
      "It causes an infinite re-render loop"
    ]
  },
  {
    "q": "What is the recommended way to set default values for props in functional components?",
    "o": [
      "Using default function parameters",
      "Using defaultProps static property",
      "Mutating props inside useEffect",
      "Assigning defaults in the parent’s state"
    ]
  },
  {
    "q": "What happens if two sibling components both maintain their own independent copy of the same state value?",
    "o": [
      "They can become inconsistent if not lifted to a common parent.",
      "React automatically synchronizes them.",
      "They throw a warning about duplicated state.",
      "They share a single state by default."
    ]
  },
  {
    "q": "What will be displayed here?",
    "c": "function Status({ online }) {\n  return <h2>{online ? 'Online' : 'Offline'}</h2>;\n}\n<Status />",
    "o": [
      "Offline",
      "Online",
      "undefined",
      "Error: missing prop 'online'"
    ]
  },
  {
    "q": "What will happen when the parent component re-renders in this code?",
    "c": "function Parent() {\n  const [count, setCount] = React.useState(0);\n  return <Child items={[1,2,3]} />;\n}\nfunction Child({ items }) {\n  console.log('Child rendered');\n  return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;\n}",
    "o": [
      "Child will re-render every time Parent renders because a new array reference is passed.",
      "Child will never re-render after the first render.",
      "Child re-renders only if items array content changes.",
      "React throws an error because arrays cannot be passed as props."
    ]
  },
  {
    "q": "What is the correct way to reset state to its initial value when a component remounts?",
    "o": [
      "Use a key on the component to force unmount/mount.",
      "Call setState with null inside useEffect.",
      "Directly mutate the state object.",
      "Use useRef to store the initial value."
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function Input() {\n  const [text, setText] = React.useState('');\n  return <input defaultValue='Hello' value={text} onChange={e => setText(e.target.value)} />;\n}",
    "o": [
      "An input controlled by React state, initially empty",
      "An uncontrolled input with value 'Hello'",
      "It throws an error because defaultValue and value are both set",
      "An input that always displays 'Hello'"
    ]
  },
  {
    "q": "Which is a consequence of directly mutating a nested state object in React?",
    "o": [
      "React may not detect the change, so the component will not re-render.",
      "React automatically creates a copy of the object.",
      "It triggers a deep re-render of the entire component tree.",
      "It is allowed if using useRef instead of useState."
    ]
  },
  {
    "q": "What will be logged when this component mounts?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(() => {\n    console.log('init');\n    return 0;\n  });\n  return <p>{count}</p>;\n}",
    "o": [
      "'init' is logged once during mount",
      "'init' is logged every render",
      "Nothing is logged",
      "React throws an error"
    ]
  },
  {
    "q": "Why should props be considered immutable inside a child component?",
    "o": [
      "Mutating props breaks React’s unidirectional data flow and can cause unexpected behavior.",
      "Props are automatically copied into state, so mutating is useless.",
      "Props are global variables and cannot be changed.",
      "React will ignore any changes made to props."
    ]
  },
  {
    "q": "What is the main risk of using derived state from props?",
    "o": [
      "The derived state may become out of sync with props if props change after initialization.",
      "It forces the component to re-render twice per update.",
      "Derived state cannot be used in functional components.",
      "React automatically resets derived state on every render."
    ]
  },
  {
    "q": "What will be displayed when this code runs?",
    "c": "function Message({ text }) {\n  return <p>{text ?? 'Default message'}</p>;\n}\n<Message text={null} />",
    "o": [
      "Default message",
      "null",
      "undefined",
      "Error: text is null"
    ]
  },
  {
    "q": "Which of the following is a common solution to avoid prop drilling?",
    "o": [
      "Using Context API or state management libraries.",
      "Passing props through more intermediate components.",
      "Using defaultProps in every component.",
      "Mutating props inside children components."
    ]
  },
  {
    "q": "What will be rendered here?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    const id = setInterval(() => setCount(c => c + 1), 1000);\n    return () => clearInterval(id);\n  }, []);\n  return <p>{count}</p>;\n}",
    "o": [
      "A counter that increments every second",
      "A static 0 that never changes",
      "Infinite re-render causing crash",
      "It logs an error due to missing dependencies"
    ]
  },
  {
    "q": "What will happen when this component renders?",
    "c": "function App() {\n  const [count, setCount] = React.useState(0);\n  setCount(count + 1);\n  setCount(count + 1);\n  return <p>{count}</p>;\n}",
    "o": [
      "It will throw 'Too many re-renders' error",
      "It will render 2 and stop",
      "It will render 1 and stop",
      "It will render 0 and never change"
    ]
  },
  {
    "q": "Why is it unsafe to mutate objects or arrays stored in React state directly?",
    "o": [
      "React may not detect the change, preventing the component from re-rendering.",
      "It will always throw a runtime error.",
      "Mutating state directly automatically resets the component.",
      "React copies objects internally, so mutations are ignored."
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function Input() {\n  const [value, setValue] = React.useState('');\n  return <input defaultValue='Hello' value={value} onChange={e => setValue(e.target.value)} />;\n}",
    "o": [
      "An empty controlled input initially, user can type to update value",
      "An uncontrolled input with 'Hello' that cannot be changed",
      "An input showing 'Hello' that throws an error",
      "Nothing will render"
    ]
  },
  {
    "q": "Which of the following is a correct use case for lazy initialization with useState?",
    "o": [
      "When computing initial state is expensive and should run only once",
      "When the state needs to be reset on every render",
      "When state depends on props that never change",
      "When using useRef instead of useState"
    ]
  },
  {
    "q": "What will be displayed here?",
    "c": "function Message({ text }) {\n  return <p>{text ?? 'Default message'}</p>;\n}\n<Message text={null} />",
    "o": [
      "Default message",
      "null",
      "undefined",
      "Error: text is null"
    ]
  },
  {
    "q": "Which of the following can prevent unnecessary re-renders of a child component?",
    "o": [
      "Passing stable references (memoized functions/objects) via props and using React.memo",
      "Mutating the child props directly",
      "Creating new object/array props on every render",
      "Using uncontrolled components always"
    ]
  },
  {
    "q": "What is the effect of changing a component's `key` prop dynamically?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state.",
      "React reuses the component and preserves state.",
      "React ignores the key change and re-renders normally.",
      "It causes an error in strict mode."
    ]
  },
  {
    "q": "What will happen if a component copies props into state and never updates it afterwards?",
    "o": [
      "The state will not reflect subsequent prop changes, leading to stale data.",
      "The state will automatically sync with props.",
      "React will throw a warning in the console.",
      "Props will become immutable and cannot change."
    ]
  },
  {
    "q": "Why might prop drilling be considered a problem?",
    "o": [
      "It requires passing props through many intermediate components, making code harder to maintain.",
      "It breaks React’s rules of hooks.",
      "It prevents the use of defaultProps.",
      "It forces all children to re-render every second."
    ]
  },
  {
    "q": "Which of the following statements about controlled components is FALSE?",
    "o": [
      "They always require a value prop and onChange handler to update state.",
      "Their value is stored in React state and drives the input value.",
      "They cannot have default values.",
      "They allow validation logic to be implemented in React."
    ]
  },
  {
    "q": "What will happen when this component mounts?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(() => {\n    console.log('Initializing');\n    return 0;\n  });\n  return <p>{count}</p>;\n}",
    "o": [
      "'Initializing' is logged once and 0 is displayed",
      "'Initializing' is logged on every render",
      "Nothing is logged and 0 is displayed",
      "It throws an error due to lazy initialization"
    ]
  },
  {
    "q": "What is the recommended way to avoid unnecessary re-renders when passing functions as props?",
    "o": [
      "Wrap the function in useCallback to memoize its reference",
      "Always create a new function inline",
      "Use useMemo on the child component",
      "Mutate the function inside useEffect"
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function InputBox() {\n  const [text, setText] = React.useState('');\n  return <input value={text} onChange={() => setText('Hello')} />;\n}",
    "o": [
      "An input that always shows 'Hello' after first change",
      "An input that is empty and cannot be changed",
      "An input with initial value 'Hello'",
      "Nothing will render due to an error"
    ]
  },
  {
    "q": "Which of the following is a pitfall of copying props into state?",
    "o": [
      "State may become out of sync with updated props",
      "Props will not render in JSX",
      "It causes React to ignore children components",
      "It prevents useEffect from running"
    ]
  },
  {
    "q": "What will be displayed here?",
    "c": "function Status({ online }) {\n  return <p>{online ? 'Online' : 'Offline'}</p>;\n}\n<Status />",
    "o": [
      "Offline",
      "Online",
      "undefined",
      "Error due to missing prop"
    ]
  },
  {
    "q": "What happens when you mutate a nested object in state directly instead of creating a new copy?",
    "o": [
      "React may not detect the change, leading to stale UI",
      "React automatically triggers a deep re-render",
      "It throws an error in development mode",
      "It resets all sibling states"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization with useState?",
    "o": [
      "When calculating initial state is expensive and should run only once",
      "When the state needs to be updated every render",
      "When props never change",
      "When using useRef to store values"
    ]
  },
  {
    "q": "Which of the following is true about defaultProps in functional components?",
    "o": [
      "They can be set using default function parameters",
      "They override explicitly passed props",
      "They are required for every functional component",
      "They cannot be used with destructured props"
    ]
  },
  {
    "q": "What will be rendered when a child component receives a new object as prop every render?",
    "o": [
      "The child will re-render even if the object's content is unchanged",
      "The child will not re-render unless content changes",
      "React throws an error for object props",
      "The child component preserves previous state automatically"
    ]
  },
  {
    "q": "Why is prop drilling often considered problematic?",
    "o": [
      "It forces passing props through many intermediate components, increasing complexity",
      "It prevents state updates in parent components",
      "It disables useEffect hooks in children",
      "It is incompatible with controlled components"
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount(c => c + 1);\n    setCount(c => c + 1);\n  }, []);\n  return <p>{count}</p>;\n}",
    "o": [
      "2",
      "1",
      "0",
      "It will throw 'Too many re-renders' error"
    ]
  },
  {
    "q": "Which of the following is a common issue when copying props into state?",
    "o": [
      "The state may become stale and not reflect updated props",
      "It forces a component to remount on every render",
      "It prevents the use of defaultProps",
      "It automatically causes deep re-renders"
    ]
  },
  {
    "q": "What will happen when this component mounts?",
    "c": "function Input() {\n  const [value, setValue] = React.useState('');\n  return <input value={value} defaultValue='Hello' onChange={e => setValue(e.target.value)} />;\n}",
    "o": [
      "An empty controlled input initially, user can type to update value",
      "An uncontrolled input showing 'Hello'",
      "An input that throws an error due to both value and defaultValue",
      "Nothing will render"
    ]
  },
  {
    "q": "Why should state be treated as immutable?",
    "o": [
      "To ensure React can detect changes via shallow comparison and trigger re-renders",
      "Mutating state directly is always forbidden by JavaScript",
      "It prevents useEffect from running",
      "React automatically deep clones objects in state"
    ]
  },
  {
    "q": "What will this code render?",
    "c": "function Message({ text }) {\n  return <p>{text ?? 'Default Message'}</p>;\n}\n<Message text={undefined} />",
    "o": [
      "Default Message",
      "undefined",
      "Error: missing prop",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a safe way to pass functions to children to avoid unnecessary re-renders?",
    "o": [
      "Memoize the function with useCallback so the reference is stable",
      "Create a new function inline on every render",
      "Store the function in useRef without useCallback",
      "Wrap the function in useMemo instead of useCallback"
    ]
  },
  {
    "q": "What happens when a component receives a different `key` prop on rerender?",
    "o": [
      "React unmounts the previous component and mounts a new one, resetting state",
      "React preserves the component and only updates props",
      "The key change is ignored",
      "React throws a runtime error"
    ]
  },
  {
    "q": "What will be displayed by this component?",
    "c": "function Status({ online }) {\n  return <p>{online ? '✅ Online' : '❌ Offline'}</p>;\n}\n<Status />",
    "o": [
      "❌ Offline",
      "✅ Online",
      "undefined",
      "Error due to missing prop"
    ]
  },
  {
    "q": "Why is prop drilling often problematic?",
    "o": [
      "It requires passing props through many layers of components, making maintenance difficult",
      "It prevents state updates in the parent component",
      "It disables defaultProps in children",
      "It automatically causes re-renders of all siblings"
    ]
  },
  {
    "q": "What is the effect of using lazy initialization with useState?",
    "o": [
      "The initializer function runs only once on the first render to compute initial state",
      "It recalculates state on every render",
      "It prevents useEffect from running",
      "It forces the state to be reset on every re-render"
    ]
  },
  {
    "q": "What will be logged to the console?",
    "c": "function App() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount(count + 1);\n  }, []);\n  console.log(count);\n  return <p>{count}</p>;\n}",
    "o": [
      "0 is logged, UI shows 1",
      "1 is logged, UI shows 1",
      "0 is logged, UI shows 0",
      "Infinite loop occurs"
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function InputBox() {\n  const [text, setText] = React.useState('');\n  return <input value={text} onChange={() => setText('Hello')} />;\n}",
    "o": [
      "An input that shows 'Hello' after first change",
      "An empty input that cannot be changed",
      "Input initialized with 'Hello'",
      "Nothing renders due to error"
    ]
  },
  {
    "q": "Which of the following is a correct way to avoid unnecessary child re-renders?",
    "o": [
      "Memoize functions and objects passed as props and use React.memo on the child",
      "Pass a new function and new objects every render",
      "Mutate props inside the child",
      "Use defaultProps to freeze child props"
    ]
  },
  {
    "q": "Why is it discouraged to derive state directly from props without syncing?",
    "o": [
      "The derived state may become stale if props change",
      "It throws a runtime error",
      "It disables useEffect hooks",
      "React will ignore the derived state completely"
    ]
  },
  {
    "q": "What will be displayed by this component?",
    "c": "function Status({ online }) {\n  return <p>{online ?? 'Offline'}</p>;\n}\n<Status online={false} />",
    "o": [
      "false",
      "Offline",
      "undefined",
      "Error due to boolean prop"
    ]
  },
  {
    "q": "Which of the following is a benefit of using lazy initialization in useState?",
    "o": [
      "It prevents expensive initial state computation on every render",
      "It allows state to auto-update when props change",
      "It replaces useEffect entirely",
      "It disables re-renders triggered by state updates"
    ]
  },
  {
    "q": "What happens when a child receives a new object or array prop on each render?",
    "o": [
      "The child re-renders even if contents are unchanged",
      "React detects deep equality and prevents re-render",
      "The child ignores the prop",
      "It throws a runtime error"
    ]
  },
  {
    "q": "What is the effect of changing a component's key prop dynamically?",
    "o": [
      "React unmounts the previous component and mounts a new one, resetting state",
      "React updates props but preserves state",
      "Key changes are ignored",
      "It throws an error in strict mode"
    ]
  },
  {
    "q": "What is a potential issue with prop drilling?",
    "o": [
      "Props must be passed through many intermediate components, making maintenance harder",
      "Props cannot be used in children if drilling occurs",
      "It automatically triggers an infinite loop",
      "It disables defaultProps"
    ]
  },
  {
    "q": "Which statement about defaultProps in functional components is TRUE?",
    "o": [
      "They can be set using default function parameters",
      "They override explicitly passed props",
      "They are mandatory for all components",
      "They cannot be used with destructured props"
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount(c => c + 1);\n    setCount(c => c + 1);\n  }, []);\n  return <p>{count}</p>;\n}",
    "o": [
      "2",
      "1",
      "0",
      "It throws 'Too many re-renders' error"
    ]
  },
  {
    "q": "Which of the following is a problem with copying props into state?",
    "o": [
      "State may become stale and not reflect prop changes",
      "It causes a syntax error",
      "It prevents component mounting",
      "React automatically ignores copied props"
    ]
  },
  {
    "q": "What will this component render?",
    "c": "function InputBox() {\n  const [text, setText] = React.useState('');\n  return <input value={text} onChange={() => setText('Hello')} />;\n}",
    "o": [
      "An input showing 'Hello' after first change",
      "An empty input that cannot be edited",
      "An input initialized with 'Hello'",
      "Nothing renders due to an error"
    ]
  },
  {
    "q": "Why should React state be treated as immutable?",
    "o": [
      "So that React can detect changes and trigger re-renders efficiently",
      "Mutating state is forbidden in JavaScript",
      "It prevents useEffect from running",
      "React automatically clones all state objects"
    ]
  },
  {
    "q": "What will this component display?",
    "c": "function Message({ text }) {\n  return <p>{text ?? 'Default Message'}</p>;\n}\n<Message text={undefined} />",
    "o": [
      "Default Message",
      "undefined",
      "Error: missing prop",
      "Nothing"
    ]
  },
  {
    "q": "Which approach helps avoid unnecessary child re-renders?",
    "o": [
      "Memoizing functions/objects and using React.memo on the child",
      "Passing a new function or object each render",
      "Mutating child props directly",
      "Using uncontrolled components always"
    ]
  },
  {
    "q": "What happens when a component receives a different `key` prop on rerender?",
    "o": [
      "React unmounts the previous component and mounts a new one, resetting state",
      "React updates props but preserves state",
      "Key changes are ignored",
      "It throws a runtime error"
    ]
  },
  {
    "q": "What is the main benefit of lazy initialization with useState?",
    "o": [
      "Expensive initial state computation runs only once",
      "It prevents re-renders",
      "It syncs state automatically with props",
      "It replaces useEffect entirely"
    ]
  },
  {
    "q": "What is a common issue when passing new object/array props every render?",
    "o": [
      "Child re-renders unnecessarily even if contents are unchanged",
      "React detects deep equality and skips re-render",
      "It throws a runtime error",
      "Child state automatically resets"
    ]
  },
  {
    "q": "Why is prop drilling considered problematic?",
    "o": [
      "Props must pass through multiple intermediate components, increasing complexity",
      "It prevents state updates in the parent",
      "It disables defaultProps in children",
      "It triggers infinite loops automatically"
    ]
  },
  {
    "q": "What will be rendered when this component mounts?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount(c => c + 2);\n    setCount(c => c + 3);\n  }, []);\n  return <p>{count}</p>;\n}",
    "o": [
      "5",
      "2",
      "3",
      "It throws 'Too many re-renders' error"
    ]
  },
  {
    "q": "Which of the following is a risk when copying props into state without syncing?",
    "o": [
      "The state may become stale if props change later",
      "It causes React to throw an error",
      "The component will never render",
      "React ignores the copied state entirely"
    ]
  },
  {
    "q": "What will happen when this component renders?",
    "c": "function InputBox() {\n  const [text, setText] = React.useState('');\n  return <input value={text} onChange={() => setText('Hello')} />;\n}",
    "o": [
      "An input that shows 'Hello' after first change",
      "An empty input that cannot be edited",
      "An input initialized with 'Hello'",
      "Nothing renders due to an error"
    ]
  },
  {
    "q": "Why is immutability important when updating React state?",
    "o": [
      "It allows React to detect changes via shallow comparison and re-render efficiently",
      "Mutating state directly is forbidden in JavaScript",
      "It prevents all useEffect hooks from running",
      "React automatically clones all state objects if mutated"
    ]
  },
  {
    "q": "What will this code render?",
    "c": "function Message({ text }) {\n  return <p>{text ?? 'Default Message'}</p>;\n}\n<Message text={null} />",
    "o": [
      "Default Message",
      "null",
      "undefined",
      "Error due to null prop"
    ]
  },
  {
    "q": "Which approach helps prevent unnecessary child re-renders?",
    "o": [
      "Memoizing functions/objects and using React.memo on the child",
      "Passing a new function/array on each render",
      "Mutating props inside child components",
      "Always using uncontrolled components"
    ]
  },
  {
    "q": "What happens if a component's `key` prop changes dynamically?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state",
      "React preserves state and only updates props",
      "The key change is ignored",
      "It throws an error in strict mode"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization in useState?",
    "o": [
      "Expensive initial state computation that should run only once",
      "When the state must update on every render",
      "When props never change",
      "When useRef is being used"
    ]
  },
  {
    "q": "What is a potential problem when passing new object/array props on every render?",
    "o": [
      "Child components re-render unnecessarily even if contents are unchanged",
      "React automatically detects equality and prevents re-render",
      "It throws a runtime error",
      "Child state resets automatically"
    ]
  },
  {
    "q": "Why is prop drilling considered problematic?",
    "o": [
      "It requires passing props through many intermediate components, increasing code complexity",
      "It prevents state updates in parent components",
      "It disables defaultProps in children",
      "It triggers infinite re-renders automatically"
    ]
  },
  {
    "q": "What will happen when this component unmounts?",
    "c": "function Timer() {\n  const [seconds, setSeconds] = React.useState(0);\n  React.useEffect(() => {\n    const id = setInterval(() => setSeconds(s => s + 1), 1000);\n    return () => clearInterval(id);\n  }, []);\n  return <p>{seconds}</p>;\n}",
    "o": [
      "The interval will be cleared, preventing memory leaks",
      "The interval continues running even after unmount",
      "React throws an error for the interval",
      "The state resets to 0 automatically"
    ]
  },
  {
    "q": "Which of the following is a reason to use useRef instead of state?",
    "o": [
      "To store mutable values that don’t trigger re-renders",
      "To replace useEffect completely",
      "To automatically sync state with props",
      "To memoize expensive calculations"
    ]
  },
  {
    "q": "What will be rendered when this component mounts in React.StrictMode?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(() => {\n    console.log('Init');\n    return 0;\n  });\n  return <p>{count}</p>;\n}",
    "o": [
      "'Init' is logged twice due to StrictMode double rendering, UI shows 0",
      "'Init' is logged once, UI shows 0",
      "Nothing is logged, UI shows 0",
      "React throws an error"
    ]
  },
  {
    "q": "What is the proper way to update state based on previous state?",
    "o": [
      "Pass a function to the setter: setCount(prev => prev + 1)",
      "Directly read the state and call setState(count + 1)",
      "Mutate the state variable directly",
      "Use useRef to increment the value"
    ]
  },
  {
    "q": "Which of the following can cause a controlled input to become read-only unintentionally?",
    "o": [
      "Not updating the state in onChange handler",
      "Using defaultValue instead of value",
      "Not using useEffect",
      "Passing undefined as key"
    ]
  },
  {
    "q": "What is a safe way to derive state from props?",
    "o": [
      "Use props only to set initial state or update state in useEffect with dependency array",
      "Copy props into state unconditionally on every render",
      "Mutate props directly and store in state",
      "Use useRef to store props as state"
    ]
  },
  {
    "q": "What happens when a parent component re-renders and passes a new object prop to a memoized child?",
    "o": [
      "The child re-renders because shallow comparison sees a new object reference",
      "The child does not re-render if the content is identical",
      "React throws an error for passing new objects",
      "The child unmounts and remounts automatically"
    ]
  },
  {
    "q": "What happens if you call setState multiple times in a single event handler without using the functional form?",
    "o": [
      "Only the last setState value is applied because updates are batched",
      "Each setState is applied sequentially and immediately",
      "React throws 'Too many re-renders' error",
      "The component does not re-render at all"
    ]
  },
  {
    "q": "Which of the following is a subtle issue with derived state?",
    "o": [
      "It can become out-of-sync with props unless carefully synchronized",
      "It always triggers infinite re-renders",
      "React ignores derived state in functional components",
      "It prevents the use of useEffect"
    ]
  },
  {
    "q": "What will happen if you assign a new array to state directly using push() instead of creating a new array?",
    "o": [
      "React may not detect the change, and the component might not re-render",
      "The component will re-render automatically",
      "React throws an error in development mode",
      "The state resets to initial value"
    ]
  },
  {
    "q": "What will happen when this component mounts?",
    "c": "function App({ initialCount }) {\n  const [count, setCount] = React.useState(initialCount);\n  return <p>{count}</p>;\n}\n<App initialCount={5} />",
    "o": [
      "It renders 5 as initial count",
      "It renders 0 because useState ignores props",
      "It throws an error because initialCount is a prop",
      "It renders undefined"
    ]
  },
  {
    "q": "Which of the following is true about updating state in useEffect cleanup?",
    "o": [
      "You should avoid updating state in cleanup because the component is unmounting",
      "State updates in cleanup are always applied after unmount",
      "Cleanup automatically resets all state values",
      "Updating state in cleanup triggers a rerender of all parents"
    ]
  },
  {
    "q": "What happens when a controlled input does not update state in its onChange handler?",
    "o": [
      "The input becomes read-only and user cannot type",
      "The input works normally",
      "React throws an error",
      "The input resets to defaultValue automatically"
    ]
  },
  {
    "q": "What is the effect of React.StrictMode on functional component state initialization?",
    "o": [
      "State initializer functions are called twice to help detect side effects",
      "State is frozen and cannot be updated",
      "State is always reset on every render",
      "StrictMode has no effect on state initialization"
    ]
  },
  {
    "q": "What will happen if a child component receives a new object as prop every render, even if contents are identical?",
    "o": [
      "Child re-renders because shallow comparison detects a new reference",
      "Child does not re-render if the content is identical",
      "React throws an error",
      "Child state automatically resets"
    ]
  },
  {
    "q": "What is a safe way to handle derived state from props?",
    "o": [
      "Use props only to set initial state or update via useEffect with dependency array",
      "Copy props to state unconditionally on every render",
      "Mutate props and store them in state",
      "Use useRef to hold prop values as state"
    ]
  },
  {
    "q": "What happens if you call multiple setState calls in one handler without using the functional updater?",
    "o": [
      "Updates are batched and only the last value is applied",
      "Each setState applies sequentially immediately",
      "React throws 'Too many re-renders' error",
      "No re-render occurs"
    ]
  },
  {
    "q": "Which is a subtle problem with derived state in React?",
    "o": [
      "It can become stale if props change and state isn’t synced",
      "It always causes infinite re-renders",
      "React ignores derived state in functional components",
      "It disables useEffect hooks"
    ]
  },
  {
    "q": "What will happen if you mutate an array in state directly (e.g., using push) instead of creating a new array?",
    "o": [
      "React may not detect the change and component may not re-render",
      "Component re-renders automatically",
      "React throws an error",
      "State resets to initial value"
    ]
  },
  {
    "q": "Why might a component re-render unexpectedly when receiving new object props from a parent?",
    "o": [
      "Because shallow comparison detects a new reference, even if object contents are identical",
      "React detects deep equality and prevents re-render",
      "React only re-renders when state changes, not props",
      "Passing objects as props is disallowed"
    ]
  },
  {
    "q": "What will be the output when this component mounts?",
    "c": "function Counter() {\n  const [count, setCount] = React.useState(() => {\n    console.log('Init');\n    return 0;\n  });\n  return <p>{count}</p>;\n}",
    "o": [
      "'Init' is logged once (or twice in StrictMode), UI shows 0",
      "'Init' is logged on every render, UI shows 0",
      "Nothing is logged, UI shows 0",
      "React throws an error"
    ]
  },
  {
    "q": "Which of the following is the correct way to update state based on the previous state?",
    "o": [
      "setCount(prev => prev + 1)",
      "setCount(count + 1)",
      "count += 1",
      "useRef(count + 1)"
    ]
  },
  {
    "q": "What happens if a parent component passes a new object prop to a memoized child every render?",
    "o": [
      "The child re-renders because shallow comparison sees a new object reference",
      "The child does not re-render if the object content is the same",
      "React throws an error",
      "Child state resets automatically"
    ]
  },
  {
    "q": "What will happen if you call multiple setState calls in a single event handler without using the functional updater?",
    "o": [
      "Only the last setState value is applied because updates are batched",
      "Each setState applies immediately",
      "It throws 'Too many re-renders' error",
      "The component does not re-render"
    ]
  },
  {
    "q": "Why is directly mutating a nested state object in React problematic?",
    "o": [
      "React may not detect the change, causing the component to not re-render",
      "It always throws an error",
      "It automatically resets the state to initial value",
      "React clones the object internally"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization with useState?",
    "o": [
      "When computing initial state is expensive and should run only once",
      "When state must update every render",
      "When props never change",
      "When using useRef instead of state"
    ]
  },
  {
    "q": "What happens when a component's key prop changes dynamically?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state",
      "React updates props but preserves state",
      "Key change is ignored",
      "It throws an error"
    ]
  },
  {
    "q": "Which of the following can cause a controlled input to become read-only unexpectedly?",
    "o": [
      "Not updating state in the onChange handler",
      "Using value instead of defaultValue",
      "Not using useEffect",
      "Passing undefined as key"
    ]
  },
  {
    "q": "What is a subtle issue with derived state from props?",
    "o": [
      "It can become out-of-sync if props change and state isn’t synchronized",
      "It always causes infinite re-renders",
      "React ignores derived state in functional components",
      "It disables useEffect hooks"
    ]
  },
  {
    "q": "Why is prop drilling often considered problematic?",
    "o": [
      "Props must pass through multiple intermediate components, increasing complexity",
      "It prevents state updates in parents",
      "It disables defaultProps",
      "It triggers infinite re-renders automatically"
    ]
  },
  {
    "q": "What happens if you call setState inside a setTimeout after the component has unmounted?",
    "o": [
      "React ignores the update and may warn about a memory leak",
      "The state updates normally and re-renders the component",
      "React throws an error immediately",
      "The previous state is reset to initial value"
    ]
  },
  {
    "q": "Which of the following is the correct way to update a deeply nested object in state?",
    "o": [
      "Create a new object at each nested level to maintain immutability",
      "Directly mutate the nested object and call setState",
      "Use useRef instead of state for nested objects",
      "React automatically detects deep mutations"
    ]
  },
  {
    "q": "What happens when a state update is scheduled in React Concurrent Mode?",
    "o": [
      "Updates may be interrupted or delayed to allow higher-priority updates",
      "Updates are applied synchronously like normal mode",
      "React throws an error if concurrent mode is enabled",
      "State is frozen until all effects run"
    ]
  },
  {
    "q": "What happens if you call setState multiple times inside a setTimeout with the functional updater?",
    "o": [
      "Each update correctly calculates the new state based on previous state",
      "Only the last setState is applied",
      "React throws 'Too many re-renders' error",
      "The component never re-renders"
    ]
  },
  {
    "q": "What is a subtle problem with mixing controlled and uncontrolled inputs in the same component?",
    "o": [
      "React may issue a warning and input behavior can be unpredictable",
      "It automatically converts all inputs to uncontrolled",
      "It prevents useEffect from running",
      "State updates freeze permanently"
    ]
  },
  {
    "q": "Which of the following ensures a state update occurs only once on mount?",
    "o": [
      "Use lazy initialization function in useState",
      "Call setState directly in the component body",
      "Call setState in every render",
      "Use useRef instead of state"
    ]
  },
  {
    "q": "What happens if a parent re-renders and passes a new callback prop to a memoized child?",
    "o": [
      "The child re-renders because the function reference changed",
      "The child does not re-render because the function content is identical",
      "React throws an error for new function props",
      "The child unmounts and remounts automatically"
    ]
  },
  {
    "q": "What is the effect of using a key on a component to force remount?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state and effects",
      "React updates props but preserves previous state",
      "The key is ignored unless component is a class component",
      "It causes React to throw a runtime error"
    ]
  },
  {
    "q": "Why might derived state from props lead to stale values?",
    "o": [
      "If props change after the initial render and state isn’t synchronized in useEffect",
      "Derived state always updates automatically",
      "React ignores derived state in functional components",
      "Derived state disables onChange handlers in controlled inputs"
    ]
  },
  {
    "q": "Which of the following is a safe way to handle state that changes frequently in a form?",
    "o": [
      "Use controlled inputs with functional updates to state",
      "Mix controlled and uncontrolled inputs",
      "Store form values in refs only",
      "Update state outside of event handlers"
    ]
  },
  {
    "q": "What happens if you update state inside a setTimeout after the component unmounts?",
    "o": [
      "React ignores the update and may warn about a potential memory leak",
      "State updates normally and component re-renders",
      "React throws an error immediately",
      "Previous state resets to initial value"
    ]
  },
  {
    "q": "What is the recommended way to update a deeply nested object in state?",
    "o": [
      "Create a new object at each nested level to maintain immutability",
      "Directly mutate the nested object and call setState",
      "Store the nested object in a ref instead of state",
      "React automatically detects nested mutations"
    ]
  },
  {
    "q": "What is a subtle issue when mixing controlled and uncontrolled inputs in the same component?",
    "o": [
      "React may warn and input behavior can become unpredictable",
      "It automatically converts all inputs to uncontrolled",
      "It disables useEffect hooks",
      "State updates freeze permanently"
    ]
  },
  {
    "q": "What happens when a memoized child receives a new callback prop from its parent on each render?",
    "o": [
      "The child re-renders because the function reference changes",
      "The child does not re-render because function content is identical",
      "React throws an error",
      "The child unmounts and remounts automatically"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization with useState?",
    "o": [
      "When computing initial state is expensive and should run only once",
      "When state must update on every render",
      "When props never change",
      "When using useRef instead of state"
    ]
  },
  {
    "q": "What happens when a component's key prop changes dynamically?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state and effects",
      "React updates props but preserves previous state",
      "Key change is ignored",
      "It throws an error"
    ]
  },
  {
    "q": "Why is it important to treat state as immutable in React?",
    "o": [
      "So React can detect changes and trigger re-renders efficiently",
      "Mutating state directly is forbidden in JavaScript",
      "It prevents useEffect hooks from running",
      "React clones state objects automatically"
    ]
  },
  {
    "q": "What happens if multiple setState calls are made inside one event handler without the functional updater?",
    "o": [
      "Updates are batched, and only the last value is applied",
      "Each setState applies immediately and sequentially",
      "React throws 'Too many re-renders' error",
      "The component does not re-render"
    ]
  },
  {
    "q": "What is a potential problem with derived state from props?",
    "o": [
      "It can become stale if props change and state is not synchronized",
      "It always triggers infinite re-renders",
      "React ignores derived state in functional components",
      "It disables event handlers for controlled inputs"
    ]
  },
  {
    "q": "What is a safe way to manage frequently changing form input state?",
    "o": [
      "Use controlled inputs with functional state updates",
      "Mix controlled and uncontrolled inputs",
      "Store input values only in refs",
      "Update state outside of event handlers"
    ]
  },
  {
    "q": "What happens when a state update is scheduled in React Concurrent Mode?",
    "o": [
      "Updates may be delayed or interrupted to allow higher-priority updates",
      "Updates are applied immediately and synchronously",
      "React throws an error if Concurrent Mode is enabled",
      "State is frozen until all effects complete"
    ]
  },
  {
    "q": "Which of the following is the safest way to update a deeply nested array in state?",
    "o": [
      "Create a new array at each nested level to maintain immutability",
      "Use push() directly on the nested array and call setState",
      "Store the nested array in useRef",
      "React automatically detects mutations of nested arrays"
    ]
  },
  {
    "q": "What is a potential pitfall of using derived state from props?",
    "o": [
      "State may become stale if props change and state isn’t updated accordingly",
      "Derived state always updates automatically",
      "React ignores derived state in functional components",
      "It prevents useEffect from running"
    ]
  },
  {
    "q": "What happens if you call setState inside a setTimeout after the component unmounts?",
    "o": [
      "React ignores the update and may warn about a memory leak",
      "State updates normally and triggers re-render",
      "React throws an error immediately",
      "Previous state resets to initial value"
    ]
  },
  {
    "q": "What happens when a memoized child receives a new object prop each render?",
    "o": [
      "The child re-renders because shallow comparison detects a new reference",
      "The child does not re-render if contents are identical",
      "React throws an error",
      "Child state resets automatically"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization in useState?",
    "o": [
      "When computing the initial state is expensive and should run only once",
      "When state must update on every render",
      "When props never change",
      "When using useRef instead of state"
    ]
  },
  {
    "q": "What effect does changing the key prop of a component have?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state and effects",
      "React updates props but preserves previous state",
      "The key change is ignored",
      "React throws a runtime error"
    ]
  },
  {
    "q": "Why is immutability important when updating state?",
    "o": [
      "It allows React to detect changes via shallow comparison and trigger re-renders efficiently",
      "Mutating state directly is forbidden by JavaScript",
      "It prevents useEffect from running",
      "React automatically clones objects internally"
    ]
  },
  {
    "q": "Which of the following can cause a controlled input to become read-only unexpectedly?",
    "o": [
      "Not updating state in the onChange handler",
      "Using defaultValue instead of value",
      "Not using useEffect",
      "Passing undefined as key"
    ]
  },
  {
    "q": "What happens if multiple setState calls are made inside one event handler without the functional updater?",
    "o": [
      "Updates are batched, and only the last value is applied",
      "Each setState applies immediately and sequentially",
      "React throws 'Too many re-renders' error",
      "The component does not re-render"
    ]
  },
  {
    "q": "What happens if you call setState inside an async function after the component unmounts?",
    "o": [
      "React ignores the update and may warn about a potential memory leak",
      "State updates normally and triggers re-render",
      "React throws an error immediately",
      "Previous state resets to initial value"
    ]
  },
  {
    "q": "What is a safe way to update a deeply nested object or array in state?",
    "o": [
      "Create a new object/array at each level to maintain immutability",
      "Mutate the nested object directly and call setState",
      "Store the nested object in useRef",
      "React automatically detects nested mutations"
    ]
  },
  {
    "q": "What is a subtle problem when mixing controlled and uncontrolled inputs in the same form?",
    "o": [
      "React may warn and the input behavior can become unpredictable",
      "All inputs automatically become uncontrolled",
      "It disables useEffect hooks",
      "State updates freeze permanently"
    ]
  },
  {
    "q": "Which of the following is true when a memoized child receives a new function prop every render?",
    "o": [
      "The child re-renders because the function reference changed",
      "The child does not re-render if the function content is identical",
      "React throws an error",
      "The child unmounts and remounts automatically"
    ]
  },
  {
    "q": "What is the main advantage of using lazy initialization in useState?",
    "o": [
      "Expensive initial state computations run only once on mount",
      "State updates automatically on every render",
      "Props are synced automatically with state",
      "It replaces the need for useEffect"
    ]
  },
  {
    "q": "What happens when a component's key prop changes?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state and effects",
      "React updates props but preserves previous state",
      "The key change is ignored",
      "React throws a runtime error"
    ]
  },
  {
    "q": "Why should React state be treated as immutable?",
    "o": [
      "So React can detect changes efficiently and trigger re-renders",
      "Mutating state directly is forbidden by JavaScript",
      "It prevents all useEffect hooks from running",
      "React automatically clones state objects internally"
    ]
  },
  {
    "q": "Which of the following can cause a controlled input to become read-only unexpectedly?",
    "o": [
      "Not updating state in the onChange handler",
      "Using defaultValue instead of value",
      "Not using useEffect",
      "Passing undefined as key"
    ]
  },
  {
    "q": "What happens if multiple setState calls are made in a single event handler without the functional updater?",
    "o": [
      "Updates are batched and only the last value is applied",
      "Each setState applies immediately and sequentially",
      "React throws 'Too many re-renders' error",
      "The component does not re-render"
    ]
  },
  {
    "q": "What is a subtle problem with deriving state from props?",
    "o": [
      "State can become stale if props change and state is not synchronized",
      "Derived state always updates automatically",
      "React ignores derived state in functional components",
      "It disables event handlers for controlled inputs"
    ]
  },
  {
    "q": "What happens if you call setState inside an async function after the component has unmounted?",
    "o": [
      "React ignores the update and may warn about a potential memory leak",
      "State updates normally and triggers re-render",
      "React throws an error immediately",
      "Previous state resets to initial value"
    ]
  },
  {
    "q": "What is the safest way to update a deeply nested array in React state?",
    "o": [
      "Create a new array at each nested level to maintain immutability",
      "Use push() or splice() directly and call setState",
      "Store the nested array in a ref",
      "React automatically detects nested mutations"
    ]
  },
  {
    "q": "Which of the following can cause a controlled input to become read-only unexpectedly?",
    "o": [
      "Not updating state in the onChange handler",
      "Using defaultValue instead of value",
      "Not using useEffect",
      "Passing undefined as key"
    ]
  },
  {
    "q": "What happens when a memoized child receives a new function prop each render?",
    "o": [
      "The child re-renders because the function reference changed",
      "The child does not re-render if the function content is identical",
      "React throws an error",
      "The child unmounts and remounts automatically"
    ]
  },
  {
    "q": "Which scenario benefits most from lazy initialization in useState?",
    "o": [
      "When computing initial state is expensive and should run only once",
      "When state must update on every render",
      "When props never change",
      "When using useRef instead of state"
    ]
  },
  {
    "q": "What is the effect of changing a component's key prop dynamically?",
    "o": [
      "React unmounts the old component and mounts a new one, resetting state and effects",
      "React updates props but preserves previous state",
      "The key change is ignored",
      "React throws a runtime error"
    ]
  },
  {
    "q": "Why should React state be treated as immutable?",
    "o": [
      "So React can detect changes efficiently and trigger re-renders",
      "Mutating state directly is forbidden by JavaScript",
      "It prevents useEffect hooks from running",
      "React automatically clones state objects internally"
    ]
  },
  {
    "q": "What happens if multiple setState calls are made in a single handler without using the functional updater?",
    "o": [
      "Updates are batched, and only the last value is applied",
      "Each setState applies immediately and sequentially",
      "React throws 'Too many re-renders' error",
      "The component does not re-render"
    ]
  },
  {
    "q": "What is a subtle issue with deriving state from props?",
    "o": [
      "State can become stale if props change and state is not synchronized",
      "Derived state always updates automatically",
      "React ignores derived state in functional components",
      "It disables event handlers for controlled inputs"
    ]
  },
  {
    "q": "What happens when multiple setState calls with functional updater are scheduled inside a setTimeout?",
    "o": [
      "Each update correctly calculates the new state based on the previous state",
      "Only the last update is applied",
      "React throws an error",
      "The component does not re-render"
    ]
  }
]