[
    {
        "q": "What is the purpose of the useState hook in React?",
        "o": [
            "To manage state in functional components",
            "To handle side effects in components",
            "To create context in React",
            "To reduce the number of renders"
        ]
    },
    {
        "q": "Which hook is used to perform side effects in a React functional component?",
        "o": [
            "useEffect",
            "useState",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [count, setCount] = useState(0);\nconsole.log(count);",
        "o": [
            "0",
            "undefined",
            "null",
            "1"
        ]
    },
    {
        "q": "Which of the following is a correct way to use useEffect to run code only once when a component mounts?",
        "o": [
            "useEffect(() => { console.log('Mounted'); }, []);",
            "useEffect(() => { console.log('Mounted'); });",
            "useEffect(() => { console.log('Mounted'); }, [state]);",
            "useEffect(() => { console.log('Mounted'); }, null);"
        ]
    },
    {
        "q": "What does the useContext hook do in React?",
        "o": [
            "Allows access to context in functional components",
            "Manages state updates in components",
            "Handles side effects like data fetching",
            "Creates a custom hook"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [value, setValue] = useState('Hello');\nconsole.log(value);",
        "o": [
            "Hello",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "What is a custom hook in React?",
        "o": [
            "A JavaScript function that uses other hooks and starts with 'use'",
            "A built-in hook provided by React",
            "A function to manage context only",
            "A class-based component method"
        ]
    },
    {
        "q": "Which hook is used to manage complex state logic similar to Redux?",
        "o": [
            "useReducer",
            "useState",
            "useEffect",
            "useContext"
        ]
    },
    {
        "q": "What is the purpose of the dependency array in useEffect?",
        "o": [
            "To control when the effect runs",
            "To store state values",
            "To define context dependencies",
            "To optimize rendering"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext(null);\nconst value = useContext(MyContext);\nconsole.log(value);",
        "o": [
            "null",
            "undefined",
            "MyContext",
            "{}"
        ]
    },
    {
        "q": "Which of the following is a valid custom hook definition?",
        "o": [
            "function useCustomHook() { const [state, setState] = useState(0); return state; }",
            "function CustomHook() { return useState(0); }",
            "function useCustomHook() { return useEffect(() => {}); }",
            "function useCustomHook() { return state; }"
        ]
    },
    {
        "q": "What is the initial state in useReducer defined by?",
        "o": [
            "The second argument to useReducer",
            "The first argument to useReducer",
            "The reducer function",
            "The dispatch function"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => state + 1;\nconst [count, dispatch] = useReducer(reducer, 0);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the primary purpose of the useEffect hook in React?",
        "o": [
            "To handle side effects like data fetching or subscriptions",
            "To manage component state",
            "To access context values",
            "To create reusable logic"
        ]
    },
    {
        "q": "Which of the following is a correct way to initialize useState with a number?",
        "o": [
            "const [count, setCount] = useState(0);",
            "const [count, setCount] = useState('0');",
            "const [count, setCount] = useState(null);",
            "const [count, setCount] = useState();"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [name, setName] = useState('React');\nconsole.log(name);",
        "o": [
            "React",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "How can you clean up a side effect in useEffect?",
        "o": [
            "Return a cleanup function from the useEffect callback",
            "Call clearEffect inside useEffect",
            "Use a second useEffect for cleanup",
            "Set the dependency array to null"
        ]
    },
    {
        "q": "What does useContext return when used with a context object?",
        "o": [
            "The current context value",
            "The context provider",
            "The default state value",
            "The context consumer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext('default');\nconst value = useContext(MyContext);\nconsole.log(value);",
        "o": [
            "default",
            "null",
            "undefined",
            "MyContext"
        ]
    },
    {
        "q": "What is a key benefit of using custom hooks in React?",
        "o": [
            "They allow reusable logic across components",
            "They replace class components",
            "They automatically optimize rendering",
            "They manage global state"
        ]
    },
    {
        "q": "Which hook would you use for managing a complex state with multiple actions?",
        "o": [
            "useReducer",
            "useState",
            "useEffect",
            "useContext"
        ]
    },
    {
        "q": "What happens if you omit the dependency array in useEffect?",
        "o": [
            "The effect runs after every render",
            "The effect runs only once",
            "The effect never runs",
            "The component throws an error"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => state * 2;\nconst [value, dispatch] = useReducer(reducer, 1);\nconsole.log(value);",
        "o": [
            "1",
            "2",
            "0",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is a valid way to call a custom hook?",
        "o": [
            "const data = useCustomHook();",
            "const data = new useCustomHook();",
            "const data = CustomHook.use();",
            "const data = useCustomHook.run();"
        ]
    },
    {
        "q": "What is the role of the dispatch function in useReducer?",
        "o": [
            "Triggers state updates by passing actions to the reducer",
            "Sets the initial state",
            "Defines the reducer logic",
            "Resets the state to null"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [count, setCount] = useState(5);\nsetCount(10);\nconsole.log(count);",
        "o": [
            "5",
            "10",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the correct syntax for using the useEffect hook in a React functional component?",
        "o": [
            "useEffect(() => { /* code */ }, [dependencies]);",
            "useEffect({ /* code */ }, [dependencies]);",
            "useEffect(() => { /* code */ }); [dependencies];",
            "useEffect([dependencies], () => { /* code */ });"
        ]
    },
    {
        "q": "Which hook allows you to share stateful logic between components?",
        "o": [
            "Custom hooks",
            "useState",
            "useEffect",
            "useContext"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [value, setValue] = useState(true);\nconsole.log(value);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the purpose of the useReducer hook in React?",
        "o": [
            "To manage complex state logic with a reducer function",
            "To perform side effects in components",
            "To access context values",
            "To create reusable hooks"
        ]
    },
    {
        "q": "Which of the following is true about the useContext hook?",
        "o": [
            "It provides a way to consume context without nesting",
            "It replaces useState for state management",
            "It triggers side effects automatically",
            "It requires a dependency array"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext({ key: 'value' });\nconst context = useContext(MyContext);\nconsole.log(context.key);",
        "o": [
            "value",
            "key",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a requirement for a function to be considered a custom hook in React?",
        "o": [
            "It must start with 'use' and call other hooks",
            "It must be a class-based function",
            "It must return a context object",
            "It must use useEffect exclusively"
        ]
    },
    {
        "q": "What happens when you dispatch an action in useReducer?",
        "o": [
            "The reducer function processes the action to update state",
            "The component re-renders without state change",
            "The action is stored in context",
            "The state is reset to its initial value"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => state + action;\nconst [count, dispatch] = useReducer(reducer, 0);\nconsole.log(count);",
        "o": [
            "0",
            "undefined",
            "null",
            "1"
        ]
    },
    {
        "q": "Which of the following is a valid way to update state using useState?",
        "o": [
            "setCount(prev => prev + 1);",
            "setCount(count++);",
            "setCount(count = count + 1);",
            "setCount(count += 1);"
        ]
    },
    {
        "q": "When does the cleanup function in useEffect run?",
        "o": [
            "When the component unmounts or dependencies change",
            "After every render",
            "Only when the component mounts",
            "When the state is updated"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [data, setData] = useState({ name: 'React' });\nconsole.log(data.name);",
        "o": [
            "React",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "Which of the following is a valid use case for a custom hook?",
        "o": [
            "Encapsulating API call logic for reuse",
            "Defining a new context provider",
            "Replacing all useState calls",
            "Managing component rendering"
        ]
    },
    {
        "q": "Which of the following hooks is used to access data from the React Context?",
        "o": [
            "useContext",
            "useState",
            "useEffect",
            "useReducer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [count, setCount] = useState(0);\nsetCount(count + 1);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the first argument passed to the useReducer hook?",
        "o": [
            "The reducer function",
            "The initial state",
            "The dispatch function",
            "The action object"
        ]
    },
    {
        "q": "Which hook can be used to replace componentDidMount in a functional component?",
        "o": [
            "useEffect with empty dependency array",
            "useState",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext(0);\nconst value = useContext(MyContext);\nconsole.log(value);",
        "o": [
            "0",
            "undefined",
            "null",
            "MyContext"
        ]
    },
    {
        "q": "What prefix must custom hooks in React start with?",
        "o": [
            "use",
            "hook",
            "react",
            "custom"
        ]
    },
    {
        "q": "What is the second value returned by useState?",
        "o": [
            "A function to update the state",
            "The initial state value",
            "The current state value",
            "A reducer function"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => action.type === 'increment' ? state + 1 : state;\nconst [count, dispatch] = useReducer(reducer, 0);\nconsole.log(count);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "When does useEffect run if the dependency array is empty?",
        "o": [
            "Only once after the initial render",
            "After every render",
            "Never",
            "Only on unmount"
        ]
    },
    {
        "q": "Which of the following is a correct way to create a context in React?",
        "o": [
            "const MyContext = createContext(defaultValue);",
            "const MyContext = useContext(defaultValue);",
            "const MyContext = useState(defaultValue);",
            "const MyContext = useEffect(defaultValue);"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isOpen, setIsOpen] = useState(false);\nconsole.log(isOpen);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What can custom hooks return in React?",
        "o": [
            "Any value, such as state or functions",
            "Only state values",
            "Only JSX elements",
            "Nothing, they are void"
        ]
    },
    {
        "q": "Which hook is suitable for handling form inputs with multiple fields?",
        "o": [
            "useReducer",
            "useEffect",
            "useContext",
            "useState for each field"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [user, setUser] = useState({ name: 'Alice' });\nconsole.log(user.name);",
        "o": [
            "Alice",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "Which hook is used to subscribe to external data sources in React?",
        "o": [
            "useEffect",
            "useState",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the default value used in createContext if no provider is found?",
        "o": [
            "The value passed to createContext",
            "undefined",
            "null",
            "An empty object"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => state - 1;\nconst [value, dispatch] = useReducer(reducer, 5);\nconsole.log(value);",
        "o": [
            "5",
            "4",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Can custom hooks call other hooks inside them?",
        "o": [
            "Yes, they can call built-in and other custom hooks",
            "No, they can only use useState",
            "No, hooks can only be called at the top level",
            "Yes, but only useEffect"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [loading, setLoading] = useState(true);\nconsole.log(loading);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which of the following is the correct way to dispatch an action in useReducer?",
        "o": [
            "dispatch({ type: 'action' });",
            "dispatch('action');",
            "setState({ type: 'action' });",
            "update({ type: 'action' });"
        ]
    },
    {
        "q": "What does useEffect return if a cleanup is needed?",
        "o": [
            "A function that performs the cleanup",
            "Void or undefined",
            "The dependency array",
            "The state value"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext('hello');\nconst value = useContext(MyContext);\nconsole.log(value);",
        "o": [
            "hello",
            "undefined",
            "null",
            "MyContext"
        ]
    },
    {
        "q": "Why are custom hooks useful in React applications?",
        "o": [
            "They promote code reuse and separation of concerns",
            "They replace all built-in hooks",
            "They optimize component performance automatically",
            "They manage routing in the app"
        ]
    },
    {
        "q": "What is the initial state value in useState if no argument is provided?",
        "o": [
            "undefined",
            "null",
            "0",
            "false"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [items, setItems] = useState([]);\nconsole.log(items.length);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook can be used to avoid prop drilling in React?",
        "o": [
            "useContext",
            "useState",
            "useEffect",
            "useReducer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [score, setScore] = useState(100);\nconsole.log(score);",
        "o": [
            "100",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which of the following hooks can be used to fetch data when a component mounts?",
        "o": [
            "useEffect",
            "useState",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the purpose of the Provider component in React Context?",
        "o": [
            "To pass the context value down the component tree",
            "To consume the context value",
            "To create a new context",
            "To manage state updates"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => action.payload || state;\nconst [state, dispatch] = useReducer(reducer, 'initial');\nconsole.log(state);",
        "o": [
            "initial",
            "undefined",
            "null",
            "payload"
        ]
    },
    {
        "q": "Can you call hooks inside loops or conditional statements in React?",
        "o": [
            "No, hooks must be called at the top level",
            "Yes, but only useState",
            "Yes, as long as they are in useEffect",
            "No, only in custom hooks"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [theme, setTheme] = useState('light');\nconsole.log(theme);",
        "o": [
            "light",
            "dark",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the reducer function in useReducer?",
        "o": [
            "A function that takes state and action and returns new state",
            "A function that dispatches actions",
            "A function that sets initial state",
            "A function that cleans up effects"
        ]
    },
    {
        "q": "Which hook is used to optimize performance by memoizing values?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useContext"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext(true);\nconst value = useContext(MyContext);\nconsole.log(value);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a common use case for custom hooks?",
        "o": [
            "Handling form validation logic",
            "Defining component styles",
            "Managing routes in the app",
            "Rendering JSX directly"
        ]
    },
    {
        "q": "What happens if you provide a dependency array with values in useEffect?",
        "o": [
            "The effect runs when those dependencies change",
            "The effect runs only once",
            "The effect never runs",
            "The component unmounts"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [list, setList] = useState(['item']);\nconsole.log(list[0]);",
        "o": [
            "item",
            "undefined",
            "null",
            "[]"
        ]
    },
    {
        "q": "Which hook can be combined with useContext for global state management?",
        "o": [
            "useReducer",
            "useEffect",
            "useState",
            "useMemo"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [counter, setCounter] = useState(0);\nconsole.log(counter);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is equivalent to componentDidUpdate in class components?",
        "o": [
            "useEffect with dependencies",
            "useState",
            "useContext",
            "useReducer"
        ]
    },
    {
        "q": "What is the Consumer component in React Context used for?",
        "o": [
            "To subscribe to context changes in class components",
            "To provide context values",
            "To create context",
            "To dispatch actions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const reducer = (state, action) => action === 'reset' ? 0 : state;\nconst [count, dispatch] = useReducer(reducer, 10);\nconsole.log(count);",
        "o": [
            "10",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Are custom hooks allowed to return JSX elements?",
        "o": [
            "No, custom hooks should return data or functions, not JSX",
            "Yes, they can return anything including JSX",
            "Only if they use useEffect",
            "No, they must return state only"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [mode, setMode] = useState('dark');\nconsole.log(mode);",
        "o": [
            "dark",
            "light",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is an action in the context of useReducer?",
        "o": [
            "An object that describes how to update the state",
            "A function that updates state directly",
            "The initial state value",
            "A cleanup function"
        ]
    },
    {
        "q": "Which hook is used to memoize functions to prevent unnecessary re-renders?",
        "o": [
            "useCallback",
            "useMemo",
            "useEffect",
            "useState"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const MyContext = createContext([]);\nconst value = useContext(MyContext);\nconsole.log(value.length);",
        "o": [
            "0",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a good practice when creating custom hooks?",
        "o": [
            "Make them composable and focused on a single concern",
            "Include all app logic in one hook",
            "Use them only for state management",
            "Avoid calling other hooks inside them"
        ]
    },
    {
        "q": "What triggers a re-run of useEffect if dependencies are specified?",
        "o": [
            "Changes in the dependency values",
            "Every render",
            "Only on mount",
            "State updates outside dependencies"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [users, setUsers] = useState([{ id: 1 }]);\nconsole.log(users.length);",
        "o": [
            "1",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "How can useReducer be used with useContext for app-wide state?",
        "o": [
            "By providing the state and dispatch via context",
            "By replacing context entirely",
            "By using useState instead",
            "It's not possible"
        ]
    },
    {
        "q": "What is the purpose of the useCallback hook in React?",
        "o": [
            "To memoize functions to prevent unnecessary re-creation",
            "To manage state updates",
            "To handle side effects",
            "To access context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedValue = useMemo(() => 1 + 2, []);\nconsole.log(memoizedValue);",
        "o": [
            "3",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is best suited for optimizing expensive calculations in a component?",
        "o": [
            "useMemo",
            "useEffect",
            "useState",
            "useReducer"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const handleClick = useCallback(() => console.log('clicked'), []);\nconsole.log(typeof handleClick);",
        "o": [
            "function",
            "object",
            "undefined",
            "string"
        ]
    },
    {
        "q": "What happens if you pass an empty array to useMemo's dependency array?",
        "o": [
            "The memoized value is computed only once",
            "The value is recomputed on every render",
            "The component throws an error",
            "The value is reset to null"
        ]
    },
    {
        "q": "Which of the following is a valid way to use useRef in a functional component?",
        "o": [
            "const myRef = useRef(null);",
            "const myRef = useRef(0, []);",
            "const myRef = useRef(() => {});",
            "const myRef = useRef({ value: null });"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const myRef = useRef(42);\nconsole.log(myRef.current);",
        "o": [
            "42",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is the primary use case for the useRef hook?",
        "o": [
            "To hold mutable values that persist across renders",
            "To manage component state",
            "To memoize functions",
            "To trigger side effects"
        ]
    },
    {
        "q": "Which hook would you use to access a DOM element directly?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useContext"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedFn = useCallback(() => 5, []);\nconsole.log(memoizedFn());",
        "o": [
            "5",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is the benefit of using useMemo for expensive calculations?",
        "o": [
            "It prevents recalculation unless dependencies change",
            "It automatically updates state",
            "It triggers side effects",
            "It replaces useState"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef('test');\nconsole.log(ref.current);",
        "o": [
            "test",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "How does useCallback differ from useMemo?",
        "o": [
            "useCallback memoizes functions, useMemo memoizes values",
            "useCallback memoizes values, useMemo memoizes functions",
            "useCallback triggers side effects, useMemo does not",
            "They are identical in functionality"
        ]
    },
    {
        "q": "What is the main purpose of the useMemo hook in React?",
        "o": [
            "To memoize computed values to avoid recalculations",
            "To manage state in functional components",
            "To handle side effects like API calls",
            "To access context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => 10 * 2, []);\nconsole.log(value);",
        "o": [
            "20",
            "10",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to persist a value across renders without causing re-renders?",
        "o": [
            "useRef",
            "useState",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const myRef = useRef({ count: 0 });\nconsole.log(myRef.current.count);",
        "o": [
            "0",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What happens if you update a useRef value in a component?",
        "o": [
            "The component does not re-render",
            "The component re-renders automatically",
            "The ref value resets to null",
            "The ref triggers a side effect"
        ]
    },
    {
        "q": "Which of the following is a valid use case for useCallback?",
        "o": [
            "Memoizing a function passed to a child component",
            "Storing a DOM element reference",
            "Managing complex state logic",
            "Accessing context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedFn = useCallback(() => 'hello', []);\nconsole.log(memoizedFn());",
        "o": [
            "hello",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the role of the dependency array in useMemo?",
        "o": [
            "Determines when the memoized value is recomputed",
            "Triggers a component re-render",
            "Stores the initial state",
            "Defines the cleanup function"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nconsole.log(ref.current);",
        "o": [
            "null",
            "undefined",
            "0",
            "{}"
        ]
    },
    {
        "q": "Which hook would you use to track previous state or props values?",
        "o": [
            "useRef",
            "useState",
            "useEffect",
            "useMemo"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => ({ key: 'value' }), []);\nconsole.log(value.key);",
        "o": [
            "value",
            "undefined",
            "null",
            "key"
        ]
    },
    {
        "q": "Why is useCallback useful when passing functions to memoized components?",
        "o": [
            "It prevents unnecessary re-renders by maintaining function identity",
            "It updates the function automatically",
            "It triggers side effects",
            "It resets the function's state"
        ]
    },
    {
        "q": "What is a common use case for useRef besides DOM access?",
        "o": [
            "Storing previous values for comparison",
            "Managing component state",
            "Memoizing expensive calculations",
            "Dispatching actions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(100);\nconsole.log(ref.current);",
        "o": [
            "100",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is best for memoizing a function to ensure it doesn’t change on re-renders?",
        "o": [
            "useCallback",
            "useMemo",
            "useRef",
            "useEffect"
        ]
    },
    {
        "q": "What is the purpose of useRef when used to store a mutable value?",
        "o": [
            "To persist values across renders without triggering re-renders",
            "To trigger re-renders when the value changes",
            "To memoize computed values",
            "To manage context state"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedValue = useMemo(() => [1, 2, 3], []);\nconsole.log(memoizedValue.length);",
        "o": [
            "3",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What happens if you omit the dependency array in useCallback?",
        "o": [
            "The function is recreated on every render",
            "The function is memoized forever",
            "The component throws an error",
            "The function returns null"
        ]
    },
    {
        "q": "Which of the following is a valid way to use useMemo in a component?",
        "o": [
            "const value = useMemo(() => computeValue(), [dependency]);",
            "const value = useMemo(computeValue(), [dependency]);",
            "const value = useMemo(() => computeValue(), dependency);",
            "const value = useMemo(computeValue, []);"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const callback = useCallback(() => true, []);\nconsole.log(callback());",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key difference between useRef and useState?",
        "o": [
            "useRef changes don’t trigger re-renders, useState changes do",
            "useRef triggers re-renders, useState does not",
            "useRef is for state, useState is for refs",
            "useRef is only for DOM elements"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef({ active: false });\nconsole.log(ref.current.active);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Why would you use useMemo for an object in a dependency array?",
        "o": [
            "To prevent unnecessary re-renders by maintaining object reference",
            "To trigger re-renders on every change",
            "To store the object in context",
            "To dispatch actions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedObj = useMemo(() => ({ count: 1 }), []);\nconsole.log(memoizedObj.count);",
        "o": [
            "1",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook can be used to store a reference to a setInterval timer?",
        "o": [
            "useRef",
            "useState",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What is the benefit of using useCallback with event handlers?",
        "o": [
            "It ensures stable function references for optimized components",
            "It automatically updates state",
            "It cleans up side effects",
            "It manages context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedValue = useMemo(() => 'React' + ' Hooks', []);\nconsole.log(memoizedValue);",
        "o": [
            "React Hooks",
            "React",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook would you use to store a reference to a DOM element for focus management?",
        "o": [
            "useRef",
            "useState",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What happens when you update the .current property of a useRef object?",
        "o": [
            "The value updates without causing a re-render",
            "The component re-renders immediately",
            "The ref resets to its initial value",
            "An error is thrown"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const callback = useCallback(() => 42, []);\nconsole.log(callback());",
        "o": [
            "42",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Why is useMemo useful in preventing unnecessary computations?",
        "o": [
            "It caches the result until dependencies change",
            "It runs computations on every render",
            "It triggers side effects automatically",
            "It updates state directly"
        ]
    },
    {
        "q": "Which of the following is a valid way to use useRef for storing a counter?",
        "o": [
            "const counter = useRef(0);",
            "const counter = useRef(0, []);",
            "const counter = useRef(() => 0);",
            "const counter = useRef({ count: 0 }, []);"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef('initial');\nref.current = 'updated';\nconsole.log(ref.current);",
        "o": [
            "updated",
            "initial",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the main difference between useCallback and a regular function declaration?",
        "o": [
            "useCallback memoizes the function to maintain its reference",
            "useCallback triggers re-renders",
            "useCallback cannot take dependencies",
            "useCallback is only for state updates"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedArray = useMemo(() => [1], []);\nconsole.log(memoizedArray[0]);",
        "o": [
            "1",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is ideal for storing a value that should persist across renders but not trigger updates?",
        "o": [
            "useRef",
            "useState",
            "useMemo",
            "useEffect"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const fn = useCallback(() => ({ key: 'value' }), []);\nconsole.log(fn().key);",
        "o": [
            "value",
            "undefined",
            "null",
            "key"
        ]
    },
    {
        "q": "When is the memoized function from useCallback recreated?",
        "o": [
            "When its dependencies change",
            "On every render",
            "Only on component mount",
            "When state updates"
        ]
    },
    {
        "q": "What is a common use case for combining useRef with useEffect?",
        "o": [
            "Managing focus or timers without causing re-renders",
            "Updating state on every render",
            "Memoizing expensive calculations",
            "Accessing context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(0);\nref.current += 1;\nconsole.log(ref.current);",
        "o": [
            "1",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is similar to useEffect but runs synchronously after DOM mutations?",
        "o": [
            "useLayoutEffect",
            "useEffect",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What is the purpose of useImperativeHandle in React?",
        "o": [
            "To customize the instance value exposed to parent components when using ref",
            "To memoize values",
            "To manage side effects",
            "To access context"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoized = useMemo(() => false, []);\nconsole.log(memoized);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "When should you use useLayoutEffect instead of useEffect?",
        "o": [
            "When you need to measure DOM elements before painting",
            "When performing side effects asynchronously",
            "When memoizing functions",
            "When managing state"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const fn = useCallback(() => console.log('fn'), []);\nconsole.log(typeof fn);",
        "o": [
            "function",
            "object",
            "undefined",
            "string"
        ]
    },
    {
        "q": "Which hook is used to debug custom hooks by providing a label in React DevTools?",
        "o": [
            "useDebugValue",
            "useRef",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nconsole.log(typeof ref.current);",
        "o": [
            "object",
            "undefined",
            "null",
            "function"
        ]
    },
    {
        "q": "What does useTransition hook do in React?",
        "o": [
            "Allows marking updates as non-urgent transitions",
            "Manages side effects",
            "Memoizes values",
            "Accesses DOM references"
        ]
    },
    {
        "q": "Which of the following is a valid way to use useDebugValue?",
        "o": [
            "useDebugValue(state, (val) => `State: ${val}`);",
            "useDebugValue(() => state);",
            "useDebugValue(state + 1);",
            "useDebugValue();"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => 3.14, []);\nconsole.log(value);",
        "o": [
            "3.14",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "When is useImperativeHandle typically used?",
        "o": [
            "With forwardRef to expose methods to parent components",
            "To memoize callbacks",
            "To handle layout effects",
            "To debug state values"
        ]
    },
    {
        "q": "What is a key difference between useEffect and useLayoutEffect?",
        "o": [
            "useLayoutEffect runs before the browser paints the screen",
            "useLayoutEffect runs asynchronously",
            "useLayoutEffect cannot have cleanup",
            "useLayoutEffect is for state management"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef({ value: 10 });\nref.current.value = 20;\nconsole.log(ref.current.value);",
        "o": [
            "20",
            "10",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to manage non-critical state updates to improve UI responsiveness?",
        "o": [
            "useTransition",
            "useLayoutEffect",
            "useMemo",
            "useDebugValue"
        ]
    },
    {
        "q": "What does useDebugValue primarily help with in custom hooks?",
        "o": [
            "Displaying custom labels in React DevTools for debugging",
            "Memoizing values for performance",
            "Managing DOM references",
            "Handling asynchronous effects"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(isPending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the purpose of useImperativeHandle when used with forwardRef?",
        "o": [
            "To expose specific methods or values to parent components via refs",
            "To memoize functions for child components",
            "To manage state updates",
            "To debug context values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoizedFn = useCallback(() => ({ id: 1 }), []);\nconsole.log(memoizedFn().id);",
        "o": [
            "1",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "When should you use useLayoutEffect over useEffect?",
        "o": [
            "For DOM measurements that need to happen before painting",
            "For asynchronous data fetching",
            "For memoizing expensive calculations",
            "For managing context"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef('start');\nref.current = 'end';\nconsole.log(ref.current);",
        "o": [
            "end",
            "start",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What does the startTransition function from useTransition do?",
        "o": [
            "Marks updates as non-urgent to prioritize rendering",
            "Triggers immediate state updates",
            "Memoizes state transitions",
            "Resets the component state"
        ]
    },
    {
        "q": "Which of the following is a valid use case for useDebugValue?",
        "o": [
            "Labeling a custom hook’s state in React DevTools",
            "Storing a DOM reference",
            "Memoizing a callback function",
            "Performing layout calculations"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => ({ name: 'React' }), []);\nconsole.log(value.name);",
        "o": [
            "React",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What happens when you use useImperativeHandle without forwardRef?",
        "o": [
            "It has no effect as it requires forwardRef to work",
            "It memoizes the ref automatically",
            "It triggers a re-render",
            "It exposes all component methods"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => {});\nconsole.log(typeof startTransition);",
        "o": [
            "function",
            "object",
            "undefined",
            "boolean"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(0);\nref.current = ref.current + 5;\nconsole.log(ref.current);",
        "o": [
            "5",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to defer rendering of non-critical updates in React?",
        "o": [
            "useDeferredValue",
            "useTransition",
            "useLayoutEffect",
            "useDebugValue"
        ]
    },
    {
        "q": "What is the purpose of useDeferredValue in React?",
        "o": [
            "To provide a deferred version of a value for non-urgent updates",
            "To memoize functions",
            "To access DOM elements",
            "To manage context state"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => 2 ** 3, []);\nconsole.log(value);",
        "o": [
            "8",
            "6",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a practical use case for useLayoutEffect?",
        "o": [
            "Adjusting DOM layout before the browser paints",
            "Fetching data from an API",
            "Memoizing complex computations",
            "Debugging custom hooks"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const fn = useCallback(() => 'test', []);\nconsole.log(fn());",
        "o": [
            "test",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "How does useDeferredValue help with performance in React?",
        "o": [
            "It delays updates to low-priority values to prioritize rendering",
            "It memoizes values automatically",
            "It triggers immediate re-renders",
            "It clears refs on unmount"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef({ key: 'initial' });\nref.current.key = 'updated';\nconsole.log(ref.current.key);",
        "o": [
            "updated",
            "initial",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the benefit of using useDebugValue in a custom hook?",
        "o": [
            "It provides custom labels for debugging in React DevTools",
            "It memoizes the hook’s output",
            "It manages side effects",
            "It exposes refs to parent components"
        ]
    },
    {
        "q": "Which hook is used to expose specific methods of a component to its parent?",
        "o": [
            "useImperativeHandle",
            "useCallback",
            "useDeferredValue",
            "useMemo"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(typeof isPending);",
        "o": [
            "boolean",
            "function",
            "object",
            "undefined"
        ]
    },
    {
        "q": "What happens if you use useDeferredValue with a frequently changing value?",
        "o": [
            "It defers updates to avoid blocking the UI",
            "It triggers re-renders on every change",
            "It memoizes the value permanently",
            "It resets the value to null"
        ]
    },
    {
        "q": "What is a key difference between useTransition and useDeferredValue?",
        "o": [
            "useTransition marks updates, useDeferredValue defers a value",
            "useTransition memoizes values, useDeferredValue manages refs",
            "useTransition is for DOM access, useDeferredValue is for effects",
            "They are identical in functionality"
        ]
    },
    {
        "q": "What is the purpose of the useId hook in React?",
        "o": [
            "To generate unique IDs for accessibility purposes",
            "To manage state transitions",
            "To defer value updates",
            "To sync with external stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(typeof id);",
        "o": [
            "string",
            "number",
            "undefined",
            "object"
        ]
    },
    {
        "q": "Which hook is used to subscribe to an external store in React?",
        "o": [
            "useSyncExternalStore",
            "useTransition",
            "useDeferredValue",
            "useId"
        ]
    },
    {
        "q": "What is the main use case for useInsertionEffect in React?",
        "o": [
            "To insert styles before DOM mutations",
            "To manage asynchronous updates",
            "To generate unique identifiers",
            "To debug hook values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(isPending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What does useDeferredValue return?",
        "o": [
            "A deferred version of the passed value",
            "A unique ID string",
            "A subscription to an external store",
            "A debug label for DevTools"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferredValue = useDeferredValue('initial');\nconsole.log(deferredValue);",
        "o": [
            "initial",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "Which hook helps in marking state updates as non-blocking transitions?",
        "o": [
            "useTransition",
            "useSyncExternalStore",
            "useInsertionEffect",
            "useImperativeHandle"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.startsWith(':'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key feature of useSyncExternalStore?",
        "o": [
            "It allows React to subscribe to external data sources safely",
            "It defers value updates for performance",
            "It generates IDs for server-side rendering",
            "It inserts effects before layout"
        ]
    },
    {
        "q": "When is useInsertionEffect typically run?",
        "o": [
            "Before any DOM mutations occur",
            "After the browser paints the screen",
            "During state transitions",
            "On external store subscriptions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(subscribe, getSnapshot);\nconsole.log(value);",
        "o": [
            "The result of getSnapshot",
            "undefined",
            "null",
            "subscribe"
        ]
    },
    {
        "q": "Which hook is useful for optimizing concurrent rendering in React?",
        "o": [
            "useDeferredValue",
            "useId",
            "useDebugValue",
            "useRef"
        ]
    },
    {
        "q": "What is the primary purpose of the useSyncExternalStore hook in React?",
        "o": [
            "To safely subscribe to external data stores in React",
            "To generate unique IDs for elements",
            "To defer non-critical updates",
            "To manage DOM mutations"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.length > 0);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is specifically designed for injecting styles before layout effects?",
        "o": [
            "useInsertionEffect",
            "useLayoutEffect",
            "useEffect",
            "useDeferredValue"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferredValue = useDeferredValue(42);\nconsole.log(deferredValue);",
        "o": [
            "42",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is a key benefit of using useId in server-side rendering?",
        "o": [
            "It ensures consistent IDs across server and client",
            "It memoizes values for performance",
            "It subscribes to external stores",
            "It defers state updates"
        ]
    },
    {
        "q": "Which hook would you use to prioritize urgent updates over non-urgent ones?",
        "o": [
            "useTransition",
            "useSyncExternalStore",
            "useId",
            "useImperativeHandle"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => console.log('transition'));\nconsole.log(isPending);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a common use case for useInsertionEffect?",
        "o": [
            "Injecting CSS-in-JS styles before DOM mutations",
            "Handling asynchronous data fetching",
            "Generating unique IDs for forms",
            "Debugging state changes"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useMemo(() => new Set([1, 2]), []);\nconsole.log(value.size);",
        "o": [
            "2",
            "1",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What does useSyncExternalStore require as its arguments?",
        "o": [
            "A subscribe function and a getSnapshot function",
            "A state value and an update function",
            "A ref and a callback",
            "A context and a default value"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nconsole.log(ref.current === null);",
        "o": [
            "true",
            "false",
            "undefined",
            "{}"
        ]
    },
    {
        "q": "Why is useDeferredValue useful in React applications?",
        "o": [
            "It improves performance by deferring low-priority updates",
            "It generates unique IDs for elements",
            "It manages DOM references",
            "It triggers layout effects"
        ]
    },
    {
        "q": "What is the difference between useEffect and useInsertionEffect?",
        "o": [
            "useInsertionEffect runs before DOM mutations, useEffect runs after",
            "useInsertionEffect is asynchronous, useEffect is synchronous",
            "useInsertionEffect memoizes values, useEffect does not",
            "useInsertionEffect is for state, useEffect is for refs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferredValue = useDeferredValue('test');\nconsole.log(deferredValue);",
        "o": [
            "test",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "Which hook is designed to ensure consistent IDs for accessibility in both client and server-side rendering?",
        "o": [
            "useId",
            "useDeferredValue",
            "useSyncExternalStore",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the primary use case for useSyncExternalStore in React?",
        "o": [
            "To integrate with external state management libraries",
            "To defer non-critical updates",
            "To inject styles before rendering",
            "To generate unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.includes(':'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What happens when you use useInsertionEffect in a component?",
        "o": [
            "It runs before any DOM mutations for style injections",
            "It defers state updates",
            "It subscribes to external stores",
            "It generates unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(typeof startTransition);",
        "o": [
            "function",
            "boolean",
            "object",
            "undefined"
        ]
    },
    {
        "q": "Which hook is useful for debugging custom hooks by providing metadata in React DevTools?",
        "o": [
            "useDebugValue",
            "useId",
            "useDeferredValue",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoized = useMemo(() => ({ active: true }), []);\nconsole.log(memoized.active);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key benefit of using useTransition for state updates?",
        "o": [
            "It allows marking updates as non-urgent to keep the UI responsive",
            "It memoizes state values",
            "It injects styles before rendering",
            "It persists values without re-renders"
        ]
    },
    {
        "q": "Which hook is used to customize the ref object exposed to parent components?",
        "o": [
            "useImperativeHandle",
            "useSyncExternalStore",
            "useDeferredValue",
            "useDebugValue"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(0);\nref.current = 100;\nconsole.log(ref.current);",
        "o": [
            "100",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the role of the getSnapshot function in useSyncExternalStore?",
        "o": [
            "It retrieves the current state of the external store",
            "It subscribes to the store",
            "It defers updates to the store",
            "It generates a unique ID"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const fn = useCallback(() => null, []);\nconsole.log(fn());",
        "o": [
            "null",
            "undefined",
            "{}",
            "function"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id);",
        "o": [
            "A unique string identifier",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is used to integrate React with external mutable data sources?",
        "o": [
            "useSyncExternalStore",
            "useDeferredValue",
            "useInsertionEffect",
            "useTransition"
        ]
    },
    {
        "q": "What is the purpose of useInsertionEffect in React?",
        "o": [
            "To insert dynamic styles before DOM mutations",
            "To generate unique IDs",
            "To defer value updates",
            "To manage state transitions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue({ key: 'value' });\nconsole.log(deferred.key);",
        "o": [
            "value",
            "undefined",
            "null",
            "key"
        ]
    },
    {
        "q": "What is a benefit of using useId for accessibility attributes like aria-labelledby?",
        "o": [
            "It ensures IDs are unique and consistent across renders",
            "It memoizes the ID for performance",
            "It defers ID generation",
            "It subscribes to external ID stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(isPending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook runs its effect before useLayoutEffect in the commit phase?",
        "o": [
            "useInsertionEffect",
            "useEffect",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const storeValue = useSyncExternalStore(subscribe, getSnapshot);\nconsole.log(storeValue);",
        "o": [
            "The current snapshot of the external store",
            "undefined",
            "null",
            "subscribe"
        ]
    },
    {
        "q": "What is the main advantage of useDeferredValue for search inputs?",
        "o": [
            "It debounces updates to prevent UI blocking",
            "It generates IDs for input elements",
            "It inserts styles for inputs",
            "It syncs inputs with external stores"
        ]
    },
    {
        "q": "Which hook is useful for labeling derived state in React DevTools?",
        "o": [
            "useDebugValue",
            "useId",
            "useInsertionEffect",
            "useSyncExternalStore"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('Custom Hook Value');\n// Assuming in a custom hook",
        "o": [
            "Displays 'Custom Hook Value' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is required for useImperativeHandle to function correctly?",
        "o": [
            "Wrapping the component with forwardRef",
            "A dependency array",
            "An external store subscription",
            "A deferred value"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ focus: () => {} }));\nconsole.log(typeof ref.current.focus);",
        "o": [
            "function",
            "undefined",
            "object",
            "null"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id);",
        "o": [
            "A unique string like ':R1:'",
            "undefined",
            "null",
            "An empty string"
        ]
    },
    {
        "q": "Which hook is used to inject dynamic effects before any DOM mutations in React?",
        "o": [
            "useInsertionEffect",
            "useLayoutEffect",
            "useEffect",
            "useTransition"
        ]
    },
    {
        "q": "What is the purpose of useDeferredValue when used with a search query?",
        "o": [
            "To debounce the query value for smoother UI updates",
            "To generate a unique ID for the query",
            "To sync the query with an external store",
            "To insert effects based on the query"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => setState(newState));\nconsole.log(isPending);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key use case for useSyncExternalStore in third-party integrations?",
        "o": [
            "Subscribing to non-React state sources like browser APIs",
            "Deferring updates to React state",
            "Generating IDs for server components",
            "Debugging hook values in DevTools"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useDeferredValue(100);\nconsole.log(value);",
        "o": [
            "100",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook helps in creating custom labels for hooks in React DevTools?",
        "o": [
            "useDebugValue",
            "useId",
            "useInsertionEffect",
            "useImperativeHandle"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ method: () => 'hello' }));\nconsole.log(ref.current.method());",
        "o": [
            "hello",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the execution order of useInsertionEffect relative to other effects?",
        "o": [
            "It runs before useLayoutEffect and DOM mutations",
            "It runs after useEffect",
            "It runs synchronously with useState",
            "It runs during rendering"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id1 = useId();\nconst id2 = useId();\nconsole.log(id1 === id2);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is ideal for handling concurrent features like suspense in React?",
        "o": [
            "useTransition",
            "useSyncExternalStore",
            "useDebugValue",
            "useRef"
        ]
    },
    {
        "q": "What is the purpose of the subscribe function in useSyncExternalStore?",
        "o": [
            "To set up a subscription to the external store for changes",
            "To get the initial snapshot",
            "To defer updates",
            "To generate a unique ID"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue(count > 10 ? 'High' : 'Low');\n// In a custom hook",
        "o": [
            "Displays 'High' or 'Low' in DevTools based on count",
            "Logs to console",
            "Throws an error",
            "Does nothing visible"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.charAt(0));",
        "o": [
            ":",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is used to integrate React with mutable external stores while avoiding tearing?",
        "o": [
            "useSyncExternalStore",
            "useState",
            "useRef",
            "useEffect"
        ]
    },
    {
        "q": "What is the purpose of useInsertionEffect in libraries like CSS-in-JS?",
        "o": [
            "To inject styles before layout effects run",
            "To defer style updates",
            "To generate unique style IDs",
            "To debug style values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue(false);\nconsole.log(deferred);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a common application for useId in form elements?",
        "o": [
            "Generating unique IDs for labels and inputs",
            "Memoizing form values",
            "Deferring form submissions",
            "Syncing forms with external stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [pending, start] = useTransition();\nconsole.log(pending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook runs its callback before useLayoutEffect in the commit phase?",
        "o": [
            "useInsertionEffect",
            "useEffect",
            "useMemo",
            "useCallback"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => {}, () => 'snapshot');\nconsole.log(value);",
        "o": [
            "snapshot",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue in lists with heavy rendering?",
        "o": [
            "It allows the UI to remain responsive by deferring list updates",
            "It generates IDs for list items",
            "It inserts effects for list rendering",
            "It syncs lists with external data"
        ]
    },
    {
        "q": "Which hook is used to provide custom formatting for values in React DevTools?",
        "o": [
            "useDebugValue",
            "useImperativeHandle",
            "useId",
            "useTransition"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue({ status: 'active' });\n// In a custom hook",
        "o": [
            "Displays { status: 'active' } in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the dependency array used for in useImperativeHandle?",
        "o": [
            "To recreate the handle object when dependencies change",
            "To trigger side effects",
            "To defer updates",
            "To subscribe to stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ value: 5 }));\nconsole.log(ref.current.value);",
        "o": [
            "5",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useDeferredValue(['item']);\nconsole.log(value.length);",
        "o": [
            "1",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to ensure stable IDs for accessibility attributes in React?",
        "o": [
            "useId",
            "useSyncExternalStore",
            "useInsertionEffect",
            "useDeferredValue"
        ]
    },
    {
        "q": "What is the main purpose of the getServerSnapshot function in useSyncExternalStore?",
        "o": [
            "To provide the initial state for server-side rendering",
            "To subscribe to external stores",
            "To defer state updates",
            "To generate unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(typeof id);",
        "o": [
            "string",
            "number",
            "undefined",
            "object"
        ]
    },
    {
        "q": "What is a key use case for useInsertionEffect in styling libraries?",
        "o": [
            "Injecting critical CSS before DOM mutations",
            "Managing asynchronous state updates",
            "Generating IDs for style elements",
            "Debugging style values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => console.log('update'));\nconsole.log(typeof isPending);",
        "o": [
            "boolean",
            "function",
            "object",
            "undefined"
        ]
    },
    {
        "q": "Which hook is best for exposing a component's methods to its parent via a ref?",
        "o": [
            "useImperativeHandle",
            "useDeferredValue",
            "useDebugValue",
            "useSyncExternalStore"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoized = useMemo(() => new Map([[1, 'one']]), []);\nconsole.log(memoized.get(1));",
        "o": [
            "one",
            "undefined",
            "null",
            "1"
        ]
    },
    {
        "q": "What is the benefit of useDebugValue when debugging complex custom hooks?",
        "o": [
            "It provides meaningful labels for values in DevTools",
            "It memoizes complex calculations",
            "It defers hook updates",
            "It syncs hooks with external stores"
        ]
    },
    {
        "q": "What happens if you omit getServerSnapshot in useSyncExternalStore?",
        "o": [
            "It may cause issues in server-side rendering",
            "The hook throws an error",
            "The store subscription fails",
            "The state is deferred"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ active: true }));\nconsole.log(ref.current.active);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the role of isPending in the useTransition hook?",
        "o": [
            "It indicates if a transition is in progress",
            "It generates a unique ID",
            "It defers state updates",
            "It memoizes the transition"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('Debug Label');\n// In a custom hook",
        "o": [
            "Shows 'Debug Label' in React DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue({ count: 10 });\nconsole.log(deferred.count);",
        "o": [
            "10",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is used to create stable, unique identifiers for elements in React?",
        "o": [
            "useId",
            "useTransition",
            "useSyncExternalStore",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the purpose of the subscribe function in useSyncExternalStore?",
        "o": [
            "To set up a listener for external store changes",
            "To provide the initial state",
            "To defer updates to the store",
            "To generate unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id1 = useId();\nconst id2 = useId();\nconsole.log(id1 === id2);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a practical use case for useInsertionEffect?",
        "o": [
            "Inserting global styles in CSS-in-JS libraries",
            "Handling asynchronous API calls",
            "Generating unique form IDs",
            "Debugging state transitions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(isPending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to provide a formatted value for debugging in React DevTools?",
        "o": [
            "useDebugValue",
            "useDeferredValue",
            "useImperativeHandle",
            "useId"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ name: 'React' }));\nconsole.log(ref.current.name);",
        "o": [
            "React",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue for large datasets?",
        "o": [
            "It delays rendering of non-critical data to prioritize UI responsiveness",
            "It generates unique IDs for dataset items",
            "It syncs datasets with external stores",
            "It memoizes dataset calculations"
        ]
    },
    {
        "q": "What is the execution timing of useInsertionEffect compared to useEffect?",
        "o": [
            "useInsertionEffect runs before DOM mutations, useEffect after",
            "useInsertionEffect runs after useEffect",
            "Both run simultaneously",
            "useInsertionEffect runs during rendering"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => 42);\nconsole.log(value);",
        "o": [
            "42",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is a key use case for useImperativeHandle in a component library?",
        "o": [
            "Exposing specific methods for parent components to call",
            "Deferring state updates",
            "Syncing with external stores",
            "Generating accessibility IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('Custom State', (val) => `Formatted: ${val}`);\n// In a custom hook",
        "o": [
            "Displays 'Formatted: Custom State' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue('hello');\nconsole.log(deferred);",
        "o": [
            "hello",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "Which hook is used to ensure safe integration with external state management systems?",
        "o": [
            "useSyncExternalStore",
            "useId",
            "useTransition",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the primary purpose of useId in React?",
        "o": [
            "To generate stable, unique IDs for accessibility",
            "To defer non-critical updates",
            "To inject styles before rendering",
            "To debug custom hooks"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => 'external');\nconsole.log(value);",
        "o": [
            "external",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is a key use case for useInsertionEffect in React?",
        "o": [
            "Injecting dynamic styles before layout calculations",
            "Managing asynchronous state updates",
            "Generating unique IDs for elements",
            "Syncing with external data sources"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => setState(1));\nconsole.log(typeof isPending);",
        "o": [
            "boolean",
            "function",
            "object",
            "undefined"
        ]
    },
    {
        "q": "Which hook allows a component to expose a custom API to its parent via a ref?",
        "o": [
            "useImperativeHandle",
            "useDebugValue",
            "useDeferredValue",
            "useSyncExternalStore"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ count: 10 }));\nconsole.log(ref.current.count);",
        "o": [
            "10",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue in a search bar component?",
        "o": [
            "It delays rendering of search results to keep the input responsive",
            "It generates IDs for search inputs",
            "It syncs the search with an external store",
            "It injects styles for the search bar"
        ]
    },
    {
        "q": "What is the role of the getServerSnapshot function in useSyncExternalStore?",
        "o": [
            "To provide the initial state for server-side rendering",
            "To subscribe to store updates",
            "To defer state updates",
            "To debug store values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue(42, (val) => `Value: ${val}`);\n// In a custom hook",
        "o": [
            "Displays 'Value: 42' in React DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What happens if you use useId in multiple components?",
        "o": [
            "Each call generates a unique ID",
            "All components share the same ID",
            "It throws an error",
            "It returns null"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const memoized = useMemo(() => new Set(['a']), []);\nconsole.log(memoized.size);",
        "o": [
            "1",
            "0",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue({ active: true });\nconsole.log(deferred.active);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to create unique IDs for elements to support accessibility?",
        "o": [
            "useId",
            "useDeferredValue",
            "useSyncExternalStore",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the purpose of the getSnapshot function in useSyncExternalStore?",
        "o": [
            "To retrieve the current state of the external store",
            "To defer updates to the store",
            "To generate unique IDs",
            "To inject styles before rendering"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.includes(':'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key use case for useTransition in React applications?",
        "o": [
            "Marking non-urgent updates to maintain UI responsiveness",
            "Generating stable IDs for elements",
            "Subscribing to external state sources",
            "Inserting styles before DOM mutations"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ getValue: () => 42 }));\nconsole.log(ref.current.getValue());",
        "o": [
            "42",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is used to debug custom hooks by adding labels in React DevTools?",
        "o": [
            "useDebugValue",
            "useId",
            "useInsertionEffect",
            "useTransition"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => true);\nconsole.log(value);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the execution order of useInsertionEffect compared to useEffect?",
        "o": [
            "useInsertionEffect runs before useEffect",
            "useInsertionEffect runs after useEffect",
            "They run simultaneously",
            "useInsertionEffect runs during rendering"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue(0);\nconsole.log(deferred);",
        "o": [
            "0",
            "undefined",
            "null",
            "false"
        ]
    },
    {
        "q": "What is the benefit of useImperativeHandle in component libraries?",
        "o": [
            "It allows exposing a controlled API to parent components",
            "It defers non-critical updates",
            "It generates unique IDs",
            "It syncs with external stores"
        ]
    },
    {
        "q": "What is a practical use case for useDeferredValue in a typeahead component?",
        "o": [
            "Deferring rendering of suggestions to keep typing smooth",
            "Generating IDs for suggestion items",
            "Injecting styles for the input",
            "Debugging suggestion values"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('Custom Hook', (val) => `Label: ${val}`);\n// In a custom hook",
        "o": [
            "Displays 'Label: Custom Hook' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue({ id: 1 });\nconsole.log(deferred.id);",
        "o": [
            "1",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook is used to create unique identifiers for accessibility attributes in React?",
        "o": [
            "useId",
            "useDeferredValue",
            "useSyncExternalStore",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the purpose of useSyncExternalStore when integrating with libraries like Redux?",
        "o": [
            "To safely subscribe to the Redux store’s state",
            "To defer state updates",
            "To generate unique IDs",
            "To inject styles"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.startsWith(':'));",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key use case for useInsertionEffect in React?",
        "o": [
            "Inserting styles for CSS-in-JS frameworks before DOM mutations",
            "Managing concurrent state updates",
            "Generating accessibility IDs",
            "Debugging external stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nstartTransition(() => setState(42));\nconsole.log(isPending);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook enhances debugging by adding custom labels to hooks in DevTools?",
        "o": [
            "useDebugValue",
            "useImperativeHandle",
            "useId",
            "useDeferredValue"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ status: 'active' }));\nconsole.log(ref.current.status);",
        "o": [
            "active",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue in a filterable list component?",
        "o": [
            "It defers filtering to prevent UI lag during typing",
            "It generates IDs for list items",
            "It syncs the list with an external store",
            "It injects styles for the list"
        ]
    },
    {
        "q": "What is the role of the dependency array in useImperativeHandle?",
        "o": [
            "It triggers recreation of the handle when dependencies change",
            "It defers the handle’s updates",
            "It subscribes to external stores",
            "It generates unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => [1, 2]);\nconsole.log(value.length);",
        "o": [
            "2",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "What is a common use case for useId in React forms?",
        "o": [
            "Associating labels with inputs using unique IDs",
            "Deferring form submissions",
            "Syncing form data with external stores",
            "Injecting form styles"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue(100, (val) => `Count: ${val}`);\n// In a custom hook",
        "o": [
            "Displays 'Count: 100' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue('React');\nconsole.log(deferred);",
        "o": [
            "React",
            "undefined",
            "null",
            ""
        ]
    },
    {
        "q": "Which hook is used to generate stable IDs for server and client-side rendering?",
        "o": [
            "useId",
            "useSyncExternalStore",
            "useDeferredValue",
            "useInsertionEffect"
        ]
    },
    {
        "q": "What is the purpose of useSyncExternalStore’s getServerSnapshot function?",
        "o": [
            "To provide initial state for server-side rendering",
            "To subscribe to store updates",
            "To defer state updates",
            "To debug external stores"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id = useId();\nconsole.log(id.length > 0);",
        "o": [
            "true",
            "false",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a key application for useInsertionEffect in React?",
        "o": [
            "Injecting styles for CSS-in-JS before layout",
            "Managing asynchronous API calls",
            "Generating unique form IDs",
            "Syncing with external state"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(typeof startTransition);",
        "o": [
            "function",
            "boolean",
            "object",
            "undefined"
        ]
    },
    {
        "q": "Which hook is used to expose specific methods to a parent component via a ref?",
        "o": [
            "useImperativeHandle",
            "useDebugValue",
            "useTransition",
            "useId"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ value: 'test' }));\nconsole.log(ref.current.value);",
        "o": [
            "test",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue in a real-time search component?",
        "o": [
            "It delays search result updates to keep the UI responsive",
            "It generates IDs for search results",
            "It syncs search with external stores",
            "It injects styles for search"
        ]
    },
    {
        "q": "What is the role of useDebugValue in custom hooks?",
        "o": [
            "To provide custom labels for debugging in DevTools",
            "To defer hook updates",
            "To subscribe to external stores",
            "To generate unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => ({ key: 1 }));\nconsole.log(value.key);",
        "o": [
            "1",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What happens if you use useTransition for a low-priority update?",
        "o": [
            "The update is marked as non-urgent to prioritize UI rendering",
            "The update is blocked",
            "The update generates a unique ID",
            "The update is memoized"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('Hook State');\n// In a custom hook",
        "o": [
            "Displays 'Hook State' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const deferred = useDeferredValue(50);\nconsole.log(deferred);",
        "o": [
            "50",
            "undefined",
            "null",
            "0"
        ]
    },
    {
        "q": "Which hook ensures unique IDs for accessibility in both client and server rendering?",
        "o": [
            "useId",
            "useSyncExternalStore",
            "useInsertionEffect",
            "useDeferredValue"
        ]
    },
    {
        "q": "What is the purpose of the subscribe function in useSyncExternalStore?",
        "o": [
            "To listen for changes in the external store",
            "To generate unique IDs",
            "To defer state updates",
            "To inject styles"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const id1 = useId();\nconst id2 = useId();\nconsole.log(id1 === id2);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is a practical use case for useInsertionEffect in a styling framework?",
        "o": [
            "Inserting critical styles before DOM mutations",
            "Handling asynchronous data fetching",
            "Generating unique IDs for styles",
            "Debugging style transitions"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const [isPending, startTransition] = useTransition();\nconsole.log(isPending);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "Which hook is used to provide a custom interface for a ref in a child component?",
        "o": [
            "useImperativeHandle",
            "useDebugValue",
            "useDeferredValue",
            "useId"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const ref = useRef(null);\nuseImperativeHandle(ref, () => ({ active: false }));\nconsole.log(ref.current.active);",
        "o": [
            "false",
            "true",
            "undefined",
            "null"
        ]
    },
    {
        "q": "What is the benefit of useDeferredValue in a dropdown with many options?",
        "o": [
            "It defers rendering of options to keep the UI responsive",
            "It generates IDs for dropdown items",
            "It syncs the dropdown with an external store",
            "It injects styles for the dropdown"
        ]
    },
    {
        "q": "What is the role of useDebugValue in a custom hook’s development?",
        "o": [
            "To display debug information in React DevTools",
            "To defer hook execution",
            "To subscribe to external stores",
            "To generate unique IDs"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "const value = useSyncExternalStore(() => () => {}, () => 'data');\nconsole.log(value);",
        "o": [
            "data",
            "undefined",
            "null",
            "{}"
        ]
    },
    {
        "q": "What happens when you use useImperativeHandle with forwardRef?",
        "o": [
            "It customizes the ref object exposed to the parent",
            "It defers ref updates",
            "It generates a unique ID for the ref",
            "It syncs the ref with an external store"
        ]
    },
    {
        "q": "What is the output of the following code",
        "c": "useDebugValue('State Info', (val) => `Info: ${val}`);\n// In a custom hook",
        "o": [
            "Displays 'Info: State Info' in DevTools",
            "Logs to console",
            "Throws an error",
            "Does nothing"
        ]
    },
    {
        "q": "What is the primary purpose of the useEffect hook in React?",
        "o": [
            "To perform side effects in function components",
            "To manage state in function components",
            "To create context for components",
            "To memoize expensive computations"
        ]
    },
    {
        "q": "What is the output of the following code using useEffect?",
        "c": "useEffect(() => { console.log('Effect ran'); return () => console.log('Cleanup'); }, []);",
        "o": [
            "Effect ran once on mount, Cleanup on unmount",
            "Effect ran on every render, no Cleanup",
            "Cleanup ran first, then Effect",
            "No output"
        ]
    },
    {
        "q": "How does useContext differ from Redux in managing state?",
        "o": [
            "useContext is a hook for accessing context, while Redux is a global state management library",
            "useContext replaces Redux entirely",
            "useContext manages global state, while Redux is for local state",
            "useContext is used only for side effects"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useCustomHook() { const [count, setCount] = useState(0); return { count, increment: () => setCount(count + 1) }; } const { count, increment } = useCustomHook(); increment(); console.log(count);",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key benefit of using useReducer over useState for complex state logic?",
        "o": [
            "It provides a dispatch function to handle state transitions predictably",
            "It automatically memoizes state values",
            "It simplifies side effect management",
            "It is faster for simple state updates"
        ]
    },
    {
        "q": "What happens if you forget to provide a dependency array to useEffect?",
        "o": [
            "The effect runs after every render",
            "The effect never runs",
            "The effect runs only on mount",
            "It causes a runtime error"
        ]
    },
    {
        "q": "What is the output of the following useReducer code?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'INCREMENT': return state + 1; default: return state; } }; const [state, dispatch] = useReducer(reducer, 0); dispatch({ type: 'INCREMENT' }); console.log(state);",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "When creating a custom hook, what is a best practice for naming?",
        "o": [
            "Prefix the hook name with 'use' to follow React conventions",
            "Use camelCase without any prefix",
            "Prefix the hook name with 'hook'",
            "Use all uppercase letters"
        ]
    },
    {
        "q": "What is the purpose of the cleanup function returned by useEffect?",
        "o": [
            "To clean up resources or subscriptions before the component unmounts or re-renders",
            "To reset the state to its initial value",
            "To trigger the effect again",
            "To memoize the effect function"
        ]
    },
    {
        "q": "What is the output of the following useContext code?",
        "c": "const MyContext = createContext(null); function Component() { const value = useContext(MyContext); return value ? value.name : 'No context'; } const App = () => <MyContext.Provider value={{ name: 'Test' }}><Component /></MyContext.Provider>;",
        "o": [
            "Test",
            "No context",
            "null",
            "Error"
        ]
    },
    {
        "q": "What happens if a custom hook violates the Rules of Hooks (e.g., calling a hook conditionally)?",
        "o": [
            "React throws a runtime error due to inconsistent hook calls",
            "The hook works but logs a warning",
            "The component renders without issues",
            "The hook is ignored"
        ]
    },
    {
        "q": "What is the output of the following useEffect with dependencies?",
        "c": "const [count, setCount] = useState(0); useEffect(() => { console.log('Count:', count); }, [count]); setCount(1);",
        "o": [
            "Count: 1",
            "Count: 0",
            "Count: 0, Count: 1",
            "No output"
        ]
    },
    {
        "q": "How does useReducer handle complex state logic compared to useState?",
        "o": [
            "useReducer centralizes state updates in a reducer function, making logic easier to test and predict",
            "useReducer is always faster than useState",
            "useReducer cannot handle multiple state values",
            "useReducer is only for global state"
        ]
    },
    {
        "q": "What happens when you pass an empty dependency array to useEffect?",
        "o": [
            "The effect runs only once on mount and cleanup runs on unmount",
            "The effect runs on every render",
            "The effect never runs",
            "It causes a runtime error"
        ]
    },
    {
        "q": "What is the output of the following useContext code?",
        "c": "const ThemeContext = createContext({ theme: 'light' }); function Component() { const { theme } = useContext(ThemeContext); return theme; } const App = () => <ThemeContext.Provider value={{ theme: 'dark' }}><Component /></ThemeContext.Provider>;",
        "o": [
            "dark",
            "light",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key advantage of using custom hooks in React?",
        "o": [
            "They allow reusable stateful logic across components",
            "They automatically optimize rendering performance",
            "They replace all built-in hooks",
            "They simplify context management"
        ]
    },
    {
        "q": "What is the output of the following useReducer code?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'DECREMENT': return state - 1; default: return state; } }; const [state, dispatch] = useReducer(reducer, 5); dispatch({ type: 'DECREMENT' }); console.log(state);",
        "o": [
            "5",
            "4",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useEffect handle asynchronous operations, such as fetching data?",
        "o": [
            "By defining async logic inside the effect and using a cleanup function for cancellation",
            "By automatically awaiting promises in the dependency array",
            "By requiring a separate useAsync hook",
            "By blocking the main thread until the async operation completes"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useToggle(initial = false) { const [value, setValue] = useState(initial); return [value, () => setValue(!value)]; } const [isOn, toggle] = useToggle(true); toggle(); console.log(isOn);",
        "o": [
            "true",
            "false",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the role of the dispatch function in useReducer?",
        "o": [
            "It triggers state updates by sending actions to the reducer",
            "It directly modifies the state",
            "It memoizes the reducer function",
            "It handles side effects automatically"
        ]
    },
    {
        "q": "What happens if you call useContext outside of a Provider?",
        "o": [
            "It returns the default value passed to createContext",
            "It throws a runtime error",
            "It returns undefined regardless of the default value",
            "It creates a new context automatically"
        ]
    },
    {
        "q": "What is the output of the following useEffect code with multiple dependencies?",
        "c": "const [a, setA] = useState(0); const [b, setB] = useState(0); useEffect(() => { console.log('Effect:', a, b); }, [a, b]); setA(1);",
        "o": [
            "Effect: 1 0",
            "Effect: 0 0",
            "Effect: 1 1",
            "No output"
        ]
    },
    {
        "q": "When should you use useReducer instead of useState?",
        "o": [
            "When managing complex state logic with multiple sub-values or dependent transitions",
            "When you need to memoize state values",
            "When you want to avoid re-renders",
            "When handling simple boolean toggles"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useCounter() { const [count, setCount] = useState(0); useEffect(() => { setCount(count + 1); }, []); return count; } console.log(useCounter());",
        "o": [
            "1",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue when using useEffect with an async function?",
        "o": [
            "useEffect does not support async functions directly and requires a wrapper function",
            "Async functions automatically trigger re-renders",
            "Async functions cannot be used with cleanup functions",
            "Async functions are not allowed in React hooks"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with multiple actions?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'ADD': return state + action.payload; default: return state; } }; const [state, dispatch] = useReducer(reducer, 0); dispatch({ type: 'ADD', payload: 3 }); console.log(state);",
        "o": [
            "0",
            "3",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the purpose of the second argument in the useEffect hook?",
        "o": [
            "To specify dependencies that control when the effect runs",
            "To define the cleanup function",
            "To pass state variables to the effect",
            "To set the initial state of the component"
        ]
    },
    {
        "q": "What is the output of the following useContext code?",
        "c": "const UserContext = createContext({ user: null }); function Component() { const { user } = useContext(UserContext); return user?.name || 'Guest'; } const App = () => <UserContext.Provider value={{ user: { name: 'Alice' } }}><Component /></UserContext.Provider>;",
        "o": [
            "Alice",
            "Guest",
            "null",
            "Error"
        ]
    },
    {
        "q": "What is a common use case for creating a custom hook in React?",
        "o": [
            "To encapsulate reusable logic like data fetching or form handling",
            "To replace all built-in React hooks",
            "To directly manipulate the DOM",
            "To manage global state without context"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with a complex reducer?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'TOGGLE': return { ...state, active: !state.active }; default: return state; } }; const [state, dispatch] = useReducer(reducer, { active: false }); dispatch({ type: 'TOGGLE' }); console.log(state.active);",
        "o": [
            "true",
            "false",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can you prevent useEffect from running on the initial render?",
        "o": [
            "By using a ref to track the initial render and conditionally running the effect",
            "By passing an empty dependency array",
            "By omitting the dependency array",
            "It is not possible to skip the initial render"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useWindowSize() { const [size, setSize] = useState(window.innerWidth); useEffect(() => { const updateSize = () => setSize(window.innerWidth); window.addEventListener('resize', updateSize); return () => window.removeEventListener('resize', updateSize); }, []); return size; } console.log(useWindowSize());",
        "o": [
            "Current window width",
            "undefined",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is a key difference between useState and useReducer when updating state?",
        "o": [
            "useReducer uses a reducer function to manage state transitions, while useState directly updates state",
            "useState is only for complex state logic",
            "useReducer cannot handle asynchronous updates",
            "useState is deprecated in modern React"
        ]
    },
    {
        "q": "What happens if you call a custom hook conditionally in a component?",
        "o": [
            "React throws an error due to violation of the Rules of Hooks",
            "The hook executes normally but logs a warning",
            "The hook is skipped silently",
            "The component re-renders infinitely"
        ]
    },
    {
        "q": "What is the output of the following useEffect code with a cleanup function?",
        "c": "useEffect(() => { const timer = setInterval(() => console.log('Tick'), 1000); return () => clearInterval(timer); }, []);",
        "o": [
            "Logs 'Tick' every second until component unmounts",
            "Logs 'Tick' once on mount",
            "No output",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useContext with useReducer for global state management?",
        "o": [
            "It allows centralized state management across components without prop drilling",
            "It automatically optimizes performance for all components",
            "It replaces the need for custom hooks",
            "It simplifies side effect handling"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with multiple dispatches?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'INCREMENT': return state + 1; default: return state; } }; const [state, dispatch] = useReducer(reducer, 0); dispatch({ type: 'INCREMENT' }); dispatch({ type: 'INCREMENT' }); console.log(state);",
        "o": [
            "0",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useEffect for data fetching without proper cleanup?",
        "o": [
            "It can cause memory leaks or race conditions if the component unmounts before the fetch completes",
            "It slows down the initial render",
            "It prevents the fetch from completing",
            "It causes the component to re-render infinitely"
        ]
    },
    {
        "q": "What is the output of the following custom hook code with useEffect?",
        "c": "function useDataFetch(url) { const [data, setData] = useState(null); useEffect(() => { setData('Fetched'); }, [url]); return data; } console.log(useDataFetch('/api'));",
        "o": [
            "Fetched",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the behavior of useEffect when dependencies are omitted?",
        "o": [
            "The effect runs after every render",
            "The effect runs only on mount",
            "The effect never runs",
            "It causes a linting error but runs once"
        ]
    },
    {
        "q": "What is the output of the following useContext code with nested providers?",
        "c": "const ThemeContext = createContext('light'); const UserContext = createContext(null); function Component() { const theme = useContext(ThemeContext); const user = useContext(UserContext); return `${theme} - ${user?.name || 'Unknown'}`; } const App = () => <ThemeContext.Provider value='dark'><UserContext.Provider value={{ name: 'Bob' }}><Component /></UserContext.Provider></ThemeContext.Provider>;",
        "o": [
            "dark - Bob",
            "light - Unknown",
            "dark - Unknown",
            "Error"
        ]
    },
    {
        "q": "What makes custom hooks shareable across components without sharing state?",
        "o": [
            "Each call to a custom hook creates its own local state instances",
            "Custom hooks always share state globally",
            "They require a single instance per app",
            "They cannot be called multiple times"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with lazy initialization?",
        "c": "const reducer = (state, action) => state; const initState = () => ({ count: 0 }); const [state, dispatch] = useReducer(reducer, undefined, initState); console.log(state.count);",
        "o": [
            "0",
            "undefined",
            "Error",
            "null"
        ]
    },
    {
        "q": "How does useEffect's dependency array handle object dependencies?",
        "o": [
            "Shallow comparison; objects must be memoized with useMemo to avoid unnecessary re-runs",
            "Deep comparison for all properties",
            "Ignores object dependencies entirely",
            "Automatically memosizes objects"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useLocalStorage(key, initial) { const [value, setValue] = useState(() => localStorage.getItem(key) || initial); useEffect(() => { localStorage.setItem(key, JSON.stringify(value)); }, [key, value]); return [value, setValue]; } const [stored, setStored] = useLocalStorage('test', 'default'); console.log(stored);",
        "o": [
            "default",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the purpose of the third argument in useReducer?",
        "o": [
            "A function to lazily initialize the state",
            "A cleanup function",
            "Dependencies for the reducer",
            "The initial action to dispatch"
        ]
    },
    {
        "q": "What occurs when useContext is called in a component not wrapped by its Provider?",
        "o": [
            "It falls back to the default value specified in createContext",
            "It throws a runtime error",
            "It returns the nearest parent's context",
            "It creates a new Provider implicitly"
        ]
    },
    {
        "q": "What is the output of the following useEffect code with stale closure?",
        "c": "const [count, setCount] = useState(0); useEffect(() => { const id = setInterval(() => setCount(c => c + 1), 1000); return () => clearInterval(id); }, []);",
        "o": [
            "Count increments every second without stale value issues",
            "Count uses stale closure and doesn't increment",
            "Error on setInterval",
            "No increment due to empty dependencies"
        ]
    },
    {
        "q": "What is a drawback of using useReducer for simple state management?",
        "o": [
            "It adds unnecessary boilerplate compared to useState",
            "It cannot handle primitive state",
            "It always causes extra re-renders",
            "It is not compatible with custom hooks"
        ]
    },
    {
        "q": "What is the output of the following useReducer code?",
        "c": "const reducer = (state, action) => { if (action.type === 'RESET') return 0; return state + (action.type === 'INCREMENT' ? 1 : 0); }; const [state, dispatch] = useReducer(reducer, 5); dispatch({ type: 'INCREMENT' }); dispatch({ type: 'RESET' }); console.log(state);",
        "o": [
            "0",
            "6",
            "5",
            "Error"
        ]
    },
    {
        "q": "What is the role of ESLint's react-hooks/exhaustive-deps rule?",
        "o": [
            "To warn about missing or unused dependencies in useEffect and other hooks",
            "To enforce hook order in components",
            "To optimize hook performance",
            "To prevent custom hook creation"
        ]
    },
    {
        "q": "What is the output of the following custom hook code with multiple effects?",
        "c": "function useMultiEffect() { const [a, setA] = useState(0); useEffect(() => { setA(1); }, []); useEffect(() => { console.log('Second effect'); }, []); return a; } console.log(useMultiEffect());",
        "o": [
            "1",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the implication of including a function in the useEffect dependency array without memoization?",
        "o": [
            "The effect runs on every render due to new function instances",
            "The effect ignores the function dependency",
            "The function is automatically memoized",
            "It causes a runtime error"
        ]
    },
    {
        "q": "What is the output of the following useContext code with multiple contexts?",
        "c": "const Ctx1 = createContext(1); const Ctx2 = createContext(2); function Component() { const v1 = useContext(Ctx1); const v2 = useContext(Ctx2); return v1 * v2; } const App = () => <Ctx1.Provider value={3}><Ctx2.Provider value={4}><Component /></Ctx2.Provider></Ctx1.Provider>;",
        "o": [
            "12",
            "2",
            "6",
            "Error"
        ]
    },
    {
        "q": "What is a critical rule when designing custom hooks?",
        "o": [
            "Custom hooks must be called at the top level of function components or other custom hooks",
            "Custom hooks can be called conditionally",
            "Custom hooks must return a single value",
            "Custom hooks cannot use other hooks"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with lazy init and action?",
        "c": "const reducer = (state, action) => ({ ...state, count: state.count + 1 }); const init = () => ({ count: 0 }); const [state, dispatch] = useReducer(reducer, undefined, init); dispatch({ type: 'inc' }); console.log(state.count);",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can you optimize useEffect to avoid unnecessary API calls when dependencies change?",
        "o": [
            "Use useMemo to stabilize dependency values or implement debouncing inside the effect",
            "Always use an empty dependency array",
            "Omit dependencies entirely",
            "React automatically optimizes API calls"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function useDerivedValue(base) { return useMemo(() => base * 2, [base]); } const derived = useDerivedValue(5); console.log(derived);",
        "o": [
            "10",
            "5",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the advantage of combining useContext with useReducer?",
        "o": [
            "It enables scalable global state management similar to Redux but with less boilerplate",
            "It restricts state to local components",
            "It eliminates the need for dispatch functions",
            "It automatically handles optimistic updates"
        ]
    },
    {
        "q": "What happens if the reducer function in useReducer is not pure?",
        "o": [
            "It can lead to unpredictable state updates or infinite re-renders",
            "React ignores impure reducers",
            "It causes a linting error but works fine",
            "The state is reset to initial value"
        ]
    },
    {
        "q": "What is the output of the following useEffect code with ref for initial run?",
        "c": "const [count, setCount] = useState(0); const isInitial = useRef(true); useEffect(() => { if (isInitial.current) { isInitial.current = false; return; } console.log('Not initial'); }, [count]); setCount(1);",
        "o": [
            "No output",
            "Not initial",
            "Error",
            "Not initial (twice)"
        ]
    },
    {
        "q": "What is a best practice for error handling in custom hooks using useEffect?",
        "o": [
            "Use try-catch inside the effect and manage error state with useState",
            "Rely on React's error boundaries exclusively",
            "Ignore errors to prevent re-renders",
            "Use console.error only"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with conditional dispatch?",
        "c": "const reducer = (state, action) => { if (action?.type === 'UPDATE') return { ...state, value: action.payload }; return state; }; const [state, dispatch] = useReducer(reducer, { value: '' }); dispatch({ payload: 'new' }); console.log(state.value);",
        "o": [
            "",
            "new",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the purpose of useCallback in relation to custom hooks?",
        "o": [
            "To memoize functions returned by custom hooks to prevent unnecessary re-renders in child components",
            "To initialize state lazily",
            "To handle context updates",
            "To clean up effects automatically"
        ]
    },
    {
        "q": "What is the output of the following custom hook code with shared logic?",
        "c": "function useSharedLogic(initial) { const [val, setVal] = useState(initial); const update = () => setVal(v => v + 1); useEffect(() => { update(); }, []); return val; } const result1 = useSharedLogic(0); const result2 = useSharedLogic(0); console.log(result1, result2);",
        "o": [
            "1 1",
            "0 0",
            "1 0",
            "Error"
        ]
    },
    {
        "q": "What is the consequence of mutating state directly in a useReducer reducer?",
        "o": [
            "It violates React's immutability principle and can cause unexpected re-renders or bugs",
            "It is allowed and optimizes performance",
            "It automatically triggers a re-render",
            "It prevents state updates"
        ]
    },
    {
        "q": "What is the output of the following useContext code with default value?",
        "c": "const AuthContext = createContext({ authenticated: false }); function Component() { const { authenticated } = useContext(AuthContext); return authenticated ? 'Logged in' : 'Logged out'; } const App = () => <Component />;",
        "o": [
            "Logged out",
            "Logged in",
            "false",
            "Error"
        ]
    },
    {
        "q": "What is an essential consideration when passing props to a custom hook?",
        "o": [
            "Props can be used as dependencies in effects within the custom hook",
            "Custom hooks cannot accept props",
            "Props are automatically memoized",
            "Props must be immutable objects"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with non-standard action?",
        "c": "const reducer = (state, action) => { switch (action.type) { case 'MULTIPLY': return state * action.factor; default: return state; } }; const [state, dispatch] = useReducer(reducer, 10); dispatch({ type: 'MULTIPLY', factor: 2 }); console.log(state);",
        "o": [
            "10",
            "20",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useEffect interact with concurrent rendering in React?",
        "o": [
            "Effects run after the browser has painted, but concurrent features may defer them further",
            "Effects block concurrent rendering",
            "Effects are skipped in concurrent mode",
            "Concurrent rendering ignores useEffect"
        ]
    },
    {
        "q": "What is the output of the following custom hook code?",
        "c": "function usePrevious(value) { const ref = useRef(); useEffect(() => { ref.current = value; }, [value]); return ref.current; } const prev = usePrevious(5); console.log(prev);",
        "o": [
            "undefined",
            "5",
            "null",
            "Error"
        ]
    },
    {
        "q": "What is the recommended way to handle loading states in a custom data-fetching hook?",
        "o": [
            "Return an object with loading, data, and error states from the hook",
            "Use useEffect exclusively for loading",
            "Rely on global context for loading",
            "Loading is handled automatically"
        ]
    },
    {
        "q": "What happens when the default value in createContext is a complex object?",
        "o": [
            "It is used as-is for components without a Provider, but should be stable to avoid issues",
            "It is automatically cloned for each useContext call",
            "It causes a warning in development",
            "Complex objects are not allowed"
        ]
    },
    {
        "q": "What is the output of the following useEffect code with useCallback dependency?",
        "c": "const [count, setCount] = useState(0); const handleClick = useCallback(() => setCount(c => c + 1), []); useEffect(() => { console.log('Effect with callback'); }, [handleClick]);",
        "o": [
            "Effect with callback (runs once due to memoized callback)",
            "Effect with callback (runs every render)",
            "No output",
            "Error"
        ]
    },
    {
        "q": "What is a limitation of useReducer compared to Redux?",
        "o": [
            "useReducer lacks middleware support and devtools integration out of the box",
            "useReducer is not suitable for global state",
            "useReducer cannot handle async actions",
            "useReducer is slower than useState"
        ]
    },
    {
        "q": "What is the output of the following useReducer code with lazy initializer?",
        "c": "const expensiveInit = () => { console.log('Init called'); return 42; }; const reducer = (state, action) => state; const [state, dispatch] = useReducer(reducer, undefined, expensiveInit); console.log(state);",
        "o": [
            "Init called, 42",
            "42 (no init log)",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the best practice for testing custom hooks in React?",
        "o": [
            "Use React Testing Library with a renderHook utility to isolate and test the hook",
            "Test hooks within full component renders only",
            "Mock all dependencies manually",
            "Hooks cannot be unit tested"
        ]
    },
    {
        "q": "What is the output of the following custom hook code with conditional effect?",
        "c": "function useConditionalEffect(condition) { useEffect(() => { console.log('Conditional effect'); }, condition ? [condition] : []); } useConditionalEffect(true);",
        "o": [
            "Conditional effect",
            "No output",
            "Error due to Rules of Hooks violation",
            "Infinite loop"
        ]
    },
    {
        "q": "What is the primary use case for the useMemo hook when used within a custom hook?",
        "o": [
            "To memoize computationally expensive values to avoid recalculation on every render",
            "To manage side effects in custom hooks",
            "To replace useState for state management",
            "To handle context updates automatically"
        ]
    },
    {
        "q": "What is the output of the following useRef code within a custom hook?",
        "c": "function useCounter() { const countRef = useRef(0); const increment = () => { countRef.current += 1; return countRef.current; }; return increment; } const inc = useCounter(); console.log(inc()); console.log(inc());",
        "o": [
            "1, 2",
            "0, 0",
            "1, 1",
            "Error"
        ]
    },
    {
        "q": "How does useCallback differ from useMemo when used in a custom hook?",
        "o": [
            "useCallback memoizes functions, while useMemo memoizes any computed value",
            "useCallback is for state updates, useMemo is for effects",
            "useCallback memoizes values, useMemo memoizes functions",
            "They are identical in functionality"
        ]
    },
    {
        "q": "What is the output of the following useMemo code?",
        "c": "function Component() { const [a, setA] = useState(2); const result = useMemo(() => a * 2, [a]); setA(3); return result; } console.log(Component());",
        "o": [
            "4",
            "6",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a common use case for useRef in a custom hook?",
        "o": [
            "To persist values across renders without triggering re-renders",
            "To manage component state directly",
            "To memoize expensive computations",
            "To handle context updates"
        ]
    },
    {
        "q": "What is the output of the following useCallback code?",
        "c": "function useCustomCallback(value) { return useCallback(() => console.log(value), [value]); } const callback = useCustomCallback('test'); callback();",
        "o": [
            "test",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "Why might you combine useRef with useEffect in a custom hook?",
        "o": [
            "To store a mutable value that persists across renders and manage side effects",
            "To replace useState for state management",
            "To memoize the effect function",
            "To prevent side effects entirely"
        ]
    },
    {
        "q": "What is the output of the following useMemo code with complex dependency?",
        "c": "function useComplexMemo(obj) { return useMemo(() => obj.value * 2, [obj]); } const obj = { value: 5 }; console.log(useComplexMemo(obj));",
        "o": [
            "10",
            "5",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential pitfall when using useRef for DOM manipulation in a custom hook?",
        "o": [
            "The ref may be null if the DOM element is not yet rendered",
            "Refs cannot be used in custom hooks",
            "Refs trigger re-renders when updated",
            "Refs are automatically cleared on unmount"
        ]
    },
    {
        "q": "What is the output of the following useRef and useEffect combination?",
        "c": "function useFocus() { const ref = useRef(null); useEffect(() => { if (ref.current) ref.current.focus(); }, []); return ref; } const inputRef = useFocus(); console.log(inputRef.current);",
        "o": [
            "null",
            "undefined",
            "Error",
            "DOM element"
        ]
    },
    {
        "q": "How does useMemo improve performance in a custom hook handling large datasets?",
        "o": [
            "By caching computed results and only recalculating when dependencies change",
            "By automatically batching state updates",
            "By reducing the number of effect runs",
            "By replacing useEffect entirely"
        ]
    },
    {
        "q": "What is the output of the following useCallback code with incorrect dependencies?",
        "c": "function useIncorrectCallback(count) { return useCallback(() => count, []); } const [count, setCount] = useState(0); const callback = useIncorrectCallback(count); setCount(1); console.log(callback());",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useRef over useState for tracking previous state in a custom hook?",
        "o": [
            "useRef avoids triggering re-renders when updated, unlike useState",
            "useRef automatically memoizes the state",
            "useRef is faster for state updates",
            "useRef cannot track previous state"
        ]
    },
    {
        "q": "What is the primary use of useImperativeHandle in a custom hook?",
        "o": [
            "To expose specific ref methods to parent components via forwardRef",
            "To manage state imperatively",
            "To replace useRef for DOM manipulation",
            "To memoize imperative functions"
        ]
    },
    {
        "q": "What is the output of the following useRef code in a custom hook?",
        "c": "function useTimer() { const timerRef = useRef(null); useEffect(() => { timerRef.current = setTimeout(() => console.log('Timeout'), 1000); return () => clearTimeout(timerRef.current); }, []); return timerRef.current; } console.log(useTimer());",
        "o": [
            "Timeout ID",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useLayoutEffect differ from useEffect in a custom hook?",
        "o": [
            "useLayoutEffect runs synchronously after DOM mutations but before painting, while useEffect runs asynchronously after painting",
            "useLayoutEffect is for state updates, useEffect is for memoization",
            "useLayoutEffect runs before useEffect in all cases",
            "useLayoutEffect cannot be used in custom hooks"
        ]
    },
    {
        "q": "What is the output of the following useMemo code with conditional logic?",
        "c": "function useConditionalMemo(flag) { return useMemo(() => flag ? 'On' : 'Off', [flag]); } console.log(useConditionalMemo(true));",
        "o": [
            "On",
            "Off",
            "true",
            "Error"
        ]
    },
    {
        "q": "What is a key consideration when using useImperativeHandle in a custom hook?",
        "o": [
            "It requires forwardRef to expose methods to parent components",
            "It automatically memoizes the ref",
            "It replaces useEffect for side effects",
            "It cannot be used with functional components"
        ]
    },
    {
        "q": "What is the output of the following useLayoutEffect code?",
        "c": "function useLayoutLogger() { useLayoutEffect(() => { console.log('Layout effect'); }, []); return 'Done'; } console.log(useLayoutLogger());",
        "o": [
            "Layout effect, Done",
            "Done",
            "Error",
            "undefined"
        ]
    },
    {
        "q": "Why might you use useDebugValue in a custom hook?",
        "o": [
            "To display custom debugging information in React DevTools",
            "To log errors to the console",
            "To debug state updates automatically",
            "To replace useEffect for debugging"
        ]
    },
    {
        "q": "What is the output of the following useRef code with multiple updates?",
        "c": "function useRefCounter() { const ref = useRef(0); const update = () => { ref.current += 1; }; update(); update(); return ref.current; } console.log(useRefCounter());",
        "o": [
            "2",
            "0",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useDebugValue with a custom hook in development?",
        "o": [
            "It improves debugging by labeling hook state in React DevTools",
            "It optimizes performance in production",
            "It logs all state changes automatically",
            "It replaces console.log for debugging"
        ]
    },
    {
        "q": "What is the output of the following useImperativeHandle code?",
        "c": "const MyInput = forwardRef((props, ref) => { const inputRef = useRef(); useImperativeHandle(ref, () => ({ focus: () => inputRef.current.focus() })); return <input ref={inputRef} />; }); const ref = useRef(); console.log(ref.current);",
        "o": [
            "null",
            "Object with focus method",
            "DOM input element",
            "Error"
        ]
    },
    {
        "q": "How does useLayoutEffect improve performance for DOM measurements in a custom hook?",
        "o": [
            "By running before browser paint, it prevents layout thrashing during DOM updates",
            "By memoizing DOM calculations",
            "By deferring DOM updates to useEffect",
            "By skipping DOM measurements entirely"
        ]
    },
    {
        "q": "What is the output of the following useMemo code with object dependency?",
        "c": "function useObjectMemo(data) { return useMemo(() => ({ computed: data.value + 1 }), [data.value]); } const input = { value: 5 }; console.log(useObjectMemo(input).computed);",
        "o": [
            "6",
            "5",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue when using useDebugValue in a custom hook?",
        "o": [
            "It only works in development mode and has no effect in production",
            "It slows down the hook in development",
            "It causes re-renders when debug values change",
            "It cannot be used with other hooks"
        ]
    },
    {
        "q": "What is the primary purpose of useId in a custom hook?",
        "o": [
            "To generate unique IDs for accessibility or DOM elements",
            "To manage component state",
            "To memoize DOM references",
            "To handle form submissions"
        ]
    },
    {
        "q": "What is the output of the following useDebugValue code?",
        "c": "function useCustomStatus(status) { useDebugValue(status ? 'Active' : 'Inactive'); return status; } console.log(useCustomStatus(true));",
        "o": [
            "true",
            "Active",
            "Inactive",
            "Error"
        ]
    },
    {
        "q": "How does useTransition benefit a custom hook handling UI updates?",
        "o": [
            "It allows marking updates as non-urgent to prevent blocking the UI",
            "It replaces useEffect for side effects",
            "It memoizes state transitions",
            "It handles form validation"
        ]
    },
    {
        "q": "What is the output of the following useId code?",
        "c": "function useCustomId() { const id = useId(); return id; } console.log(useCustomId());",
        "o": [
            "Unique string ID",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key consideration when using useTransition in a custom hook?",
        "o": [
            "Ensure transitions are only used for non-critical updates to maintain responsiveness",
            "Use it for all state updates",
            "It cannot be used with useState",
            "It requires a dependency array"
        ]
    },
    {
        "q": "What is the output of the following useLayoutEffect code with DOM manipulation?",
        "c": "function useLayoutAdjust() { const ref = useRef(null); useLayoutEffect(() => { if (ref.current) ref.current.style.color = 'red'; }, []); return ref; } const ref = useLayoutAdjust(); console.log(ref.current);",
        "o": [
            "null",
            "DOM element with red color",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "Why is useDebugValue particularly useful in complex custom hooks?",
        "o": [
            "It provides meaningful debug labels for state or computed values in React DevTools",
            "It logs all hook outputs to the console",
            "It optimizes hook performance",
            "It simplifies state management"
        ]
    },
    {
        "q": "What is the output of the following useTransition code?",
        "c": "function useTransitionExample() { const [isPending, startTransition] = useTransition(); startTransition(() => console.log('Transition')); return isPending; } console.log(useTransitionExample());",
        "o": [
            "false",
            "true",
            "Transition",
            "Error"
        ]
    },
    {
        "q": "What is a potential pitfall when using useId in a custom hook?",
        "o": [
            "The generated ID may not be stable across server and client renders",
            "It cannot be used with multiple components",
            "It causes re-renders when called",
            "It generates non-unique IDs"
        ]
    },
    {
        "q": "What is the output of the following useImperativeHandle with useRef?",
        "c": "const MyComponent = forwardRef((props, ref) => { const inputRef = useRef(); useImperativeHandle(ref, () => ({ clear: () => inputRef.current.value = '' })); return <input ref={inputRef} />; }); const ref = useRef(); console.log(ref.current);",
        "o": [
            "null",
            "Object with clear method",
            "DOM input element",
            "Error"
        ]
    },
    {
        "q": "How does useTransition improve user experience in a custom hook for search filtering?",
        "o": [
            "By deferring expensive filter updates to keep the UI responsive",
            "By memoizing filter results",
            "By replacing useEffect for filtering",
            "By blocking UI updates"
        ]
    },
    {
        "q": "What is the output of the following useDebugValue with computed value?",
        "c": "function useComplexValue(num) { const value = useMemo(() => num * 2, [num]); useDebugValue(`Computed: ${value}`); return value; } console.log(useComplexValue(3));",
        "o": [
            "6",
            "Computed: 6",
            "3",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useId over manual ID generation in a custom hook?",
        "o": [
            "It ensures unique IDs across server and client rendering",
            "It memoizes IDs automatically",
            "It replaces useRef for ID tracking",
            "It generates human-readable IDs"
        ]
    },
    {
        "q": "What is the primary purpose of useDeferredValue in a custom hook?",
        "o": [
            "To defer non-critical updates to improve performance and responsiveness",
            "To synchronize external store updates",
            "To insert styles before DOM mutations",
            "To generate unique IDs for elements"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code?",
        "c": "function useDeferredSearch(query) { const deferredQuery = useDeferredValue(query); console.log(deferredQuery); return deferredQuery; } const deferred = useDeferredSearch('initial');",
        "o": [
            "initial",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "How does useSyncExternalStore work in a custom hook for integrating with external stores?",
        "o": [
            "It subscribes to external store changes and provides a snapshot for React to track",
            "It defers store updates to non-urgent transitions",
            "It caches store values across renders",
            "It replaces useContext for global state"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code?",
        "c": "const store = { getSnapshot: () => 'value', subscribe: () => () => {} }; function useStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useStore());",
        "o": [
            "value",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "What is the role of useInsertionEffect in React?",
        "o": [
            "To insert styles into the DOM before layout effects run, useful for CSS-in-JS libraries",
            "To handle deferred value updates",
            "To sync external store subscriptions",
            "To debug hook values"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code?",
        "c": "function useInsertStyle() { useInsertionEffect(() => { console.log('Style inserted'); }, []); return 'Styled'; } console.log(useInsertStyle());",
        "o": [
            "Style inserted, Styled",
            "Styled",
            "Error",
            "undefined"
        ]
    },
    {
        "q": "What is a key benefit of using useDeferredValue for rendering large lists?",
        "o": [
            "It keeps the UI responsive by rendering a previous value while the new one loads",
            "It immediately renders the new value",
            "It skips rendering large lists entirely",
            "It caches the entire list"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with state change?",
        "c": "let externalState = 'old'; const store = { getSnapshot: () => externalState, subscribe: (cb) => { const handler = () => cb(); return handler; } }; function useExternal() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } externalState = 'new'; console.log(useExternal());",
        "o": [
            "new",
            "old",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "When should you use useInsertionEffect in a custom hook?",
        "o": [
            "When building a CSS-in-JS library that needs to inject styles before any layout calculations",
            "For general state management",
            "To handle user input deferral",
            "To sync browser APIs"
        ]
    },
    {
        "q": "What is a potential issue with misuse of useDeferredValue in a custom hook?",
        "o": [
            "It may cause the UI to show stale data longer than necessary if overused",
            "It always blocks the UI",
            "It prevents state updates",
            "It causes infinite re-renders"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect with dependency?",
        "c": "function useDynamicInsert(value) { useInsertionEffect(() => { console.log('Insert:', value); }, [value]); } useDynamicInsert('test');",
        "o": [
            "Insert: test",
            "test",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useSyncExternalStore ensure consistency in a custom hook for browser APIs?",
        "o": [
            "By providing a way to subscribe to and get snapshots from mutable external data sources",
            "By automatically memoizing API calls",
            "By deferring API responses",
            "By inserting API data before rendering"
        ]
    },
    {
        "q": "What is the benefit of combining useDeferredValue with useTransition in a custom hook?",
        "o": [
            "It allows marking updates as low-priority while deferring values for even better responsiveness",
            "It replaces useState for external stores",
            "It syncs insertions with transitions",
            "It generates IDs for transitions"
        ]
    },
    {
        "q": "What is the main advantage of using useTransition for state updates in a custom hook?",
        "o": [
            "It marks updates as non-urgent, allowing React to interrupt them for more important renders",
            "It automatically batches all state updates",
            "It replaces useState for urgent updates",
            "It defers all renders indefinitely"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code?",
        "c": "const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); setQuery('search'); console.log(deferredQuery);",
        "o": [
            "'search' (after a brief delay if rendering is busy)",
            "",
            "'search' immediately",
            "undefined"
        ]
    },
    {
        "q": "How does useSyncExternalStore prevent tearing in a custom hook subscribing to an external store?",
        "o": [
            "By ensuring the snapshot is read atomically during render",
            "By memoizing the entire store",
            "By deferring subscriptions until after render",
            "By using useEffect for all updates"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code in a CSS-in-JS hook?",
        "c": "function useCSS(rule) { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = rule; document.head.appendChild(style); return () => document.head.removeChild(style); }, [rule]); } useCSS('.test { color: red; }');",
        "o": [
            "Styles inserted before layout effects run",
            "No style insertion",
            "Error in cleanup",
            "Styles appended after paint"
        ]
    },
    {
        "q": "What is a best practice for error boundaries in custom hooks using useEffect for async operations?",
        "o": [
            "Throw errors inside the effect to propagate to the nearest error boundary",
            "Catch errors silently to avoid re-renders",
            "Use useState to store errors without throwing",
            "Error boundaries do not work with hooks"
        ]
    },
    {
        "q": "What is the output of the following useTransition code with pending state?",
        "c": "const [isPending, startTransition] = useTransition(); startTransition(() => { /* heavy update */ }); console.log(isPending);",
        "o": [
            "true (during the transition)",
            "false",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "In a custom hook, how should you handle cleanup for event listeners added in useLayoutEffect?",
        "o": [
            "Return a cleanup function to remove listeners before the browser paints",
            "Cleanup is not needed in useLayoutEffect",
            "Use useEffect instead for all listeners",
            "Listeners are automatically removed"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with invalidation?",
        "c": "let count = 0; const store = { getSnapshot: () => count, subscribe: (onStoreChange) => { const handler = () => onStoreChange(); return handler; } }; function useCount() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } count++; console.log(useCount());",
        "o": [
            "Updated count value",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the role of useDeferredValue in optimizing typeahead search in a custom hook?",
        "o": [
            "It renders the search UI with the previous query while computing the new one, keeping input responsive",
            "It blocks input until search completes",
            "It caches all previous queries",
            "It uses transitions for all searches"
        ]
    },
    {
        "q": "What happens if you forget to unsubscribe in useSyncExternalStore's subscribe callback?",
        "o": [
            "It can cause memory leaks from dangling subscriptions",
            "React automatically unsubscribes",
            "The hook ignores the subscription",
            "It triggers a warning but works"
        ]
    },
    {
        "q": "What is the output of the following combined useTransition and useDeferredValue code?",
        "c": "const [tab, setTab] = useState(0); const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const [isPending, startTransition] = useTransition(); startTransition(() => setTab(1)); setQuery('deferred'); console.log(deferredQuery, isPending);",
        "o": [
            "'deferred', true (temporarily)",
            "'', false",
            "'deferred', false",
            "Error"
        ]
    },
    {
        "q": "How can useInsertionEffect be misused in a custom hook leading to performance issues?",
        "o": [
            "By including it in dependency arrays that change frequently, causing repeated style insertions",
            "It never affects performance",
            "By using it for state updates",
            "It only runs in development"
        ]
    },
    {
        "q": "What is a strategy for testing useDeferredValue behavior in a custom hook unit test?",
        "o": [
            "Mock React's scheduler to simulate busy rendering and assert deferred value lags",
            "Disable deferral in tests",
            "Use real-time delays only",
            "DeferredValue cannot be tested"
        ]
    },
    {
        "q": "What is the primary use of useOptimistic in React for handling optimistic updates?",
        "o": [
            "To immediately update the UI with an optimistic state while awaiting server confirmation",
            "To defer optimistic renders until confirmed",
            "To rollback all state changes automatically",
            "To memoize optimistic values"
        ]
    },
    {
        "q": "What is the output of the following useActionState code?",
        "c": "function MyForm() { const [state, action, isPending] = useActionState(async (prev, formData) => { const result = await submit(formData); return result; }, null); return <form action={action}>{isPending ? 'Loading...' : 'Submit'}</form>; }",
        "o": [
            "Submit (initially), Loading... during submission",
            "Loading... always",
            "null",
            "Error"
        ]
    },
    {
        "q": "How does useFormStatus integrate with useActionState in a form component?",
        "o": [
            "useFormStatus provides pending state for the nearest form without direct prop passing",
            "It requires explicit prop drilling from useActionState",
            "It replaces useActionState entirely",
            "It only works with uncontrolled forms"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code?",
        "c": "const [optimisticState, addOptimistic] = useOptimistic(state, (current, update) => ({ ...current, ...update })); addOptimistic({ item: 'new' }); console.log(optimisticState.item);",
        "o": [
            "new",
            "undefined",
            "state.item",
            "Error"
        ]
    },
    {
        "q": "What is a key benefit of useActionState over manual form handling with useState?",
        "o": [
            "It simplifies server actions with built-in pending state and error handling",
            "It avoids server mutations entirely",
            "It memoizes form data automatically",
            "It requires no async functions"
        ]
    },
    {
        "q": "What happens when an optimistic update reverts due to server error in useOptimistic?",
        "o": [
            "The UI reverts to the previous state, and the error can be handled separately",
            "The optimistic state persists regardless",
            "It throws an uncaught error",
            "The component unmounts"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code?",
        "c": "function SubmitButton() { const { pending } = useFormStatus(); return <button disabled={pending}>Submit</button>; }",
        "o": [
            "Button disabled during form submission",
            "Button always enabled",
            "Error if no form ancestor",
            "Button without disabled attribute"
        ]
    },
    {
        "q": "How should you handle multiple optimistic updates in a list using useOptimistic?",
        "o": [
            "Chain multiple addOptimistic calls, each updating the relevant part of the state",
            "Use a single call with array concatenation",
            "Optimistic updates do not support lists",
            "Rely on useReducer for lists only"
        ]
    },
    {
        "q": "What is the purpose of the update function in useOptimistic's second argument?",
        "o": [
            "To compute the optimistic state from the current state and pending update",
            "To revert the state on error",
            "To memoize the original state",
            "To dispatch the actual mutation"
        ]
    },
    {
        "q": "What is the output of the following useActionState with error handling?",
        "c": "const [state, action, isPending] = useActionState(async (prev, data) => { if (error) throw new Error('Failed'); return 'Success'; }, ''); console.log(state);",
        "o": [
            "'Success' on success, error thrown on failure",
            "Always ''",
            "undefined",
            "Error always"
        ]
    },
    {
        "q": "In React 19, how does useFormStatus detect form submission without context?",
        "o": [
            "It reads from the implicit form context provided by the <form> element",
            "It requires a useActionState provider",
            "It uses global state",
            "It polls the form state"
        ]
    },
    {
        "q": "What is a potential issue with nesting useOptimistic hooks in child components?",
        "o": [
            "Each instance manages its own optimistic state, potentially leading to inconsistent UI",
            "Nesting is not allowed",
            "It automatically syncs all instances",
            "It causes infinite re-renders"
        ]
    },
    {
        "q": "What is the output of the following combined useOptimistic and useActionState?",
        "c": "const [optimisticMessages, addOptimisticMessage] = useOptimistic(messages, (state, newMessage) => [...state, { ...newMessage, id: 'temp' }]); const [state, sendMessage] = useActionState(async (prev, formData) => { addOptimisticMessage({ text: formData.get('text') }); const result = await api.send(formData); return result; }, []);",
        "o": [
            "Immediate UI update with temp ID, then sync with real ID on success",
            "No immediate update",
            "Error on addOptimisticMessage",
            "Only updates after success"
        ]
    },
    {
        "q": "What is the primary benefit of using useOptimistic with server actions in a custom hook?",
        "o": [
            "It allows instant UI updates with temporary data while awaiting server confirmation",
            "It caches server responses for faster rendering",
            "It replaces useActionState for form submissions",
            "It prevents server requests entirely"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code in a nested component?",
        "c": "function FormWrapper() { return <form><SubmitButton /></form>; } function SubmitButton() { const { pending, data } = useFormStatus(); return pending ? 'Submitting...' : data?.get('name') || 'No name'; }",
        "o": [
            "'No name' initially, 'Submitting...' during submission",
            "Always 'Submitting...'",
            "null",
            "Error"
        ]
    },
    {
        "q": "How does useActionState improve error handling in a custom form hook?",
        "o": [
            "It captures errors thrown in the action and updates state with the error result",
            "It ignores all errors by default",
            "It requires manual try-catch in the component",
            "It cannot handle server errors"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with multiple updates?",
        "c": "const [optimisticState, addOptimistic] = useOptimistic({ count: 0 }, (state, update) => ({ count: state.count + update })); addOptimistic(1); addOptimistic(2); console.log(optimisticState.count);",
        "o": [
            "3",
            "1",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is a key consideration when using useSyncExternalStore with third-party libraries?",
        "o": [
            "Ensure the store's subscribe function supports cleanup to avoid memory leaks",
            "Use it only with React-based stores",
            "It requires useDeferredValue for stability",
            "It cannot handle external subscriptions"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with mutable state?",
        "c": "const store = { state: { value: 0 }, subscribe: (cb) => { const interval = setInterval(() => { store.state.value++; cb(); }, 1000); return () => clearInterval(interval); }, getSnapshot: () => store.state.value }; function useStoreValue() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useStoreValue());",
        "o": [
            "0 initially, increments every second",
            "0 always",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useInsertionEffect ensure compatibility with concurrent rendering?",
        "o": [
            "It runs before layout effects, ensuring styles are applied before React's concurrent updates",
            "It defers style insertion to after rendering",
            "It blocks concurrent rendering",
            "It is incompatible with concurrent mode"
        ]
    },
    {
        "q": "What is the output of the following useActionState with optimistic update?",
        "c": "const [state, action] = useActionState(async (prev, formData) => { return { id: formData.get('id') }; }, null); const [optimisticState, addOptimistic] = useOptimistic(state, (current, update) => update); action(new FormData().set('id', 'temp')); console.log(optimisticState?.id);",
        "o": [
            "temp",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useDeferredValue in a custom hook for real-time data?",
        "o": [
            "It may introduce noticeable lag in fast-updating UI scenarios",
            "It blocks real-time updates",
            "It requires manual synchronization",
            "It causes memory leaks"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus in a controlled form?",
        "c": "function ControlledForm() { const [value, setValue] = useState(''); return <form><input value={value} onChange={(e) => setValue(e.target.value)} /><Status /></form>; } function Status() { const { data } = useFormStatus(); return data?.get('input') || 'Empty'; }",
        "o": [
            "Empty",
            "Current input value",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can you combine useOptimistic with useTransition for smoother UI updates?",
        "o": [
            "Use useTransition to mark updates as low-priority and useOptimistic to show temporary UI states",
            "Use both to block UI updates",
            "Replace useOptimistic with useTransition",
            "Combine them with useEffect for cleanup"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect with cleanup?",
        "c": "function useStyleInsert(rule) { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = rule; document.head.appendChild(style); console.log('Inserted'); return () => { console.log('Cleaned'); document.head.removeChild(style); }; }, [rule]); } useStyleInsert('.test { color: blue; }');",
        "o": [
            "Inserted, Cleaned on unmount",
            "Inserted only",
            "Cleaned only",
            "Error"
        ]
    },
    {
        "q": "What is a best practice for handling server hydration with useSyncExternalStore?",
        "o": [
            "Provide a server snapshot to ensure consistent initial rendering",
            "Disable hydration for external stores",
            "Use useDeferredValue for hydration",
            "Ignore server snapshots entirely"
        ]
    },
    {
        "q": "What is the role of the getServerSnapshot function in useSyncExternalStore when used in a custom hook?",
        "o": [
            "To provide the initial state for server-side rendering to prevent hydration mismatches",
            "To cache client-side data for server use",
            "To defer server-side subscriptions",
            "To replace client-side snapshots"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with rollback?",
        "c": "const [state, addOptimistic] = useOptimistic({ value: 0 }, (current, update) => ({ value: current.value + update })); addOptimistic(5); console.log(state.value);",
        "o": [
            "5",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useActionState simplify progressive enhancement in forms?",
        "o": [
            "It allows forms to work without JavaScript while handling enhanced behavior with server actions",
            "It requires JavaScript for all form submissions",
            "It disables progressive enhancement",
            "It only works with client-side forms"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code with action data?",
        "c": "function Form() { return <form action={someAction}><Status /></form>; } function Status() { const { data, pending } = useFormStatus(); return data?.get('key') || 'None'; }",
        "o": [
            "None (initially), form data 'key' value on submit",
            "Always 'key'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key consideration when using useOptimistic in a list-based custom hook?",
        "o": [
            "Ensure unique temporary IDs for optimistic items to avoid key collisions",
            "Avoid using lists with optimistic updates",
            "Use useReducer instead for lists",
            "Optimistic updates do not need IDs"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect with multiple rules?",
        "c": "function useMultiStyleInsert(rules) { useInsertionEffect(() => { rules.forEach(rule => { const style = document.createElement('style'); style.textContent = rule; document.head.appendChild(style); }); }, [rules]); } useMultiStyleInsert(['.a { color: red; }', '.b { color: blue; }']);",
        "o": [
            "Two style elements inserted in document head",
            "No styles inserted",
            "Error due to multiple insertions",
            "Only one style inserted"
        ]
    },
    {
        "q": "How does useDeferredValue handle high-frequency input in a custom hook?",
        "o": [
            "It stabilizes the UI by rendering with the latest stable value while processing new inputs",
            "It blocks input until processing completes",
            "It caches all input values",
            "It requires useTransition for inputs"
        ]
    },
    {
        "q": "What is the output of the following useActionState with async failure?",
        "c": "const [state, action] = useActionState(async (prev, formData) => { throw new Error('Failed'); }, 'Initial'); console.log(state);",
        "o": [
            "Initial (error caught, state unchanged)",
            "Error",
            "undefined",
            "Failed"
        ]
    },
    {
        "q": "What is a potential issue with using useInsertionEffect for non-style updates?",
        "o": [
            "It may cause layout thrashing if used for non-CSS tasks due to its early execution",
            "It is designed for all DOM updates",
            "It delays style insertion",
            "It prevents cleanup functions"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with empty subscription?",
        "c": "const store = { getSnapshot: () => 'empty', subscribe: () => () => {}, getServerSnapshot: () => 'server' }; function useEmptyStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot, store.getServerSnapshot); } console.log(useEmptyStore());",
        "o": [
            "empty",
            "server",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useOptimistic improve perceived performance in a chat application hook?",
        "o": [
            "By showing messages instantly in the UI before server confirmation",
            "By caching all messages",
            "By deferring message rendering",
            "By blocking message input"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue with complex state?",
        "c": "function useComplexDeferred(data) { const deferred = useDeferredValue(data); return deferred.value; } console.log(useComplexDeferred({ value: 'test' }));",
        "o": [
            "test",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "What is a best practice for combining useFormStatus with useActionState in a custom hook?",
        "o": [
            "Use useFormStatus to read form state and useActionState to handle submission logic",
            "Replace useFormStatus with useActionState",
            "Use both for all form inputs",
            "Avoid combining them"
        ]
    },
    {
        "q": "What is the purpose of the previous state argument in useActionState's action function?",
        "o": [
            "To allow the action to access and potentially reuse or modify the previous state during updates",
            "To initialize the state on first call",
            "To cache the action result",
            "To handle form data only"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code during submission?",
        "c": "function Button() { const { pending, method } = useFormStatus(); return <button type='submit'>{pending ? 'Sending...' : 'Send'} via {method}</button>; }",
        "o": [
            "Sending... via POST (during submission)",
            "Send via GET",
            "Sending... via GET",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic handle concurrent optimistic updates?",
        "o": [
            "It applies updates sequentially based on the order of addOptimistic calls",
            "It merges all updates atomically",
            "It discards concurrent updates",
            "It requires manual queuing"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with state transformation?",
        "c": "const [state, action] = useActionState(async (prev, data) => { return { ...prev, submitted: true }; }, { submitted: false }); console.log(state.submitted);",
        "o": [
            "false initially, true after action",
            "true always",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a limitation of useFormStatus in a custom hook?",
        "o": [
            "It only works within a form descendant and reads from the implicit context",
            "It can be used anywhere without a form",
            "It requires explicit state passing",
            "It handles multiple forms automatically"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with error reversion?",
        "c": "const [state, addOptimistic] = useOptimistic({ items: [] }, (current, newItem) => ({ items: [...current.items, newItem] })); addOptimistic({ id: 'temp' }); // Assume server error reverts console.log(state.items.length);",
        "o": [
            "0 (after reversion)",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useActionState be used for pagination in a custom hook?",
        "o": [
            "By passing page data in formData and updating state with new page results",
            "It cannot handle pagination",
            "Use useState instead for pagination",
            "It requires useReducer"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue with object dependency?",
        "c": "const [searchObj, setSearchObj] = useState({ query: '' }); const deferredObj = useDeferredValue(searchObj); setSearchObj({ query: 'updated' }); console.log(deferredObj.query);",
        "o": [
            "'updated' (after deferral if busy)",
            "",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useInsertionEffect for emotion.js in a custom theme hook?",
        "o": [
            "It injects dynamic styles before layout to prevent flash of unstyled content",
            "It defers styles to after render",
            "It caches all styles globally",
            "It replaces useEffect for themes"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with server fallback?",
        "c": "const store = { getSnapshot: () => 'client', getServerSnapshot: () => 'server', subscribe: () => () => {} }; function useFallback() { return useSyncExternalStore(store.subscribe, store.getSnapshot, store.getServerSnapshot); } console.log(useFallback()); // On server",
        "o": [
            "server",
            "client",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic integrate with suspense boundaries?",
        "o": [
            "Optimistic updates can be suspended until resolved, showing fallbacks during confirmation",
            "It blocks suspense entirely",
            "It requires no boundaries",
            "Suspense ignores optimistic state"
        ]
    },
    {
        "q": "What is the output of the following useActionState with form method override?",
        "c": "const [state, action] = useActionState(async (prev, formData) => 'Processed', null); const form = <form action={action} method='GET'>Submit</form>; console.log(action);",
        "o": [
            "Function that handles GET submission",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for debouncing in a custom hook using useDeferredValue?",
        "o": [
            "Combine with a timeout to further delay updates after input stops",
            "useDeferredValue handles debouncing automatically",
            "Replace with useEffect for debouncing",
            "It cannot be debounced"
        ]
    },
    {
        "q": "What is the role of the action function in useActionState when handling form submissions?",
        "o": [
            "It processes form data asynchronously and updates state with the result",
            "It validates form inputs synchronously",
            "It memoizes form data for performance",
            "It triggers immediate UI updates"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with array manipulation?",
        "c": "const [state, addOptimistic] = useOptimistic([], (current, newItem) => [...current, newItem]); addOptimistic('item1'); console.log(state);",
        "o": [
            "['item1']",
            "[]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useFormStatus enhance accessibility in a custom form hook?",
        "o": [
            "By providing pending state to update ARIA attributes during form submission",
            "By automatically generating accessible IDs",
            "By replacing form validation",
            "It has no impact on accessibility"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with multiple submissions?",
        "c": "const [state, action] = useActionState(async (prev, data) => { return prev + 1; }, 0); action(new FormData()); action(new FormData()); console.log(state);",
        "o": [
            "0 (pending submissions not reflected immediately)",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useOptimistic without proper error handling?",
        "o": [
            "Failed server requests may leave the UI in an inconsistent state",
            "It always reverts automatically",
            "It prevents server errors",
            "It blocks optimistic updates"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with dynamic subscription?",
        "c": "const store = { state: 0, listeners: new Set(), getSnapshot: () => store.state, subscribe: (cb) => { store.listeners.add(cb); return () => store.listeners.delete(cb); } }; function useDynamicStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } store.state = 1; store.listeners.forEach(cb => cb()); console.log(useDynamicStore());",
        "o": [
            "1",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useDeferredValue complement useTransition in a search filter hook?",
        "o": [
            "useDeferredValue stabilizes input while useTransition prioritizes UI responsiveness",
            "They perform the same function",
            "useDeferredValue replaces useTransition",
            "They cannot be combined"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect with conditional styles?",
        "c": "function useConditionalStyle(active) { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = active ? '.box { display: block; }' : '.box { display: none; }'; document.head.appendChild(style); return () => document.head.removeChild(style); }, [active]); } useConditionalStyle(true);",
        "o": [
            "Style with display: block inserted",
            "Style with display: none inserted",
            "No style inserted",
            "Error"
        ]
    },
    {
        "q": "What is a best practice for handling optimistic updates with useActionState?",
        "o": [
            "Combine with useOptimistic to show temporary UI changes before action completion",
            "Use only useActionState for updates",
            "Avoid optimistic updates entirely",
            "Cache all optimistic states"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus with action attribute?",
        "c": "function FormComponent() { const [state, action] = useActionState(async () => 'Done', null); return <form action={action}><Status /></form>; } function Status() { const { action: formAction } = useFormStatus(); return formAction ? 'Has action' : 'No action'; }",
        "o": [
            "Has action",
            "No action",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useSyncExternalStore for integrating with browser APIs like localStorage?",
        "o": [
            "It ensures consistent reads and subscriptions to mutable browser APIs",
            "It caches localStorage data automatically",
            "It defers localStorage updates",
            "It replaces useEffect for storage"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic with conditional update?",
        "c": "const [state, addOptimistic] = useOptimistic({ active: false }, (current, update) => update.active ? { active: true } : current); addOptimistic({ active: true }); console.log(state.active);",
        "o": [
            "true",
            "false",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useInsertionEffect prevent visual glitches in a custom hook for animations?",
        "o": [
            "By applying animation styles before layout calculations, avoiding FOUC",
            "By deferring animations to after render",
            "By memoizing animation keyframes",
            "By syncing animations with state"
        ]
    },
    {
        "q": "How does useActionState handle server-side form submissions in a custom hook?",
        "o": [
            "It integrates with server actions, updating state with the response or error",
            "It blocks server submissions until client validation",
            "It only works with client-side forms",
            "It requires useOptimistic for server actions"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with nested state?",
        "c": "const [state, addOptimistic] = useOptimistic({ data: { count: 0 } }, (current, update) => ({ data: { count: current.data.count + update } })); addOptimistic(1); console.log(state.data.count);",
        "o": [
            "1",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key advantage of using useFormStatus for progressive enhancement?",
        "o": [
            "It allows forms to work without JavaScript while providing enhanced UI feedback",
            "It requires JavaScript for all interactions",
            "It disables form submissions without JavaScript",
            "It only works with useOptimistic"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore with async store?",
        "c": "const store = { async getSnapshot() { return await Promise.resolve('async'); }, subscribe: (cb) => { setTimeout(cb, 1000); return () => {}; } }; function useAsyncStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useAsyncStore());",
        "o": [
            "Error (getSnapshot must be synchronous)",
            "'async'",
            "undefined",
            "Promise object"
        ]
    },
    {
        "q": "What is a potential pitfall of using useDeferredValue for critical UI updates?",
        "o": [
            "It may delay updates, causing stale UI for time-sensitive data",
            "It blocks critical updates",
            "It caches updates indefinitely",
            "It requires useTransition"
        ]
    },
    {
        "q": "What is the output of the following useActionState with form data?",
        "c": "const [state, action] = useActionState(async (prev, formData) => formData.get('value'), ''); const formData = new FormData(); formData.set('value', 'test'); action(formData); console.log(state);",
        "o": [
            "'' (pending action not reflected immediately)",
            "'test'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useInsertionEffect be used in a custom hook for critical CSS injection?",
        "o": [
            "To inject critical styles before any DOM layout to ensure immediate styling",
            "To defer styles to after rendering",
            "To memoize CSS rules",
            "To handle non-style DOM updates"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus with custom attributes?",
        "c": "function Form() { return <form><Status /></form>; } function Status() { const { pending, action, method, data } = useFormStatus(); return data?.get('custom') || 'No custom'; }",
        "o": [
            "No custom (initially), custom field value on submit",
            "Always 'custom'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useOptimistic for real-time collaboration in a custom hook?",
        "o": [
            "It shows immediate changes locally while syncing with remote users",
            "It blocks collaboration until synced",
            "It caches all remote changes",
            "It requires server-only updates"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue with rapid state changes?",
        "c": "function useFastInput(input) { const deferred = useDeferredValue(input); return deferred; } const [value, setValue] = useState(0); setValue(1); setValue(2); console.log(useFastInput(value));",
        "o": [
            "2 (after potential deferral)",
            "0",
            "1",
            "Error"
        ]
    },
    {
        "q": "What is a best practice for handling cleanup in useSyncExternalStore subscriptions?",
        "o": [
            "Return a cleanup function from subscribe to remove listeners and prevent leaks",
            "Use useEffect for cleanup",
            "Subscriptions auto-cleanup",
            "Avoid cleanup entirely"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic with conditional rollback?",
        "c": "const [state, addOptimistic] = useOptimistic({ status: 'idle' }, (current, update) => update.valid ? { status: 'updated' } : current); addOptimistic({ valid: false }); console.log(state.status);",
        "o": [
            "idle",
            "updated",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useActionState support client-side validation in a custom hook?",
        "o": [
            "By allowing validation logic in the action function before server submission",
            "It requires separate validation hooks",
            "It disables client-side validation",
            "It only validates server responses"
        ]
    },
    {
        "q": "What is the behavior of useActionState when the action function returns undefined?",
        "o": [
            "The state remains unchanged, as undefined is a valid return value",
            "It throws an error",
            "The state resets to initial",
            "It triggers a re-render without state update"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with deep nesting?",
        "c": "const [state, addOptimistic] = useOptimistic({ user: { posts: [] } }, (current, post) => ({ user: { ...current.user, posts: [...current.user.posts, post] } })); addOptimistic({ title: 'New Post' }); console.log(state.user.posts[0].title);",
        "o": [
            "New Post",
            "undefined",
            "null",
            "Error"
        ]
    },
    {
        "q": "How does useFormStatus handle multiple forms in the component tree?",
        "o": [
            "It reads from the nearest ancestor form context",
            "It aggregates data from all forms",
            "It throws an error if multiple forms exist",
            "It uses global form state"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with external dependency?",
        "c": "function useExternalStyle(url) { useInsertionEffect(() => { const link = document.createElement('link'); link.rel = 'stylesheet'; link.href = url; document.head.appendChild(link); return () => document.head.removeChild(link); }, [url]); } useExternalStyle('https://example.com/style.css');",
        "o": [
            "External stylesheet linked before layout",
            "No link created",
            "Error due to external URL",
            "Link appended after paint"
        ]
    },
    {
        "q": "What is a key consideration for using useSyncExternalStore in concurrent mode?",
        "o": [
            "Ensure the snapshot function is fast and consistent to avoid tearing during concurrent renders",
            "It blocks concurrent mode",
            "It requires useDeferredValue",
            "Snapshots are deferred automatically"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with non-primitive value?",
        "c": "const [complex, setComplex] = useState({ data: { items: [1,2] } }); const deferred = useDeferredValue(complex); setComplex({ data: { items: [3,4] } }); console.log(deferred.data.items);",
        "o": [
            "[1,2] (potentially, if deferred)",
            "[3,4]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useActionState be integrated with useOptimistic for form mutations?",
        "o": [
            "Call addOptimistic inside the action function to update UI before server response",
            "UseOptimistic cannot be used with actions",
            "ActionState handles optimism automatically",
            "Require useTransition for integration"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code with no form ancestor?",
        "c": "function StandaloneStatus() { const { pending } = useFormStatus(); return pending ? 'Pending' : 'Idle'; } console.log(StandaloneStatus());",
        "o": [
            "Idle (no form context)",
            "Pending",
            "Error",
            "undefined"
        ]
    },
    {
        "q": "What is the benefit of using useInsertionEffect over useLayoutEffect for style injection?",
        "o": [
            "useInsertionEffect runs even earlier, before layout effects, ideal for pure style insertion without DOM reads",
            "It runs after useLayoutEffect",
            "It handles DOM mutations better",
            "It is synchronous like useLayoutEffect"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic with useReducer integration?",
        "c": "const reducer = (state, action) => state; const [state, dispatch] = useReducer(reducer, []); const [optimisticState, addOptimistic] = useOptimistic(state, (current, update) => [...current, update]); addOptimistic('optimistic item'); console.log(optimisticState[0]);",
        "o": [
            "'optimistic item'",
            "undefined",
            "[]",
            "Error"
        ]
    },
    {
        "q": "How does useSyncExternalStore's subscribe callback interact with React's re-renders?",
        "o": [
            "Calling the callback from subscribe triggers a re-render with the new snapshot",
            "It queues updates without re-renders",
            "It requires manual setState",
            "Subscriptions do not trigger re-renders"
        ]
    },
    {
        "q": "What is the output of the following useActionState with synchronous return?",
        "c": "const [state, action] = useActionState((prev, data) => ({ ...prev, processed: true }), { processed: false }); action(new FormData()); console.log(state.processed);",
        "o": [
            "false (action is async by default)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for handling stale closures in useDeferredValue dependencies?",
        "o": [
            "Use useCallback or useMemo to stabilize function or object dependencies",
            "DeferredValue ignores closures",
            "Use useRef for all dependencies",
            "It automatically handles staleness"
        ]
    },
    {
        "q": "What is the behavior of useActionState when the action function throws an error synchronously?",
        "o": [
            "The error is caught, and the state remains unchanged, allowing error boundaries to handle it",
            "The error resets the state to initial",
            "The component crashes without recovery",
            "The error updates the state with undefined"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with conditional state update?",
        "c": "const [state, addOptimistic] = useOptimistic({ count: 0 }, (current, { increment }) => increment ? { count: current.count + 1 } : current); addOptimistic({ increment: false }); console.log(state.count);",
        "o": [
            "0",
            "1",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useFormStatus improve form UX in a custom hook without explicit state management?",
        "o": [
            "By providing real-time feedback like pending state or form data without requiring useState",
            "By caching form data globally",
            "By requiring manual state updates",
            "By replacing form validation"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with delayed subscription?",
        "c": "const store = { state: 'initial', getSnapshot: () => store.state, subscribe: (cb) => { setTimeout(() => { store.state = 'updated'; cb(); }, 1000); return () => {}; } }; function useDelayedStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useDelayedStore());",
        "o": [
            "'initial' (before subscription update)",
            "'updated'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a key consideration when using useInsertionEffect for third-party style libraries?",
        "o": [
            "Ensure cleanup removes injected styles to prevent conflicts with other libraries",
            "It cannot be used with third-party libraries",
            "It requires useEffect for cleanup",
            "Styles persist across renders automatically"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with frequent object updates?",
        "c": "const [obj, setObj] = useState({ id: 1 }); const deferredObj = useDeferredValue(obj); setObj({ id: 2 }); setObj({ id: 3 }); console.log(deferredObj.id);",
        "o": [
            "1 (potentially, if rendering is busy)",
            "3",
            "2",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic handle race conditions in a custom hook for API updates?",
        "o": [
            "It applies updates in order, reverting to the latest server state if conflicts occur",
            "It ignores race conditions",
            "It requires manual conflict resolution",
            "It blocks concurrent updates"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with form reset?",
        "c": "const [state, action] = useActionState(async (prev, formData) => formData.get('reset') ? null : prev, { value: 'data' }); const formData = new FormData(); formData.set('reset', 'true'); action(formData); console.log(state?.value);",
        "o": [
            "'data' (pending reset not reflected immediately)",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for dynamic button states in a form?",
        "o": [
            "It provides pending and data states to toggle button disabled or loading states",
            "It caches button states across renders",
            "It requires explicit state passing",
            "It only works with uncontrolled forms"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with empty dependency?",
        "c": "function useEmptyStyle() { useInsertionEffect(() => { console.log('Style applied'); }, []); return 'Done'; } console.log(useEmptyStyle());",
        "o": [
            "Style applied, Done",
            "Done",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useSyncExternalStore be used to integrate with a WebSocket in a custom hook?",
        "o": [
            "By subscribing to WebSocket messages and providing a snapshot of the latest data",
            "By caching WebSocket messages",
            "By deferring WebSocket connections",
            "By replacing WebSocket with HTTP"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with multiple fields?",
        "c": "const [state, addOptimistic] = useOptimistic({ name: '', age: 0 }, (current, update) => ({ ...current, ...update })); addOptimistic({ name: 'Alice', age: 25 }); console.log(state.name, state.age);",
        "o": [
            "Alice, 25",
            "'', 0",
            "undefined, undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for testing useActionState with mocked server responses?",
        "o": [
            "Mock the action function to return controlled responses and test state updates",
            "Test only client-side state",
            "Use real server calls in tests",
            "ActionState cannot be mocked"
        ]
    },
    {
        "q": "What is the impact of using useActionState in a server component?",
        "o": [
            "It enables direct server actions without client-side JavaScript for form handling",
            "It requires client-side hydration always",
            "It disables server actions",
            "It only works in client components"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with immutable updates?",
        "c": "const [state, addOptimistic] = useOptimistic({ list: [1, 2] }, (current, item) => ({ list: [...current.list, item] })); addOptimistic(3); console.log(state.list);",
        "o": [
            "[1, 2, 3]",
            "[1, 2]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useFormStatus provide access to form method in a custom hook?",
        "o": [
            "Through the method property, which reflects the form's method attribute",
            "It hardcodes to POST",
            "It requires manual detection",
            "Method is not accessible"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with array state?",
        "c": "const [items, setItems] = useState([1]); const deferredItems = useDeferredValue(items); setItems([1, 2]); console.log(deferredItems);",
        "o": [
            "[1] (potentially deferred)",
            "[1, 2]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a limitation of useSyncExternalStore for complex store graphs?",
        "o": [
            "It requires manual handling of nested subscriptions to avoid partial updates",
            "It automatically subscribes to all graph nodes",
            "It cannot handle graphs",
            "It uses deep equality by default"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with dynamic class?",
        "c": "function useClassStyle(className) { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = `.${className} { font-weight: bold; }`; document.head.appendChild(style); return () => document.head.removeChild(style); }, [className]); } useClassStyle('dynamic');",
        "o": [
            "Style for .dynamic inserted",
            "No style inserted",
            "Error on className",
            "Style without class"
        ]
    },
    {
        "q": "How does useActionState manage concurrent form submissions?",
        "o": [
            "It queues actions, but concurrent calls may overwrite state based on completion order",
            "It blocks concurrent submissions",
            "It merges concurrent form data",
            "It ignores concurrent calls"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with function update?",
        "c": "const [state, addOptimistic] = useOptimistic(0, (current, fn) => fn(current)); addOptimistic(c => c * 2); console.log(state);",
        "o": [
            "0 (update function not applied immediately)",
            "0 * 2",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for loading indicators without prop drilling?",
        "o": [
            "It reads implicit form context, allowing any descendant to access status without props",
            "It requires prop drilling",
            "It only works at form root",
            "It caches status globally"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with getServerSnapshot?",
        "c": "const store = { getSnapshot: () => 'client', getServerSnapshot: () => 'server', subscribe: () => () => {} }; function useSSRStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot, store.getServerSnapshot); } // Simulated SSR console.log(useSSRStore());",
        "o": [
            "server",
            "client",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useDeferredValue be misused leading to infinite re-renders?",
        "o": [
            "By depending on a value that changes in the same render cycle without stabilization",
            "It prevents infinite re-renders",
            "By omitting dependencies",
            "It requires dependencies always"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with previous state usage?",
        "c": "const [state, action] = useActionState(async (prev, data) => ({ ...prev, count: (prev.count || 0) + 1 }), {}); action(new FormData()); console.log(state.count);",
        "o": [
            "1",
            "undefined",
            "0",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for combining useInsertionEffect with useMemo for computed styles?",
        "o": [
            "Memoize style strings and depend on them in useInsertionEffect to avoid unnecessary injections",
            "useInsertionEffect memos automatically",
            "Avoid memoization with effects",
            "Use useEffect instead"
        ]
    },
    {
        "q": "What is the purpose of the initialState in useOptimistic?",
        "o": [
            "To provide the base state before any optimistic updates are applied",
            "To define the update function",
            "To handle error reversion",
            "To memoize the state"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with async state update?",
        "c": "const [state, action] = useActionState(async (prev, data) => { await new Promise(r => setTimeout(r, 100)); return { ...prev, updated: true }; }, { updated: false }); action(new FormData()); console.log(state.updated);",
        "o": [
            "false (update pending, not reflected immediately)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useFormStatus's data property access form inputs?",
        "o": [
            "It provides a FormData-like object with get() method for field values",
            "It returns raw HTML form data",
            "It requires manual input tracking",
            "Data is not accessible"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with tearing prevention?",
        "c": "const store = { state: { count: 0 }, getSnapshot: () => store.state.count, subscribe: (cb) => { const id = setInterval(() => { store.state.count++; cb(); }, 1000); return () => clearInterval(id); } }; function useTearSafe() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useTearSafe());",
        "o": [
            "0 (atomic read prevents tearing)",
            "Partial state object",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useInsertionEffect for JavaScript injections?",
        "o": [
            "It may execute scripts too early, before DOM is ready, leading to errors",
            "It defers JS execution",
            "It memos JS code",
            "It is designed for JS only"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with function dependency?",
        "c": "const [num, setNum] = useState(1); const expensiveFn = useCallback(() => num * 100, [num]); const deferredFn = useDeferredValue(expensiveFn); setNum(2); console.log(deferredFn());",
        "o": [
            "100 (stale closure if not memoized properly)",
            "200",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic interact with React's automatic batching?",
        "o": [
            "Optimistic updates are batched with other state updates for efficient rendering",
            "It disables batching",
            "It requires manual batching",
            "Batching is not supported"
        ]
    },
    {
        "q": "What is the output of the following useFormStatus code with method detection?",
        "c": "function Form() { return <form method='PUT'><Status /></form>; } function Status() { const { method } = useFormStatus(); return method; } console.log(Status());",
        "o": [
            "'PUT'",
            "'POST'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useSyncExternalStore for Redux-like stores in hooks?",
        "o": [
            "It provides a low-level API to subscribe to store changes without full Redux setup",
            "It replaces Redux entirely",
            "It caches store slices",
            "It handles actions automatically"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with error propagation?",
        "c": "const [state, action] = useActionState(async (prev, data) => { if (Math.random() > 0.5) throw new Error('Random fail'); return 'Success'; }, ''); console.log(state);",
        "o": [
            "'Success' or error caught (state unchanged on error)",
            "Always 'Random fail'",
            "undefined",
            "Error always"
        ]
    },
    {
        "q": "How can useInsertionEffect be combined with useContext for theme styles?",
        "o": [
            "Subscribe to theme context and inject theme-specific styles before layout",
            "useInsertionEffect cannot use context",
            "Context updates after insertion",
            "It requires useEffect for themes"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with reverted update?",
        "c": "const [state, addOptimistic] = useOptimistic({ items: [] }, (current, item) => ({ items: [...current.items, item] })); addOptimistic({ id: 'temp' }); // Server success replaces with { id: 'real' } console.log(state.items[0].id);",
        "o": [
            "'real'",
            "'temp'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for optimizing useDeferredValue with large computed values?",
        "o": [
            "Memoize the computed value with useMemo and defer the memoized result",
            "Defer raw computations always",
            "Use useRef for large values",
            "It optimizes automatically"
        ]
    },
    {
        "q": "What happens when useActionState's action function is called multiple times concurrently?",
        "o": [
            "React queues the actions, but state updates depend on the order of completion",
            "All calls are merged into one update",
            "Concurrent calls are blocked",
            "It causes a runtime error"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with array filtering?",
        "c": "const [state, addOptimistic] = useOptimistic([1, 2, 3], (current, id) => current.filter(item => item !== id)); addOptimistic(2); console.log(state);",
        "o": [
            "[1, 3]",
            "[1, 2, 3]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useFormStatus be used to enhance form validation feedback in a custom hook?",
        "o": [
            "By accessing form data to display real-time validation messages without prop drilling",
            "By replacing client-side validation",
            "By requiring external state management",
            "It cannot access form data"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with conditional updates?",
        "c": "const store = { state: 'off', getSnapshot: () => store.state, subscribe: (cb) => { if (store.state === 'on') cb(); return () => {}; } }; function useConditionalStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } store.state = 'on'; console.log(useConditionalStore());",
        "o": [
            "'on'",
            "'off'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useInsertionEffect for large style sheets?",
        "o": [
            "Frequent updates to large styles may cause performance bottlenecks due to early execution",
            "It caches styles automatically",
            "It defers large styles to useEffect",
            "It only supports small styles"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with string concatenation?",
        "c": "const [text, setText] = useState('hello'); const deferredText = useDeferredValue(text); setText('world'); console.log(deferredText);",
        "o": [
            "'hello' (potentially, if rendering is busy)",
            "'world'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic ensure consistency with server responses in a custom hook?",
        "o": [
            "It reverts to server state if the optimistic update conflicts with the response",
            "It ignores server responses",
            "It merges server and optimistic states",
            "It blocks server updates"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with form data validation?",
        "c": "const [state, action] = useActionState(async (prev, formData) => { const value = formData.get('input'); return value ? { valid: true } : { valid: false }; }, { valid: false }); const formData = new FormData(); formData.set('input', 'test'); action(formData); console.log(state.valid);",
        "o": [
            "false (pending update not reflected immediately)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for dynamic form disabling?",
        "o": [
            "It allows disabling inputs during submission using the pending state",
            "It requires manual state tracking",
            "It only works with button elements",
            "It caches form state"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with media queries?",
        "c": "function useMediaStyle(query) { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = `@media ${query} { .item { display: flex; } }`; document.head.appendChild(style); return () => document.head.removeChild(style); }, [query]); } useMediaStyle('(min-width: 600px)');",
        "o": [
            "Media query style inserted",
            "No style inserted",
            "Error on media query",
            "Style without media query"
        ]
    },
    {
        "q": "How can useSyncExternalStore be used for browser event listeners in a custom hook?",
        "o": [
            "By subscribing to browser events like resize and providing a snapshot of the event data",
            "By caching event data globally",
            "By deferring event handling",
            "By replacing addEventListener"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with object merging?",
        "c": "const [state, addOptimistic] = useOptimistic({ a: 1, b: 2 }, (current, update) => ({ ...current, ...update })); addOptimistic({ b: 3, c: 4 }); console.log(state.b, state.c);",
        "o": [
            "3, 4",
            "2, undefined",
            "undefined, undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for handling timeouts in a custom hook using useActionState?",
        "o": [
            "Implement timeout logic in the action function with Promise.race",
            "Use useEffect for timeouts",
            "Timeouts are handled automatically",
            "Avoid timeouts in actions"
        ]
    },
    {
        "q": "What is the behavior of useActionState when the form action is invoked with no FormData?",
        "o": [
            "The action function receives an empty FormData object and processes as usual",
            "It throws an error",
            "It skips the action execution",
            "It resets the state to null"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with conditional array updates?",
        "c": "const [state, addOptimistic] = useOptimistic([], (current, item) => item.valid ? [...current, item.value] : current); addOptimistic({ valid: true, value: 'new' }); console.log(state);",
        "o": [
            "['new']",
            "[]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useFormStatus handle dynamic form method changes in a custom hook?",
        "o": [
            "It reflects the current form method, updating dynamically with form changes",
            "It locks to the initial method",
            "It requires manual method updates",
            "Method cannot change dynamically"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with external mutation?",
        "c": "const store = { state: { value: 'init' }, getSnapshot: () => store.state.value, subscribe: (cb) => { const observer = new MutationObserver(cb); observer.observe(document.body, { childList: true }); return () => observer.disconnect(); } }; function useMutationStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } store.state.value = 'mutated'; console.log(useMutationStore());",
        "o": [
            "'mutated' (if observer triggers)",
            "'init'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useDeferredValue for time-critical UI updates?",
        "o": [
            "It may delay updates, causing a lag in critical UI feedback",
            "It blocks critical updates",
            "It requires manual synchronization",
            "It caches updates indefinitely"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with nested styles?",
        "c": "function useNestedStyle() { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = '.outer { .inner { color: red; } }'; document.head.appendChild(style); return () => document.head.removeChild(style); }, []); } useNestedStyle();",
        "o": [
            "Invalid CSS, no style applied",
            "Nested style applied",
            "Error on style insertion",
            "Style without nesting"
        ]
    },
    {
        "q": "How does useOptimistic handle state conflicts with multiple users in a custom hook?",
        "o": [
            "It relies on server reconciliation to resolve conflicts, reverting if needed",
            "It merges all user updates",
            "It prevents multi-user updates",
            "It ignores conflicts"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with conditional state?",
        "c": "const [state, action] = useActionState(async (prev, data) => data.get('flag') ? { active: true } : prev, { active: false }); const formData = new FormData(); formData.set('flag', 'true'); action(formData); console.log(state.active);",
        "o": [
            "false (pending action not reflected immediately)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for real-time form feedback?",
        "o": [
            "It provides immediate access to form state like pending or data for dynamic UI",
            "It caches form state globally",
            "It requires explicit state passing",
            "It only works post-submission"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with empty update?",
        "c": "const [state, addOptimistic] = useOptimistic({ value: 'default' }, (current, update) => update || current); addOptimistic(null); console.log(state.value);",
        "o": [
            "default",
            "null",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How can useSyncExternalStore integrate with a BroadcastChannel in a custom hook?",
        "o": [
            "By subscribing to channel messages and providing a snapshot of the latest message",
            "By caching channel data",
            "By deferring channel messages",
            "By replacing BroadcastChannel"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with nested object?",
        "c": "const [data, setData] = useState({ user: { name: 'Alice' } }); const deferredData = useDeferredValue(data); setData({ user: { name: 'Bob' } }); console.log(deferredData.user.name);",
        "o": [
            "'Alice' (potentially deferred)",
            "'Bob'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for handling large form submissions with useActionState?",
        "o": [
            "Break down form data processing into chunks within the action function",
            "Use useEffect for large submissions",
            "ActionState cannot handle large data",
            "Cache all form data first"
        ]
    },
    {
        "q": "How does useActionState handle empty form submissions in a custom hook?",
        "o": [
            "It passes an empty FormData object to the action function for processing",
            "It throws an error for empty submissions",
            "It skips the action call",
            "It resets the form state"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with dynamic array updates?",
        "c": "const [state, addOptimistic] = useOptimistic([], (current, { action, value }) => action === 'add' ? [...current, value] : current); addOptimistic({ action: 'add', value: 'item' }); console.log(state);",
        "o": [
            "['item']",
            "[]",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for form error feedback?",
        "o": [
            "It allows real-time error display by accessing form data during submission",
            "It caches errors globally",
            "It requires manual error propagation",
            "It only shows errors post-submission"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with event-driven updates?",
        "c": "const store = { state: 'idle', getSnapshot: () => store.state, subscribe: (cb) => { window.addEventListener('customEvent', () => { store.state = 'active'; cb(); }); return () => window.removeEventListener('customEvent', cb); } }; function useEventStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } console.log(useEventStore());",
        "o": [
            "'idle' (until event triggers)",
            "'active'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useInsertionEffect for frequent style updates?",
        "o": [
            "It may cause performance issues due to repeated DOM manipulations before layout",
            "It caches styles to prevent updates",
            "It defers updates to useEffect",
            "It limits style updates to once"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with boolean state?",
        "c": "const [flag, setFlag] = useState(false); const deferredFlag = useDeferredValue(flag); setFlag(true); console.log(deferredFlag);",
        "o": [
            "false (potentially deferred)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic support undo functionality in a custom hook?",
        "o": [
            "By applying a reverse update via addOptimistic before server confirmation",
            "It cannot support undo",
            "It requires useReducer for undo",
            "It caches undo states automatically"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with complex state?",
        "c": "const [state, action] = useActionState(async (prev, data) => ({ ...prev, field: data.get('field') }), { field: '' }); const formData = new FormData(); formData.set('field', 'value'); action(formData); console.log(state.field);",
        "o": [
            "'' (pending action not reflected immediately)",
            "'value'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for client-side form progress?",
        "o": [
            "It provides pending state for progress indicators without extra state management",
            "It requires manual progress tracking",
            "It only works with server progress",
            "It caches progress globally"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with keyframe animations?",
        "c": "function useAnimationStyle() { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = '@keyframes fade { from { opacity: 0; } to { opacity: 1; } }'; document.head.appendChild(style); return () => document.head.removeChild(style); }, []); } useAnimationStyle();",
        "o": [
            "Fade keyframe inserted",
            "No keyframe inserted",
            "Error on keyframe",
            "Style without animation"
        ]
    },
    {
        "q": "How can useSyncExternalStore integrate with a service worker in a custom hook?",
        "o": [
            "By subscribing to service worker messages and providing a snapshot of the latest state",
            "By caching service worker responses",
            "By deferring service worker events",
            "By replacing service worker APIs"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with toggle state?",
        "c": "const [state, addOptimistic] = useOptimistic({ enabled: false }, (current, toggle) => ({ enabled: toggle ? !current.enabled : current.enabled })); addOptimistic(true); console.log(state.enabled);",
        "o": [
            "true",
            "false",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for handling network errors in useActionState?",
        "o": [
            "Catch errors in the action function and return an error state for UI feedback",
            "Rely on global error boundaries",
            "Ignore network errors",
            "Use useEffect for error handling"
        ]
    },
    {
        "q": "What happens if useActionState's action function is synchronous instead of asynchronous?",
        "o": [
            "It behaves the same, updating state with the returned value, but without async delays",
            "It throws an error",
            "It skips state updates",
            "It forces an async wrapper"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with object deletion?",
        "c": "const [state, addOptimistic] = useOptimistic({ a: 1, b: 2 }, (current, key) => { const newState = { ...current }; delete newState[key]; return newState; }); addOptimistic('b'); console.log(state.b);",
        "o": [
            "undefined",
            "2",
            "null",
            "Error"
        ]
    },
    {
        "q": "How can useFormStatus improve UX for file uploads in a custom hook?",
        "o": [
            "By providing pending state to show upload progress without additional state tracking",
            "By caching file data",
            "By requiring manual progress updates",
            "By blocking uploads until complete"
        ]
    },
    {
        "q": "What is the output of the following useSyncExternalStore code with storage events?",
        "c": "const store = { getSnapshot: () => localStorage.getItem('key') || 'none', subscribe: (cb) => { window.addEventListener('storage', cb); return () => window.removeEventListener('storage', cb); } }; function useStorageStore() { return useSyncExternalStore(store.subscribe, store.getSnapshot); } localStorage.setItem('key', 'value'); console.log(useStorageStore());",
        "o": [
            "'value' (if storage event triggers)",
            "'none'",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a potential issue with using useInsertionEffect for non-critical styles?",
        "o": [
            "It may unnecessarily prioritize style injection, impacting layout performance",
            "It delays non-critical styles",
            "It caches styles globally",
            "It only supports critical styles"
        ]
    },
    {
        "q": "What is the output of the following useDeferredValue code with rapid primitive updates?",
        "c": "const [num, setNum] = useState(0); const deferredNum = useDeferredValue(num); setNum(1); setNum(2); console.log(deferredNum);",
        "o": [
            "0 (potentially deferred)",
            "2",
            "1",
            "Error"
        ]
    },
    {
        "q": "How does useOptimistic handle optimistic updates in a multi-step form?",
        "o": [
            "By applying incremental updates for each step, reverting if any step fails",
            "It cannot handle multi-step forms",
            "It merges all steps into one update",
            "It requires useReducer for steps"
        ]
    },
    {
        "q": "What is the output of the following useActionState code with validation?",
        "c": "const [state, action] = useActionState(async (prev, data) => { const input = data.get('input'); return input.length > 3 ? { valid: true } : { valid: false }; }, { valid: false }); const formData = new FormData(); formData.set('input', 'test'); action(formData); console.log(state.valid);",
        "o": [
            "false (pending action not reflected immediately)",
            "true",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is the benefit of using useFormStatus for dynamic form field enabling?",
        "o": [
            "It allows enabling/disabling fields based on pending state without extra logic",
            "It requires manual field tracking",
            "It only works with static forms",
            "It caches field states"
        ]
    },
    {
        "q": "What is the output of the following useInsertionEffect code with font loading?",
        "c": "function useFontStyle() { useInsertionEffect(() => { const style = document.createElement('style'); style.textContent = '@font-face { font-family: Custom; src: url(/font.woff2); }'; document.head.appendChild(style); return () => document.head.removeChild(style); }, []); } useFontStyle();",
        "o": [
            "Font-face style inserted",
            "No font loaded",
            "Error on font-face",
            "Style without font"
        ]
    },
    {
        "q": "How can useSyncExternalStore be used with a WebRTC data channel in a custom hook?",
        "o": [
            "By subscribing to data channel messages and providing a snapshot of the latest data",
            "By caching WebRTC messages",
            "By deferring channel events",
            "By replacing WebRTC with WebSocket"
        ]
    },
    {
        "q": "What is the output of the following useOptimistic code with conditional merge?",
        "c": "const [state, addOptimistic] = useOptimistic({ value: 0 }, (current, update) => update.reset ? { value: 0 } : { value: current.value + update.inc }); addOptimistic({ inc: 1 }); console.log(state.value);",
        "o": [
            "1",
            "0",
            "undefined",
            "Error"
        ]
    },
    {
        "q": "What is a strategy for handling timeouts in useOptimistic updates?",
        "o": [
            "Use a timeout to revert optimistic updates if the server doesn’t confirm in time",
            "Timeouts are handled automatically",
            "Use useEffect for timeouts",
            "Avoid timeouts in optimistic updates"
        ]
    }
]