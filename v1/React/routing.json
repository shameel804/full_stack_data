[
    {
        "q": "What is the primary purpose of the useEffect hook in React?",
        "type": "mcq",
        "o": [
            "To perform side effects in functional components",
            "To manage local state in functional components",
            "To create a context for sharing data",
            "To optimize performance by memoizing values"
        ]
    },
    {
        "q": "Which hook is used to access the context value in a functional component?",
        "type": "mcq",
        "o": [
            "useContext",
            "useReducer",
            "useState",
            "useEffect"
        ]
    },
    {
        "q": "What is a custom hook in React?",
        "type": "mcq",
        "o": [
            "A JavaScript function that starts with 'use' and can call other hooks",
            "A built-in component for routing",
            "A global state management library",
            "A method to fetch data from an API"
        ]
    },
    {
        "q": "The useReducer hook is an alternative to which other hook?",
        "type": "mcq",
        "o": [
            "useState",
            "useEffect",
            "useContext",
            "useCallback"
        ]
    },
    {
        "q": "When does useEffect run by default?",
        "type": "mcq",
        "o": [
            "After every render",
            "Only on the first render",
            "Before every render",
            "Only when the component unmounts"
        ]
    },
    {
        "q": "What syntax is used to import useEffect from React?",
        "type": "mcq",
        "o": [
            "import { useEffect } from 'react';",
            "import isEffect from 'react';",
            "import React.useEffect from 'react';",
            "const useEffect = require('react');"
        ]
    },
    {
        "q": "What argument does useContext accept?",
        "type": "mcq",
        "o": [
            "The context object created by React.createContext",
            "A string representing the context name",
            "A function that returns the context value",
            "The initial state of the context"
        ]
    },
    {
        "q": "Which of the following is a rule for custom hooks?",
        "type": "mcq",
        "o": [
            "The name must start with 'use'",
            "They must be defined inside a class component",
            "They cannot call other hooks",
            "They must always return JSX"
        ]
    },
    {
        "q": "What are the two values returned by useReducer?",
        "type": "mcq",
        "o": [
            "The current state and a dispatch function",
            "The current state and a setter function",
            "The initial state and a reducer function",
            "The previous state and the next state"
        ]
    },
    {
        "q": "How can you make useEffect run only once (on mount)?",
        "type": "mcq",
        "o": [
            "Pass an empty array [] as the second argument",
            "Pass null as the second argument",
            "Do not pass a second argument",
            "Return specific value from the effect"
        ]
    },
    {
        "q": "In useEffect, what is the return function used for?",
        "type": "mcq",
        "o": [
            "Cleanup tasks like clearing timers or subscriptions",
            "Updating the state",
            "Triggering a re-render",
            "Fetching data asynchronously"
        ]
    },
    {
        "q": "What is the typical use case for useContext?",
        "type": "mcq",
        "o": [
            "Avoiding prop drilling for global data",
            "Optimizing complex calculations",
            "Managing complex state logic",
            "Handling side effects"
        ]
    },
    {
        "q": "Can custom hooks return values?",
        "type": "mcq",
        "o": [
            "Yes, they can return any value (array, object, primitive)",
            "No, they only execute logic",
            "Yes, but only JSX",
            "No, they must return a cleanup function"
        ]
    },
    {
        "q": "What is the first argument passed to the reducer function in useReducer?",
        "type": "mcq",
        "o": [
            "The current state",
            "The dispatch method",
            "The action object",
            "The initial state"
        ]
    },
    {
        "q": "What happens if you omit the dependency array in useEffect?",
        "type": "mcq",
        "o": [
            "The effect runs after every render",
            "The effect runs only once",
            "The effect never runs",
            "It causes a compilation error"
        ]
    },
    {
        "q": "Which hook is preferred for complex state logic?",
        "type": "mcq",
        "o": [
            "useReducer",
            "useState",
            "useEffect",
            "useRef"
        ]
    },
    {
        "q": "Can multiple useEffect hooks be used in a single component?",
        "type": "mcq",
        "o": [
            "Yes, as many as needed",
            "No, only one is allowed",
            "Yes, but only if they have different dependencies",
            "No, it will cause infinite loops"
        ]
    },
    {
        "q": "What does the second argument of useEffect represent?",
        "type": "mcq",
        "o": [
            "The dependency array",
            "The cleanup function",
            "The initial state",
            "The context value"
        ]
    },
    {
        "q": "To share logic between two JavaScript functions, we usually...",
        "type": "mcq",
        "o": [
            "extract it to a third function",
            "copy and paste the code",
            "use a class",
            "use a higher-order component"
        ]
    },
    {
        "q": "Custom hooks allow you to allow sharing _____ logic.",
        "type": "mcq",
        "o": [
            "stateful",
            "rendering",
            "styling",
            "class-based"
        ]
    },
    {
        "q": "What triggers a re-run of useEffect if dependencies are provided?",
        "type": "mcq",
        "o": [
            "Change in any value in the dependency array",
            "Change in component props only",
            "User interaction events",
            "Timer expiration"
        ]
    },
    {
        "q": "Which hook would you use to subscribe to a chat service?",
        "type": "mcq",
        "o": [
            "useEffect",
            "useLayoutEffect",
            "useMemo",
            "useState"
        ]
    },
    {
        "q": "In useReducer, the second argument is...",
        "type": "mcq",
        "o": [
            "the initial state",
            "the reducer function",
            "the action creator",
            "the lazy initialization function"
        ]
    },
    {
        "q": "Does useContext subscribe to context changes?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only if specified",
            "Only in class components"
        ]
    },
    {
        "q": "Custom hooks usually start with which word?",
        "type": "mcq",
        "o": [
            "use",
            "get",
            "set",
            "create"
        ]
    },
    {
        "q": "Can you use hooks inside a conditional statement?",
        "type": "mcq",
        "o": [
            "No",
            "Yes",
            "Only in development mode",
            "Only if condition is constant"
        ]
    },
    {
        "q": "What is 'dispatch' in the context of useReducer?",
        "type": "mcq",
        "o": [
            "A function to send actions to the reducer",
            "The current state value",
            "The initial configuration object",
            "A method to fetch data"
        ]
    },
    {
        "q": "Which hook separates side effects from rendering?",
        "type": "mcq",
        "o": [
            "useEffect",
            "useState",
            "useContext",
            "useCallback"
        ]
    },
    {
        "q": "Can custom hooks use other built-in hooks?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only useState",
            "Only useEffect"
        ]
    },
    {
        "q": "Is 'useFormInput' a valid name for a custom hook?",
        "type": "mcq",
        "o": [
            "Yes",
            "No, it must contain 'hook'",
            "No, it must be longer",
            "No, it is reserved"
        ]
    },
    {
        "q": "What is the second argument of the reducer function (state, action) => newState?",
        "type": "mcq",
        "o": [
            "action",
            "dispatch",
            "props",
            "context"
        ]
    },
    {
        "q": "How do you specify no dependencies for useEffect?",
        "type": "mcq",
        "o": [
            "Omit the second argument",
            "Pass an empty array []",
            "Pass null",
            "Pass false"
        ]
    },
    {
        "q": "If you want to read the current theme context, which hook do you use?",
        "type": "mcq",
        "o": [
            "useContext",
            "useTheme",
            "useProps",
            "useState"
        ]
    },
    {
        "q": "useReducer is usually preferable to useState when...",
        "type": "mcq",
        "o": [
            "the next state depends on the previous one",
            "state is a simple primitive",
            "there are no side effects",
            "creating a simple counter"
        ]
    },
    {
        "q": "Can a custom hook manage its own state?",
        "type": "mcq",
        "o": [
            "Yes, using useState or useReducer",
            "No, it must use the component's state",
            "Only using Redux",
            "Only if it is a pure function"
        ]
    },
    {
        "q": "The function passed to useEffect acts as...",
        "type": "mcq",
        "o": [
            "componentDidMount and componentDidUpdate",
            "componentWillUnmount only",
            "constructor",
            "render method"
        ]
    },
    {
        "q": "What must be passed to React.createContext()?",
        "type": "mcq",
        "o": [
            "A default value",
            "A provider component",
            "A consumer component",
            "A hook function"
        ]
    },
    {
        "q": "Which is NOT a valid hook?",
        "type": "mcq",
        "o": [
            "useData",
            "useEffect",
            "useState",
            "useContext"
        ]
    },
    {
        "q": "Actions in useReducer are typically...",
        "type": "mcq",
        "o": [
            "objects with a type property",
            "strings representing the state",
            "functions to update state",
            "boolean flags"
        ]
    },
    {
        "q": "If useEffect returns a function, when is it called?",
        "type": "mcq",
        "o": [
            "Before the effect re-runs or on unmount",
            "Immediately after the effect runs",
            "Only on page refresh",
            "When the app crashes"
        ]
    },
    {
        "q": "Can you use useContext without a Context.Provider?",
        "type": "mcq",
        "o": [
            "Yes, it uses the default value",
            "No, it throws an error",
            "Yes, but it returns undefined",
            "No, it returns null"
        ]
    },
    {
        "q": "What is the main benefit of extracting logic into a custom hook?",
        "type": "mcq",
        "o": [
            "Reusability across components",
            "Faster rendering speed",
            "Automatic error handling",
            "Reduced bundle size"
        ]
    },
    {
        "q": "In useReducer, the 'initialArg' is the...",
        "type": "mcq",
        "o": [
            "second argument",
            "first argument",
            "third argument",
            "return value"
        ]
    },
    {
        "q": "Which hook is useful for reading from local storage?",
        "type": "mcq",
        "o": [
            "A custom hook (e.g., useLocalStorage)",
            "useContext",
            "useReducer",
            "useHistory"
        ]
    },
    {
        "q": "Does useEffect block the browser from painting?",
        "type": "mcq",
        "o": [
            "No, it runs asynchronously",
            "Yes, it is synchronous",
            "Only if it contains a heavy computation",
            "Only in strict mode"
        ]
    },
    {
        "q": "What hook allows functional components to have 'lifecycle' events?",
        "type": "mcq",
        "o": [
            "useEffect",
            "useLifecycle",
            "useEvent",
            "useState"
        ]
    },
    {
        "q": "If I want to access the window width in multiple components, I should...",
        "type": "mcq",
        "o": [
            "create a useWindowWidth custom hook",
            "copy the logic to each component",
            "pass it as a prop from root",
            "use a global variable"
        ]
    },
    {
        "q": "What is 'init' in useReducer(reducer, initialArg, init)?",
        "type": "mcq",
        "o": [
            "Function for lazy initialization",
            "The initial state value",
            "The cleanup function",
            "The dispatch middleware"
        ]
    },
    {
        "q": "Context is primarily used to solve which problem?",
        "type": "mcq",
        "o": [
            "Prop drilling",
            "State immutability",
            "Performance bottlenecks",
            "Asynchronous rendering"
        ]
    },
    {
        "q": "Can you debug custom hooks in React DevTools?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only in production",
            "Only if they use useDebugValue"
        ]
    },
    {
        "q": "How do you conditionally skip an effect?",
        "type": "mcq",
        "o": [
            "Use the dependency array",
            "Use an if statement inside the hook",
            "Use a try-catch block",
            "Return false from the effect"
        ]
    },
    {
        "q": "Can useReducer handle asynchronous updates directly?",
        "type": "mcq",
        "o": [
            "No, reducers must be pure",
            "Yes, by using async/await",
            "Yes, by returning a promise",
            "Only with external libraries"
        ]
    },
    {
        "q": "What does useReducer return if no state change occurs?",
        "type": "mcq",
        "o": [
            "The current state",
            "null",
            "undefined",
            "An error"
        ]
    },
    {
        "q": "Which hook would you use to listen to 'resize' events?",
        "type": "mcq",
        "o": [
            "useEffect",
            "useResize",
            "useEvent",
            "useListener"
        ]
    },
    {
        "q": "A custom hook must start with 'use' to...",
        "type": "mcq",
        "o": [
            "let React check for hook rule violations",
            "make it a reserved keyword",
            "allow it to access the DOM",
            "compile it faster"
        ]
    },
    {
        "q": "In `const [state, dispatch] = useReducer(reducer, initial)`, what is `state`?",
        "type": "mcq",
        "o": [
            "The current state value",
            "The initial state value",
            "A reference to the state object",
            "The history of state changes"
        ]
    },
    {
        "q": "Context Provider component accepts a prop called...",
        "type": "mcq",
        "o": [
            "value",
            "data",
            "context",
            "state"
        ]
    },
    {
        "q": "Dependencies in useEffect are compared using...",
        "type": "mcq",
        "o": [
            "shallow comparison (Object.is)",
            "deep comparison",
            "JSON.stringify",
            "reference counting"
        ]
    },
    {
        "q": "When creating a custom hook, what determines its return value?",
        "type": "mcq",
        "o": [
            "You decide what it returns",
            "React mandates an array",
            "It must return JSX",
            "It cannot return anything"
        ]
    },
    {
        "q": "If you need to fetch data when a component mounts, where do you put the fetch call?",
        "type": "mcq",
        "o": [
            "Inside useEffect with [] dependency",
            "Inside the render body",
            "Inside useState",
            "Inside useMemo"
        ]
    },
    {
        "q": "Can you use hooks inside a loop?",
        "type": "mcq",
        "o": [
            "No",
            "Yes",
            "Only if loop is constant",
            "Only in class components"
        ]
    },
    {
        "q": "What happens if a Context Provider updates its value?",
        "type": "mcq",
        "o": [
            "All consuming components re-render",
            "Only the Provider re-renders",
            "Nothing happens automatically",
            "The app crashes"
        ]
    },
    {
        "q": "Which hook is good for managing toggle states (true/false)?",
        "type": "mcq",
        "o": [
            "useReducer or a custom useToggle hook",
            "useEffect",
            "useContext",
            "useRef"
        ]
    },
    {
        "q": "The cleanup function in useEffect is equivalent to which class lifecycle method?",
        "type": "mcq",
        "o": [
            "componentWillUnmount",
            "componentDidCatch",
            "shouldComponentUpdate",
            "getDerivedStateFromProps"
        ]
    },
    {
        "q": "When using `dispatch({type: 'increment'})` in useReducer, what does the reducer receive as `action`?",
        "type": "mcq",
        "o": [
            "{type: 'increment'}",
            "'increment'",
            "Wait for promise",
            "The current state"
        ]
    },
    {
        "q": "Can custom hooks use `useEffect`?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only if they don't return data",
            "Only if they are pure"
        ]
    },
    {
        "q": "If a dependency is an object, useEffect might run too often because...",
        "type": "mcq",
        "o": [
            "objects have different references on every render",
            "objects are mutable",
            "React cannot compare objects",
            "dependencies must be primitives"
        ]
    },
    {
        "q": "What is the specialized hook `useLayoutEffect` used for?",
        "type": "mcq",
        "o": [
            "Reading layout from DOM and synchronously re-rendering",
            "Managing layout grid systems",
            "Optimizing CSS transitions",
            "Lazy loading components"
        ]
    },
    {
        "q": "Which of these is NOT a rule of hooks?",
        "type": "mcq",
        "o": [
            "Call hooks only in class components",
            "Call hooks at the top level",
            "Call hooks from React functions",
            "Don't call hooks inside loops"
        ]
    },
    {
        "q": "To avoid passing props through many levels, we use...",
        "type": "mcq",
        "o": [
            "Context API",
            "Higher-Order Components",
            "Render Props",
            "React.memo"
        ]
    },
    {
        "q": "Can `useReducer` be used for local component state?",
        "type": "mcq",
        "o": [
            "Yes, it is often used for complex local state",
            "No, only for global state",
            "No, validation requires Redux",
            "Only if passed to a Provider"
        ]
    },
    {
        "q": "How do you access the value of a context without the `useContext` hook in a functional component?",
        "type": "mcq",
        "o": [
            "Use the Consumer component",
            "You cannot access it",
            "Use `this.context`",
            "Use `Context.getValue()`"
        ]
    },
    {
        "q": "Custom hooks allow you to package...",
        "type": "mcq",
        "o": [
            "logic and state",
            "UI and styles",
            "HTML and CSS",
            "backend API routes"
        ]
    },
    {
        "q": "When does the lazy initialization function in useReducer run?",
        "type": "mcq",
        "o": [
            "Only during the initial render",
            "Every time the component updates",
            "When dispatch is called",
            "When the component unmounts"
        ]
    },
    {
        "q": "What is the common naming convention for Context objects?",
        "type": "mcq",
        "o": [
            "ThemeContext, UserContext",
            "themeContext, userContext",
            "ContextTheme, ContextUser",
            "useTheme, useUser"
        ]
    },
    {
        "q": "If you have a `useFetch` custom hook, what does it likely return?",
        "type": "mcq",
        "o": [
            "data, loading, and error states",
            "The JSX to render the data",
            "The fetch promise itself",
            "A callback to component"
        ]
    },
    {
        "q": "Does `useEffect` run server-side?",
        "type": "mcq",
        "o": [
            "No",
            "Yes",
            "Only if configured",
            "Yes, with Next.js"
        ]
    },
    {
        "q": "Can you call `useState` inside a custom hook?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only if exported",
            "Only once"
        ]
    },
    {
        "q": "What hook should you use if your effect manipulates the DOM and needs to happen before paint?",
        "type": "mcq",
        "o": [
            "useLayoutEffect",
            "useEffect",
            "useRef",
            "useInsertionEffect"
        ]
    },
    {
        "q": "Which hook is best for form handling logic reuse?",
        "type": "mcq",
        "o": [
            "A custom hook (e.g., useForm)",
            "useReducer",
            "useContext",
            "useEffect"
        ]
    },
    {
        "q": "In `useEffect(() => { ... }, [count])`, the effect runs when...",
        "type": "mcq",
        "o": [
            "`count` changes",
            "the component mounts only",
            "`count` is null",
            "every second"
        ]
    },
    {
        "q": "What mechanism does `useReducer` use to update state?",
        "type": "mcq",
        "o": [
            "Dispathing actions",
            "Direct mutation",
            "Calling setState",
            "Event bubbling"
        ]
    },
    {
        "q": "If deep prop passing is the problem, is `useReducer` the solution?",
        "type": "mcq",
        "o": [
            "No, Context is the solution",
            "Yes, it eliminates props",
            "Only combined with `useCallback`",
            "Yes, it stores data globally"
        ]
    },
    {
        "q": "Can you pass parameters to a custom hook?",
        "type": "mcq",
        "o": [
            "Yes, just like a regular function",
            "No, hooks take no arguments",
            "Only configuration objects",
            "Only initial state"
        ]
    },
    {
        "q": "Which hook allows you to persist a value across renders without causing re-renders?",
        "type": "mcq",
        "o": [
            "useRef",
            "useState",
            "useMemo",
            "useEffect"
        ]
    },
    {
        "q": "If you omit the second argument to useEffect, it behaves like...",
        "type": "mcq",
        "o": [
            "componentDidMount + componentDidUpdate",
            "componentDidMount only",
            "componentWillUnmount",
            "shouldComponentUpdate"
        ]
    },
    {
        "q": "Can `useContext` trigger a re-render even if the parent component didn't render?",
        "type": "mcq",
        "o": [
            "Yes, if the context value changes",
            "No, parent must render first",
            "Yes, but only in concurrent mode",
            "No, props must change"
        ]
    },
    {
        "q": "What is the best way to unit test a custom hook?",
        "type": "mcq",
        "o": [
            "Using a testing library like `renderHook`",
            "Manually mounting a dummy component",
            "Calling it as a regular function",
            "You cannot test hooks"
        ]
    },
    {
        "q": "Is it good practice to wrap `dispatch` from `useReducer` in `useCallback`?",
        "type": "mcq",
        "o": [
            "No, dispatch is already stable",
            "Yes, to prevent re-renders",
            "Yes, for performance",
            "Only if passed to children"
        ]
    },
    {
        "q": "What happens if you have circular dependencies in useEffect?",
        "type": "mcq",
        "o": [
            "Infinite re-render loop",
            "It stops automatically",
            "Effect runs once",
            "React warning only"
        ]
    },
    {
        "q": "When multiple components use the same custom hook, do they share state?",
        "type": "mcq",
        "o": [
            "No, each uses its own independent state",
            "Yes, state is global",
            "Yes, if defined in same file",
            "Only if wrapped in Context"
        ]
    },
    {
        "q": "What indicates a component is 'unmounting' in useEffect?",
        "type": "mcq",
        "o": [
            "The cleanup function is called",
            "The effect returns null",
            "The dependency array is empty",
            "The first argument is null"
        ]
    },
    {
        "q": "Can you use `async/await` directly in the `useEffect` callback function?",
        "type": "mcq",
        "o": [
            "No, the callback shouldn't return a Promise",
            "Yes, it works fine",
            "Only in React 18",
            "Only with Suspense"
        ]
    },
    {
        "q": "Which hook is helpful for defining a reducer in a functional component?",
        "type": "mcq",
        "o": [
            "useReducer",
            "useRedux",
            "useState",
            "useAction"
        ]
    },
    {
        "q": "What is the primary difference between `useState` and `useReducer`?",
        "type": "mcq",
        "o": [
            "useReducer uses a reducer function for state updates",
            "useState cannot hold objects",
            "useReducer is synchronous",
            "useState is deprecated"
        ]
    },
    {
        "q": "If you want to perform an action when a specific prop changes, you use...",
        "type": "mcq",
        "o": [
            "useEffect with that prop in dependency array",
            "useState",
            "useRef",
            "if statement in render"
        ]
    },
    {
        "q": "A custom hook that attaches an event listener should also...",
        "type": "mcq",
        "o": [
            "remove it in the cleanup function",
            "return the listener",
            "use `useCallback`",
            "be inside a class"
        ]
    },
    {
        "q": "What is `React.createContext(defaultValue)` used for?",
        "type": "mcq",
        "o": [
            "Creating a Context object",
            "Accessing context",
            "Updating context",
            "Defining a reducer"
        ]
    },
    {
        "q": "Which hook allows you to get the previous value of props or state?",
        "type": "mcq",
        "o": [
            "A custom hook using `useRef`",
            "usePrevious",
            "useHistory",
            "useEffect"
        ]
    },
    {
        "q": "In `useEffect`, if you rely on a function from props, you should...",
        "type": "mcq",
        "o": [
            "put it in the dependency array",
            "ignore it",
            "call it only once",
            "use useReducer"
        ]
    },
    {
        "q": "What happens if you use a mutable variable (like a global variable) in the dependency array of useEffect?",
        "type": "mcq",
        "o": [
            "React might not detect changes efficiently",
            "It works perfectly",
            "It throws a syntax error",
            "It converts it to state"
        ]
    },
    {
        "q": "Why might you use `useReducer` over `useState` for a form with many fields?",
        "type": "mcq",
        "o": [
            "To centralize the update logic and handle multiple field updates",
            "Because `useState` cannot handle objects",
            "To make the form render faster",
            "Because `useReducer` is automatically persistent"
        ]
    },
    {
        "q": "If `useContext` triggers too many re-renders, how can you optimize it?",
        "type": "mcq",
        "o": [
            "Split the context into smaller contexts",
            "Use `useContext` inside `useEffect`",
            "Wrap the Consumer in `React.memo`",
            "You cannot optimize Context"
        ]
    },
    {
        "q": "What is the 'stale closure' problem in `useEffect`?",
        "type": "mcq",
        "o": [
            "The effect captures variables from a previous render",
            "The effect never runs",
            "The effect runs too many times",
            "The cleanup function is not called"
        ]
    },
    {
        "q": "When using `useReducer`, how do you access the state in other components?",
        "type": "mcq",
        "o": [
            "Pass it down via props or Context",
            "It is globally available",
            "Use `getReducerState` hook",
            "Import the reducer function"
        ]
    },
    {
        "q": "Can a custom hook return a JSX component?",
        "type": "mcq",
        "o": [
            "Yes, but it's uncommon",
            "No, only hooks return data",
            "Yes, this is the main purpose",
            "No, it violates React rules"
        ]
    },
    {
        "q": "If you want to fetch data when a user clicks a button, you should use...",
        "type": "mcq",
        "o": [
            "an event handler calling the fetch function",
            "useEffect",
            "useLayoutEffect",
            "useMemo"
        ]
    },
    {
        "q": "What is the correct way to update a nested object in `useReducer`?",
        "type": "mcq",
        "o": [
            "Return a new object with spread syntax copying previous levels",
            "Mutate the state directly",
            "Use `Object.assign` mutation",
            "Return only the changed field"
        ]
    },
    {
        "q": "Is `useEffect` guaranteed to fire after the DOM has been updated?",
        "type": "mcq",
        "o": [
            "Yes",
            "No, it fires before paint",
            "No, it fires during render",
            "Only in concurrent mode"
        ]
    },
    {
        "q": "What is the benefit of returning a cleanup function in `useEffect` for a subscription?",
        "type": "mcq",
        "o": [
            "Prevents memory leaks",
            "Speeds up subscription",
            "Allows multiple subscriptions",
            "Automatically updates state"
        ]
    },
    {
        "q": "Can you use `useContext` in a Class component?",
        "type": "mcq",
        "o": [
            "No, use `static contextType` or Consumer",
            "Yes, inside `render`",
            "Yes, inside `componentDidMount`",
            "Yes, anywhere"
        ]
    },
    {
        "q": "How do you detect if a component is truly mounted inside an async effect?",
        "type": "mcq",
        "o": [
            "Use a boolean flag (isMounted) inside the effect",
            "Check `this.mounted`",
            "Use `useIsMounted` hook provided by React",
            "Check `window.mounted`"
        ]
    },
    {
        "q": "If you declare a function inside a component body, when is it recreated?",
        "type": "mcq",
        "o": [
            "On every render",
            "Only on mount",
            "Only when props change",
            "Never"
        ]
    },
    {
        "q": "To prevent a function dependency from causing `useEffect` to re-run unnecessarily, you should...",
        "type": "mcq",
        "o": [
            "wrap the function definition in `useCallback`",
            "remove it from dependencies",
            "move it outside the component",
            "any of the above"
        ]
    },
    {
        "q": "What is the typical pattern for handling 'loading' state with `useReducer`?",
        "type": "mcq",
        "o": [
            "Dispatch 'FETCH_INIT', 'FETCH_SUCCESS', 'FETCH_FAILURE'",
            "Use a separate `useState` for loading",
            "Check if data is null",
            "Use `Suspense` automatically"
        ]
    },
    {
        "q": "Does `useContext` replace Redux?",
        "type": "mcq",
        "o": [
            "No, it's a transport mechanism, not a state manager",
            "Yes, completely",
            "Yes, but only for small apps",
            "No, Redux is deprecated"
        ]
    },
    {
        "q": "If a custom hook uses `useState`, where is that state stored?",
        "type": "mcq",
        "o": [
            "In the component using the hook",
            "In the hook itself",
            "In the global window object",
            "In a separate heap"
        ]
    },
    {
        "q": "What happens if you return a Promise from `useEffect`?",
        "type": "mcq",
        "o": [
            "It causes a warning/error about cleanup function",
            "React waits for the promise",
            "It works as `async` effect",
            "Nothing happens"
        ]
    },
    {
        "q": "Which hook is best for implementing a 'debounced' search input?",
        "type": "mcq",
        "o": [
            "useEffect with a cleanup timer",
            "useMemo",
            "useReducer",
            "useContext"
        ]
    },
    {
        "q": "In `useReducer`, is the `initialState` mutable?",
        "type": "mcq",
        "o": [
            "No, you should treat it as immutable",
            "Yes, you can change it freely",
            "Only if it's an object",
            "Only inside the reducer"
        ]
    },
    {
        "q": "Can you use `refs` inside a custom hook?",
        "type": "mcq",
        "o": [
            "Yes, to store mutable values",
            "No, refs are for DOM only",
            "Only if passed as argument",
            "Only in class components"
        ]
    },
    {
        "q": "What is the default value of the argument in `useContext(MyContext)`?",
        "type": "mcq",
        "o": [
            "The value passed to `createContext`",
            "undefined",
            "null",
            "The nearest Provider's value"
        ]
    },
    {
        "q": "If you have a heavy calculation in a custom hook, you should wrap it in...",
        "type": "mcq",
        "o": [
            "useMemo",
            "useEffect",
            "useCallback",
            "useRef"
        ]
    },
    {
        "q": "Does `useReducer` support middleware like Redux Thunk out of the box?",
        "type": "mcq",
        "o": [
            "No",
            "Yes",
            "Only logging middleware",
            "Yes, if configured"
        ]
    },
    {
        "q": "When creating a library of hooks, how do you handle peer dependencies?",
        "type": "mcq",
        "o": [
            "List `react` as a peer dependency",
            "Bundle `react` inside",
            "List `react` as a dev dependency only",
            "Do not list `react`"
        ]
    },
    {
        "q": "Can `useEffect` depend on a ref?",
        "type": "mcq",
        "o": [
            "It can, but ref changes don't trigger re-renders",
            "Yes, and it triggers re-render",
            "No, refs are invisible to hooks",
            "No, it throws error"
        ]
    },
    {
        "q": "Why is `useContext` often paired with `useReducer`?",
        "type": "mcq",
        "o": [
            "To simulate a global state management system",
            "To improve performance",
            "They are required to be used together",
            "To handle routing"
        ]
    },
    {
        "q": "What is the danger of putting an object literal `{{...}}` as a context value?",
        "type": "mcq",
        "o": [
            "It creates a new object every render, causing consumers to re-render",
            "It is invalid syntax",
            "It causes memory leaks",
            "It breaks the Provider"
        ]
    },
    {
        "q": "How can you run an effect only when a specific prop *changes* (not just on mount)?",
        "type": "mcq",
        "o": [
            "Add the prop to dependency array",
            "Use `useRef` to track previous value and compare",
            "Remove dependency array",
            "Use `useLayoutEffect`"
        ]
    },
    {
        "q": "Custom hooks are essentially...",
        "type": "mcq",
        "o": [
            "functions that use hooks",
            "class components",
            "higher-order components",
            "mixins"
        ]
    },
    {
        "q": "In `useEffect`, why must we be careful with setting state?",
        "type": "mcq",
        "o": [
            "It can cause infinite loops if not handled correctly",
            "It is asynchronous",
            "It blocks the UI",
            "It is disabled in effects"
        ]
    },
    {
        "q": "Is it possible to use `hooks` in a regular JavaScript function (not a component or hook)?",
        "type": "mcq",
        "o": [
            "No, it violates hook rules",
            "Yes, if it's called by a component",
            "Yes, anywhere",
            "Yes, with a special flag"
        ]
    },
    {
        "q": "Which hook can be used to force a re-render?",
        "type": "mcq",
        "o": [
            "useReducer(x => x + 1, 0)",
            "useEffect",
            "useRef",
            "useCallback"
        ]
    },
    {
        "q": "When using `useContext` with a large object, how can you prevent unnecessary re-renders?",
        "type": "mcq",
        "o": [
            "Split context or use memoization",
            "Use `shouldComponentUpdate`",
            "Use `React.PureComponent`",
            "Disable context updates"
        ]
    },
    {
        "q": "What is the purpose of the `init` function in `useReducer`'s lazy initialization?",
        "type": "mcq",
        "o": [
            "To calculate initial state logic only when needed",
            "To reset the state",
            "To handle side effects",
            "To logger actions"
        ]
    },
    {
        "q": "Can `custom hooks` be asynchronous?",
        "type": "mcq",
        "o": [
            "They can contain async logic, but the hook function itself must be synchronous",
            "Yes, they can be `async function use...`",
            "No, async is not allowed",
            "Only for data fetching"
        ]
    },
    {
        "q": "If `useEffect` dependencies are missing, what tool helps identify them?",
        "type": "mcq",
        "o": [
            "ESLint plugin `react-hooks/exhaustive-deps`",
            "React DevTools",
            "Console warnings",
            "TypeScript compiler"
        ]
    },
    {
        "q": "What is the recommended way to fetch data in strictly React 18+ (outside of effects)?",
        "type": "mcq",
        "o": [
            "Libraries (React Query, SWR) or Suspense-enabled frameworks",
            "Synchronous XHR",
            "Global fetch",
            "Inline fetch"
        ]
    },
    {
        "q": "Can you use `useContext` inside `useEffect`?",
        "type": "mcq",
        "o": [
            "Yes",
            "No",
            "Only if dependencey is set",
            "Only in loops"
        ]
    },
    {
        "q": "When defining a reducer, where should the function be defined?",
        "type": "mcq",
        "o": [
            "Outside the component (if it doesn't need props) or inside using `useCallback`",
            "Always inside the component",
            "In a separate file only",
            "Inside `useEffect`"
        ]
    },
    {
        "q": "How do you share code between a Class and a Functional component?",
        "type": "mcq",
        "o": [
            "Render props or HOCs",
            "Hooks",
            "Mixins",
            "Inheritance"
        ]
    },
    {
        "q": "What describes 'Prop Drilling'?",
        "type": "mcq",
        "o": [
            "Passing data through many layers of components",
            "Using `useDrill` hook",
            "Passing method references",
            "Injecting props optimization"
        ]
    },
    {
        "q": "Which hook can capture the previous value of a state?",
        "type": "mcq",
        "o": [
            "useRef",
            "usePrevious",
            "useEffect",
            "useState"
        ]
    },
    {
        "q": "If `useEffect` removes an event listener, the function returned is called...",
        "type": "mcq",
        "o": [
            "cleanup function",
            "disposer",
            "un-mounter",
            "destructor"
        ]
    },
    {
        "q": "Which API allows passing data without manually passing props at every level?",
        "type": "mcq",
        "o": [
            "Context API",
            "Props API",
            "Ref API",
            "DOM API"
        ]
    },
    {
        "q": "Why is `useCallback` important when passing functions to children?",
        "type": "mcq",
        "o": [
            "It maintains reference equality to prevent child re-renders",
            "It makes the function run faster",
            "It allows the function to access state",
            "It binds `this` context"
        ]
    },
    {
        "q": "Can `useReducer` state be an array?",
        "type": "mcq",
        "o": [
            "Yes",
            "No, must be object",
            "No, must be primitive",
            "Only strings"
        ]
    },
    {
        "q": "Does `useEffect` run before or after the browser paints?",
        "type": "mcq",
        "o": [
            "After",
            "Before",
            "Simultaneously",
            "It depends on network"
        ]
    },
    {
        "q": "Custom hooks allow logic reuse that was previously done with...",
        "type": "mcq",
        "o": [
            "Mixins and HOCs",
            "Classes and inheritance",
            "jQuery plugins",
            "Global variables"
        ]
    },
    {
        "q": "What is the effect of passing `[prop]` to `useEffect`?",
        "type": "mcq",
        "o": [
            "Runs on mount and whenever `prop` changes",
            "Runs only on mount",
            "Runs on every render",
            "Runs only when `prop` is true"
        ]
    }
,
{
    "q": "Which hook exposes the same capability as `this.setState` in classes but for function components?",
    "type": "mcq",
    "o": [
        "useState",
        "useEffect",
        "useContext",
        "useReducer"
    ]
},
{
    "q": "If `useEffect` runs on every render, what is likely missing?",
    "type": "mcq",
    "o": [
        "The dependency array",
        "The return statement",
        "The import statement",
        "The await keyword"
    ]
},
{
    "q": "Can `useContext` be used to replace localized state (useState)?",
    "type": "mcq",
    "o": [
        "It can, but it is generally an overkill and affects performance",
        "Yes, it is the recommended way",
        "No, it only works for strings",
        "No, it cannot store values"
    ]
},
{
    "q": "What happens when you use `useReducer` with `React.memo` on the child component?",
    "type": "mcq",
    "o": [
        "The child only re-renders if props (including dispatch) change",
        "The child never re-renders",
        "The child always re-renders",
        "The reducer stops working"
    ]
},
{
    "q": "What is a 'side effect' in React components?",
    "type": "mcq",
    "o": [
        "Data fetching, subscriptions, or manually changing the DOM",
        "Calculating state",
        "Rendering JSX",
        "Defining props"
    ]
},
{
    "q": "If you have a custom hook `useAuth`, where should you call it?",
    "type": "mcq",
    "o": [
        "At the top level of your function component",
        "Inside a condition",
        "Inside `useEffect`",
        "Inside `return` statement"
    ]
},
{
    "q": "Can `useEffect` be used to validate props?",
    "type": "mcq",
    "o": [
        "Yes, by checking them inside the effect",
        "No, use PropTypes or TypeScript",
        "Yes, but only in dev mode",
        "No, effects cannot read props"
    ]
},
{
    "q": "What is the third argument to `useReducer` used for?",
    "type": "mcq",
    "o": [
        "Lazy initialization of state",
        "Middleware configuration",
        "Debug label",
        "Context provider"
    ]
},
{
    "q": "If you want to use a context value only in a specific part of the tree, where do you put the Provider?",
    "type": "mcq",
    "o": [
        "As close as possible to the consuming components",
        "Always at the root (index.js)",
        "Inside the consuming component",
        "In a separate file"
    ]
},
{
    "q": "Why is `useReducer` considered more predictable than `useState`?",
    "type": "mcq",
    "o": [
        "State transitions are explicit and central",
        "It makes components pure",
        "It disallows async operations",
        "It uses Redux under the hood"
    ]
},
{
    "q": "What does `useEffect(() => {}, [])` simulate?",
    "type": "mcq",
    "o": [
        "componentDidMount",
        "componentDidUpdate",
        "componentWillUnmount",
        "getDerivedStateFromProps"
    ]
},
{
    "q": "Can multiple contexts be consumed by one component?",
    "type": "mcq",
    "o": [
        "Yes, by calling `useContext` multiple times",
        "No, only one context per component",
        "Yes, but they overwrite each other",
        "Yes, by merging providers"
    ]
},
{
    "q": "Should API calls be made directly in the request body of the component?",
    "type": "mcq",
    "o": [
        "No, they should be in `useEffect` or event handlers",
        "Yes, it is faster",
        "Yes, if using Suspense",
        "Only for GET requests"
    ]
},
{
    "q": "If you use `setInterval` inside `useEffect`, what must you do to avoid bugs?",
    "type": "mcq",
    "o": [
        "Clear the interval in the return function",
        "Use `setTimeout` instead",
        "Nothing, React handles it",
        "Pass the interval ID to dependencies"
    ]
},
{
    "q": "How does `useReducer` handle deep updates?",
    "type": "mcq",
    "o": [
        "Manually copying nested levels (using spread or libraries like Immer)",
        "It does it automatically",
        "It cannot handle deep updates",
        "By using JSON.stringify"
    ]
},
{
    "q": "What is the primary role of a 'custom hook'?",
    "type": "mcq",
    "o": [
        "To encapsulate reusable stateful logic",
        "To replace class components",
        "To create UI components",
        "To configure Webpack"
    ]
},
{
    "q": "Can `useContext` lead to performance issues if the context value changes frequently?",
    "type": "mcq",
    "o": [
        "Yes, because all consumers re-render",
        "No, React optimizations prevent this",
        "Only if the value is large",
        "No, Context is faster than props"
    ]
},
{
    "q": "If you need to imperatively call a child method, which hook is relevant?",
    "type": "mcq",
    "o": [
        "useImperativeHandle (with useRef)",
        "useEffect",
        "useContext",
        "useReducer"
    ]
},
{
    "q": "What happens if a custom hook throws an error?",
    "type": "mcq",
    "o": [
        "The error propagates to the component using it (requires Error Boundary)",
        "The hook returns null",
        "The app ignores it",
        "The hook restarts"
    ]
},
{
    "q": "Is it possible to reset Ref value in `useEffect`?",
    "type": "mcq",
    "o": [
        "Yes, `ref.current = value`",
        "No, refs are read-only",
        "Only in the cleanup function",
        "Only using `useState`"
    ]
},
{
    "q": "Context API is defined in which package?",
    "type": "mcq",
    "o": [
        "react",
        "react-dom",
        "react-router",
        "redux"
    ]
},
{
    "q": "When a component unmounts, what happens to the state in `useReducer`?",
    "type": "mcq",
    "o": [
        "It is destroyed (unless stored globally)",
        "It is preserved in memory",
        "It is saved to local storage",
        "It is sent to the parent"
    ]
},
{
    "q": "What is the benefit of keeping the dependency array exhaustive?",
    "type": "mcq",
    "o": [
        "Ensures the effect always operates on the latest data",
        "Prevents the effect from running",
        "Optimizes bundle size",
        "Allows using `var` instead of `const`"
    ]
},
{
    "q": "Which hook can be used to optimize expensive calculations?",
    "type": "mcq",
    "o": [
        "useMemo",
        "useEffect",
        "useCallback",
        "useReducer"
    ]
},
{
    "q": "If you want to use 'lifecycle methods' in a functional component, you use...",
    "type": "mcq",
    "o": [
        "Hooks (mainly useEffect)",
        "Classes",
        "Mixins",
        "Polyfills"
    ]
},
{
    "q": "Can you use `useContext` to pass functions?",
    "type": "mcq",
    "o": [
        "Yes",
        "No, only data",
        "Only pure functions",
        "Only dispatch functions"
    ]
},
{
    "q": "What is the return type of `useEffect`?",
    "type": "mcq",
    "o": [
        "void or a cleanup function",
        "The effect result",
        "A promise",
        "The dependency array"
    ]
},
{
    "q": "If `useReducer` dispatch is called with the *same* state value...",
    "type": "mcq",
    "o": [
        "React bails out (skips re-render)",
        "React forces a re-render",
        "Wait for next tick",
        "It throws an error"
    ]
},
{
    "q": "What is the main drawback of 'Prop Drilling'?",
    "type": "mcq",
    "o": [
        "Makes intermediate components bloated and hard to maintain",
        "Decreases application speed",
        "Requires more memory",
        "Breaks encapsulation"
    ]
},
{
    "q": "How can you debug a custom hook?",
    "type": "mcq",
    "o": [
        "useDebugValue hook or console.log",
        "useDebugger",
        "cannot be debugged",
        "only in unit tests"
    ]
},
{
    "q": "Which hook is useful for tracking focus state?",
    "type": "mcq",
    "o": [
        "A custom hook using event listeners",
        "useFocus",
        "useRef only",
        "useEffect only"
    ]
},
{
    "q": "In `const [state, dispatch] = useReducer(reducer, initial)`, is `dispatch` stable?",
    "type": "mcq",
    "o": [
        "Yes, its identity is stable across renders",
        "No, it changes every render",
        "Yes, but only if memoized",
        "No, depend on Redux"
    ]
},
{
    "q": "Can `useEffect` be async?",
    "type": "mcq",
    "o": [
        "No, the function passed to useEffect cannot be async",
        "Yes, `useEffect(async () => ...)` is valid",
        "Yes, in React 19",
        "Only for data fetching"
    ]
},
{
    "q": "If `useContext` value is a dynamic object, wrapping it in `useMemo` helps...",
    "type": "mcq",
    "o": [
        "prevent unnecessary re-renders of consumers",
        "prevent the provider from rendering",
        "cache the context in the browser",
        "encrypt the context"
    ]
},
{
    "q": "What does `useLayoutEffect` block?",
    "type": "mcq",
    "o": [
        "Visual updates (painting)",
        "Network requests",
        "Event listeners",
        "State updates"
    ]
},
{
    "q": "If you have 10 `useState` hooks, should you convert to `useReducer`?",
    "type": "mcq",
    "o": [
        "Usually yes, to manage related state logic better",
        "No, quantity doesn't matter",
        "Yes, `useState` has a limit of 5",
        "No, `useReducer` is slower"
    ]
},
{
    "q": "Can a custom hook return an array like `useState`?",
    "type": "mcq",
    "o": [
        "Yes, `[value, setValue]` pattern is common",
        "No, must return object",
        "No, must return single value",
        "Only if it uses `useState` internally"
    ]
},
{
    "q": "Is `useEffect` called during server-side rendering?",
    "type": "mcq",
    "o": [
        "No",
        "Yes",
        "Only if `ssr: true`",
        "Yes, for SEO"
    ]
},
{
    "q": "If you want to run code when the component unmounts, you place it in...",
    "type": "mcq",
    "o": [
        "the return function of `useEffect`",
        "`useUnmount` hook",
        "the dependency array",
        "the catch block"
    ]
},
{
    "q": "What is `React.createContext()` used for?",
    "type": "mcq",
    "o": [
        "Initializing a Context object",
        "Creating a Redux store",
        "Creating a new component",
        "Defining global variables"
    ]
},
{
    "q": "Can you use `useEffect` to subscribe to external data sources?",
    "type": "mcq",
    "o": [
        "Yes, commonly used for subscriptions",
        "No, use `useSubscription`",
        "No, use websockets directly",
        "Only via libraries"
    ]
},
{
    "q": "When using `useReducer`, where is the business logic typically located?",
    "type": "mcq",
    "o": [
        "In the reducer function",
        "In the dispatch call",
        "In the component",
        "In the view layer"
    ]
},
{
    "q": "If you need to fetch data based on a prop `id`, what should the dependency array be?",
    "type": "mcq",
    "o": [
        "`[id]`",
        "`[]`",
        "`[props]`",
        "`[fetch]`"
    ]
},
{
    "q": "What pattern allows a child component to update a parent's state via context?",
    "type": "mcq",
    "o": [
        "Passing a state updater function (dispatch/setState) in the context value",
        "It effectively cannot",
        "Using `reverseContext`",
        "Using `parent.state`"
    ]
},
{
    "q": "Custom hooks can help separate...",
    "type": "mcq",
    "o": [
        "concerns (logic vs UI)",
        "files",
        "dependencies",
        "styles"
    ]
},
{
    "q": "In `useEffect`, if you use a function like `fetchData` defined outside the effect...",
    "type": "mcq",
    "o": [
        "include it in dependencies or wrap it in useCallback",
        "ignore it safely",
        "move it to a separate file",
        "it will cause an error"
    ]
},
{
    "q": "What is the best way to handle errors in `useEffect`?",
    "type": "mcq",
    "o": [
        "Try/catch inside the effect function",
        "Error boundaries",
        "It throws automatically",
        "Return error object"
    ]
},
{
    "q": "Can you dynamically run hooks inside loops or conditions?",
    "type": "mcq",
    "o": [
        "No, hooks must be called in the same order every render",
        "Yes, React 18 supports it",
        "Yes, if wrapped in `useCondition`",
        "Only `useEffect`"
    ]
},
{
    "q": "Which hook serves as the basis for most state management libraries in React?",
    "type": "mcq",
    "o": [
        "useSyncExternalStore (or useContext + useReducer)",
        "useState",
        "useRef",
        "useMemo"
    ]
},
{
    "q": "If `useReducer` is used, do you still need `useState`?",
    "type": "mcq",
    "o": [
        "You might still use `useState` for simple local UI state",
        "No, `useReducer` replaces `useState` entirely",
        "Yes, `useReducer` cannot handle booleans",
        "No, `useState` is removed from React"
    ]
}
,
{
    "q": "To avoid race conditions in `useEffect` when fetching data, what is a common pattern?",
    "type": "mcq",
    "o": [
        "Use a boolean flag (e.g., `let ignore = false`) to check validity before setting state",
        "Use `setTimeout` to delay execution",
        "Use `useRace` custom hook",
        "Call the API twice"
    ]
},
{
    "q": "If you want to use a value from `useContext` but prevent re-renders when other parts of the context change, what is one solution?",
    "type": "mcq",
    "o": [
        "Split the context into multiple contexts based on usage",
        "Use `React.useMemo` on the context value in the provider",
        "Use `shouldComponentUpdate`",
        "Use `React.PureComponent`"
    ]
},
{
    "q": "Which of these is a valid way to force a component to re-mount (fully reset state)?",
    "type": "mcq",
    "o": [
        "Change its `key` prop",
        "Call `forceUpdate()`",
        "Use `useEffect` with no deps",
        "Update a ref"
    ]
},
{
    "q": "Can a reducer in `useReducer` be asynchronous?",
    "type": "mcq",
    "o": [
        "No, reducers must be synchronous and pure",
        "Yes, if you use async/await",
        "Yes, but it returns a promise",
        "Only in Redux"
    ]
},
{
    "q": "What is the primary difference between `useEffect` and `useLayoutEffect`?",
    "type": "mcq",
    "o": [
        "Timing: `useEffect` runs after paint, `useLayoutEffect` runs synchronously before paint",
        "Syntax only",
        "`useLayoutEffect` is deprecated",
        "`useEffect` cannot access DOM"
    ]
},
{
    "q": "If you are creating a custom hook `useFetch`, how should you handle component unmounting during a request?",
    "type": "mcq",
    "o": [
        "Use an `AbortController` signal to cancel the fetch",
        "Ignore it, React handles it",
        "Use `isMounted` ref check",
        "Make the fetch synchronous"
    ]
},
{
    "q": "When multiple `useContext` calls are present in a component, does it subscribe to all of them?",
    "type": "mcq",
    "o": [
        "Yes, updates to any provider trigger re-render",
        "No, only the last one",
        "Yes, but only if they are nested",
        "No, explicit subscription is needed"
    ]
},
{
    "q": "In `useEffect`, why is it considered bad practice to disable the exhaustive-deps rule?",
    "type": "mcq",
    "o": [
        "It often masks bugs where effects run with stale data",
        "It causes syntax errors",
        "It increases bundle size",
        "It breaks server-side rendering"
    ]
},
{
    "q": "How can you simulate `componentWillUnmount` using `useEffect`?",
    "type": "mcq",
    "o": [
        "Return a function from a `useEffect` with `[]` deps",
        "Use `useEffect` without return",
        "Use `useUnmount`",
        "Use `useEffect` with no deps"
    ]
},
{
    "q": "What is the purpose of `React.useDebugValue`?",
    "type": "mcq",
    "o": [
        "To display a label for custom hooks in React DevTools",
        "To log values to console",
        "To conditionally break execution",
        "To test hooks"
    ]
},
{
    "q": "Can `useReducer` interact with `useContext` directly?",
    "type": "mcq",
    "o": [
        "Yes, you can dispatch actions that are passed via context",
        "No, they are mutually exclusive",
        "Yes, reducer can call useContext",
        "Only via HOC"
    ]
},
{
    "q": "If a custom hook `useWindowSize` causes performance issues on resize, what should be added?",
    "type": "mcq",
    "o": [
        "Debouncing or throttling the event listener",
        "Removing the listener",
        "Using `useLayoutEffect`",
        "Using `setTimeout`"
    ]
},
{
    "q": "Why might you wrap a context provider's value in `useMemo`?",
    "type": "mcq",
    "o": [
        "To maintain referential identity and prevent consumers from re-rendering unless data changes",
        "To cache the data on the server",
        "To allow async values",
        "To secure the data"
    ]
},
{
    "q": "In a reducer, how should you handle an unknown action type?",
    "type": "mcq",
    "o": [
        "Return the current state unchanged or throw an error",
        "Return null",
        "Return initial state",
        "Call a fallback function"
    ]
},
{
    "q": "What happens if you define a component inside another component?",
    "type": "mcq",
    "o": [
        "It gets redefined on every render, causing remounting and state loss",
        "It works perfectly fine",
        "It is optimized automatically",
        "React throws an error"
    ]
},
{
    "q": "Can `useEffect` have a cleanup function if it has dependencies?",
    "type": "mcq",
    "o": [
        "Yes, cleanup runs before the effect re-runs (and on unmount)",
        "No, only on unmount",
        "Yes, but it runs after the new effect",
        "No, it creates a memory leak"
    ]
},
{
    "q": "If you need to store a mutable value that does *not* trigger a re-render...",
    "type": "mcq",
    "o": [
        "Use `useRef`",
        "Use `useState`",
        "Use `useMemo`",
        "Use `useEffect`"
    ]
},
{
    "q": "When implementing a 'dark mode' toggle hook, where is the best place to apply the class to the body?",
    "type": "mcq",
    "o": [
        "Inside a `useEffect` or `useLayoutEffect` in the hook",
        "In the render method",
        "In the reducer",
        "In `useState`"
    ]
},
{
    "q": "What is the argument passed to the dispatch function in `useReducer`?",
    "type": "mcq",
    "o": [
        "The action object",
        "The new state directly",
        "The reducer function",
        "A callback"
    ]
},
{
    "q": "Can you use `useEffect` to implement a global event bus?",
    "type": "mcq",
    "o": [
        "Yes, by subscribing to window events or a custom emitter",
        "No, use Redux only",
        "No, React doesn't allow events",
        "Yes, but only for clicks"
    ]
},
{
    "q": "How do you handle 'derived state' in functional components?",
    "type": "mcq",
    "o": [
        "Calculate it during render (or use useMemo)",
        "Store it in useState and update via useEffect",
        "Use useReducer",
        "Fetch it from server"
    ]
},
{
    "q": "What pattern helps avoid 'Context Hell' (nesting many providers)?",
    "type": "mcq",
    "o": [
        "Component composition (passing children) or a massive provider wrapper",
        "Using a single context for everything",
        "Using Redux instead",
        "Removing context"
    ]
},
{
    "q": "Is it valid to call `setValue(prev => ...)` in `useEffect`?",
    "type": "mcq",
    "o": [
        "Yes, functional updates are safe and common",
        "No, it creates a loop",
        "Only if `prev` is in dependencies",
        "Only in layout effects"
    ]
},
{
    "q": "If `useReducer` state depends on props, how do you handle prop changes?",
    "type": "mcq",
    "o": [
        "Use `useEffect` to dispatch an action when props change",
        "Call the reducer directly",
        "Re-initialize the reducer",
        "Use `getDerivedStateFromProps`"
    ]
},
{
    "q": "Why does `setTimeout` in `useEffect` often behave unexpectedly with state?",
    "type": "mcq",
    "o": [
        "It closes over the state value from the render where it was created",
        "React blocks timers",
        "Timers are imprecise",
        "State is mutable"
    ]
},
{
    "q": "What is 'memoization' in the context of custom hooks?",
    "type": "mcq",
    "o": [
        "Caching return values (via useMemo/useCallback) to ensure stability",
        "Writing hooks on paper",
        "Using `React.memo` on the hook",
        "Storing hook history"
    ]
},
{
    "q": "If you have a `useInterval` custom hook, what is a key challenge implementation detail?",
    "type": "mcq",
    "o": [
        "Keeping the callback fresh without resetting the interval",
        "Avoiding use of `setInterval`",
        "Making it asynchronous",
        "Using `useReducer`"
    ]
},
{
    "q": "Can `useContext` be used for theme switching?",
    "type": "mcq",
    "o": [
        "Yes, it is a primary use case",
        "No, it is too slow",
        "Only with CSS-in-JS",
        "Only with Styled Components"
    ]
},
{
    "q": "Does `useReducer` enforce immutability?",
    "type": "mcq",
    "o": [
        "No, but React relies on it for change detection",
        "Yes, it throws error on mutation",
        "Yes, it freezes state",
        "No, mutation is preferred"
    ]
},
{
    "q": "When does `useEffect` cleanup run during a re-render?",
    "type": "mcq",
    "o": [
        "After the new render, but before the new effect runs",
        "Before the new render",
        "Simultaneously with new effect",
        "It doesn't run"
    ]
},
{
    "q": "If you want to track the 'previous' value of a prop across renders, you use...",
    "type": "mcq",
    "o": [
        "A `useRef` updated in `useEffect`",
        "`useState`",
        "`usePrevious` built-in hook",
        "Local variable"
    ]
},
{
    "q": "Can you use `hooks` in conditional logic *inside* a custom hook?",
    "type": "mcq",
    "o": [
        "No, the same rules apply",
        "Yes, custom hooks are exceptions",
        "Yes, if exported",
        "Only `useEffect`"
    ]
},
{
    "q": "What is the best way to combine multiple reducers?",
    "type": "mcq",
    "o": [
        "Create a root reducer function that calls individual slice reducers",
        "Use `combineReducers` from Redux (or similar helper)",
        "Put them in separate `useReducer` hooks",
        "All of the above"
    ]
},
{
    "q": "How do you share state between sibling components using hooks?",
    "type": "mcq",
    "o": [
        "Lift state up to common parent (useState/useReducer) or use Context",
        "Pass state laterally",
        "Use `useSibling`",
        "Direct DOM manipulation"
    ]
},
{
    "q": "If you need to optimize a context that updates frequently, you might...",
    "type": "mcq",
    "o": [
        "pass a dispatch function in context and keep state in a separate context/store",
        "use `useEffect`",
        "disable re-renders",
        "use class components"
    ]
},
{
    "q": "Does `useEffect` support `AbortController` natively?",
    "type": "mcq",
    "o": [
        "No, you must implement the logic yourself in the effect body/cleanup",
        "Yes, it is an argument",
        "Yes, via `return true`",
        "Only for `fetch`"
    ]
},
{
    "q": "When should you use `useImperativeHandle`?",
    "type": "mcq",
    "o": [
        "Rarely, when you need to expose imperative methods to a parent (e.g., focus)",
        "Always for form inputs",
        "To handle state",
        "To optimize rendering"
    ]
},
{
    "q": "If `useEffect` depends on an object `{id: 1}` created in the render body...",
    "type": "mcq",
    "o": [
        "It will trigger the effect every render because reference changes",
        "It will check content equality",
        "It will work fine",
        "React will warn"
    ]
},
{
    "q": "Can you create a custom hook that returns a Component?",
    "type": "mcq",
    "o": [
        "Yes, but beware of remounting if created during render",
        "No",
        "Yes, standard pattern",
        "Only HOCs can do that"
    ]
},
{
    "q": "What is 'idempotency' in the context of `useEffect`?",
    "type": "mcq",
    "o": [
        "Ensuring the effect can run multiple times without unintended side effects (Strict Mode tests this)",
        "Running only once",
        "Running fast",
        "Cleaning up memory"
    ]
},
{
    "q": "If you see 'Warning: Can't perform a React state update on an unmounted component', it means...",
    "type": "mcq",
    "o": [
        "You tried to set state after an async operation completed but the component had unmounted",
        "You used the wrong hook",
        "You have a syntax error",
        "React failed to render"
    ]
},
{
    "q": "What is the best alternative to `isMounted` checks?",
    "type": "mcq",
    "o": [
        "Canceling the async operation (subscription/request) in cleanup",
        "Ignoring the warning",
        "Using global state",
        "Using `forceUpdate`"
    ]
},
{
    "q": "Can `useReducer` manage state that is not an object?",
    "type": "mcq",
    "o": [
        "Yes, the state can be a number, string, boolean, etc.",
        "No, it must be an object",
        "No, it must be an array",
        "Only strings"
    ]
},
{
    "q": "When creating a `useModal` hook, what state does it typically manage?",
    "type": "mcq",
    "o": [
        "isOpen, open, close, toggle",
        "modal content only",
        "screen size",
        "user authentication"
    ]
},
{
    "q": "Why is `useContext` sometimes criticized in large apps?",
    "type": "mcq",
    "o": [
        "Potential for unnecessary re-renders in broad consumers",
        "Complexity of syntax",
        "Lack of TypeScript support",
        "Incompatibility with Classes"
    ]
},
{
    "q": "If you want to fetch data only when a button is clicked, not on mount...",
    "type": "mcq",
    "o": [
        "Don't use `useEffect`; put the logic in the click handler",
        "Use `useEffect` with a condition",
        "Use `useLayoutEffect`",
        "Use `useCallback`"
    ]
},
{
    "q": "Is `useCallback` useful for functions passed to `useEffect` dependencies?",
    "type": "mcq",
    "o": [
        "Yes, it ensures the function identity is stable",
        "No, it has no effect",
        "No, functions cannot be dependencies",
        "Only for event handlers"
    ]
},
{
    "q": "Can you call `useContext` effectively in a loop?",
    "type": "mcq",
    "o": [
        "No, hooks cannot be in loops",
        "Yes",
        "Only for arrays",
        "Only in Redux"
    ]
},
{
    "q": "Which hook might you use to integrate with a third-party DOM library (like D3)?",
    "type": "mcq",
    "o": [
        "useLayoutEffect or useEffect + useRef",
        "useState",
        "useContext",
        "useReducer"
    ]
},
{
    "q": "If `useEffect` has no dependencies `[]`, how does it behave regarding props?",
    "type": "mcq",
    "o": [
        "It captures the initial props and never sees updates inside the effect closure",
        "It updates automatically",
        "It throws an error",
        "It polls for changes"
    ]
}
,
{
    "q": "What is the primary use of `useRef` besides accessing DOM elements?",
    "type": "mcq",
    "o": [
        "Keeping a mutable value around ensuring that it doesn't trigger a re-render",
        "Triggering re-renders explicitly",
        "Replacing `useState` for everything",
        "Storing global state"
    ]
},
{
    "q": "Which hook solves the problem of 'value stability' for context objects?",
    "type": "mcq",
    "o": [
        "useMemo",
        "useCallback",
        "useEffect",
        "useRef"
    ]
},
{
    "q": "If you want to read the latest state in a `setTimeout` inside `useEffect` without adding state to dependencies (which resets timer), you use...",
    "type": "mcq",
    "o": [
        "A ref to hold the state",
        "A global variable",
        "The `useLatest` hook",
        "Nothing, it works automatically"
    ]
},
{
    "q": "Can you use `useEffect` to intercept browser back button?",
    "type": "mcq",
    "o": [
        "Yes, by listening to `popstate` event",
        "No, only Router can do that",
        "No, browser security prevents it",
        "Yes, using `useBack`"
    ]
},
{
    "q": "What is the specialized hook `useInsertionEffect` meant for?",
    "type": "mcq",
    "o": [
        "CSS-in-JS libraries injecting styles before layout",
        "Inserting DOM nodes",
        "Database insertions",
        "Form submissions"
    ]
},
{
    "q": "When does `useDeferredValue` trigger a re-render?",
    "type": "mcq",
    "o": [
        "When the deferred value updates (lagging behind the main UI update)",
        "Immediately",
        "Never",
        "Before paint"
    ]
},
{
    "q": "What is `useTransition` used for?",
    "type": "mcq",
    "o": [
        "Marking state updates as non-urgent (transitions)",
        "CSS transitions",
        "Page navigation animations",
        "Lazy loading"
    ]
},
{
    "q": "Does `useTransition` increase the priority of an update?",
    "type": "mcq",
    "o": [
        "No, it lowers it",
        "Yes, it makes it urgent",
        "It doesn't affect priority",
        "Only in strict mode"
    ]
},
{
    "q": "If you are using `useId`, what is it generating?",
    "type": "mcq",
    "o": [
        "A unique stable ID for accessibility attributes",
        "A random number",
        "A database primary key",
        "A CSS class name"
    ]
},
{
    "q": "Can `useId` be used for list keys?",
    "type": "mcq",
    "o": [
        "No, keys should be generated from data",
        "Yes, it is recommended",
        "Yes, if the list is static",
        "Only for tables"
    ]
},
{
    "q": "What is the difference between `useCallback(fn, deps)` and `useMemo(() => fn, deps)`?",
    "type": "mcq",
    "o": [
        "They are effectively equivalent for functions",
        "`useCallback` runs the function, `useMemo` doesn't",
        "`useMemo` is for components only",
        "There is no difference"
    ]
},
{
    "q": "Why is `useExternalStore` preferred over `useEffect` for external data?",
    "type": "mcq",
    "o": [
        "It avoids tearing and handles concurrent rendering correctly",
        "It is faster",
        "It allows async rendering",
        "It is easier to write"
    ]
},
{
    "q": "If a custom hook returns `[state, setState]`, `setState` should be...",
    "type": "mcq",
    "o": [
        "stable (referentially equal across renders)",
        "regenerated every time",
        "a promise",
        "null"
    ]
},
{
    "q": "Can you use hooks in a `class` component's render method?",
    "type": "mcq",
    "o": [
        "No, never",
        "Yes, if using a wrapper HOC or render prop",
        "Yes, directly",
        "Only `useContext`"
    ]
},
{
    "q": "How do you test a component that uses `useContext`?",
    "type": "mcq",
    "o": [
        "Wrap the component in the Context Provider with a mocked value",
        "Mock the `useContext` hook",
        "You cannot test it",
        "Use `shallow` rendering"
    ]
},
{
    "q": "What is the typical naming convention for a context provider component?",
    "type": "mcq",
    "o": [
        "MyContext.Provider or MyProvider",
        "useMyContext",
        "provideMyContext",
        "withMyContext"
    ]
},
{
    "q": "In `useReducer`, can the reducer function be defined inline in the hook?",
    "type": "mcq",
    "o": [
        "Yes, but it will be recreated every render (bad for performance if passed down)",
        "No, it must be external",
        "No, it must be memoized",
        "Only if it is anonymous"
    ]
},
{
    "q": "Can `useMemo` return a component?",
    "type": "mcq",
    "o": [
        "Yes, this is useful for optimization",
        "No, only data",
        "No, it returns JSX elements not components",
        "Only in React 16"
    ]
},
{
    "q": "What happens if you accidentally call a hook inside a nested function?",
    "type": "mcq",
    "o": [
        "It violates theRules of Hooks (lint error / runtime bug)",
        "It works if the function is called synchronously",
        "It works if the function is a hook",
        "React fixes it"
    ]
},
{
    "q": "Does `useCallback` prevent the creation of the function object?",
    "type": "mcq",
    "o": [
        "No, it just returns the memoized version",
        "Yes, it stops function creation",
        "Yes, it compiles it away",
        "Only in production"
    ]
},
{
    "q": "To synchronize with an external store, React 18 introduced...",
    "type": "mcq",
    "o": [
        "useSyncExternalStore",
        "useExternalState",
        "useStore",
        "useRedux"
    ]
},
{
    "q": "If `useEffect` returns `undefined` (implicit return), is that valid?",
    "type": "mcq",
    "o": [
        "Yes",
        "No, it must return null",
        "No, it must return a function",
        "No, it must return void"
    ]
},
{
    "q": "Can `useEffect` track changes to `localStorage` automatically?",
    "type": "mcq",
    "o": [
        "No, you need an event listener (like `storage` event)",
        "Yes, it observes the window",
        "Yes, via `useStorage`",
        "Only in the same tab"
    ]
},
{
    "q": "What is a 'thunk' in the context of `useReducer`?",
    "type": "mcq",
    "o": [
        "A pattern where dispatch receives a function to handle async logic (simulated)",
        "A built-in feature",
        "A mistake",
        "A type of action"
    ]
},
{
    "q": "Can you use `useRef` to store a previous prop value?",
    "type": "mcq",
    "o": [
        "Yes",
        "No",
        "Only if prop is numeric",
        "Only if prop is stable"
    ]
},
{
    "q": "If you have a customized `useInput` hook, it typically returns...",
    "type": "mcq",
    "o": [
        "`{ value, onChange, ... }` bindings",
        "Just the value",
        "Just the setter",
        "The DOM node"
    ]
},
{
    "q": "Why avoid putting everything in `useEffect` dependency array blindly?",
    "type": "mcq",
    "o": [
        "It controls *when* the effect runs; unnecessary deps cause unnecessary runs",
        "It causes syntax errors",
        "It creates circular refs",
        "It is deprecated"
    ]
},
{
    "q": "Is `useCallback` guaranteed to never discard the memoized function?",
    "type": "mcq",
    "o": [
        "React may discard the cache to free memory (though rare currently)",
        "Yes, it is permanent",
        "Yes, until unmount",
        "No, it resets every render"
    ]
},
{
    "q": "What is the impact of strict mode on `useEffect` in development?",
    "type": "mcq",
    "o": [
        "It mounts, unmounts, and mounts again (effect runs twice)",
        "It disables the effect",
        "It warns about dependencies",
        "It runs effect synchronously"
    ]
},
{
    "q": "Why does React 18 Strict Mode double-invoke effects?",
    "type": "mcq",
    "o": [
        "To ensure effects are resilient to mounting/unmounting (idempotent)",
        "To test performance",
        "It is a bug",
        "To clear cache"
    ]
},
{
    "q": "Can you use `hooks` in a loop if the loop has a fixed number of iterations?",
    "type": "mcq",
    "o": [
        "No, it still violates the Rules of Hooks (static analysis can't prove it)",
        "Yes, if standard loop",
        "Yes, if unrolled",
        "Yes, if array is constant"
    ]
},
{
    "q": "If `useReducer` returns the *exact same* state object reference...",
    "type": "mcq",
    "o": [
        "React will not re-render the component",
        "React re-renders anyway",
        "React throws error",
        "It triggers `useEffect`"
    ]
},
{
    "q": "How do you fix a missing dependency warning for a function?",
    "type": "mcq",
    "o": [
        "Wrap the function in `useCallback` or move it inside the effect",
        "Disable the warning",
        "Move it to Redux",
        "Make it a class method"
    ]
},
{
    "q": "What is the correct way to type `useRef` that holds a DOM element in TypeScript?",
    "type": "mcq",
    "o": [
        "`useRef<HTMLDivElement>(null)`",
        "`useRef(document.div)`",
        "`useRef<Element>()`",
        "`useRef(null)`"
    ]
},
{
    "q": "Can you use `useContext` to pass a ref?",
    "type": "mcq",
    "o": [
        "Yes",
        "No, refs are not serializable",
        "No, refs break context",
        "Only callback refs"
    ]
},
{
    "q": "What is the primary benefit of `useDeferredValue`?",
    "type": "mcq",
    "o": [
        "Keeping the UI responsive by deprioritizing parts of the tree",
        "Fetching data later",
        "Delaying function execution",
        "Creating timers"
    ]
},
{
    "q": "Is `useTransition` synchronous or asynchronous?",
    "type": "mcq",
    "o": [
        "It schedules updates concurrently (asynchronous-like behavior)",
        "Synchronous",
        "Promise-based",
        "Generator-based"
    ]
},
{
    "q": "If `useEffect` modifies the DOM, you might see a flicker. How to fix?",
    "type": "mcq",
    "o": [
        "Use `useLayoutEffect`",
        "Use `useMemo`",
        "Use `requestAnimationFrame`",
        "Use `setTimeout`"
    ]
},
{
    "q": "When implementing `useFetch`, how do you prevent setting state on unmount?",
    "type": "mcq",
    "o": [
        "Use a cleanup function that sets a flag (e.g. `isActive = false`)",
        "Check `this.mounted`",
        "Use `try/catch`",
        "You cannot prevent it"
    ]
},
{
    "q": "What hook allows you to integrate with React DevTools profiler?",
    "type": "mcq",
    "o": [
        "There is no specific hook, use `<Profiler>` component or `useDebugValue` for labels",
        "useProfiler",
        "usePerformance",
        "useTrace"
    ]
},
{
    "q": "Can a custom hook return a `Promise`?",
    "type": "mcq",
    "o": [
        "Typically no, hooks return values, not promises (unless using Suspense integration)",
        "Yes, standard practice",
        "Yes, for async components",
        "No, it crashes React"
    ]
},
{
    "q": "Why is `useReducer` often used with `useContext`?",
    "type": "mcq",
    "o": [
        "To provide a global state management solution without external libraries",
        "Because `useState` doesn't work with Context",
        "To speed up rendering",
        "To use classes"
    ]
},
{
    "q": "If a context provider re-renders, do all consumers re-render?",
    "type": "mcq",
    "o": [
        "Yes, unless they are optimized or the value hasn't changed",
        "No, only if they use the value",
        "No, context handles this",
        "Yes, always"
    ]
},
{
    "q": "Does `React.memo` work with `useContext`?",
    "type": "mcq",
    "o": [
        "It prevents re-renders from props, but NOT from context changes",
        "Yes, it blocks context updates",
        "No, they are incompatible",
        "It caches the context"
    ]
},
{
    "q": "How do you perform 'constructor' logic in functional components?",
    "type": "mcq",
    "o": [
        "Use `useMemo` (runs during render) or `useRef` with lazy init",
        "Use `useEffect`",
        "Use `constructor` function",
        "Use `init` hook"
    ]
},
{
    "q": "What is the `init` function in `useReducer` signature?",
    "type": "mcq",
    "o": [
        "(initialArg) => initialState",
        "() => initialState",
        "(state) => newState",
        "(dispatch) => void"
    ]
},
{
    "q": "Can you toggle the rules of hooks off?",
    "type": "mcq",
    "o": [
        "No, they are fundamental to how React works",
        "Yes, in config",
        "Yes, with a directive",
        "Only in strict mode"
    ]
},
{
    "q": "What is the `useEffect` cleanup function return type?",
    "type": "mcq",
    "o": [
        "void or undefined",
        "Promise",
        "Boolean",
        "Object"
    ]
},
{
    "q": "If `useCallback` dependency array is empty, the function...",
    "type": "mcq",
    "o": [
        "is created once and reused forever",
        "recreated every render",
        "throws error",
        "never runs"
    ]
},
{
    "q": "What is the best hook to encapsulate complex validation logic?",
    "type": "mcq",
    "o": [
        "A custom hook `useValidation` using `useState`/`useEffect`",
        "useReducer",
        "useMemo",
        "useContext"
    ]
}
,
{
    "q": "What is the difference between `useMemo(() => x, [x])` and `useMemo(() => x, [])` where x is a variable?",
    "type": "mcq",
    "o": [
        "The first updates when x changes, the second captures the initial value of x forever (stale closure)",
        "They are identical",
        "The first one is invalid",
        "The second one throws error"
    ]
},
{
    "q": "Why shouldn't you write `const MyComponent = () => { const [x, setX] = useState(0); ... }` inside `useEffect`?",
    "type": "mcq",
    "o": [
        "Hooks cannot be defined inside other hooks or functions (Rules of Hooks)",
        "It works efficiently",
        "It creates a closure",
        "It is a valid pattern"
    ]
},
{
    "q": "If `useReducer` returns a state object, and you destructure it in the return statement `return <p>{state.count}</p>`, does the component re-render if another property `state.text` changes?",
    "type": "mcq",
    "o": [
        "Yes, the component re-renders whenever the `state` object changes reference",
        "No, only if used properties change",
        "No, React scans JSX usage",
        "Only if wrapped in memo"
    ]
},
{
    "q": "Can you use `useEffect` to implement `getDerivedStateFromError`?",
    "type": "mcq",
    "o": [
        "No, error boundaries must be Class components",
        "Yes, using `useError`",
        "Yes, in cleanup",
        "Yes, with try/catch"
    ]
},
{
    "q": "When using `useContext`, if the context value is an object `{ a, b }` and `a` changes, will a component consuming only `b` re-render?",
    "type": "mcq",
    "o": [
        "Yes, because the context object reference changes",
        "No, React tracks usage",
        "Only if `b` also changes",
        "No, context is granular"
    ]
},
{
    "q": "How can you prevent the issue described in the previous question?",
    "type": "mcq",
    "o": [
        "Split the context into `ContextA` and `ContextB`, or use selectors (via libraries)",
        "Use `React.memo` on the provider",
        "Use `useCallback` on consumers",
        "It is unavoidable"
    ]
},
{
    "q": "StartTransition (from `useTransition`) wraps...",
    "type": "mcq",
    "o": [
        "state updates",
        "effects",
        "render methods",
        "API calls"
    ]
},
{
    "q": "If you have a `useEffect` that updates state, and that state update triggers the same `useEffect`...",
    "type": "mcq",
    "o": [
        "Infinite loop",
        "React stops it",
        "It runs twice",
        "It works fine"
    ]
},
{
    "q": "What is the 'Compound Component' pattern often implemented with?",
    "type": "mcq",
    "o": [
        "Context API (passing state between parent and children implicitly)",
        "Redux",
        "Ref forwarding only",
        "Global events"
    ]
},
{
    "q": "Can `useLayoutEffect` cause visual blocking?",
    "type": "mcq",
    "o": [
        "Yes, browsers cannot paint until it finishes",
        "No, it is async",
        "Only in Firefox",
        "Only if it fails"
    ]
},
{
    "q": "If you use `useDebugValue(date, date => date.toDateString())`...",
    "type": "mcq",
    "o": [
        "The formatting function runs only when DevTools are open",
        "It runs every render",
        "It runs on mount",
        "It formats the data for the UI"
    ]
},
{
    "q": "What is 'tearing' in React concurrent rendering?",
    "type": "mcq",
    "o": [
        "UI showing inconsistent states because of interruptions during render",
        "CSS breaking",
        "Components unmounting unexpectedly",
        "Memory leaks"
    ]
},
{
    "q": "Which hook helps prevent tearing when reading from external mutable sources?",
    "type": "mcq",
    "o": [
        "useSyncExternalStore",
        "useEffect",
        "useMutable",
        "useRef"
    ]
},
{
    "q": "If `useEffect` dependency array is `[prop.someFunction]`, and the parent creates that function every render...",
    "type": "mcq",
    "o": [
        "The effect runs every render",
        "The effect runs once",
        "The effect errors",
        "React optimizes it"
    ]
},
{
    "q": "How to fix the issue in the previous question?",
    "type": "mcq",
    "o": [
        "Wrap the function in `useCallback` in the parent",
        "Remove it from dependency array",
        "Use `useMemo` in child",
        "Ignore it"
    ]
},
{
    "q": "What is 'batched updates' in React 18?",
    "type": "mcq",
    "o": [
        "Multiple state updates (even in promises/timeouts) trigger a single re-render",
        "Updates are delayed until idle",
        "Updates are disabled",
        "Batching is removed"
    ]
},
{
    "q": "How do you opt-out of automatic batching in React 18?",
    "type": "mcq",
    "o": [
        "flushSync(() => ...)",
        "noBatch(() => ...)",
        "syncUpdate(() => ...)",
        "using `useLayoutEffect`"
    ]
},
{
    "q": "If you use `useReducer` with a fast-changing action stream, what might happen?",
    "type": "mcq",
    "o": [
        "React batches them, but too many might cause lag",
        "The reducer queue overflows",
        "State gets lost",
        "It switches to synchronous mode"
    ]
},
{
    "q": "Can you use `useEffect` to manage focus management?",
    "type": "mcq",
    "o": [
        "Yes, accessing refs in the effect",
        "No, focus is automatic",
        "Only with `useFocus`",
        "Only in class components"
    ]
},
{
    "q": "If `useContext` is used in a component that renders a heavy list...",
    "type": "mcq",
    "o": [
        "The list re-renders whenever context changes (bad performance)",
        "The list is unaffected",
        "The list unmounts",
        "React crashes"
    ]
},
{
    "q": "How do you memoize a component that uses `useContext`?",
    "type": "mcq",
    "o": [
        "`React.memo` won't stop context updates; you must assume it re-renders or split the component",
        "Use `React.memo` and it works",
        "Use `shouldComponentUpdate`",
        "Use `useMemo` on the component"
    ]
},
{
    "q": "What is the 'render-as-you-fetch' pattern enabled by Suspense?",
    "type": "mcq",
    "o": [
        "Starting fetch early and rendering immediately, suspending if data isn't ready",
        "Fetching in `useEffect`",
        "Fetching in `componentDidMount`",
        "Fetching on button click"
    ]
},
{
    "q": "Which hook is critical for suppressing hydration mismatches?",
    "type": "mcq",
    "o": [
        "useId (ensures stable IDs)",
        "useEffect",
        "useLayoutEffect",
        "useState"
    ]
},
{
    "q": "Is `useImperativeHandle` generally discouraged?",
    "type": "mcq",
    "o": [
        "Yes, it breaks declarative flow; use only when necessary",
        "No, it is recommended",
        "Only for beginners",
        "It is default"
    ]
},
{
    "q": "If a custom hook returns functions, should they be wrapped in `useCallback`?",
    "type": "mcq",
    "o": [
        "Yes, to allow consumers to use them in dependency arrays without loops",
        "No, it's waste of memory",
        "Only if async",
        "Only if they use state"
    ]
},
{
    "q": "Can `useEffect` return a Promise?",
    "type": "mcq",
    "o": [
        "No",
        "Yes",
        "In React Native only",
        "In concurrent mode only"
    ]
},
{
    "q": "If you want to measure the DOM node size, which hook combinator is best?",
    "type": "mcq",
    "o": [
        "useCallback ref (ref callback) or useLayoutEffect",
        "useEffect",
        "useMemo",
        "useState"
    ]
},
{
    "q": "Why is `useRef` often called an 'escape hatch'?",
    "type": "mcq",
    "o": [
        "You stepping out of the declarative React flow to mutate variables/DOM directly",
        "It escapes the component tree",
        "It handles errors",
        "It escapes strict mode"
    ]
},
{
    "q": "Does `useContext` allow 'bailing out' similar to `useSelector` in Redux?",
    "type": "mcq",
    "o": [
        "No, context consumers always re-render on provider update (unless context splitting used)",
        "Yes, via selector argument",
        "Yes, automatically",
        "Only in React 17"
    ]
},
{
    "q": "If `useReducer` has side effects in the reducer function...",
    "type": "mcq",
    "o": [
        "It is an anti-pattern; reducers must be pure",
        "It works fine",
        "It is standard practice",
        "It boosts performance"
    ]
},
{
    "q": "When is the `initialArg` of `useReducer` ignored?",
    "type": "mcq",
    "o": [
        "Never",
        "If `init` function is provided, `initialArg` is passed to `init`",
        "If state is null",
        "If dispatch is called"
    ]
},
{
    "q": "Can `useMemo` be used for side effects?",
    "type": "mcq",
    "o": [
        "No, the function runs during render where side effects are forbidden",
        "Yes",
        "Only logging",
        "Only data fetching"
    ]
},
{
    "q": "If you use `useEffect` to sync props to state...",
    "type": "mcq",
    "o": [
        "You might be duplicating sources of truth (anti-pattern)",
        "It is the best way",
        "It is required",
        "It is faster than deriving state"
    ]
},
{
    "q": "What happens if a Hook is conditional?",
    "type": "mcq",
    "o": [
        "React's internal list of hooks gets misaligned -> data corruption/error",
        "It works conditionally",
        "It skips the hook",
        "React warns but proceeds"
    ]
},
{
    "q": "Is `useLayoutEffect` preferred for tooltips positioning?",
    "type": "mcq",
    "o": [
        "Yes, to prevent visual jumping (computation before paint)",
        "No, `useEffect` is fine",
        "No, use CSS",
        "No, use `useTooltip`"
    ]
},
{
    "q": "Can `useContext` values be functions?",
    "type": "mcq",
    "o": [
        "Yes, often used for providing methods/handlers",
        "No, only data",
        "No, functions are not serializable",
        "Only reducers"
    ]
},
{
    "q": "If you see a warning about a memory leak in `useEffect`, it means...",
    "type": "mcq",
    "o": [
        "You tried to update state on an unmounted component (e.g. async fetch finished late)",
        "You used too much memory",
        "You forgot to close a file",
        "Your component is too large"
    ]
},
{
    "q": "Which hook can best replace `componentDidUpdate` logic?",
    "type": "mcq",
    "o": [
        "useEffect pattern with ref to skip first run",
        "useUpdate",
        "useLayoutEffect",
        "useMemo"
    ]
},
{
    "q": "In `useReducer`, how do you handle multiple actions needing the same logic?",
    "type": "mcq",
    "o": [
        "Fallthrough in switch statement or shared helper functions",
        "You duplicate code",
        "You cannot",
        "Use inheritance"
    ]
},
{
    "q": "What is the key difference between `useRef` and `createRef` in functional components?",
    "type": "mcq",
    "o": [
        "`useRef` persists the object across renders; `createRef` creates a new one every render",
        "They are the same",
        "`createRef` is for hooks",
        "`useRef` is deprecated"
    ]
},
{
    "q": "If `useEffect` depends on `Date.now()`, what happens?",
    "type": "mcq",
    "o": [
        "It runs every render if passed inline, or never if used inside",
        "It runs every second",
        "It crashes",
        "It works as a timer"
    ]
},
{
    "q": "How do you implement 'getDerivedStateFromProps' with hooks?",
    "type": "mcq",
    "o": [
        "Update state during render (if condition met) - rare pattern",
        "Use `useEffect`",
        "Use `useLayoutEffect`",
        "Use `useDerivedState`"
    ]
},
{
    "q": "What does `useEffect` return?",
    "type": "mcq",
    "o": [
        "Cleanup function or undefined",
        "Nothing",
        "The effect's result",
        "Promise"
    ]
},
{
    "q": "Can custom hooks be reused between projects?",
    "type": "mcq",
    "o": [
        "Yes, they are just functions",
        "No, they are tied to project",
        "Only if published to npm",
        "Only if they use standard hooks"
    ]
},
{
    "q": "If `useContext` returns `undefined`, what is the likely cause?",
    "type": "mcq",
    "o": [
        "Component is not wrapped in the Provider (and no default value set)",
        "Context is empty",
        "Wrong hook used",
        "React bug"
    ]
},
{
    "q": "When using `useReducer`, what is the best practice for the action object structure?",
    "type": "mcq",
    "o": [
        "Standard Flux/Redux pattern: `{ type: 'ACTION_NAME', payload: ... }`",
        "Just a string",
        "Just the payload",
        "An array"
    ]
},
{
    "q": "If you need a globally unique ID for a form field label and input, use...",
    "type": "mcq",
    "o": [
        "useId",
        "useRef",
        "Math.random()",
        "Date.now()"
    ]
},
{
    "q": "Can `useEffect` operate on the DOM directly?",
    "type": "mcq",
    "o": [
        "Yes, using refs or querySelector",
        "No, virtual DOM prevents it",
        "No, forbidden",
        "Only in layout effects"
    ]
},
{
    "q": "Why is `useMemo` not a semantic guarantee?",
    "type": "mcq",
    "o": [
        "React may discard the cache to free memory; code should work even without it",
        "It is always guaranteed",
        "It only works in production",
        "It is a hint only"
    ]
},
{
    "q": "What hook handles 'subscription' logic best?",
    "type": "mcq",
    "o": [
        "useEffect",
        "useMemo",
        "useState",
        "useReducer"
    ]
}
,
{
    "q": "What is the 'Rule of Hooks' regarding conditional execution?",
    "type": "mcq",
    "o": [
        "Don't call Hooks inside loops, conditions, or nested functions",
        "You can call them if the condition is constant",
        "Only `useEffect` can be conditional",
        "There is no such rule"
    ]
},
{
    "q": "If `useEffect` is triggered by a state change, and it sets the *same* state again...",
    "type": "mcq",
    "o": [
        "React bails out if the value is identical (optimization)",
        "Infinite loop",
        "It renders twice",
        "It throws error"
    ]
},
{
    "q": "What hook would you use to implement 'undo/redo' functionality?",
    "type": "mcq",
    "o": [
        "useReducer (manage history state)",
        "useEffect",
        "useUndo",
        "useMemo"
    ]
},
{
    "q": "When using `useContext` with High Order Components (HOCs), what is a common pattern?",
    "type": "mcq",
    "o": [
        "Creating a `withContext` HOC that passes context as props",
        "Using useContext inside the HOC",
        "Replacing context with props",
        "Using Redux"
    ]
},
{
    "q": "If you have a `useEffect` that listens for clicks outside a component (click-away listener)...",
    "type": "mcq",
    "o": [
        "You attach listener to `document` in effect and remove in cleanup",
        "You use `onClick` on body",
        "You use `useClickAway` hook",
        "You use `onBlur`"
    ]
},
{
    "q": "What is the correct way to type `useReducer` state in TypeScript?",
    "type": "mcq",
    "o": [
        "Define state interface and action types (discriminated union)",
        "Use `any`",
        "Use `string`",
        "React types it automatically"
    ]
},
{
    "q": "Can you use `hooks` in `Class` components via inheritance?",
    "type": "mcq",
    "o": [
        "No, classes cannot use hooks",
        "Yes",
        "Only if you extend `React.HookComponent`",
        "Only in mixins"
    ]
},
{
    "q": "What is the `useCallback` hook syntactic sugar for?",
    "type": "mcq",
    "o": [
        "`useMemo(() => fn, deps)`",
        "`useEffect(() => fn, deps)`",
        "`useRef(fn)`",
        "`useState(fn)`"
    ]
},
{
    "q": "If you use `React.useContext` in a loop to access multiple contexts...",
    "type": "mcq",
    "o": [
        "It violates Rules of Hooks (loop)",
        "It works fine",
        "It combines them",
        "It is optimized"
    ]
},
{
    "q": "Can `useLayoutEffect` run on the server?",
    "type": "mcq",
    "o": [
        "No, and it warns about useLayoutEffect does nothing on the server",
        "Yes",
        "Yes, if configured",
        "Only in Next.js"
    ]
},
{
    "q": "How do you quiet the 'useLayoutEffect does nothing on the server' warning?",
    "type": "mcq",
    "o": [
        "Use `useEffect` or a conditional hook (useIsomorphicLayoutEffect)",
        "Disable SSR",
        "Ignore it",
        "Use `React.lazy`"
    ]
},
{
    "q": "What effect does `React.StrictMode` have on `useReducer`?",
    "type": "mcq",
    "o": [
        "It may call the reducer twice to detect impurities",
        "It disables the reducer",
        "It enforces types",
        "It logs actions"
    ]
},
{
    "q": "If you want to focus an input on mount, you use...",
    "type": "mcq",
    "o": [
        "`useEffect` with `[]` deps and a `ref`",
        "`autofocus` attribute",
        "`useFocus`",
        "`componentDidMount`"
    ]
},
{
    "q": "Typical use case for `useImperativeHandle` is...",
    "type": "mcq",
    "o": [
        "Allowing parent to focus a child's input or trigger animation",
        "Passing state up",
        "Routing",
        "Data fetching"
    ]
},
{
    "q": "Does `useContext` support selectors natively in React 18?",
    "type": "mcq",
    "o": [
        "No (usually requires `useFromStore` or 3rd party like Redux)",
        "Yes, `useContext(Context, selector)`",
        "Yes, via `useSelector`",
        "Yes, via `Context.select`"
    ]
},
{
    "q": "If a custom hook maintains a WebSocket connection...",
    "type": "mcq",
    "o": [
        "It should close it in `useEffect` cleanup",
        "It should keep it open forever",
        "It should rely on garbage collection",
        "It resets on render"
    ]
},
{
    "q": "Can `useState` initialize with a function `useState(() => heavy())`?",
    "type": "mcq",
    "o": [
        "Yes, this is lazy initialization",
        "No, it stores the function as state",
        "No, only usage in `useEffect`",
        "Only in `useReducer`"
    ]
},
{
    "q": "Why use lazy initialization in `useState`?",
    "type": "mcq",
    "o": [
        "To avoid running expensive calculation on every render",
        "To support async state",
        "To delay mounting",
        "To use promises"
    ]
},
{
    "q": "If `useEffect` tries to update a component that is unmounting...",
    "type": "mcq",
    "o": [
        "React warns about memory leak (in older versions) or ignores it",
        "It crashes",
        "It prevents unmount",
        "It retries"
    ]
},
{
    "q": "What is `useSyncExternalStore` primarily for?",
    "type": "mcq",
    "o": [
        "Subscribing to external data sources (stores) compatibly with concurrent features",
        "Syncing local storage",
        "Syncing props",
        "Fetching data"
    ]
},
{
    "q": "In `useReducer`, is the dispatch function synchronous?",
    "type": "mcq",
    "o": [
        "State updates are scheduled (async-like behavior regarding render), but dispatch call itself returns immediately",
        "Yes, it updates DOM synchronously",
        "No, it returns a promise",
        "It blocks execution"
    ]
},
{
    "q": "If you pass an inline function to `useEffect` deps `[() => {}]`, what happens?",
    "type": "mcq",
    "o": [
        "It changes every render, causing effect to run every time",
        "It is stable",
        "React ignores functions",
        "It works fine"
    ]
},
{
    "q": "Can `useId` be used for CSS selectors?",
    "type": "mcq",
    "o": [
        "Not recommended (it contains colons which need escaping)",
        "Yes, easily",
        "Yes, it is just a string",
        "No, it returns number"
    ]
},
{
    "q": "What is the key benefit of Hooks over HOCs?",
    "type": "mcq",
    "o": [
        "No 'wrapper hell' (cleaner component tree)",
        "Faster performance",
        "Hooks are classes",
        "Hooks support inheritance"
    ]
},
{
    "q": "Can you call `useEffect` inside a `useMemo` callback?",
    "type": "mcq",
    "o": [
        "No, that's a hook inside a loop/condition/nested function violation",
        "Yes",
        "Only if memo is empty",
        "Only in production"
    ]
},
{
    "q": "If you need to share logic that uses lifecycle methods, you convert to...",
    "type": "mcq",
    "o": [
        "Custom hooks using `useEffect`",
        "Classes",
        "Mixins",
        "HOCs"
    ]
},
{
    "q": "Does `useCallback` work if the function relies on state?",
    "type": "mcq",
    "o": [
        "Yes, but you must include state in dependencies",
        "No, it creates stale closures",
        "No, it cannot see state",
        "Yes, automatically updates"
    ]
},
{
    "q": "What is the 'dependencies' argument in hooks primarily for?",
    "type": "mcq",
    "o": [
        "Optimization (memoization) and consistency (stale closures prevention)",
        "Execution order",
        "Debugging",
        "Type checking"
    ]
},
{
    "q": "If `React.memo` wraps a component, does it prevent `useContext` updates?",
    "type": "mcq",
    "o": [
        "No",
        "Yes",
        "Only if props change",
        "Only if context is static"
    ]
},
{
    "q": "How to force a ref to cause a re-render?",
    "type": "mcq",
    "o": [
        "You can't; refs don't trigger updates. Use state instead.",
        "Call `ref.update()`",
        "Assign `ref.current = null`",
        "Use `useReactiveRef`"
    ]
},
{
    "q": "If `useEffect` runs twice in Strict Mode, is the cleanup function called?",
    "type": "mcq",
    "o": [
        "Yes, cycle is: mount -> unmount (cleanup) -> mount",
        "No",
        "Only on refresh",
        "Only on error"
    ]
},
{
    "q": "Is `useContext` suitable for high-frequency updates (e.g. animation)?",
    "type": "mcq",
    "o": [
        "Usually no, due to re-render overhead. Use refs or specialized libs.",
        "Yes, it is very fast",
        "Yes, React handles it",
        "Only with `useLayoutEffect`"
    ]
},
{
    "q": "Can `useReducer` be used to manipulate DOM?",
    "type": "mcq",
    "o": [
        "Indirectly via state, but not directly inside reducer (must be pure)",
        "Yes, inside reducer",
        "Yes, using refs",
        "No"
    ]
},
{
    "q": "What is the recommended way to fetch data with a race condition check?",
    "type": "mcq",
    "o": [
        "Boolean flag in effect cleanup closure",
        "AbortController",
        "Either of the above",
        "None, race conditions don't happen in React"
    ]
},
{
    "q": "If `useMemo` calculation is cheap, should you use it?",
    "type": "mcq",
    "o": [
        "No, the overhead of useMemo might exceed the savings",
        "Yes, always memoize",
        "Yes, for code style",
        "It doesn't matter"
    ]
},
{
    "q": "When implementing a 'useInterval', why use a ref for the callback?",
    "type": "mcq",
    "o": [
        "To always access the latest callback without restarting the interval timer",
        "To duplicate the callback",
        "To prevent execution",
        "To make it async"
    ]
},
{
    "q": "What does `useDeferredValue` return during the lag?",
    "type": "mcq",
    "o": [
        "The old value",
        "null",
        "undefined",
        "Loading state"
    ]
},
{
    "q": "Can you use `useEffect` to implement `componentDidCatch`?",
    "type": "mcq",
    "o": [
        "No, hooks don't support error boundaries yet",
        "Yes",
        "Yes, `useError`",
        "Yes, in cleanup"
    ]
},
{
    "q": "If `useDebugValue` is slow to calculate, how to optimize?",
    "type": "mcq",
    "o": [
        "Pass a formatting function as the second argument",
        "Use `useMemo`",
        "Disable it",
        "Use `useEffect`"
    ]
},
{
    "q": "Is `useTransition` available in React 17?",
    "type": "mcq",
    "o": [
        "No, it is a React 18 feature",
        "Yes",
        "Polyfilled",
        "Experimental"
    ]
},
{
    "q": "What hook allows inserting a style tag into the head?",
    "type": "mcq",
    "o": [
        "useInsertionEffect",
        "useEffect",
        "useLayoutEffect",
        "useStyle"
    ]
},
{
    "q": "Can `useReducer` action hold a payload?",
    "type": "mcq",
    "o": [
        "Yes, it is a standard pattern",
        "No",
        "Only strings",
        "Only numbers"
    ]
},
{
    "q": "If `useEffect` returns a standard value (not function/undefined)...",
    "type": "mcq",
    "o": [
        "React logs a warning because it expects a cleanup function or nothing",
        "It ignores it",
        "It crashes",
        "It uses it as state"
    ]
},
{
    "q": "What is the relationship between `useState` and `useReducer`?",
    "type": "mcq",
    "o": [
        "`useState` is built using `useReducer` internally",
        "`useReducer` uses `useState`",
        "They are unrelated",
        "`useState` is legacy"
    ]
},
{
    "q": "If you want to isolate a heavy component from re-rendering when parent state changes...",
    "type": "mcq",
    "o": [
        "Wrap it in `React.memo`",
        "Use `useMemo`",
        "Use `useEffect`",
        "Use `useCallback`"
    ]
},
{
    "q": "Does `useCallback` run during render?",
    "type": "mcq",
    "o": [
        "Yes, to return the memoized function",
        "No",
        "After render",
        "Before render"
    ]
},
{
    "q": "Can `useContext` be used to replace global stores like Redux?",
    "type": "mcq",
    "o": [
        "For low-frequency updates yes, but performance may suffer for high-frequency",
        "No",
        "Yes, always better",
        "Yes, effectively same performance"
    ]
},
{
    "q": "What is the rule about the *order* of hooks?",
    "type": "mcq",
    "o": [
        "Hooks must be called in the exact same order on every render",
        "Order doesn't matter",
        "Depends on names",
        "Depends on arguments"
    ]
},
{
    "q": "Can you define a hook inside a loop if the loop size is constant?",
    "type": "mcq",
    "o": [
        "No, React doesn't know the loop size is constant (rule violation)",
        "Yes",
        "Yes, with warning",
        "Only `useEffect`"
    ]
},
{
    "q": "If you use `useReducer`, how do you access the current state outside the component?",
    "type": "mcq",
    "o": [
        "You cannot directly; state is local. Pass it up or use Context/Global Store.",
        "Use `window.state`",
        "Use `getReducer`",
        "Import it"
    ]
}
,
{
    "q": "How does React internally store hooks for a functional component?",
    "type": "mcq",
    "o": [
        "As a linked list attached to the fiber node",
        "As an array",
        "As a hash map",
        "As a binary tree"
    ]
},
{
    "q": "What happens if a hook is removed in a subsequent render?",
    "type": "mcq",
    "o": [
        "React throws an error because the hook order must remain static",
        "React skips it",
        "React cleans it up",
        "React re-indexes the list"
    ]
},
{
    "q": "What is the 'dispatcher' in React's internal hooks implementation?",
    "type": "mcq",
    "o": [
        "The object that holds the current implementation of hooks (e.g., hooks for mount vs update)",
        "The Redux store",
        "The event loop",
        "The scheduler"
    ]
},
{
    "q": "When does React switch the dispatcher from 'mount' to 'update'?",
    "type": "mcq",
    "o": [
        "After the first render commit phase",
        "Before the first render",
        "During reconciliation",
        "On button click"
    ]
},
{
    "q": "Why can't you statically analyze hooks usage perfectly?",
    "type": "mcq",
    "o": [
        "JavaScript is dynamic and hooks are regular functions, making static analysis of control flow hard",
        "Hooks are async",
        "Hooks are compiled",
        "Hooks have no types"
    ]
},
{
    "q": "If you access `ref.current` during the `render` phase (not effect/event)...",
    "type": "mcq",
    "o": [
        "It is unsafe (reading during mutation/render interleaving in concurrent mode)",
        "It is recommended",
        "It works 100% of time",
        "It allows time travel"
    ]
},
{
    "q": "How does `useReducer` implement performance bail-out?",
    "type": "mcq",
    "o": [
        "By comparing the new state with the old state using `Object.is` before scheduling update",
        "Using `shouldComponentUpdate`",
        "It doesn't",
        "By using JSON comparison"
    ]
},
{
    "q": "What is the 'passive effect' in React internals?",
    "type": "mcq",
    "o": [
        "`useEffect` (runs asynchronously after paint)",
        "`useLayoutEffect`",
        "`useState`",
        "Events"
    ]
},
{
    "q": "What is the difference between `hydration` and `render` regarding hooks?",
    "type": "mcq",
    "o": [
        "Hydration re-runs hooks to attach event listeners to existing DOM",
        "Hydration skips hooks",
        "They are the same",
        "Hydration only runs `useEffect`"
    ]
},
{
    "q": "If you throw a Promise in a functional component (Suspense mechanism), what happens to standard hooks?",
    "type": "mcq",
    "o": [
        "The component 'suspends' and unmounts/hides; state is preserved if Suspense config allows, or reset",
        "Hooks are destroyed immediately",
        "Hooks turn into promises",
        "React crashes"
    ]
},
{
    "q": "Can a custom hook detect if it is running on the server?",
    "type": "mcq",
    "o": [
        "Yes, by checking `typeof window === 'undefined'` or similar",
        "No",
        "Yes, using `useServer`",
        "Yes, using `useHydration`"
    ]
},
{
    "q": "What is the issue with using `useMemo` for semantic validity (e.g. running code exactly once)?",
    "type": "mcq",
    "o": [
        "React may purge the cache, running the function again. Use `useRef` + `if` checks for strict 'once' semantics",
        "It is too slow",
        "It is deprecated",
        "It works perfectly"
    ]
},
{
    "q": "In React 18, `useEffect` fires synchronously if...",
    "type": "mcq",
    "o": [
        "It is inside a `flushSync` context, or discrete event updates in some cases? No, `useEffect` is always async/passive except when flushed manually or in specific legacy modes.",
        "The component is huge",
        "The dependency is null",
        "Never, unless `useLayoutEffect`"
    ]
},
{
    "q": "How does `useDeferredValue` implementation relate to time-slicing?",
    "type": "mcq",
    "o": [
        "React yields back to main thread while rendering the deferred value tree",
        "It uses `setTimeout`",
        "It runs in a web worker",
        "It uses promises"
    ]
},
{
    "q": "If you have a `useContext` provider at the very top, and update it often...",
    "type": "mcq",
    "o": [
        "All consumers re-render. If there are many, it kills performance. Optimization: Context splitting or memoized children.",
        "It is the fastest pattern",
        "React blocks updates",
        "Consumers don't re-render"
    ]
},
{
    "q": "What is `act()` in React testing used for?",
    "type": "mcq",
    "o": [
        "To ensure all updates (effects, re-renders) related to a unit of interaction are processed/flushed before asserting",
        "To simulate clicks",
        "To mount components",
        "To mock modules"
    ]
},
{
    "q": "Does `act()` handle Promises?",
    "type": "mcq",
    "o": [
        "Yes, `await act(async () => ...)` allows flushing async effects",
        "No",
        "Only in Jest",
        "Only for timers"
    ]
},
{
    "q": "React `useId` uses what algorithm to generate IDs?",
    "type": "mcq",
    "o": [
        "Tree structure/position based generation (e.g. :R1:, :R1:2)",
        "Random UUID",
        "Sequential integer",
        "Hash of props"
    ]
},
{
    "q": "Can `useEffect` cause 'tearing' in UI?",
    "type": "mcq",
    "o": [
        "Yes, if it updates state based on mutable external data reading without sync",
        "No",
        "Only in StrictMode",
        "Only `useLayoutEffect`"
    ]
},
{
    "q": "Why is `useMutableSource` (experimental) difficult to implement correctly?",
    "type": "mcq",
    "o": [
        "It must handle concurrent reads and versioning to prevent tearing",
        "It requires a database",
        "It is too simple",
        "It conflicts with hooks"
    ]
},
{
    "q": "If `useRef` value is mutated during render...",
    "type": "mcq",
    "o": [
        "It makes the render impure and behavior unpredictable in Concurrent Mode",
        "It works fine",
        "It triggers update",
        "It throws error"
    ]
},
{
    "q": "What is 'Fast Refresh' in React tooling?",
    "type": "mcq",
    "o": [
        "A feature that preserves component state (hooks) while editing files, handling hot reloading smartly",
        "Browser refresh",
        "Webpack plugin",
        "Server restart"
    ]
},
{
    "q": "How does Fast Refresh handle `useEffect`?",
    "type": "mcq",
    "o": [
        "It tries to preserve state but may re-run effects if dependencies or code inside them changed",
        "It ignores effects",
        "It never runs effects",
        "It deletes effects"
    ]
},
{
    "q": "If you use a closure in `useEffect` that captures `props.id`...",
    "type": "mcq",
    "o": [
        "If `props.id` isn't in deps, the closure sees the old `id` forever (stale closure)",
        "It sees the live value",
        "It causes error",
        "It works via proxy"
    ]
},
{
    "q": "Is `useCallback` efficient for every function?",
    "type": "mcq",
    "o": [
        "No, the cost of creating the hook and array array often outweighs creating an inline function, unless passing to memoized child",
        "Yes, always optimize",
        "Yes, improves readability",
        "No, never use it"
    ]
},
{
    "q": "What is the `useLayoutEffect` signature?",
    "type": "mcq",
    "o": [
        "Identical to `useEffect`",
        "Different arguments",
        "Returns a promise",
        "No cleanup"
    ]
},
{
    "q": "In the React Fiber tree, hooks are stored on which property of the fiber?",
    "type": "mcq",
    "o": [
        "memoizedState",
        "state",
        "hooks",
        "props"
    ]
},
{
    "q": "If you update state in a microtask (Promise.resolve().then) in React 17 vs 18...",
    "type": "mcq",
    "o": [
        "React 17: separate renders; React 18: batched into one render",
        "No difference",
        "React 17 batches; 18 separates",
        "Both separate"
    ]
},
{
    "q": "Can `useReducer` be used for 'forcing' a component to update from outside?",
    "type": "mcq",
    "o": [
        "Yes, by exposing the dispatch function (e.g. via Context) and dispatching a dummy action",
        "No",
        "Only with class components",
        "Only for error boundaries"
    ]
},
{
    "q": "What is the primary motivation for hooks?",
    "type": "mcq",
    "o": [
        "Logic reuse (composition) without hierarchy hell",
        "Replacing classes due to `this` confusion",
        "Performance",
        "All of the above"
    ]
},
{
    "q": "If `useEffect` returns a cleanup function, and the component unmounts...",
    "type": "mcq",
    "o": [
        "The cleanup runs",
        "The effect runs",
        "Nothing runs",
        "State is reset"
    ]
},
{
    "q": "If you have a customized `useWhyDidYouUpdate` hook, what does it likely use?",
    "type": "mcq",
    "o": [
        "`useRef` to store previous props and `useEffect` to compare current vs previous",
        "`useState`",
        "`useContext`",
        "`useReducer`"
    ]
},
{
    "q": "Can you use `hooks` in Next.js `getServerSideProps`?",
    "type": "mcq",
    "o": [
        "No, that runs on the server (Node.js) environment, not in React component tree",
        "Yes",
        "Only `useEffect`",
        "Only `useState`"
    ]
},
{
    "q": "What happens if you have a dependency cycle in `useEffect` (A updates B, B updates A)?",
    "type": "mcq",
    "o": [
        "Maximum update depth exceeded error (infinite loop)",
        "React stops it",
        "It works slowly",
        "It hangs the browser"
    ]
},
{
    "q": "How does `useInsertionEffect` differ from `useLayoutEffect`?",
    "type": "mcq",
    "o": [
        "`useInsertionEffect` cannot access refs and is meant for style injection",
        "They are the same",
        "`useInsertionEffect` is slower",
        "`useInsertionEffect` runs after paint"
    ]
},
{
    "q": "If you use `useContext` consumes a context that provides a mutable object...",
    "type": "mcq",
    "o": [
        "Changes to properties of that object won't trigger update unless the object reference changes",
        "It triggers update on any property change",
        "It throws error",
        "It works via Proxy"
    ]
},
{
    "q": "What is the 'zombie child' problem in Redux/hooks?",
    "type": "mcq",
    "o": [
        "A child component reads data from store that was removed by a parent action before the child updated",
        "A component that doesn't unmount",
        "A memory leak",
        "A loop"
    ]
},
{
    "q": "Does `useSelector` (Redux) use `useContext` internally?",
    "type": "mcq",
    "o": [
        "Yes, to access the store instance, but `useSyncExternalStore` (or subscription) for state updates",
        "No",
        "Yes, exclusively",
        "It uses `useState`"
    ]
},
{
    "q": "If `useEffect` is used for data fetching, how do you handle strict mode double-invocation?",
    "type": "mcq",
    "o": [
        "Ensure the effect is idempotent or use a cleanup function to ignore the result of the first call",
        "Disable strict mode",
        "Use `useRef`",
        "Cache the data"
    ]
},
{
    "q": "Can you access the 'owner' of a component via hooks?",
    "type": "mcq",
    "o": [
        "No, React internals abstract this away",
        "Yes, `useOwner`",
        "Yes, `useParent`",
        "Yes, `this.owner`"
    ]
},
{
    "q": "If you need to implement a 'singleton' hook (state shared across all usages)...",
    "type": "mcq",
    "o": [
        "You must use an external store or Context; a custom hook alone creates local state per usage",
        "It is automatic",
        "Use `static` keyword",
        "Use `global`"
    ]
},
{
    "q": "What is the result of `useState(() => 5)` vs `useState(5)`?",
    "type": "mcq",
    "o": [
        "Same initial state (5), but function version avoids passing 5 every render (pointless for 5, useful for expensive logic)",
        "Different states",
        "Function version is read-only",
        "Literal version is read-only"
    ]
},
{
    "q": "Can you use `useEffect` to override props?",
    "type": "mcq",
    "o": [
        "No, props are read-only. You can copy to state and update state.",
        "Yes, `props.x = 1`",
        "Yes, via `setProps`",
        "Yes, via `useProps`"
    ]
},
{
    "q": "If you use `React.memo` with a custom comparison function, what hook helps pass stable props?",
    "type": "mcq",
    "o": [
        "useMemo / useCallback",
        "useEffect",
        "useState",
        "useRef"
    ]
},
{
    "q": "In `useReducer`, is the `state` argument in reducer a snapshot or live?",
    "type": "mcq",
    "o": [
        "Snapshot (value at the time of execution)",
        "Live reference",
        "Mutable object",
        "Proxy"
    ]
},
{
    "q": "Can `useEffect` take an async function `async () => {}`?",
    "type": "mcq",
    "o": [
        "No, because it returns a Promise which messes up the cleanup function expectation",
        "Yes",
        "Yes, in React 18",
        "Only in Next.js"
    ]
},
{
    "q": "How to fix the async useEffect issue?",
    "type": "mcq",
    "o": [
        "Define an async function *inside* the effect and call it",
        "Use `useLayoutEffect`",
        "Use `useAsync`",
        "Return the promise"
    ]
},
{
    "q": "What determines if `useLayoutEffect` fires?",
    "type": "mcq",
    "o": [
        "DOM mutations",
        "State changes",
        "Browser idle",
        "User click"
    ]
},
{
    "q": "Is `useDebugValue` stripped in production?",
    "type": "mcq",
    "o": [
        "Ideally yes, or it does nothing; tooling usually handles this",
        "No, it runs always",
        "No, it errors",
        "Yes, it is dev-only"
    ]
},
{
    "q": "If `useCallback` depends on `[a, b]`, and `a` changes...",
    "type": "mcq",
    "o": [
        "A new function reference is created",
        "Old function is returned",
        "Function is deleted",
        "Error occurs"
    ]
}
,
{
    "q": "What is the 'Stack Reconciliation' vs 'Fiber Reconciliation' regarding hooks?",
    "type": "mcq",
    "o": [
        "Stack was recursive (blocking), Fiber is iterative (interruptible); Hooks rely on Fiber to maintain state across pauses",
        "Stack used hooks, Fiber removed them",
        "They are the same",
        "Fiber is slower"
    ]
},
{
    "q": "If you use `useContext` in a list item, and the list has 1000 items...",
    "type": "mcq",
    "o": [
        "1000 components subscribe; performance hit on update. Use React.memo or split context.",
        "React batches them to 1 update",
        "Only visible items update",
        "It works instantly"
    ]
},
{
    "q": "Can you use `useEffect` to manage a WebSocket that needs to persist across re-renders?",
    "type": "mcq",
    "o": [
        "Yes, create in effect (or useRef) and cleanup in return. Use empty deps if single connection needed.",
        "No",
        "Use `useSocket`",
        "Use `useState`"
    ]
},
{
    "q": "What is the risk of using `useCallback` excessively?",
    "type": "mcq",
    "o": [
        "Memory overhead and complexity without performance gain if children aren't memoized",
        "It breaks the app",
        "It causes infinite loops",
        "It is deprecated"
    ]
},
{
    "q": "Does `useTransition` work with text inputs?",
    "type": "mcq",
    "o": [
        "Yes, but beware of input lag. Usually split state: one for input (urgent), one for results (transition).",
        "No, only for suspense",
        "No, only for buttons",
        "Yes, perfectly"
    ]
},
{
    "q": "In `useReducer`, how do you handle 'thunks' or async logic natively?",
    "type": "mcq",
    "o": [
        "You don't. You dispatch generic actions, and perform async logic *before* dispatching, or use a custom middleware wrapper.",
        "It supports async/await",
        "It supports promises",
        "It has native thunk support"
    ]
},
{
    "q": "What is the purpose of `useImperativeHandle` dependency array?",
    "type": "mcq",
    "o": [
        "Re-creates the handle only when dependencies change",
        "Trigger re-render",
        "Cleanup handle",
        "It has no dependencies"
    ]
},
{
    "q": "If `useEffect` tries to setState on an unmounted component, React 18...",
    "type": "mcq",
    "o": [
        "Removed the warning (it is swallowed as harmless usually), but best practice remains to avoid it",
        "Still warns loudly",
        "Crashes",
        "Retries updates"
    ]
},
{
    "q": "Can `useId` be used for `key` props in a loop?",
    "type": "mcq",
    "o": [
        "No, keys must be stable based on data, `useId` is for the component instance",
        "Yes",
        "Yes, if list is static",
        "No, it duplicates"
    ]
},
{
    "q": "What is the specialized hook `useDeferredValue` useful for in search UIs?",
    "type": "mcq",
    "o": [
        "Showing results for the 'previous' query while the new one loads/renders (stale data display)",
        "Debouncing input",
        "Fetching data",
        "Highlighting text"
    ]
},
{
    "q": "If you have a `useEffect` with `[]` deps, does it capture the initial props?",
    "type": "mcq",
    "o": [
        "Yes, it creates a closure over initial props",
        "No, it always sees latest",
        "It sees null",
        "It sees undefined"
    ]
},
{
    "q": "How to access the previous props in a functional component?",
    "type": "mcq",
    "o": [
        "Use `useRef` to store current props in `useEffect`, return ref.current",
        "Use `usePreviousProps`",
        "Use `this.props`",
        "Use `useState`"
    ]
},
{
    "q": "What is the 'Rules of Hooks' ESLint plugin name?",
    "type": "mcq",
    "o": [
        "eslint-plugin-react-hooks",
        "eslint-plugin-hooks",
        "eslint-plugin-react",
        "eslint-react-hooks"
    ]
},
{
    "q": "Can you use `hooks` in vanilla JS functions?",
    "type": "mcq",
    "o": [
        "Only if that function is called as a custom hook inside a component",
        "Yes, anywhere",
        "No",
        "Only if imported"
    ]
},
{
    "q": "If `useReducer` state is an object, and you mutate it...",
    "type": "mcq",
    "o": [
        "React won't detect change if you return the same object reference",
        "React detects deep changes",
        "React throws error",
        "It works fine"
    ]
},
{
    "q": "What is the standard workaround for `useEffect` not being async?",
    "type": "mcq",
    "o": [
        "IIFE async function inside effect",
        "Using `useAsyncEffect` lib",
        "Using promise.then",
        "All of the above"
    ]
},
{
    "q": "In `useEffect`, does the cleanup function run on unmount even if deps are `[]`?",
    "type": "mcq",
    "o": [
        "Yes",
        "No",
        "Only if it returns true",
        "Only in strict mode"
    ]
},
{
    "q": "What is the specific use case for `useLayoutEffect` involving measurements?",
    "type": "mcq",
    "o": [
        "Measure DOM node, then update state to adjust layout *before* browser paints (avoids flicker)",
        "Measure after paint",
        "Measure network speed",
        "Measure render time"
    ]
},
{
    "q": "Can `useContext` cause components to unmount?",
    "type": "mcq",
    "o": [
        "No, just re-render",
        "Yes, if key changes",
        "Yes, if error occurs",
        "Yes, if null returned"
    ]
},
{
    "q": "If `useMemo` returns a function...",
    "type": "mcq",
    "o": [
        "It works, but `useCallback` is sugar for this specific case",
        "It is invalid",
        "It calls the function",
        "It errors"
    ]
},
{
    "q": "Does `React.forwardRef` work with hooks?",
    "type": "mcq",
    "o": [
        "Yes, the render function can use hooks",
        "No",
        "Only `useRef`",
        "Only `useState`"
    ]
},
{
    "q": "What is the signature of `useImperativeHandle`?",
    "type": "mcq",
    "o": [
        "useImperativeHandle(ref, createHandle, [deps])",
        "useImperativeHandle(createHandle, ref)",
        "useImperativeHandle(ref, [deps])",
        "useImperativeHandle(handle)"
    ]
},
{
    "q": "If you have a hook `usetimeout(callback, delay)`, why is `callback` often stored in a ref?",
    "type": "mcq",
    "o": [
        "To allow the callback to change without resetting the timer",
        "To make it faster",
        "To access DOM",
        "To prevent execution"
    ]
},
{
    "q": "Can `useDebugValue` accept a formatting function?",
    "type": "mcq",
    "o": [
        "Yes, for lazy formatting",
        "No",
        "Only in production",
        "Only for dates"
    ]
},
{
    "q": "What is the behavior of `useEffect` with `[state]` dependency when `state` changes to same value?",
    "type": "mcq",
    "o": [
        "Effect does not run",
        "Effect runs",
        "React throws error",
        "Depends on browser"
    ]
},
{
    "q": "Is it safe to use `Math.random()` in `useState` initial value?",
    "type": "mcq",
    "o": [
        "Yes, if used as `useState(() => Math.random())` for stability, otherwise it might cause hydration mismatch if SSR",
        "No, never",
        "Yes, generally safe",
        "Only via `useId`"
    ]
},
{
    "q": "How does `useReducer` relate to Redux?",
    "type": "mcq",
    "o": [
        "Same concept (reducer pattern), but `useReducer` is local state management (unless combined with Context)",
        "They share code",
        "`useReducer` is Redux",
        "Redux is deprecated"
    ]
},
{
    "q": "Can hooks be used in `React.PureComponent`?",
    "type": "mcq",
    "o": [
        "No, strictly Class component",
        "Yes",
        "Yes, via mixin",
        "Yes, via inheritance"
    ]
},
{
    "q": "What is the best way to handle 'componentDidMount' logic with hooks?",
    "type": "mcq",
    "o": [
        "`useEffect(() => { ... }, [])`",
        "`useMount`",
        "`useLayoutEffect`",
        "`useState`"
    ]
},
{
    "q": "If `useEffect` has no return value...",
    "type": "mcq",
    "o": [
        "It implies no cleanup needed",
        "It is an error",
        "It leaks memory",
        "It runs once"
    ]
},
{
    "q": "Can `useContext` be used to inject dependencies (DI)?",
    "type": "mcq",
    "o": [
        "Yes, it is a form of Dependency Injection",
        "No",
        "Only for styles",
        "Only for strings"
    ]
},
{
    "q": "What is the limitation of `useContext` regarding updates?",
    "type": "mcq",
    "o": [
        "Lack of fine-grained subscriptions (any context change triggers update)",
        "It is slow",
        "It is sync only",
        "It has max size"
    ]
},
{
    "q": "If `useCallback` is not used, passing a function to a child...",
    "type": "mcq",
    "o": [
        "Causes child to re-render (if it checks prop equality) because function reference changes",
        "Has no effect",
        "Is an error",
        "Is optimized"
    ]
},
{
    "q": "Is `useMemo` guaranteed to keep value?",
    "type": "mcq",
    "o": [
        "No, cache can be purged",
        "Yes",
        "Yes, until unmount",
        "Yes, indefinitely"
    ]
},
{
    "q": "When using `useDeferredValue`, does the UI block?",
    "type": "mcq",
    "o": [
        "No, it yields to high priority updates",
        "Yes",
        "Only for input",
        "Only for images"
    ]
},
{
    "q": "What is `useSyncExternalStore` main advantage over `useEffect` subscription?",
    "type": "mcq",
    "o": [
        "Prevents tearing during concurrent rendering",
        "Simpler syntax",
        "Automatic retries",
        "Faster mounting"
    ]
},
{
    "q": "If you have a `useLocalStorage` hook, which event should it listen to for cross-tab sync?",
    "type": "mcq",
    "o": [
        "`storage` event",
        "`change` event",
        "`update` event",
        "`sync` event"
    ]
},
{
    "q": "Can `useReducer` replace `useState`?",
    "type": "mcq",
    "o": [
        "Yes, `useState` is internally a reducer",
        "No",
        "Only for objects",
        "Only for arrays"
    ]
},
{
    "q": "If you call `hooks` inside a `try/catch` block...",
    "type": "mcq",
    "o": [
        "Violation of Rules of Hooks (conditional execution)",
        "It caches errors",
        "It works safely",
        "It provides error boundary"
    ]
},
{
    "q": "What is the `ref` object structure?",
    "type": "mcq",
    "o": [
        "`{ current: ... }`",
        "`{ value: ... }`",
        "`{ state: ... }`",
        "`{ dom: ... }`"
    ]
},
{
    "q": "Does `useTransition` return a pending flag?",
    "type": "mcq",
    "o": [
        "Yes, `isPending`",
        "No",
        "Yes, `isLoading`",
        "Yes, `isBusy`"
    ]
},
{
    "q": "Can `useEffect` depend on `window.innerWidth`?",
    "type": "mcq",
    "o": [
        "Not directly valid as dependency; you need an event listener to update state or trigger effect",
        "Yes, React tracks window",
        "Yes",
        "Only in CSS"
    ]
},
{
    "q": "If `useCallback` relies on `setState` from `useState`...",
    "type": "mcq",
    "o": [
        "`setState` is stable, so you don't need to add it to deps (but linter might ask, harmless to add)",
        "You must add it",
        "You must not add it",
        "It causes loop"
    ]
},
{
    "q": "What is the 'subscription' pattern with `useEffect`?",
    "type": "mcq",
    "o": [
        "Subscribe in body, unsubscribe in return cleanup",
        "Subscribe in render",
        "Subscribe in useState",
        "Subscribe in useMemo"
    ]
},
{
    "q": "Is `useLayoutEffect` blocking?",
    "type": "mcq",
    "o": [
        "Yes, synchronous",
        "No",
        "Only in dev",
        "Only for SVG"
    ]
},
{
    "q": "Which hook exposes a value to the 'React DevTools'?",
    "type": "mcq",
    "o": [
        "useDebugValue",
        "useDevTools",
        "useLog",
        "useExpose"
    ]
},
{
    "q": "If `useContext` is used, where must the Provider be?",
    "type": "mcq",
    "o": [
        "Higher up in the tree",
        "In the same component",
        "In index.js",
        "Parallel component"
    ]
},
{
    "q": "Can you destructure hooks imports?",
    "type": "mcq",
    "o": [
        "Yes, `import { useState } from 'react'`",
        "No, `React.useState` only",
        "No, `import hooks from 'react'`",
        "Only in TS"
    ]
},
{
    "q": "What happens if you have a memory leak in a component?",
    "type": "mcq",
    "o": [
        "Performance degradation over time",
        "Immediate crash",
        "Network error",
        "Style break"
    ]
},
{
    "q": "Is `useMemo` computed eagerly or lazily?",
    "type": "mcq",
    "o": [
        "Computed during render if deps change",
        "Lazily on access",
        "Async",
        "On idle"
    ]
},
{
    "q": "Can `useReducer` access `props`?",
    "type": "mcq",
    "o": [
        "Yes, inside the component, but standard reducer function is external. You can pass props to it or define it inside (re-created).",
        "No",
        "Yes, via `this.props`",
        "Yes, via context"
    ]
},
{
    "q": "If you want to scroll to top on route change, valid effect is...",
    "type": "mcq",
    "o": [
        "`useEffect(() => { window.scrollTo(0,0) }, [pathname])`",
        "`useLayoutEffect`",
        "`useState`",
        "`useMemo`"
    ]
},
{
    "q": "What is the primary usage of `useCallback`?",
    "type": "mcq",
    "o": [
        "To prevent unnecessary re-rendering of child components that rely on reference equality of functions",
        "To cache values",
        "To run side effects",
        "To access refs"
    ]
},
{
    "q": "In React 18, are updates inside timeouts batched?",
    "type": "mcq",
    "o": [
        "Yes, automatic batching covers timeouts/promises",
        "No, only event handlers",
        "No, never",
        "Only if configured"
    ]
},
{
    "q": "Can `useId` be used for generating keys for a list of items?",
    "type": "mcq",
    "o": [
        "No, use data IDs",
        "Yes",
        "Yes, better than index",
        "Yes, primarily"
    ]
}
]