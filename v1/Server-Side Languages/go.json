[
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "package main\nimport \"fmt\"\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
        "o": [
            "Hello, World!",
            "Error",
            "nil",
            "main"
        ]
    },
    {
        "q": "Go is a _____ typed language.",
        "type": "fill_blank",
        "answers": [
            "statically"
        ],
        "other_options": [
            "dynamically",
            "weakly",
            "untyped"
        ]
    },
    {
        "q": "Go was developed by Google.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match the Go keywords:",
        "type": "match",
        "left": [
            "package",
            "import",
            "func",
            "var"
        ],
        "right": [
            "Module name",
            "Include library",
            "Function",
            "Variable"
        ]
    },
    {
        "q": "Which declares a variable?",
        "type": "mcq",
        "o": [
            "var x int",
            "int x",
            "x: int",
            "declare x int"
        ]
    },
    {
        "q": "Arrange the Go program structure:",
        "type": "rearrange",
        "words": [
            "package main",
            "import",
            "func main()",
            "code block"
        ]
    },
    {
        "q": "The _____ function is the entry point.",
        "type": "fill_blank",
        "answers": [
            "main"
        ],
        "other_options": [
            "entry",
            "start",
            "init"
        ]
    },
    {
        "q": "Go requires semicolons at line endings.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "x := 10\nfmt.Println(x)",
        "o": [
            "10",
            "Error",
            "x",
            "nil"
        ]
    },
    {
        "q": "Match the data types:",
        "type": "match",
        "left": [
            "int",
            "float64",
            "string",
            "bool"
        ],
        "right": [
            "Integer",
            "Decimal",
            "Text",
            "True/False"
        ]
    },
    {
        "q": "Which is short variable declaration?",
        "type": "mcq",
        "o": [
            ":=",
            "=",
            "var",
            "let"
        ]
    },
    {
        "q": "Arrange the variable declaration:",
        "type": "rearrange",
        "words": [
            "var",
            "name",
            "type",
            "= value"
        ]
    },
    {
        "q": "The _____ keyword declares constants.",
        "type": "fill_blank",
        "answers": [
            "const"
        ],
        "other_options": [
            "var",
            "let",
            "final"
        ]
    },
    {
        "q": "Go supports type inference.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "const pi = 3.14\nfmt.Println(pi)",
        "o": [
            "3.14",
            "Error",
            "pi",
            "nil"
        ]
    },
    {
        "q": "Match the operators:",
        "type": "match",
        "left": [
            "+",
            "-",
            "*",
            "/"
        ],
        "right": [
            "Addition",
            "Subtraction",
            "Multiplication",
            "Division"
        ]
    },
    {
        "q": "Which is the modulo operator?",
        "type": "mcq",
        "o": [
            "%",
            "mod",
            "//",
            "rem"
        ]
    },
    {
        "q": "Arrange the arithmetic:",
        "type": "rearrange",
        "words": [
            "operand1",
            "operator",
            "operand2",
            "result"
        ]
    },
    {
        "q": "The _____ returns remainder.",
        "type": "fill_blank",
        "answers": [
            "%"
        ],
        "other_options": [
            "/",
            "mod",
            "rem"
        ]
    },
    {
        "q": "Go supports operator overloading.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "fmt.Println(10 % 3)",
        "o": [
            "1",
            "3",
            "10",
            "Error"
        ]
    },
    {
        "q": "Match the comparison operators:",
        "type": "match",
        "left": [
            "==",
            "!=",
            "<",
            ">"
        ],
        "right": [
            "Equal",
            "Not equal",
            "Less than",
            "Greater than"
        ]
    },
    {
        "q": "Which checks equality?",
        "type": "mcq",
        "o": [
            "==",
            "=",
            "===",
            "eq"
        ]
    },
    {
        "q": "Arrange the comparison:",
        "type": "rearrange",
        "words": [
            "value1",
            "==",
            "value2",
            "returns bool"
        ]
    },
    {
        "q": "The _____ compares not equal.",
        "type": "fill_blank",
        "answers": [
            "!="
        ],
        "other_options": [
            "<>",
            "!==",
            "ne"
        ]
    },
    {
        "q": "Comparison returns boolean.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "fmt.Println(5 == 5)",
        "o": [
            "true",
            "false",
            "5",
            "Error"
        ]
    },
    {
        "q": "Match the logical operators:",
        "type": "match",
        "left": [
            "&&",
            "||",
            "!",
            "true"
        ],
        "right": [
            "AND",
            "OR",
            "NOT",
            "Boolean"
        ]
    },
    {
        "q": "Which is logical AND?",
        "type": "mcq",
        "o": [
            "&&",
            "&",
            "and",
            "AND"
        ]
    },
    {
        "q": "Arrange the logical expression:",
        "type": "rearrange",
        "words": [
            "condition1",
            "&&",
            "condition2",
            "evaluates"
        ]
    },
    {
        "q": "The _____ negates boolean.",
        "type": "fill_blank",
        "answers": [
            "!"
        ],
        "other_options": [
            "not",
            "~",
            "neg"
        ]
    },
    {
        "q": "|| returns true if any is true.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "fmt.Println(true && false)",
        "o": [
            "false",
            "true",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the control flow:",
        "type": "match",
        "left": [
            "if",
            "else",
            "switch",
            "for"
        ],
        "right": [
            "Condition",
            "Alternative",
            "Multi-branch",
            "Loop"
        ]
    },
    {
        "q": "Which is the only loop in Go?",
        "type": "mcq",
        "o": [
            "for",
            "while",
            "do",
            "loop"
        ]
    },
    {
        "q": "Arrange the if statement:",
        "type": "rearrange",
        "words": [
            "if",
            "condition",
            "{ code }",
            "else { }"
        ]
    },
    {
        "q": "The _____ is Go's only loop.",
        "type": "fill_blank",
        "answers": [
            "for"
        ],
        "other_options": [
            "while",
            "loop",
            "do"
        ]
    },
    {
        "q": "Go has no while loop keyword.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "for i := 0; i < 3; i++ {\n    fmt.Print(i)\n}",
        "o": [
            "012",
            "123",
            "Error",
            "0123"
        ]
    },
    {
        "q": "Match the loop patterns:",
        "type": "match",
        "left": [
            "for i",
            "for range",
            "for {}",
            "break"
        ],
        "right": [
            "Index loop",
            "Iterator",
            "Infinite",
            "Exit loop"
        ]
    },
    {
        "q": "Which iterates collections?",
        "type": "mcq",
        "o": [
            "range",
            "each",
            "iter",
            "in"
        ]
    },
    {
        "q": "Arrange the range loop:",
        "type": "rearrange",
        "words": [
            "for",
            "index, value",
            ":= range",
            "slice"
        ]
    },
    {
        "q": "The _____ exits a loop.",
        "type": "fill_blank",
        "answers": [
            "break"
        ],
        "other_options": [
            "exit",
            "stop",
            "return"
        ]
    },
    {
        "q": "continue skips to next iteration.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "nums := []int{1, 2, 3}\nfor i, v := range nums {\n    fmt.Print(v)\n}",
        "o": [
            "123",
            "012",
            "Error",
            "1 2 3"
        ]
    },
    {
        "q": "Match the function parts:",
        "type": "match",
        "left": [
            "func",
            "params",
            "return",
            "body"
        ],
        "right": [
            "Keyword",
            "Inputs",
            "Output",
            "Code"
        ]
    },
    {
        "q": "Which declares a function?",
        "type": "mcq",
        "o": [
            "func",
            "function",
            "def",
            "fn"
        ]
    },
    {
        "q": "Arrange the function definition:",
        "type": "rearrange",
        "words": [
            "func",
            "name(params)",
            "return_type",
            "{ body }"
        ]
    },
    {
        "q": "The _____ sends value back.",
        "type": "fill_blank",
        "answers": [
            "return"
        ],
        "other_options": [
            "yield",
            "output",
            "give"
        ]
    },
    {
        "q": "Go functions can return multiple values.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func add(a, b int) int {\n    return a + b\n}\nfmt.Println(add(2, 3))",
        "o": [
            "5",
            "Error",
            "23",
            "nil"
        ]
    },
    {
        "q": "Match the return types:",
        "type": "match",
        "left": [
            "int",
            "(int, error)",
            "func()",
            "interface{}"
        ],
        "right": [
            "Single return",
            "Multiple return",
            "Function type",
            "Any type"
        ]
    },
    {
        "q": "Which returns multiple values?",
        "type": "mcq",
        "o": [
            "(int, error)",
            "int[]",
            "tuple",
            "multi"
        ]
    },
    {
        "q": "Arrange the multi-return:",
        "type": "rearrange",
        "words": [
            "func name()",
            "(type1, type2)",
            "{ return a, b }",
            "call"
        ]
    },
    {
        "q": "The _____ ignores return value.",
        "type": "fill_blank",
        "answers": [
            "_"
        ],
        "other_options": [
            "-",
            "null",
            "void"
        ]
    },
    {
        "q": "Named returns are optional.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func swap(a, b int) (int, int) {\n    return b, a\n}\nx, y := swap(1, 2)\nfmt.Println(x, y)",
        "o": [
            "2 1",
            "1 2",
            "Error",
            "12"
        ]
    },
    {
        "q": "Match the array concepts:",
        "type": "match",
        "left": [
            "[3]int",
            "[]int",
            "len()",
            "cap()"
        ],
        "right": [
            "Fixed array",
            "Slice",
            "Length",
            "Capacity"
        ]
    },
    {
        "q": "Which has dynamic size?",
        "type": "mcq",
        "o": [
            "slice",
            "array",
            "both",
            "neither"
        ]
    },
    {
        "q": "Arrange the slice creation:",
        "type": "rearrange",
        "words": [
            "make",
            "([]int,",
            "length,",
            "capacity)"
        ]
    },
    {
        "q": "The _____ returns slice length.",
        "type": "fill_blank",
        "answers": [
            "len"
        ],
        "other_options": [
            "size",
            "length",
            "count"
        ]
    },
    {
        "q": "Arrays in Go have fixed size.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "s := []int{1, 2, 3}\nfmt.Println(len(s))",
        "o": [
            "3",
            "Error",
            "[1 2 3]",
            "nil"
        ]
    },
    {
        "q": "Match the slice operations:",
        "type": "match",
        "left": [
            "append",
            "copy",
            "s[1:3]",
            "make"
        ],
        "right": [
            "Add elements",
            "Copy slice",
            "Sub-slice",
            "Create"
        ]
    },
    {
        "q": "Which adds to slice?",
        "type": "mcq",
        "o": [
            "append",
            "push",
            "add",
            "insert"
        ]
    },
    {
        "q": "Arrange the append:",
        "type": "rearrange",
        "words": [
            "slice",
            "= append(",
            "slice,",
            "elements)"
        ]
    },
    {
        "q": "The _____ creates a new slice.",
        "type": "fill_blank",
        "answers": [
            "make"
        ],
        "other_options": [
            "new",
            "create",
            "alloc"
        ]
    },
    {
        "q": "append returns new slice.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "s := []int{1, 2}\ns = append(s, 3)\nfmt.Println(s)",
        "o": [
            "[1 2 3]",
            "Error",
            "3",
            "nil"
        ]
    },
    {
        "q": "Match the map concepts:",
        "type": "match",
        "left": [
            "map[string]int",
            "make(map)",
            "delete",
            "ok"
        ],
        "right": [
            "Map type",
            "Create map",
            "Remove key",
            "Key exists"
        ]
    },
    {
        "q": "Which creates a map?",
        "type": "mcq",
        "o": [
            "make(map[K]V)",
            "map{}",
            "new map",
            "Map()"
        ]
    },
    {
        "q": "Arrange the map creation:",
        "type": "rearrange",
        "words": [
            "m :=",
            "make(",
            "map[string]int",
            ")"
        ]
    },
    {
        "q": "The _____ removes map key.",
        "type": "fill_blank",
        "answers": [
            "delete"
        ],
        "other_options": [
            "remove",
            "del",
            "unset"
        ]
    },
    {
        "q": "Maps are reference types.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "m := map[string]int{\"a\": 1}\nfmt.Println(m[\"a\"])",
        "o": [
            "1",
            "Error",
            "a",
            "nil"
        ]
    },
    {
        "q": "Match the struct concepts:",
        "type": "match",
        "left": [
            "type",
            "struct",
            "field",
            "embedded"
        ],
        "right": [
            "Define type",
            "Composite",
            "Property",
            "Inheritance"
        ]
    },
    {
        "q": "Which defines a struct?",
        "type": "mcq",
        "o": [
            "type Name struct",
            "struct Name",
            "class Name",
            "def struct"
        ]
    },
    {
        "q": "Arrange the struct definition:",
        "type": "rearrange",
        "words": [
            "type",
            "Person",
            "struct {",
            "fields }"
        ]
    },
    {
        "q": "The _____ defines custom type.",
        "type": "fill_blank",
        "answers": [
            "type"
        ],
        "other_options": [
            "struct",
            "class",
            "def"
        ]
    },
    {
        "q": "Structs group related data.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type Person struct {\n    Name string\n    Age  int\n}\np := Person{\"John\", 30}\nfmt.Println(p.Name)",
        "o": [
            "John",
            "Error",
            "Person",
            "nil"
        ]
    },
    {
        "q": "Match the pointer concepts:",
        "type": "match",
        "left": [
            "*",
            "&",
            "nil",
            "new"
        ],
        "right": [
            "Dereference",
            "Address of",
            "Null pointer",
            "Allocate"
        ]
    },
    {
        "q": "Which gets memory address?",
        "type": "mcq",
        "o": [
            "&",
            "*",
            "->",
            "@"
        ]
    },
    {
        "q": "Arrange the pointer usage:",
        "type": "rearrange",
        "words": [
            "var p",
            "*int",
            "= &x",
            "access *p"
        ]
    },
    {
        "q": "The _____ dereferences pointer.",
        "type": "fill_blank",
        "answers": [
            "*"
        ],
        "other_options": [
            "&",
            "->",
            "@"
        ]
    },
    {
        "q": "Go has no pointer arithmetic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "x := 10\np := &x\nfmt.Println(*p)",
        "o": [
            "10",
            "Error",
            "address",
            "nil"
        ]
    },
    {
        "q": "Match the method concepts:",
        "type": "match",
        "left": [
            "receiver",
            "value receiver",
            "pointer receiver",
            "method"
        ],
        "right": [
            "Target type",
            "Copy",
            "Modify original",
            "Function on type"
        ]
    },
    {
        "q": "Which modifies the original?",
        "type": "mcq",
        "o": [
            "pointer receiver",
            "value receiver",
            "both",
            "neither"
        ]
    },
    {
        "q": "Arrange the method definition:",
        "type": "rearrange",
        "words": [
            "func",
            "(r Type)",
            "MethodName()",
            "body"
        ]
    },
    {
        "q": "The _____ binds function to type.",
        "type": "fill_blank",
        "answers": [
            "receiver"
        ],
        "other_options": [
            "this",
            "self",
            "method"
        ]
    },
    {
        "q": "Methods can have receivers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type Counter struct { count int }\nfunc (c *Counter) Inc() { c.count++ }\nc := Counter{0}\nc.Inc()\nfmt.Println(c.count)",
        "o": [
            "1",
            "0",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the interface concepts:",
        "type": "match",
        "left": [
            "interface",
            "method set",
            "empty interface",
            "type assertion"
        ],
        "right": [
            "Contract",
            "Required methods",
            "Any type",
            "Check type"
        ]
    },
    {
        "q": "Which accepts any type?",
        "type": "mcq",
        "o": [
            "interface{}",
            "any",
            "Object",
            "void"
        ]
    },
    {
        "q": "Arrange the interface implementation:",
        "type": "rearrange",
        "words": [
            "Define interface",
            "Create type",
            "Implement methods",
            "Use interface"
        ]
    },
    {
        "q": "The _____ is implicit in Go.",
        "type": "fill_blank",
        "answers": [
            "interface implementation"
        ],
        "other_options": [
            "inheritance",
            "subclassing",
            "extending"
        ]
    },
    {
        "q": "Go uses implicit interface implementation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type Reader interface {\n    Read() string\n}\ntype File struct{}\nfunc (f File) Read() string { return \"data\" }",
        "o": [
            "Implements Reader",
            "Error",
            "nil",
            "No interface"
        ]
    },
    {
        "q": "Match the error handling:",
        "type": "match",
        "left": [
            "error",
            "nil",
            "panic",
            "recover"
        ],
        "right": [
            "Error type",
            "No error",
            "Crash",
            "Handle panic"
        ]
    },
    {
        "q": "Which indicates no error?",
        "type": "mcq",
        "o": [
            "nil",
            "null",
            "void",
            "none"
        ]
    },
    {
        "q": "Arrange the error handling:",
        "type": "rearrange",
        "words": [
            "Call function",
            "Check err != nil",
            "Handle error",
            "Continue"
        ]
    },
    {
        "q": "The _____ stops normal execution.",
        "type": "fill_blank",
        "answers": [
            "panic"
        ],
        "other_options": [
            "error",
            "throw",
            "crash"
        ]
    },
    {
        "q": "Go uses explicit error handling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"divide by zero\")\n    }\n    return a / b, nil\n}",
        "o": [
            "Returns result or error",
            "Error",
            "nil",
            "Panics"
        ]
    },
    {
        "q": "Match the concurrency concepts:",
        "type": "match",
        "left": [
            "goroutine",
            "channel",
            "select",
            "sync"
        ],
        "right": [
            "Lightweight thread",
            "Communication",
            "Multi-channel",
            "Synchronization"
        ]
    },
    {
        "q": "Which starts concurrent function?",
        "type": "mcq",
        "o": [
            "go",
            "async",
            "spawn",
            "thread"
        ]
    },
    {
        "q": "Arrange the goroutine creation:",
        "type": "rearrange",
        "words": [
            "go",
            "funcName()",
            "execute async",
            "main continues"
        ]
    },
    {
        "q": "The _____ keyword starts goroutine.",
        "type": "fill_blank",
        "answers": [
            "go"
        ],
        "other_options": [
            "async",
            "spawn",
            "run"
        ]
    },
    {
        "q": "Goroutines are lightweight.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go func() {\n    fmt.Println(\"Hello\")\n}()",
        "o": [
            "Async Hello",
            "Error",
            "nil",
            "Synchronous"
        ]
    },
    {
        "q": "Match the channel types:",
        "type": "match",
        "left": [
            "chan int",
            "chan<-",
            "<-chan",
            "make(chan)"
        ],
        "right": [
            "Bidirectional",
            "Send only",
            "Receive only",
            "Create channel"
        ]
    },
    {
        "q": "Which creates a channel?",
        "type": "mcq",
        "o": [
            "make(chan int)",
            "chan int{}",
            "new(chan)",
            "Channel()"
        ]
    },
    {
        "q": "Arrange the channel usage:",
        "type": "rearrange",
        "words": [
            "Create channel",
            "Send value",
            "Receive value",
            "Close channel"
        ]
    },
    {
        "q": "The _____ operator sends to channel.",
        "type": "fill_blank",
        "answers": [
            "<-"
        ],
        "other_options": [
            "->",
            "<<",
            ">>"
        ]
    },
    {
        "q": "Channels synchronize goroutines.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ch := make(chan int)\ngo func() { ch <- 42 }()\nfmt.Println(<-ch)",
        "o": [
            "42",
            "Error",
            "nil",
            "deadlock"
        ]
    },
    {
        "q": "Match the buffered channels:",
        "type": "match",
        "left": [
            "make(chan int, 5)",
            "cap()",
            "len()",
            "blocking"
        ],
        "right": [
            "Buffered channel",
            "Capacity",
            "Items in buffer",
            "Unbuffered"
        ]
    },
    {
        "q": "Which creates buffered channel?",
        "type": "mcq",
        "o": [
            "make(chan int, 5)",
            "make(chan int)",
            "buffer(chan)",
            "chan[5]int"
        ]
    },
    {
        "q": "Arrange the buffered channel:",
        "type": "rearrange",
        "words": [
            "make channel with size",
            "Send without blocking",
            "Buffer fills",
            "Blocks when full"
        ]
    },
    {
        "q": "The _____ gets channel capacity.",
        "type": "fill_blank",
        "answers": [
            "cap"
        ],
        "other_options": [
            "len",
            "size",
            "max"
        ]
    },
    {
        "q": "Buffered channels are non-blocking until full.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ch := make(chan int, 2)\nch <- 1\nch <- 2\nfmt.Println(len(ch))",
        "o": [
            "2",
            "0",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the select statement:",
        "type": "match",
        "left": [
            "select",
            "case",
            "default",
            "timeout"
        ],
        "right": [
            "Multi-channel",
            "Channel op",
            "Non-blocking",
            "Time limit"
        ]
    },
    {
        "q": "Which waits on multiple channels?",
        "type": "mcq",
        "o": [
            "select",
            "switch",
            "for",
            "if"
        ]
    },
    {
        "q": "Arrange the select usage:",
        "type": "rearrange",
        "words": [
            "select {",
            "case <-ch1:",
            "case <-ch2:",
            "}"
        ]
    },
    {
        "q": "The _____ makes select non-blocking.",
        "type": "fill_blank",
        "answers": [
            "default"
        ],
        "other_options": [
            "else",
            "nil",
            "skip"
        ]
    },
    {
        "q": "Select chooses ready channel randomly.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "select {\ncase v := <-ch:\n    fmt.Println(v)\ndefault:\n    fmt.Println(\"no value\")\n}",
        "o": [
            "Value or no value",
            "Error",
            "nil",
            "Deadlock"
        ]
    },
    {
        "q": "Match the sync primitives:",
        "type": "match",
        "left": [
            "Mutex",
            "RWMutex",
            "WaitGroup",
            "Once"
        ],
        "right": [
            "Exclusive lock",
            "Read/write lock",
            "Wait for goroutines",
            "Run once"
        ]
    },
    {
        "q": "Which provides mutual exclusion?",
        "type": "mcq",
        "o": [
            "Mutex",
            "Channel",
            "Semaphore",
            "Lock"
        ]
    },
    {
        "q": "Arrange the mutex usage:",
        "type": "rearrange",
        "words": [
            "Lock()",
            "Critical section",
            "Unlock()",
            "defer Unlock"
        ]
    },
    {
        "q": "The _____ waits for goroutines.",
        "type": "fill_blank",
        "answers": [
            "WaitGroup"
        ],
        "other_options": [
            "Mutex",
            "Channel",
            "Barrier"
        ]
    },
    {
        "q": "defer Unlock() is best practice.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var wg sync.WaitGroup\nwg.Add(1)\ngo func() { defer wg.Done() }()\nwg.Wait()",
        "o": [
            "Waits for goroutine",
            "Error",
            "nil",
            "Deadlock"
        ]
    },
    {
        "q": "Match the context package:",
        "type": "match",
        "left": [
            "context.Background",
            "context.WithCancel",
            "context.WithTimeout",
            "context.WithValue"
        ],
        "right": [
            "Root context",
            "Cancellable",
            "Timeout",
            "Pass values"
        ]
    },
    {
        "q": "Which creates root context?",
        "type": "mcq",
        "o": [
            "context.Background()",
            "context.TODO()",
            "context.New()",
            "Both Background and TODO"
        ]
    },
    {
        "q": "Arrange the context cancellation:",
        "type": "rearrange",
        "words": [
            "Create context",
            "Pass to goroutines",
            "Call cancel",
            "Goroutines exit"
        ]
    },
    {
        "q": "The _____ context has deadline.",
        "type": "fill_blank",
        "answers": [
            "WithTimeout"
        ],
        "other_options": [
            "WithCancel",
            "Background",
            "TODO"
        ]
    },
    {
        "q": "Context propagates cancellation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ctx, cancel := context.WithTimeout(context.Background(), time.Second)\ndefer cancel()",
        "o": [
            "1 second timeout",
            "Error",
            "nil",
            "Infinite"
        ]
    },
    {
        "q": "Match the testing functions:",
        "type": "match",
        "left": [
            "TestXxx",
            "BenchmarkXxx",
            "ExampleXxx",
            "t.Error"
        ],
        "right": [
            "Unit test",
            "Performance",
            "Documentation",
            "Fail test"
        ]
    },
    {
        "q": "Which runs unit tests?",
        "type": "mcq",
        "o": [
            "go test",
            "go run test",
            "go check",
            "go verify"
        ]
    },
    {
        "q": "Arrange the test function:",
        "type": "rearrange",
        "words": [
            "func Test",
            "Name(t *testing.T)",
            "{ test logic }",
            "t.Error if fail"
        ]
    },
    {
        "q": "The _____ marks test as failed.",
        "type": "fill_blank",
        "answers": [
            "t.Error"
        ],
        "other_options": [
            "t.Fail",
            "t.Fatal",
            "All of these"
        ]
    },
    {
        "q": "Test files end with _test.go.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func TestAdd(t *testing.T) {\n    if add(2, 3) != 5 {\n        t.Error(\"Expected 5\")\n    }\n}",
        "o": [
            "Unit test",
            "Error",
            "nil",
            "Benchmark"
        ]
    },
    {
        "q": "Match the net/http:",
        "type": "match",
        "left": [
            "http.ListenAndServe",
            "http.HandleFunc",
            "http.Get",
            "http.Client"
        ],
        "right": [
            "Start server",
            "Route handler",
            "GET request",
            "HTTP client"
        ]
    },
    {
        "q": "Which starts HTTP server?",
        "type": "mcq",
        "o": [
            "http.ListenAndServe",
            "http.Serve",
            "http.Start",
            "http.Run"
        ]
    },
    {
        "q": "Arrange the HTTP server:",
        "type": "rearrange",
        "words": [
            "Define handlers",
            "Register routes",
            "ListenAndServe",
            "Handle requests"
        ]
    },
    {
        "q": "The _____ registers route handler.",
        "type": "fill_blank",
        "answers": [
            "HandleFunc"
        ],
        "other_options": [
            "Handle",
            "Route",
            "Register"
        ]
    },
    {
        "q": "http.Handler is an interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello\")\n})",
        "o": [
            "Route handler",
            "Error",
            "nil",
            "Server"
        ]
    },
    {
        "q": "Match the JSON handling:",
        "type": "match",
        "left": [
            "json.Marshal",
            "json.Unmarshal",
            "json.Encoder",
            "json.Decoder"
        ],
        "right": [
            "To JSON",
            "From JSON",
            "Stream encode",
            "Stream decode"
        ]
    },
    {
        "q": "Which converts to JSON?",
        "type": "mcq",
        "o": [
            "json.Marshal",
            "json.Encode",
            "json.Stringify",
            "json.ToJSON"
        ]
    },
    {
        "q": "Arrange the JSON parsing:",
        "type": "rearrange",
        "words": [
            "Get JSON bytes",
            "Define struct",
            "Unmarshal",
            "Use data"
        ]
    },
    {
        "q": "The _____ parses JSON to struct.",
        "type": "fill_blank",
        "answers": [
            "Unmarshal"
        ],
        "other_options": [
            "Marshal",
            "Decode",
            "Parse"
        ]
    },
    {
        "q": "Struct tags control JSON field names.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type User struct {\n    Name string `json:\"name\"`\n}\ndata, _ := json.Marshal(User{\"John\"})",
        "o": [
            "{\"name\":\"John\"}",
            "Error",
            "nil",
            "John"
        ]
    },
    {
        "q": "Match the file I/O:",
        "type": "match",
        "left": [
            "os.Open",
            "os.Create",
            "ioutil.ReadFile",
            "io.Copy"
        ],
        "right": [
            "Open file",
            "Create file",
            "Read all",
            "Copy streams"
        ]
    },
    {
        "q": "Which reads entire file?",
        "type": "mcq",
        "o": [
            "ioutil.ReadFile",
            "os.Read",
            "file.ReadAll",
            "io.ReadAll"
        ]
    },
    {
        "q": "Arrange the file reading:",
        "type": "rearrange",
        "words": [
            "Open file",
            "Read content",
            "Handle error",
            "Close file"
        ]
    },
    {
        "q": "The _____ must be called after Open.",
        "type": "fill_blank",
        "answers": [
            "Close"
        ],
        "other_options": [
            "End",
            "Finish",
            "Done"
        ]
    },
    {
        "q": "defer file.Close() is idiomatic.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "f, err := os.Open(\"test.txt\")\ndefer f.Close()\ndata, _ := io.ReadAll(f)",
        "o": [
            "Reads file",
            "Error",
            "nil",
            "Creates file"
        ]
    },
    {
        "q": "Match the string operations:",
        "type": "match",
        "left": [
            "strings.Split",
            "strings.Join",
            "strings.Contains",
            "strings.Replace"
        ],
        "right": [
            "To slice",
            "From slice",
            "Check substring",
            "Replace text"
        ]
    },
    {
        "q": "Which splits string?",
        "type": "mcq",
        "o": [
            "strings.Split",
            "strings.Divide",
            "strings.Break",
            "strings.Cut"
        ]
    },
    {
        "q": "Arrange the string building:",
        "type": "rearrange",
        "words": [
            "strings.Builder",
            "WriteString",
            "Build string",
            "String()"
        ]
    },
    {
        "q": "The _____ is efficient for concatenation.",
        "type": "fill_blank",
        "answers": [
            "strings.Builder"
        ],
        "other_options": [
            "+ operator",
            "fmt.Sprintf",
            "bytes.Buffer"
        ]
    },
    {
        "q": "Strings are immutable in Go.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "parts := strings.Split(\"a,b,c\", \",\")\nfmt.Println(len(parts))",
        "o": [
            "3",
            "1",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the time package:",
        "type": "match",
        "left": [
            "time.Now",
            "time.Sleep",
            "time.Duration",
            "time.Parse"
        ],
        "right": [
            "Current time",
            "Pause",
            "Time span",
            "Parse string"
        ]
    },
    {
        "q": "Which gets current time?",
        "type": "mcq",
        "o": [
            "time.Now()",
            "time.Current()",
            "time.Get()",
            "time.Today()"
        ]
    },
    {
        "q": "Arrange the timer usage:",
        "type": "rearrange",
        "words": [
            "time.NewTimer",
            "Wait <-timer.C",
            "Timer fires",
            "Handle event"
        ]
    },
    {
        "q": "The _____ pauses execution.",
        "type": "fill_blank",
        "answers": [
            "time.Sleep"
        ],
        "other_options": [
            "time.Wait",
            "time.Pause",
            "time.Delay"
        ]
    },
    {
        "q": "time.Ticker repeats at intervals.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "t := time.Now()\nfmt.Println(t.Year())",
        "o": [
            "Current year",
            "Error",
            "nil",
            "Unix timestamp"
        ]
    },
    {
        "q": "Match the generics (Go 1.18+):",
        "type": "match",
        "left": [
            "[T any]",
            "constraints",
            "comparable",
            "~int"
        ],
        "right": [
            "Type param",
            "Type limits",
            "== support",
            "Underlying type"
        ]
    },
    {
        "q": "Which declares type parameter?",
        "type": "mcq",
        "o": [
            "[T any]",
            "<T>",
            "T any",
            "(T any)"
        ]
    },
    {
        "q": "Arrange the generic function:",
        "type": "rearrange",
        "words": [
            "func Name",
            "[T any]",
            "(param T)",
            "T { }"
        ]
    },
    {
        "q": "The _____ allows any type.",
        "type": "fill_blank",
        "answers": [
            "any"
        ],
        "other_options": [
            "interface{}",
            "generic",
            "T"
        ]
    },
    {
        "q": "Go 1.18 introduced generics.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func Print[T any](v T) {\n    fmt.Println(v)\n}",
        "o": [
            "Generic function",
            "Error",
            "nil",
            "Template"
        ]
    },
    {
        "q": "Match the embedding:",
        "type": "match",
        "left": [
            "embedded struct",
            "promoted fields",
            "anonymous field",
            "composition"
        ],
        "right": [
            "Include struct",
            "Access directly",
            "No name",
            "Has-a relation"
        ]
    },
    {
        "q": "Which promotes fields?",
        "type": "mcq",
        "o": [
            "embedding",
            "inheritance",
            "extending",
            "including"
        ]
    },
    {
        "q": "Arrange the struct embedding:",
        "type": "rearrange",
        "words": [
            "Define base struct",
            "Embed in child",
            "Access base fields",
            "Override if needed"
        ]
    },
    {
        "q": "The _____ gives access to embedded fields.",
        "type": "fill_blank",
        "answers": [
            "promotion"
        ],
        "other_options": [
            "inheritance",
            "delegation",
            "forwarding"
        ]
    },
    {
        "q": "Go uses composition over inheritance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type Animal struct { Name string }\ntype Dog struct { Animal; Breed string }\nd := Dog{Animal{\"Rex\"}, \"Lab\"}\nfmt.Println(d.Name)",
        "o": [
            "Rex",
            "Error",
            "nil",
            "Dog"
        ]
    },
    {
        "q": "Match the defer behavior:",
        "type": "match",
        "left": [
            "defer",
            "LIFO",
            "panic recovery",
            "cleanup"
        ],
        "right": [
            "Delay execution",
            "Stack order",
            "recover in defer",
            "Close resources"
        ]
    },
    {
        "q": "When does defer execute?",
        "type": "mcq",
        "o": [
            "Function exit",
            "Immediately",
            "After return",
            "Before return"
        ]
    },
    {
        "q": "Arrange the defer stack:",
        "type": "rearrange",
        "words": [
            "defer A()",
            "defer B()",
            "defer C()",
            "C B A executed"
        ]
    },
    {
        "q": "The _____ order is defer execution.",
        "type": "fill_blank",
        "answers": [
            "LIFO"
        ],
        "other_options": [
            "FIFO",
            "random",
            "sequential"
        ]
    },
    {
        "q": "Deferred arguments are evaluated immediately.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "defer fmt.Println(\"world\")\nfmt.Println(\"hello\")",
        "o": [
            "hello world",
            "world hello",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the reflection:",
        "type": "match",
        "left": [
            "reflect.TypeOf",
            "reflect.ValueOf",
            "Kind()",
            "Interface()"
        ],
        "right": [
            "Get type",
            "Get value",
            "Type category",
            "To interface"
        ]
    },
    {
        "q": "Which gets runtime type?",
        "type": "mcq",
        "o": [
            "reflect.TypeOf",
            "typeof",
            "type()",
            "getType"
        ]
    },
    {
        "q": "Arrange the reflection usage:",
        "type": "rearrange",
        "words": [
            "Get Type",
            "Get Value",
            "Check Kind",
            "Modify if settable"
        ]
    },
    {
        "q": "The _____ returns type category.",
        "type": "fill_blank",
        "answers": [
            "Kind"
        ],
        "other_options": [
            "Type",
            "Category",
            "Class"
        ]
    },
    {
        "q": "Reflection has performance cost.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "x := 42\nt := reflect.TypeOf(x)\nfmt.Println(t.Kind())",
        "o": [
            "int",
            "42",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the database/sql:",
        "type": "match",
        "left": [
            "sql.Open",
            "db.Query",
            "db.Exec",
            "rows.Scan"
        ],
        "right": [
            "Connect",
            "SELECT",
            "INSERT/UPDATE",
            "Read row"
        ]
    },
    {
        "q": "Which connects to database?",
        "type": "mcq",
        "o": [
            "sql.Open",
            "sql.Connect",
            "sql.New",
            "sql.DB"
        ]
    },
    {
        "q": "Arrange the database query:",
        "type": "rearrange",
        "words": [
            "Open connection",
            "Prepare query",
            "Execute query",
            "Scan results"
        ]
    },
    {
        "q": "The _____ reads row values.",
        "type": "fill_blank",
        "answers": [
            "Scan"
        ],
        "other_options": [
            "Read",
            "Get",
            "Fetch"
        ]
    },
    {
        "q": "database/sql uses connection pooling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "db, _ := sql.Open(\"mysql\", \"user:pass@/dbname\")\nrows, _ := db.Query(\"SELECT name FROM users\")",
        "o": [
            "Query result",
            "Error",
            "nil",
            "Connection"
        ]
    },
    {
        "q": "Match the HTTP middleware:",
        "type": "match",
        "left": [
            "http.Handler",
            "HandlerFunc",
            "middleware",
            "chain"
        ],
        "right": [
            "Interface",
            "Adapter",
            "Wrapper",
            "Multiple handlers"
        ]
    },
    {
        "q": "Which is handler interface?",
        "type": "mcq",
        "o": [
            "http.Handler",
            "http.Mux",
            "http.Server",
            "http.Client"
        ]
    },
    {
        "q": "Arrange the middleware chain:",
        "type": "rearrange",
        "words": [
            "Define middleware",
            "Wrap handler",
            "Call next",
            "Return response"
        ]
    },
    {
        "q": "The _____ wraps another handler.",
        "type": "fill_blank",
        "answers": [
            "middleware"
        ],
        "other_options": [
            "wrapper",
            "decorator",
            "filter"
        ]
    },
    {
        "q": "Middleware follows handler pattern.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func logging(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Println(r.URL)\n        next.ServeHTTP(w, r)\n    })\n}",
        "o": [
            "Logging middleware",
            "Error",
            "nil",
            "Handler"
        ]
    },
    {
        "q": "Match the template package:",
        "type": "match",
        "left": [
            "text/template",
            "html/template",
            "Execute",
            "ParseFiles"
        ],
        "right": [
            "Text templates",
            "HTML safe",
            "Run template",
            "Load files"
        ]
    },
    {
        "q": "Which is XSS safe?",
        "type": "mcq",
        "o": [
            "html/template",
            "text/template",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "Arrange the template usage:",
        "type": "rearrange",
        "words": [
            "Parse template",
            "Define data",
            "Execute",
            "Output result"
        ]
    },
    {
        "q": "The _____ escapes HTML.",
        "type": "fill_blank",
        "answers": [
            "html/template"
        ],
        "other_options": [
            "text/template",
            "template",
            "html"
        ]
    },
    {
        "q": "Templates use {{.Field}} syntax.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "t := template.Must(template.ParseFiles(\"page.html\"))\nt.Execute(w, data)",
        "o": [
            "Renders template",
            "Error",
            "nil",
            "Parses only"
        ]
    },
    {
        "q": "Match the os package:",
        "type": "match",
        "left": [
            "os.Args",
            "os.Getenv",
            "os.Exit",
            "os.Stdin"
        ],
        "right": [
            "CLI args",
            "Env vars",
            "Exit program",
            "Standard input"
        ]
    },
    {
        "q": "Which gets environment variable?",
        "type": "mcq",
        "o": [
            "os.Getenv",
            "os.Env",
            "os.GetVar",
            "env.Get"
        ]
    },
    {
        "q": "Arrange the CLI parsing:",
        "type": "rearrange",
        "words": [
            "Get os.Args",
            "Parse flags",
            "Validate input",
            "Execute command"
        ]
    },
    {
        "q": "The _____ exits with code.",
        "type": "fill_blank",
        "answers": [
            "os.Exit"
        ],
        "other_options": [
            "return",
            "panic",
            "exit"
        ]
    },
    {
        "q": "os.Args[0] is program name.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "port := os.Getenv(\"PORT\")\nif port == \"\" {\n    port = \"8080\"\n}",
        "o": [
            "Gets PORT or default",
            "Error",
            "nil",
            "8080 always"
        ]
    },
    {
        "q": "Match the flag package:",
        "type": "match",
        "left": [
            "flag.String",
            "flag.Int",
            "flag.Parse",
            "flag.Args"
        ],
        "right": [
            "String flag",
            "Int flag",
            "Parse flags",
            "Remaining args"
        ]
    },
    {
        "q": "Which parses command flags?",
        "type": "mcq",
        "o": [
            "flag.Parse()",
            "flag.Run()",
            "flag.Get()",
            "flags.Parse()"
        ]
    },
    {
        "q": "Arrange the flag definition:",
        "type": "rearrange",
        "words": [
            "Define flags",
            "flag.Parse()",
            "Use flag values",
            "Handle errors"
        ]
    },
    {
        "q": "The _____ defines string flag.",
        "type": "fill_blank",
        "answers": [
            "flag.String"
        ],
        "other_options": [
            "flag.Str",
            "flag.StringVar",
            "Both String and StringVar"
        ]
    },
    {
        "q": "flag.Parse() must be called.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "name := flag.String(\"name\", \"World\", \"Name to greet\")\nflag.Parse()\nfmt.Println(*name)",
        "o": [
            "Flag value",
            "Error",
            "nil",
            "name"
        ]
    },
    {
        "q": "Match the log package:",
        "type": "match",
        "left": [
            "log.Print",
            "log.Fatal",
            "log.Panic",
            "log.SetOutput"
        ],
        "right": [
            "Log message",
            "Log and exit",
            "Log and panic",
            "Set destination"
        ]
    },
    {
        "q": "Which logs and exits?",
        "type": "mcq",
        "o": [
            "log.Fatal",
            "log.Exit",
            "log.Die",
            "log.Panic"
        ]
    },
    {
        "q": "Arrange the logging setup:",
        "type": "rearrange",
        "words": [
            "Create file",
            "SetOutput",
            "Log messages",
            "Close file"
        ]
    },
    {
        "q": "The _____ logs and panics.",
        "type": "fill_blank",
        "answers": [
            "log.Panic"
        ],
        "other_options": [
            "log.Fatal",
            "log.Error",
            "log.Critical"
        ]
    },
    {
        "q": "log.Fatal calls os.Exit(1).",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "log.SetFlags(log.Ldate | log.Ltime)\nlog.Println(\"Hello\")",
        "o": [
            "Dated log",
            "Error",
            "nil",
            "Hello only"
        ]
    },
    {
        "q": "Match the regexp package:",
        "type": "match",
        "left": [
            "regexp.Compile",
            "MatchString",
            "FindString",
            "ReplaceAllString"
        ],
        "right": [
            "Create regex",
            "Check match",
            "Find first",
            "Replace all"
        ]
    },
    {
        "q": "Which compiles regex?",
        "type": "mcq",
        "o": [
            "regexp.Compile",
            "regexp.New",
            "regexp.Create",
            "regex.Compile"
        ]
    },
    {
        "q": "Arrange the regex usage:",
        "type": "rearrange",
        "words": [
            "Compile pattern",
            "Match string",
            "Find matches",
            "Get groups"
        ]
    },
    {
        "q": "The _____ panics on bad regex.",
        "type": "fill_blank",
        "answers": [
            "MustCompile"
        ],
        "other_options": [
            "Compile",
            "New",
            "Parse"
        ]
    },
    {
        "q": "regexp.MustCompile panics on error.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "re := regexp.MustCompile(`\\d+`)\nfmt.Println(re.FindString(\"abc123\"))",
        "o": [
            "123",
            "abc",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the crypto package:",
        "type": "match",
        "left": [
            "crypto/sha256",
            "crypto/md5",
            "crypto/rand",
            "crypto/aes"
        ],
        "right": [
            "SHA-256 hash",
            "MD5 hash",
            "Random bytes",
            "AES encrypt"
        ]
    },
    {
        "q": "Which generates secure random?",
        "type": "mcq",
        "o": [
            "crypto/rand",
            "math/rand",
            "random",
            "rand"
        ]
    },
    {
        "q": "Arrange the hashing:",
        "type": "rearrange",
        "words": [
            "Create hasher",
            "Write data",
            "Sum hash",
            "Encode result"
        ]
    },
    {
        "q": "The _____ is cryptographically secure.",
        "type": "fill_blank",
        "answers": [
            "crypto/rand"
        ],
        "other_options": [
            "math/rand",
            "random",
            "secure"
        ]
    },
    {
        "q": "math/rand is not secure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "h := sha256.New()\nh.Write([]byte(\"hello\"))\nhash := h.Sum(nil)",
        "o": [
            "SHA-256 hash",
            "Error",
            "nil",
            "hello"
        ]
    },
    {
        "q": "Match the encoding packages:",
        "type": "match",
        "left": [
            "encoding/json",
            "encoding/xml",
            "encoding/base64",
            "encoding/gob"
        ],
        "right": [
            "JSON",
            "XML",
            "Base64",
            "Go binary"
        ]
    },
    {
        "q": "Which handles XML?",
        "type": "mcq",
        "o": [
            "encoding/xml",
            "xml",
            "xmlparser",
            "goxml"
        ]
    },
    {
        "q": "Arrange the base64 encoding:",
        "type": "rearrange",
        "words": [
            "Get bytes",
            "Encode to string",
            "Decode back",
            "Use data"
        ]
    },
    {
        "q": "The _____ is Go-specific encoding.",
        "type": "fill_blank",
        "answers": [
            "gob"
        ],
        "other_options": [
            "json",
            "binary",
            "gobinary"
        ]
    },
    {
        "q": "gob is efficient for Go types.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "encoded := base64.StdEncoding.EncodeToString([]byte(\"hello\"))",
        "o": [
            "aGVsbG8=",
            "Error",
            "hello",
            "nil"
        ]
    },
    {
        "q": "Match the sort package:",
        "type": "match",
        "left": [
            "sort.Ints",
            "sort.Strings",
            "sort.Slice",
            "sort.Interface"
        ],
        "right": [
            "Sort ints",
            "Sort strings",
            "Custom sort",
            "Interface"
        ]
    },
    {
        "q": "Which sorts custom types?",
        "type": "mcq",
        "o": [
            "sort.Slice",
            "sort.Sort",
            "sort.Custom",
            "Both Slice and Sort"
        ]
    },
    {
        "q": "Arrange the custom sort:",
        "type": "rearrange",
        "words": [
            "Implement Interface",
            "Len() Swap() Less()",
            "Call sort.Sort",
            "Sorted slice"
        ]
    },
    {
        "q": "The _____ sorts with function.",
        "type": "fill_blank",
        "answers": [
            "sort.Slice"
        ],
        "other_options": [
            "sort.Sort",
            "sort.Func",
            "sort.By"
        ]
    },
    {
        "q": "sort.Interface requires 3 methods.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "nums := []int{3, 1, 2}\nsort.Ints(nums)\nfmt.Println(nums)",
        "o": [
            "[1 2 3]",
            "[3 1 2]",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the bytes package:",
        "type": "match",
        "left": [
            "bytes.Buffer",
            "bytes.Reader",
            "bytes.Contains",
            "bytes.Equal"
        ],
        "right": [
            "Read/write buffer",
            "Read bytes",
            "Check contains",
            "Compare bytes"
        ]
    },
    {
        "q": "Which is a buffer?",
        "type": "mcq",
        "o": [
            "bytes.Buffer",
            "bytes.Array",
            "bytes.Slice",
            "bytes.Stream"
        ]
    },
    {
        "q": "Arrange the buffer usage:",
        "type": "rearrange",
        "words": [
            "Create buffer",
            "Write bytes",
            "Read bytes",
            "Get all"
        ]
    },
    {
        "q": "The _____ efficiently builds bytes.",
        "type": "fill_blank",
        "answers": [
            "bytes.Buffer"
        ],
        "other_options": [
            "[]byte",
            "strings.Builder",
            "io.Buffer"
        ]
    },
    {
        "q": "bytes.Buffer implements io.Writer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var buf bytes.Buffer\nbuf.WriteString(\"hello\")\nfmt.Println(buf.String())",
        "o": [
            "hello",
            "Error",
            "nil",
            "bytes"
        ]
    },
    {
        "q": "Match the path package:",
        "type": "match",
        "left": [
            "path.Join",
            "path.Base",
            "path.Dir",
            "path/filepath"
        ],
        "right": [
            "Join paths",
            "Filename",
            "Directory",
            "OS paths"
        ]
    },
    {
        "q": "Which is OS-aware?",
        "type": "mcq",
        "o": [
            "path/filepath",
            "path",
            "os/path",
            "filepath"
        ]
    },
    {
        "q": "Arrange the path manipulation:",
        "type": "rearrange",
        "words": [
            "Get path",
            "Join parts",
            "Get base",
            "Get directory"
        ]
    },
    {
        "q": "The _____ gets filename.",
        "type": "fill_blank",
        "answers": [
            "filepath.Base"
        ],
        "other_options": [
            "filepath.Name",
            "filepath.File",
            "path.Base"
        ]
    },
    {
        "q": "path/filepath handles OS separators.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "p := filepath.Join(\"dir\", \"file.txt\")\nfmt.Println(p)",
        "o": [
            "dir/file.txt or dir\\file.txt",
            "Error",
            "nil",
            "dirfile.txt"
        ]
    },
    {
        "q": "Match the net package:",
        "type": "match",
        "left": [
            "net.Dial",
            "net.Listen",
            "net.Conn",
            "net.IP"
        ],
        "right": [
            "Connect",
            "Server socket",
            "Connection",
            "IP address"
        ]
    },
    {
        "q": "Which creates server socket?",
        "type": "mcq",
        "o": [
            "net.Listen",
            "net.Serve",
            "net.Server",
            "net.Socket"
        ]
    },
    {
        "q": "Arrange the TCP server:",
        "type": "rearrange",
        "words": [
            "Listen on port",
            "Accept connection",
            "Handle connection",
            "Close"
        ]
    },
    {
        "q": "The _____ connects to server.",
        "type": "fill_blank",
        "answers": [
            "net.Dial"
        ],
        "other_options": [
            "net.Connect",
            "net.Open",
            "net.Client"
        ]
    },
    {
        "q": "net.Conn is read/write interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ln, _ := net.Listen(\"tcp\", \":8080\")\nconn, _ := ln.Accept()",
        "o": [
            "Accepts connection",
            "Error",
            "nil",
            "Dials out"
        ]
    },
    {
        "q": "Match the atomic package:",
        "type": "match",
        "left": [
            "atomic.AddInt64",
            "atomic.LoadInt64",
            "atomic.StoreInt64",
            "atomic.CompareAndSwap"
        ],
        "right": [
            "Atomic add",
            "Atomic read",
            "Atomic write",
            "CAS"
        ]
    },
    {
        "q": "Which is thread-safe increment?",
        "type": "mcq",
        "o": [
            "atomic.AddInt64",
            "counter++",
            "sync.Add",
            "add()"
        ]
    },
    {
        "q": "Arrange the atomic operation:",
        "type": "rearrange",
        "words": [
            "Load value",
            "Compute new",
            "Compare and swap",
            "Retry if failed"
        ]
    },
    {
        "q": "The _____ atomically reads.",
        "type": "fill_blank",
        "answers": [
            "atomic.Load"
        ],
        "other_options": [
            "atomic.Get",
            "atomic.Read",
            "atomic.Fetch"
        ]
    },
    {
        "q": "Atomics are faster than mutexes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var counter int64\natomic.AddInt64(&counter, 1)\nfmt.Println(counter)",
        "o": [
            "1",
            "0",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the runtime package:",
        "type": "match",
        "left": [
            "runtime.GOMAXPROCS",
            "runtime.NumGoroutine",
            "runtime.GC",
            "runtime.Stack"
        ],
        "right": [
            "Set CPUs",
            "Goroutine count",
            "Force GC",
            "Stack trace"
        ]
    },
    {
        "q": "Which sets max CPUs?",
        "type": "mcq",
        "o": [
            "runtime.GOMAXPROCS",
            "runtime.SetCPU",
            "runtime.MaxProcs",
            "runtime.CPUs"
        ]
    },
    {
        "q": "Arrange the profiling setup:",
        "type": "rearrange",
        "words": [
            "Import runtime/pprof",
            "Create profile",
            "Write to file",
            "Analyze"
        ]
    },
    {
        "q": "The _____ returns goroutine count.",
        "type": "fill_blank",
        "answers": [
            "runtime.NumGoroutine"
        ],
        "other_options": [
            "runtime.GoroutineCount",
            "runtime.Goroutines",
            "runtime.Count"
        ]
    },
    {
        "q": "Go has garbage collection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "fmt.Println(runtime.NumGoroutine())",
        "o": [
            "Goroutine count",
            "Error",
            "nil",
            "1 always"
        ]
    },
    {
        "q": "Match the unsafe package:",
        "type": "match",
        "left": [
            "unsafe.Pointer",
            "unsafe.Sizeof",
            "unsafe.Offsetof",
            "uintptr"
        ],
        "right": [
            "Any pointer",
            "Type size",
            "Field offset",
            "Integer pointer"
        ]
    },
    {
        "q": "Which bypasses type safety?",
        "type": "mcq",
        "o": [
            "unsafe.Pointer",
            "interface{}",
            "any",
            "void*"
        ]
    },
    {
        "q": "unsafe package should be avoided.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go was created at Google.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go is compiled language.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The go command manages projects.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match the go commands:",
        "type": "match",
        "left": [
            "go build",
            "go run",
            "go mod",
            "go get"
        ],
        "right": [
            "Compile",
            "Build & run",
            "Modules",
            "Add dependency"
        ]
    },
    {
        "q": "Which compiles without running?",
        "type": "mcq",
        "o": [
            "go build",
            "go run",
            "go compile",
            "go make"
        ]
    },
    {
        "q": "Arrange the module creation:",
        "type": "rearrange",
        "words": [
            "go mod init",
            "Add dependencies",
            "go mod tidy",
            "go build"
        ]
    },
    {
        "q": "The _____ initializes module.",
        "type": "fill_blank",
        "answers": [
            "go mod init"
        ],
        "other_options": [
            "go init",
            "go new",
            "go create"
        ]
    },
    {
        "q": "go.mod defines module path.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go mod init example.com/myapp",
        "o": [
            "Creates go.mod",
            "Error",
            "nil",
            "Runs app"
        ]
    },
    {
        "q": "Match the module files:",
        "type": "match",
        "left": [
            "go.mod",
            "go.sum",
            "vendor/",
            "go.work"
        ],
        "right": [
            "Module def",
            "Checksums",
            "Dependencies",
            "Workspaces"
        ]
    },
    {
        "q": "Which stores checksums?",
        "type": "mcq",
        "o": [
            "go.sum",
            "go.mod",
            "go.lock",
            "checksums.txt"
        ]
    },
    {
        "q": "Arrange the dependency add:",
        "type": "rearrange",
        "words": [
            "go get package",
            "Update go.mod",
            "Download",
            "Use in code"
        ]
    },
    {
        "q": "The _____ cleans unused deps.",
        "type": "fill_blank",
        "answers": [
            "go mod tidy"
        ],
        "other_options": [
            "go clean",
            "go mod clean",
            "go tidy"
        ]
    },
    {
        "q": "Vendor directory is optional.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go mod tidy",
        "o": [
            "Cleans deps",
            "Error",
            "nil",
            "Builds"
        ]
    },
    {
        "q": "Match the build constraints:",
        "type": "match",
        "left": [
            "//go:build",
            "GOOS",
            "GOARCH",
            "CGO_ENABLED"
        ],
        "right": [
            "Build tag",
            "Target OS",
            "Architecture",
            "C interop"
        ]
    },
    {
        "q": "Which specifies target OS?",
        "type": "mcq",
        "o": [
            "GOOS",
            "OS",
            "TARGET_OS",
            "GO_OS"
        ]
    },
    {
        "q": "Arrange the cross-compile:",
        "type": "rearrange",
        "words": [
            "Set GOOS",
            "Set GOARCH",
            "go build",
            "Binary created"
        ]
    },
    {
        "q": "The _____ enables cgo.",
        "type": "fill_blank",
        "answers": [
            "CGO_ENABLED=1"
        ],
        "other_options": [
            "CGO=1",
            "ENABLE_CGO",
            "USE_CGO"
        ]
    },
    {
        "q": "Go supports cross-compilation.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "GOOS=linux GOARCH=amd64 go build",
        "o": [
            "Linux binary",
            "Error",
            "nil",
            "Windows binary"
        ]
    },
    {
        "q": "Match the benchmark concepts:",
        "type": "match",
        "left": [
            "b.N",
            "b.ReportAllocs",
            "b.ResetTimer",
            "go test -bench"
        ],
        "right": [
            "Iterations",
            "Memory report",
            "Reset timing",
            "Run benchmarks"
        ]
    },
    {
        "q": "Which runs benchmarks?",
        "type": "mcq",
        "o": [
            "go test -bench",
            "go bench",
            "go test -perf",
            "go performance"
        ]
    },
    {
        "q": "Arrange the benchmark:",
        "type": "rearrange",
        "words": [
            "func Benchmark",
            "Name(b *testing.B)",
            "for i := 0; i < b.N",
            "run code"
        ]
    },
    {
        "q": "The _____ is iteration count.",
        "type": "fill_blank",
        "answers": [
            "b.N"
        ],
        "other_options": [
            "b.Count",
            "b.Iterations",
            "b.Times"
        ]
    },
    {
        "q": "Benchmarks auto-adjust b.N.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func BenchmarkAdd(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        add(1, 2)\n    }\n}",
        "o": [
            "Benchmark function",
            "Error",
            "nil",
            "Test"
        ]
    },
    {
        "q": "Match the table tests:",
        "type": "match",
        "left": [
            "test case",
            "t.Run",
            "subtests",
            "parallel"
        ],
        "right": [
            "Input/output",
            "Named test",
            "Grouped tests",
            "t.Parallel"
        ]
    },
    {
        "q": "Which creates subtest?",
        "type": "mcq",
        "o": [
            "t.Run",
            "t.Sub",
            "t.Test",
            "t.Case"
        ]
    },
    {
        "q": "Arrange the table test:",
        "type": "rearrange",
        "words": [
            "Define test cases",
            "Loop cases",
            "t.Run each",
            "Check result"
        ]
    },
    {
        "q": "The _____ runs tests in parallel.",
        "type": "fill_blank",
        "answers": [
            "t.Parallel"
        ],
        "other_options": [
            "t.Concurrent",
            "t.Async",
            "t.Multi"
        ]
    },
    {
        "q": "Table tests reduce duplication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "cases := []struct{\n    input, want int\n}{{1, 2}, {2, 4}}\nfor _, tc := range cases {\n    t.Run(fmt.Sprintf(\"%d\", tc.input), func(t *testing.T) {})\n}",
        "o": [
            "Table test",
            "Error",
            "nil",
            "Single test"
        ]
    },
    {
        "q": "Match the mock patterns:",
        "type": "match",
        "left": [
            "interface",
            "test double",
            "fake",
            "stub"
        ],
        "right": [
            "Contract",
            "Replace impl",
            "Simple impl",
            "Fixed return"
        ]
    },
    {
        "q": "Which enables mocking?",
        "type": "mcq",
        "o": [
            "interface",
            "struct",
            "function",
            "module"
        ]
    },
    {
        "q": "Arrange the mock creation:",
        "type": "rearrange",
        "words": [
            "Define interface",
            "Create mock type",
            "Implement methods",
            "Use in test"
        ]
    },
    {
        "q": "The _____ replaces real impl.",
        "type": "fill_blank",
        "answers": [
            "mock"
        ],
        "other_options": [
            "fake",
            "stub",
            "double"
        ]
    },
    {
        "q": "Mocks verify interactions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type MockDB struct{}\nfunc (m *MockDB) Get(id int) string { return \"test\" }",
        "o": [
            "Mock implementation",
            "Error",
            "nil",
            "Real DB"
        ]
    },
    {
        "q": "Match the error wrapping:",
        "type": "match",
        "left": [
            "fmt.Errorf",
            "%w",
            "errors.Unwrap",
            "errors.Is"
        ],
        "right": [
            "Format error",
            "Wrap error",
            "Get wrapped",
            "Check error"
        ]
    },
    {
        "q": "Which wraps an error?",
        "type": "mcq",
        "o": [
            "%w",
            "%s",
            "%v",
            "%e"
        ]
    },
    {
        "q": "Arrange the error chain:",
        "type": "rearrange",
        "words": [
            "Get error",
            "Wrap with context",
            "Return wrapped",
            "Check with Is/As"
        ]
    },
    {
        "q": "The _____ checks error type.",
        "type": "fill_blank",
        "answers": [
            "errors.As"
        ],
        "other_options": [
            "errors.Is",
            "errors.Type",
            "errors.Cast"
        ]
    },
    {
        "q": "errors.Is checks equality.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "err := fmt.Errorf(\"failed: %w\", originalErr)",
        "o": [
            "Wrapped error",
            "Error",
            "nil",
            "String"
        ]
    },
    {
        "q": "Match the io interfaces:",
        "type": "match",
        "left": [
            "io.Reader",
            "io.Writer",
            "io.Closer",
            "io.ReadWriter"
        ],
        "right": [
            "Read bytes",
            "Write bytes",
            "Close resource",
            "Read & write"
        ]
    },
    {
        "q": "Which has Read method?",
        "type": "mcq",
        "o": [
            "io.Reader",
            "io.Input",
            "io.Stream",
            "io.Source"
        ]
    },
    {
        "q": "Arrange the streaming:",
        "type": "rearrange",
        "words": [
            "Get Reader",
            "Create buffer",
            "Read to buffer",
            "Process data"
        ]
    },
    {
        "q": "The _____ combines read/write.",
        "type": "fill_blank",
        "answers": [
            "io.ReadWriter"
        ],
        "other_options": [
            "io.ReadWrite",
            "io.RW",
            "io.Stream"
        ]
    },
    {
        "q": "io.Copy streams efficiently.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "io.Copy(dst, src)",
        "o": [
            "Copies bytes",
            "Error",
            "nil",
            "Reads only"
        ]
    },
    {
        "q": "Match the bufio package:",
        "type": "match",
        "left": [
            "bufio.Reader",
            "bufio.Scanner",
            "bufio.Writer",
            "ReadString"
        ],
        "right": [
            "Buffered read",
            "Line scanner",
            "Buffered write",
            "Read until delim"
        ]
    },
    {
        "q": "Which scans lines?",
        "type": "mcq",
        "o": [
            "bufio.Scanner",
            "bufio.Reader",
            "bufio.Lines",
            "io.Scanner"
        ]
    },
    {
        "q": "Arrange the line reading:",
        "type": "rearrange",
        "words": [
            "Create Scanner",
            "scanner.Scan()",
            "scanner.Text()",
            "Process line"
        ]
    },
    {
        "q": "The _____ reads buffered.",
        "type": "fill_blank",
        "answers": [
            "bufio.Reader"
        ],
        "other_options": [
            "io.Reader",
            "bytes.Reader",
            "file.Reader"
        ]
    },
    {
        "q": "Buffered I/O is faster.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "scanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n    fmt.Println(scanner.Text())\n}",
        "o": [
            "Reads lines",
            "Error",
            "nil",
            "Reads bytes"
        ]
    },
    {
        "q": "Match the http client:",
        "type": "match",
        "left": [
            "http.Get",
            "http.Post",
            "http.Client",
            "Transport"
        ],
        "right": [
            "Simple GET",
            "Simple POST",
            "Custom client",
            "Connection pool"
        ]
    },
    {
        "q": "Which is simple GET?",
        "type": "mcq",
        "o": [
            "http.Get",
            "http.Request",
            "http.Fetch",
            "http.Simple"
        ]
    },
    {
        "q": "Arrange the HTTP request:",
        "type": "rearrange",
        "words": [
            "Create request",
            "Set headers",
            "Send request",
            "Read response"
        ]
    },
    {
        "q": "The _____ manages connections.",
        "type": "fill_blank",
        "answers": [
            "http.Transport"
        ],
        "other_options": [
            "http.Pool",
            "http.Connection",
            "http.Client"
        ]
    },
    {
        "q": "Response body must be closed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "resp, _ := http.Get(url)\ndefer resp.Body.Close()\ndata, _ := io.ReadAll(resp.Body)",
        "o": [
            "HTTP response",
            "Error",
            "nil",
            "Request"
        ]
    },
    {
        "q": "Match the router packages:",
        "type": "match",
        "left": [
            "http.ServeMux",
            "gorilla/mux",
            "chi",
            "gin"
        ],
        "right": [
            "Standard",
            "Feature-rich",
            "Lightweight",
            "Fast"
        ]
    },
    {
        "q": "Which is stdlib router?",
        "type": "mcq",
        "o": [
            "http.ServeMux",
            "gorilla/mux",
            "chi",
            "echo"
        ]
    },
    {
        "q": "Arrange the router setup:",
        "type": "rearrange",
        "words": [
            "Create mux",
            "Register routes",
            "Add middleware",
            "Start server"
        ]
    },
    {
        "q": "The _____ extracts URL params.",
        "type": "fill_blank",
        "answers": [
            "mux.Vars"
        ],
        "other_options": [
            "r.Params",
            "url.Params",
            "http.Params"
        ]
    },
    {
        "q": "Chi supports middleware.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "r := mux.NewRouter()\nr.HandleFunc(\"/users/{id}\", handler)",
        "o": [
            "URL params route",
            "Error",
            "nil",
            "Static route"
        ]
    },
    {
        "q": "Match the websocket:",
        "type": "match",
        "left": [
            "gorilla/websocket",
            "Upgrader",
            "Conn",
            "ReadMessage"
        ],
        "right": [
            "WS package",
            "HTTP upgrade",
            "Connection",
            "Receive"
        ]
    },
    {
        "q": "Which upgrades to WebSocket?",
        "type": "mcq",
        "o": [
            "Upgrader",
            "Connector",
            "Handshaker",
            "Switcher"
        ]
    },
    {
        "q": "Arrange the WS connection:",
        "type": "rearrange",
        "words": [
            "Upgrade request",
            "Get connection",
            "Read/write messages",
            "Close connection"
        ]
    },
    {
        "q": "The _____ receives messages.",
        "type": "fill_blank",
        "answers": [
            "ReadMessage"
        ],
        "other_options": [
            "Receive",
            "GetMessage",
            "Read"
        ]
    },
    {
        "q": "WebSockets are full-duplex.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "conn, _ := upgrader.Upgrade(w, r, nil)\ndefer conn.Close()",
        "o": [
            "WebSocket conn",
            "Error",
            "nil",
            "HTTP conn"
        ]
    },
    {
        "q": "Match the gRPC concepts:",
        "type": "match",
        "left": [
            "protobuf",
            "service",
            "rpc",
            "stream"
        ],
        "right": [
            "Serialization",
            "API definition",
            "Method",
            "Bidirectional"
        ]
    },
    {
        "q": "Which defines services?",
        "type": "mcq",
        "o": [
            "protobuf",
            "JSON",
            "XML",
            "YAML"
        ]
    },
    {
        "q": "Arrange the gRPC setup:",
        "type": "rearrange",
        "words": [
            "Define proto",
            "Generate code",
            "Implement server",
            "Create client"
        ]
    },
    {
        "q": "The _____ generates Go code.",
        "type": "fill_blank",
        "answers": [
            "protoc"
        ],
        "other_options": [
            "grpc-gen",
            "proto-go",
            "generate"
        ]
    },
    {
        "q": "gRPC uses HTTP/2.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "service UserService {\n    rpc GetUser(UserRequest) returns (User);\n}",
        "o": [
            "gRPC service def",
            "Error",
            "nil",
            "REST"
        ]
    },
    {
        "q": "Match the CLI frameworks:",
        "type": "match",
        "left": [
            "cobra",
            "urfave/cli",
            "kingpin",
            "pflag"
        ],
        "right": [
            "Popular CLI",
            "Simple CLI",
            "Type-safe",
            "POSIX flags"
        ]
    },
    {
        "q": "Which is popular CLI lib?",
        "type": "mcq",
        "o": [
            "cobra",
            "flag",
            "argparse",
            "click"
        ]
    },
    {
        "q": "Arrange the cobra command:",
        "type": "rearrange",
        "words": [
            "Define root cmd",
            "Add sub commands",
            "Set flags",
            "Execute"
        ]
    },
    {
        "q": "The _____ adds subcommands.",
        "type": "fill_blank",
        "answers": [
            "AddCommand"
        ],
        "other_options": [
            "Add",
            "SubCommand",
            "Register"
        ]
    },
    {
        "q": "Cobra generates completion.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var rootCmd = &cobra.Command{\n    Use: \"app\",\n    Run: func(cmd *cobra.Command, args []string) {},\n}",
        "o": [
            "Cobra command",
            "Error",
            "nil",
            "Flag"
        ]
    },
    {
        "q": "Match the config libs:",
        "type": "match",
        "left": [
            "viper",
            "envconfig",
            "godotenv",
            "yaml"
        ],
        "right": [
            "All formats",
            "Env vars",
            "Dotenv",
            "YAML only"
        ]
    },
    {
        "q": "Which supports all formats?",
        "type": "mcq",
        "o": [
            "viper",
            "yaml",
            "json",
            "envconfig"
        ]
    },
    {
        "q": "Arrange the config loading:",
        "type": "rearrange",
        "words": [
            "Set config path",
            "Set config name",
            "Read config",
            "Use values"
        ]
    },
    {
        "q": "The _____ reads env vars.",
        "type": "fill_blank",
        "answers": [
            "viper.AutomaticEnv"
        ],
        "other_options": [
            "os.Getenv",
            "env.Load",
            "config.Env"
        ]
    },
    {
        "q": "Viper supports live reload.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "viper.SetConfigName(\"config\")\nviper.AddConfigPath(\".\")\nviper.ReadInConfig()",
        "o": [
            "Loads config",
            "Error",
            "nil",
            "Creates config"
        ]
    },
    {
        "q": "Match the logging libs:",
        "type": "match",
        "left": [
            "logrus",
            "zap",
            "zerolog",
            "slog"
        ],
        "right": [
            "Structured",
            "Fast",
            "Zero alloc",
            "Go 1.21 stdlib"
        ]
    },
    {
        "q": "Which is stdlib in Go 1.21?",
        "type": "mcq",
        "o": [
            "slog",
            "log",
            "logrus",
            "zap"
        ]
    },
    {
        "q": "Arrange the structured log:",
        "type": "rearrange",
        "words": [
            "Create logger",
            "Add fields",
            "Log message",
            "Output JSON"
        ]
    },
    {
        "q": "The _____ is zero-allocation.",
        "type": "fill_blank",
        "answers": [
            "zerolog"
        ],
        "other_options": [
            "logrus",
            "log",
            "zap"
        ]
    },
    {
        "q": "Zap is high performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "logger := zap.NewProduction()\nlogger.Info(\"message\", zap.String(\"key\", \"value\"))",
        "o": [
            "Structured log",
            "Error",
            "nil",
            "Plain log"
        ]
    },
    {
        "q": "Match the ORM packages:",
        "type": "match",
        "left": [
            "GORM",
            "sqlx",
            "ent",
            "sqlc"
        ],
        "right": [
            "Full ORM",
            "SQL extensions",
            "Entity framework",
            "Code gen"
        ]
    },
    {
        "q": "Which is full ORM?",
        "type": "mcq",
        "o": [
            "GORM",
            "sqlx",
            "sql",
            "database"
        ]
    },
    {
        "q": "Arrange the GORM query:",
        "type": "rearrange",
        "words": [
            "db.Model",
            "Where condition",
            "Find records",
            "Return result"
        ]
    },
    {
        "q": "The _____ extends database/sql.",
        "type": "fill_blank",
        "answers": [
            "sqlx"
        ],
        "other_options": [
            "GORM",
            "ent",
            "sql"
        ]
    },
    {
        "q": "GORM supports migrations.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var users []User\ndb.Where(\"age > ?\", 18).Find(&users)",
        "o": [
            "GORM query",
            "Error",
            "nil",
            "SQL"
        ]
    },
    {
        "q": "Match the validation:",
        "type": "match",
        "left": [
            "validator",
            "validate tag",
            "custom",
            "struct"
        ],
        "right": [
            "Validation lib",
            "Field rules",
            "Custom func",
            "Validate struct"
        ]
    },
    {
        "q": "Which validates structs?",
        "type": "mcq",
        "o": [
            "validator",
            "validate",
            "check",
            "verify"
        ]
    },
    {
        "q": "Arrange the validation:",
        "type": "rearrange",
        "words": [
            "Add validate tags",
            "Create validator",
            "Validate struct",
            "Handle errors"
        ]
    },
    {
        "q": "The _____ defines validation rules.",
        "type": "fill_blank",
        "answers": [
            "validate tag"
        ],
        "other_options": [
            "rule tag",
            "check tag",
            "valid tag"
        ]
    },
    {
        "q": "Tags are comma-separated.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "type User struct {\n    Email string `validate:\"required,email\"`\n}",
        "o": [
            "Validation tags",
            "Error",
            "nil",
            "Plain struct"
        ]
    },
    {
        "q": "Match the testing tools:",
        "type": "match",
        "left": [
            "testify",
            "gomock",
            "mockery",
            "go-cmp"
        ],
        "right": [
            "Assertions",
            "Mock gen",
            "Interface mocks",
            "Deep compare"
        ]
    },
    {
        "q": "Which provides assertions?",
        "type": "mcq",
        "o": [
            "testify",
            "testing",
            "assert",
            "check"
        ]
    },
    {
        "q": "Arrange the mock generation:",
        "type": "rearrange",
        "words": [
            "Define interface",
            "Run mockgen",
            "Get mock file",
            "Use in tests"
        ]
    },
    {
        "q": "The _____ compares deeply.",
        "type": "fill_blank",
        "answers": [
            "go-cmp"
        ],
        "other_options": [
            "reflect.DeepEqual",
            "== ",
            "compare"
        ]
    },
    {
        "q": "testify has require and assert.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "assert.Equal(t, expected, actual)",
        "o": [
            "Assertion",
            "Error",
            "nil",
            "Test fail"
        ]
    },
    {
        "q": "Match the concurrency patterns:",
        "type": "match",
        "left": [
            "worker pool",
            "fan-out",
            "fan-in",
            "pipeline"
        ],
        "right": [
            "Fixed workers",
            "Spread work",
            "Collect results",
            "Stage chain"
        ]
    },
    {
        "q": "Which collects results?",
        "type": "mcq",
        "o": [
            "fan-in",
            "fan-out",
            "merge",
            "collect"
        ]
    },
    {
        "q": "Arrange the worker pool:",
        "type": "rearrange",
        "words": [
            "Create workers",
            "Send jobs",
            "Process jobs",
            "Collect results"
        ]
    },
    {
        "q": "The _____ distributes work.",
        "type": "fill_blank",
        "answers": [
            "fan-out"
        ],
        "other_options": [
            "distribute",
            "spread",
            "broadcast"
        ]
    },
    {
        "q": "Pipelines chain stages.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "for i := 0; i < workers; i++ {\n    go worker(jobs, results)\n}",
        "o": [
            "Worker pool",
            "Error",
            "nil",
            "Single worker"
        ]
    },
    {
        "q": "Match the rate limiting:",
        "type": "match",
        "left": [
            "time.Ticker",
            "semaphore",
            "token bucket",
            "rate.Limiter"
        ],
        "right": [
            "Interval",
            "Max concurrent",
            "Algorithm",
            "Stdlib limiter"
        ]
    },
    {
        "q": "Which limits rate?",
        "type": "mcq",
        "o": [
            "rate.Limiter",
            "Ticker",
            "Timer",
            "Counter"
        ]
    },
    {
        "q": "Arrange the rate limiting:",
        "type": "rearrange",
        "words": [
            "Create limiter",
            "Wait for token",
            "Process request",
            "Return response"
        ]
    },
    {
        "q": "The _____ controls concurrency.",
        "type": "fill_blank",
        "answers": [
            "semaphore"
        ],
        "other_options": [
            "mutex",
            "channel",
            "limiter"
        ]
    },
    {
        "q": "Buffered channel limits concurrency.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "limiter := rate.NewLimiter(rate.Limit(10), 1)\nlimiter.Wait(ctx)",
        "o": [
            "Rate limited",
            "Error",
            "nil",
            "Unlimited"
        ]
    },
    {
        "q": "Match the memory concepts:",
        "type": "match",
        "left": [
            "heap",
            "stack",
            "escape analysis",
            "GC"
        ],
        "right": [
            "Dynamic alloc",
            "Local vars",
            "Heap decision",
            "Auto cleanup"
        ]
    },
    {
        "q": "Which is automatic cleanup?",
        "type": "mcq",
        "o": [
            "GC",
            "free",
            "delete",
            "release"
        ]
    },
    {
        "q": "Arrange the allocation:",
        "type": "rearrange",
        "words": [
            "Declare variable",
            "Escape analysis",
            "Allocate heap/stack",
            "Use memory"
        ]
    },
    {
        "q": "The _____ decides allocation.",
        "type": "fill_blank",
        "answers": [
            "escape analysis"
        ],
        "other_options": [
            "compiler",
            "runtime",
            "GC"
        ]
    },
    {
        "q": "Stack is faster than heap.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go build -gcflags=\"-m\" main.go",
        "o": [
            "Escape analysis output",
            "Error",
            "nil",
            "Normal build"
        ]
    },
    {
        "q": "Match the profiling:",
        "type": "match",
        "left": [
            "pprof",
            "cpu profile",
            "memory profile",
            "trace"
        ],
        "right": [
            "Profiling tool",
            "CPU usage",
            "Memory usage",
            "Execution trace"
        ]
    },
    {
        "q": "Which profiles memory?",
        "type": "mcq",
        "o": [
            "memory profile",
            "heap profile",
            "alloc profile",
            "ram profile"
        ]
    },
    {
        "q": "Arrange the profiling:",
        "type": "rearrange",
        "words": [
            "Import pprof",
            "Start profile",
            "Run code",
            "Analyze results"
        ]
    },
    {
        "q": "The _____ visualizes profiles.",
        "type": "fill_blank",
        "answers": [
            "go tool pprof"
        ],
        "other_options": [
            "pprof",
            "profile",
            "analyze"
        ]
    },
    {
        "q": "pprof has web interface.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "import _ \"net/http/pprof\"",
        "o": [
            "Enables HTTP pprof",
            "Error",
            "nil",
            "Disables"
        ]
    },
    {
        "q": "Match the embedding types:",
        "type": "match",
        "left": [
            "embed.FS",
            "//go:embed",
            "embed.String",
            "embed.Bytes"
        ],
        "right": [
            "File system",
            "Directive",
            "String file",
            "Byte file"
        ]
    },
    {
        "q": "Which embeds files?",
        "type": "mcq",
        "o": [
            "//go:embed",
            "import",
            "include",
            "require"
        ]
    },
    {
        "q": "Arrange the file embedding:",
        "type": "rearrange",
        "words": [
            "Add directive",
            "Declare variable",
            "Build binary",
            "Access file"
        ]
    },
    {
        "q": "The _____ is embedded filesystem.",
        "type": "fill_blank",
        "answers": [
            "embed.FS"
        ],
        "other_options": [
            "os.FS",
            "file.FS",
            "io.FS"
        ]
    },
    {
        "q": "Embed puts files in binary.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "//go:embed templates/*\nvar templates embed.FS",
        "o": [
            "Embeds templates",
            "Error",
            "nil",
            "Ignores"
        ]
    },
    {
        "q": "Match the testing coverage:",
        "type": "match",
        "left": [
            "-cover",
            "-coverprofile",
            "-covermode",
            "go tool cover"
        ],
        "right": [
            "Show coverage",
            "Save profile",
            "Count mode",
            "View HTML"
        ]
    },
    {
        "q": "Which shows coverage?",
        "type": "mcq",
        "o": [
            "-cover",
            "-cov",
            "-coverage",
            "-percent"
        ]
    },
    {
        "q": "Arrange the coverage report:",
        "type": "rearrange",
        "words": [
            "Run with -coverprofile",
            "Generate profile",
            "go tool cover -html",
            "View report"
        ]
    },
    {
        "q": "The _____ generates HTML.",
        "type": "fill_blank",
        "answers": [
            "go tool cover"
        ],
        "other_options": [
            "go cover",
            "coverage",
            "report"
        ]
    },
    {
        "q": "100% coverage is not always needed.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go test -coverprofile=coverage.out",
        "o": [
            "Creates profile",
            "Error",
            "nil",
            "Runs tests only"
        ]
    },
    {
        "q": "Match the fuzzing:",
        "type": "match",
        "left": [
            "go test -fuzz",
            "FuzzXxx",
            "f.Fuzz",
            "corpus"
        ],
        "right": [
            "Run fuzzing",
            "Fuzz function",
            "Define target",
            "Test cases"
        ]
    },
    {
        "q": "Which runs fuzz tests?",
        "type": "mcq",
        "o": [
            "go test -fuzz",
            "go fuzz",
            "go test -random",
            "go test -chaos"
        ]
    },
    {
        "q": "Arrange the fuzz test:",
        "type": "rearrange",
        "words": [
            "func Fuzz",
            "Name(f *testing.F)",
            "Add seeds",
            "f.Fuzz target"
        ]
    },
    {
        "q": "The _____ stores test cases.",
        "type": "fill_blank",
        "answers": [
            "corpus"
        ],
        "other_options": [
            "seeds",
            "cases",
            "inputs"
        ]
    },
    {
        "q": "Go 1.18 added fuzzing.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func FuzzReverse(f *testing.F) {\n    f.Fuzz(func(t *testing.T, s string) { Reverse(s) })\n}",
        "o": [
            "Fuzz test",
            "Error",
            "nil",
            "Unit test"
        ]
    },
    {
        "q": "Match the observability:",
        "type": "match",
        "left": [
            "metrics",
            "tracing",
            "logging",
            "OpenTelemetry"
        ],
        "right": [
            "Numbers",
            "Request flow",
            "Text output",
            "Standard API"
        ]
    },
    {
        "q": "Which tracks request flow?",
        "type": "mcq",
        "o": [
            "tracing",
            "metrics",
            "logging",
            "monitoring"
        ]
    },
    {
        "q": "Arrange the tracing:",
        "type": "rearrange",
        "words": [
            "Start span",
            "Add attributes",
            "Propagate context",
            "End span"
        ]
    },
    {
        "q": "The _____ is observability standard.",
        "type": "fill_blank",
        "answers": [
            "OpenTelemetry"
        ],
        "other_options": [
            "Prometheus",
            "Jaeger",
            "Zipkin"
        ]
    },
    {
        "q": "Metrics are numbers.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ctx, span := tracer.Start(ctx, \"operation\")\ndefer span.End()",
        "o": [
            "Creates span",
            "Error",
            "nil",
            "Logs message"
        ]
    },
    {
        "q": "Match the deployment:",
        "type": "match",
        "left": [
            "Docker",
            "Kubernetes",
            "systemd",
            "Supervisor"
        ],
        "right": [
            "Container",
            "Orchestration",
            "Linux service",
            "Process manager"
        ]
    },
    {
        "q": "Which is container platform?",
        "type": "mcq",
        "o": [
            "Docker",
            "VM",
            "Hypervisor",
            "Bare metal"
        ]
    },
    {
        "q": "Arrange the containerization:",
        "type": "rearrange",
        "words": [
            "Write Dockerfile",
            "Build image",
            "Push registry",
            "Deploy container"
        ]
    },
    {
        "q": "The _____ orchestrates containers.",
        "type": "fill_blank",
        "answers": [
            "Kubernetes"
        ],
        "other_options": [
            "Docker Compose",
            "Swarm",
            "Mesos"
        ]
    },
    {
        "q": "Go binaries are static.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "FROM scratch\nCOPY app /\nCMD [\"/app\"]",
        "o": [
            "Minimal Dockerfile",
            "Error",
            "nil",
            "Full image"
        ]
    },
    {
        "q": "Match the security:",
        "type": "match",
        "left": [
            "html/template",
            "crypto/tls",
            "bcrypt",
            "jwt"
        ],
        "right": [
            "XSS safe",
            "HTTPS",
            "Password hash",
            "Token auth"
        ]
    },
    {
        "q": "Which prevents XSS?",
        "type": "mcq",
        "o": [
            "html/template",
            "text/template",
            "escaping",
            "sanitize"
        ]
    },
    {
        "q": "Arrange the HTTPS setup:",
        "type": "rearrange",
        "words": [
            "Get certificate",
            "Load cert/key",
            "Configure TLS",
            "ListenAndServeTLS"
        ]
    },
    {
        "q": "The _____ hashes passwords.",
        "type": "fill_blank",
        "answers": [
            "bcrypt"
        ],
        "other_options": [
            "md5",
            "sha256",
            "argon2"
        ]
    },
    {
        "q": "Never store plain passwords.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)",
        "o": [
            "Password hash",
            "Error",
            "nil",
            "Plain text"
        ]
    },
    {
        "q": "Match the caching:",
        "type": "match",
        "left": [
            "sync.Map",
            "go-cache",
            "groupcache",
            "bigcache"
        ],
        "right": [
            "Concurrent map",
            "In-memory",
            "Distributed",
            "Fast cache"
        ]
    },
    {
        "q": "Which is concurrent safe map?",
        "type": "mcq",
        "o": [
            "sync.Map",
            "map",
            "cache",
            "store"
        ]
    },
    {
        "q": "Arrange the cache usage:",
        "type": "rearrange",
        "words": [
            "Check cache",
            "Return if found",
            "Compute value",
            "Store in cache"
        ]
    },
    {
        "q": "The _____ is distributed cache.",
        "type": "fill_blank",
        "answers": [
            "groupcache"
        ],
        "other_options": [
            "go-cache",
            "sync.Map",
            "redis"
        ]
    },
    {
        "q": "Caching improves performance.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "cache := cache.New(5*time.Minute, 10*time.Minute)\ncache.Set(\"key\", value, cache.DefaultExpiration)",
        "o": [
            "Caches value",
            "Error",
            "nil",
            "Deletes"
        ]
    },
    {
        "q": "Go supports generics since 1.18.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The blank identifier is _.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go has no exceptions.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which creates goroutine?",
        "type": "mcq",
        "o": [
            "go keyword",
            "thread.new",
            "async",
            "spawn"
        ]
    },
    {
        "q": "Go has garbage collection.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Channels are typed conduits.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match the slice internals:",
        "type": "match",
        "left": [
            "pointer",
            "length",
            "capacity",
            "backing array"
        ],
        "right": [
            "Data address",
            "Current size",
            "Max size",
            "Underlying data"
        ]
    },
    {
        "q": "Which stores current elements?",
        "type": "mcq",
        "o": [
            "length",
            "capacity",
            "size",
            "count"
        ]
    },
    {
        "q": "Arrange the slice growth:",
        "type": "rearrange",
        "words": [
            "Append element",
            "Check capacity",
            "Allocate new array",
            "Copy elements"
        ]
    },
    {
        "q": "The _____ is maximum elements.",
        "type": "fill_blank",
        "answers": [
            "capacity"
        ],
        "other_options": [
            "length",
            "size",
            "max"
        ]
    },
    {
        "q": "Slices share backing array.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "s := make([]int, 3, 5)\nfmt.Println(len(s), cap(s))",
        "o": [
            "3 5",
            "5 3",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the map internals:",
        "type": "match",
        "left": [
            "hash function",
            "bucket",
            "overflow",
            "load factor"
        ],
        "right": [
            "Key to index",
            "Storage unit",
            "Extra storage",
            "Resize trigger"
        ]
    },
    {
        "q": "Which triggers resize?",
        "type": "mcq",
        "o": [
            "load factor",
            "size",
            "count",
            "capacity"
        ]
    },
    {
        "q": "Arrange the map lookup:",
        "type": "rearrange",
        "words": [
            "Hash key",
            "Find bucket",
            "Search bucket",
            "Return value"
        ]
    },
    {
        "q": "The _____ distributes keys.",
        "type": "fill_blank",
        "answers": [
            "hash function"
        ],
        "other_options": [
            "bucket",
            "index",
            "algorithm"
        ]
    },
    {
        "q": "Map iteration order is random.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "m := make(map[string]int)\nm[\"key\"] = 1\nv, ok := m[\"key\"]",
        "o": [
            "1, true",
            "1, false",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the interface internals:",
        "type": "match",
        "left": [
            "type",
            "data",
            "method table",
            "nil interface"
        ],
        "right": [
            "Concrete type",
            "Value pointer",
            "Methods",
            "Both nil"
        ]
    },
    {
        "q": "Which stores concrete type?",
        "type": "mcq",
        "o": [
            "type field",
            "data field",
            "method table",
            "interface"
        ]
    },
    {
        "q": "Arrange the interface assignment:",
        "type": "rearrange",
        "words": [
            "Create value",
            "Assign to interface",
            "Store type info",
            "Store data"
        ]
    },
    {
        "q": "The _____ contains method pointers.",
        "type": "fill_blank",
        "answers": [
            "method table"
        ],
        "other_options": [
            "interface",
            "type",
            "data"
        ]
    },
    {
        "q": "Empty interface holds any type.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var i interface{} = 42\nv := i.(int)",
        "o": [
            "42",
            "Error",
            "nil",
            "interface"
        ]
    },
    {
        "q": "Match the channel internals:",
        "type": "match",
        "left": [
            "buffer",
            "sendx",
            "recvx",
            "lock"
        ],
        "right": [
            "Storage",
            "Send index",
            "Receive index",
            "Synchronization"
        ]
    },
    {
        "q": "Which synchronizes access?",
        "type": "mcq",
        "o": [
            "lock",
            "mutex",
            "sync",
            "buffer"
        ]
    },
    {
        "q": "Arrange the channel send:",
        "type": "rearrange",
        "words": [
            "Acquire lock",
            "Check buffer",
            "Copy value",
            "Release lock"
        ]
    },
    {
        "q": "The _____ tracks send position.",
        "type": "fill_blank",
        "answers": [
            "sendx"
        ],
        "other_options": [
            "recvx",
            "index",
            "position"
        ]
    },
    {
        "q": "Unbuffered channels block.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ch := make(chan int, 1)\nch <- 42\nfmt.Println(<-ch)",
        "o": [
            "42",
            "Error",
            "nil",
            "deadlock"
        ]
    },
    {
        "q": "Match the GC phases:",
        "type": "match",
        "left": [
            "mark",
            "sweep",
            "STW",
            "concurrent"
        ],
        "right": [
            "Find live",
            "Free dead",
            "Stop world",
            "Background"
        ]
    },
    {
        "q": "Which finds live objects?",
        "type": "mcq",
        "o": [
            "mark phase",
            "sweep phase",
            "collect phase",
            "scan phase"
        ]
    },
    {
        "q": "Arrange the GC cycle:",
        "type": "rearrange",
        "words": [
            "Trigger GC",
            "Mark phase",
            "Sweep phase",
            "Resume"
        ]
    },
    {
        "q": "The _____ frees memory.",
        "type": "fill_blank",
        "answers": [
            "sweep phase"
        ],
        "other_options": [
            "mark phase",
            "free phase",
            "collect phase"
        ]
    },
    {
        "q": "Go GC is mostly concurrent.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "runtime.GC()",
        "o": [
            "Forces GC",
            "Error",
            "nil",
            "Disables GC"
        ]
    },
    {
        "q": "Match the scheduler concepts:",
        "type": "match",
        "left": [
            "G",
            "M",
            "P",
            "GOMAXPROCS"
        ],
        "right": [
            "Goroutine",
            "OS thread",
            "Processor",
            "Max Ps"
        ]
    },
    {
        "q": "Which is OS thread?",
        "type": "mcq",
        "o": [
            "M",
            "G",
            "P",
            "Thread"
        ]
    },
    {
        "q": "Arrange the scheduling:",
        "type": "rearrange",
        "words": [
            "Create G",
            "Assign to P",
            "M executes",
            "Context switch"
        ]
    },
    {
        "q": "The _____ is logical processor.",
        "type": "fill_blank",
        "answers": [
            "P"
        ],
        "other_options": [
            "G",
            "M",
            "CPU"
        ]
    },
    {
        "q": "Go uses M:N scheduling.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "runtime.GOMAXPROCS(4)",
        "o": [
            "Sets 4 Ps",
            "Error",
            "nil",
            "Sets 4 Ms"
        ]
    },
    {
        "q": "Match the stack concepts:",
        "type": "match",
        "left": [
            "goroutine stack",
            "stack growth",
            "2KB",
            "segmented"
        ],
        "right": [
            "Per-goroutine",
            "Dynamic",
            "Initial size",
            "Old method"
        ]
    },
    {
        "q": "What is initial stack size?",
        "type": "mcq",
        "o": [
            "2KB",
            "1KB",
            "4KB",
            "8KB"
        ]
    },
    {
        "q": "Arrange the stack growth:",
        "type": "rearrange",
        "words": [
            "Stack check",
            "Need more space",
            "Allocate larger",
            "Copy stack"
        ]
    },
    {
        "q": "The _____ stacks grow dynamically.",
        "type": "fill_blank",
        "answers": [
            "goroutine"
        ],
        "other_options": [
            "OS thread",
            "process",
            "main"
        ]
    },
    {
        "q": "Goroutine stacks are small initially.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go func() { /* work */ }()",
        "o": [
            "New goroutine",
            "Error",
            "nil",
            "New thread"
        ]
    },
    {
        "q": "Match the preemption:",
        "type": "match",
        "left": [
            "cooperative",
            "async",
            "signal",
            "safepoint"
        ],
        "right": [
            "Yield points",
            "Go 1.14+",
            "SIGURG",
            "Check point"
        ]
    },
    {
        "q": "Which Go version added async preemption?",
        "type": "mcq",
        "o": [
            "1.14",
            "1.12",
            "1.16",
            "1.18"
        ]
    },
    {
        "q": "Arrange the preemption:",
        "type": "rearrange",
        "words": [
            "Long running G",
            "Send signal",
            "Handle signal",
            "Context switch"
        ]
    },
    {
        "q": "The _____ preemption uses signals.",
        "type": "fill_blank",
        "answers": [
            "async"
        ],
        "other_options": [
            "cooperative",
            "manual",
            "forced"
        ]
    },
    {
        "q": "Async preemption prevents hogging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "for { /* infinite loop */ }",
        "o": [
            "Now preemptible",
            "Before 1.14 hogged",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the testing setup:",
        "type": "match",
        "left": [
            "TestMain",
            "setup",
            "teardown",
            "os.Exit"
        ],
        "right": [
            "Entry point",
            "Before tests",
            "After tests",
            "Exit code"
        ]
    },
    {
        "q": "Which controls test execution?",
        "type": "mcq",
        "o": [
            "TestMain",
            "TestSetup",
            "TestInit",
            "TestStart"
        ]
    },
    {
        "q": "Arrange the TestMain:",
        "type": "rearrange",
        "words": [
            "Setup",
            "m.Run()",
            "Teardown",
            "os.Exit"
        ]
    },
    {
        "q": "The _____ runs all tests.",
        "type": "fill_blank",
        "answers": [
            "m.Run()"
        ],
        "other_options": [
            "testing.Run",
            "test.Run",
            "run()"
        ]
    },
    {
        "q": "TestMain is optional.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func TestMain(m *testing.M) {\n    setup()\n    code := m.Run()\n    teardown()\n    os.Exit(code)\n}",
        "o": [
            "Test lifecycle",
            "Error",
            "nil",
            "Single test"
        ]
    },
    {
        "q": "Match the build modes:",
        "type": "match",
        "left": [
            "default",
            "plugin",
            "c-shared",
            "c-archive"
        ],
        "right": [
            "Executable",
            "Go plugin",
            "Shared lib",
            "Static lib"
        ]
    },
    {
        "q": "Which creates shared library?",
        "type": "mcq",
        "o": [
            "c-shared",
            "plugin",
            "shared",
            "library"
        ]
    },
    {
        "q": "Arrange the plugin usage:",
        "type": "rearrange",
        "words": [
            "Build plugin",
            "Load plugin",
            "Lookup symbol",
            "Call function"
        ]
    },
    {
        "q": "The _____ creates Go plugins.",
        "type": "fill_blank",
        "answers": [
            "plugin"
        ],
        "other_options": [
            "c-shared",
            "shared",
            "module"
        ]
    },
    {
        "q": "Plugins work on Linux.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "go build -buildmode=plugin -o plugin.so",
        "o": [
            "Creates plugin",
            "Error",
            "nil",
            "Creates exe"
        ]
    },
    {
        "q": "Match the cgo concepts:",
        "type": "match",
        "left": [
            "import C",
            "CFLAGS",
            "LDFLAGS",
            "//export"
        ],
        "right": [
            "Enable cgo",
            "Compiler flags",
            "Linker flags",
            "Export Go func"
        ]
    },
    {
        "q": "Which enables cgo?",
        "type": "mcq",
        "o": [
            "import \"C\"",
            "import cgo",
            "use cgo",
            "enable cgo"
        ]
    },
    {
        "q": "Arrange the cgo call:",
        "type": "rearrange",
        "words": [
            "Import C",
            "Call C.func",
            "Pass args",
            "Get result"
        ]
    },
    {
        "q": "The _____ sets compiler flags.",
        "type": "fill_blank",
        "answers": [
            "CFLAGS"
        ],
        "other_options": [
            "LDFLAGS",
            "FLAGS",
            "CXXFLAGS"
        ]
    },
    {
        "q": "cgo has overhead.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "// #include <stdio.h>\nimport \"C\"",
        "o": [
            "Enables cgo",
            "Error",
            "nil",
            "Disables"
        ]
    },
    {
        "q": "Match the sync.Pool:",
        "type": "match",
        "left": [
            "Get",
            "Put",
            "New",
            "reuse"
        ],
        "right": [
            "Get object",
            "Return object",
            "Factory func",
            "Reduce allocs"
        ]
    },
    {
        "q": "Which returns object to pool?",
        "type": "mcq",
        "o": [
            "Put",
            "Return",
            "Release",
            "Free"
        ]
    },
    {
        "q": "Arrange the pool usage:",
        "type": "rearrange",
        "words": [
            "Create pool",
            "Get object",
            "Use object",
            "Put back"
        ]
    },
    {
        "q": "The _____ creates new objects.",
        "type": "fill_blank",
        "answers": [
            "New function"
        ],
        "other_options": [
            "Create",
            "Factory",
            "Make"
        ]
    },
    {
        "q": "sync.Pool reduces GC pressure.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "pool := &sync.Pool{New: func() any { return new(Buffer) }}\nbuf := pool.Get().(*Buffer)",
        "o": [
            "Gets buffer",
            "Error",
            "nil",
            "Creates only"
        ]
    },
    {
        "q": "Match the sync.Once:",
        "type": "match",
        "left": [
            "Do",
            "once",
            "initialization",
            "singleton"
        ],
        "right": [
            "Execute func",
            "sync.Once",
            "One-time setup",
            "Pattern"
        ]
    },
    {
        "q": "Which runs function once?",
        "type": "mcq",
        "o": [
            "once.Do",
            "once.Run",
            "once.Call",
            "once.Exec"
        ]
    },
    {
        "q": "Arrange the once usage:",
        "type": "rearrange",
        "words": [
            "Declare once",
            "once.Do(func)",
            "Function runs once",
            "Subsequent calls skip"
        ]
    },
    {
        "q": "The _____ ensures single execution.",
        "type": "fill_blank",
        "answers": [
            "sync.Once"
        ],
        "other_options": [
            "sync.Do",
            "once",
            "single"
        ]
    },
    {
        "q": "sync.Once is goroutine-safe.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var once sync.Once\nonce.Do(initialize)",
        "o": [
            "Runs once",
            "Error",
            "nil",
            "Runs always"
        ]
    },
    {
        "q": "Match the sync.Cond:",
        "type": "match",
        "left": [
            "Wait",
            "Signal",
            "Broadcast",
            "L"
        ],
        "right": [
            "Block",
            "Wake one",
            "Wake all",
            "Locker"
        ]
    },
    {
        "q": "Which wakes all waiters?",
        "type": "mcq",
        "o": [
            "Broadcast",
            "Signal",
            "WakeAll",
            "NotifyAll"
        ]
    },
    {
        "q": "Arrange the condition variable:",
        "type": "rearrange",
        "words": [
            "Lock mutex",
            "Check condition",
            "Wait if false",
            "Signal when true"
        ]
    },
    {
        "q": "The _____ wakes one waiter.",
        "type": "fill_blank",
        "answers": [
            "Signal"
        ],
        "other_options": [
            "Broadcast",
            "Wake",
            "Notify"
        ]
    },
    {
        "q": "sync.Cond requires mutex.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "cond := sync.NewCond(&sync.Mutex{})\ncond.L.Lock()\ncond.Wait()",
        "o": [
            "Waits for signal",
            "Error",
            "nil",
            "Returns immediately"
        ]
    },
    {
        "q": "Match the atomics types:",
        "type": "match",
        "left": [
            "atomic.Int64",
            "atomic.Bool",
            "atomic.Pointer",
            "atomic.Value"
        ],
        "right": [
            "Int counter",
            "Boolean",
            "Type-safe ptr",
            "Any value"
        ]
    },
    {
        "q": "Which stores any value?",
        "type": "mcq",
        "o": [
            "atomic.Value",
            "atomic.Any",
            "atomic.Interface",
            "atomic.Object"
        ]
    },
    {
        "q": "Arrange the atomic counter:",
        "type": "rearrange",
        "words": [
            "Declare atomic.Int64",
            "Add value",
            "Load value",
            "Store value"
        ]
    },
    {
        "q": "The _____ is typed pointer.",
        "type": "fill_blank",
        "answers": [
            "atomic.Pointer"
        ],
        "other_options": [
            "atomic.Value",
            "atomic.Ref",
            "atomic.Ptr"
        ]
    },
    {
        "q": "New atomic types are in Go 1.19+.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "var counter atomic.Int64\ncounter.Add(1)\nfmt.Println(counter.Load())",
        "o": [
            "1",
            "0",
            "Error",
            "nil"
        ]
    },
    {
        "q": "Match the generic constraints:",
        "type": "match",
        "left": [
            "any",
            "comparable",
            "constraints.Ordered",
            "~int"
        ],
        "right": [
            "No constraint",
            "== support",
            "< > support",
            "Underlying int"
        ]
    },
    {
        "q": "Which allows comparison?",
        "type": "mcq",
        "o": [
            "constraints.Ordered",
            "comparable",
            "any",
            "sortable"
        ]
    },
    {
        "q": "Arrange the generic function:",
        "type": "rearrange",
        "words": [
            "Define type param",
            "Add constraint",
            "Use in function",
            "Call with type"
        ]
    },
    {
        "q": "The _____ matches underlying type.",
        "type": "fill_blank",
        "answers": [
            "~"
        ],
        "other_options": [
            "*",
            "&",
            "@"
        ]
    },
    {
        "q": "Generics reduce code duplication.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func Min[T constraints.Ordered](a, b T) T {\n    if a < b { return a }\n    return b\n}",
        "o": [
            "Generic min",
            "Error",
            "nil",
            "Non-generic"
        ]
    },
    {
        "q": "Go uses CSP model.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go fmt formats code.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go vet finds bugs.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which formats Go code?",
        "type": "mcq",
        "o": [
            "go fmt",
            "go format",
            "go style",
            "go lint"
        ]
    },
    {
        "q": "Go was released in 2009.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go is open source.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The go keyword creates goroutine.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match the error types:",
        "type": "match",
        "left": [
            "error",
            "panic",
            "recover",
            "log.Fatal"
        ],
        "right": [
            "Return value",
            "Runtime crash",
            "Handle panic",
            "Log and exit"
        ]
    },
    {
        "q": "Which causes runtime crash?",
        "type": "mcq",
        "o": [
            "panic",
            "error",
            "fatal",
            "crash"
        ]
    },
    {
        "q": "Arrange the error handling:",
        "type": "rearrange",
        "words": [
            "Call function",
            "Check error",
            "Handle or return",
            "Continue"
        ]
    },
    {
        "q": "The _____ recovers from panic.",
        "type": "fill_blank",
        "answers": [
            "recover"
        ],
        "other_options": [
            "catch",
            "handle",
            "try"
        ]
    },
    {
        "q": "recover only works in defer.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Match the testing utilities:",
        "type": "match",
        "left": [
            "t.Helper",
            "t.Cleanup",
            "t.Setenv",
            "t.TempDir"
        ],
        "right": [
            "Mark helper",
            "Cleanup func",
            "Set env var",
            "Temp directory"
        ]
    },
    {
        "q": "Which marks test helper?",
        "type": "mcq",
        "o": [
            "t.Helper",
            "t.Mark",
            "t.Util",
            "t.Func"
        ]
    },
    {
        "q": "Arrange the helper usage:",
        "type": "rearrange",
        "words": [
            "func helper(t *testing.T)",
            "t.Helper()",
            "Do assertion",
            "Report error"
        ]
    },
    {
        "q": "The _____ creates temp directory.",
        "type": "fill_blank",
        "answers": [
            "t.TempDir"
        ],
        "other_options": [
            "os.TempDir",
            "ioutil.TempDir",
            "tempdir"
        ]
    },
    {
        "q": "t.Cleanup runs after test.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "t.Setenv(\"KEY\", \"value\")",
        "o": [
            "Sets env for test",
            "Error",
            "nil",
            "Global set"
        ]
    },
    {
        "q": "Match the networking:",
        "type": "match",
        "left": [
            "tcp",
            "udp",
            "unix",
            "grpc"
        ],
        "right": [
            "Reliable",
            "Fast",
            "Local socket",
            "RPC proto"
        ]
    },
    {
        "q": "Which is connection-oriented?",
        "type": "mcq",
        "o": [
            "tcp",
            "udp",
            "both",
            "neither"
        ]
    },
    {
        "q": "Arrange the TCP server:",
        "type": "rearrange",
        "words": [
            "net.Listen",
            "Accept",
            "Handle conn",
            "Close"
        ]
    },
    {
        "q": "The _____ is unreliable protocol.",
        "type": "fill_blank",
        "answers": [
            "UDP"
        ],
        "other_options": [
            "TCP",
            "HTTP",
            "GRPC"
        ]
    },
    {
        "q": "Unix sockets are local only.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "ln, _ := net.Listen(\"tcp\", \":8080\")",
        "o": [
            "TCP listener",
            "Error",
            "nil",
            "UDP listener"
        ]
    },
    {
        "q": "Match the debugging:",
        "type": "match",
        "left": [
            "delve",
            "gdb",
            "print",
            "log"
        ],
        "right": [
            "Go debugger",
            "C debugger",
            "Quick debug",
            "Logging"
        ]
    },
    {
        "q": "Which is Go debugger?",
        "type": "mcq",
        "o": [
            "delve",
            "gdb",
            "lldb",
            "debugger"
        ]
    },
    {
        "q": "Arrange the debugging:",
        "type": "rearrange",
        "words": [
            "dlv debug",
            "Set breakpoint",
            "Continue",
            "Inspect vars"
        ]
    },
    {
        "q": "The _____ command starts debugger.",
        "type": "fill_blank",
        "answers": [
            "dlv debug"
        ],
        "other_options": [
            "go debug",
            "debug go",
            "dlv start"
        ]
    },
    {
        "q": "Delve supports remote debugging.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "dlv attach <pid>",
        "o": [
            "Attaches debugger",
            "Error",
            "nil",
            "Starts new"
        ]
    },
    {
        "q": "Match the best practices:",
        "type": "match",
        "left": [
            "small interfaces",
            "accept interfaces",
            "return structs",
            "error handling"
        ],
        "right": [
            "Few methods",
            "Flexibility",
            "Concrete types",
            "Check all errors"
        ]
    },
    {
        "q": "Which accepts interfaces?",
        "type": "mcq",
        "o": [
            "Functions",
            "Structs",
            "Methods",
            "Variables"
        ]
    },
    {
        "q": "Arrange the interface design:",
        "type": "rearrange",
        "words": [
            "Define small interface",
            "Accept interface param",
            "Return concrete type",
            "Caller decides"
        ]
    },
    {
        "q": "The _____ principle applies.",
        "type": "fill_blank",
        "answers": [
            "accept interfaces"
        ],
        "other_options": [
            "return interfaces",
            "use interfaces",
            "define interfaces"
        ]
    },
    {
        "q": "Small interfaces are better.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "What is the output of this code?",
        "type": "mcq",
        "c": "func Process(r io.Reader) { io.Copy(os.Stdout, r) }",
        "o": [
            "Accepts interface",
            "Error",
            "nil",
            "Returns interface"
        ]
    },
    {
        "q": "Go favors composition.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go has no classes.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go code is formatted by gofmt.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Which checks Go code style?",
        "type": "mcq",
        "o": [
            "golint",
            "gofmt",
            "govet",
            "gocheck"
        ]
    },
    {
        "q": "Go modules replaced GOPATH.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "The defer keyword delays execution.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go supports method overloading.",
        "type": "true_false",
        "correct": "False"
    },
    {
        "q": "Go uses interfaces for polymorphism.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Goroutines are multiplexed on threads.",
        "type": "true_false",
        "correct": "True"
    },
    {
        "q": "Go was created by Rob Pike and Ken Thompson.",
        "type": "true_false",
        "correct": "True"
    }
]