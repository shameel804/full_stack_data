[
    {
        "title": "ORM Definition",
        "ques": "What does **ORM** stand for and what problem does it solve?",
        "answer": {
            "type": "text",
            "content": "**Object-Relational Mapping.**\n\n**Problem:** Object-Oriented code (Classes, Inheritance) doesn't map cleanly to Relational Databases (Tables, Foreign Keys). This is called the 'Object-Relational Impedance Mismatch'. ORMs automate the translation between the two."
        },
        "explanation": "It lets you manipulate DB data as standard objects."
    },
    {
        "title": "ODM Definition",
        "ques": "What is an **ODM**?",
        "answer": {
            "type": "text",
            "content": "**Object-Document Mapping.**\n\nThe equivalent of ORM but for NoSQL Document databases (like MongoDB). It maps JSON documents to Class instances in your code."
        },
        "explanation": "Mongoose is the most famous example."
    },
    {
        "title": "Active Record Pattern",
        "ques": "In the **Active Record** pattern (used by Laravel/Rails), where does the persistence logic live?",
        "answer": {
            "type": "text",
            "content": "It lives **inside the Model class** itself.\n\n`user.save()`\n`User.find(1)`\n\nThe model carries both data and behavior (saving, updating)."
        },
        "explanation": "Simple to use, but violates Single Responsibility Principle."
    },
    {
        "title": "Data Mapper Pattern",
        "ques": "In the **Data Mapper** pattern (used by Hibernate/Doctrine/TypeORM), where does the persistence logic live?",
        "answer": {
            "type": "text",
            "content": "In a separate **Repository** or **Entity Manager**.\n\n`repository.save(user)`\n\nThe Model (Entity) is a dumb class (POJO) with only data. It knows nothing about the database. This decouples your domain logic from the persistence layer."
        },
        "explanation": "Better for complex applications and testing."
    }
]