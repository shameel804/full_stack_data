[
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => {\n    callback('Data received');\n  }, 1000);\n}\n\nfetchData(console.log);",
    "o": [
      "Data received",
      "undefined",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which of the following correctly defines a JavaScript callback function?",
    "o": [
      "A function passed as an argument to another function",
      "A function that executes immediately when defined",
      "A function that runs only once after execution",
      "A function that returns a promise"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  resolve('Promise Resolved');\n});\n\npromise.then(console.log);",
    "o": [
      "Promise Resolved",
      "undefined",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which of the following correctly explains JavaScript Promises?",
    "o": [
      "An object representing the eventual completion or failure of an asynchronous operation",
      "A function that runs synchronously",
      "A way to execute functions in parallel",
      "A method to make HTTP requests"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return 'Async Data';\n}\n\nfetchData().then(console.log);",
    "o": [
      "Async Data",
      "undefined",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which of the following statements about async/await is true?",
    "o": [
      "Async functions always return a promise",
      "Await can only be used inside a normal function",
      "Async functions block the main thread",
      "Await works without async functions"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delayedLog() {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve('Hello after delay'), 1000);\n  });\n}\n\ndelayedLog().then(console.log);",
    "o": [
      "Hello after delay",
      "undefined",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to handle errors in Promises?",
    "o": [
      "Using try-catch outside a promise chain",
      "Using .catch() method",
      "Using async/await with try-catch",
      "Using .then() with an error argument"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  throw new Error('Something went wrong');\n}\n\ntest().catch(console.error);",
    "o": [
      "Error: Something went wrong",
      "undefined",
      "null",
      "Promise { <pending> }"
    ]
  },
  {
    "q": "Which of the following statements about JavaScript callbacks is false?",
    "o": [
      "Callbacks always execute immediately after being defined",
      "Callbacks can be used to handle asynchronous operations",
      "A callback function can be passed as an argument to another function",
      "Multiple callbacks can be nested, leading to callback hell"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncOp(callback) {\n  setTimeout(() => callback('Completed'), 500);\n}\n\nconsole.log('Start');\nasyncOp(console.log);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nCompleted",
      "Start\nCompleted\nEnd",
      "Completed\nStart\nEnd",
      "End\nCompleted\nStart"
    ]
  },
  {
    "q": "Which of the following is true about JavaScript event loop?",
    "o": [
      "It handles asynchronous operations by managing the call stack and callback queue",
      "It executes all functions in parallel",
      "It blocks execution until all async operations complete",
      "It can only handle one asynchronous operation at a time"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('A');\nsetTimeout(() => console.log('B'), 1000);\nconsole.log('C');",
    "o": [
      "A\nC\nB",
      "A\nB\nC",
      "B\nA\nC",
      "C\nA\nB"
    ]
  },
  {
    "q": "Which of the following is NOT a state of a JavaScript Promise?",
    "o": [
      "Canceled",
      "Pending",
      "Fulfilled",
      "Rejected"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Resolved!'), 1000);\n});\nconsole.log(promise);",
    "o": [
      "Promise { <pending> }",
      "Resolved!",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly describes the behavior of async functions?",
    "o": [
      "They always return a Promise",
      "They execute synchronously",
      "They can only contain one await statement",
      "They do not require error handling"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return new Promise(resolve => setTimeout(() => resolve('Data Loaded'), 1000));\n}\nfetchData().then(console.log);\nconsole.log('Loading...');",
    "o": [
      "Loading...\nData Loaded",
      "Data Loaded\nLoading...",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is a key benefit of using async/await over Promises?",
    "o": [
      "Improves code readability by making asynchronous code look synchronous",
      "Prevents errors from occurring",
      "Executes code faster than Promises",
      "Allows JavaScript to run in parallel"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  return 42;\n}\n\ntest().then(console.log);",
    "o": [
      "42",
      "Promise { 42 }",
      "undefined",
      "null"
    ]
  },
  {
    "q": "Which of the following is NOT a correct way to create a Promise?",
    "o": [
      "new Promise(resolve, reject) => { resolve('Done'); }",
      "new Promise((resolve, reject) => { resolve('Done'); })",
      "Promise.resolve('Done')",
      "Promise.reject('Error')"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function doSomething(callback) {\n  setTimeout(() => callback('Done!'), 2000);\n}\n\ndoSomething(console.log);\nconsole.log('Processing...');",
    "o": [
      "Processing...\nDone!",
      "Done!\nProcessing...",
      "Processing...",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly describes callback hell?",
    "o": [
      "A situation where multiple nested callbacks make the code difficult to read and maintain",
      "An error caused by incorrect function calls",
      "A situation where a callback function does not execute",
      "A problem where JavaScript stops executing due to an infinite loop"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log('First'), 0);\nconsole.log('Second');",
    "o": [
      "Second\nFirst",
      "First\nSecond",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about Promises is true?",
    "o": [
      "A Promise can be in one of three states: pending, fulfilled, or rejected",
      "A Promise must always resolve after a set timeout",
      "A Promise executes synchronously",
      "A rejected Promise cannot be handled"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  reject('Error occurred');\n});\n\npromise.catch(console.log);",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <pending> }",
      "null"
    ]
  },
  {
    "q": "Which of the following statements is true about async/await?",
    "o": [
      "Await pauses the execution of the function until the Promise resolves",
      "Await can be used outside an async function",
      "Async functions run synchronously",
      "Async functions do not return Promises"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  return new Promise(resolve => setTimeout(() => resolve('Async Done'), 1500));\n}\n\nexample().then(console.log);\nconsole.log('Waiting...');",
    "o": [
      "Waiting...\nAsync Done",
      "Async Done\nWaiting...",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods is used to chain multiple Promises?",
    "o": [
      ".then()",
      ".catch()",
      ".await()",
      ".resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  throw 'Something went wrong';\n}\n\ntest().catch(console.log);",
    "o": [
      "Something went wrong",
      "undefined",
      "null",
      "Promise { <pending> }"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to create an asynchronous function?",
    "o": [
      "function myAsyncFunction() { await fetchData(); }",
      "async function myAsyncFunction() { return await fetchData(); }",
      "const myAsyncFunction = async () => await fetchData();",
      "async function myAsyncFunction() { return Promise.resolve('Done'); }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Data received'), 1000);\n}\nconsole.log('Fetching...');\nfetchData(console.log);",
    "o": [
      "Fetching...\nData received",
      "Data received\nFetching...",
      "Fetching...",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a drawback of using callbacks for asynchronous operations?",
    "o": [
      "Callback hell makes code difficult to read and maintain",
      "Callbacks always execute before the main function",
      "Callbacks block the execution of other code",
      "Callbacks cannot handle asynchronous operations"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log('Timeout executed'), 0);\nPromise.resolve('Promise resolved').then(console.log);\nconsole.log('Synchronous log');",
    "o": [
      "Synchronous log\nPromise resolved\nTimeout executed",
      "Synchronous log\nTimeout executed\nPromise resolved",
      "Promise resolved\nSynchronous log\nTimeout executed",
      "Timeout executed\nPromise resolved\nSynchronous log"
    ]
  },
  {
    "q": "Which of the following correctly describes the execution order in JavaScript event loop?",
    "o": [
      "Synchronous code -> Microtasks (Promises) -> Macrotasks (setTimeout, setInterval)",
      "Macrotasks (setTimeout, setInterval) -> Microtasks (Promises) -> Synchronous code",
      "Synchronous code -> Macrotasks (setTimeout) -> Microtasks (Promises)",
      "Microtasks (Promises) -> Synchronous code -> Macrotasks (setTimeout, setInterval)"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Promise resolved!'), 500);\n});\nconsole.log(promise);",
    "o": [
      "Promise { <pending> }",
      "Promise resolved!",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about JavaScript Promises?",
    "o": [
      "They are used to handle asynchronous operations and can be in three states",
      "They always execute synchronously",
      "They can only resolve to numbers or strings",
      "They must always be created using setTimeout"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  return 'Hello World';\n}\ngetData().then(console.log);",
    "o": [
      "Hello World",
      "Promise { <pending> }",
      "undefined",
      "null"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to handle a rejected Promise?",
    "o": [
      "promise.onError()",
      "promise.catch()",
      "promise.then(null, errorHandler)",
      "async function with try...catch"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return new Promise(resolve => setTimeout(() => resolve('Data Loaded'), 1000));\n}\nfetchData().then(console.log);\nconsole.log('Loading...');",
    "o": [
      "Loading...\nData Loaded",
      "Data Loaded\nLoading...",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about async/await is true?",
    "o": [
      "Async functions always return a Promise",
      "Await can be used outside an async function",
      "Async functions execute faster than normal functions",
      "Await stops the entire JavaScript execution thread"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function processData(callback) {\n  setTimeout(() => callback('Processed Data'), 1500);\n}\nconsole.log('Start Processing...');\nprocessData(console.log);",
    "o": [
      "Start Processing...\nProcessed Data",
      "Processed Data\nStart Processing...",
      "Start Processing...",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes the role of a callback function in JavaScript?",
    "o": [
      "A function passed as an argument to another function and executed later",
      "A function that runs synchronously inside another function",
      "A function used only for handling errors",
      "A function that is automatically executed without being called"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise resolved'));\nconsole.log('Synchronous execution');",
    "o": [
      "Synchronous execution\nPromise resolved\nTimeout",
      "Synchronous execution\nTimeout\nPromise resolved",
      "Promise resolved\nSynchronous execution\nTimeout",
      "Timeout\nSynchronous execution\nPromise resolved"
    ]
  },
  {
    "q": "Which of the following statements about Promises is true?",
    "o": [
      "A Promise can be resolved or rejected only once",
      "A Promise can be resolved multiple times",
      "A Promise executes immediately when created, even if not used",
      "A Promise is executed only when awaited"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject('Error Occurred'), 500);\n});\n\npromise.then(console.log).catch(console.log);",
    "o": [
      "Error Occurred",
      "undefined",
      "Promise { <pending> }",
      "null"
    ]
  },
  {
    "q": "Which of the following methods is used to execute a function after a Promise is resolved or rejected?",
    "o": [
      ".finally()",
      ".then()",
      ".catch()",
      ".done()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  let result = await new Promise(resolve => setTimeout(() => resolve('Data Received'), 1000));\n  console.log(result);\n}\nfetchData();\nconsole.log('Fetching...');",
    "o": [
      "Fetching...\nData Received",
      "Data Received\nFetching...",
      "Fetching...",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is true about async/await?",
    "o": [
      "Await makes JavaScript wait for the Promise to resolve before continuing execution",
      "Await can be used in any function, even if it is not marked async",
      "Async functions do not return Promises",
      "Await blocks the execution of all JavaScript code"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  throw new Error('Something went wrong');\n}\ntest().catch(err => console.log(err.message));",
    "o": [
      "Something went wrong",
      "undefined",
      "null",
      "Promise { <pending> }"
    ]
  },
  {
    "q": "Which of the following is NOT a correct way to handle a rejected Promise?",
    "o": [
      "promise.fail(callback)",
      "promise.catch(callback)",
      "async function with try...catch",
      "promise.then(null, callback)"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise resolved'));\nconsole.log('End');",
    "o": [
      "Start\nEnd\nPromise resolved\nTimeout",
      "Start\nPromise resolved\nEnd\nTimeout",
      "Start\nTimeout\nEnd\nPromise resolved",
      "Start\nPromise resolved\nTimeout\nEnd"
    ]
  },
  {
    "q": "Which of the following correctly describes the purpose of setTimeout in JavaScript?",
    "o": [
      "It schedules a function to run after a specified delay",
      "It immediately pauses execution for the given delay",
      "It runs a function asynchronously without any delay",
      "It stops the JavaScript execution until the delay is over"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncFunction() {\n  return new Promise(resolve => setTimeout(() => resolve('Done'), 1000));\n}\nasyncFunction().then(console.log);\nconsole.log('Processing...');",
    "o": [
      "Processing...\nDone",
      "Done\nProcessing...",
      "Processing...",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to create a Promise?",
    "o": [
      "new Promise((resolve, reject) => { ... })",
      "Promise.create((resolve, reject) => { ... })",
      "promise((resolve, reject) => { ... })",
      "Promise.then((resolve, reject) => { ... })"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  let data = await Promise.resolve('Success');\n  console.log(data);\n}\ntest();\nconsole.log('After function call');",
    "o": [
      "After function call\nSuccess",
      "Success\nAfter function call",
      "After function call",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about JavaScript Promises?",
    "o": [
      "A Promise starts executing as soon as it is created",
      "A Promise will not execute until .then() is called",
      "A Promise must always be resolved or rejected",
      "A Promise blocks JavaScript execution until it resolves"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => {\n  resolve('Resolved!');\n});\nmyPromise.then(console.log).catch(console.log);",
    "o": [
      "Resolved!",
      "undefined",
      "Error",
      "Promise { <pending> }"
    ]
  },
  {
    "q": "Which of the following is a benefit of using async/await over Promises with .then()?",
    "o": [
      "It makes asynchronous code look synchronous and improves readability",
      "It makes the code execute faster",
      "It ensures the function executes in parallel",
      "It removes the need for error handling"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  try {\n    let result = await Promise.reject('Error occurred');\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\nfetchData();",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <pending> }",
      "null"
    ]
  },
  {
    "q": "Which of the following is NOT true about JavaScript async functions?",
    "o": [
      "They always execute synchronously",
      "They always return a Promise",
      "They allow the use of await inside them",
      "They can handle errors using try...catch"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('A');\nsetTimeout(() => console.log('B'), 0);\nPromise.resolve().then(() => console.log('C'));\nconsole.log('D');",
    "o": [
      "A\nD\nC\nB",
      "A\nB\nC\nD",
      "A\nC\nD\nB",
      "A\nD\nB\nC"
    ]
  },
  {
    "q": "Which of the following is true about the event loop in JavaScript?",
    "o": [
      "It handles asynchronous operations by managing the execution of callback functions",
      "It is used to create infinite loops in JavaScript",
      "It blocks the execution of JavaScript until a Promise is resolved",
      "It is only triggered when the user interacts with the webpage"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Data loaded'), 1000);\n}\nfetchData(console.log);\nconsole.log('Fetching...');",
    "o": [
      "Fetching...\nData loaded",
      "Data loaded\nFetching...",
      "Fetching...",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about Promises is correct?",
    "o": [
      "A Promise represents a value that may be available now, or in the future, or never",
      "A Promise is always resolved immediately",
      "A Promise must be rejected before it can be resolved",
      "A Promise executes synchronously"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve) => resolve('Resolved!'));\nmyPromise.then(console.log);\nconsole.log('End');",
    "o": [
      "End\nResolved!",
      "Resolved!\nEnd",
      "End",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods is used to handle errors in Promises?",
    "o": [
      ".catch()",
      ".finally()",
      ".then()",
      ".reject()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncFunc() {\n  return 'Hello';\n}\nasyncFunc().then(console.log);\nconsole.log('End');",
    "o": [
      "End\nHello",
      "Hello\nEnd",
      "End",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about async/await is correct?",
    "o": [
      "Await pauses the execution of an async function until the Promise resolves",
      "Await works outside of async functions",
      "Async functions do not return Promises",
      "Using await makes the function synchronous"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    let result = await Promise.reject('Failure');\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\ntest();",
    "o": [
      "Failure",
      "undefined",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to handle Promises in JavaScript?",
    "o": [
      "Using .fail()",
      "Using .catch()",
      "Using async/await with try...catch",
      "Using .then() with a second argument"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 1000);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 2\nEnd\nTimeout 1",
      "Start\nTimeout 1\nTimeout 2\nEnd",
      "Start\nTimeout 1\nEnd\nTimeout 2"
    ]
  },
  {
    "q": "Which of the following is true about JavaScript Callbacks?",
    "o": [
      "A callback is a function passed as an argument to another function",
      "Callbacks execute synchronously by default",
      "Callbacks are the only way to handle asynchronous operations in JavaScript",
      "Callbacks do not support error handling"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Hello, World!'), 500);\n}\nfetchData(console.log);\nconsole.log('Loading...');",
    "o": [
      "Loading...\nHello, World!",
      "Hello, World!\nLoading...",
      "Loading...",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid state of a JavaScript Promise?",
    "o": [
      "Canceled",
      "Pending",
      "Fulfilled",
      "Rejected"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Done!'), 2000);\n});\nconsole.log(promise);",
    "o": [
      "Promise { <pending> }",
      "Promise { 'Done!' }",
      "Done!",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of using Promises?",
    "o": [
      "They allow synchronous execution of asynchronous tasks",
      "They improve readability compared to callbacks",
      "They provide better error handling using .catch()",
      "They can be chained using .then()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  let data = await Promise.resolve('Async Success');\n  console.log(data);\n}\ngetData();\nconsole.log('After function call');",
    "o": [
      "After function call\nAsync Success",
      "Async Success\nAfter function call",
      "After function call",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about async/await in JavaScript?",
    "o": [
      "Async functions always return a Promise",
      "Await can be used outside an async function",
      "Async functions block the main thread",
      "Await pauses execution permanently"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function demo() {\n  try {\n    let result = await Promise.reject('Error occurred');\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\ndemo();",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <pending> }",
      "null"
    ]
  },
  {
    "q": "Which of the following methods is used to execute multiple Promises in parallel?",
    "o": [
      "Promise.all()",
      "Promise.parallel()",
      "Promise.sequence()",
      "Promise.wait()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Middle'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('End');",
    "o": [
      "Start\nEnd\nPromise\nMiddle",
      "Start\nMiddle\nPromise\nEnd",
      "Start\nPromise\nEnd\nMiddle",
      "Start\nEnd\nMiddle\nPromise"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using callbacks?",
    "o": [
      "Callback hell makes code difficult to read and maintain",
      "Callbacks are always synchronous",
      "Callbacks do not support error handling",
      "Callbacks cannot be used for asynchronous operations"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function doSomething(callback) {\n  console.log('Task 1');\n  setTimeout(() => {\n    console.log('Task 2');\n    callback();\n  }, 1000);\n}\ndoSomething(() => console.log('Task 3'));",
    "o": [
      "Task 1\nTask 2\nTask 3",
      "Task 1\nTask 3\nTask 2",
      "Task 2\nTask 1\nTask 3",
      "Task 3\nTask 1\nTask 2"
    ]
  },
  {
    "q": "Which method allows handling multiple Promises, returning the first one that settles?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.allSettled()",
      "Promise.any()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise1 = new Promise(resolve => setTimeout(() => resolve('First'), 3000));\nconst promise2 = new Promise(resolve => setTimeout(() => resolve('Second'), 1000));\nPromise.race([promise1, promise2]).then(console.log);",
    "o": [
      "Second",
      "First",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which of the following statements about async/await is false?",
    "o": [
      "Await can be used outside an async function",
      "Async functions return a Promise",
      "Await pauses execution until the Promise resolves",
      "Errors in async functions can be handled using try...catch"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  console.log('Before');\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  console.log('After');\n}\nexample();\nconsole.log('End');",
    "o": [
      "Before\nEnd\nAfter",
      "Before\nAfter\nEnd",
      "End\nBefore\nAfter",
      "Before\nAfter\nEnd\nundefined"
    ]
  },
  {
    "q": "Which method waits for all Promises to either resolve or reject and returns their results?",
    "o": [
      "Promise.allSettled()",
      "Promise.race()",
      "Promise.any()",
      "Promise.all()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    let result = await Promise.any([\n      Promise.reject('Error 1'),\n      Promise.reject('Error 2'),\n      Promise.resolve('Success')\n    ]);\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\ntest();",
    "o": [
      "Success",
      "Error 1",
      "Error 2",
      "Error: AggregateError"
    ]
  },
  {
    "q": "Which of the following best describes the difference between Promise.all() and Promise.any()?",
    "o": [
      "Promise.all() waits for all Promises to resolve, while Promise.any() waits for the first resolved Promise",
      "Promise.all() waits for one Promise to resolve, while Promise.any() waits for all Promises to resolve",
      "Promise.all() returns the first rejected Promise, while Promise.any() ignores rejected Promises",
      "Promise.all() does not handle errors, while Promise.any() does"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('A');\nsetTimeout(() => console.log('B'), 0);\nPromise.resolve().then(() => console.log('C'));\nconsole.log('D');",
    "o": [
      "A\nD\nC\nB",
      "A\nB\nC\nD",
      "A\nC\nD\nB",
      "A\nD\nB\nC"
    ]
  },
  {
    "q": "Which of the following is true about JavaScript Promises?",
    "o": [
      "A Promise can be in one of three states: pending, fulfilled, or rejected",
      "A Promise always executes synchronously",
      "Promises replace all need for callbacks",
      "A Promise can only be resolved, never rejected"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncTask() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('Task Complete'), 1000);\n  });\n}\nasyncTask().then(console.log);\nconsole.log('Done');",
    "o": [
      "Done\nTask Complete",
      "Task Complete\nDone",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which method is used to handle both resolved and rejected cases of a Promise?",
    "o": [
      ".then()",
      ".catch()",
      ".finally()",
      ".resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  reject('Error occurred');\n});\n\npromise\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n  .finally(() => console.log('Cleanup done'));",
    "o": [
      "Error occurred\nCleanup done",
      "Cleanup done\nError occurred",
      "Error occurred",
      "Cleanup done"
    ]
  },
  {
    "q": "Which of the following is a key advantage of using async/await over Promises with .then()?",
    "o": [
      "It makes asynchronous code look more synchronous and readable",
      "It executes code faster",
      "It eliminates all errors in asynchronous operations",
      "It allows synchronous blocking of the main thread"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  console.log('Fetching...');\n  let result = await new Promise(resolve => setTimeout(() => resolve('Data received'), 2000));\n  console.log(result);\n}\nfetchData();\nconsole.log('End of script');",
    "o": [
      "Fetching...\nEnd of script\nData received",
      "Fetching...\nData received\nEnd of script",
      "End of script\nFetching...\nData received",
      "Data received\nFetching...\nEnd of script"
    ]
  },
  {
    "q": "Which method ensures that all Promises resolve successfully before proceeding?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.any()",
      "Promise.settled()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    let result = await Promise.all([\n      Promise.resolve('First'),\n      Promise.reject('Error'),\n      Promise.resolve('Second')\n    ]);\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\ntest();",
    "o": [
      "Error",
      "First, Second",
      "First, Error, Second",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of JavaScript asynchronous execution?",
    "o": [
      "It blocks the main thread until execution completes",
      "It uses the event loop to schedule tasks",
      "It allows non-blocking execution",
      "It can handle time-consuming operations without freezing the UI"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Data fetched'), 1000);\n}\n\nfetchData(console.log);\nconsole.log('Processing...');",
    "o": [
      "Processing...\nData fetched",
      "Data fetched\nProcessing...",
      "Processing...",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about callbacks in JavaScript is true?",
    "o": [
      "Callbacks allow asynchronous execution of functions",
      "Callbacks always execute synchronously",
      "Callbacks eliminate all issues with asynchronous code",
      "Callbacks cannot be used inside setTimeout"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Promise resolved'), 500);\n})\n  .then(console.log);\nconsole.log('Script end');",
    "o": [
      "Script end\nPromise resolved",
      "Promise resolved\nScript end",
      "Error",
      "Promise resolved"
    ]
  },
  {
    "q": "Which method is used to handle only the rejected case of a Promise?",
    "o": [
      ".catch()",
      ".then()",
      ".finally()",
      ".reject()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return 'Hello World';\n}\nfetchData().then(console.log);",
    "o": [
      "Hello World",
      "undefined",
      "Promise { 'Hello World' }",
      "Error"
    ]
  },
  {
    "q": "Which statement about async functions in JavaScript is correct?",
    "o": [
      "An async function always returns a Promise",
      "An async function blocks the execution of the script",
      "An async function must contain at least one await keyword",
      "An async function executes synchronously"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('End');\n}\ntest();\nconsole.log('Middle');",
    "o": [
      "Start\nMiddle\nEnd",
      "Start\nEnd\nMiddle",
      "Middle\nStart\nEnd",
      "Start\nMiddle\nPromise { <pending> }\nEnd"
    ]
  },
  {
    "q": "Which Promise method returns the first Promise that resolves or rejects?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.any()",
      "Promise.resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "Promise.resolve('Resolved')\n  .then(value => {\n    console.log(value);\n    return 'Next';\n  })\n  .finally(() => console.log('Finally executed'))\n  .then(console.log);",
    "o": [
      "Resolved\nFinally executed\nNext",
      "Resolved\nNext\nFinally executed",
      "Finally executed\nResolved\nNext",
      "Error"
    ]
  },
  {
    "q": "Which statement about Promise chaining is correct?",
    "o": [
      "Each .then() receives the return value of the previous .then()",
      "Each .then() executes immediately without waiting for the previous one",
      "Only the first .then() executes in a chain",
      "Promise chaining does not allow handling rejections"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function first(callback) {\n  setTimeout(() => {\n    console.log(\"First function executed\");\n    callback();\n  }, 500);\n}\n\nfunction second() {\n  console.log(\"Second function executed\");\n}\n\nfirst(second);",
    "o": [
      "First function executed\nSecond function executed",
      "Second function executed\nFirst function executed",
      "Error",
      "First function executed"
    ]
  },
  {
    "q": "Which of the following is an advantage of using Promises over Callbacks?",
    "o": [
      "Promises make asynchronous code more readable and avoid callback hell",
      "Promises execute faster than Callbacks",
      "Promises work only for synchronous operations",
      "Promises eliminate the need for error handling"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "let promise = new Promise((resolve, reject) => {\n  resolve(\"Success\");\n  reject(\"Error\");\n});\n\npromise.then(console.log).catch(console.log);",
    "o": [
      "Success",
      "Error",
      "Success\nError",
      "Error\nSuccess"
    ]
  },
  {
    "q": "Which of the following statements about async/await is correct?",
    "o": [
      "async functions always return a Promise",
      "await can be used inside regular functions",
      "async functions must always have an await keyword",
      "await pauses code execution permanently"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function demo() {\n  console.log(\"Start\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"End\");\n}\ndemo();\nconsole.log(\"Middle\");",
    "o": [
      "Start\nMiddle\nEnd",
      "Start\nEnd\nMiddle",
      "Middle\nStart\nEnd",
      "Start\nMiddle\nPromise { <pending> }\nEnd"
    ]
  },
  {
    "q": "Which Promise method waits for all Promises to resolve or reject before continuing?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.any()",
      "Promise.resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return new Promise(resolve => setTimeout(() => resolve(\"Data Loaded\"), 1000));\n}\n\nasync function main() {\n  console.log(\"Fetching...\");\n  let data = await fetchData();\n  console.log(data);\n}\nmain();\nconsole.log(\"Process Started\");",
    "o": [
      "Fetching...\nProcess Started\nData Loaded",
      "Process Started\nFetching...\nData Loaded",
      "Fetching...\nData Loaded\nProcess Started",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT true about JavaScript Promises?",
    "o": [
      "A Promise can only settle once",
      "A Promise has three states: pending, fulfilled, and rejected",
      "A resolved Promise can later switch to a rejected state",
      "A rejected Promise can be handled using .catch()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve().then(() => console.log(\"Promise resolved\"));\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise resolved\nTimeout",
      "Start\nPromise resolved\nEnd\nTimeout",
      "Start\nTimeout\nEnd\nPromise resolved",
      "Start\nEnd\nTimeout\nPromise resolved"
    ]
  },
  {
    "q": "Which statement about JavaScript's Event Loop is correct?",
    "o": [
      "It handles asynchronous operations by managing the call stack and the task queue",
      "It executes all asynchronous code before synchronous code",
      "It processes Promises before synchronous functions",
      "It only runs once when the script starts execution"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncFunction(callback) {\n  setTimeout(() => {\n    callback(\"Hello\");\n  }, 1000);\n}\n\nasyncFunction(console.log);\nconsole.log(\"World\");",
    "o": [
      "World\nHello",
      "Hello\nWorld",
      "World",
      "Hello"
    ]
  },
  {
    "q": "Which method is used to handle errors in Promises?",
    "o": [
      ".catch()",
      ".then()",
      ".finally()",
      "try-catch block"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "let p = new Promise((resolve, reject) => {\n  reject(\"Error occurred\");\n});\n\np.then(console.log).catch(console.log);",
    "o": [
      "Error occurred",
      "Promise { <rejected> }",
      "undefined",
      "No output"
    ]
  },
  {
    "q": "Which of the following statements about async functions is correct?",
    "o": [
      "An async function always returns a Promise",
      "An async function must always contain an await statement",
      "Async functions execute synchronously",
      "You cannot use await inside an async function"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"A\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"B\");\n}\ntest();\nconsole.log(\"C\");",
    "o": [
      "A\nC\nB",
      "A\nB\nC",
      "C\nA\nB",
      "A\nB"
    ]
  },
  {
    "q": "Which of the following correctly describes Promise chaining?",
    "o": [
      "Using multiple .then() calls on a Promise to execute code sequentially",
      "Executing multiple Promises simultaneously",
      "Using await inside a Promise",
      "Handling errors inside a Promise"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return \"Data Received\";\n}\n\nfetchData().then(console.log);",
    "o": [
      "Data Received",
      "Promise { <resolved>: \"Data Received\" }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods will execute the first resolved Promise among multiple Promises?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.allSettled()",
      "Promise.any()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"1\");\nsetTimeout(() => console.log(\"2\"), 0);\nPromise.resolve().then(() => console.log(\"3\"));\nconsole.log(\"4\");",
    "o": [
      "1\n4\n3\n2",
      "1\n3\n4\n2",
      "1\n2\n3\n4",
      "1\n3\n2\n4"
    ]
  },
  {
    "q": "What does the finally() method do in Promises?",
    "o": [
      "Executes a callback regardless of whether the Promise is resolved or rejected",
      "Handles errors in Promises",
      "Executes only if the Promise resolves",
      "Executes before the .then() method"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => {\n    callback(\"Data loaded\");\n  }, 2000);\n}\n\nfetchData(console.log);\nconsole.log(\"Fetching data...\");",
    "o": [
      "Fetching data...\nData loaded",
      "Data loaded\nFetching data...",
      "Fetching data...",
      "Data loaded"
    ]
  },
  {
    "q": "Which statement is true about JavaScript callbacks?",
    "o": [
      "A callback is a function passed as an argument to another function",
      "A callback function must always be asynchronous",
      "Callbacks cannot be nested inside other callbacks",
      "Callback functions block the execution of code"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delayedMessage() {\n  setTimeout(() => console.log(\"Hello\"), 1000);\n}\n\ndelayedMessage();\nconsole.log(\"World\");",
    "o": [
      "World\nHello",
      "Hello\nWorld",
      "World",
      "Hello"
    ]
  },
  {
    "q": "Which of the following is true about Promises?",
    "o": [
      "A Promise represents a value that might be available now, in the future, or never",
      "A Promise must always resolve",
      "A Promise can only handle asynchronous operations",
      "A Promise executes synchronously"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "let p = new Promise((resolve, reject) => {\n  setTimeout(() => resolve(\"Resolved!\"), 1000);\n});\n\np.then(console.log);\nconsole.log(\"Waiting...\");",
    "o": [
      "Waiting...\nResolved!",
      "Resolved!\nWaiting...",
      "Waiting...",
      "Resolved!"
    ]
  },
  {
    "q": "Which method can be used to handle multiple Promises concurrently and return the first resolved Promise?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.allSettled()",
      "Promise.resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"Start\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"End\");\n}\ntest();\nconsole.log(\"Running...\");",
    "o": [
      "Start\nRunning...\nEnd",
      "Start\nEnd\nRunning...",
      "Running...\nStart\nEnd",
      "Start\nEnd"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to handle errors in async/await?",
    "o": [
      "Using try-catch blocks",
      "Using .catch() on the returned Promise",
      "Ignoring the error completely",
      "Using .finally() to handle the error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"A\");\nsetTimeout(() => console.log(\"B\"), 0);\nPromise.resolve().then(() => console.log(\"C\"));\nconsole.log(\"D\");",
    "o": [
      "A\nD\nC\nB",
      "A\nC\nD\nB",
      "A\nB\nC\nD",
      "A\nD\nB\nC"
    ]
  },
  {
    "q": "What does the async keyword do when used before a function?",
    "o": [
      "It makes the function return a Promise",
      "It forces the function to execute asynchronously",
      "It prevents the function from using await",
      "It stops execution until the function completes"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"First\"), 0);\nPromise.resolve().then(() => console.log(\"Second\"));\nconsole.log(\"Third\");",
    "o": [
      "Third\nSecond\nFirst",
      "First\nSecond\nThird",
      "Third\nFirst\nSecond",
      "Second\nThird\nFirst"
    ]
  },
  {
    "q": "Which of the following is a key difference between callbacks and Promises?",
    "o": [
      "Promises allow chaining, while callbacks require nesting",
      "Callbacks execute synchronously, while Promises are always asynchronous",
      "Promises block execution, while callbacks do not",
      "Callbacks can only be used for handling errors, while Promises handle success and failure"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return \"Data received\";\n}\nfetchData().then(console.log);\nconsole.log(\"Fetching...\");",
    "o": [
      "Fetching...\nData received",
      "Data received\nFetching...",
      "Fetching...",
      "Data received"
    ]
  },
  {
    "q": "Which of the following is true about async/await in JavaScript?",
    "o": [
      "Async functions always return a Promise",
      "Await can only be used inside synchronous functions",
      "An async function executes all await calls in parallel",
      "Async/await does not use Promises internally"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData() {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(\"Data received\"), 1000);\n  });\n}\n\nasync function getData() {\n  console.log(\"Fetching...\");\n  const data = await fetchData();\n  console.log(data);\n}\n\ng getData();\nconsole.log(\"Processing...\");",
    "o": [
      "Fetching...\nProcessing...\nData received",
      "Fetching...\nData received\nProcessing...",
      "Processing...\nFetching...\nData received",
      "Data received\nProcessing...\nFetching..."
    ]
  },
  {
    "q": "Which method ensures multiple Promises resolve before executing code?",
    "o": [
      "Promise.all()",
      "Promise.any()",
      "Promise.race()",
      "Promise.resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise1 = new Promise((resolve) => setTimeout(() => resolve(\"First\"), 3000));\nconst promise2 = new Promise((resolve) => setTimeout(() => resolve(\"Second\"), 1000));\nPromise.race([promise1, promise2]).then(console.log);",
    "o": [
      "Second",
      "First",
      "Second\nFirst",
      "First\nSecond"
    ]
  },
  {
    "q": "Which statement about error handling in async/await is correct?",
    "o": [
      "Errors inside an async function should be handled using try-catch",
      "Unhandled errors in async functions are ignored",
      "Await automatically handles errors without try-catch",
      "An async function cannot throw an error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    await Promise.reject(\"Error occurred\");\n  } catch (error) {\n    console.log(\"Caught:\", error);\n  }\n}\ntest();",
    "o": [
      "Caught: Error occurred",
      "Error occurred",
      "UnhandledPromiseRejectionWarning: Error occurred",
      "Caught: undefined"
    ]
  },
  {
    "q": "Which of the following best describes the event loop in JavaScript?",
    "o": [
      "It continuously checks the call stack and executes tasks from the task queue",
      "It executes all JavaScript code synchronously",
      "It blocks execution while waiting for asynchronous tasks to complete",
      "It is used only for handling setTimeout and setInterval"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function task1(callback) {\n  setTimeout(() => {\n    console.log(\"Task 1 completed\");\n    callback();\n  }, 1000);\n}\nfunction task2() {\n  console.log(\"Task 2 completed\");\n}\ntask1(task2);",
    "o": [
      "Task 1 completed\nTask 2 completed",
      "Task 2 completed\nTask 1 completed",
      "Task 1 completed",
      "Task 2 completed"
    ]
  },
  {
    "q": "Which of the following is an issue with callback-based asynchronous programming?",
    "o": [
      "Callback Hell (Pyramid of Doom)",
      "Callbacks are always blocking",
      "Callbacks cannot handle asynchronous operations",
      "Callbacks can only be used with setTimeout"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => {\n  reject(\"Error occurred\");\n});\nmyPromise.then(console.log).catch(console.log);",
    "o": [
      "Error occurred",
      "UnhandledPromiseRejectionWarning: Error occurred",
      "Nothing",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates promise chaining?",
    "o": [
      "fetchData().then(processData).then(saveData).catch(handleError);",
      "fetchData().then(processData.catch(handleError)).then(saveData);",
      "fetchData().catch(processData).then(saveData);",
      "fetchData().then(processData(saveData)).catch(handleError);"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncFunction() {\n  return 42;\n}\nasyncFunction().then(console.log);",
    "o": [
      "42",
      "Promise { 42 }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about async/await is true?",
    "o": [
      "An async function always returns a Promise",
      "An async function pauses execution of all JavaScript code",
      "An async function can be used without a return statement",
      "Await can be used outside an async function"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nasync function run() {\n  console.log(\"Start\");\n  await delay(2000);\n  console.log(\"End\");\n}\nrun();",
    "o": [
      "Start\n(wait 2 seconds)\nEnd",
      "End\n(wait 2 seconds)\nStart",
      "Start\nEnd",
      "Nothing is printed"
    ]
  },
  {
    "q": "Which of the following correctly describes Promise.all()?",
    "o": [
      "It resolves when all Promises in the array resolve",
      "It resolves when the first Promise in the array resolves",
      "It rejects if at least one Promise rejects, but still returns resolved ones",
      "It executes Promises sequentially instead of concurrently"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve) => setTimeout(() => resolve(\"Done\"), 1000));\nasync function test() {\n  console.log(\"Start\");\n  console.log(await promise);\n  console.log(\"End\");\n}\ntest();",
    "o": [
      "Start\n(wait 1 second)\nDone\nEnd",
      "Start\nDone\n(wait 1 second)\nEnd",
      "Start\nEnd\nDone",
      "Done\nStart\nEnd"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  return Promise.resolve(\"Hello\");\n}\ntest().then(console.log);",
    "o": [
      "Hello",
      "Promise { 'Hello' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => {\n    callback(\"Data received\");\n  }, 2000);\n}\nfetchData(console.log);\nconsole.log(\"Fetching...\");",
    "o": [
      "Fetching...\n(wait 2 seconds)\nData received",
      "Data received\n(wait 2 seconds)\nFetching...",
      "Fetching...\nData received",
      "Data received\nFetching..."
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of Promises in JavaScript?",
    "o": [
      "A Promise can be in only one of three states: pending, fulfilled, or rejected",
      "A Promise can be resolved or rejected multiple times",
      "Promises help to avoid callback hell",
      "Promises are asynchronous by nature"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const p1 = new Promise((resolve) => setTimeout(() => resolve(\"First\"), 3000));\nconst p2 = new Promise((resolve) => setTimeout(() => resolve(\"Second\"), 1000));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Second",
      "First",
      "Error",
      "Promise { 'Second' }"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates error handling in async/await?",
    "o": [
      "try { await myAsyncFunction(); } catch (error) { console.error(error); }",
      "await myAsyncFunction() catch (error) { console.error(error); }",
      "myAsyncFunction().catch { console.error(error); }",
      "await myAsyncFunction().catch(console.error);"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  return \"Hello\";\n}\nconsole.log(getData());",
    "o": [
      "Promise { 'Hello' }",
      "Hello",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about async/await is FALSE?",
    "o": [
      "Async functions always return a Promise",
      "Await pauses execution of the entire JavaScript engine",
      "Await can only be used inside an async function",
      "Async/await simplifies working with Promises"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nasync function run() {\n  console.log(\"Start\");\n  await delay(3000);\n  console.log(\"End\");\n}\nrun();",
    "o": [
      "Start\n(wait 3 seconds)\nEnd",
      "End\n(wait 3 seconds)\nStart",
      "Start\nEnd",
      "Nothing is printed"
    ]
  },
  {
    "q": "Which of the following is NOT true about JavaScript Promises?",
    "o": [
      "A Promise can transition from pending to fulfilled or rejected",
      "A Promise's .then() handler runs synchronously",
      "A Promise executes immediately when created",
      "A rejected Promise can be handled using .catch()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const p = new Promise((resolve) => resolve(\"Resolved\"));\np.then(console.log);\nconsole.log(\"After Promise\");",
    "o": [
      "After Promise\nResolved",
      "Resolved\nAfter Promise",
      "Error",
      "Promise { 'Resolved' }"
    ]
  },
  {
    "q": "Which method runs multiple Promises concurrently and returns the first resolved or rejected Promise?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.allSettled()",
      "Promise.any()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncOperation() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"Success\"), 1000);\n  });\n}\nasyncOperation().then(console.log);\nconsole.log(\"Processing...\");",
    "o": [
      "Processing...\n(wait 1 second)\nSuccess",
      "Success\nProcessing...",
      "Processing...\nSuccess",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about JavaScript callbacks is TRUE?",
    "o": [
      "Callbacks allow asynchronous operations to execute without blocking code execution",
      "Callbacks execute synchronously in JavaScript",
      "A callback function must always be named",
      "Callbacks can only be used with event listeners"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve().then(() => console.log(\"Promise\"));\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise\nTimeout",
      "Start\nTimeout\nPromise\nEnd",
      "Start\nPromise\nEnd\nTimeout",
      "Start\nEnd\nTimeout\nPromise"
    ]
  },
  {
    "q": "Which of the following is a correct way to handle a rejected Promise?",
    "o": [
      "promise.catch(error => console.error(error));",
      "promise.then(error => console.error(error));",
      "promise.reject(error => console.error(error));",
      "promise.error(error => console.error(error));"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  return Promise.reject(\"Error occurred\");\n}\ntest().catch(console.log);",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <rejected>: 'Error occurred' }",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following methods waits for all Promises to resolve but ignores rejected ones?",
    "o": [
      "Promise.any()",
      "Promise.all()",
      "Promise.race()",
      "Promise.allSettled()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return \"Fetched Data\";\n}\nfetchData().then(console.log);",
    "o": [
      "Fetched Data",
      "Promise { 'Fetched Data' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about async/await is TRUE?",
    "o": [
      "Async functions always return a Promise",
      "Await can be used in any function",
      "Await makes the function synchronous",
      "Async functions block the JavaScript event loop"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nasync function run() {\n  console.log(\"Before delay\");\n  await delay(2000);\n  console.log(\"After delay\");\n}\nrun();",
    "o": [
      "Before delay\n(wait 2 seconds)\nAfter delay",
      "After delay\n(wait 2 seconds)\nBefore delay",
      "Before delay\nAfter delay",
      "Nothing"
    ]
  },
  {
    "q": "Which JavaScript method executes a function asynchronously after a delay?",
    "o": [
      "setTimeout()",
      "setInterval()",
      "requestAnimationFrame()",
      "process.nextTick()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"A\"), 1000);\nsetTimeout(() => console.log(\"B\"), 500);\nconsole.log(\"C\");",
    "o": [
      "C\nB\nA",
      "A\nB\nC",
      "B\nC\nA",
      "C\nA\nB"
    ]
  },
  {
    "q": "Which of the following statements about Promises in JavaScript is TRUE?",
    "o": [
      "A Promise can be in one of three states: pending, fulfilled, or rejected",
      "A Promise must always resolve to a string or a number",
      "A Promise executes synchronously in JavaScript",
      "A Promise can only be rejected, not resolved"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve, reject) => {\n  resolve(\"Success\");\n  reject(\"Error\");\n});\npromise.then(console.log).catch(console.log);",
    "o": [
      "Success",
      "Error",
      "Success\nError",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following functions correctly demonstrates the use of a callback in JavaScript?",
    "o": [
      "function fetchData(callback) { setTimeout(() => callback(\"Data\"), 1000); }",
      "function fetchData() { setTimeout(() => return \"Data\", 1000); }",
      "function fetchData() { setTimeout(callback(\"Data\"), 1000); }",
      "function fetchData(callback) { return setTimeout(callback, \"Data\", 1000); }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  return 42;\n}\nconsole.log(test());",
    "o": [
      "Promise { 42 }",
      "42",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which method can be used to handle both resolved and rejected states of a Promise?",
    "o": [
      "promise.then().catch()",
      "promise.resolve().reject()",
      "promise.catch().finally()",
      "promise.handle()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  try {\n    let response = await Promise.reject(\"Error occurred\");\n    console.log(response);\n  } catch (error) {\n    console.log(error);\n  }\n}\nexample();",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <rejected>: 'Error occurred' }",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about async/await is FALSE?",
    "o": [
      "Async functions execute synchronously",
      "Async functions return a Promise",
      "Await pauses execution of the async function",
      "Await can only be used inside an async function"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return await new Promise(resolve => setTimeout(() => resolve(\"Done\"), 1000));\n}\nfetchData().then(console.log);",
    "o": [
      "Done",
      "Promise { 'Done' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which JavaScript function executes code at regular intervals?",
    "o": [
      "setInterval()",
      "setTimeout()",
      "requestAnimationFrame()",
      "process.nextTick()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Middle\"), 0);\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nMiddle",
      "Start\nMiddle\nEnd",
      "Middle\nStart\nEnd",
      "End\nMiddle\nStart"
    ]
  },
  {
    "q": "Which statement about JavaScript callbacks is TRUE?",
    "o": [
      "Callbacks allow functions to be executed asynchronously after an operation completes.",
      "Callbacks always run before the main execution thread.",
      "Callbacks are used only with asynchronous functions like setTimeout.",
      "Callbacks execute synchronously and block execution."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function delayedLog() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"Hello\"), 1000);\n  });\n}\ndelayedLog().then(console.log);\nconsole.log(\"World\");",
    "o": [
      "World\nHello",
      "Hello\nWorld",
      "World",
      "Hello"
    ]
  },
  {
    "q": "Which method is used to execute a function once after a specified delay?",
    "o": [
      "setTimeout()",
      "setInterval()",
      "requestAnimationFrame()",
      "clearTimeout()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback(\"Data\"), 1000);\n}\nfetchData(console.log);\nconsole.log(\"Loading...\");",
    "o": [
      "Loading...\nData",
      "Data\nLoading...",
      "Loading...",
      "Data"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates promise chaining?",
    "o": [
      "fetchData().then(data => process(data)).then(result => console.log(result));",
      "fetchData().then(data => process(data), result => console.log(result));",
      "fetchData().process(data).then(result => console.log(result));",
      "fetchData.then(process(data)).then(console.log);"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  let result = await Promise.resolve(\"Success\");\n  console.log(result);\n}\ntest();",
    "o": [
      "Success",
      "Promise { 'Success' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which keyword is used to handle errors in async/await functions?",
    "o": [
      "try...catch",
      "catch()",
      "error()",
      "handle()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  throw new Error(\"Something went wrong\");\n}\nfetchData().catch(error => console.log(error.message));",
    "o": [
      "Something went wrong",
      "Error: Something went wrong",
      "Promise { <rejected>: 'Something went wrong' }",
      "undefined"
    ]
  },
  {
    "q": "Which statement about the event loop in JavaScript is TRUE?",
    "o": [
      "The event loop handles execution of asynchronous tasks in JavaScript.",
      "The event loop executes all synchronous code before moving to asynchronous tasks.",
      "The event loop is only used for handling user interactions in the browser.",
      "The event loop ensures that asynchronous functions run before synchronous ones."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"A\");\nsetTimeout(() => console.log(\"B\"), 1000);\nconsole.log(\"C\");",
    "o": [
      "A\nC\nB",
      "A\nB\nC",
      "B\nA\nC",
      "C\nA\nB"
    ]
  },
  {
    "q": "Which of the following statements about Promises is TRUE?",
    "o": [
      "A promise represents a value that may be available now, or in the future, or never.",
      "Promises execute synchronously by default.",
      "A promise can only be resolved but not rejected.",
      "A promise must always return a value immediately."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"Data loaded\"), 2000);\n  });\n}\nfetchData().then(console.log);\nconsole.log(\"Fetching...\");",
    "o": [
      "Fetching...\nData loaded",
      "Data loaded\nFetching...",
      "Fetching...",
      "Data loaded"
    ]
  },
  {
    "q": "Which of the following is a correct way to handle errors in a promise?",
    "o": [
      "promiseFunction().catch(error => console.log(error));",
      "promiseFunction().error(error => console.log(error));",
      "try { promiseFunction(); } catch(error) { console.log(error); }",
      "promiseFunction().handle(error => console.log(error));"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  let result = await new Promise(resolve => resolve(\"Async Success\"));\n  console.log(result);\n}\ntest();",
    "o": [
      "Async Success",
      "Promise { 'Async Success' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to declare an async function?",
    "o": [
      "async function myFunction() { return 'Hello'; }",
      "function async myFunction() { return 'Hello'; }",
      "function myFunction() async { return 'Hello'; }",
      "function myFunction() { await 'Hello'; }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve(\"Promise\").then(console.log);\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise\nTimeout",
      "Start\nPromise\nEnd\nTimeout",
      "Start\nTimeout\nPromise\nEnd",
      "Start\nEnd\nTimeout\nPromise"
    ]
  },
  {
    "q": "Which of the following is the correct way to use Promise.all()?",
    "o": [
      "Promise.all([promise1, promise2]).then(results => console.log(results));",
      "Promise.all(promise1, promise2).then(results => console.log(results));",
      "Promise.all(promise1, promise2).catch(error => console.log(error));",
      "Promise.all([promise1, promise2]).resolve(results => console.log(results));"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  return \"Hello World\";\n}\ngetData().then(console.log);",
    "o": [
      "Hello World",
      "Promise { 'Hello World' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which statement about async/await is TRUE?",
    "o": [
      "Async functions always return a Promise.",
      "Async functions execute faster than synchronous functions.",
      "Await can be used in any function, even non-async ones.",
      "Async functions block the main thread until execution completes."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"A\"), 0);\nPromise.resolve().then(() => console.log(\"B\"));\nconsole.log(\"C\");",
    "o": [
      "C\nB\nA",
      "C\nA\nB",
      "A\nB\nC",
      "B\nC\nA"
    ]
  },
  {
    "q": "Which of the following statements about JavaScript callbacks is TRUE?",
    "o": [
      "A callback is a function passed as an argument to another function.",
      "Callbacks execute immediately after they are defined.",
      "Callbacks are always synchronous.",
      "Callbacks can only be used with setTimeout."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback(\"Data received\"), 1000);\n}\nfetchData(console.log);\nconsole.log(\"Fetching...\");",
    "o": [
      "Fetching...\nData received",
      "Data received\nFetching...",
      "Fetching...",
      "Data received"
    ]
  },
  {
    "q": "Which of the following is a correct way to convert a callback function into a Promise?",
    "o": [
      "function myAsyncFunction() {\n  return new Promise((resolve, reject) => {\n    myCallbackFunction((error, data) => {\n      if (error) reject(error);\n      else resolve(data);\n    });\n  });\n}",
      "function myAsyncFunction() {\n  return Promise.callback(myCallbackFunction);\n}",
      "function myAsyncFunction() {\n  return myCallbackFunction().promise();\n}",
      "function myAsyncFunction() {\n  return resolvePromise(myCallbackFunction);\n}"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getValue() {\n  return await Promise.resolve(\"Hello Async\");\n}\ngetValue().then(console.log);",
    "o": [
      "Hello Async",
      "Promise { 'Hello Async' }",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to handle multiple promises simultaneously?",
    "o": [
      "Promise.all([promise1, promise2]).then(results => console.log(results));",
      "Promise.all(promise1, promise2).then(results => console.log(results));",
      "Promise.all(promise1, promise2).catch(error => console.log(error));",
      "Promise.all([promise1, promise2]).resolve(results => console.log(results));"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"Start\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"End\");\n}\ntest();\nconsole.log(\"Middle\");",
    "o": [
      "Start\nMiddle\nEnd",
      "Start\nEnd\nMiddle",
      "Middle\nStart\nEnd",
      "Start\nMiddle\nEnd after 1 second"
    ]
  },
  {
    "q": "Which of the following is the correct way to reject a promise?",
    "o": [
      "return Promise.reject(\"Error occurred\");",
      "return Promise.failure(\"Error occurred\");",
      "return reject.Promise(\"Error occurred\");",
      "throw new Promise(\"Error occurred\");"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  throw new Error(\"Something went wrong\");\n}\nfetchData().catch(console.log);",
    "o": [
      "Error: Something went wrong",
      "Promise { <rejected>: \"Something went wrong\" }",
      "undefined",
      "Nothing, as errors in async functions are ignored"
    ]
  },
  {
    "q": "Which statement about async/await is TRUE?",
    "o": [
      "Async functions always return a Promise.",
      "Async functions execute faster than synchronous functions.",
      "Await can be used in any function, even non-async ones.",
      "Async functions block the main thread until execution completes."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve().then(() => console.log(\"Promise\"));\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise\nTimeout",
      "Start\nTimeout\nPromise\nEnd",
      "Start\nPromise\nEnd\nTimeout",
      "Start\nEnd\nTimeout\nPromise"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a callback function?",
    "o": [
      "function fetchData(callback) { callback(\"Data\"); }",
      "function fetchData[callback] { callback(\"Data\"); }",
      "function fetchData { callback(\"Data\"); }",
      "callback function fetchData() { callback(\"Data\"); }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncTask() {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(\"Task Completed\"), 1000);\n  });\n}\nasyncTask().then(console.log);\nconsole.log(\"Task Started\");",
    "o": [
      "Task Started\nTask Completed",
      "Task Completed\nTask Started",
      "Task Started",
      "Task Completed"
    ]
  },
  {
    "q": "Which method waits for all promises to resolve or any to reject?",
    "o": [
      "Promise.all()",
      "Promise.any()",
      "Promise.allSettled()",
      "Promise.race()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return \"Hello World\";\n}\nconsole.log(fetchData());",
    "o": [
      "Promise { 'Hello World' }",
      "Hello World",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to handle errors in an async function?",
    "o": [
      "try { await someFunction(); } catch (error) { console.log(error); }",
      "await someFunction().catch(error => console.log(error));",
      "Both of the above",
      "Errors in async functions cannot be handled"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"Start\");\n  await Promise.reject(\"Error\");\n  console.log(\"End\");\n}\ntest().catch(console.log);",
    "o": [
      "Start\nError",
      "Start\nEnd",
      "Error\nStart",
      "End\nStart"
    ]
  },
  {
    "q": "Which of the following is true about JavaScript promises?",
    "o": [
      "A promise can be in one of three states: pending, fulfilled, or rejected.",
      "A promise can only be fulfilled or rejected, never pending.",
      "A promise executes immediately, even if not awaited.",
      "Promises are synchronous in nature."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout 1\"), 500);\nsetTimeout(() => console.log(\"Timeout 2\"), 0);\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 2\nTimeout 1\nEnd",
      "Timeout 2\nStart\nEnd\nTimeout 1",
      "Start\nEnd\nTimeout 1\nTimeout 2"
    ]
  },
  {
    "q": "Which of the following correctly describes async/await?",
    "o": [
      "It allows writing asynchronous code in a synchronous style.",
      "It blocks the execution of JavaScript until the async function is resolved.",
      "It only works with setTimeout and setInterval.",
      "It replaces Promises entirely."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"A\"), 1000);\nsetTimeout(() => console.log(\"B\"), 500);\nconsole.log(\"C\");",
    "o": [
      "C\nB\nA",
      "B\nC\nA",
      "C\nA\nB",
      "A\nB\nC"
    ]
  },
  {
    "q": "Which of the following statements about JavaScript callbacks is true?",
    "o": [
      "Callbacks allow asynchronous operations to be executed in order.",
      "Callbacks are always executed synchronously.",
      "Callbacks must always be named functions.",
      "Callbacks are only used with setTimeout."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => {\n    callback(\"Data received\");\n  }, 1000);\n}\nfetchData(console.log);\nconsole.log(\"Fetching...\");",
    "o": [
      "Fetching...\nData received",
      "Data received\nFetching...",
      "Fetching...",
      "Data received"
    ]
  },
  {
    "q": "Which method returns a promise that resolves when the first of multiple promises resolves?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.any()",
      "Promise.allSettled()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"Start\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"End\");\n}\ntest();\nconsole.log(\"Outside\");",
    "o": [
      "Start\nOutside\nEnd",
      "Start\nEnd\nOutside",
      "Outside\nStart\nEnd",
      "Start\nEnd"
    ]
  },
  {
    "q": "Which of the following is true about Promises in JavaScript?",
    "o": [
      "A Promise can be pending, fulfilled, or rejected.",
      "A Promise must always be resolved.",
      "A rejected Promise cannot be handled.",
      "A Promise executes code synchronously."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getValue() {\n  return \"Hello\";\n}\nconsole.log(getValue());",
    "o": [
      "Promise { 'Hello' }",
      "Hello",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly handles errors in async/await?",
    "o": [
      "try { await fetchData(); } catch (error) { console.error(error); }",
      "await fetchData().catch(error => console.error(error));",
      "Both of the above",
      "Errors in async/await cannot be caught"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve().then(() => console.log(\"Promise\"));\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise\nTimeout",
      "Start\nPromise\nEnd\nTimeout",
      "Start\nTimeout\nPromise\nEnd",
      "Start\nEnd\nTimeout\nPromise"
    ]
  },
  {
    "q": "Which of the following best describes async/await?",
    "o": [
      "It simplifies writing asynchronous code using Promises.",
      "It makes JavaScript execution synchronous.",
      "It replaces callbacks entirely.",
      "It only works with fetch API."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"A\"), 0);\nsetTimeout(() => console.log(\"B\"), 1000);\nconsole.log(\"C\");",
    "o": [
      "C\nA\nB",
      "C\nB\nA",
      "A\nC\nB",
      "A\nB\nC"
    ]
  },
  {
    "q": "Which of the following is an example of a callback function in JavaScript?",
    "o": [
      "setTimeout(() => console.log(\"Delayed\"), 1000);",
      "function myFunction() { return true; }",
      "const promise = new Promise(resolve => resolve());",
      "let x = 5;"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncTask() {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(\"Task done!\"), 500);\n  });\n}\nasyncTask().then(console.log);\nconsole.log(\"Task started!\");",
    "o": [
      "Task started!\nTask done!",
      "Task done!\nTask started!",
      "Task started!",
      "Task done!"
    ]
  },
  {
    "q": "Which of the following methods is used to handle multiple promises in JavaScript?",
    "o": [
      "Promise.all()",
      "setTimeout()",
      "Promise.delay()",
      "Promise.finally()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function demo() {\n  console.log(\"Start\");\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log(\"End\");\n}\ndemo();\nconsole.log(\"Outside\");",
    "o": [
      "Start\nOutside\nEnd",
      "Start\nEnd\nOutside",
      "Outside\nStart\nEnd",
      "Outside\nEnd\nStart"
    ]
  },
  {
    "q": "Which of the following statements is true about Promises in JavaScript?",
    "o": [
      "A promise can either be resolved or rejected, but never pending.",
      "A promise executes immediately once created.",
      "Promises can only be used with asynchronous functions.",
      "Promises can only resolve with primitive values like strings or numbers."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log(\"First\");\n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log(\"Second\");\n}\ntest();\nconsole.log(\"Third\");",
    "o": [
      "First\nThird\nSecond",
      "First\nSecond\nThird",
      "Third\nFirst\nSecond",
      "Second\nFirst\nThird"
    ]
  },
  {
    "q": "What is the purpose of the `Promise.all()` method in JavaScript?",
    "o": [
      "It returns a single promise that resolves when all promises passed as arguments are resolved.",
      "It executes multiple promises one after another.",
      "It returns the first promise that resolves.",
      "It waits for any promise to resolve."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log(\"Start\");\nPromise.resolve().then(() => console.log(\"Promise 1\"));\nsetTimeout(() => console.log(\"Timeout\"), 0);\nPromise.resolve().then(() => console.log(\"Promise 2\"));\nconsole.log(\"End\");",
    "o": [
      "Start\nEnd\nPromise 1\nPromise 2\nTimeout",
      "Start\nEnd\nPromise 1\nTimeout\nPromise 2",
      "Start\nEnd\nTimeout\nPromise 1\nPromise 2",
      "Start\nEnd\nTimeout\nPromise 2\nPromise 1"
    ]
  },
  {
    "q": "Which of the following is a correct way to handle errors in async/await?",
    "o": [
      "try { await fetchData(); } catch (error) { console.log(error); }",
      "await fetchData().catch(error => console.log(error));",
      "Both of the above",
      "Async/await does not allow error handling"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log(\"A\"), 500);\nsetTimeout(() => console.log(\"B\"), 0);\nconsole.log(\"C\");",
    "o": [
      "C\nB\nA",
      "C\nA\nB",
      "A\nB\nC",
      "B\nA\nC"
    ]
  },
  {
    "q": "Which of the following is an example of using callbacks in JavaScript?",
    "o": [
      "setTimeout(() => console.log('Hello'), 1000);",
      "const promise = new Promise((resolve, reject) => resolve('Done'));",
      "let x = new Set([1, 2, 3]);",
      "const obj = { key: 'value' };"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => {\n    callback('Data fetched');\n  }, 2000);\n}\nfetchData((message) => console.log(message));\nconsole.log('Loading...');",
    "o": [
      "Loading...\nData fetched",
      "Data fetched\nLoading...",
      "Loading...",
      "Data fetched"
    ]
  },
  {
    "q": "Which of the following methods returns a promise that resolves when all promises have resolved?",
    "o": [
      "Promise.all()",
      "Promise.any()",
      "Promise.resolve()",
      "Promise.race()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  const data = await new Promise(resolve => resolve('Fetched Data'));\n  console.log(data);\n}\ngetData();",
    "o": [
      "Fetched Data",
      "undefined",
      "Promise { <pending> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes how promises work in JavaScript?",
    "o": [
      "Promises represent the eventual completion (or failure) of an asynchronous operation.",
      "Promises are only used for asynchronous functions with no return value.",
      "Promises are synchronous by default and can be forced to run asynchronously.",
      "Promises must be resolved before they can be chained."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function demo() {\n  console.log('Start');\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  console.log('End');\n}\ndemo();\nconsole.log('Outside');",
    "o": [
      "Start\nOutside\nEnd",
      "Start\nEnd\nOutside",
      "Outside\nStart\nEnd",
      "End\nStart\nOutside"
    ]
  },
  {
    "q": "What is the purpose of the `await` keyword in JavaScript?",
    "o": [
      "It pauses the execution of an async function until the promise is resolved or rejected.",
      "It is used to define an asynchronous function.",
      "It makes a function synchronous.",
      "It returns a value from a function."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nPromise.resolve().then(() => console.log('Promise 1'));\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise 2'));\nconsole.log('End');",
    "o": [
      "Start\nEnd\nPromise 1\nPromise 2\nTimeout",
      "Start\nEnd\nPromise 1\nTimeout\nPromise 2",
      "Start\nEnd\nTimeout\nPromise 1\nPromise 2",
      "Start\nTimeout\nPromise 1\nPromise 2\nEnd"
    ]
  },
  {
    "q": "Which of the following is true about error handling in async/await functions?",
    "o": [
      "You can handle errors with try/catch blocks around async/await.",
      "Async/await functions cannot throw errors.",
      "Errors in async/await functions are automatically logged.",
      "Error handling is not required in async/await functions."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Middle'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nMiddle",
      "Start\nMiddle\nEnd",
      "Middle\nStart\nEnd",
      "End\nStart\nMiddle"
    ]
  },
  {
    "q": "Which of the following is a valid way to create a promise in JavaScript?",
    "o": [
      "const myPromise = new Promise((resolve, reject) => { resolve('Success'); });",
      "const myPromise = new Promise(resolve => resolve('Success'))",
      "const myPromise = Promise();",
      "const myPromise = new Promise(resolve => reject('Error'));"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('Data Loaded'), 1000);\n  });\n}\nfetchData().then((result) => { console.log(result); });\nconsole.log('Fetching...');",
    "o": [
      "Fetching...\nData Loaded",
      "Fetching...\nundefined",
      "Data Loaded\nFetching...",
      "undefined\nFetching..."
    ]
  },
  {
    "q": "Which of the following is true about promises in JavaScript?",
    "o": [
      "A promise represents a value that may be available now, or in the future.",
      "A promise is an object returned by a function and cannot be resolved.",
      "Promises can only be resolved with primitive values.",
      "Promises are executed synchronously."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function processData() {\n  let result = await new Promise(resolve => setTimeout(() => resolve('Processed'), 1500));\n  console.log(result);\n}\nprocessData();\nconsole.log('Processing...');",
    "o": [
      "Processing...\nProcessed",
      "Processed\nProcessing...",
      "Processing...",
      "Processed"
    ]
  },
  {
    "q": "Which of the following is an advantage of using async/await over callbacks?",
    "o": [
      "Async/await leads to cleaner and more readable code than callbacks.",
      "Async/await is always faster than callbacks.",
      "Async/await works only with promises and cannot handle synchronous code.",
      "Async/await does not support error handling."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function processData(callback) {\n  setTimeout(() => {\n    callback('Data Processed');\n  }, 2000);\n}\nprocessData((message) => { console.log(message); });\nconsole.log('Starting process...');",
    "o": [
      "Starting process...\nData Processed",
      "Data Processed\nStarting process...",
      "Starting process...",
      "Data Processed"
    ]
  },
  {
    "q": "Which method of a promise is used to handle errors in JavaScript?",
    "o": [
      ".catch()",
      ".resolve()",
      ".finally()",
      ".then()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => { resolve('Success!'); });\nmyPromise.then((result) => { console.log(result); });\nconsole.log('Promise initiated');",
    "o": [
      "Promise initiated\nSuccess!",
      "Success!\nPromise initiated",
      "Promise initiated",
      "undefined\nSuccess!"
    ]
  },
  {
    "q": "What does the following code do in JavaScript?",
    "l": "javascript",
    "c": "async function asyncFunction() {\n  let result = await Promise.reject('Error occurred');\n  console.log(result);\n}\nasyncFunction();",
    "o": [
      "It throws an error: 'Error occurred'.",
      "It prints 'Error occurred'.",
      "It catches the error and prints 'Error occurred'.",
      "It resolves the promise with 'Error occurred'."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Delayed'), 2000);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nDelayed",
      "Start\nDelayed\nEnd",
      "Delayed\nStart\nEnd",
      "End\nStart\nDelayed"
    ]
  },
  {
    "q": "Which of the following will cause a promise to be rejected?",
    "o": [
      "Promise.reject('Error')",
      "Promise.resolve('Success')",
      "Promise.all([promise1, promise2])",
      "new Promise((resolve, reject) => { resolve('Done') });"
    ]
  },
  {
    "q": "What is the purpose of the `Promise.all()` method in JavaScript?",
    "o": [
      "It runs multiple promises in parallel and returns a single promise that resolves when all the promises are resolved.",
      "It executes promises one by one and returns the first resolved promise.",
      "It resolves only the first promise and ignores others.",
      "It catches errors from all promises in the array."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => { reject('Error!'); });\nmyPromise.catch((error) => { console.log(error); });",
    "o": [
      "Error!",
      "undefined",
      "Promise { <pending> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to handle multiple asynchronous operations using promises?",
    "o": [
      "Promise.all([promise1, promise2, promise3])",
      "Promise.parallel([promise1, promise2, promise3])",
      "Promise.any([promise1, promise2, promise3])",
      "Promise.each([promise1, promise2, promise3])"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  let result = await new Promise((resolve, reject) => reject('Failed'));\n  console.log(result);\n}\nexample();",
    "o": [
      "Failed",
      "undefined",
      "Error",
      "Promise { <pending> }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => console.log('A'), 0);\nsetTimeout(() => console.log('B'), 0);\nconsole.log('C');",
    "o": [
      "C\nA\nB",
      "C\nB\nA",
      "A\nB\nC",
      "B\nA\nC"
    ]
  },
  {
    "q": "What is the key benefit of using async/await over promises with .then()?",
    "o": [
      "Async/await makes asynchronous code look and behave more like synchronous code.",
      "Async/await always runs faster than promises.",
      "Async/await requires fewer lines of code than promises.",
      "Async/await is only useful in handling synchronous code."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return 'Fetched Data';\n}\nfetchData().then((result) => console.log(result));",
    "o": [
      "Fetched Data",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "What is the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  throw new Error('Something went wrong!');\n}\nfetchData().catch((error) => console.log(error.message));",
    "o": [
      "Something went wrong!",
      "undefined",
      "Error",
      "Promise { <rejected> }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('In Timeout'), 1000);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nIn Timeout",
      "In Timeout\nStart\nEnd",
      "End\nStart\nIn Timeout",
      "Start\nIn Timeout\nEnd"
    ]
  },
  {
    "q": "What will the following JavaScript code snippet log to the console?",
    "l": "javascript",
    "c": "function myFunction(a, b, callback) {\n  setTimeout(() => {\n    callback(a + b);\n  }, 2000);\n}\nmyFunction(3, 4, (result) => { console.log(result); });",
    "o": [
      "7",
      "undefined",
      "NaN",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about promises in JavaScript?",
    "o": [
      "A promise can be either resolved or rejected, but not both.",
      "Promises can only resolve with primitive values.",
      "Promises can handle synchronous operations.",
      "A promise cannot be resolved after it has been rejected."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    resolve('Data loaded');\n  });\n}\nfetchData().then((message) => { console.log(message); });",
    "o": [
      "Data loaded",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods is used to handle multiple promises and return a single result once all promises have been resolved?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.resolve()",
      "Promise.finally()"
    ]
  },
  {
    "q": "What will the following JavaScript code snippet output?",
    "l": "javascript",
    "c": "async function asyncFunction() {\n  const result = await new Promise((resolve, reject) => resolve('Resolved!'));\n  console.log(result);\n}\nasyncFunction();",
    "o": [
      "Resolved!",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the `finally()` method in a promise?",
    "o": [
      "It allows you to run code after the promise is settled, regardless of whether it was resolved or rejected.",
      "It catches errors in the promise chain.",
      "It is used to convert a promise into a synchronous function.",
      "It immediately executes the next promise in the chain."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => { console.log('First'); }, 1000);\nsetTimeout(() => { console.log('Second'); }, 500);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nSecond\nFirst",
      "Start\nSecond\nEnd\nFirst",
      "Start\nEnd\nFirst\nSecond",
      "End\nStart\nSecond\nFirst"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  return 'Fetched';\n}\nconst result = fetchData();\nconsole.log(result);",
    "o": [
      "Promise { <resolved> }",
      "Fetched",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "What is the correct way to handle errors in async/await functions in JavaScript?",
    "o": [
      "Using try/catch blocks",
      "Using .catch() method",
      "Using .then() method",
      "Using .finally() method"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 2000);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 1\nTimeout 2\nEnd",
      "Timeout 2\nStart\nEnd\nTimeout 1",
      "Timeout 1\nStart\nEnd\nTimeout 2"
    ]
  },
  {
    "q": "Which of the following statements is true about the `async` keyword in JavaScript?",
    "o": [
      "It makes a function return a promise.",
      "It makes a function execute synchronously.",
      "It causes an immediate error if used with non-async functions.",
      "It is only used with callback functions."
    ]
  },
  {
    "q": "What is the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    resolve('Fetched Data');\n  });\n}\nfetchData().then((data) => console.log(data));",
    "o": [
      "Fetched Data",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncFunc() {\n  const result = await Promise.reject('Something went wrong');\n  console.log(result);\n}\nasyncFunc();",
    "o": [
      "Uncaught (in promise) Something went wrong",
      "undefined",
      "Something went wrong",
      "Promise { <rejected> }"
    ]
  },
  {
    "q": "Which of the following is the correct syntax to handle multiple asynchronous operations using `Promise.all()`?",
    "o": [
      "Promise.all([promise1, promise2, promise3])",
      "Promise.all(promise1, promise2, promise3)",
      "Promise.all{promise1, promise2, promise3}",
      "Promise.all([promise1, promise2].then(promise3))"
    ]
  },
  {
    "q": "What will the following JavaScript code snippet output?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => { reject('Error!'); });\nmyPromise.catch((error) => { console.log(error); });",
    "o": [
      "Error!",
      "undefined",
      "Promise { <rejected> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following JavaScript functions can be used to handle errors in promises?",
    "o": [
      ".catch()",
      ".error()",
      ".reject()",
      ".finally()"
    ]
  },
  {
    "q": "What is the purpose of the `await` keyword in JavaScript?",
    "o": [
      "It pauses the execution of an async function until a promise is resolved.",
      "It makes a function return immediately.",
      "It allows asynchronous code to run synchronously.",
      "It waits for a timeout to finish."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  const result = await new Promise((resolve) => setTimeout(() => resolve('Resolved!'), 2000));\n  console.log(result);\n}\nexample();",
    "o": [
      "Resolved!",
      "undefined",
      "Promise { <pending> }",
      "Error"
    ]
  },
  {
    "q": "What is the correct way to chain promises in JavaScript?",
    "o": [
      "Using .then() after each promise",
      "Using .async() after each promise",
      "Using .next() after each promise",
      "Using .await() after each promise"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 0);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 1\nTimeout 2",
      "Start\nTimeout 1\nEnd\nTimeout 2",
      "Start\nTimeout 1\nTimeout 2\nEnd",
      "Timeout 1\nTimeout 2\nStart\nEnd"
    ]
  },
  {
    "q": "What does the `async` function return in JavaScript?",
    "o": [
      "A promise",
      "A value",
      "A callback",
      "Nothing"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function asyncExample() {\n  return new Promise((resolve) => { setTimeout(() => resolve('Done'), 2000); });\n}\nasyncExample().then((message) => console.log(message));",
    "o": [
      "Done",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "Which method is used to execute multiple promises concurrently and return a result when all promises are resolved?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.allSettled()",
      "Promise.finally()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function delay() {\n  const value = await new Promise((resolve) => setTimeout(() => resolve('Resolved after delay'), 1000));\n  console.log(value);\n}\ndelay();",
    "o": [
      "Resolved after delay",
      "undefined",
      "Promise { <pending> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for handling a promise rejection in JavaScript?",
    "o": [
      ".catch()",
      ".reject()",
      ".finally()",
      ".then()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Inside Timeout'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nInside Timeout",
      "Inside Timeout\nStart\nEnd",
      "End\nStart\nInside Timeout",
      "Start\nInside Timeout\nEnd"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const myPromise = new Promise((resolve, reject) => { reject('Error occurred!'); });\nmyPromise.finally(() => { console.log('Promise finished'); });",
    "o": [
      "Promise finished",
      "undefined",
      "Error occurred!",
      "Nothing"
    ]
  },
  {
    "q": "What will the following JavaScript code log to the console?",
    "l": "javascript",
    "c": "function callbackExample(callback) {\n  setTimeout(() => callback('Hello'), 1000);\n}\ncallbackExample((message) => { console.log(message); });",
    "o": [
      "Hello",
      "undefined",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following correctly uses `async/await` to handle a promise in JavaScript?",
    "o": [
      "const result = await fetchData();",
      "const result = fetchData(); await result;",
      "await fetchData().then(result);",
      "fetchData() then(result);"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 1000);\nsetTimeout(() => console.log('Timeout 2'), 500);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 1\nTimeout 2\nEnd",
      "Timeout 2\nStart\nEnd\nTimeout 1",
      "Timeout 1\nStart\nEnd\nTimeout 2"
    ]
  },
  {
    "q": "What does the `Promise.race()` method do in JavaScript?",
    "o": [
      "It returns a promise that resolves or rejects as soon as one of the promises in the array resolves or rejects.",
      "It returns a promise that resolves when all promises in the array resolve.",
      "It allows you to set a timeout for promises to resolve.",
      "It prevents any promise from resolving until all are settled."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncFunction() {\n  const promise1 = Promise.resolve('Resolved1');\n  const promise2 = Promise.resolve('Resolved2');\n  const result = await Promise.race([promise1, promise2]);\n  console.log(result);\n}\nasyncFunction();",
    "o": [
      "Resolved1",
      "Resolved2",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to catch errors in promises in JavaScript?",
    "o": [
      "Using `.catch()` method",
      "Using `.then()` method",
      "Using `.finally()` method",
      "Using `.reject()` method"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncExample() {\n  try {\n    const result = await new Promise((resolve, reject) => { reject('Error occurred!'); });\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\nasyncExample();",
    "o": [
      "Error occurred!",
      "undefined",
      "Promise { <rejected> }",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout",
      "Start\nTimeout\nEnd",
      "Timeout\nStart\nEnd",
      "End\nStart\nTimeout"
    ]
  },
  {
    "q": "Which of the following JavaScript methods is used to execute a function when a promise is settled, regardless of whether it is resolved or rejected?",
    "o": [
      ".finally()",
      ".then()",
      ".catch()",
      ".resolve()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const data = await new Promise((resolve, reject) => setTimeout(() => resolve('Fetched data'), 2000));\n  return data;\n}\nfetchData().then(result => console.log(result));",
    "o": [
      "Fetched data",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct syntax to handle multiple promises concurrently using `Promise.allSettled()`?",
    "o": [
      "Promise.allSettled([promise1, promise2, promise3])",
      "Promise.allSettled(promise1, promise2, promise3)",
      "Promise.allSettled{promise1, promise2, promise3}",
      "Promise.allSettled([promise1.then(promise2)])"
    ]
  },
  {
    "q": "What is the advantage of using async/await over promises in JavaScript?",
    "o": [
      "It makes asynchronous code look and behave like synchronous code.",
      "It makes promises run synchronously.",
      "It provides better error handling than promises.",
      "It makes callbacks more efficient."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 500);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 1\nTimeout 2\nEnd",
      "Timeout 2\nStart\nEnd\nTimeout 1",
      "Timeout 1\nStart\nEnd\nTimeout 2"
    ]
  },
  {
    "q": "Which of the following statements is correct about promises in JavaScript?",
    "o": [
      "A promise can be in one of three states: pending, resolved, or rejected.",
      "A promise can only be in the resolved state.",
      "A promise can only be in the rejected state.",
      "Promises are not asynchronous."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  const result = await new Promise(resolve => resolve('Hello World'));\n  console.log(result);\n}\nexample();",
    "o": [
      "Hello World",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to return a promise from an asynchronous function?",
    "o": [
      "return new Promise((resolve, reject) => { /* some code */ });",
      "return Promise.resolve();",
      "return Promise.reject();",
      "All of the above"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncTest() {\n  return 'Resolved value';\n}\nconsole.log(asyncTest());",
    "o": [
      "Promise { <resolved> 'Resolved value' }",
      "'Resolved value'",
      "undefined",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods can be used to handle both resolved and rejected promises in JavaScript?",
    "o": [
      "Promise.finally()",
      "Promise.then()",
      "Promise.catch()",
      "Promise.resolve()"
    ]
  },
  {
    "q": "What is the behavior of `await` in JavaScript?",
    "o": [
      "It waits for a promise to resolve and returns the result.",
      "It immediately resolves the promise.",
      "It executes the code synchronously.",
      "It creates a new promise."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function callbackFunction(callback) {\n  setTimeout(() => callback('Callback executed'), 1000);\n}\ncallbackFunction((message) => { console.log(message); });",
    "o": [
      "Callback executed",
      "undefined",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for chaining `.then()` and `.catch()` methods on a promise?",
    "o": [
      "promise.then(result => { /* success */ }).catch(error => { /* error */ });",
      "promise.then(result => { /* success */ }).catch();",
      "promise.then().catch(error => { /* error */ });",
      "promise.catch(result => { /* success */ }).then();"
    ]
  },
  {
    "q": "Which of the following methods is used to create a new promise that settles when all the input promises are settled, regardless of whether they are resolved or rejected?",
    "o": [
      "Promise.allSettled()",
      "Promise.all()",
      "Promise.race()",
      "Promise.any()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function testAsync() {\n  const result = await Promise.resolve('Async resolved');\n  console.log(result);\n}\ntestAsync();",
    "o": [
      "Async resolved",
      "undefined",
      "Promise { <resolved> 'Async resolved' }",
      "Error"
    ]
  },
  {
    "q": "Which method is used to create a promise that resolves after a specified time?",
    "o": [
      "setTimeout()",
      "Promise.resolve()",
      "Promise.reject()",
      "setInterval()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "const promise1 = Promise.resolve('Resolved 1');\nconst promise2 = Promise.resolve('Resolved 2');\nPromise.all([promise1, promise2]).then(results => console.log(results));",
    "o": [
      "['Resolved 1', 'Resolved 2']",
      "Promise { <resolved> }",
      "Resolved 1, Resolved 2",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of `async/await` in JavaScript?",
    "o": [
      "To make asynchronous code look and behave like synchronous code.",
      "To execute synchronous code asynchronously.",
      "To speed up the execution of asynchronous code.",
      "To prevent callback hell."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  try {\n    const result = await new Promise((resolve, reject) => reject('Error!'));\n    console.log(result);\n  } catch (error) {\n    console.log(error);\n  }\n}\nexample();",
    "o": [
      "Error!",
      "undefined",
      "Promise { <rejected> 'Error!' }",
      "Error: Error!"
    ]
  },
  {
    "q": "Which of the following statements is true about `Promise.all()`?",
    "o": [
      "It resolves when all promises in the array are resolved.",
      "It resolves when any one promise in the array is resolved.",
      "It rejects when any promise in the array rejects.",
      "Both A and C"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 0);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 1\nTimeout 2",
      "Start\nTimeout 1\nEnd\nTimeout 2",
      "Timeout 1\nStart\nEnd\nTimeout 2",
      "Timeout 2\nStart\nEnd\nTimeout 1"
    ]
  },
  {
    "q": "What is the purpose of `Promise.catch()` method in JavaScript?",
    "o": [
      "It handles errors or rejected promises.",
      "It immediately resolves the promise.",
      "It handles both resolved and rejected promises.",
      "It ensures a promise is always resolved."
    ]
  },
  {
    "q": "Which of the following methods allows you to create a promise that resolves with the first fulfilled promise from an array of promises?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.any()",
      "Promise.allSettled()"
    ]
  },
  {
    "q": "What is the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const result = await new Promise((resolve, reject) => setTimeout(() => resolve('Data fetched'), 2000));\n  console.log(result);\n}\nfetchData();",
    "o": [
      "Data fetched",
      "undefined",
      "Promise { <resolved> }",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const data = await new Promise((resolve) => setTimeout(() => resolve('Fetched Data'), 1500));\n  console.log(data);\n}\nfetchData();",
    "o": [
      "Fetched Data",
      "undefined",
      "Promise { <resolved> 'Fetched Data' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for creating a promise in JavaScript?",
    "o": [
      "new Promise((resolve, reject) => { /* some code */ });",
      "new promise((resolve, reject) => { /* some code */ });",
      "Promise.new((resolve, reject) => { /* some code */ });",
      "Promise.create((resolve, reject) => { /* some code */ });"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('End');\n}\ntest();",
    "o": [
      "Start\nEnd",
      "End\nStart",
      "Start\nundefined\nEnd",
      "undefined\nStart\nEnd"
    ]
  },
  {
    "q": "Which of the following methods allows chaining multiple asynchronous actions and handles errors at the end?",
    "o": [
      "Promise.then().catch()",
      "Promise.then().finally()",
      "Promise.finally().then()",
      "Promise.catch().finally()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => { console.log('Inside setTimeout'); }, 0);\nconsole.log('Outside setTimeout');",
    "o": [
      "Outside setTimeout\nInside setTimeout",
      "Inside setTimeout\nOutside setTimeout",
      "Inside setTimeout",
      "Outside setTimeout"
    ]
  },
  {
    "q": "Which of the following statements about `async` functions is true?",
    "o": [
      "An `async` function always returns a promise.",
      "An `async` function can never throw an error.",
      "An `async` function executes synchronously.",
      "An `async` function does not support `await`."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function asyncExample() {\n  return 'Promise resolved';\n}\nasyncExample().then(result => console.log(result));",
    "o": [
      "Promise resolved",
      "undefined",
      "Promise { <resolved> 'Promise resolved' }",
      "Error"
    ]
  },
  {
    "q": "What does the `Promise.all()` method do when one of the promises in the array is rejected?",
    "o": [
      "It immediately rejects the entire promise array.",
      "It ignores the rejected promise and resolves the rest.",
      "It resolves the entire promise array.",
      "It returns an error for the resolved promises."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Data loaded'), 2000);\n}\nfetchData(data => console.log(data));",
    "o": [
      "Data loaded",
      "undefined",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct way to catch an error in an `async/await` function?",
    "o": [
      "try { await somePromise(); } catch (error) { console.log(error); }",
      "catch { await somePromise(); }",
      "await try { somePromise(); } catch (error) { console.log(error); }",
      "await somePromise(); catch (error) { console.log(error); }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const result = await new Promise(resolve => resolve('Success'));\n  console.log(result);\n}\nfetchData();",
    "o": [
      "Success",
      "undefined",
      "Promise { <resolved> 'Success' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to handle multiple promises in parallel and resolve them all?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.any()",
      "Promise.settle()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 0);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 1\nTimeout 2",
      "Start\nTimeout 1\nEnd\nTimeout 2",
      "Timeout 1\nStart\nEnd\nTimeout 2",
      "Timeout 2\nStart\nEnd\nTimeout 1"
    ]
  },
  {
    "q": "Which of the following statements about `async/await` is true?",
    "o": [
      "It makes asynchronous code look and behave like synchronous code.",
      "It is used only for synchronous code.",
      "It can only be used with `Promise.resolve()`.",
      "It prevents JavaScript from executing code asynchronously."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function getData() {\n  const result = await new Promise((resolve, reject) => setTimeout(() => reject('Error!'), 1000));\n  console.log(result);\n} \ngetData().catch(error => console.log(error));",
    "o": [
      "Error!",
      "undefined",
      "Promise { <rejected> 'Error!' }",
      "Error: Error!"
    ]
  },
  {
    "q": "What does the `Promise.race()` method do?",
    "o": [
      "It returns a promise that resolves or rejects as soon as one of the promises resolves or rejects.",
      "It waits for all promises to resolve and returns a single result.",
      "It resolves only if all promises in the array resolve.",
      "It resolves after the longest promise resolves."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Fetched Data'), 2000);\n}\nfetchData(function(data) { console.log(data); });",
    "o": [
      "Fetched Data",
      "undefined",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which method is used to chain promises and handle results once all promises have been resolved?",
    "o": [
      "Promise.all()",
      "Promise.then()",
      "Promise.finally()",
      "Promise.catch()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function greet() {\n  const name = await Promise.resolve('Alice');\n  console.log('Hello, ' + name);\n}\ngreet();",
    "o": [
      "Hello, Alice",
      "Hello, undefined",
      "Promise { <resolved> 'Alice' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a valid syntax to create a promise in JavaScript?",
    "o": [
      "new Promise((resolve, reject) => { /* some code */ });",
      "Promise.create((resolve, reject) => { /* some code */ });",
      "Promise.new((resolve, reject) => { /* some code */ });",
      "new Promise({ resolve, reject }) => { /* some code */ }"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const result = await new Promise(resolve => setTimeout(() => resolve('Completed'), 1500));\n  console.log(result);\n}\nfetchData();",
    "o": [
      "Completed",
      "undefined",
      "Promise { <resolved> 'Completed' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a valid syntax for handling multiple asynchronous operations concurrently using promises?",
    "o": [
      "Promise.all([promise1, promise2, promise3])",
      "Promise.parallel([promise1, promise2, promise3])",
      "Promise.concurrent([promise1, promise2, promise3])",
      "Promise.wait([promise1, promise2, promise3])"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Inside Timeout'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nInside Timeout",
      "Start\nInside Timeout\nEnd",
      "Inside Timeout\nStart\nEnd",
      "Inside Timeout\nEnd\nStart"
    ]
  },
  {
    "q": "Which of the following methods allows you to handle a promise that might be rejected but still execute the final block of code?",
    "o": [
      "Promise.finally()",
      "Promise.then()",
      "Promise.catch()",
      "Promise.all()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const data = await new Promise((resolve, reject) => setTimeout(() => reject('Something went wrong!'), 1000));\n  console.log(data);\n}\nfetchData().catch(error => console.log(error));",
    "o": [
      "Something went wrong!",
      "undefined",
      "Promise { <rejected> 'Something went wrong!' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct example of a `Promise` chain?",
    "o": [
      "promise.then(result => { return result; }).catch(error => { console.error(error); })",
      "promise.then(result => { return result; }).finally(() => { console.log('Done'); })",
      "promise.then(result => { return result; }).onRejected(() => { console.log('Error'); })",
      "promise.catch(result => { console.log(result); }).then(() => { console.log('Done'); })"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function greeting() {\n  const name = await Promise.resolve('Alice');\n  console.log(`Hello, ${name}`);\n}\ngreeting();",
    "o": [
      "Hello, Alice",
      "Hello, undefined",
      "Promise { <resolved> 'Alice' }",
      "Error"
    ]
  },
  {
    "q": "Which method can be used to handle multiple promises in parallel, and return when the first promise resolves or rejects?",
    "o": [
      "Promise.race()",
      "Promise.all()",
      "Promise.any()",
      "Promise.allSettled()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "setTimeout(() => { console.log('Callback 1'); }, 0);\nsetTimeout(() => { console.log('Callback 2'); }, 0);\nconsole.log('Synchronous code');",
    "o": [
      "Synchronous code\nCallback 1\nCallback 2",
      "Callback 1\nSynchronous code\nCallback 2",
      "Callback 2\nSynchronous code\nCallback 1",
      "Synchronous code\nCallback 2\nCallback 1"
    ]
  },
  {
    "q": "Which of the following statements is true about the `async` keyword in JavaScript?",
    "o": [
      "It indicates that a function always returns a promise.",
      "It makes the function run synchronously.",
      "It automatically handles errors without the need for `.catch()`.",
      "It ensures the function executes asynchronously and returns `undefined`."
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const result = await new Promise(resolve => setTimeout(() => resolve('Data Fetched'), 2000));\n  console.log(result);\n}\nfetchData();",
    "o": [
      "Data Fetched",
      "undefined",
      "Promise { <resolved> 'Data Fetched' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods is used to execute a function when a promise is either resolved or rejected?",
    "o": [
      "finally()",
      "then()",
      "catch()",
      "all()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout 1'), 500);\nsetTimeout(() => console.log('Timeout 2'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout 2\nTimeout 1",
      "Start\nTimeout 2\nEnd\nTimeout 1",
      "Timeout 2\nStart\nEnd\nTimeout 1",
      "Timeout 1\nStart\nTimeout 2\nEnd"
    ]
  },
  {
    "q": "Which method allows you to execute asynchronous code in a more readable, synchronous-looking way?",
    "o": [
      "async/await",
      "Promise.all()",
      "setTimeout()",
      "forEach()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function fetchData() {\n  try {\n    const data = await new Promise((resolve, reject) => setTimeout(() => reject('Error occurred'), 1000));\n    console.log(data);\n  } catch (error) {\n    console.log(error);\n  }\n}\nfetchData();",
    "o": [
      "Error occurred",
      "undefined",
      "Promise { <rejected> 'Error occurred' }",
      "Error: Error occurred"
    ]
  },
  {
    "q": "Which of the following methods can be used to handle multiple promises and returns when all promises are either resolved or rejected?",
    "o": [
      "Promise.allSettled()",
      "Promise.race()",
      "Promise.any()",
      "Promise.all()"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "async function example() {\n  const result = await new Promise((resolve, reject) => setTimeout(() => resolve('Resolved'), 1000));\n  console.log(result);\n}\nexample();",
    "o": [
      "Resolved",
      "undefined",
      "Promise { <resolved> 'Resolved' }",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to handle asynchronous operations using callbacks in JavaScript?",
    "o": [
      "callback(error, result)",
      "promise.then(callback)",
      "await callback()",
      "setTimeout(callback)"
    ]
  },
  {
    "q": "What will be the output of the following JavaScript code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => { console.log('First Timeout'); }, 1000);\nsetTimeout(() => { console.log('Second Timeout'); }, 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nSecond Timeout\nFirst Timeout",
      "Start\nSecond Timeout\nEnd\nFirst Timeout",
      "Start\nFirst Timeout\nEnd\nSecond Timeout",
      "Second Timeout\nStart\nEnd\nFirst Timeout"
    ]
  },
  {
    "q": "Which of the following is true about the `Promise` constructor in JavaScript?",
    "o": [
      "It requires an executor function that takes resolve and reject as arguments.",
      "It automatically resolves with a value of `null`.",
      "It can only resolve values of type `string`.",
      "It automatically catches errors."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nconsole.log('End');",
    "o": [
      "Start\nEnd\nTimeout",
      "Start\nTimeout\nEnd",
      "Timeout\nStart\nEnd",
      "End\nStart\nTimeout"
    ]
  },
  {
    "q": "Which of the following is a valid callback function in JavaScript?",
    "o": [
      "function callback(err, data) { /*...*/ }",
      "callback function(err, data) { /*...*/ }",
      "callback(err, data) => { /*...*/ }",
      "def callback(err, data): /*...*/"
    ]
  },
  {
    "q": "What is the output of the following Promise code?",
    "l": "javascript",
    "c": "let promise = new Promise((resolve) => {\n  resolve('Resolved!');\n});\npromise.then(value => console.log(value));",
    "o": [
      "Resolved!",
      "Promise {<resolved>: 'Resolved!'}",
      "undefined",
      "Nothing is output"
    ]
  },
  {
    "q": "Which method is used to handle multiple promises and wait for all to complete?",
    "o": [
      "Promise.all()",
      "Promise.race()",
      "Promise.some()",
      "Promise.any()"
    ]
  },
  {
    "q": "What is the output of the following async/await code?",
    "l": "javascript",
    "c": "async function test() {\n  return await Promise.resolve('Done');\n}\ntest().then(console.log);",
    "o": [
      "Done",
      "Promise {<resolved>: 'Done'}",
      "undefined",
      "test()"
    ]
  },
  {
    "q": "What is the purpose of the catch() method in a Promise chain?",
    "o": [
      "To handle rejected promises",
      "To pause promise execution",
      "To terminate the promise chain",
      "To catch syntax errors"
    ]
  },
  {
    "q": "What is the output of the following code with nested setTimeout callbacks?",
    "l": "javascript",
    "c": "console.log('First');\nsetTimeout(() => {\n  console.log('Second');\n  setTimeout(() => console.log('Third'), 0);\n}, 0);",
    "o": [
      "First\nSecond\nThird",
      "First\nThird\nSecond",
      "Second\nFirst\nThird",
      "The order is unpredictable"
    ]
  },
  {
    "q": "Which of these is a correct way to create a resolved Promise?",
    "o": [
      "Promise.resolve('value')",
      "new Promise('value')",
      "Promise('value')",
      "Promise.resolved('value')"
    ]
  },
  {
    "q": "What does the following async function return?",
    "l": "javascript",
    "c": "async function getData() {\n  return 'Data';\n}",
    "o": [
      "A Promise that resolves to 'Data'",
      "The string 'Data' directly",
      "undefined",
      "A pending Promise"
    ]
  },
  {
    "q": "What is the purpose of the finally() method in a Promise chain?",
    "o": [
      "To execute code regardless of promise resolution",
      "To mark the end of the promise chain",
      "To handle successful promise resolution",
      "To catch any type of error"
    ]
  },
  {
    "q": "What is the output of the following Promise chain?",
    "l": "javascript",
    "c": "Promise.resolve(1)\n  .then(x => x + 1)\n  .then(x => { throw new Error('Error!') })\n  .catch(() => 3)\n  .then(x => console.log(x));",
    "o": [
      "3",
      "1",
      "2",
      "Error!"
    ]
  },
  {
    "q": "Which statement about async/await is correct?",
    "o": [
      "Async functions always return a Promise",
      "Await can only be used in regular functions",
      "Async/await makes code execute synchronously",
      "Await can be used without async"
    ]
  },
  {
    "q": "What is the output of the following callback-based code?",
    "l": "javascript",
    "c": "function fetchData(callback) {\n  setTimeout(() => callback('Data received'), 1000);\n}\nfetchData((message) => console.log(message));",
    "o": [
      "Data received (after 1 second)",
      "Data received (immediately)",
      "undefined",
      "Error: callback not defined"
    ]
  },
  {
    "q": "Which of the following correctly chains multiple Promises?",
    "o": [
      "promise.then().then().catch()",
      "promise.then().catch().then()",
      "promise.catch().then().then()",
      "promise.then().then().then()"
    ]
  },
  {
    "q": "What does the following async/await function log?",
    "l": "javascript",
    "c": "async function fetchUser() {\n  const response = await fetch('https://api.example.com/user');\n  const data = await response.json();\n  console.log(data.name);\n}\nfetchUser();",
    "o": [
      "The user's name from the API response",
      "A Promise object",
      "undefined",
      "An error due to missing await"
    ]
  },
  {
    "q": "What is the purpose of the 'race' method in Promises?",
    "o": [
      "To resolve or reject as soon as one Promise settles",
      "To run Promises in parallel and wait for all",
      "To prioritize faster-executing Promises",
      "To cancel slower Promises"
    ]
  },
  {
    "q": "What is logged in the following microtask vs macrotask example?",
    "l": "javascript",
    "c": "console.log('Script start');\nsetTimeout(() => console.log('setTimeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('Script end');",
    "o": [
      "Script start\nScript end\nPromise\nsetTimeout",
      "Script start\nsetTimeout\nScript end\nPromise",
      "Script start\nScript end\nsetTimeout\nPromise",
      "Promise\nScript start\nScript end\nsetTimeout"
    ]
  },
  {
    "q": "Which of these is a valid way to handle errors in async/await?",
    "o": [
      "try/catch block inside async function",
      "Using .error() method",
      "Adding an error callback",
      "Await on catch"
    ]
  },
  {
    "q": "What is the output of the following nested Promise example?",
    "l": "javascript",
    "c": "Promise.resolve(1)\n  .then((x) => Promise.resolve(x + 1))\n  .then((x) => console.log(x));",
    "o": [
      "2",
      "1",
      "Promise {<resolved>: 2}",
      "undefined"
    ]
  },
  {
    "q": "What happens if an error is thrown inside a .then() handler?",
    "o": [
      "It is caught by the nearest .catch()",
      "The Promise resolves to undefined",
      "The script crashes immediately",
      "The error is ignored"
    ]
  },
  {
    "q": "What does the following code using Promise.all() output?",
    "l": "javascript",
    "c": "const p1 = Promise.resolve(3);\nconst p2 = 42;\nconst p3 = new Promise((resolve) => setTimeout(resolve, 100, 'foo'));\nPromise.all([p1, p2, p3]).then(console.log);",
    "o": [
      "[3, 42, 'foo'] (after 100ms)",
      "[3, 42, undefined]",
      "42",
      "Error: p3 is not a Promise"
    ]
  },
  {
    "q": "Which statement about callbacks is true?",
    "o": [
      "They can lead to 'callback hell' if nested deeply",
      "They always execute synchronously",
      "They replace Promises in modern JS",
      "They cannot be used with setTimeout"
    ]
  },
  {
    "q": "What is the output of this mixed async/await and Promise code?",
    "l": "javascript",
    "c": "async function foo() {\n  await Promise.reject('Error!');\n}\nfoo().catch(console.log);",
    "o": [
      "Error!",
      "Unhandled promise rejection",
      "undefined",
      "Nothing (silent failure)"
    ]
  },
  {
    "q": "What is the key difference between Promises and callbacks?",
    "o": [
      "Promises avoid deep nesting and provide better error handling",
      "Callbacks are always faster",
      "Promises can only be used with async/await",
      "Callbacks work only in Node.js"
    ]
  },
  {
    "q": "What is the output of the following callback-based asynchronous code?",
    "l": "javascript",
    "c": "function delayedLog(message, callback) {\n  setTimeout(() => {\n    console.log(message);\n    callback();\n  }, 1000);\n}\ndelayedLog('First', () => console.log('Second'));",
    "o": [
      "First (after 1s) followed by Second",
      "Second followed by First (after 1s)",
      "First and Second simultaneously after 1s",
      "Second immediately, then First after 1s"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using callbacks for asynchronous operations?",
    "o": [
      "Callback hell (deep nesting)",
      "Inability to handle errors",
      "Slower execution compared to Promises",
      "Browser incompatibility"
    ]
  },
  {
    "q": "What does the following Promise code log?",
    "l": "javascript",
    "c": "const promise = new Promise((resolve) => {\n  resolve('Resolved');\n});\npromise\n  .then((val) => val + '!')\n  .then((val) => console.log(val));",
    "o": [
      "Resolved!",
      "Resolved",
      "Promise {<resolved>: 'Resolved!'}",
      "undefined"
    ]
  },
  {
    "q": "What is the purpose of the `async` keyword in a function declaration?",
    "o": [
      "To indicate the function will always return a Promise",
      "To make the function execute synchronously",
      "To allow the use of `yield` for generators",
      "To automatically handle errors"
    ]
  },
  {
    "q": "What is the output of the following async/await code?",
    "l": "javascript",
    "c": "async function getValue() {\n  return await Promise.resolve(42);\n}\ngetValue().then((v) => console.log(v));",
    "o": [
      "42",
      "Promise {<resolved>: 42}",
      "undefined",
      "Error: await must be inside async"
    ]
  },
  {
    "q": "Which method is used to handle the first settled Promise (either resolved or rejected)?",
    "o": [
      "Promise.race()",
      "Promise.any()",
      "Promise.all()",
      "Promise.settle()"
    ]
  },
  {
    "q": "What does the following code log when the API call fails?",
    "l": "javascript",
    "c": "async function fetchData() {\n  try {\n    const res = await fetch('https://invalid.url');\n    console.log(await res.json());\n  } catch {\n    console.log('Error');\n  }\n}\nfetchData();",
    "o": [
      "Error",
      "undefined",
      "A network error object",
      "Nothing (silent failure)"
    ]
  },
  {
    "q": "What is the key advantage of Promises over callbacks?",
    "o": [
      "Fluent chaining and better error handling",
      "Faster execution speed",
      "No need for error handling",
      "Works only in modern browsers"
    ]
  },
  {
    "q": "What is the output of the following microtask/macrotask example?",
    "l": "javascript",
    "c": "console.log('Start');\nPromise.resolve().then(() => console.log('Microtask'));\nsetTimeout(() => console.log('Macrotask'), 0);\nconsole.log('End');",
    "o": [
      "Start, End, Microtask, Macrotask",
      "Start, Microtask, End, Macrotask",
      "Start, End, Macrotask, Microtask",
      "Microtask, Start, End, Macrotask"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to create a Promise?",
    "o": [
      "new Promise('resolve')",
      "new Promise((resolve) => resolve())",
      "Promise.resolve()",
      "Promise.reject()"
    ]
  },
  {
    "q": "What does the following code log if the Promise rejects?",
    "l": "javascript",
    "c": "Promise.reject('Failed')\n  .catch((err) => console.log(err))\n  .then(() => console.log('Done'));",
    "o": [
      "Failed followed by Done",
      "Failed",
      "Done",
      "Unhandled rejection error"
    ]
  },
  {
    "q": "What is the correct way to handle multiple async/await calls sequentially?",
    "o": [
      "Use `await` for each operation in order",
      "Wrap them in `Promise.all()`",
      "Use callbacks inside async functions",
      "Assign results to global variables"
    ]
  },
  {
    "q": "What is the output of this Promise chain with a thrown error?",
    "l": "javascript",
    "c": "Promise.resolve()\n  .then(() => { throw new Error('Oops!'); })\n  .catch((err) => console.log(err.message))\n  .then(() => console.log('Recovered'));",
    "o": [
      "Oops! followed by Recovered",
      "Oops!",
      "Recovered",
      "Uncaught Error: Oops!"
    ]
  },
  {
    "q": "Which statement about `Promise.allSettled()` is true?",
    "o": [
      "It waits for all Promises to settle (resolve or reject)",
      "It rejects if any Promise rejects",
      "It only resolves if all Promises resolve",
      "It executes Promises sequentially"
    ]
  },
  {
    "q": "What is the output of the following code using Promise chaining?",
    "l": "javascript",
    "c": "Promise.resolve(2)\n  .then(x => x * 3)\n  .then(x => { return Promise.reject(x) })\n  .catch(x => console.log(x))\n  .then(() => console.log('Done'));",
    "o": [
      "6 followed by Done",
      "2 followed by Done",
      "Uncaught rejection: 6",
      "Done"
    ]
  },
  {
    "q": "Which of these correctly demonstrates parallel execution of async operations?",
    "o": [
      "Promise.all([asyncTask1(), asyncTask2()])",
      "await asyncTask1(); await asyncTask2();",
      "asyncTask1().then(() => asyncTask2())",
      "asyncTask1(); asyncTask2();"
    ]
  },
  {
    "q": "What does this async IIFE (Immediately Invoked Function Expression) output?",
    "l": "javascript",
    "c": "(async () => {\n  await Promise.resolve();\n  console.log('A');\n})();\nconsole.log('B');",
    "o": [
      "B followed by A",
      "A followed by B",
      "A",
      "B"
    ]
  },
  {
    "q": "What is the problem with this callback-based code?",
    "l": "javascript",
    "c": "getData(function(data) {\n  process(data, function(result) {\n    save(result, function() {\n      log('Done');\n    });\n  });\n});",
    "o": [
      "Callback hell (deep nesting)",
      "Missing error handling",
      "Synchronous execution",
      "Memory leaks"
    ]
  },
  {
    "q": "What is the output of this Promise.race() example?",
    "l": "javascript",
    "c": "const p1 = new Promise(res => setTimeout(res, 500, 'Fast'));\nconst p2 = new Promise(res => setTimeout(res, 1000, 'Slow'));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Fast (after 500ms)",
      "Slow (after 1000ms)",
      "['Fast', 'Slow']",
      "The first rejected Promise"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async/await over plain Promises?",
    "o": [
      "Faster execution speed",
      "More readable sequential code",
      "Better error handling with try/catch",
      "Avoiding .then() chains"
    ]
  },
  {
    "q": "What does this code log when the fetch fails?",
    "l": "javascript",
    "c": "async function getUser() {\n  try {\n    let res = await fetch('invalid-url');\n    return await res.json();\n  } catch {\n    return 'Fallback Data';\n  }\n}\ngetUser().then(console.log);",
    "o": [
      "Fallback Data",
      "undefined",
      "A network error object",
      "Nothing (hangs)"
    ]
  },
  {
    "q": "What is the purpose of the finally() block in this Promise chain?",
    "l": "javascript",
    "c": "fetchData()\n  .then(process)\n  .catch(handleError)\n  .finally(cleanup);",
    "o": [
      "Execute cleanup regardless of success/failure",
      "Handle uncaught exceptions",
      "Terminate the Promise chain",
      "Process the final result"
    ]
  },
  {
    "q": "What is the output of this advanced async/await example?",
    "l": "javascript",
    "c": "async function foo() {\n  console.log(await Promise.resolve('A'));\n  console.log('B');\n}\nasync function bar() {\n  await foo();\n  console.log('C');\n}\nbar();\nconsole.log('D');",
    "o": [
      "D, A, B, C",
      "A, B, C, D",
      "A, D, B, C",
      "D, C, B, A"
    ]
  },
  {
    "q": "Which statement about Promise.all() is FALSE?",
    "o": [
      "It resolves when the first Promise resolves",
      "It rejects immediately if any Promise rejects",
      "It preserves the order of results",
      "It accepts an iterable of Promises"
    ]
  },
  {
    "q": "What does this code using Promise.any() output?",
    "l": "javascript",
    "c": "const p1 = Promise.reject('Error');\nconst p2 = Promise.resolve('Success');\nPromise.any([p1, p2]).then(console.log);",
    "o": [
      "Success",
      "Error",
      "['Success', 'Error']",
      "AggregateError if all reject"
    ]
  },
  {
    "q": "How can you convert a callback-based function to return a Promise?",
    "o": [
      "Use util.promisify() or wrap in new Promise()",
      "Add the async keyword to the callback",
      "Return the callback directly",
      "Use Promise.callback()"
    ]
  },
  {
    "q": "What is the output of this nested async function?",
    "l": "javascript",
    "c": "async function outer() {\n  console.log('A');\n  await inner();\n  console.log('B');\n}\nasync function inner() {\n  console.log('C');\n}\nouter();\nconsole.log('D');",
    "o": [
      "A, C, D, B",
      "A, D, C, B",
      "D, A, C, B",
      "A, C, B, D"
    ]
  },
  {
    "q": "Which of these will NOT catch errors in an async function?",
    "o": [
      "Adding .catch() to the function call",
      "Using try/catch inside the function",
      "Adding a .catch() after await",
      "Using Promise.catch()"
    ]
  },
  {
    "q": "What is the output of the following Promise chain with multiple catches?",
    "l": "javascript",
    "c": "Promise.reject('Error1')\n  .catch(err => { console.log(err); return 'Recovery1'; })\n  .then(val => { console.log(val); throw 'Error2'; })\n  .catch(err => console.log(err));",
    "o": [
      "Error1 followed by Recovery1 followed by Error2",
      "Error1 followed by Error2",
      "Recovery1 followed by Error2",
      "Error1 only"
    ]
  },
  {
    "q": "Which of these is a correct implementation of promisifying a callback-style function?",
    "o": [
      "function readFilePromise(path) { return new Promise((resolve, reject) => { fs.readFile(path, (err, data) => { if (err) reject(err); else resolve(data); }); }); }",
      "async function readFilePromise(path) { return fs.readFile(path); }",
      "function readFilePromise(path) { return Promise.callback(fs.readFile(path)); }",
      "function readFilePromise(path) { return new Promise(fs.readFile(path)); }"
    ]
  },
  {
    "q": "What does this async generator function output?",
    "l": "javascript",
    "c": "async function* asyncGen() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n(async () => {\n  for await (const num of asyncGen()) {\n    console.log(num);\n  }\n})();",
    "o": [
      "1 followed by 2",
      "Promise { 1 } followed by Promise { 2 }",
      "[1, 2]",
      "Nothing (it hangs)"
    ]
  },
  {
    "q": "What is the key difference between Promise.all() and Promise.allSettled()?",
    "o": [
      "allSettled() never rejects, while all() rejects if any promise rejects",
      "all() is faster than allSettled()",
      "allSettled() only works with async/await",
      "all() preserves order while allSettled() doesn't"
    ]
  },
  {
    "q": "What is the output of this complex microtask/macrotask example?",
    "l": "javascript",
    "c": "console.log('Script start');\nsetTimeout(() => console.log('Timeout1'), 0);\nPromise.resolve().then(() => {\n  console.log('Promise1');\n  setTimeout(() => console.log('Timeout2'), 0);\n});\nPromise.resolve().then(() => console.log('Promise2'));\nconsole.log('Script end');",
    "o": [
      "Script start, Script end, Promise1, Promise2, Timeout1, Timeout2",
      "Script start, Script end, Promise1, Promise2, Timeout2, Timeout1",
      "Script start, Promise1, Script end, Promise2, Timeout1, Timeout2",
      "Script start, Script end, Timeout1, Promise1, Promise2, Timeout2"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to handle multiple async operations?",
    "o": [
      "Using forEach with async/await",
      "Using Promise.all() with an array of promises",
      "Using a for-of loop with await",
      "Using reduce with promises"
    ]
  },
  {
    "q": "What is the output of this async recursion example?",
    "l": "javascript",
    "c": "async function countdown(n) {\n  if (n <= 0) return;\n  console.log(n);\n  await countdown(n-1);\n}\ncountdown(3);",
    "o": [
      "3, 2, 1 (in order)",
      "1, 2, 3 (in reverse order)",
      "3, 2, 1 (with delays between)",
      "Nothing (it deadlocks)"
    ]
  },
  {
    "q": "What happens if you don't handle a Promise rejection?",
    "o": [
      "It triggers an unhandledRejection event",
      "The script terminates immediately",
      "The Promise automatically retries",
      "It becomes a resolved Promise with undefined value"
    ]
  },
  {
    "q": "What is the output of this advanced Promise composition?",
    "l": "javascript",
    "c": "const p1 = Promise.resolve(1);\nconst p2 = Promise.resolve(2);\nconst p3 = Promise.reject(3);\n\np1\n  .then(val => { console.log(val); return p2; })\n  .then(val => { console.log(val); return p3; })\n  .then(val => console.log(val))\n  .catch(err => console.log('Error:', err));",
    "o": [
      "1 followed by 2 followed by 'Error: 3'",
      "1 followed by 2 followed by 3",
      "1 followed by 'Error: 3'",
      "1, 2, 3 in parallel"
    ]
  },
  {
    "q": "Which of these is a valid use of AbortController with fetch?",
    "o": [
      "const controller = new AbortController(); fetch(url, { signal: controller.signal }); controller.abort();",
      "fetch(url).abort()",
      "new AbortController(fetch(url))",
      "fetch(url, { abortable: true }).stop()"
    ]
  },
  {
    "q": "What does this code using async/await and setTimeout output?",
    "l": "javascript",
    "c": "async function delayedLog() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  console.log('Done');\n  return 'Finished';\n}\ndelayedLog().then(console.log);",
    "o": [
      "'Done' after 1s followed by 'Finished'",
      "'Finished' immediately followed by 'Done' after 1s",
      "'Done' immediately followed by 'Finished' after 1s",
      "Nothing (it hangs)"
    ]
  },
  {
    "q": "What is the purpose of the Promise.resolve() method?",
    "o": [
      "To create an already resolved Promise with a value",
      "To force a Promise to resolve immediately",
      "To handle Promise rejections",
      "To pause execution until all Promises resolve"
    ]
  },
  {
    "q": "What is the output of this event loop challenge?",
    "l": "javascript",
    "c": "setTimeout(() => console.log('Timeout'), 0);\nqueueMicrotask(() => console.log('Microtask'));\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('Script');",
    "o": [
      "Script, Microtask, Promise, Timeout",
      "Script, Promise, Microtask, Timeout",
      "Microtask, Promise, Script, Timeout",
      "Script, Timeout, Microtask, Promise"
    ]
  },
  {
    "q": "Which technique helps avoid 'callback hell'?",
    "o": [
      "Using Promises or async/await",
      "Using only synchronous code",
      "Nesting callbacks deeper",
      "Using global variables for results"
    ]
  },
  {
    "q": "What is the output of the following code using async/await with a rejected Promise?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    await Promise.reject('Error occurred');\n  } catch (err) {\n    console.log(err);\n  }\n}\ntest();",
    "o": [
      "Error occurred",
      "Unhandled promise rejection",
      "undefined",
      "Nothing (silent failure)"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to create a Promise in JavaScript?",
    "o": [
      "new Promise('resolve')",
      "new Promise((resolve) => resolve())",
      "Promise.resolve()",
      "Promise.reject()"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple then handlers?",
    "l": "javascript",
    "c": "Promise.resolve(1)\n  .then(x => x + 1)\n  .then(x => { throw new Error('Failed') })\n  .catch(err => 3)\n  .then(x => console.log(x));",
    "o": [
      "3",
      "1",
      "2",
      "Error: Failed"
    ]
  },
  {
    "q": "What is the purpose of the finally() method in a Promise chain?",
    "o": [
      "To execute code regardless of the Promise's outcome",
      "To handle only successful Promise resolutions",
      "To catch any errors in the Promise chain",
      "To terminate the Promise chain"
    ]
  },
  {
    "q": "What does this code output when using Promise.all with a rejected Promise?",
    "l": "javascript",
    "c": "Promise.all([\n  Promise.resolve(1),\n  Promise.reject('Error'),\n  Promise.resolve(3)\n]).catch(err => console.log(err));",
    "o": [
      "Error",
      "[1, 'Error', 3]",
      "1",
      "3"
    ]
  },
  {
    "q": "Which statement about async functions is FALSE?",
    "o": [
      "Async functions always complete synchronously",
      "Async functions always return a Promise",
      "Await can only be used inside async functions",
      "Async functions can contain try/catch blocks"
    ]
  },
  {
    "q": "What is the output of this event loop challenge with microtasks and macrotasks?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nqueueMicrotask(() => console.log('Microtask'));\nconsole.log('End');",
    "o": [
      "Start, End, Promise, Microtask, Timeout",
      "Start, End, Timeout, Promise, Microtask",
      "Start, Promise, End, Microtask, Timeout",
      "Start, End, Microtask, Promise, Timeout"
    ]
  },
  {
    "q": "What is the correct way to handle errors in this async function?",
    "l": "javascript",
    "c": "async function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n}",
    "o": [
      "Wrap the await calls in a try/catch block",
      "Add .catch() to the function call",
      "Use Promise.all() for error handling",
      "JavaScript automatically handles errors in async functions"
    ]
  },
  {
    "q": "What is the output of this Promise.race example?",
    "l": "javascript",
    "c": "const fast = new Promise(resolve => setTimeout(resolve, 100, 'Fast'));\nconst slow = new Promise(resolve => setTimeout(resolve, 500, 'Slow'));\nconst error = new Promise((_, reject) => setTimeout(reject, 200, 'Error'));\nPromise.race([fast, slow, error])\n  .then(console.log)\n  .catch(console.error);",
    "o": [
      "Fast",
      "Slow",
      "Error",
      "Fast followed by Error"
    ]
  },
  {
    "q": "Which of these is a valid use of AbortController with fetch?",
    "o": [
      "const controller = new AbortController(); fetch(url, { signal: controller.signal }); controller.abort();",
      "fetch(url).abort()",
      "new AbortController(fetch(url))",
      "fetch(url, { abortable: true }).stop()"
    ]
  },
  {
    "q": "What does this code output when mixing async/await with regular Promises?",
    "l": "javascript",
    "c": "async function foo() {\n  console.log(await Promise.resolve('A'));\n  console.log('B');\n}\nfoo();\nPromise.resolve('C').then(console.log);\nconsole.log('D');",
    "o": [
      "D, C, A, B",
      "A, B, C, D",
      "D, A, B, C",
      "A, D, B, C"
    ]
  },
  {
    "q": "What is the key difference between Promise.all and Promise.allSettled?",
    "o": [
      "allSettled never rejects, while all rejects if any input Promise rejects",
      "all is faster than allSettled",
      "allSettled doesn't preserve the order of results",
      "all can only handle two Promises at once"
    ]
  },
  {
    "q": "What is the output of this nested setTimeout example?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => {\n  console.log('First');\n  setTimeout(() => console.log('Second'), 0);\n}, 0);\nsetTimeout(() => console.log('Third'), 0);\nconsole.log('End');",
    "o": [
      "Start, End, First, Third, Second",
      "Start, End, First, Second, Third",
      "Start, First, End, Second, Third",
      "Start, End, Third, First, Second"
    ]
  },
  {
    "q": "Which of these correctly demonstrates parallel execution of async operations?",
    "o": [
      "Promise.all([task1(), task2()])",
      "await task1(); await task2();",
      "task1().then(() => task2())",
      "task1(); task2();"
    ]
  },
  {
    "q": "What is the output of this Promise chain with a finally block?",
    "l": "javascript",
    "c": "Promise.resolve('A')\n  .then(val => { console.log(val); return 'B'; })\n  .finally(() => console.log('Cleanup'))\n  .then(val => console.log(val));",
    "o": [
      "A, Cleanup, B",
      "A, B, Cleanup",
      "Cleanup, A, B",
      "B, A, Cleanup"
    ]
  },
  {
    "q": "Which of these will NOT execute parallel async operations?",
    "o": [
      "for (const task of tasks) { await task(); }",
      "Promise.all(tasks.map(task => task()))",
      "tasks.forEach(task => task())",
      "await Promise.all(tasks)"
    ]
  },
  {
    "q": "What does this async/await error handling pattern output?",
    "l": "javascript",
    "c": "async function getUser() {\n  try {\n    const res = await fetch('invalid-url');\n    return await res.json();\n  } catch (err) {\n    console.log('Network Error');\n    throw err;\n  }\n}\ngetUser().catch(() => console.log('Fallback'));",
    "o": [
      "Network Error followed by Fallback",
      "Network Error only",
      "Fallback only",
      "Uncaught TypeError"
    ]
  },
  {
    "q": "What is the key difference between Promise.any() and Promise.race()?",
    "o": [
      "any() fulfills when any Promise fulfills, race() settles when any Promise settles",
      "any() is faster than race()",
      "race() ignores rejections while any() handles them",
      "any() works only with async functions"
    ]
  },
  {
    "q": "What is the output of this microtask queue challenge?",
    "l": "javascript",
    "c": "console.log('Script start');\nqueueMicrotask(() => console.log('Microtask 1'));\nPromise.resolve().then(() => console.log('Promise 1'));\nqueueMicrotask(() => console.log('Microtask 2'));\nconsole.log('Script end');",
    "o": [
      "Script start, Script end, Microtask 1, Promise 1, Microtask 2",
      "Script start, Script end, Promise 1, Microtask 1, Microtask 2",
      "Script start, Microtask 1, Script end, Promise 1, Microtask 2",
      "Script start, Script end, Microtask 1, Microtask 2, Promise 1"
    ]
  },
  {
    "q": "Which of these is a valid way to cancel a fetch request?",
    "o": [
      "Using AbortController with signal",
      "Calling request.abort()",
      "Using Promise.cancel()",
      "Throwing an Error in then()"
    ]
  },
  {
    "q": "What does this recursive async function output?",
    "l": "javascript",
    "c": "async function count(n) {\n  if (n <= 0) return;\n  console.log(n);\n  await Promise.resolve();\n  await count(n-1);\n}\ncount(3);",
    "o": [
      "3, 2, 1 (in order)",
      "1, 2, 3 (reverse order)",
      "3 (only once)",
      "Nothing (stack overflow)"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled example?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('Error'),\n  Promise.resolve(3)\n]).then(console.log);",
    "o": [
      "Array of objects with status and value/reason",
      "[1, 'Error', 3]",
      "'Error'",
      "Unhandled rejection"
    ]
  },
  {
    "q": "Which statement about queueMicrotask() is FALSE?",
    "o": [
      "It executes before Promise callbacks",
      "It adds a microtask to the queue",
      "It has higher priority than setTimeout",
      "It can be used to break up long tasks"
    ]
  },
  {
    "q": "What is the output of this async generator example?",
    "l": "javascript",
    "c": "async function* asyncCounter() {\n  let i = 0;\n  while (i < 2) {\n    await Promise.resolve();\n    yield i++;\n  }\n}\n(async () => {\n  for await (const num of asyncCounter()) {\n    console.log(num);\n  }\n})();",
    "o": [
      "0, 1",
      "Promise { 0 }, Promise { 1 }",
      "Nothing (hangs)",
      "undefined, undefined"
    ]
  },
  {
    "q": "What does this code show about error handling in Promise chains?",
    "l": "javascript",
    "c": "Promise.reject('Error')\n  .catch(err => { console.log('Caught:', err); throw 'New Error'; })\n  .catch(err => console.log('Final:', err));",
    "o": [
      "Caught: Error followed by Final: New Error",
      "Final: New Error only",
      "Uncaught Error",
      "Caught: Error only"
    ]
  },
  {
    "q": "Which of these is NOT a way to avoid callback hell?",
    "o": [
      "Using deeper nesting of callbacks",
      "Promisifying callback functions",
      "Using async/await syntax",
      "Breaking functions into smaller pieces"
    ]
  },
  {
    "q": "What is the output of this complex event loop example?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n  queueMicrotask(() => console.log('Microtask'));\n});\nPromise.resolve().then(() => console.log('Promise 2'));\nconsole.log('End');",
    "o": [
      "Start, End, Promise 1, Promise 2, Microtask, Timeout",
      "Start, End, Promise 1, Microtask, Promise 2, Timeout",
      "Start, End, Timeout, Promise 1, Promise 2, Microtask",
      "Start, Promise 1, End, Microtask, Promise 2, Timeout"
    ]
  },
  {
    "q": "What is the purpose of the AbortSignal.timeout() method?",
    "o": [
      "To automatically abort after a specified time",
      "To delay fetch requests",
      "To handle Promise timeouts",
      "To pause execution temporarily"
    ]
  },
  {
    "q": "What is the output of this async/await timing example?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('A');\n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log('B');\n}\nconsole.log('C');\ntest();\nconsole.log('D');",
    "o": [
      "C, A, D, B (with B after 100ms)",
      "A, C, D, B",
      "C, D, A, B",
      "A, B, C, D"
    ]
  },
  {
    "q": "Which of these correctly handles multiple API requests with error tolerance?",
    "o": [
      "Promise.allSettled(requests).then(processResults)",
      "Promise.any(requests).then(useFirstResponse)",
      "try { await Promise.all(requests) } catch { /* ignore errors */ }",
      "requests.map(req => req.catch(() => null))"
    ]
  },
  {
    "q": "What does this Promise composition pattern output?",
    "l": "javascript",
    "c": "const p1 = Promise.resolve(1);\nconst p2 = p1.then(x => x + 1);\nconst p3 = p2.then(x => { throw x });\nconst p4 = p3.catch(x => x * 2);\np4.then(console.log);",
    "o": [
      "4",
      "1",
      "2",
      "Uncaught 2"
    ]
  },
  {
    "q": "What is the key advantage of using async/await over Promise.then()?",
    "o": [
      "More readable sequential code style",
      "Better performance in all cases",
      "Automatic parallel execution",
      "No need for error handling"
    ]
  },
  {
    "q": "What is the output of this event loop challenge with nested promises?",
    "l": "javascript",
    "c": "console.log('Start');\nPromise.resolve().then(() => {\n  console.log('Promise1');\n  Promise.resolve().then(() => console.log('Nested Promise'));\n});\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise2'));\nconsole.log('End');",
    "o": [
      "Start, End, Promise1, Promise2, Nested Promise, Timeout",
      "Start, End, Promise1, Nested Promise, Promise2, Timeout",
      "Start, Promise1, End, Nested Promise, Promise2, Timeout",
      "Start, End, Timeout, Promise1, Promise2, Nested Promise"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to handle Promise timeouts?",
    "o": [
      "await new Promise(resolve => setTimeout(resolve, delay))",
      "Promise.race([task, timeoutPromise])",
      "AbortSignal.timeout(delay)",
      "task.then(() => clearTimeout(timer))"
    ]
  },
  {
    "q": "What does this recursive async function demonstrate?",
    "l": "javascript",
    "c": "async function process(items) {\n  if (!items.length) return;\n  await processItem(items[0]);\n  await process(items.slice(1));\n}",
    "o": [
      "Sequential processing of items",
      "Parallel processing of items",
      "Potential stack overflow",
      "No-op due to missing return"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled example with mixed results?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve('Success'),\n  Promise.reject('Error'),\n  new Promise(() => {}) // Pending\n]).then(console.log);",
    "o": [
      "Array with one fulfilled, one rejected, and one pending Promise",
      "Array with status objects for Success and Error only",
      "Never resolves due to pending Promise",
      "Error immediately"
    ]
  },
  {
    "q": "Which statement about Promise cancellation is TRUE?",
    "o": [
      "AbortController can cancel fetch requests",
      "Promises have a built-in cancel() method",
      "Async functions can be cancelled mid-execution",
      "Promise.race() automatically cancels slower Promises"
    ]
  },
  {
    "q": "What does this code show about microtask queue priority?",
    "l": "javascript",
    "c": "queueMicrotask(() => console.log('Microtask'));\nPromise.resolve().then(() => console.log('Promise'));\nsetTimeout(() => console.log('Timeout'), 0);",
    "o": [
      "Microtask and Promise execute before Timeout",
      "Order is unpredictable",
      "Timeout executes first",
      "Microtask always runs last"
    ]
  },
  {
    "q": "What is the output of this async iterator example?",
    "l": "javascript",
    "c": "const asyncIterable = {\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      async next() {\n        if (i++ < 2) {\n          await Promise.resolve();\n          return { value: i, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\n(async () => {\n  for await (const num of asyncIterable) {\n    console.log(num);\n  }\n})();",
    "o": [
      "1, 2",
      "0, 1",
      "Promise { 1 }, Promise { 2 }",
      "Nothing (infinite loop)"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise.any()?",
    "o": [
      "Getting the first successful response from multiple APIs",
      "Waiting for all Promises to complete successfully",
      "Handling the fastest Promise regardless of rejection",
      "Executing Promises in sequential order"
    ]
  },
  {
    "q": "What is the output of this complex error handling example?",
    "l": "javascript",
    "c": "async function test() {\n  try {\n    await Promise.reject('Error1');\n  } catch (err) {\n    console.log(err);\n    try {\n      await Promise.reject('Error2');\n    } catch {\n      return 'Recovered';\n    }\n  }\n}\ntest().then(console.log).catch(console.error);",
    "o": [
      "Error1 followed by Recovered",
      "Error1 followed by Error2",
      "Recovered only",
      "Uncaught Error2"
    ]
  },
  {
    "q": "What is the purpose of the void operator with Promises?",
    "o": [
      "To intentionally ignore Promise results",
      "To cancel Promise execution",
      "To make Promises resolve faster",
      "To handle Promise rejections"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error handlers?",
    "l": "javascript",
    "c": "Promise.reject('Initial Error')\n  .catch(err => { console.log(`Caught: ${err}`); throw 'New Error'; })\n  .then(() => console.log('Success'))\n  .catch(err => console.log(`Final: ${err}`));",
    "o": [
      "Caught: Initial Error followed by Final: New Error",
      "Caught: Initial Error followed by Success",
      "Final: Initial Error",
      "Uncaught New Error"
    ]
  },
  {
    "q": "Which of these is the most efficient way to process an array of items asynchronously without overwhelming memory?",
    "o": [
      "Using a concurrency-limited pool like p-limit",
      "Promise.all() on the entire array",
      "Sequential processing with for-loop and await",
      "Using Array.map() with async functions"
    ]
  },
  {
    "q": "What does this code reveal about microtask starvation?",
    "l": "javascript",
    "c": "function starve() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    starve();\n  });\n}\nstarve();\nsetTimeout(() => console.log('Timeout'), 100);",
    "o": [
      "Timeout never executes due to infinite microtask queue",
      "Alternates between Microtask and Timeout",
      "Runs Timeout once then enters infinite loop",
      "Throws stack overflow error"
    ]
  },
  {
    "q": "What is the key difference between these two async function declarations?",
    "l": "javascript",
    "c": "async function foo() { return 1; }\nconst bar = async () => { return 1; };",
    "o": [
      "Hoisting behavior (foo is hoisted, bar isn't)",
      "Execution speed",
      "Memory usage",
      "Error handling capability"
    ]
  },
  {
    "q": "What is the output of this Promise.race() edge case?",
    "l": "javascript",
    "c": "const p1 = new Promise(() => {}); // Never settles\nconst p2 = new Promise(resolve => setTimeout(resolve, 100, 'Winner'));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Winner (after 100ms)",
      "Never resolves",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid approach to prevent memory leaks with abandoned Promises?",
    "o": [
      "Always using Promise.race() with a timeout",
      "Cleaning up event listeners in finally()",
      "Using AbortController for cancellation",
      "Storing Promise references indefinitely"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces?",
    "l": "javascript",
    "c": "async function fail() {\n  await Promise.resolve();\n  throw new Error('Async Error');\n}\nfail().catch(err => console.log(err.stack));",
    "o": [
      "Includes async call chain in stack trace",
      "Shows empty stack trace",
      "Only shows error message",
      "Crashes the process"
    ]
  },
  {
    "q": "What is the output of this generator-Promise hybrid?",
    "l": "javascript",
    "c": "async function* asyncGen() {\n  yield await Promise.resolve(1);\n  yield await Promise.reject(2);\n}\n\n(async () => {\n  try {\n    for await (const num of asyncGen()) {\n      console.log(num);\n    }\n  } catch (e) {\n    console.log(`Caught: ${e}`);\n  }\n})();",
    "o": [
      "1 followed by Caught: 2",
      "1, 2",
      "Caught: 2",
      "1 then unhandled rejection"
    ]
  },
  {
    "q": "Which statement about V8's microtask queue is TRUE?",
    "o": [
      "Processes all queued microtasks before moving to macrotasks",
      "Alternates between microtasks and macrotasks",
      "Prioritizes setImmediate over Promises",
      "Limits microtask queue depth to prevent starvation"
    ]
  },
  {
    "q": "What is the output of this performance-sensitive Promise pattern?",
    "l": "javascript",
    "c": "const p = Promise.resolve();\n(async () => {\n  for (let i = 0; i < 3; i++) {\n    await p;\n    console.log(i);\n  }\n})();",
    "o": [
      "0, 1, 2 (with minimal delay between)",
      "Random order due to race conditions",
      "All numbers simultaneously",
      "Nothing (hangs)"
    ]
  },
  {
    "q": "What does this reveal about Node.js's nextTick vs microtasks?",
    "l": "javascript",
    "c": "process.nextTick(() => console.log('nextTick'));\nPromise.resolve().then(() => console.log('Promise'));",
    "o": [
      "nextTick executes before Promise",
      "Promise executes before nextTick",
      "Order is non-deterministic",
      "Throws error about mixing APIs"
    ]
  },
  {
    "q": "Which of these is a valid use case for Promise.reject()?",
    "o": [
      "Immediately returning a failed async operation",
      "Stopping Promise execution mid-chain",
      "Cancelling other Promises",
      "Skipping subsequent .then() handlers"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection scenario?",
    "l": "javascript",
    "c": "const p = new Promise((_, reject) => {\n  setTimeout(() => reject('Late Error'), 100);\n});\nsetTimeout(() => p.catch(() => {}), 200);",
    "o": [
      "Triggers unhandledRejection then rejectionHandled events",
      "Silently fails with no output",
      "Throws synchronous error",
      "Logs 'Late Error' after 200ms"
    ]
  },
  {
    "q": "What does this code show about async function return values?",
    "l": "javascript",
    "c": "async function test() {\n  return { then(resolve) { resolve('Custom Thenable'); } };\n}\ntest().then(console.log);",
    "o": [
      "Custom Thenable",
      "{ then: [Function] }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple finally blocks?",
    "l": "javascript",
    "c": "Promise.resolve('Start')\n  .finally(() => console.log('Cleanup1'))\n  .then(val => { console.log(val); throw 'Error'; })\n  .finally(() => console.log('Cleanup2'))\n  .catch(err => console.log(err));",
    "o": [
      "Cleanup1, Start, Cleanup2, Error",
      "Start, Cleanup1, Error, Cleanup2",
      "Cleanup1, Cleanup2, Start, Error",
      "Start, Error, Cleanup1, Cleanup2"
    ]
  },
  {
    "q": "Which of these patterns provides the best error handling for parallel async operations?",
    "o": [
      "Promise.allSettled() with individual error analysis",
      "Promise.all() with a single catch block",
      "Multiple await statements in try/catch",
      "Using Promise.any() to ignore failures"
    ]
  },
  {
    "q": "What does this code reveal about async function return values?",
    "l": "javascript",
    "c": "async function getValue() {\n  return Promise.resolve('Nested Promise');\n}\ngetValue().then(console.log);",
    "o": [
      "Nested Promise (automatically unwrapped)",
      "Promise { 'Nested Promise' }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What is the execution order of this microtask/macrotask hybrid?",
    "l": "javascript",
    "c": "console.log('Script start');\nqueueMicrotask(() => console.log('Microtask1'));\nsetTimeout(() => {\n  console.log('Timeout1');\n  queueMicrotask(() => console.log('Microtask2'));\n}, 0);\nPromise.resolve().then(() => console.log('Promise1'));\nconsole.log('Script end');",
    "o": [
      "Script start, Script end, Microtask1, Promise1, Timeout1, Microtask2",
      "Script start, Script end, Promise1, Microtask1, Timeout1, Microtask2",
      "Script start, Timeout1, Script end, Microtask1, Microtask2, Promise1",
      "Script start, Script end, Microtask1, Timeout1, Promise1, Microtask2"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to create a delayed Promise resolution?",
    "o": [
      "new Promise(resolve => resolve(setTimeout(resolve, delay)))",
      "new Promise(resolve => setTimeout(resolve, delay))",
      "Promise.resolve().then(() => new Promise(resolve => setTimeout(resolve, delay)))",
      "util.promisify(setTimeout)(delay)"
    ]
  },
  {
    "q": "What is the output of this async generator error handling example?",
    "l": "javascript",
    "c": "async function* errorGen() {\n  yield 1;\n  throw 'Generator Error';\n}\n\n(async () => {\n  try {\n    for await (const num of errorGen()) {\n      console.log(num);\n    }\n  } catch (e) {\n    console.log(`Caught: ${e}`);\n  }\n})();",
    "o": [
      "1 followed by Caught: Generator Error",
      "1 then unhandled rejection",
      "Caught: Generator Error",
      "1, undefined"
    ]
  },
  {
    "q": "What does this code demonstrate about AbortController propagation?",
    "l": "javascript",
    "c": "const controller = new AbortController();\nconst { signal } = controller;\n\nfetch(url1, { signal })\n  .then(() => fetch(url2, { signal }))\n  .catch(err => {\n    if (err.name === 'AbortError') {\n      console.log('Aborted!');\n    }\n  });\n\ncontroller.abort();",
    "o": [
      "Both fetch requests are aborted and caught",
      "Only the first fetch is aborted",
      "Throws Synchronous AbortError",
      "Requests continue despite abort"
    ]
  },
  {
    "q": "Which statement about async function performance is TRUE?",
    "o": [
      "Zero-cost for simple Promises in modern engines",
      "Always slower than Promise.then() chains",
      "Adds significant memory overhead per call",
      "Forces synchronous execution"
    ]
  },
  {
    "q": "What is the output of this Promise composition with thenables?",
    "l": "javascript",
    "c": "Promise.resolve({\n  then(resolve) { resolve('Custom Thenable'); }\n}).then(console.log);",
    "o": [
      "Custom Thenable",
      "{ then: [Function] }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What does this reveal about unhandled rejections in async functions?",
    "l": "javascript",
    "c": "async function fail() {\n  await Promise.reject('Silent Error');\n}\nfail();\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Triggers unhandledRejection but Timeout still runs",
      "Prevents Timeout from executing",
      "Throws synchronous error",
      "Logs 'Silent Error' after Timeout"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise.try() pattern?",
    "o": [
      "Wrapping synchronous code that might throw",
      "Replacing all try/catch blocks",
      "Making async functions run faster",
      "Converting callbacks to Promises"
    ]
  },
  {
    "q": "What is the output of this nested microtask example?",
    "l": "javascript",
    "c": "queueMicrotask(() => {\n  console.log('Microtask1');\n  queueMicrotask(() => console.log('Nested Microtask'));\n});\nqueueMicrotask(() => console.log('Microtask2'));",
    "o": [
      "Microtask1, Microtask2, Nested Microtask",
      "Microtask1, Nested Microtask, Microtask2",
      "Nested Microtask, Microtask1, Microtask2",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What does this code show about Promise resolution timing?",
    "l": "javascript",
    "c": "let resolved = false;\nconst p = new Promise(resolve => {\n  setTimeout(() => {\n    resolve('Done');\n    resolved = true;\n  }, 100);\n});\nsetTimeout(() => console.log(resolved ? 'Resolved' : 'Pending'), 200);",
    "o": [
      "Resolved",
      "Pending",
      "Throws ReferenceError",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async iterators over callbacks?",
    "o": [
      "Lower memory usage in all cases",
      "Cleaner syntax with for-await-of",
      "Better error handling with try/catch",
      "Natural backpressure handling"
    ]
  },
  {
    "q": "What is the output of this Promise chain with conditional branching?",
    "l": "javascript",
    "c": "Promise.resolve(2)\n  .then(val => val > 1 ? Promise.resolve('A') : Promise.reject('B'))\n  .then(console.log)\n  .catch(console.error);",
    "o": [
      "A",
      "B",
      "2",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which of these patterns provides optimal performance for sequential async operations?",
    "o": [
      "for (const task of tasks) { await task(); }",
      "tasks.reduce((p, task) => p.then(() => task()), Promise.resolve())",
      "Promise.all(tasks.map(task => task()))",
      "tasks.forEach(async task => await task())"
    ]
  },
  {
    "q": "What does this code reveal about Promise resolution values?",
    "l": "javascript",
    "c": "Promise.resolve(\n  new Promise(resolve => resolve('Nested'))\n).then(console.log);",
    "o": [
      "Nested (flattened automatically)",
      "Promise { 'Nested' }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What is the execution order of this complex microtask scenario?",
    "l": "javascript",
    "c": "console.log('Start');\nqueueMicrotask(() => {\n  console.log('Microtask1');\n  Promise.resolve().then(() => console.log('Microtask2'));\n});\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise1'));\nconsole.log('End');",
    "o": [
      "Start, End, Microtask1, Promise1, Microtask2, Timeout",
      "Start, End, Promise1, Microtask1, Microtask2, Timeout",
      "Start, Microtask1, End, Promise1, Microtask2, Timeout",
      "Start, End, Microtask1, Microtask2, Promise1, Timeout"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to implement a Promise timeout?",
    "o": [
      "new Promise(resolve => setTimeout(resolve, delay)).then(() => timeout())",
      "Promise.race([task, new Promise((_, reject) => setTimeout(() => reject('Timeout'), delay))])",
      "AbortSignal.timeout(delay)",
      "util.promisify(setTimeout)(delay).then(() => { throw 'Timeout' })"
    ]
  },
  {
    "q": "What is the output of this async iterator error handling example?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  yield Promise.reject('Error');\n}\n\n(async () => {\n  try {\n    for await (const val of gen()) {\n      console.log(val);\n    }\n  } catch (e) {\n    console.log(`Caught: ${e}`);\n  }\n})();",
    "o": [
      "1 followed by Caught: Error",
      "1 then unhandled rejection",
      "Caught: Error",
      "1, undefined"
    ]
  },
  {
    "q": "What does this code demonstrate about multiple AbortControllers?",
    "l": "javascript",
    "c": "const c1 = new AbortController();\nconst c2 = new AbortController();\n\nfetch(url, { signal: c1.signal })\n  .then(() => fetch(url, { signal: c2.signal }))\n  .catch(err => console.log(err.name));\n\nc1.abort();\nc2.abort();",
    "o": [
      "Only logs 'AbortError' once (first abort wins)",
      "Logs 'AbortError' twice",
      "Neither fetch is aborted",
      "Throws Synchronous AbortError"
    ]
  },
  {
    "q": "Which statement about async function optimization is FALSE?",
    "o": [
      "Async functions always create 2 additional Promises per call",
      "V8 optimizes simple async functions similarly to plain Promises",
      "await expressions don't always create new microtasks",
      "Zero-cost await works for already-resolved Promises"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled edge case?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve(1),\n  new Promise(() => {}), // Pending\n  Promise.reject(3)\n]).then(console.log);",
    "o": [
      "Array with one fulfilled, one pending, and one rejected Promise",
      "Never resolves due to pending Promise",
      "[1, undefined, 3]",
      "TypeError"
    ]
  },
  {
    "q": "What does this reveal about unhandled rejections in nested Promises?",
    "l": "javascript",
    "c": "Promise.resolve()\n  .then(() => Promise.reject('Nested Error'))\n  .catch(() => {}); // Empty handler\n\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Timeout executes (rejection was handled)",
      "Triggers unhandledRejection event",
      "Process crashes immediately",
      "Nothing logs (silent failure)"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators?",
    "o": [
      "Promise.any() for implementing fast-fail patterns",
      "Promise.all() for sequential operations",
      "Promise.race() for merging results",
      "Promise.allSettled() for immediate failure"
    ]
  },
  {
    "q": "What is the output of this microtask recursion example?",
    "l": "javascript",
    "c": "function loop() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    loop();\n  });\n}\nloop();\nsetTimeout(() => console.log('Timeout'), 100);",
    "o": [
      "Infinite Microtask logs (Timeout never runs)",
      "Microtask logs until Timeout executes",
      "Throws stack overflow error",
      "Alternates between Microtask and Timeout"
    ]
  },
  {
    "q": "What does this code show about Promise resolution timing?",
    "l": "javascript",
    "c": "const p1 = Promise.resolve(1);\nconst p2 = p1.then(val => {\n  console.log(val);\n  return val + 1;\n});\nsetTimeout(() => {\n  p2.then(console.log);\n}, 0);",
    "o": [
      "1 (immediately) followed by 2 (in timeout)",
      "1 and 2 simultaneously after timeout",
      "2 then 1",
      "Nothing (hangs)"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of async/await over callbacks?",
    "o": [
      "Lower memory usage in all cases",
      "Straight-line code readability",
      "Better error handling with try/catch",
      "No callback hell/pyramid"
    ]
  },
  {
    "q": "What is the output of this Promise chain with nested then handlers?",
    "l": "javascript",
    "c": "Promise.resolve(1)\n  .then(x => {\n    console.log(x);\n    return Promise.resolve(2)\n      .then(y => {\n        console.log(y);\n        return x + y;\n      });\n  })\n  .then(z => console.log(z));",
    "o": [
      "1, 2, 3",
      "1, 3, 2",
      "2, 1, 3",
      "3, 2, 1"
    ]
  },
  {
    "q": "Which of these patterns provides the best memory efficiency for processing large datasets asynchronously?",
    "o": [
      "Async generator with for-await-of",
      "Promise.all() with full dataset",
      "Array.map() with async functions",
      "Recursive Promise chaining"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue behavior?",
    "l": "javascript",
    "c": "let count = 0;\nfunction loop() {\n  Promise.resolve().then(() => {\n    count++;\n    if (count < 3) loop();\n  });\n}\nloop();\nsetTimeout(() => console.log(count), 100);",
    "o": [
      "3 (all microtasks complete before timeout)",
      "0 (timeout executes first)",
      "1 (only one iteration completes)",
      "Infinite loop"
    ]
  },
  {
    "q": "What is the execution order of this mixed microtask/macrotask example?",
    "l": "javascript",
    "c": "console.log('Start');\nsetTimeout(() => console.log('Timeout1'), 0);\nqueueMicrotask(() => {\n  console.log('Microtask1');\n  setTimeout(() => console.log('Timeout2'), 0);\n});\nPromise.resolve().then(() => console.log('Promise1'));\nsetTimeout(() => console.log('Timeout3'), 0);\nconsole.log('End');",
    "o": [
      "Start, End, Microtask1, Promise1, Timeout1, Timeout3, Timeout2",
      "Start, End, Promise1, Microtask1, Timeout1, Timeout2, Timeout3",
      "Start, End, Microtask1, Timeout1, Promise1, Timeout3, Timeout2",
      "Start, End, Timeout1, Microtask1, Promise1, Timeout3, Timeout2"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to implement a retry mechanism for failed Promises?",
    "o": [
      "Using Promise.finally() to trigger retries",
      "Recursive function with catch handler",
      "Exponential backoff with async/await",
      "Wrapper function with max retry count"
    ]
  },
  {
    "q": "What is the output of this async generator error propagation example?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  throw 'Error';\n  yield 2;\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})().catch(e => console.log(e));",
    "o": [
      "{value: 1, done: false}, then 'Error'",
      "{value: 1, done: false}, {value: undefined, done: true}",
      "{value: 1, done: false}, {value: 2, done: false}",
      "Throws uncaught exception"
    ]
  },
  {
    "q": "What does this code demonstrate about AbortController composition?",
    "l": "javascript",
    "c": "const mainController = new AbortController();\nconst subController = new AbortController();\n\nmainController.signal.addEventListener('abort', () => {\n  subController.abort();\n});\n\nfetch(url, { signal: subController.signal })\n  .catch(e => console.log(e.name));\n\nmainController.abort();",
    "o": [
      "Logs 'AbortError' (both controllers abort)",
      "Only mainController triggers abort",
      "Neither controller affects the fetch",
      "Throws 'Duplicate Abort' error"
    ]
  },
  {
    "q": "Which statement about async stack traces is TRUE in modern JavaScript engines?",
    "o": [
      "They preserve the full async call chain for debugging",
      "They are identical to synchronous stack traces",
      "They only show the most recent await",
      "They require special compiler flags to enable"
    ]
  },
  {
    "q": "What is the output of this Promise resolution edge case?",
    "l": "javascript",
    "c": "const p = new Promise(resolve => {\n  resolve(Promise.reject('Error'));\n});\np.catch(e => console.log(e));",
    "o": [
      "Error (rejection is properly caught)",
      "Unhandled promise rejection",
      "Promise { <rejected> 'Error' }",
      "Infinite loop"
    ]
  },
  {
    "q": "What does this reveal about unhandled rejections in nested chains?",
    "l": "javascript",
    "c": "Promise.resolve()\n  .then(() => Promise.reject('Inner'))\n  .catch(() => { throw 'Outer'; });\n\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Triggers unhandledRejection with 'Outer' but Timeout still runs",
      "Prevents Timeout from executing",
      "Silently handles both errors",
      "Logs 'Inner' then 'Outer'"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for different purposes?",
    "o": [
      "Promise.all() for dependencies, Promise.race() for timeouts",
      "Promise.any() for sequential operations",
      "Promise.allSettled() for fast-fail behavior",
      "Promise.race() for merging multiple results"
    ]
  },
  {
    "q": "What is the output of this microtask priority example?",
    "l": "javascript",
    "c": "queueMicrotask(() => console.log('Microtask1'));\nPromise.resolve().then(() => console.log('Promise1'));\nqueueMicrotask(() => console.log('Microtask2'));\nPromise.resolve().then(() => console.log('Promise2'));",
    "o": [
      "Microtask1, Microtask2, Promise1, Promise2",
      "Microtask1, Promise1, Microtask2, Promise2",
      "Promise1, Promise2, Microtask1, Microtask2",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What does this code show about Promise construction timing?",
    "l": "javascript",
    "c": "let state = 'pending';\nconst p = new Promise(resolve => {\n  setTimeout(() => {\n    state = 'resolved';\n    resolve();\n  }, 100);\n});\nsetTimeout(() => console.log(state), 200);",
    "o": [
      "resolved (after the Promise resolves)",
      "pending (never updates)",
      "undefined",
      "Throws ReferenceError"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of async iterators over Promise.all?",
    "o": [
      "Better performance for fixed-size arrays",
      "Natural backpressure handling",
      "Lazy evaluation of items",
      "Memory efficiency for large datasets"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error handlers?",
    "l": "javascript",
    "c": "Promise.reject('Initial Error')\n  .catch(err => { console.log(`Caught: ${err}`); throw 'New Error'; })\n  .then(() => console.log('Success'))\n  .catch(err => console.log(`Final: ${err}`));",
    "o": [
      "Caught: Initial Error followed by Final: New Error",
      "Caught: Initial Error followed by Success",
      "Final: Initial Error",
      "Uncaught New Error"
    ]
  },
  {
    "q": "Which of these is the most efficient way to process an array of items asynchronously without overwhelming memory?",
    "o": [
      "Using a concurrency-limited pool like p-limit",
      "Promise.all() on the entire array",
      "Sequential processing with for-loop and await",
      "Using Array.map() with async functions"
    ]
  },
  {
    "q": "What does this code reveal about microtask starvation?",
    "l": "javascript",
    "c": "function starve() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    starve();\n  });\n}\nstarve();\nsetTimeout(() => console.log('Timeout'), 100);",
    "o": [
      "Timeout never executes due to infinite microtask queue",
      "Alternates between Microtask and Timeout",
      "Runs Timeout once then enters infinite loop",
      "Throws stack overflow error"
    ]
  },
  {
    "q": "What is the key difference between these two async function declarations?",
    "l": "javascript",
    "c": "async function foo() { return 1; }\nconst bar = async () => { return 1; };",
    "o": [
      "Hoisting behavior (foo is hoisted, bar isn't)",
      "Execution speed",
      "Memory usage",
      "Error handling capability"
    ]
  },
  {
    "q": "What is the output of this Promise.race() edge case?",
    "l": "javascript",
    "c": "const p1 = new Promise(() => {}); // Never settles\nconst p2 = new Promise(resolve => setTimeout(resolve, 100, 'Winner'));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Winner (after 100ms)",
      "Never resolves",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid approach to prevent memory leaks with abandoned Promises?",
    "o": [
      "Always using Promise.race() with a timeout",
      "Cleaning up event listeners in finally()",
      "Using AbortController for cancellation",
      "Storing Promise references indefinitely"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces?",
    "l": "javascript",
    "c": "async function fail() {\n  await Promise.resolve();\n  throw new Error('Async Error');\n}\nfail().catch(err => console.log(err.stack));",
    "o": [
      "Includes async call chain in stack trace",
      "Shows empty stack trace",
      "Only shows error message",
      "Crashes the process"
    ]
  },
  {
    "q": "What is the output of this generator-Promise hybrid?",
    "l": "javascript",
    "c": "async function* asyncGen() {\n  yield await Promise.resolve(1);\n  yield await Promise.reject(2);\n}\n\n(async () => {\n  try {\n    for await (const num of asyncGen()) {\n      console.log(num);\n    }\n  } catch (e) {\n    console.log(`Caught: ${e}`);\n  }\n})();",
    "o": [
      "1 followed by Caught: 2",
      "1, 2",
      "Caught: 2",
      "1 then unhandled rejection"
    ]
  },
  {
    "q": "Which statement about V8's microtask queue is TRUE?",
    "o": [
      "Processes all queued microtasks before moving to macrotasks",
      "Alternates between microtasks and macrotasks",
      "Prioritizes setImmediate over Promises",
      "Limits microtask queue depth to prevent starvation"
    ]
  },
  {
    "q": "What is the output of this performance-sensitive Promise pattern?",
    "l": "javascript",
    "c": "const p = Promise.resolve();\n(async () => {\n  for (let i = 0; i < 3; i++) {\n    await p;\n    console.log(i);\n  }\n})();",
    "o": [
      "0, 1, 2 (with minimal delay between)",
      "Random order due to race conditions",
      "All numbers simultaneously",
      "Nothing (hangs)"
    ]
  },
  {
    "q": "What does this reveal about Node.js's nextTick vs microtasks?",
    "l": "javascript",
    "c": "process.nextTick(() => console.log('nextTick'));\nPromise.resolve().then(() => console.log('Promise'));",
    "o": [
      "nextTick executes before Promise",
      "Promise executes before nextTick",
      "Order is non-deterministic",
      "Throws error about mixing APIs"
    ]
  },
  {
    "q": "Which of these is a valid use case for Promise.reject()?",
    "o": [
      "Immediately returning a failed async operation",
      "Stopping Promise execution mid-chain",
      "Cancelling other Promises",
      "Skipping subsequent .then() handlers"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection scenario?",
    "l": "javascript",
    "c": "const p = new Promise((_, reject) => {\n  setTimeout(() => reject('Late Error'), 100);\n});\nsetTimeout(() => p.catch(() => {}), 200);",
    "o": [
      "Triggers unhandledRejection then rejectionHandled events",
      "Silently fails with no output",
      "Throws synchronous error",
      "Logs 'Late Error' after 200ms"
    ]
  },
  {
    "q": "What does this code show about async function return values?",
    "l": "javascript",
    "c": "async function test() {\n  return { then(resolve) { resolve('Custom Thenable'); } };\n}\ntest().then(console.log);",
    "o": [
      "Custom Thenable",
      "{ then: [Function] }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple finally blocks?",
    "l": "javascript",
    "c": "Promise.resolve('Data')\n  .finally(() => console.log('Cleanup1'))\n  .then(val => { console.log(val); throw 'Error'; })\n  .finally(() => console.log('Cleanup2'))\n  .catch(err => console.log(err));",
    "o": [
      "Cleanup1, Data, Cleanup2, Error",
      "Data, Cleanup1, Error, Cleanup2",
      "Cleanup1, Cleanup2, Data, Error",
      "Data, Error, Cleanup1, Cleanup2"
    ]
  },
  {
    "q": "Which of these is the optimal way to handle concurrent API requests with error tolerance?",
    "o": [
      "Promise.allSettled() with individual result processing",
      "Promise.all() with a single catch block",
      "Multiple await statements in try/catch",
      "Using Promise.any() to ignore failures"
    ]
  },
  {
    "q": "What does this code reveal about Promise resolution values?",
    "l": "javascript",
    "c": "Promise.resolve(\n  new Promise(resolve => resolve('Wrapped'))\n).then(console.log);",
    "o": [
      "Wrapped (automatically unwrapped)",
      "Promise { 'Wrapped' }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What is the execution order of this complex microtask/macrotask example?",
    "l": "javascript",
    "c": "console.log('Start');\nqueueMicrotask(() => console.log('Microtask1'));\nsetTimeout(() => {\n  console.log('Timeout1');\n  queueMicrotask(() => console.log('Microtask2'));\n}, 0);\nPromise.resolve().then(() => console.log('Promise1'));\nconsole.log('End');",
    "o": [
      "Start, End, Microtask1, Promise1, Timeout1, Microtask2",
      "Start, End, Promise1, Microtask1, Timeout1, Microtask2",
      "Start, End, Microtask1, Timeout1, Promise1, Microtask2",
      "Start, End, Timeout1, Microtask1, Promise1, Microtask2"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to implement a Promise timeout pattern?",
    "o": [
      "new Promise(resolve => resolve(setTimeout(resolve, delay)))",
      "Promise.race([task, timeoutPromise])",
      "AbortSignal.timeout(delay)",
      "util.promisify(setTimeout)(delay).then(() => { throw 'Timeout' })"
    ]
  },
  {
    "q": "What is the output of this async generator error handling example?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  throw 'Generator Error';\n}\n\n(async () => {\n  try {\n    for await (const num of gen()) {\n      console.log(num);\n    }\n  } catch (e) {\n    console.log(`Caught: ${e}`);\n  }\n})();",
    "o": [
      "1 followed by Caught: Generator Error",
      "1 then unhandled rejection",
      "Caught: Generator Error",
      "1, undefined"
    ]
  },
  {
    "q": "What does this code demonstrate about AbortController propagation?",
    "l": "javascript",
    "c": "const controller = new AbortController();\nconst { signal } = controller;\n\nfetch(url1, { signal })\n  .then(() => fetch(url2, { signal }))\n  .catch(err => {\n    if (err.name === 'AbortError') {\n      console.log('Aborted!');\n    }\n  });\n\ncontroller.abort();",
    "o": [
      "Both fetch requests are aborted and caught",
      "Only the first fetch is aborted",
      "Throws Synchronous AbortError",
      "Requests continue despite abort"
    ]
  },
  {
    "q": "Which statement about async function performance is TRUE?",
    "o": [
      "Zero-cost for simple Promises in modern engines",
      "Always slower than Promise.then() chains",
      "Adds significant memory overhead per call",
      "Forces synchronous execution"
    ]
  },
  {
    "q": "What is the output of this Promise composition with thenables?",
    "l": "javascript",
    "c": "Promise.resolve({\n  then(resolve) { resolve('Custom Thenable'); }\n}).then(console.log);",
    "o": [
      "Custom Thenable",
      "{ then: [Function] }",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "What does this reveal about unhandled rejections in async functions?",
    "l": "javascript",
    "c": "async function fail() {\n  await Promise.reject('Silent Error');\n}\nfail();\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Triggers unhandledRejection but Timeout still runs",
      "Prevents Timeout from executing",
      "Throws synchronous error",
      "Logs 'Silent Error' after Timeout"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise.try() pattern?",
    "o": [
      "Wrapping synchronous code that might throw",
      "Replacing all try/catch blocks",
      "Making async functions run faster",
      "Converting callbacks to Promises"
    ]
  },
  {
    "q": "What is the output of this nested microtask example?",
    "l": "javascript",
    "c": "queueMicrotask(() => {\n  console.log('Microtask1');\n  queueMicrotask(() => console.log('Nested Microtask'));\n});\nqueueMicrotask(() => console.log('Microtask2'));",
    "o": [
      "Microtask1, Microtask2, Nested Microtask",
      "Microtask1, Nested Microtask, Microtask2",
      "Nested Microtask, Microtask1, Microtask2",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What does this code show about Promise resolution timing?",
    "l": "javascript",
    "c": "let resolved = false;\nconst p = new Promise(resolve => {\n  setTimeout(() => {\n    resolve('Done');\n    resolved = true;\n  }, 100);\n});\nsetTimeout(() => console.log(resolved ? 'Resolved' : 'Pending'), 200);",
    "o": [
      "Resolved",
      "Pending",
      "Throws ReferenceError",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of async iterators over callbacks?",
    "o": [
      "Lower memory usage in all cases",
      "Cleaner syntax with for-await-of",
      "Better error handling with try/catch",
      "Natural backpressure handling"
    ]
  },
  {
    "q": "What is the output of this Promise chain with conditional error handling?",
    "l": "javascript",
    "c": "Promise.reject('Error')\n  .catch(err => err === 'Error' ? Promise.resolve('Recovered') : Promise.reject(err))\n  .then(console.log)\n  .catch(console.error);",
    "o": [
      "Recovered",
      "Error",
      "Unhandled promise rejection",
      "No output"
    ]
  },
  {
    "q": "Which of these patterns provides the best way to implement a cancellable async workflow?",
    "o": [
      "AbortController with signal propagation",
      "Promise.race() with timeout",
      "Throwing special cancellation errors",
      "Using generator functions with yield"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue ordering?",
    "l": "javascript",
    "c": "console.log('Start');\nPromise.resolve().then(() => console.log('Promise1'));\nqueueMicrotask(() => console.log('Microtask1'));\nPromise.resolve().then(() => console.log('Promise2'));\nqueueMicrotask(() => console.log('Microtask2'));\nconsole.log('End');",
    "o": [
      "Start, End, Promise1, Microtask1, Promise2, Microtask2",
      "Start, End, Microtask1, Microtask2, Promise1, Promise2",
      "Start, End, Promise1, Promise2, Microtask1, Microtask2",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What is the key difference between these two async error handling approaches?",
    "l": "javascript",
    "c": "// Approach 1\nasync function foo() {\n  try { await riskyOp(); }\n  catch (e) { handle(e); }\n}\n\n// Approach 2\nasync function bar() {\n  return riskyOp().catch(handle);\n}",
    "o": [
      "Approach 2 doesn't create implicit Promise",
      "Approach 1 has better stack traces",
      "Approach 2 is always faster",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled edge case?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve(1),\n  new Promise(() => {}), // Pending\n  Promise.reject(3)\n]).then(console.log);",
    "o": [
      "Array with one fulfilled, one pending, and one rejected",
      "Never resolves due to pending Promise",
      "[1, undefined, 3]",
      "Throws TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid optimization for high-throughput Promise chains?",
    "o": [
      "Using async/await for every operation",
      "Reusing resolved Promises",
      "Avoiding unnecessary await",
      "Batching operations with Promise.all"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces?",
    "l": "javascript",
    "c": "async function a() { await b(); }\nasync function b() { await c(); }\nasync function c() { throw new Error('Trace'); }\na().catch(console.log);",
    "o": [
      "Full async call stack is preserved",
      "Only shows error from function c",
      "Stack trace is empty",
      "Throws synchronously"
    ]
  },
  {
    "q": "What is the output of this async generator flow control example?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  await Promise.resolve();\n  yield 2;\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1, done: false}, {value: 2, done: false}, {value: undefined, done: true}",
      "1, 2, undefined",
      "{value: 1, done: false} then hangs",
      "Throws after first yield"
    ]
  },
  {
    "q": "Which statement about Promise hooks is TRUE?",
    "o": [
      "They allow tracking Promise lifecycle events",
      "They can cancel Promises mid-execution",
      "They are part of the official ECMAScript spec",
      "They improve Promise performance"
    ]
  },
  {
    "q": "What is the output of this performance-sensitive Promise reuse pattern?",
    "l": "javascript",
    "c": "const p = Promise.resolve('Shared');\n(async () => {\n  console.log(await p);\n  console.log(await p);\n})();",
    "o": [
      "Shared, Shared (reuses same Promise)",
      "Shared (only once)",
      "Throws 'Promise already consumed'",
      "Undefined behavior"
    ]
  },
  {
    "q": "What does this reveal about Node.js async resource tracking?",
    "l": "javascript",
    "c": "const ac = new AsyncLocalStorage();\n\nac.run('context', async () => {\n  await Promise.resolve();\n  console.log(ac.getStore());\n});",
    "o": [
      "Preserves context across async hops",
      "Loses context after await",
      "Throws 'AsyncLocalStorage not defined'",
      "Output is non-deterministic"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for different scenarios?",
    "o": [
      "Promise.all() for dependencies, Promise.any() for fallbacks",
      "Promise.race() for merging results",
      "Promise.allSettled() for fast-fail",
      "Promise.any() for sequential operations"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection lifecycle example?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only",
      "No output"
    ]
  },
  {
    "q": "What does this code show about AbortSignal composition?",
    "l": "javascript",
    "c": "const c1 = new AbortController();\nconst c2 = new AbortController();\n\nc1.signal.addEventListener('abort', () => c2.abort());\n\nfetch(url, { signal: c2.signal })\n  .catch(e => console.log(e.name));\n\nc1.abort();",
    "o": [
      "Logs 'AbortError' (both controllers abort)",
      "Only c1 triggers abort",
      "Neither controller affects the fetch",
      "Throws 'Duplicate Abort' error"
    ]
  },
  {
    "q": "What is the output of this Promise chain with nested error handling?",
    "l": "javascript",
    "c": "Promise.resolve()\n  .then(() => { throw 'Error1'; })\n  .catch(e => { console.log(e); throw 'Error2'; })\n  .catch(e => console.log(e))\n  .then(() => { throw 'Error3'; }, e => console.log(e));",
    "o": [
      "Error1 followed by Error2 followed by Error3",
      "Error1 followed by Error2",
      "Error1 followed by Error3",
      "Error2 followed by Error3"
    ]
  },
  {
    "q": "Which of these is the most efficient way to implement a retry mechanism for failed API calls?",
    "o": [
      "Exponential backoff with async/await",
      "Simple for-loop with retry count",
      "Recursive Promise chain",
      "Using setInterval for retries"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue behavior?",
    "l": "javascript",
    "c": "let count = 0;\nfunction loop() {\n  Promise.resolve().then(() => {\n    count++;\n    if (count < 3) loop();\n    console.log(count);\n  });\n}\nloop();\nsetTimeout(() => console.log('Timeout'), 0);",
    "o": [
      "1, 2, 3, then Timeout",
      "Timeout, then 1, 2, 3",
      "3, 2, 1, then Timeout",
      "Infinite loop"
    ]
  },
  {
    "q": "What is the key difference between these two async function declarations?",
    "l": "javascript",
    "c": "async function foo() { await Promise.resolve(); }\nconst bar = async function() { await Promise.resolve(); };",
    "o": [
      "Only foo is hoisted",
      "bar is faster to execute",
      "foo cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.race() edge case with a never-settling Promise?",
    "l": "javascript",
    "c": "const p1 = new Promise(() => {});\nconst p2 = new Promise(resolve => setTimeout(resolve, 100, 'Result'));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Result (after 100ms)",
      "Never resolves",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to prevent memory leaks with Promises?",
    "o": [
      "Using weak references for Promise storage",
      "Cleaning up event listeners in finally()",
      "Using AbortController for cancellation",
      "Avoiding circular Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in Node.js?",
    "l": "javascript",
    "c": "async function a() { await b(); }\nasync function b() { await c(); }\nasync function c() { throw new Error('Trace'); }\n\na().catch(err => console.log(err.stack));",
    "o": [
      "Includes full async call chain (a → b → c)",
      "Only shows error from function c",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error handling?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  throw 'Error';\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n})().catch(e => console.log(e));",
    "o": [
      "{value: 1, done: false} followed by 'Error'",
      "{value: 1, done: false}, {value: undefined, done: true}",
      "'Error' only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which statement about V8's Promise optimization is TRUE?",
    "o": [
      "Simple await expressions may not create microtasks",
      "Async functions are always slower than Promises",
      "Promise chains cannot be optimized",
      "await always adds significant overhead"
    ]
  },
  {
    "q": "What is the output of this shared Promise optimization pattern?",
    "l": "javascript",
    "c": "const shared = Promise.resolve('Value');\n\nasync function a() { console.log(await shared); }\nasync function b() { console.log(await shared); }\n\na(); b();",
    "o": [
      "Value, Value (reuses same Promise)",
      "Value (only once)",
      "undefined, undefined",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's async_hooks?",
    "l": "javascript",
    "c": "const asyncHook = require('async_hooks').createHook({\n  init(asyncId) { /* track async ops */ }\n});\n\nasyncHook.enable();\n\nasync function example() {\n  await Promise.resolve();\n}\n\nexample();",
    "o": [
      "Can track Promise lifecycle events",
      "Slows down Promise execution significantly",
      "Only works for callbacks, not Promises",
      "Prevents Promise optimization"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators?",
    "o": [
      "Promise.allSettled() for analytics logging",
      "Promise.race() for merging multiple results",
      "Promise.any() for sequential operations",
      "Promise.all() for fallback behavior"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection lifecycle example?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only",
      "No output"
    ]
  },
  {
    "q": "What does this code show about AbortController composition?",
    "l": "javascript",
    "c": "const parent = new AbortController();\nconst child = new AbortController();\n\nparent.signal.addEventListener('abort', () => child.abort());\n\nfetch(url, { signal: child.signal })\n  .catch(e => console.log(e.name));\n\nparent.abort();",
    "o": [
      "Logs 'AbortError' (both controllers abort)",
      "Only parent triggers abort",
      "Neither controller affects the fetch",
      "Throws 'Duplicate Abort' error"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of async iterators over Promise.all?",
    "o": [
      "Better performance for small fixed arrays",
      "Lazy evaluation of items",
      "Natural backpressure handling",
      "Memory efficiency for large datasets"
    ]
  },
  {
    "q": "What is the output of this Promise chain with conditional error recovery?",
    "l": "javascript",
    "c": "Promise.reject(404)\n  .catch(err => err === 404 ? 'Fallback Data' : Promise.reject(err))\n  .then(console.log)\n  .catch(console.error);",
    "o": [
      "Fallback Data",
      "404",
      "Unhandled promise rejection",
      "No output"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a rate-limited API client?",
    "o": [
      "Token bucket algorithm with async/await",
      "Promise.all() with fixed concurrency",
      "setInterval with queue processing",
      "Recursive setTimeout"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue starvation?",
    "l": "javascript",
    "c": "function starve() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    starve();\n  });\n}\nstarve();\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Infinite 'Microtask' logs (Timeout never runs)",
      "Microtask logs until Timeout executes",
      "Throws stack overflow error",
      "Alternates between Microtask and Timeout"
    ]
  },
  {
    "q": "What is the key difference between these async function declarations?",
    "l": "javascript",
    "c": "const foo = async function() { await Promise.resolve(); };\nconst bar = async () => { await Promise.resolve(); };",
    "o": [
      "foo has arguments object, bar doesn't",
      "bar is faster to execute",
      "foo cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.any() edge case with all rejections?",
    "l": "javascript",
    "c": "Promise.any([\n  Promise.reject('Error1'),\n  Promise.reject('Error2')\n]).catch(e => console.log(e.errors));",
    "o": [
      "['Error1', 'Error2']",
      "AggregateError",
      "Error1",
      "Unhandled rejection"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to debug Promise memory leaks?",
    "o": [
      "Counting .then() handlers",
      "Using async_hooks in Node.js",
      "Chrome DevTools Promise inspector",
      "WeakRef tracking"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in Chrome?",
    "l": "javascript",
    "c": "async function a() { await b(); }\nasync function b() { await c(); }\nasync function c() { throw new Error('Trace'); }\n\na().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async call chain with 'await' locations",
      "Only shows error from function c",
      "Stack trace is truncated",
      "Requires --async-stack-traces flag"
    ]
  },
  {
    "q": "What is the output of this async generator with early return?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  return 2;\n  yield 3;\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1, done: false}, {value: 2, done: true}, {value: undefined, done: true}",
      "1, 2, undefined",
      "{value: 1, done: false}, {value: 2, done: false}",
      "Throws after first yield"
    ]
  },
  {
    "q": "Which statement about V8's Promise optimization is FALSE?",
    "o": [
      "Async functions always create 3 Promises per call",
      "await can be zero-cost for immediate values",
      "Simple chains may skip microtasks",
      "TurboFan optimizes Promise handling"
    ]
  },
  {
    "q": "What is the output of this high-performance Promise reuse pattern?",
    "l": "javascript",
    "c": "const cache = Promise.resolve('Cached');\n\nasync function a() { console.log(await cache, await cache); }\nasync function b() { console.log(await cache); }\n\na(); b();",
    "o": [
      "Cached Cached, Cached (reuses same Promise)",
      "Cached, Cached Cached",
      "Race condition",
      "Cached (only once)"
    ]
  },
  {
    "q": "What does this reveal about Node.js's async context tracking?",
    "l": "javascript",
    "c": "const { AsyncLocalStorage } = require('async_hooks');\nconst ctx = new AsyncLocalStorage();\n\nctx.run('data', async () => {\n  await Promise.resolve();\n  console.log(ctx.getStore());\n});",
    "o": [
      "data (context persists across async)",
      "undefined (lost after await)",
      "Throws 'Store missing' error",
      "Non-deterministic output"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for analytics?",
    "o": [
      "Promise.allSettled() to track success/failure rates",
      "Promise.race() to merge response data",
      "Promise.any() for sequential processing",
      "Promise.all() to implement fallbacks"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with late handling?",
    "l": "javascript",
    "c": "const p = Promise.reject('Late');\nsetTimeout(() => p.catch(() => {}), 100);\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only",
      "No output"
    ]
  },
  {
    "q": "What does this code show about nested AbortControllers?",
    "l": "javascript",
    "c": "const parent = new AbortController();\nconst child = new AbortController();\n\nparent.signal.addEventListener('abort', () => child.abort());\n\nfetch(url, { signal: child.signal })\n  .catch(e => console.log(e.name));\n\nparent.abort();",
    "o": [
      "Logs 'AbortError' (cascading abort)",
      "Only parent aborts",
      "Neither affects the fetch",
      "Throws 'Double Abort' error"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async iterators over callbacks?",
    "o": [
      "Lower CPU usage in all cases",
      "Cleaner control flow with for-await-of",
      "Integrated error handling",
      "Natural backpressure"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error transformations?",
    "l": "javascript",
    "c": "Promise.reject(new Error('DB_FAILURE'))\n  .catch(err => { throw new Error('NETWORK_ERROR'); })\n  .catch(err => { console.log(err.message); throw err; })\n  .catch(err => console.log('Final:', err.message));",
    "o": [
      "NETWORK_ERROR followed by Final: NETWORK_ERROR",
      "DB_FAILURE followed by NETWORK_ERROR",
      "Final: NETWORK_ERROR only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a priority queue for async tasks?",
    "o": [
      "Heap structure with async processing loop",
      "Array.sort() before Promise.all()",
      "Multiple Promise.race() calls",
      "Recursive setTimeout with priority check"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue ordering with async/await?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await Promise.resolve();\n  console.log('Middle');\n  queueMicrotask(() => console.log('Microtask'));\n  await Promise.resolve();\n  console.log('End');\n}\ntest();",
    "o": [
      "Start, Middle, Microtask, End",
      "Start, Middle, End, Microtask",
      "Start, Microtask, Middle, End",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What is the key difference between these async arrow functions?",
    "l": "javascript",
    "c": "const foo = async (x) => { await x; };\nconst bar = async x => await x;",
    "o": [
      "bar implicitly returns the await result",
      "foo has different scoping rules",
      "bar cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled() edge case with mixed states?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve('Success'),\n  new Promise(() => {}), // Pending\n  Promise.reject('Error'),\n  { status: 'fulfilled', value: 'Manual' }\n]).then(console.log);",
    "o": [
      "Array with fulfilled, pending, rejected, and fulfilled entries",
      "Never resolves due to pending Promise",
      "['Success', undefined, 'Error', 'Manual']",
      "Throws TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to analyze Promise memory usage in Node.js?",
    "o": [
      "Using process.memoryUsage().promises",
      "Async hooks with init/destroy tracking",
      "Heap snapshots in DevTools",
      "WeakMap for Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in error recovery?",
    "l": "javascript",
    "c": "async function fetchData() {\n  await setup();\n  throw new Error('API_FAILURE');\n}\n\nasync function setup() {\n  await connect();\n}\n\nasync function connect() {\n  await Promise.resolve();\n}\n\nfetchData().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async chain including setup() and connect()",
      "Only shows API_FAILURE at fetchData()",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error recovery?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  try {\n    yield Promise.reject('Error');\n  } catch (e) {\n    yield 'Recovered';\n  }\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1}, {value: 'Recovered'}, {done: true}",
      "{value: 1}, then unhandled rejection",
      "{value: 1}, {error: 'Error'}, {done: true}",
      "Throws during iteration"
    ]
  },
  {
    "q": "Which statement about V8's async/await optimization is TRUE?",
    "o": [
      "await of non-Promise values skips microtasks",
      "Async functions are always slower than callbacks",
      "Each await creates exactly one microtask",
      "Optimizations don't work with try/catch"
    ]
  },
  {
    "q": "What is the output of this Promise memoization pattern?",
    "l": "javascript",
    "c": "function memoize(fn) {\n  let cache;\n  return () => cache || (cache = fn());\n}\n\nconst getData = memoize(async () => {\n  console.log('Fetching');\n  return 'Data';\n});\n\ngetData().then(console.log);\ngetData().then(console.log);",
    "o": [
      "Fetching once then Data twice",
      "Fetching twice then Data twice",
      "Data, Fetching, Data",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's AsyncResource class?",
    "l": "javascript",
    "c": "const { AsyncResource } = require('async_hooks');\n\nconst resource = new AsyncResource('DBQuery');\nresource.runInAsyncScope(async () => {\n  await Promise.resolve();\n  console.log(AsyncResource.currentId());\n});",
    "o": [
      "Maintains context across async operations",
      "Loses context after await",
      "Throws 'AsyncResource not defined'",
      "Output is non-deterministic"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for monitoring?",
    "o": [
      "Promise.allSettled() for tracking completion states",
      "Promise.race() to merge API responses",
      "Promise.any() for sequential processing",
      "Promise.all() to implement retries"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with multiple handlers?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\np.catch(() => {});\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "No output (properly handled)",
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only"
    ]
  },
  {
    "q": "What does this code show about AbortController propagation in chains?",
    "l": "javascript",
    "c": "const controller = new AbortController();\n\nfetch(url1, { signal: controller.signal })\n  .then(() => fetch(url2, { signal: controller.signal }))\n  .catch(e => console.log(e.name));\n\ncontroller.abort();",
    "o": [
      "Logs 'AbortError' (both fetches aborted)",
      "Only first fetch is aborted",
      "Neither fetch is aborted",
      "Throws 'AbortError' synchronously"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async generators over callbacks?",
    "o": [
      "Lower memory usage for all use cases",
      "Cleaner iteration with for-await-of",
      "Built-in error handling in loops",
      "Natural backpressure implementation"
    ]
  },
  {
    "q": "What is the output of this Promise chain with conditional error recovery?",
    "l": "javascript",
    "c": "Promise.reject(404)\n  .catch(err => err === 404 ? 'Fallback Data' : Promise.reject(err))\n  .then(console.log)\n  .catch(console.error);",
    "o": [
      "Fallback Data",
      "404",
      "Unhandled promise rejection",
      "No output"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a rate-limited API client?",
    "o": [
      "Token bucket algorithm with async/await",
      "Promise.all() with fixed concurrency",
      "setInterval with queue processing",
      "Recursive setTimeout"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue starvation?",
    "l": "javascript",
    "c": "function starve() {\n  Promise.resolve().then(() => {\n    console.log('Microtask');\n    starve();\n  });\n}\nstarve();\nsetTimeout(() => console.log('Timeout'), 1000);",
    "o": [
      "Infinite 'Microtask' logs (Timeout never runs)",
      "Microtask logs until Timeout executes",
      "Throws stack overflow error",
      "Alternates between Microtask and Timeout"
    ]
  },
  {
    "q": "What is the key difference between these async function declarations?",
    "l": "javascript",
    "c": "const foo = async function() { await Promise.resolve(); };\nconst bar = async () => { await Promise.resolve(); };",
    "o": [
      "foo has arguments object, bar doesn't",
      "bar is faster to execute",
      "foo cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.any() edge case with all rejections?",
    "l": "javascript",
    "c": "Promise.any([\n  Promise.reject('Error1'),\n  Promise.reject('Error2')\n]).catch(e => console.log(e.errors));",
    "o": [
      "['Error1', 'Error2']",
      "AggregateError",
      "Error1",
      "Unhandled rejection"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to debug Promise memory leaks?",
    "o": [
      "Counting .then() handlers",
      "Using async_hooks in Node.js",
      "Chrome DevTools Promise inspector",
      "WeakRef tracking"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in Chrome?",
    "l": "javascript",
    "c": "async function a() { await b(); }\nasync function b() { await c(); }\nasync function c() { throw new Error('Trace'); }\n\na().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async call chain with 'await' locations",
      "Only shows error from function c",
      "Stack trace is truncated",
      "Requires --async-stack-traces flag"
    ]
  },
  {
    "q": "What is the output of this async generator with early return?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  return 2;\n  yield 3;\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1, done: false}, {value: 2, done: true}, {value: undefined, done: true}",
      "1, 2, undefined",
      "{value: 1, done: false}, {value: 2, done: false}",
      "Throws after first yield"
    ]
  },
  {
    "q": "Which statement about V8's Promise optimization is FALSE?",
    "o": [
      "Async functions always create 3 Promises per call",
      "await can be zero-cost for immediate values",
      "Simple chains may skip microtasks",
      "TurboFan optimizes Promise handling"
    ]
  },
  {
    "q": "What is the output of this high-performance Promise reuse pattern?",
    "l": "javascript",
    "c": "const cache = Promise.resolve('Cached');\n\nasync function a() { console.log(await cache, await cache); }\nasync function b() { console.log(await cache); }\n\na(); b();",
    "o": [
      "Cached Cached, Cached (reuses same Promise)",
      "Cached, Cached Cached",
      "Race condition",
      "Cached (only once)"
    ]
  },
  {
    "q": "What does this reveal about Node.js's async context tracking?",
    "l": "javascript",
    "c": "const { AsyncLocalStorage } = require('async_hooks');\nconst ctx = new AsyncLocalStorage();\n\nctx.run('data', async () => {\n  await Promise.resolve();\n  console.log(ctx.getStore());\n});",
    "o": [
      "data (context persists across async)",
      "undefined (lost after await)",
      "Throws 'Store missing' error",
      "Non-deterministic output"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for analytics?",
    "o": [
      "Promise.allSettled() to track success/failure rates",
      "Promise.race() to merge response data",
      "Promise.any() for sequential processing",
      "Promise.all() to implement fallbacks"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with late handling?",
    "l": "javascript",
    "c": "const p = Promise.reject('Late');\nsetTimeout(() => p.catch(() => {}), 100);\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only",
      "No output"
    ]
  },
  {
    "q": "What does this code show about nested AbortControllers?",
    "l": "javascript",
    "c": "const parent = new AbortController();\nconst child = new AbortController();\n\nparent.signal.addEventListener('abort', () => child.abort());\n\nfetch(url, { signal: child.signal })\n  .catch(e => console.log(e.name));\n\nparent.abort();",
    "o": [
      "Logs 'AbortError' (cascading abort)",
      "Only parent aborts",
      "Neither affects the fetch",
      "Throws 'Double Abort' error"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async iterators over callbacks?",
    "o": [
      "Lower CPU usage in all cases",
      "Cleaner control flow with for-await-of",
      "Integrated error handling",
      "Natural backpressure"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error transformations?",
    "l": "javascript",
    "c": "Promise.reject(new Error('DB_FAILURE'))\n  .catch(err => { throw new Error('NETWORK_ERROR'); })\n  .catch(err => { console.log(err.message); throw err; })\n  .catch(err => console.log('Final:', err.message));",
    "o": [
      "NETWORK_ERROR followed by Final: NETWORK_ERROR",
      "DB_FAILURE followed by NETWORK_ERROR",
      "Final: NETWORK_ERROR only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a priority queue for async tasks?",
    "o": [
      "Heap structure with async processing loop",
      "Array.sort() before Promise.all()",
      "Multiple Promise.race() calls",
      "Recursive setTimeout with priority check"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue ordering with async/await?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await Promise.resolve();\n  console.log('Middle');\n  queueMicrotask(() => console.log('Microtask'));\n  await Promise.resolve();\n  console.log('End');\n}\ntest();",
    "o": [
      "Start, Middle, Microtask, End",
      "Start, Middle, End, Microtask",
      "Start, Microtask, Middle, End",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What is the key difference between these async arrow functions?",
    "l": "javascript",
    "c": "const foo = async (x) => { await x; };\nconst bar = async x => await x;",
    "o": [
      "bar implicitly returns the await result",
      "foo has different scoping rules",
      "bar cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled() edge case with mixed states?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve('Success'),\n  new Promise(() => {}), // Pending\n  Promise.reject('Error'),\n  { status: 'fulfilled', value: 'Manual' }\n]).then(console.log);",
    "o": [
      "Array with fulfilled, pending, rejected, and fulfilled entries",
      "Never resolves due to pending Promise",
      "['Success', undefined, 'Error', 'Manual']",
      "Throws TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to analyze Promise memory usage in Node.js?",
    "o": [
      "Using process.memoryUsage().promises",
      "Async hooks with init/destroy tracking",
      "Heap snapshots in DevTools",
      "WeakMap for Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in error recovery?",
    "l": "javascript",
    "c": "async function fetchData() {\n  await setup();\n  throw new Error('API_FAILURE');\n}\n\nasync function setup() {\n  await connect();\n}\n\nasync function connect() {\n  await Promise.resolve();\n}\n\nfetchData().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async chain including setup() and connect()",
      "Only shows API_FAILURE at fetchData()",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error recovery?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  try {\n    yield Promise.reject('Error');\n  } catch (e) {\n    yield 'Recovered';\n  }\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1}, {value: 'Recovered'}, {done: true}",
      "{value: 1}, then unhandled rejection",
      "{value: 1}, {error: 'Error'}, {done: true}",
      "Throws during iteration"
    ]
  },
  {
    "q": "Which statement about V8's async/await optimization is TRUE?",
    "o": [
      "await of non-Promise values skips microtasks",
      "Async functions are always slower than callbacks",
      "Each await creates exactly one microtask",
      "Optimizations don't work with try/catch"
    ]
  },
  {
    "q": "What is the output of this Promise memoization pattern?",
    "l": "javascript",
    "c": "function memoize(fn) {\n  let cache;\n  return () => cache || (cache = fn());\n}\n\nconst getData = memoize(async () => {\n  console.log('Fetching');\n  return 'Data';\n});\n\ngetData().then(console.log);\ngetData().then(console.log);",
    "o": [
      "Fetching once then Data twice",
      "Fetching twice then Data twice",
      "Data, Fetching, Data",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's AsyncResource class?",
    "l": "javascript",
    "c": "const { AsyncResource } = require('async_hooks');\n\nconst resource = new AsyncResource('DBQuery');\nresource.runInAsyncScope(async () => {\n  await Promise.resolve();\n  console.log(AsyncResource.currentId());\n});",
    "o": [
      "Maintains context across async operations",
      "Loses context after await",
      "Throws 'AsyncResource not defined'",
      "Output is non-deterministic"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for monitoring?",
    "o": [
      "Promise.allSettled() for tracking completion states",
      "Promise.race() to merge API responses",
      "Promise.any() for sequential processing",
      "Promise.all() to implement retries"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with multiple handlers?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\np.catch(() => {});\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "No output (properly handled)",
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only"
    ]
  },
  {
    "q": "What does this code show about AbortController propagation in chains?",
    "l": "javascript",
    "c": "const controller = new AbortController();\n\nfetch(url1, { signal: controller.signal })\n  .then(() => fetch(url2, { signal: controller.signal }))\n  .catch(e => console.log(e.name));\n\ncontroller.abort();",
    "o": [
      "Logs 'AbortError' (both fetches aborted)",
      "Only first fetch is aborted",
      "Neither fetch is aborted",
      "Throws 'AbortError' synchronously"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async generators over callbacks?",
    "o": [
      "Lower memory usage for all use cases",
      "Cleaner iteration with for-await-of",
      "Built-in error handling in loops",
      "Natural backpressure implementation"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error transformations?",
    "l": "javascript",
    "c": "Promise.reject(new Error('DB_FAILURE'))\n  .catch(err => { throw new Error('NETWORK_ERROR'); })\n  .catch(err => { console.log(err.message); throw err; })\n  .catch(err => console.log('Final:', err.message));",
    "o": [
      "NETWORK_ERROR followed by Final: NETWORK_ERROR",
      "DB_FAILURE followed by NETWORK_ERROR",
      "Final: NETWORK_ERROR only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a priority queue for async tasks?",
    "o": [
      "Heap structure with async processing loop",
      "Array.sort() before Promise.all()",
      "Multiple Promise.race() calls",
      "Recursive setTimeout with priority check"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue ordering with async/await?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await Promise.resolve();\n  console.log('Middle');\n  queueMicrotask(() => console.log('Microtask'));\n  await Promise.resolve();\n  console.log('End');\n}\ntest();",
    "o": [
      "Start, Middle, Microtask, End",
      "Start, Middle, End, Microtask",
      "Start, Microtask, Middle, End",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What is the key difference between these async arrow functions?",
    "l": "javascript",
    "c": "const foo = async (x) => { await x; };\nconst bar = async x => await x;",
    "o": [
      "bar implicitly returns the await result",
      "foo has different scoping rules",
      "bar cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled() edge case with mixed states?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve('Success'),\n  new Promise(() => {}), // Pending\n  Promise.reject('Error'),\n  { status: 'fulfilled', value: 'Manual' }\n]).then(console.log);",
    "o": [
      "Array with fulfilled, pending, rejected, and fulfilled entries",
      "Never resolves due to pending Promise",
      "['Success', undefined, 'Error', 'Manual']",
      "Throws TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to analyze Promise memory usage in Node.js?",
    "o": [
      "Using process.memoryUsage().promises",
      "Async hooks with init/destroy tracking",
      "Heap snapshots in DevTools",
      "WeakMap for Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in error recovery?",
    "l": "javascript",
    "c": "async function fetchData() {\n  await setup();\n  throw new Error('API_FAILURE');\n}\n\nasync function setup() {\n  await connect();\n}\n\nasync function connect() {\n  await Promise.resolve();\n}\n\nfetchData().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async chain including setup() and connect()",
      "Only shows API_FAILURE at fetchData()",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error recovery?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  try {\n    yield Promise.reject('Error');\n  } catch (e) {\n    yield 'Recovered';\n  }\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1}, {value: 'Recovered'}, {done: true}",
      "{value: 1}, then unhandled rejection",
      "{value: 1}, {error: 'Error'}, {done: true}",
      "Throws during iteration"
    ]
  },
  {
    "q": "Which statement about V8's async/await optimization is TRUE?",
    "o": [
      "await of non-Promise values skips microtasks",
      "Async functions are always slower than callbacks",
      "Each await creates exactly one microtask",
      "Optimizations don't work with try/catch"
    ]
  },
  {
    "q": "What is the output of this Promise memoization pattern?",
    "l": "javascript",
    "c": "function memoize(fn) {\n  let cache;\n  return () => cache || (cache = fn());\n}\n\nconst getData = memoize(async () => {\n  console.log('Fetching');\n  return 'Data';\n});\n\ngetData().then(console.log);\ngetData().then(console.log);",
    "o": [
      "Fetching once then Data twice",
      "Fetching twice then Data twice",
      "Data, Fetching, Data",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's AsyncResource class?",
    "l": "javascript",
    "c": "const { AsyncResource } = require('async_hooks');\n\nconst resource = new AsyncResource('DBQuery');\nresource.runInAsyncScope(async () => {\n  await Promise.resolve();\n  console.log(AsyncResource.currentId());\n});",
    "o": [
      "Maintains context across async operations",
      "Loses context after await",
      "Throws 'AsyncResource not defined'",
      "Output is non-deterministic"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for monitoring?",
    "o": [
      "Promise.allSettled() for tracking completion states",
      "Promise.race() to merge API responses",
      "Promise.any() for sequential processing",
      "Promise.all() to implement retries"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with multiple handlers?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\np.catch(() => {});\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "No output (properly handled)",
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only"
    ]
  },
  {
    "q": "What does this code show about AbortController propagation in chains?",
    "l": "javascript",
    "c": "const controller = new AbortController();\n\nfetch(url1, { signal: controller.signal })\n  .then(() => fetch(url2, { signal: controller.signal }))\n  .catch(e => console.log(e.name));\n\ncontroller.abort();",
    "o": [
      "Logs 'AbortError' (both fetches aborted)",
      "Only first fetch is aborted",
      "Neither fetch is aborted",
      "Throws 'AbortError' synchronously"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async generators over callbacks?",
    "o": [
      "Lower memory usage for all use cases",
      "Cleaner iteration with for-await-of",
      "Built-in error handling in loops",
      "Natural backpressure implementation"
    ]
  },
  {
    "q": "What is the output of this Promise chain with multiple error transformations?",
    "l": "javascript",
    "c": "Promise.reject(new Error('DB_FAILURE'))\n  .catch(err => { throw new Error('NETWORK_ERROR'); })\n  .catch(err => { console.log(err.message); throw err; })\n  .catch(err => console.log('Final:', err.message));",
    "o": [
      "NETWORK_ERROR followed by Final: NETWORK_ERROR",
      "DB_FAILURE followed by NETWORK_ERROR",
      "Final: NETWORK_ERROR only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which of these is the optimal way to implement a priority queue for async tasks?",
    "o": [
      "Heap structure with async processing loop",
      "Array.sort() before Promise.all()",
      "Multiple Promise.race() calls",
      "Recursive setTimeout with priority check"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue ordering with async/await?",
    "l": "javascript",
    "c": "async function test() {\n  console.log('Start');\n  await Promise.resolve();\n  console.log('Middle');\n  queueMicrotask(() => console.log('Microtask'));\n  await Promise.resolve();\n  console.log('End');\n}\ntest();",
    "o": [
      "Start, Middle, Microtask, End",
      "Start, Middle, End, Microtask",
      "Start, Microtask, Middle, End",
      "Order is non-deterministic"
    ]
  },
  {
    "q": "What is the key difference between these async arrow functions?",
    "l": "javascript",
    "c": "const foo = async (x) => { await x; };\nconst bar = async x => await x;",
    "o": [
      "bar implicitly returns the await result",
      "foo has different scoping rules",
      "bar cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.allSettled() edge case with mixed states?",
    "l": "javascript",
    "c": "Promise.allSettled([\n  Promise.resolve('Success'),\n  new Promise(() => {}), // Pending\n  Promise.reject('Error'),\n  { status: 'fulfilled', value: 'Manual' }\n]).then(console.log);",
    "o": [
      "Array with fulfilled, pending, rejected, and fulfilled entries",
      "Never resolves due to pending Promise",
      "['Success', undefined, 'Error', 'Manual']",
      "Throws TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to analyze Promise memory usage in Node.js?",
    "o": [
      "Using process.memoryUsage().promises",
      "Async hooks with init/destroy tracking",
      "Heap snapshots in DevTools",
      "WeakMap for Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in error recovery?",
    "l": "javascript",
    "c": "async function fetchData() {\n  await setup();\n  throw new Error('API_FAILURE');\n}\n\nasync function setup() {\n  await connect();\n}\n\nasync function connect() {\n  await Promise.resolve();\n}\n\nfetchData().catch(err => console.log(err.stack));",
    "o": [
      "Shows full async chain including setup() and connect()",
      "Only shows API_FAILURE at fetchData()",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error recovery?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  try {\n    yield Promise.reject('Error');\n  } catch (e) {\n    yield 'Recovered';\n  }\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n  console.log(await g.next());\n})();",
    "o": [
      "{value: 1}, {value: 'Recovered'}, {done: true}",
      "{value: 1}, then unhandled rejection",
      "{value: 1}, {error: 'Error'}, {done: true}",
      "Throws during iteration"
    ]
  },
  {
    "q": "Which statement about V8's async/await optimization is TRUE?",
    "o": [
      "await of non-Promise values skips microtasks",
      "Async functions are always slower than callbacks",
      "Each await creates exactly one microtask",
      "Optimizations don't work with try/catch"
    ]
  },
  {
    "q": "What is the output of this Promise memoization pattern?",
    "l": "javascript",
    "c": "function memoize(fn) {\n  let cache;\n  return () => cache || (cache = fn());\n}\n\nconst getData = memoize(async () => {\n  console.log('Fetching');\n  return 'Data';\n});\n\ngetData().then(console.log);\ngetData().then(console.log);",
    "o": [
      "Fetching once then Data twice",
      "Fetching twice then Data twice",
      "Data, Fetching, Data",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's AsyncResource class?",
    "l": "javascript",
    "c": "const { AsyncResource } = require('async_hooks');\n\nconst resource = new AsyncResource('DBQuery');\nresource.runInAsyncScope(async () => {\n  await Promise.resolve();\n  console.log(AsyncResource.currentId());\n});",
    "o": [
      "Maintains context across async operations",
      "Loses context after await",
      "Throws 'AsyncResource not defined'",
      "Output is non-deterministic"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators for monitoring?",
    "o": [
      "Promise.allSettled() for tracking completion states",
      "Promise.race() to merge API responses",
      "Promise.any() for sequential processing",
      "Promise.all() to implement retries"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection with multiple handlers?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\np.catch(() => {});\n\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "No output (properly handled)",
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only"
    ]
  },
  {
    "q": "What does this code show about AbortController propagation in chains?",
    "l": "javascript",
    "c": "const controller = new AbortController();\n\nfetch(url1, { signal: controller.signal })\n  .then(() => fetch(url2, { signal: controller.signal }))\n  .catch(e => console.log(e.name));\n\ncontroller.abort();",
    "o": [
      "Logs 'AbortError' (both fetches aborted)",
      "Only first fetch is aborted",
      "Neither fetch is aborted",
      "Throws 'AbortError' synchronously"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of async generators over callbacks?",
    "o": [
      "Lower memory usage for all use cases",
      "Cleaner iteration with for-await-of",
      "Built-in error handling in loops",
      "Natural backpressure implementation"
    ]
  },
  {
    "q": "What is the output of this Promise chain with nested error handling?",
    "l": "javascript",
    "c": "Promise.resolve()\n  .then(() => { throw 'Error1'; })\n  .catch(e => { console.log(e); throw 'Error2'; })\n  .catch(e => console.log(e))\n  .then(() => { throw 'Error3'; }, e => console.log(e));",
    "o": [
      "Error1 followed by Error2 followed by Error3",
      "Error1 followed by Error2",
      "Error1 followed by Error3",
      "Error2 followed by Error3"
    ]
  },
  {
    "q": "Which of these is the most efficient way to implement a retry mechanism for failed API calls?",
    "o": [
      "Exponential backoff with async/await",
      "Simple for-loop with retry count",
      "Recursive Promise chain",
      "Using setInterval for retries"
    ]
  },
  {
    "q": "What does this code reveal about microtask queue behavior?",
    "l": "javascript",
    "c": "let count = 0;\nfunction loop() {\n  Promise.resolve().then(() => {\n    count++;\n    if (count < 3) loop();\n    console.log(count);\n  });\n}\nloop();\nsetTimeout(() => console.log('Timeout'), 0);",
    "o": [
      "1, 2, 3, then Timeout",
      "Timeout, then 1, 2, 3",
      "3, 2, 1, then Timeout",
      "Infinite loop"
    ]
  },
  {
    "q": "What is the key difference between these two async function declarations?",
    "l": "javascript",
    "c": "async function foo() { await Promise.resolve(); }\nconst bar = async function() { await Promise.resolve(); };",
    "o": [
      "Only foo is hoisted",
      "bar is faster to execute",
      "foo cannot be used as a constructor",
      "No practical difference"
    ]
  },
  {
    "q": "What is the output of this Promise.race() edge case with a never-settling Promise?",
    "l": "javascript",
    "c": "const p1 = new Promise(() => {});\nconst p2 = new Promise(resolve => setTimeout(resolve, 100, 'Result'));\nPromise.race([p1, p2]).then(console.log);",
    "o": [
      "Result (after 100ms)",
      "Never resolves",
      "undefined",
      "TypeError"
    ]
  },
  {
    "q": "Which of these is NOT a valid way to prevent memory leaks with Promises?",
    "o": [
      "Using weak references for Promise storage",
      "Cleaning up event listeners in finally()",
      "Using AbortController for cancellation",
      "Avoiding circular Promise references"
    ]
  },
  {
    "q": "What does this code demonstrate about async stack traces in Node.js?",
    "l": "javascript",
    "c": "async function a() { await b(); }\nasync function b() { await c(); }\nasync function c() { throw new Error('Trace'); }\n\na().catch(err => console.log(err.stack));",
    "o": [
      "Includes full async call chain (a → b → c)",
      "Only shows error from function c",
      "Stack trace is empty",
      "Process crashes"
    ]
  },
  {
    "q": "What is the output of this async generator with error handling?",
    "l": "javascript",
    "c": "async function* gen() {\n  yield 1;\n  throw 'Error';\n}\n\n(async () => {\n  const g = gen();\n  console.log(await g.next());\n  console.log(await g.next());\n})().catch(e => console.log(e));",
    "o": [
      "{value: 1, done: false} followed by 'Error'",
      "{value: 1, done: false}, {value: undefined, done: true}",
      "'Error' only",
      "Unhandled promise rejection"
    ]
  },
  {
    "q": "Which statement about V8's Promise optimization is TRUE?",
    "o": [
      "Simple await expressions may not create microtasks",
      "Async functions are always slower than Promises",
      "Promise chains cannot be optimized",
      "await always adds significant overhead"
    ]
  },
  {
    "q": "What is the output of this shared Promise optimization pattern?",
    "l": "javascript",
    "c": "const shared = Promise.resolve('Value');\n\nasync function a() { console.log(await shared); }\nasync function b() { console.log(await shared); }\n\na(); b();",
    "o": [
      "Value, Value (reuses same Promise)",
      "Value (only once)",
      "undefined, undefined",
      "Race condition"
    ]
  },
  {
    "q": "What does this reveal about Node.js's async_hooks?",
    "l": "javascript",
    "c": "const asyncHook = require('async_hooks').createHook({\n  init(asyncId) { /* track async ops */ }\n});\n\nasyncHook.enable();\n\nasync function example() {\n  await Promise.resolve();\n}\n\nexample();",
    "o": [
      "Can track Promise lifecycle events",
      "Slows down Promise execution significantly",
      "Only works for callbacks, not Promises",
      "Prevents Promise optimization"
    ]
  },
  {
    "q": "Which of these is a valid use of Promise combinators?",
    "o": [
      "Promise.allSettled() for analytics logging",
      "Promise.race() for merging multiple results",
      "Promise.any() for sequential operations",
      "Promise.all() for fallback behavior"
    ]
  },
  {
    "q": "What is the output of this unhandled rejection lifecycle example?",
    "l": "javascript",
    "c": "const p = Promise.reject('Error');\nsetTimeout(() => p.catch(() => {}), 100);\nprocess.on('unhandledRejection', () => console.log('UNHANDLED'));\nprocess.on('rejectionHandled', () => console.log('HANDLED'));",
    "o": [
      "UNHANDLED followed by HANDLED",
      "HANDLED only",
      "UNHANDLED only",
      "No output"
    ]
  },
  {
    "q": "What does this code show about AbortController composition?",
    "l": "javascript",
    "c": "const parent = new AbortController();\nconst child = new AbortController();\n\nparent.signal.addEventListener('abort', () => child.abort());\n\nfetch(url, { signal: child.signal })\n  .catch(e => console.log(e.name));\n\nparent.abort();",
    "o": [
      "Logs 'AbortError' (both controllers abort)",
      "Only parent triggers abort",
      "Neither controller affects the fetch",
      "Throws 'Duplicate Abort' error"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of async iterators over Promise.all?",
    "o": [
      "Better performance for fixed-size arrays",
      "Lazy evaluation of items",
      "Natural backpressure handling",
      "Memory efficiency for large datasets"
    ]
  }
]