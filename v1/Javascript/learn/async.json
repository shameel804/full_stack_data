{
    "id": "learn_js_async",
    "topicId": "async",
    "topicTitle": "Asynchronous JavaScript",
    "description": "Master handling operations that take time: Callbacks, Promises, and the modern Async/Await syntax.",
    "baseKP": 100,
    "slides": [
        {
            "id": "js_async_1",
            "type": "content",
            "title": "Synchronous vs Asynchronous",
            "content": "# Sync vs Async â±ï¸\n\n**Synchronous:** Code executes line by line. One line waits for the previous line to finish.\n\n**Asynchronous:** Code executes without waiting. Long running tasks (like fetching data) run in the background while the rest of the code continues.\n\n```javascript\nconsole.log(\"1\");\nsetTimeout(() => console.log(\"2\"), 1000);\nconsole.log(\"3\");\n// Output: 1, 3, 2\n```"
        },
        {
            "id": "js_async_2",
            "type": "content",
            "title": "Callbacks",
            "content": "# The Callback Hell ðŸ”¥\n\nIn the past, async was handled by passing functions (callbacks).\n\n```javascript\ngetData(function(a) {\n  getMoreData(a, function(b) {\n    getMoreData(b, function(c) {\n      console.log(c);\n    });\n  });\n});\n```\nThis nesting is difficult to read and debug. Known as \"Callback Hell\"."
        },
        {
            "id": "js_async_3",
            "type": "content",
            "title": "Promises",
            "content": "# Promises to the Rescue ðŸ¤\n\nA Promise is an object that commits to returning a value later (either resolved or rejected).\n\nStates:\n- **Pending:** Initial state.\n- **Fulfilled:** Operation successful.\n- **Rejected:** Operation failed.\n\n```javascript\nmyPromise\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n```"
        },
        {
            "id": "js_async_4",
            "type": "content",
            "title": "Creating a Promise",
            "content": "# Making Promises ðŸ¤ž\n\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  const success = true;\n  \n  if (success) {\n    resolve(\"Operation successful!\");\n  } else {\n    reject(\"Operation failed.\");\n  }\n});\n```"
        },
        {
            "id": "js_async_quiz_1",
            "type": "quiz",
            "title": "Promise State Quiz",
            "content": "Check states.",
            "quizQuestion": "Which state does a Promise start in?",
            "quizOptions": [
                "Fulfilled",
                "Rejected",
                "Pending",
                "Waiting"
            ],
            "correctOptionIndex": 2
        },
        {
            "id": "js_async_5",
            "type": "content",
            "title": "Async/Await",
            "content": "# Async / Await â³\n\nIntroduced in ES2017 to make async code look synchronous.\n\n- `async`: Makes a function return a Promise.\n- `await`: Makes the function pause and wait for a Promise.\n\n```javascript\nasync function fetchData() {\n  let response = await fetch(\"url\");\n  let data = await response.json();\n  console.log(data);\n}\n```"
        },
        {
            "id": "js_async_6",
            "type": "content",
            "title": "Error Handling in Async",
            "content": "# Try / Catch ðŸ›¡ï¸\n\nWith `async/await`, we use `try...catch` blocks to handle errors (rejections).\n\n```javascript\nasync function getData() {\n  try {\n    let response = await fetch(\"wrong-url\");\n  } catch (error) {\n    console.error(\"Something went wrong:\", error);\n  }\n}\n```"
        },
        {
            "id": "js_async_7",
            "type": "content",
            "title": "Fetch API",
            "content": "# The Fetch API ðŸ¶\n\nThe modern way to make network requests (AJAX).\n\nIt returns a Promise.\n\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));\n```"
        },
        {
            "id": "js_async_8",
            "type": "content",
            "title": "Promise.all",
            "content": "# Promise.all ðŸ¤²\n\nRun multiple promises in parallel and wait for ALL to finish.\n\n```javascript\nconst p1 = fetch('/users');\nconst p2 = fetch('/posts');\n\nPromise.all([p1, p2])\n  .then(responses => {\n     // responses[0] is from /users\n     // responses[1] is from /posts\n     console.log(\"All data loaded\");\n  });\n```"
        },
        {
            "id": "js_async_quiz_2",
            "type": "quiz",
            "title": "Syntax Quiz",
            "content": "Keyword check.",
            "quizQuestion": "Which keyword pauses the execution of an async function until a Promise is resolved?",
            "quizOptions": [
                "pause",
                "wait",
                "stop",
                "await"
            ],
            "correctOptionIndex": 3
        },
        {
            "id": "js_async_9",
            "type": "content",
            "title": "Event Loop",
            "content": "# The Event Loop ðŸŽ¢\n\nJavascript is single-threaded.\n\nThe **Event Loop** is responsible for executing the code, collecting and processing events, and executing queued sub-tasks.\n\n1.  **Call Stack:** Where synchronous code runs.\n2.  **Web APIs:** Where async tasks (setTimeout, fetch) wait.\n3.  **Queue:** Where callbacks wait to be moved to the Call Stack."
        },
        {
            "id": "js_async_10",
            "type": "content",
            "title": "Code Example",
            "content": "# Fetching Data ðŸ’»\n\n<!-- FULL_CODE_START\nasync function getUser(username) {\n  console.log(\"Fetching user... â³\");\n  \n  // Simulate network delay\n  await new Promise(r => setTimeout(r, 1000));\n  \n  return { name: username, role: \"Admin\" };\n}\n\n// Main execution\n(async () => {\n  try {\n    const user = await getUser(\"Alice\");\n    console.log(`User loaded: ${user.name}`);\n  } catch (err) {\n    console.log(\"Error loading user\");\n  }\n})();\nFULL_CODE_END -->"
        },
        {
            "id": "js_async_11",
            "type": "content",
            "title": "Summary",
            "content": "# Recap: Async JS ðŸŽ“\n\nHandling usage of time.\n\n- **Callback:** Old school, prone to nesting hell.\n- **Promise:** Object for future value (`.then`, `.catch`).\n- **Async/Await:** Syntactic sugar for Promises, readable code.\n- **Fetch:** Modern HTTP requests.\n\n## Next Steps\nLearn how to gracefully handle mistakes with **Error Handling**!"
        }
    ]
}