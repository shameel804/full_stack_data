[
    {
        "q": "What is the purpose of Vue.js's reactivity system?",
        "o": [
            "To automatically update the DOM when data changes",
            "To compile templates into static HTML",
            "To handle HTTP requests",
            "To manage component styling"
        ]
    },
    {
        "q": "Which property is used to declare reactive data in a Vue component?",
        "o": [
            "data",
            "props",
            "methods",
            "computed"
        ]
    },
    {
        "q": "What is the output of the following code when the button is clicked?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    count: 0\n  },\n  methods: {\n    increment() {\n      this.count++;\n    }\n  }\n})",
        "o": [
            "The count variable increases by 1 and the DOM updates",
            "The count variable remains unchanged",
            "An error occurs",
            "The DOM updates without changing the count"
        ]
    },
    {
        "q": "What is a watcher in Vue.js used for?",
        "o": [
            "To observe changes to a reactive property and perform actions",
            "To define computed properties",
            "To create new components",
            "To manage routing in Vue applications"
        ]
    },
    {
        "q": "What is the difference between computed properties and methods in Vue.js?",
        "o": [
            "Computed properties are cached based on their dependencies, while methods are not",
            "Methods are cached, while computed properties are not",
            "Computed properties cannot return values, while methods can",
            "There is no difference between them"
        ]
    },
    {
        "q": "What will happen when the following code runs and 'message' is updated?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello'\n  },\n  watch: {\n    message(newVal, oldVal) {\n      console.log(`New: ${newVal}, Old: ${oldVal}`);\n    }\n  }\n})",
        "o": [
            "The watcher logs the new and old values of 'message'",
            "The watcher only logs the new value",
            "The watcher throws an error",
            "Nothing is logged"
        ]
    },
    {
        "q": "Which of the following is a reactivity caveat in Vue.js?",
        "o": [
            "Adding a new property to an object does not trigger reactivity",
            "Computed properties cannot depend on reactive data",
            "Watchers cannot observe nested properties",
            "Reactive data cannot be used in templates"
        ]
    },
    {
        "q": "How can you make a new property reactive in an existing Vue.js object?",
        "o": [
            "Use Vue.set(object, propertyName, value)",
            "Assign the property directly with object[propertyName] = value",
            "Use this.$addProperty(propertyName, value)",
            "Restart the Vue instance"
        ]
    },
    {
        "q": "What is the output of the following code when 'price' or 'quantity' changes?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    price: 10,\n    quantity: 2\n  },\n  computed: {\n    total() {\n      return this.price * this.quantity;\n    }\n  }\n})",
        "o": [
            "The 'total' computed property updates automatically",
            "The 'total' computed property does not update",
            "An error occurs due to invalid computation",
            "The 'total' property remains undefined"
        ]
    },
    {
        "q": "What happens when you try to delete a reactive property in Vue.js?",
        "o": [
            "You must use Vue.delete to ensure reactivity",
            "Using the delete operator automatically triggers reactivity",
            "Deleting a reactive property is not allowed",
            "The property is deleted but the DOM does not update"
        ]
    },
    {
        "q": "What is the role of the 'deep' option in a Vue.js watcher?",
        "o": [
            "To watch for changes in nested properties of an object",
            "To prevent any changes to the watched property",
            "To cache the watcher's results",
            "To limit the watcher to top-level properties"
        ]
    },
    {
        "q": "What is the output of the following code when 'items' is modified?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    items: [1, 2, 3]\n  }\n})",
        "o": [
            "Changing an array element with items[0] = 4 is reactive",
            "Changing an array element with items[0] = 4 is not reactive",
            "The array cannot be modified",
            "An error occurs when modifying the array"
        ]
    },
    {
        "q": "Which method can be used to make an array mutation reactive in Vue.js?",
        "o": [
            "Vue.set or array methods like push()",
            "Directly assigning a new array",
            "Using array.splice() without Vue.set",
            "None of the options"
        ]
    },
    {
        "q": "What does Vue.js use to track dependencies in its reactivity system?",
        "o": [
            "Object.defineProperty or Proxy",
            "Event listeners",
            "DOM mutations",
            "Manual tracking functions"
        ]
    },
    {
        "q": "How does Vue.js ensure a property is reactive when declared in the data option?",
        "o": [
            "By wrapping it in a reactive Proxy or getter/setter",
            "By storing it in a global state",
            "By compiling it into a static value",
            "By binding it to the DOM directly"
        ]
    },
    {
        "q": "What happens when you update a reactive property in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    user: { name: 'Alice' }\n  },\n  watch: {\n    'user.name': function(newVal) {\n      console.log('Name changed to: ' + newVal);\n    }\n  }\n})",
        "o": [
            "The watcher logs the new name value",
            "The watcher does not trigger",
            "An error occurs due to invalid syntax",
            "The DOM updates but nothing is logged"
        ]
    },
    {
        "q": "Why are computed properties preferred over methods for derived data in Vue.js?",
        "o": [
            "They are cached and only recompute when dependencies change",
            "They execute faster than methods",
            "They can modify reactive data directly",
            "They are easier to write than methods"
        ]
    },
    {
        "q": "What is a common reactivity caveat when working with arrays in Vue.js?",
        "o": [
            "Directly setting an array index does not trigger reactivity",
            "Array methods like push() are not reactive",
            "Arrays cannot be reactive in Vue.js",
            "All array changes are automatically reactive"
        ]
    },
    {
        "q": "What is the output when 'score' is updated in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    score: 0\n  },\n  computed: {\n    grade() {\n      return this.score >= 60 ? 'Pass' : 'Fail';\n    }\n  }\n})",
        "o": [
            "The 'grade' computed property updates based on the new score",
            "The 'grade' computed property remains unchanged",
            "An error occurs due to invalid logic",
            "The 'score' cannot be updated"
        ]
    },
    {
        "q": "How can you make a dynamically added object property reactive in Vue.js?",
        "o": [
            "Use this.$set(object, key, value)",
            "Assign it directly with object[key] = value",
            "Use Vue.addProperty(object, key, value)",
            "Restart the Vue instance"
        ]
    },
    {
        "q": "What is the purpose of the 'immediate' option in a Vue.js watcher?",
        "o": [
            "To run the watcher immediately upon setup",
            "To delay the watcher until the next tick",
            "To disable the watcher by default",
            "To make the watcher run only once"
        ]
    },
    {
        "q": "What happens when you try to push a new item to a reactive array in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    fruits: ['apple', 'banana']\n  }\n})",
        "o": [
            "The DOM updates automatically after pushing the item",
            "The push operation is not reactive",
            "An error occurs when pushing to the array",
            "The array resets to its initial state"
        ]
    },
    {
        "q": "Why might a computed property not update as expected in Vue.js?",
        "o": [
            "Its dependencies are not reactive",
            "It contains asynchronous code",
            "It is defined in the methods option",
            "It always updates regardless of dependencies"
        ]
    },
    {
        "q": "What is the output when 'user.age' is updated in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    user: { age: 25 }\n  },\n  watch: {\n    user: {\n      handler(newVal) {\n        console.log('Age: ' + newVal.age);\n      },\n      deep: true\n    }\n  }\n})",
        "o": [
            "The watcher logs the new age value",
            "The watcher does not detect the change",
            "An error occurs due to deep watching",
            "The console logs the entire user object"
        ]
    },
    {
        "q": "Which Vue.js method ensures reactivity when removing a property from an object?",
        "o": [
            "Vue.delete(object, key)",
            "delete object[key]",
            "Vue.remove(object, key)",
            "None of the options"
        ]
    },
    {
        "q": "What happens if you assign a new array to a reactive data property in Vue.js?",
        "o": [
            "The new array becomes reactive automatically",
            "The new array is not reactive unless wrapped with Vue.set",
            "An error occurs due to invalid assignment",
            "The DOM does not update"
        ]
    },
    {
        "q": "What is the core mechanism Vue.js uses to make data reactive in modern versions?",
        "o": [
            "ES6 Proxy",
            "Object.defineProperty",
            "Event emitters",
            "Custom setters"
        ]
    },
    {
        "q": "What happens if you add a new property to a reactive object without using Vue.set?",
        "o": [
            "The new property is not reactive",
            "The property triggers reactivity automatically",
            "The Vue instance throws an error",
            "The DOM updates but the property is ignored"
        ]
    },
    {
        "q": "What is logged when 'counter' is incremented in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    counter: 0\n  },\n  watch: {\n    counter(newVal, oldVal) {\n      console.log(`Counter changed from ${oldVal} to ${newVal}`);\n    }\n  },\n  methods: {\n    increment() {\n      this.counter++;\n    }\n  }\n})",
        "o": [
            "The old and new values of counter are logged",
            "Only the new value is logged",
            "Nothing is logged",
            "An error occurs due to invalid watcher"
        ]
    },
    {
        "q": "How does a computed property differ from a watcher in Vue.js?",
        "o": [
            "Computed properties return cached values, watchers execute side effects",
            "Watchers return values, computed properties execute side effects",
            "Computed properties are not reactive, watchers are",
            "There is no functional difference"
        ]
    },
    {
        "q": "What is a limitation of Vue.js reactivity when modifying arrays?",
        "o": [
            "Directly setting an index like arr[0] = value is not reactive",
            "Array methods like push() are not reactive",
            "Arrays cannot be made reactive",
            "All array operations are fully reactive"
        ]
    },
    {
        "q": "What is the output when 'items' length is changed in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    items: [1, 2, 3]\n  },\n  computed: {\n    itemCount() {\n      return this.items.length;\n    }\n  }\n})",
        "o": [
            "The 'itemCount' computed property updates automatically",
            "The 'itemCount' computed property does not update",
            "An error occurs due to invalid array access",
            "The DOM does not reflect the change"
        ]
    },
    {
        "q": "Which method ensures a new array element is reactive in Vue.js?",
        "o": [
            "this.$set(array, index, value)",
            "array[index] = value",
            "Vue.add(array, index, value)",
            "array.push(value) with a delay"
        ]
    },
    {
        "q": "What is the effect of setting 'deep: true' in a Vue.js watcher?",
        "o": [
            "It monitors changes in nested object properties",
            "It prevents nested properties from being reactive",
            "It caches the watcher's results",
            "It limits the watcher to immediate changes only"
        ]
    },
    {
        "q": "What happens when you modify 'dataObj' in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    dataObj: {}\n  },\n  methods: {\n    addProperty() {\n      this.dataObj.newKey = 'value';\n    }\n  }\n})",
        "o": [
            "The new property 'newKey' is not reactive",
            "The new property 'newKey' is reactive",
            "An error occurs when adding the property",
            "The DOM updates without reactivity"
        ]
    },
    {
        "q": "Why might a computed property cause performance issues in Vue.js?",
        "o": [
            "It performs complex calculations without caching",
            "It always runs asynchronously",
            "It cannot depend on reactive data",
            "It is not cached like methods"
        ]
    },
    {
        "q": "What is logged when 'settings.theme' is changed in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    settings: { theme: 'light' }\n  },\n  watch: {\n    'settings.theme': {\n      handler(newVal) {\n        console.log('Theme set to: ' + newVal);\n      }\n    }\n  }\n})",
        "o": [
            "The new theme value is logged",
            "The entire settings object is logged",
            "Nothing is logged due to shallow watching",
            "An error occurs due to invalid syntax"
        ]
    },
    {
        "q": "Which Vue.js method is used to remove a property reactively from an object?",
        "o": [
            "this.$delete(object, key)",
            "delete object[key]",
            "Vue.removeProperty(object, key)",
            "object[key] = null"
        ]
    },
    {
        "q": "What happens when you replace a reactive array with a new array in Vue.js?",
        "o": [
            "The new array is reactive if assigned directly",
            "The new array is not reactive unless set with Vue.set",
            "The Vue instance crashes",
            "The array cannot be replaced"
        ]
    },
    {
        "q": "In Vue.js, what makes a data property reactive?",
        "o": [
            "Declaring it in the data() function or option",
            "Using it in a computed property",
            "Assigning it in a method",
            "Defining it outside the Vue instance"
        ]
    },
    {
        "q": "What is the primary benefit of using computed properties over watchers?",
        "o": [
            "Computed properties can produce a value based on reactive data",
            "Watchers are better for caching values",
            "Computed properties execute side effects",
            "There is no benefit; they are identical"
        ]
    },
    {
        "q": "What occurs when 'text' is changed in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    text: 'Hello World'\n  },\n  computed: {\n    reversedText() {\n      return this.text.split('').reverse().join('');\n    }\n  }\n})",
        "o": [
            "The 'reversedText' updates automatically",
            "The 'reversedText' stays the same",
            "An error is thrown due to invalid split",
            "The DOM does not update"
        ]
    },
    {
        "q": "What is a watcher typically used for in Vue.js?",
        "o": [
            "Performing actions in response to data changes",
            "Defining reusable functions",
            "Creating virtual DOM elements",
            "Handling user inputs directly"
        ]
    },
    {
        "q": "How does Vue.js handle reactivity for nested objects?",
        "o": [
            "It recursively makes nested properties reactive",
            "Nested objects are not reactive by default",
            "You must manually set them with Vue.set",
            "Only top-level properties are reactive"
        ]
    },
    {
        "q": "What is the result when 'list' is updated with push() in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    list: []\n  },\n  methods: {\n    addItem(item) {\n      this.list.push(item);\n    }\n  }\n})",
        "o": [
            "The DOM updates to reflect the new item",
            "The push does not trigger a DOM update",
            "An error occurs on push",
            "The list resets"
        ]
    },
    {
        "q": "What is a key difference between computed properties and methods?",
        "o": [
            "Computed properties are cached, methods run every time",
            "Methods are cached, computed properties are not",
            "Computed properties cannot be called like functions",
            "Methods cannot depend on reactive data"
        ]
    },
    {
        "q": "What is a common caveat with reactivity in Vue.js objects?",
        "o": [
            "Dynamically added properties are not reactive unless using Vue.set",
            "All properties are always reactive",
            "Objects cannot be reactive",
            "Reactivity only works for primitive types"
        ]
    },
    {
        "q": "How can you force a watcher to run immediately in Vue.js?",
        "o": [
            "Set the 'immediate: true' option",
            "Call the watcher manually",
            "Use a computed property instead",
            "Set 'deep: true'"
        ]
    },
    {
        "q": "What happens when you set 'obj.prop = value' in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    obj: {}\n  }\n})",
        "o": [
            "The 'prop' is not reactive",
            "The 'prop' is reactive automatically",
            "An error is thrown",
            "The Vue instance updates the DOM"
        ]
    },
    {
        "q": "Why use watchers over computed properties for certain tasks?",
        "o": [
            "Watchers can perform asynchronous operations or side effects",
            "Computed properties cannot handle side effects",
            "Watchers are cached like computed properties",
            "There is no reason; use computed always"
        ]
    },
    {
        "q": "What is the output when 'config' nested property changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    config: { option: false }\n  },\n  watch: {\n    config: {\n      deep: true,\n      handler() {\n        console.log('Config changed');\n      }\n    }\n  }\n})",
        "o": [
            "'Config changed' is logged",
            "Nothing is logged without deep",
            "An error due to handler",
            "The watcher ignores nested changes"
        ]
    },
    {
        "q": "Which method makes deleting an array element reactive in Vue.js?",
        "o": [
            "Use splice() or Vue.delete",
            "Use delete array[index]",
            "Assign array[index] = undefined",
            "None of the options"
        ]
    },
    {
        "q": "What Vue.js feature allows data to automatically trigger UI updates?",
        "o": [
            "Reactive data",
            "Static data",
            "Computed methods",
            "Event handlers"
        ]
    },
    {
        "q": "How are watchers defined in a Vue.js component?",
        "o": [
            "In the watch object with property names as keys",
            "In the methods object",
            "In the computed object",
            "In the data function"
        ]
    },
    {
        "q": "What is the behavior when 'value' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    value: 5\n  },\n  watch: {\n    value: function(newVal) {\n      console.log('Value is now: ' + newVal);\n    }\n  }\n})",
        "o": [
            "The watcher logs the new value",
            "The watcher logs the old value",
            "No log occurs",
            "An error is thrown"
        ]
    },
    {
        "q": "When should you use a computed property instead of a method?",
        "o": [
            "When the result should be cached based on dependencies",
            "When you need to perform side effects",
            "When handling user events",
            "When defining reactive data"
        ]
    },
    {
        "q": "What is a reactivity caveat related to object properties in Vue.js?",
        "o": [
            "Properties added after initialization are not reactive",
            "All properties are always reactive",
            "Objects cannot have reactive properties",
            "Reactivity only applies to arrays"
        ]
    },
    {
        "q": "What happens when 'numbers' is modified with splice in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    numbers: [10, 20, 30]\n  },\n  methods: {\n    removeFirst() {\n      this.numbers.splice(0, 1);\n    }\n  }\n})",
        "o": [
            "The array updates reactively and DOM reflects the change",
            "The splice does not trigger reactivity",
            "An error occurs on splice",
            "The array remains unchanged"
        ]
    },
    {
        "q": "What advantage do computed properties have over watchers?",
        "o": [
            "They can be used in templates like data properties",
            "They always run asynchronously",
            "They modify data directly",
            "They are not dependency-based"
        ]
    },
    {
        "q": "How can you observe deep changes in an object with a watcher?",
        "o": [
            "By setting the deep: true option",
            "By using immediate: true",
            "By nesting watchers",
            "By converting to a computed property"
        ]
    },
    {
        "q": "What is the result of adding a property without $set in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    person: { name: 'Bob' }\n  },\n  methods: {\n    addAge() {\n      this.person.age = 30;\n    }\n  }\n})",
        "o": [
            "The 'age' property is not reactive",
            "The 'age' property is reactive",
            "The method throws an error",
            "The person object resets"
        ]
    },
    {
        "q": "Why are methods not cached like computed properties in Vue.js?",
        "o": [
            "Methods are invoked each time they are called",
            "Computed properties run more frequently",
            "Methods depend on external state",
            "There is no caching in Vue.js"
        ]
    },
    {
        "q": "What is the purpose of Vue.set in handling reactivity?",
        "o": [
            "To add reactive properties to objects or arrays",
            "To remove properties reactively",
            "To define new watchers",
            "To create computed properties"
        ]
    },
    {
        "q": "What occurs when 'info' changes deeply in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    info: { detail: 'initial' }\n  },\n  watch: {\n    info: {\n      handler() {\n        console.log('Info updated');\n      },\n      deep: true\n    }\n  }\n})",
        "o": [
            "'Info updated' is logged on deep changes",
            "Only shallow changes are detected",
            "No log without immediate",
            "Error due to deep option"
        ]
    },
    {
        "q": "Which array methods are mutated to be reactive in Vue.js?",
        "o": [
            "push, pop, shift, unshift, splice, sort, reverse",
            "map, filter, reduce",
            "indexOf, includes, find",
            "All array methods"
        ]
    },
    {
        "q": "What Vue.js option is used to define reactive state?",
        "o": [
            "data",
            "state",
            "reactive",
            "props"
        ]
    },
    {
        "q": "What parameters does a watcher function receive in Vue.js?",
        "o": [
            "newValue and oldValue",
            "only newValue",
            "only oldValue",
            "no parameters"
        ]
    },
    {
        "q": "What is the effect when 'input' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    input: ''\n  },\n  computed: {\n    upperCaseInput() {\n      return this.input.toUpperCase();\n    }\n  }\n})",
        "o": [
            "The 'upperCaseInput' updates to the uppercase version",
            "The 'upperCaseInput' does not change",
            "An error due to toUpperCase",
            "The input resets"
        ]
    },
    {
        "q": "In Vue.js, when are computed properties re-evaluated?",
        "o": [
            "When their reactive dependencies change",
            "Every time the component renders",
            "Only on component mount",
            "When manually triggered"
        ]
    },
    {
        "q": "What is a reactivity caveat for arrays in Vue.js?",
        "o": [
            "Changing length directly does not trigger reactivity",
            "All array changes are reactive",
            "Arrays must be declared empty",
            "Reactivity does not apply to arrays"
        ]
    },
    {
        "q": "What happens when 'tasks' is updated with push in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    tasks: []\n  },\n  methods: {\n    addTask(task) {\n      this.tasks.push(task);\n    }\n  }\n})",
        "o": [
            "The 'tasks' array updates reactively",
            "The push is ignored",
            "An error on push",
            "The array does not update the DOM"
        ]
    },
    {
        "q": "How do methods differ from computed properties in invocation?",
        "o": [
            "Methods run every time called, computed cache results",
            "Computed run every call, methods cache",
            "Both cache equally",
            "Methods cannot be invoked"
        ]
    },
    {
        "q": "What option makes a watcher trigger on initialization?",
        "o": [
            "immediate: true",
            "deep: true",
            "cache: true",
            "sync: true"
        ]
    },
    {
        "q": "What is the outcome of setting a new property directly in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    car: { model: 'Tesla' }\n  },\n  methods: {\n    addYear() {\n      this.car.year = 2023;\n    }\n  }\n})",
        "o": [
            "The 'year' property is not reactive",
            "The 'year' property becomes reactive",
            "The method errors out",
            "The car object is replaced"
        ]
    },
    {
        "q": "Why might you choose a watcher over a computed property?",
        "o": [
            "For performing imperative actions on data change",
            "For caching complex computations",
            "For defining template bindings",
            "For handling props validation"
        ]
    },
    {
        "q": "What is Vue.delete used for in reactivity?",
        "o": [
            "To remove properties or array items reactively",
            "To add new reactive properties",
            "To define new watchers",
            "To compute derived values"
        ]
    },
    {
        "q": "What logs when a nested property changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    profile: { bio: '' }\n  },\n  watch: {\n    profile: {\n      deep: true,\n      handler() {\n        console.log('Profile updated');\n      }\n    }\n  }\n})",
        "o": [
            "'Profile updated' is logged on bio change",
            "No log for nested changes",
            "Error from deep watcher",
            "Logs only on profile replacement"
        ]
    },
    {
        "q": "Which of the following is not a reactive array mutation method in Vue.js?",
        "o": [
            "array.length = newLength",
            "array.push(item)",
            "array.splice(index, 1)",
            "array.pop()"
        ]
    },
    {
        "q": "What is the default behavior of Vue.js when a reactive dependency changes?",
        "o": [
            "It re-renders the affected parts of the DOM",
            "It reloads the entire page",
            "It ignores the change",
            "It throws a warning in the console"
        ]
    },
    {
        "q": "Where can watchers be used in a Vue.js application?",
        "o": [
            "To react to data changes and perform custom logic",
            "To define the initial state",
            "To handle component lifecycle",
            "To manage global state"
        ]
    },
    {
        "q": "What is displayed when 'name' is updated in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    name: 'Vue'\n  },\n  computed: {\n    greeting() {\n      return 'Hello ' + this.name;\n    }\n  }\n})",
        "o": [
            "The 'greeting' updates to include the new name",
            "The 'greeting' remains 'Hello Vue'",
            "An error occurs on update",
            "The DOM does not reflect changes"
        ]
    },
    {
        "q": "What is the caching mechanism for computed properties in Vue.js?",
        "o": [
            "They cache based on reactive dependencies",
            "They cache based on method calls",
            "They do not cache at all",
            "They cache globally across components"
        ]
    },
    {
        "q": "What caveat exists when replacing an entire reactive object in Vue.js?",
        "o": [
            "The new object must be made reactive manually if nested",
            "Replacement always triggers reactivity",
            "Objects cannot be replaced",
            "It causes a memory leak"
        ]
    },
    {
        "q": "What happens when 'colors' is sorted in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    colors: ['red', 'blue', 'green']\n  },\n  methods: {\n    sortColors() {\n      this.colors.sort();\n    }\n  }\n})",
        "o": [
            "The array sorts reactively and updates the DOM",
            "The sort does not trigger reactivity",
            "An error on sort method",
            "The colors array reverses instead"
        ]
    },
    {
        "q": "How can computed properties be made writable in Vue.js?",
        "o": [
            "By defining getter and setter functions",
            "By using a watcher instead",
            "By declaring them in data",
            "Computed properties are always writable"
        ]
    },
    {
        "q": "What does the 'handler' function do in a Vue.js watcher?",
        "o": [
            "It executes when the watched value changes",
            "It defines the initial value",
            "It computes a derived value",
            "It handles errors"
        ]
    },
    {
        "q": "What is the result of changing array length directly in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    items: [1, 2, 3, 4]\n  },\n  methods: {\n    truncate() {\n      this.items.length = 2;\n    }\n  }\n})",
        "o": [
            "The length change is not reactive",
            "The length change is reactive",
            "An error occurs on length assignment",
            "The items array empties"
        ]
    },
    {
        "q": "When might a watcher be more appropriate than a computed property?",
        "o": [
            "When you need to perform an expensive operation only on change",
            "When you need a cached value for templates",
            "When defining methods",
            "When handling props"
        ]
    },
    {
        "q": "What is Vue.observable used for in Vue.js?",
        "o": [
            "To make an object reactive outside of components",
            "To define computed properties globally",
            "To create new Vue instances",
            "To handle asynchronous data"
        ]
    },
    {
        "q": "What logs when 'address.street' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    address: { street: 'Main St' }\n  },\n  watch: {\n    address: {\n      deep: true,\n      handler(newVal) {\n        console.log('Street: ' + newVal.street);\n      }\n    }\n  }\n})",
        "o": [
            "The new street value is logged",
            "No log for street change",
            "Error from handler",
            "Logs the old value"
        ]
    },
    {
        "q": "Which methods are not reactive for arrays in Vue.js?",
        "o": [
            "Direct index assignment and length setting",
            "push and pop",
            "splice and sort",
            "All are reactive"
        ]
    },
    {
        "q": "What is reactive data in Vue.js?",
        "o": [
            "Data that triggers UI updates when changed",
            "Static data that does not change",
            "Data fetched from an API",
            "Data used in methods only"
        ]
    },
    {
        "q": "How do you define a watcher in Vue.js?",
        "o": [
            "By adding a watch property in the component options",
            "By using the data property",
            "By defining it in computed",
            "By creating a method"
        ]
    },
    {
        "q": "What is the result when 'quantity' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    quantity: 1\n  },\n  computed: {\n    doubled() {\n      return this.quantity * 2;\n    }\n  }\n})",
        "o": [
            "The 'doubled' value updates automatically",
            "The 'doubled' value stays the same",
            "An error is thrown",
            "The quantity resets"
        ]
    },
    {
        "q": "What is one main advantage of computed properties over methods?",
        "o": [
            "They are cached and only re-run when needed",
            "They always execute on every render",
            "They can change data properties",
            "They are used for event handling"
        ]
    },
    {
        "q": "What is a reactivity caveat when adding properties to Vue.js objects?",
        "o": [
            "New properties added dynamically are not reactive by default",
            "All new properties are reactive",
            "Properties can only be added at initialization",
            "Objects lose reactivity when properties are added"
        ]
    },
    {
        "q": "What occurs when 'stack' is updated with pop in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    stack: [1, 2, 3]\n  },\n  methods: {\n    removeTop() {\n      this.stack.pop();\n    }\n  }\n})",
        "o": [
            "The array updates reactively",
            "The pop does not affect reactivity",
            "An error on pop",
            "The stack empties completely"
        ]
    },
    {
        "q": "Can computed properties in Vue.js have setters?",
        "o": [
            "Yes, by defining a set function",
            "No, they are read-only",
            "Only if defined in watchers",
            "Only for primitive types"
        ]
    },
    {
        "q": "What does a watcher do when its dependency changes?",
        "o": [
            "It executes its callback function",
            "It updates the DOM directly",
            "It caches the new value",
            "It ignores the change"
        ]
    },
    {
        "q": "What happens if you set array[index] = value in Vue.js?",
        "o": [
            "It may not trigger reactivity without $set",
            "It always triggers reactivity",
            "It throws an error",
            "It removes the index"
        ]
    },
    {
        "q": "When is a method preferred over a computed property in Vue.js?",
        "o": [
            "When you need to run code every time it's called, like on events",
            "When caching is required",
            "When depending on reactive data",
            "When used in templates"
        ]
    },
    {
        "q": "How do you add a reactive property to an object in Vue.js?",
        "o": [
            "Using this.$set(obj, 'key', value)",
            "Directly with obj.key = value",
            "Using Vue.add(obj, 'key', value)",
            "By reassigning the object"
        ]
    },
    {
        "q": "What is logged when 'options' changes deeply in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    options: { flag: true }\n  },\n  watch: {\n    options: {\n      deep: true,\n      handler() {\n        console.log('Options changed');\n      }\n    }\n  }\n})",
        "o": [
            "'Options changed' is logged",
            "No log occurs",
            "Error from watcher",
            "Logs only shallow changes"
        ]
    },
    {
        "q": "What are some reactive mutation methods for arrays in Vue.js?",
        "o": [
            "push, pop, shift, unshift, splice",
            "map, filter, reduce",
            "forEach, some, every",
            "length, indexOf"
        ]
    },
    {
        "q": "What Vue.js API is used to create a reactive object outside a component?",
        "o": [
            "Vue.observable",
            "Vue.reactive",
            "Vue.data",
            "Vue.createReactive"
        ]
    },
    {
        "q": "What happens when a computed property depends on a non-reactive property?",
        "o": [
            "It does not update when the non-reactive property changes",
            "It automatically becomes reactive",
            "It throws an error",
            "It updates but logs a warning"
        ]
    },
    {
        "q": "What is logged when 'config.size' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    config: { size: 10 }\n  },\n  watch: {\n    'config.size': function(newVal, oldVal) {\n      console.log(`Size changed from ${oldVal} to ${newVal}`);\n    }\n  }\n})",
        "o": [
            "The old and new size values are logged",
            "Only the new size is logged",
            "Nothing is logged",
            "An error occurs"
        ]
    },
    {
        "q": "What is the purpose of the 'reactive' function introduced in Vue 3?",
        "o": [
            "To create reactive objects programmatically",
            "To define computed properties",
            "To replace watchers",
            "To handle DOM events"
        ]
    },
    {
        "q": "What is a reactivity limitation when modifying an array's length in Vue.js?",
        "o": [
            "Setting array.length directly is not reactive",
            "All length changes are reactive",
            "Length cannot be modified",
            "Length changes cause errors"
        ]
    },
    {
        "q": "What happens when 'data' is replaced in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    data: { key: 'value' }\n  },\n  methods: {\n    replaceData() {\n      this.data = { newKey: 'newValue' };\n    }\n  }\n})",
        "o": [
            "The new object is reactive automatically",
            "The new object is not reactive",
            "An error occurs on replacement",
            "The DOM does not update"
        ]
    },
    {
        "q": "How can you make a computed property writable in Vue.js?",
        "o": [
            "By defining both get and set functions",
            "By using Vue.set",
            "By declaring it in data",
            "Computed properties cannot be writable"
        ]
    },
    {
        "q": "What is the role of the 'ref' function in Vue 3's reactivity system?",
        "o": [
            "To create a reactive reference for a single value",
            "To define a computed property",
            "To watch an object",
            "To bind to the DOM"
        ]
    },
    {
        "q": "What is the outcome when a new index is set in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    scores: [90, 85]\n  },\n  methods: {\n    addScore() {\n      this.scores[2] = 95;\n    }\n  }\n})",
        "o": [
            "The new score is not reactive",
            "The new score is reactive",
            "An error occurs",
            "The scores array resets"
        ]
    },
    {
        "q": "What is the benefit of using 'reactive' over 'ref' in Vue 3 for complex objects?",
        "o": [
            "It provides deep reactivity for objects",
            "It is faster for single values",
            "It avoids unwrapping in templates",
            "It cannot be used with objects"
        ]
    },
    {
        "q": "What happens when 'settings' is updated in this code with Vue.set?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    settings: {}\n  },\n  methods: {\n    addSetting() {\n      this.$set(this.settings, 'theme', 'dark');\n    }\n  }\n})",
        "o": [
            "The 'theme' property is reactive",
            "The 'theme' property is not reactive",
            "An error occurs with $set",
            "The settings object clears"
        ]
    },
    {
        "q": "What is the effect of using 'toRefs' in Vue 3's reactivity system?",
        "o": [
            "It converts reactive object properties to individual refs",
            "It makes an object non-reactive",
            "It creates computed properties",
            "It watches for changes"
        ]
    },
    {
        "q": "What is a limitation of watchers without the 'deep' option in Vue.js?",
        "o": [
            "They only detect top-level property changes",
            "They cannot detect any changes",
            "They always detect nested changes",
            "They cause performance issues"
        ]
    },
    {
        "q": "What is the purpose of the 'reactive' function in Vue 3's Composition API?",
        "o": [
            "To create a deeply reactive object",
            "To define a single reactive value",
            "To replace computed properties",
            "To handle DOM events"
        ]
    },
    {
        "q": "What happens if you modify a reactive array using a non-mutating method like map()?",
        "o": [
            "The change is not reactive unless assigned with $set",
            "The change is automatically reactive",
            "An error occurs",
            "The array is replaced"
        ]
    },
    {
        "q": "What is logged when 'user.email' is updated in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    user: { email: 'old@example.com' }\n  },\n  watch: {\n    'user.email': function(newVal) {\n      console.log('Email updated to: ' + newVal);\n    }\n  }\n})",
        "o": [
            "The new email value is logged",
            "Nothing is logged",
            "The old email value is logged",
            "An error occurs"
        ]
    },
    {
        "q": "What is the role of 'ref' in Vue 3's reactivity system?",
        "o": [
            "To create a reactive wrapper for a primitive value",
            "To make an object reactive",
            "To define a watcher",
            "To compute derived state"
        ]
    },
    {
        "q": "What is a reactivity caveat when using objects in Vue.js?",
        "o": [
            "Deleting properties with 'delete' is not reactive",
            "All object operations are reactive",
            "Objects cannot be reactive",
            "Nested objects are not reactive"
        ]
    },
    {
        "q": "What happens when 'items' is reversed in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    items: ['a', 'b', 'c']\n  },\n  methods: {\n    reverseItems() {\n      this.items.reverse();\n    }\n  }\n})",
        "o": [
            "The array reverses reactively and updates the DOM",
            "The reverse is not reactive",
            "An error occurs on reverse",
            "The items array clears"
        ]
    },
    {
        "q": "How does 'toRefs' enhance reactivity in Vue 3?",
        "o": [
            "It converts reactive object properties to individual reactive refs",
            "It makes non-reactive objects reactive",
            "It defines computed properties",
            "It creates deep watchers"
        ]
    },
    {
        "q": "What is the effect of using 'shallowRef' instead of 'ref' in Vue 3?",
        "o": [
            "It only makes the top-level value reactive, not nested properties",
            "It makes nested properties reactive",
            "It prevents any reactivity",
            "It behaves the same as ref"
        ]
    },
    {
        "q": "What is the outcome when adding a property in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    profile: { name: 'Alice' }\n  },\n  methods: {\n    addProperty() {\n      this.$set(this.profile, 'age', 25);\n    }\n  }\n})",
        "o": [
            "The 'age' property is added reactively",
            "The 'age' property is not reactive",
            "An error occurs with $set",
            "The profile object resets"
        ]
    },
    {
        "q": "What is the purpose of 'isReactive' in Vue 3?",
        "o": [
            "To check if an object is reactive",
            "To make an object reactive",
            "To define a watcher",
            "To create a computed property"
        ]
    },
    {
        "q": "What happens when 'state.level' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    state: { level: 1 }\n  },\n  watch: {\n    state: {\n      handler(newVal) {\n        console.log('Level is: ' + newVal.level);\n      },\n      deep: true\n    }\n  }\n})",
        "o": [
            "The new level value is logged",
            "No log occurs for nested changes",
            "An error due to deep watch",
            "Only the state object is logged"
        ]
    },
    {
        "q": "What is a benefit of using 'computed' in Vue 3's Composition API?",
        "o": [
            "It creates cached, reactive derived state",
            "It makes all data non-reactive",
            "It replaces watchers entirely",
            "It handles asynchronous operations"
        ]
    },
    {
        "q": "What happens when you assign a new object to a 'ref' in Vue 3?",
        "o": [
            "The new object is reactive if assigned to the ref's value",
            "The new object is not reactive",
            "An error occurs on assignment",
            "The ref becomes undefined"
        ]
    },
    {
        "q": "What is the 'watchEffect' function in Vue 3's Composition API?",
        "o": [
            "It runs a function immediately and re-runs on dependency changes",
            "It defines a computed property",
            "It creates a reactive ref",
            "It handles lifecycle hooks"
        ]
    },
    {
        "q": "What happens if you use 'delete' on a reactive object property without Vue.delete?",
        "o": [
            "The deletion may not trigger reactivity",
            "The deletion always triggers reactivity",
            "An error is thrown",
            "The object becomes non-reactive"
        ]
    },
    {
        "q": "What is logged when 'counter' changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    counter: 0\n  },\n  watch: {\n    counter: {\n      handler(newVal, oldVal) {\n        console.log(`From ${oldVal} to ${newVal}`);\n      },\n      immediate: true\n    }\n  }\n})",
        "o": [
            "The initial values are logged immediately",
            "Nothing is logged initially",
            "An error due to immediate",
            "Only changes are logged"
        ]
    },
    {
        "q": "What is the difference between 'ref' and 'reactive' in Vue 3?",
        "o": [
            "ref is for primitives, reactive for objects",
            "reactive is for primitives, ref for objects",
            "Both are identical",
            "ref is not reactive"
        ]
    },
    {
        "q": "What is a caveat with reactivity in Vue.js when using frozen objects?",
        "o": [
            "Frozen objects cannot be made reactive",
            "Frozen objects are fully reactive",
            "Reactivity ignores frozen states",
            "It causes infinite loops"
        ]
    },
    {
        "q": "What occurs when 'list' is updated with shift in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    list: [1, 2, 3]\n  },\n  methods: {\n    removeFirst() {\n      this.list.shift();\n    }\n  }\n})",
        "o": [
            "The first item is removed reactively",
            "The shift is not reactive",
            "An error on shift",
            "The list reverses"
        ]
    },
    {
        "q": "How do you access the value of a 'ref' in Vue 3?",
        "o": [
            "Using the .value property",
            "Directly without .value",
            "Using get() method",
            "Using unwrap()"
        ]
    },
    {
        "q": "What is the purpose of 'shallowReactive' in Vue 3?",
        "o": [
            "To create an object with only top-level reactivity",
            "To make deep nested reactivity",
            "To prevent reactivity",
            "To compute values"
        ]
    },
    {
        "q": "What happens when adding an item beyond current length in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    arr: [0, 1]\n  },\n  methods: {\n    extend() {\n      this.arr[2] = 2;\n    }\n  }\n})",
        "o": [
            "The new item is not reactive",
            "The new item is reactive",
            "An error occurs",
            "The array shortens"
        ]
    },
    {
        "q": "What is 'isRef' used for in Vue 3?",
        "o": [
            "To check if a value is a ref",
            "To make a ref",
            "To unwrap a ref",
            "To define reactive objects"
        ]
    },
    {
        "q": "What is the output when 'params' nested value changes in this code?",
        "c": "new Vue({\n  el: '#app',\n  data: {\n    params: { id: 1 }\n  },\n  watch: {\n    params: {\n      deep: true,\n      handler() {\n        console.log('Params updated');\n      }\n    }\n  }\n})",
        "o": [
            "'Params updated' is logged",
            "No log for nested update",
            "Error from deep",
            "Logs only on params replacement"
        ]
    },
    {
        "q": "What is the benefit of 'readonly' in Vue 3's reactivity?",
        "o": [
            "It creates a read-only reactive proxy",
            "It makes everything mutable",
            "It disables reactivity",
            "It computes derived state"
        ]
    },
    {
        "q": "What happens when replacing a ref's value with a new array in Vue 3?",
        "o": [
            "The new array is reactive",
            "The new array is not reactive",
            "An error on replacement",
            "The ref becomes null"
        ]
    },
    {
        "q": "What does the 'unref' function do in Vue 3?",
        "o": [
            "It returns the inner value if it's a ref, otherwise the argument itself",
            "It makes a value reactive",
            "It creates a shallow ref",
            "It defines a computed property"
        ]
    },
    {
        "q": "What is the main difference between 'watch' and 'watchEffect' in Vue 3?",
        "o": [
            "watch requires specifying dependencies, watchEffect runs immediately and tracks automatically",
            "watchEffect requires dependencies, watch runs immediately",
            "Both are identical in function",
            "watch is for refs, watchEffect for reactive"
        ]
    },
    {
        "q": "What is returned when 'count' changes in this code?",
        "c": "import { ref, computed } from 'vue';\nconst count = ref(0);\nconst doubled = computed(() => count.value * 2);",
        "o": [
            "The 'doubled' computed updates automatically",
            "The 'doubled' does not update",
            "An error due to ref access",
            "The count resets"
        ]
    },
    {
        "q": "What is a reactivity caveat with refs in Vue 3 templates?",
        "o": [
            "Refs are automatically unwrapped in templates, no need for .value",
            "You must always use .value in templates",
            "Refs cannot be used in templates",
            "Templates make refs non-reactive"
        ]
    },
    {
        "q": "What happens when assigning to a ref without .value in Vue 3?",
        "o": [
            "It replaces the ref object itself, breaking reactivity",
            "It updates the value correctly",
            "It throws an error",
            "It creates a new ref"
        ]
    },
    {
        "q": "What occurs when 'message' changes in this code?",
        "c": "import { ref, watch } from 'vue';\nconst message = ref('hello');\nwatch(message, (newVal) => console.log(newVal));",
        "o": [
            "The new message value is logged",
            "Nothing is logged",
            "The old value is logged",
            "An error occurs"
        ]
    },
    {
        "q": "What is the purpose of 'markRaw' in Vue 3's reactivity?",
        "o": [
            "To mark an object as non-reactive",
            "To make an object deeply reactive",
            "To create a ref",
            "To define a watcher"
        ]
    },
    {
        "q": "What is the effect of 'shallowWatch' in Vue 3?",
        "o": [
            "It watches only top-level properties, not deep changes",
            "It watches deeply by default",
            "It prevents watching altogether",
            "It is not a valid function"
        ]
    },
    {
        "q": "What happens when updating 'user.name' in this code?",
        "c": "import { reactive } from 'vue';\nconst user = reactive({ name: 'Bob' });",
        "o": [
            "The change is reactive without .value",
            "You need .value to update",
            "An error occurs on update",
            "The user object becomes non-reactive"
        ]
    },
    {
        "q": "Why use 'toRef' in Vue 3 for reactive objects?",
        "o": [
            "To create a ref for a specific property of a reactive object",
            "To make the entire object a ref",
            "To unwrap all refs",
            "To define computed properties"
        ]
    },
    {
        "q": "What is the output when 'flag' toggles in this code?",
        "c": "import { ref, watchEffect } from 'vue';\nconst flag = ref(false);\nwatchEffect(() => console.log(flag.value));",
        "o": [
            "The current flag value is logged on change and initially",
            "Only on changes, not initially",
            "An error due to watchEffect",
            "Nothing is logged"
        ]
    },
    {
        "q": "What does 'customRef' allow in Vue 3?",
        "o": [
            "To create a ref with custom get and set behavior",
            "To make standard refs custom",
            "To disable reactivity",
            "To compute values"
        ]
    },
    {
        "q": "What is a caveat when destructuring a reactive object in Vue 3?",
        "o": [
            "Destructured properties lose reactivity unless using toRefs",
            "Destructured properties are always reactive",
            "Destructuring is not allowed",
            "It causes errors"
        ]
    },
    {
        "q": "What does the 'triggerRef' function do in Vue 3?",
        "o": [
            "It manually triggers updates for a shallow ref",
            "It creates a new ref",
            "It unwraps a ref",
            "It defines a computed property"
        ]
    },
    {
        "q": "What is the purpose of 'effectScope' in Vue 3's reactivity?",
        "o": [
            "To create a scope for collecting and disposing effects",
            "To make global reactive state",
            "To define watchers",
            "To handle errors in reactivity"
        ]
    },
    {
        "q": "What is returned by the computed function in this code?",
        "c": "import { ref, computed } from 'vue';\nconst a = ref(1);\nconst b = ref(2);\nconst sum = computed(() => a.value + b.value);",
        "o": [
            "A reactive computed ref with value 3 initially",
            "A non-reactive sum",
            "An error due to refs",
            "Undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using Map or Set in Vue.js?",
        "o": [
            "They are not deeply reactive by default in Vue 2",
            "They are always fully reactive",
            "They cannot be used in data",
            "They cause performance issues"
        ]
    },
    {
        "q": "What happens if you forget .value when accessing a ref in a watcher?",
        "o": [
            "It accesses the ref object, not the value, potentially causing issues",
            "It automatically unwraps",
            "It throws an error immediately",
            "It makes the watcher non-reactive"
        ]
    },
    {
        "q": "What logs when 'status' changes in this code?",
        "c": "import { ref, watch } from 'vue';\nconst status = ref('active');\nwatch(status, (newStatus, oldStatus) => {\n  console.log(`Status changed from ${oldStatus} to ${newStatus}`);\n});",
        "o": [
            "The old and new status values are logged",
            "Only the new status is logged",
            "Nothing is logged",
            "An error occurs"
        ]
    },
    {
        "q": "What is the role of 'readonly' in Vue 3?",
        "o": [
            "To create a reactive object that cannot be mutated",
            "To make non-reactive objects reactive",
            "To define shallow reactivity",
            "To unwrap refs"
        ]
    },
    {
        "q": "What does 'isReadonly' check in Vue 3?",
        "o": [
            "If an object is a readonly reactive proxy",
            "If a ref is readonly",
            "If reactivity is enabled",
            "If a computed is cached"
        ]
    },
    {
        "q": "What happens when updating 'book.title' in this code?",
        "c": "import { shallowReactive } from 'vue';\nconst book = shallowReactive({ title: 'Vue Guide' });",
        "o": [
            "The change to nested 'title' is not reactive",
            "The change is reactive",
            "An error occurs on update",
            "The book becomes deep reactive"
        ]
    },
    {
        "q": "What is the benefit of using 'shallowRef' in Vue 3?",
        "o": [
            "It provides reactivity only for the ref itself, not its nested values",
            "It makes deep nested reactivity",
            "It prevents ref updates",
            "It computes derived values"
        ]
    },
    {
        "q": "What is the purpose of the flush option in Vue 3's watch?",
        "o": [
            "To control when the watcher callback is executed (pre, post, sync)",
            "To flush the reactive state",
            "To define deep watching",
            "To make immediate calls"
        ]
    },
    {
        "q": "What does 'proxyRefs' do in Vue 3?",
        "o": [
            "It creates a proxy that automatically unwraps refs",
            "It makes refs reactive",
            "It defines readonly proxies",
            "It handles effect scopes"
        ]
    },
    {
        "q": "What is a caveat with reactivity transforms in Vue 3 (experimental)?",
        "o": [
            "They allow ref usage without .value but are experimental",
            "They are stable and recommended",
            "They disable reactivity",
            "They only work with reactive"
        ]
    },
    {
        "q": "What does the 'stop' method do when called on a watcher in Vue 3?",
        "o": [
            "It stops the watcher from reacting to further changes",
            "It resets the watched value",
            "It triggers an immediate update",
            "It converts the watcher to a computed property"
        ]
    },
    {
        "q": "What happens when you use a non-reactive dependency in a Vue 3 computed property?",
        "o": [
            "The computed property does not update when the non-reactive dependency changes",
            "The dependency becomes reactive automatically",
            "An error is thrown",
            "The computed property updates regardless"
        ]
    },
    {
        "q": "What is logged when 'data.value' changes in this code?",
        "c": "import { ref, watchEffect } from 'vue';\nconst data = ref({ value: 0 });\nwatchEffect(() => console.log(data.value.value));",
        "o": [
            "The new value of 'data.value' is logged",
            "Nothing is logged due to nested ref",
            "An error occurs",
            "The entire ref object is logged"
        ]
    },
    {
        "q": "What is the purpose of 'trigger' in Vue 3's reactivity system?",
        "o": [
            "To manually trigger reactivity updates for an effect",
            "To create a new reactive object",
            "To stop a watcher",
            "To define a ref"
        ]
    },
    {
        "q": "What is a reactivity caveat when using WeakMap or WeakSet in Vue.js?",
        "o": [
            "They are not reactive by default in Vue 2",
            "They are always reactive",
            "They cannot be used in Vue",
            "They cause memory leaks"
        ]
    },
    {
        "q": "What happens when 'options' is modified in this code?",
        "c": "import { reactive, readonly } from 'vue';\nconst options = readonly(reactive({ mode: 'light' }));\noptions.mode = 'dark';",
        "o": [
            "The assignment fails silently or warns in dev mode",
            "The mode changes reactively",
            "An error is thrown",
            "The options object becomes non-reactive"
        ]
    },
    {
        "q": "What is the role of 'computed' with a setter in Vue 3?",
        "o": [
            "It allows setting the computed value reactively",
            "It prevents computed updates",
            "It makes the computed read-only",
            "It converts to a ref"
        ]
    },
    {
        "q": "What does 'pauseTracking' do in Vue 3's reactivity system?",
        "o": [
            "It temporarily disables dependency tracking for effects",
            "It pauses all watchers",
            "It stops reactivity entirely",
            "It resets refs"
        ]
    },
    {
        "q": "What is the outcome when modifying 'obj.nested' in this code?",
        "c": "import { shallowReactive } from 'vue';\nconst obj = shallowReactive({ nested: { prop: 1 } });",
        "o": [
            "Changes to 'nested.prop' are not reactive",
            "Changes to 'nested.prop' are reactive",
            "An error occurs on modification",
            "The obj becomes fully reactive"
        ]
    },
    {
        "q": "What is the benefit of 'resetTracking' in Vue 3?",
        "o": [
            "It resets dependency tracking for the current effect",
            "It clears all reactive state",
            "It creates a new ref",
            "It defines a watcher"
        ]
    },
    {
        "q": "What logs when 'settings.value' changes in this code?",
        "c": "import { ref, watch } from 'vue';\nconst settings = ref({ value: 'initial' });\nwatch(settings, () => console.log('Settings changed'), { deep: true });",
        "o": [
            "'Settings changed' is logged for nested changes",
            "No log for nested changes",
            "An error due to deep option",
            "Only top-level changes are logged"
        ]
    },
    {
        "q": "What does 'reactiveEffect' do in Vue 3's internal reactivity?",
        "o": [
            "It creates a reactive effect for dependency tracking",
            "It makes objects non-reactive",
            "It defines computed properties",
            "It handles ref unwrapping"
        ]
    },
    {
        "q": "What is a caveat with using refs in Vue 3's reactive objects?",
        "o": [
            "Refs inside reactive objects are not automatically unwrapped",
            "Refs are always unwrapped",
            "Refs cannot be used in reactive objects",
            "Refs break reactivity"
        ]
    },
    {
        "q": "What does the 'effect' function in Vue 3's reactivity system primarily do?",
        "o": [
            "It creates a reactive effect that tracks dependencies and re-runs",
            "It defines a new ref",
            "It creates a readonly proxy",
            "It stops all watchers"
        ]
    },
    {
        "q": "What happens if you use a computed property as a ref in Vue 3?",
        "o": [
            "It acts as a reactive ref with get and set capabilities",
            "It becomes non-reactive",
            "An error is thrown",
            "It loses its computed behavior"
        ]
    },
    {
        "q": "What is logged when 'state.active' changes in this code?",
        "c": "import { reactive, watch } from 'vue';\nconst state = reactive({ active: false });\nwatch(() => state.active, (newVal) => console.log(`Active: ${newVal}`));",
        "o": [
            "The new value of 'active' is logged",
            "Nothing is logged",
            "An error occurs",
            "The old value is logged"
        ]
    },
    {
        "q": "What is the purpose of 'enableTracking' in Vue 3's reactivity system?",
        "o": [
            "It re-enables dependency tracking after being paused",
            "It creates a new reactive object",
            "It defines a computed property",
            "It stops all effects"
        ]
    },
    {
        "q": "What is a reactivity caveat when using Symbols as keys in Vue.js objects?",
        "o": [
            "Symbols are not reactive in Vue 2",
            "Symbols are always reactive",
            "Symbols cause errors in reactive objects",
            "Symbols are ignored by Vue"
        ]
    },
    {
        "q": "What happens when 'data.list' is updated in this code?",
        "c": "import { shallowReactive } from 'vue';\nconst data = shallowReactive({ list: [1, 2] });\ndata.list.push(3);",
        "o": [
            "The push is not reactive due to shallow reactivity",
            "The push is reactive",
            "An error occurs on push",
            "The list resets"
        ]
    },
    {
        "q": "What is the role of 'isProxy' in Vue 3?",
        "o": [
            "It checks if an object is a reactive or readonly proxy",
            "It creates a new proxy",
            "It unwraps refs",
            "It defines watchers"
        ]
    },
    {
        "q": "What does 'stop' do when called on an effectScope in Vue 3?",
        "o": [
            "It stops all effects within the scope",
            "It creates a new scope",
            "It makes effects reactive",
            "It pauses tracking"
        ]
    },
    {
        "q": "What is the outcome when modifying 'config' in this code?",
        "c": "import { reactive, readonly } from 'vue';\nconst config = readonly(reactive({ setting: 1 }));\nconfig.setting = 2;",
        "o": [
            "The change is ignored or warns in dev mode",
            "The change is reactive",
            "An error is thrown",
            "The config becomes mutable"
        ]
    },
    {
        "q": "What is the benefit of using 'shallowComputed' in Vue 3 (if available)?",
        "o": [
            "It creates a computed property with shallow dependency tracking",
            "It makes deep computed properties",
            "It prevents computed updates",
            "It is not a valid function"
        ]
    },
    {
        "q": "What logs when 'counter' increments in this code?",
        "c": "import { ref, watchEffect } from 'vue';\nconst counter = ref(0);\nwatchEffect(() => console.log(counter.value), { flush: 'post' });",
        "o": [
            "The new counter value is logged after DOM updates",
            "The value is logged before DOM updates",
            "Nothing is logged",
            "An error due to flush"
        ]
    },
    {
        "q": "What is the purpose of 'toRaw' in Vue 3?",
        "o": [
            "It returns the raw, non-reactive version of a proxy",
            "It creates a reactive proxy",
            "It unwraps refs",
            "It defines computed properties"
        ]
    },
    {
        "q": "What is a caveat when using refs in reactive objects in Vue 3?",
        "o": [
            "Assigning a ref to a reactive object property requires .value access",
            "Refs are automatically unwrapped",
            "Refs break reactive objects",
            "Refs cannot be assigned"
        ]
    },
    {
        "q": "What does the 'getCurrentScope' function return in Vue 3's reactivity system?",
        "o": [
            "The currently active effect scope or undefined",
            "A new reactive object",
            "The current ref's value",
            "A computed property"
        ]
    },
    {
        "q": "What happens when a reactive object's property is assigned a ref in Vue 3?",
        "o": [
            "The ref is stored as-is and requires .value to access",
            "The ref is automatically unwrapped",
            "An error is thrown",
            "The property becomes non-reactive"
        ]
    },
    {
        "q": "What is logged when 'item.count' changes in this code?",
        "c": "import { reactive, watch } from 'vue';\nconst item = reactive({ count: 0 });\nwatch(() => item.count, (newCount) => console.log(`Count: ${newCount}`));",
        "o": [
            "The new count value is logged",
            "Nothing is logged",
            "An error occurs",
            "The old count is logged"
        ]
    },
    {
        "q": "What is the purpose of 'onScopeDispose' in Vue 3?",
        "o": [
            "To register a callback when an effect scope is disposed",
            "To create a new effect scope",
            "To make an object reactive",
            "To trigger a ref update"
        ]
    },
    {
        "q": "What is a reactivity caveat with non-enumerable properties in Vue.js?",
        "o": [
            "Non-enumerable properties are not reactive in Vue 2",
            "They are always reactive",
            "They cause errors in reactive objects",
            "They are ignored by templates"
        ]
    },
    {
        "q": "What happens when 'values' is updated with unshift in this code?",
        "c": "import { reactive } from 'vue';\nconst values = reactive([1, 2]);\nvalues.unshift(0);",
        "o": [
            "The unshift is reactive and updates the DOM",
            "The unshift is not reactive",
            "An error occurs on unshift",
            "The values array resets"
        ]
    },
    {
        "q": "What is the role of 'reactiveCopy' in Vue 3 (if available)?",
        "o": [
            "It creates a shallow copy of a reactive object",
            "It makes a deep non-reactive copy",
            "It converts refs to reactive",
            "It is not a valid function"
        ]
    },
    {
        "q": "What does 'track' do in Vue 3's reactivity internals?",
        "o": [
            "It manually tracks dependencies for a reactive effect",
            "It stops dependency tracking",
            "It creates a new ref",
            "It defines a watcher"
        ]
    },
    {
        "q": "What is the outcome when modifying 'data.nested' in this code?",
        "c": "import { shallowRef } from 'vue';\nconst data = shallowRef({ nested: { key: 'value' } });",
        "o": [
            "Changes to 'nested.key' are not reactive",
            "Changes to 'nested.key' are reactive",
            "An error occurs on modification",
            "The data becomes fully reactive"
        ]
    },
    {
        "q": "What is the benefit of using 'watch' with a function as source in Vue 3?",
        "o": [
            "It allows watching computed or derived values",
            "It prevents watching refs",
            "It disables deep watching",
            "It creates a readonly proxy"
        ]
    },
    {
        "q": "What logs when 'config.mode' changes in this code?",
        "c": "import { reactive, watchEffect } from 'vue';\nconst config = reactive({ mode: 'light' });\nwatchEffect(() => console.log(config.mode));",
        "o": [
            "The new mode value is logged initially and on change",
            "Only changes are logged",
            "An error due to watchEffect",
            "Nothing is logged"
        ]
    },
    {
        "q": "What does 'onTrack' do in Vue 3's custom ref?",
        "o": [
            "It defines a callback for when dependencies are tracked",
            "It triggers manual updates",
            "It stops the ref",
            "It creates a reactive object"
        ]
    },
    {
        "q": "What is a caveat with using computed properties in Vue 3 loops?",
        "o": [
            "They may not recompute correctly if dependencies are dynamic",
            "They are always recomputed",
            "They cannot be used in loops",
            "They break reactivity in loops"
        ]
    },
    {
        "q": "What does 'onTrigger' do in Vue 3 when used with a custom ref?",
        "o": [
            "It defines a callback for when the ref triggers an update",
            "It creates a new reactive effect",
            "It stops dependency tracking",
            "It unwraps the ref"
        ]
    },
    {
        "q": "What happens when you nest a ref inside another ref in Vue 3?",
        "o": [
            "The nested ref remains a ref and requires .value access",
            "The nested ref is automatically unwrapped",
            "An error occurs",
            "The outer ref becomes non-reactive"
        ]
    },
    {
        "q": "What is logged when 'flags.enabled' changes in this code?",
        "c": "import { reactive, watch } from 'vue';\nconst flags = reactive({ enabled: false });\nwatch(() => flags.enabled, (newVal, oldVal) => console.log(`Enabled: ${newVal}, was ${oldVal}`));",
        "o": [
            "The new and old values of 'enabled' are logged",
            "Only the new value is logged",
            "Nothing is logged",
            "An error occurs due to reactive"
        ]
    },
    {
        "q": "What is the purpose of 'reactiveEffectRunner' in Vue 3's internal reactivity?",
        "o": [
            "It runs a reactive effect with dependency tracking",
            "It creates a new ref",
            "It defines a readonly proxy",
            "It stops all watchers"
        ]
    },
    {
        "q": "What is a reactivity caveat when using Object.defineProperty in Vue 2?",
        "o": [
            "Properties defined with non-configurable descriptors are not reactive",
            "All defined properties are reactive",
            "It prevents object reactivity",
            "It causes errors in Vue 2"
        ]
    },
    {
        "q": "What happens when 'queue' is updated with sort in this code?",
        "c": "import { reactive } from 'vue';\nconst queue = reactive([3, 1, 2]);\nqueue.sort((a, b) => a - b);",
        "o": [
            "The sort is reactive and updates the DOM",
            "The sort is not reactive",
            "An error occurs on sort",
            "The queue resets"
        ]
    },
    {
        "q": "What is the role of 'computed' with an object argument in Vue 3?",
        "o": [
            "It allows defining get and set for a writable computed property",
            "It makes the computed non-reactive",
            "It creates a shallow computed",
            "It defines a ref"
        ]
    },
    {
        "q": "What does 'collectDependencies' do in Vue 3's reactivity internals?",
        "o": [
            "It gathers dependencies for a reactive effect",
            "It clears all reactive state",
            "It creates a new effect scope",
            "It unwraps refs"
        ]
    },
    {
        "q": "What is the outcome when modifying 'state.data' in this code?",
        "c": "import { shallowRef } from 'vue';\nconst state = shallowRef({ data: { value: 0 } });",
        "o": [
            "Changes to 'data.value' are not reactive",
            "Changes to 'data.value' are reactive",
            "An error occurs on modification",
            "The state becomes fully reactive"
        ]
    },
    {
        "q": "What is the benefit of using 'watch' with multiple sources in Vue 3?",
        "o": [
            "It allows watching multiple refs or reactive properties simultaneously",
            "It prevents watching single sources",
            "It disables deep watching",
            "It creates computed properties"
        ]
    },
    {
        "q": "What logs when 'options.theme' changes in this code?",
        "c": "import { reactive, watchEffect } from 'vue';\nconst options = reactive({ theme: 'dark' });\nwatchEffect(() => console.log(`Theme: ${options.theme}`), { flush: 'sync' });",
        "o": [
            "The theme is logged synchronously on change and initially",
            "The theme is logged asynchronously",
            "An error due to flush",
            "Nothing is logged"
        ]
    },
    {
        "q": "What is the purpose of 'reactiveProxy' in Vue 3 internals?",
        "o": [
            "It creates a reactive proxy for an object",
            "It unwraps all refs",
            "It stops reactive effects",
            "It defines a custom ref"
        ]
    },
    {
        "q": "What is a caveat when using refs in Vue 3's watchEffect?",
        "o": [
            "You must access refs with .value inside watchEffect",
            "Refs are auto-unwrapped in watchEffect",
            "Refs cannot be watched",
            "Refs break watchEffect"
        ]
    },
    {
        "q": "What does the 'reactiveDeps' map manage in Vue 3's reactivity system?",
        "o": [
            "It tracks dependencies for reactive effects",
            "It stores ref values",
            "It defines computed properties",
            "It handles DOM updates"
        ]
    },
    {
        "q": "What happens when a ref is used as a key in a reactive object in Vue 3?",
        "o": [
            "The ref is treated as its raw value, not reactive",
            "The ref key is reactive",
            "An error occurs",
            "The ref is auto-unwrapped"
        ]
    },
    {
        "q": "What is logged when 'metrics.value' changes in this code?",
        "c": "import { ref, watch } from 'vue';\nconst metrics = ref({ value: 100 });\nwatch(metrics, (newVal) => console.log(`Value: ${newVal.value}`), { deep: true });",
        "o": [
            "The new value of 'metrics.value' is logged",
            "Nothing is logged for nested changes",
            "An error due to deep watch",
            "The entire metrics object is logged"
        ]
    },
    {
        "q": "What is the purpose of 'onBeforeUpdate' in Vue 3's reactivity effects?",
        "o": [
            "It runs a callback before an effect is re-run",
            "It stops an effect",
            "It creates a reactive ref",
            "It defines a watcher"
        ]
    },
    {
        "q": "What is a reactivity caveat with inherited properties in Vue 2 objects?",
        "o": [
            "Inherited properties are not reactive",
            "Inherited properties are always reactive",
            "They cause errors in reactive objects",
            "They are ignored by Vue"
        ]
    },
    {
        "q": "What happens when 'items' is updated with splice in this code?",
        "c": "import { reactive } from 'vue';\nconst items = reactive([1, 2, 3]);\nitems.splice(1, 1, 4);",
        "o": [
            "The splice is reactive and updates the DOM",
            "The splice is not reactive",
            "An error occurs on splice",
            "The items array clears"
        ]
    },
    {
        "q": "What is the role of 'effectScope().run' in Vue 3?",
        "o": [
            "It runs a function within a new effect scope",
            "It creates a reactive object",
            "It stops all effects",
            "It unwraps refs"
        ]
    },
    {
        "q": "What does 'onCleanup' do in a Vue 3 custom ref?",
        "o": [
            "It registers a cleanup callback before the ref updates",
            "It clears the ref's value",
            "It makes the ref readonly",
            "It defines a computed property"
        ]
    },
    {
        "q": "What is the outcome when modifying 'config.data' in this code?",
        "c": "import { shallowReactive } from 'vue';\nconst config = shallowReactive({ data: { key: 'value' } });",
        "o": [
            "Changes to 'data.key' are not reactive",
            "Changes to 'data.key' are reactive",
            "An error occurs on modification",
            "The config becomes fully reactive"
        ]
    },
    {
        "q": "What is the benefit of using 'watch' with an array of sources in Vue 3?",
        "o": [
            "It allows simultaneous monitoring of multiple reactive sources",
            "It prevents watching single refs",
            "It disables deep reactivity",
            "It creates a computed ref"
        ]
    },
    {
        "q": "What logs when 'state.flag' changes in this code?",
        "c": "import { reactive, watchEffect } from 'vue';\nconst state = reactive({ flag: false });\nwatchEffect(() => console.log(`Flag: ${state.flag}`), { flush: 'pre' });",
        "o": [
            "The flag value is logged before DOM updates",
            "The flag is logged after DOM updates",
            "An error due to flush",
            "Nothing is logged"
        ]
    },
    {
        "q": "What is the purpose of 'reactiveHandler' in Vue 3's internal reactivity?",
        "o": [
            "It defines the proxy handler for reactive objects",
            "It creates a new effect scope",
            "It stops reactive tracking",
            "It unwraps all refs"
        ]
    },
    {
        "q": "What is a caveat when using computed properties with async operations in Vue 3?",
        "o": [
            "Async operations are not supported in computed properties",
            "They are fully supported and reactive",
            "They cause infinite loops",
            "They work but are non-reactive"
        ]
    },
    {
        "q": "What does the 'reactiveEffect.active' property indicate in Vue 3?",
        "o": [
            "Whether a reactive effect is currently active",
            "If a ref is reactive",
            "If a computed property is cached",
            "The status of a watcher"
        ]
    },
    {
        "q": "What happens when you assign a non-reactive object to a ref's value in Vue 3?",
        "o": [
            "The object becomes reactive automatically",
            "The object remains non-reactive",
            "An error is thrown",
            "The ref becomes undefined"
        ]
    },
    {
        "q": "What is logged when 'settings.mode' changes in this code?",
        "c": "import { reactive, watch } from 'vue';\nconst settings = reactive({ mode: 'light' });\nwatch(() => settings.mode, (newMode) => console.log(`Mode: ${newMode}`));",
        "o": [
            "The new mode value is logged",
            "Nothing is logged",
            "An error occurs",
            "The old mode is logged"
        ]
    },
    {
        "q": "What is the purpose of 'onEffectCleanup' in Vue 3's reactivity system?",
        "o": [
            "To register cleanup logic for a reactive effect",
            "To create a new ref",
            "To stop an effect scope",
            "To define a computed property"
        ]
    },
    {
        "q": "What is a reactivity caveat with getter-only properties in Vue 2?",
        "o": [
            "Getter-only properties are not reactive",
            "They are always reactive",
            "They cause errors in reactive objects",
            "They are ignored by the DOM"
        ]
    },
    {
        "q": "What happens when 'list' is updated with pop in this code?",
        "c": "import { reactive } from 'vue';\nconst list = reactive([1, 2, 3]);\nlist.pop();",
        "o": [
            "The pop is reactive and updates the DOM",
            "The pop is not reactive",
            "An error occurs on pop",
            "The list empties completely"
        ]
    },
    {
        "q": "What is the role of 'getCurrentInstance' in Vue 3's reactivity context?",
        "o": [
            "It retrieves the current component instance for reactivity",
            "It creates a new reactive object",
            "It stops all effects",
            "It unwraps refs"
        ]
    },
    {
        "q": "What does 'reactiveEffect.scheduler' do in Vue 3?",
        "o": [
            "It defines a custom scheduler for effect execution",
            "It clears reactive dependencies",
            "It creates a shallow ref",
            "It defines a watcher"
        ]
    },
    {
        "q": "What is the outcome when modifying 'obj.inner' in this code?",
        "c": "import { shallowReactive } from 'vue';\nconst obj = shallowReactive({ inner: { prop: 'value' } });",
        "o": [
            "Changes to 'inner.prop' are not reactive",
            "Changes to 'inner.prop' are reactive",
            "An error occurs on modification",
            "The obj becomes fully reactive"
        ]
    },
    {
        "q": "What is the benefit of using 'watch' with a cleanup callback in Vue 3?",
        "o": [
            "It allows cleaning up resources before the next watch run",
            "It prevents watching changes",
            "It makes the watch readonly",
            "It creates a computed ref"
        ]
    },
    {
        "q": "What logs when 'data.value' changes in this code?",
        "c": "import { ref, watchEffect } from 'vue';\nconst data = ref({ value: 0 });\nwatchEffect(() => console.log(data.value.value), { flush: 'sync' });",
        "o": [
            "The new value is logged synchronously",
            "The value is logged asynchronously",
            "An error due to flush",
            "Nothing is logged"
        ]
    },
    {
        "q": "What is the purpose of 'reactiveEffect.allowRecurse' in Vue 3?",
        "o": [
            "It allows an effect to trigger itself recursively",
            "It stops recursive effects",
            "It creates a reactive proxy",
            "It unwraps refs"
        ]
    },
    {
        "q": "What is a caveat when using refs in Vue 3's reactive computed properties?",
        "o": [
            "You must access .value explicitly in computed getters",
            "Refs are auto-unwrapped in computed",
            "Refs cannot be used in computed",
            "Refs break computed reactivity"
        ]
    },
    {
        "q": "Which function is used in Vue.js 3 to create a reactive object?",
        "o": [
            "reactive",
            "ref",
            "toRef",
            "computed"
        ]
    },
    {
        "q": "What is the output of the following code when the `count` value changes?",
        "c": "const count = ref(0);\nwatch(count, (newVal) => console.log(newVal));\ncount.value = 5;",
        "o": [
            "5",
            "0",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a key difference between computed properties and methods in Vue.js?",
        "o": [
            "Computed properties are cached based on their dependencies",
            "Methods are reactive, while computed properties are not",
            "Computed properties can only return primitive values",
            "Methods are automatically memoized"
        ]
    },
    {
        "q": "What happens when you try to add a new property to a reactive object in Vue.js 3?",
        "o": [
            "The new property is not reactive by default",
            "The new property is automatically reactive",
            "It throws an error",
            "The entire object becomes non-reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ count: 0 });\nconst doubled = computed(() => obj.count * 2);\nobj.count = 10;\nconsole.log(doubled.value);",
        "o": [
            "20",
            "0",
            "10",
            "undefined"
        ]
    },
    {
        "q": "Which of the following is a reactivity caveat when using `ref` in Vue.js 3?",
        "o": [
            "You must use .value to access or modify the ref's value in JavaScript",
            "Refs are not reactive when used in templates",
            "Refs cannot store objects",
            "Refs are automatically unwrapped in all contexts"
        ]
    },
    {
        "q": "What is the purpose of the `watchEffect` function in Vue.js 3?",
        "o": [
            "It runs immediately and re-runs whenever any reactive dependency changes",
            "It only runs when explicitly triggered",
            "It creates a computed property",
            "It watches for changes in non-reactive data"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ a: 1 });\nconst watcher = watch(() => obj.a, (val) => console.log(val));\nobj.a = 2;\nobj.a = 3;",
        "o": [
            "2, 3",
            "1, 2, 3",
            "3",
            "No output"
        ]
    },
    {
        "q": "Why might a computed property not update when its dependencies change?",
        "o": [
            "The dependency is not reactive",
            "The computed property is not cached",
            "The computed property uses a method instead of a getter",
            "The dependency is a ref instead of a reactive object"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = reactive({ list: [1, 2] });\nstate.list.push(3);\nconsole.log(state.list.length);",
        "o": [
            "3",
            "2",
            "undefined",
            "1"
        ]
    },
    {
        "q": "Which of the following is true about Vue.js 3's `toRef` function?",
        "o": [
            "It creates a reactive reference to a property of a reactive object",
            "It converts a reactive object into a non-reactive object",
            "It creates a computed property",
            "It is used to watch non-reactive data"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const count = ref(1);\nconst isEven = computed(() => count.value % 2 === 0);\ncount.value = 2;\nconsole.log(isEven.value);",
        "o": [
            "true",
            "false",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What happens when you try to directly mutate a reactive array's length in Vue.js 3?",
        "o": [
            "The change is reactive and triggers updates",
            "The change is not reactive and does not trigger updates",
            "It throws an error",
            "The array becomes non-reactive"
        ]
    },
    {
        "q": "In Vue.js 3, what is the primary difference between `ref` and `reactive` when creating reactive data?",
        "o": [
            "ref creates a single reactive value, while reactive creates a reactive object",
            "ref is used for objects, while reactive is for primitive values",
            "ref is non-reactive, while reactive is reactive",
            "ref cannot be used in templates, while reactive can"
        ]
    },
    {
        "q": "What is the output of the following code when `data.value` is updated?",
        "c": "const data = ref(10);\nwatchEffect(() => console.log(data.value * 2));\ndata.value = 20;",
        "o": [
            "40",
            "20",
            "10",
            "No output"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for nested objects within a `reactive` object?",
        "o": [
            "Nested objects are automatically made reactive",
            "Nested objects remain non-reactive unless explicitly converted",
            "Nested objects require manual watching with `watch`",
            "Nested objects cannot be accessed reactively"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = reactive({ count: 5 });\nconst tripled = computed(() => state.count * 3);\nstate.count = 10;\nconsole.log(tripled.value);",
        "o": [
            "30",
            "15",
            "5",
            "undefined"
        ]
    },
    {
        "q": "What is a common reactivity caveat when modifying arrays in Vue.js 3?",
        "o": [
            "Directly setting an array index does not trigger reactivity",
            "Pushing to an array is not reactive",
            "Array methods like splice are non-reactive",
            "Arrays cannot be made reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ x: 1, y: 2 });\nwatch([() => obj.x, () => obj.y], ([newX, newY]) => console.log(newX + newY));\nobj.x = 3;\nobj.y = 4;",
        "o": [
            "7",
            "3",
            "4",
            "No output"
        ]
    },
    {
        "q": "Why would you use `toRefs` in Vue.js 3 when working with a reactive object?",
        "o": [
            "To convert all properties of a reactive object into individual refs",
            "To make a reactive object non-reactive",
            "To create a computed version of the object",
            "To watch the object for changes"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const flag = ref(false);\nconst status = computed(() => flag.value ? 'On' : 'Off');\nflag.value = true;\nconsole.log(status.value);",
        "o": [
            "On",
            "Off",
            "true",
            "false"
        ]
    },
    {
        "q": "What happens when you use a non-reactive dependency in a computed property?",
        "o": [
            "The computed property does not update when the dependency changes",
            "The computed property throws an error",
            "The computed property becomes reactive automatically",
            "The computed property updates but logs a warning"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const data = reactive({ items: [] });\ndata.items = [1, 2, 3];\nconsole.log(data.items.length);",
        "o": [
            "3",
            "0",
            "undefined",
            "1"
        ]
    },
    {
        "q": "How does Vue.js 3's `watch` function differ from `watchEffect`?",
        "o": [
            "watch requires explicit dependencies, while watchEffect automatically tracks them",
            "watch is non-reactive, while watchEffect is reactive",
            "watch only works with refs, while watchEffect works with reactive objects",
            "watchEffect requires a manual trigger, while watch does not"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ a: { b: 1 } });\nconst bRef = toRef(obj.a, 'b');\nobj.a.b = 5;\nconsole.log(bRef.value);",
        "o": [
            "5",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` objects in Vue.js 3?",
        "o": [
            "Replacing the entire reactive object breaks reactivity",
            "Individual property changes are not reactive",
            "Reactive objects cannot be used in templates",
            "Reactive objects cannot contain arrays"
        ]
    },
    {
        "q": "In Vue.js 3, what happens when you attempt to make a non-reactive object reactive using `reactive`?",
        "o": [
            "A new reactive proxy is created for the object",
            "The original object is mutated to be reactive",
            "It throws an error if the object is not reactive",
            "The object remains non-reactive"
        ]
    },
    {
        "q": "What is the output of the following code when `state.num` is updated?",
        "c": "const state = reactive({ num: 1 });\nwatchEffect(() => console.log(state.num ** 2));\nstate.num = 3;",
        "o": [
            "9",
            "1",
            "3",
            "No output"
        ]
    },
    {
        "q": "What is a key advantage of using computed properties over watchers in Vue.js 3?",
        "o": [
            "Computed properties automatically cache their results",
            "Watchers are more efficient for simple calculations",
            "Computed properties can watch non-reactive data",
            "Watchers are cached by default"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const data = ref(2);\nconst squared = computed(() => data.value * data.value);\ndata.value = 4;\nconsole.log(squared.value);",
        "o": [
            "16",
            "4",
            "8",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when updating properties of a `reactive` object in Vue.js 3?",
        "o": [
            "Adding new properties directly does not trigger reactivity",
            "Updating existing properties is not reactive",
            "Deleting properties is not allowed",
            "Reactive objects cannot be nested"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ x: 0, y: 0 });\nwatch(() => obj.x + obj.y, (sum) => console.log(sum));\nobj.x = 1;\nobj.y = 2;",
        "o": [
            "3",
            "0",
            "1",
            "2"
        ]
    },
    {
        "q": "Why might you use `shallowReactive` instead of `reactive` in Vue.js 3?",
        "o": [
            "To make only the top-level properties reactive",
            "To make nested objects reactive",
            "To improve memory usage for small objects",
            "To disable reactivity entirely"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const count = ref(0);\nconst isPositive = computed(() => count.value > 0);\ncount.value = 5;\nconsole.log(isPositive.value);",
        "o": [
            "true",
            "false",
            "0",
            "5"
        ]
    },
    {
        "q": "What happens when you try to use a `ref` inside a `reactive` object in Vue.js 3?",
        "o": [
            "The ref is automatically unwrapped when accessed",
            "The ref remains wrapped and requires .value",
            "It causes a reactivity error",
            "The ref becomes non-reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const arr = reactive([1, 2]);\narr[0] = 3;\nconsole.log(arr[0]);",
        "o": [
            "3",
            "1",
            "undefined",
            "2"
        ]
    },
    {
        "q": "What is the purpose of `toRaw` in Vue.js 3's reactivity system?",
        "o": [
            "To access the original non-reactive object from a reactive proxy",
            "To convert a ref to a reactive object",
            "To make a non-reactive object reactive",
            "To create a shallow copy of a reactive object"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ nested: { val: 1 } });\nconst valRef = toRef(obj.nested, 'val');\nobj.nested.val = 10;\nconsole.log(valRef.value);",
        "o": [
            "10",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "Why does directly modifying a `reactive` array’s length in Vue.js 3 not trigger reactivity?",
        "o": [
            "Vue.js does not track length changes as reactive",
            "Array length is immutable in reactive objects",
            "Length changes require using Vue.set",
            "Arrays are not reactive by default"
        ]
    },
    {
        "q": "In Vue.js 3, what is the primary role of the `reactive` function when used with an object?",
        "o": [
            "It creates a reactive proxy that tracks property changes",
            "It converts a reactive object to a non-reactive one",
            "It creates a shallow copy of the object",
            "It only tracks changes to primitive values"
        ]
    },
    {
        "q": "What is the output of the following code when `num.value` is modified?",
        "c": "const num = ref(5);\nwatchEffect(() => console.log(num.value + 10));\nnum.value = 15;",
        "o": [
            "25",
            "15",
            "5",
            "10"
        ]
    },
    {
        "q": "How does a computed property in Vue.js 3 differ from a regular method in terms of execution?",
        "o": [
            "Computed properties only re-evaluate when dependencies change",
            "Methods cache their results until manually called",
            "Computed properties run on every render",
            "Methods are reactive by default"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = reactive({ value: 2 });\nconst quadrupled = computed(() => state.value * 4);\nstate.value = 3;\nconsole.log(quadrupled.value);",
        "o": [
            "12",
            "8",
            "2",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when attempting to delete a property from a `reactive` object in Vue.js 3?",
        "o": [
            "Direct deletion using delete operator is not reactive",
            "Deleting properties is always reactive",
            "Deletion requires a computed property",
            "Properties cannot be deleted from reactive objects"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ a: 1, b: 2 });\nwatch(() => obj.a * obj.b, (product) => console.log(product));\nobj.a = 3;\nobj.b = 4;",
        "o": [
            "12",
            "2",
            "3",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `isReactive` in Vue.js 3's reactivity system?",
        "o": [
            "To check if an object is a reactive proxy",
            "To check if a ref is reactive",
            "To convert a ref to a reactive object",
            "To make a non-reactive object reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const toggle = ref(true);\nconst message = computed(() => toggle.value ? 'Active' : 'Inactive');\ntoggle.value = false;\nconsole.log(message.value);",
        "o": [
            "Inactive",
            "Active",
            "true",
            "false"
        ]
    },
    {
        "q": "What happens when you assign a new object to a property of a `reactive` object in Vue.js 3?",
        "o": [
            "The new object is automatically made reactive",
            "The new object remains non-reactive",
            "It causes a reactivity error",
            "The entire reactive object is replaced"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const arr = reactive([10, 20]);\narr.splice(0, 1, 30);\nconsole.log(arr[0]);",
        "o": [
            "30",
            "10",
            "20",
            "undefined"
        ]
    },
    {
        "q": "Why would you use `shallowRef` instead of `ref` in Vue.js 3?",
        "o": [
            "To create a ref that does not deeply track object changes",
            "To make a ref deeply reactive",
            "To convert a reactive object to a ref",
            "To disable reactivity for primitive values"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ data: { count: 1 } });\nconst countRef = toRef(obj.data, 'count');\nobj.data.count = 7;\nconsole.log(countRef.value);",
        "o": [
            "7",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a reactivity caveat when working with `reactive` arrays in Vue.js 3?",
        "o": [
            "Replacing the entire array breaks reactivity",
            "Array methods like push are non-reactive",
            "Arrays cannot contain reactive objects",
            "Array length changes are always reactive"
        ]
    },
    {
        "q": "In Vue.js 3, what does the `markRaw` function do in the reactivity system?",
        "o": [
            "It prevents an object from being made reactive",
            "It marks an object as reactive",
            "It creates a shallow reactive object",
            "It unwraps a ref"
        ]
    },
    {
        "q": "What is the output of the following code when `state.val` changes?",
        "c": "const state = reactive({ val: 0 });\nconst deepWatcher = watch(() => state, (newVal) => console.log(newVal.val), { deep: true });\nstate.val = 42;",
        "o": [
            "42",
            "0",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a key difference between `readonly` and `reactive` in Vue.js 3?",
        "o": [
            "readonly creates a read-only reactive proxy",
            "reactive prevents reading properties",
            "readonly allows mutations",
            "reactive is non-reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const num = ref(3);\nconst cubed = computed(() => num.value ** 3);\nnum.value = 2;\nconsole.log(cubed.value);",
        "o": [
            "8",
            "27",
            "3",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using asynchronous code inside a watcher in Vue.js 3?",
        "o": [
            "The watcher may run before the async operation completes",
            "Watchers cannot handle async code",
            "Async code makes the watcher non-reactive",
            "Watchers are synchronous by default"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ count: 1 });\nwatch(obj, (newObj) => console.log(newObj.count), { deep: true });\nobj.count = 100;",
        "o": [
            "100",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `customRef` in Vue.js 3's reactivity system?",
        "o": [
            "To create a ref with custom get and set behavior",
            "To create a standard ref",
            "To make a reactive object custom",
            "To unwrap custom refs"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const active = ref(false);\nconst label = computed(() => active.value ? 'Enabled' : 'Disabled');\nactive.value = true;\nconsole.log(label.value);",
        "o": [
            "Enabled",
            "Disabled",
            "false",
            "true"
        ]
    },
    {
        "q": "What happens when you try to mutate a `readonly` object in Vue.js 3?",
        "o": [
            "It logs a warning and does not mutate",
            "It mutates successfully",
            "It throws an error",
            "It becomes reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const list = reactive([4, 5, 6]);\nlist.length = 2;\nconsole.log(list.length);",
        "o": [
            "2",
            "3",
            "undefined",
            "0"
        ]
    },
    {
        "q": "What is the role of `effectScope` in Vue.js 3?",
        "o": [
            "To group and manage reactive effects",
            "To scope watchers to components",
            "To create global reactive effects",
            "To disable effects"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const parent = reactive({ child: { prop: 'hello' } });\nconst propRef = toRef(parent.child, 'prop');\nparent.child.prop = 'world';\nconsole.log(propRef.value);",
        "o": [
            "world",
            "hello",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "Why might a watcher not trigger when expected in Vue.js 3?",
        "o": [
            "The change was made outside the reactive system",
            "Watchers are disabled by default",
            "The dependency is a computed property",
            "Watchers only work with methods"
        ]
    },
    {
        "q": "What does the `unref` function do in Vue.js 3's reactivity system?",
        "o": [
            "It returns the inner value if it's a ref, otherwise the argument",
            "It makes a ref non-reactive",
            "It creates a new ref from a value",
            "It checks if a value is a ref"
        ]
    },
    {
        "q": "What is the output of the following code when `data.value` is set to 10?",
        "c": "const data = ref(5);\nwatchEffect(() => console.log(data.value - 3));\ndata.value = 10;",
        "o": [
            "7",
            "2",
            "5",
            "No output"
        ]
    },
    {
        "q": "In Vue.js 3, what is the default flush timing for watchers?",
        "o": [
            "post",
            "pre",
            "sync",
            "immediate"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const value = ref(4);\nconst doubled = computed(() => value.value * 2);\nvalue.value = 6;\nconsole.log(doubled.value);",
        "o": [
            "12",
            "8",
            "4",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using objects as keys in reactive Maps or Sets in Vue.js 3?",
        "o": [
            "Objects are compared by reference, not value",
            "Maps and Sets are not reactive",
            "Objects cannot be used as keys",
            "Reactivity is lost on iteration"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = reactive({ x: 10 });\nwatch(state, (newState) => console.log(newState.x * 2), { deep: true });\nstate.x = 20;",
        "o": [
            "40",
            "20",
            "10",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `isRef` in Vue.js 3?",
        "o": [
            "To check if a value is a ref",
            "To check if an object is reactive",
            "To unwrap a ref",
            "To create a ref"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const flag = ref(true);\nconst status = computed(() => flag.value ? 'Yes' : 'No');\nflag.value = false;\nconsole.log(status.value);",
        "o": [
            "No",
            "Yes",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3 handle ref unwrapping in reactive objects?",
        "o": [
            "Refs are automatically unwrapped when set as properties",
            "Refs must be manually unwrapped with .value",
            "Refs cannot be placed in reactive objects",
            "Unwrapping happens only in templates"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const numbers = reactive([1, 2, 3]);\nnumbers.pop();\nconsole.log(numbers.length);",
        "o": [
            "2",
            "3",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What is the role of `triggerRef` in Vue.js 3?",
        "o": [
            "To manually trigger updates for a shallow ref",
            "To create a trigger for watchers",
            "To stop a ref from updating",
            "To check ref triggers"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ inner: { key: 1 } });\nconst keyRef = toRef(obj.inner, 'key');\nobj.inner = { key: 2 };\nconsole.log(keyRef.value);",
        "o": [
            "undefined",
            "1",
            "2",
            "No output"
        ]
    },
    {
        "q": "Why might a computed property return a stale value in Vue.js 3?",
        "o": [
            "If its dependencies haven't triggered a re-computation",
            "Computed properties are always stale",
            "If the getter function has side effects",
            "Computed properties update synchronously"
        ]
    },
    {
        "q": "In Vue.js 3, what does the `isReadonly` function check?",
        "o": [
            "If an object is a readonly reactive proxy",
            "If a ref is readonly",
            "If a computed property is readonly",
            "If a watcher is readonly"
        ]
    },
    {
        "q": "What is the output of the following code when `obj.nested.val` is updated?",
        "c": "const obj = reactive({ nested: { val: 1 } });\nwatchEffect(() => console.log(obj.nested.val));\nobj.nested.val = 100;",
        "o": [
            "100",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a key feature of writable computed properties in Vue.js 3?",
        "o": [
            "They allow setting the computed value which updates dependencies",
            "They are readonly by default",
            "They cannot have setters",
            "They only work with refs"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const count = ref(1);\nconst factorial = computed(() => count.value === 0 ? 1 : count.value * factorial.value);\ncount.value = 3;\nconsole.log(factorial.value);",
        "o": [
            "6",
            "1",
            "3",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `ref` with objects in Vue.js 3?",
        "o": [
            "Replacing the object inside ref requires triggerRef for updates",
            "Objects in refs are deeply reactive by default",
            "Refs cannot hold objects",
            "Object changes are not tracked"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const data = reactive({ a: 1 });\nconst stop = watch(data, (newData) => console.log(newData.a));\ndata.a = 2;\nstop();\ndata.a = 3;",
        "o": [
            "2",
            "1",
            "3",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `shallowReadonly` in Vue.js 3?",
        "o": [
            "To create a shallow read-only reactive object",
            "To make deep properties readonly",
            "To convert readonly to reactive",
            "To check if shallow readonly"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const loading = ref(true);\nconst text = computed(() => loading.value ? 'Loading...' : 'Ready');\nloading.value = false;\nconsole.log(text.value);",
        "o": [
            "Ready",
            "Loading...",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3's reactivity system handle Symbols as property keys?",
        "o": [
            "Symbols are supported and reactive",
            "Symbols are ignored in reactivity",
            "Symbols cause errors in reactive objects",
            "Symbols are converted to strings"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const set = reactive(new Set([1, 2]));\nset.add(3);\nconsole.log(set.size);",
        "o": [
            "3",
            "2",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What is the role of `onScopeDispose` in Vue.js 3?",
        "o": [
            "To register a callback when the effect scope is disposed",
            "To dispose watchers manually",
            "To create new scopes",
            "To check scope status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const base = reactive({ prop: 5 });\nconst propRef = toRef(base, 'prop');\nbase.prop = 10;\nconsole.log(propRef.value);",
        "o": [
            "10",
            "5",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "Why might watchEffect run multiple times initially in Vue.js 3?",
        "o": [
            "If it has side effects that change dependencies",
            "watchEffect only runs once",
            "If flush is set to pre",
            "If deep is enabled"
        ]
    },
    {
        "q": "What does the `proxyRefs` function do in Vue.js 3's reactivity system?",
        "o": [
            "It creates a proxy that automatically unwraps refs when accessed",
            "It makes refs reactive",
            "It converts reactive objects to refs",
            "It checks if a proxy is reactive"
        ]
    },
    {
        "q": "What is the output of the following code when `state.arr[0]` is modified?",
        "c": "const state = reactive({ arr: [1] });\nwatchEffect(() => console.log(state.arr[0]));\nstate.arr[0] = 99;",
        "o": [
            "99",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "In Vue.js 3, what is the `flush` option for watchers?",
        "o": [
            "It controls when the watcher callback is called relative to DOM updates",
            "It flushes the reactive cache",
            "It sets the watcher to immediate mode",
            "It disables deep watching"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const x = ref(10);\nconst y = ref(20);\nconst sum = computed(() => x.value + y.value);\nx.value = 15;\nconsole.log(sum.value);",
        "o": [
            "35",
            "30",
            "10",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when destructuring a reactive object in Vue.js 3?",
        "o": [
            "Destructured properties lose reactivity",
            "Destructuring makes properties readonly",
            "Destructuring is not allowed on reactive objects",
            "Destructured properties become refs"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ key: 'value' });\nwatch(obj, (newObj, oldObj) => console.log(oldObj.key));\nobj.key = 'newValue';",
        "o": [
            "value",
            "newValue",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `isProxy` in Vue.js 3?",
        "o": [
            "To check if a value is a reactive or readonly proxy",
            "To check if a ref is a proxy",
            "To create a proxy",
            "To unwrap a proxy"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const error = ref(false);\nconst msg = computed(() => error.value ? 'Error occurred' : 'Success');\nerror.value = true;\nconsole.log(msg.value);",
        "o": [
            "Error occurred",
            "Success",
            "false",
            "true"
        ]
    },
    {
        "q": "How does Vue.js 3's reactivity handle inheritance from reactive objects?",
        "o": [
            "Inherited properties are reactive if accessed through the proxy",
            "Inheritance breaks reactivity",
            "Only own properties are reactive",
            "Prototypes are made reactive automatically"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const map = reactive(new Map([['a', 1]]));\nmap.set('b', 2);\nconsole.log(map.size);",
        "o": [
            "2",
            "1",
            "undefined",
            "0"
        ]
    },
    {
        "q": "What is the role of `getCurrentScope` in Vue.js 3?",
        "o": [
            "To get the current active effect scope",
            "To create a new scope",
            "To dispose the current scope",
            "To check if in scope"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const source = reactive({ num: 0 });\nconst numRef = toRef(source, 'num');\nsource.num = 50;\nconsole.log(numRef.value);",
        "o": [
            "50",
            "0",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "Why might a watcher receive the same value for old and new in Vue.js 3?",
        "o": [
            "If the change is a mutation that doesn't create a new object",
            "Watchers always receive same values",
            "If deep is false",
            "If flush is sync"
        ]
    },
    {
        "q": "In Vue.js 3, what happens when you pass a ref to `reactive`?",
        "o": [
            "The ref is treated as a normal value and loses reactivity",
            "The ref is automatically unwrapped and becomes reactive",
            "It throws an error",
            "The ref is wrapped in a new ref"
        ]
    },
    {
        "q": "What is the output of the following code when `data.nested.val` changes?",
        "c": "const data = reactive({ nested: { val: 0 } });\nwatchEffect(() => console.log(data.nested.val * 2), { flush: 'sync' });\ndata.nested.val = 5;",
        "o": [
            "10",
            "0",
            "5",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of the `onWatcherCleanup` function in Vue.js 3?",
        "o": [
            "To register cleanup logic before a watcher re-runs",
            "To stop all watchers",
            "To create a cleanup scope",
            "To check watcher status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const value = ref(5);\nconst inverse = computed({ get: () => 1 / value.value, set: (v) => value.value = 1 / v });\ninverse.value = 2;\nconsole.log(value.value);",
        "o": [
            "0.5",
            "2",
            "5",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` with a WeakMap in Vue.js 3?",
        "o": [
            "WeakMap keys are not reactive",
            "WeakMap is fully reactive",
            "WeakMap cannot be used with reactive",
            "WeakMap values lose reactivity"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ list: [1] });\nwatch(() => obj.list.length, (len) => console.log(len));\nobj.list.push(2);",
        "o": [
            "2",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the role of `pauseTracking` and `resumeTracking` in Vue.js 3?",
        "o": [
            "To temporarily disable and re-enable dependency tracking",
            "To pause and resume watchers",
            "To stop and start reactive effects",
            "To check tracking status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const flag = ref(false);\nconst computedVal = computed(() => !flag.value);\nflag.value = true;\nconsole.log(computedVal.value);",
        "o": [
            "false",
            "true",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for getters defined in a reactive object?",
        "o": [
            "Getters are reactive if they access reactive properties",
            "Getters are non-reactive by default",
            "Getters cannot be used in reactive objects",
            "Getters break reactivity"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const items = reactive(new Set(['a']));\nitems.add('b');\nconsole.log(items.size);",
        "o": [
            "2",
            "1",
            "0",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `reactive` when used with a Proxy object in Vue.js 3?",
        "o": [
            "It wraps the Proxy in a new reactive Proxy",
            "It unwraps the Proxy",
            "It throws an error",
            "It ignores the Proxy"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ inner: { num: 1 } });\nconst numRef = toRef(obj.inner, 'num');\nobj.inner = { num: 3 };\nconsole.log(numRef.value);",
        "o": [
            "undefined",
            "1",
            "3",
            "No output"
        ]
    },
    {
        "q": "What issue arises when using `reactive` with circular references in Vue.js 3?",
        "o": [
            "Circular references may cause infinite loops in reactivity",
            "Circular references are not reactive",
            "Circular references are automatically resolved",
            "Circular references throw errors"
        ]
    },
    {
        "q": "In Vue.js 3, what is the effect of using `reactive` on an already reactive object?",
        "o": [
            "It returns the same reactive proxy",
            "It creates a new reactive proxy",
            "It throws an error",
            "It makes the object non-reactive"
        ]
    },
    {
        "q": "What is the output of the following code when `state.data` is updated?",
        "c": "const state = reactive({ data: 0 });\nwatchEffect(() => console.log(state.data % 2), { flush: 'pre' });\nstate.data = 3;",
        "o": [
            "1",
            "0",
            "3",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of the `onTrack` option in Vue.js 3 watchers?",
        "o": [
            "To define a callback when a reactive dependency is tracked",
            "To pause dependency tracking",
            "To trigger manual updates",
            "To cleanup tracked dependencies"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const input = ref(10);\nconst scaled = computed({ get: () => input.value * 10, set: (v) => input.value = v / 10 });\nscaled.value = 50;\nconsole.log(input.value);",
        "o": [
            "5",
            "50",
            "10",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` with a frozen object in Vue.js 3?",
        "o": [
            "Frozen objects cannot be made reactive",
            "Frozen objects are reactive but immutable",
            "Frozen objects lose their frozen state",
            "Frozen objects cause errors in templates"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ count: 0 });\nwatch(() => obj.count, (newVal, oldVal) => console.log(oldVal));\nobj.count = 7;",
        "o": [
            "0",
            "7",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the role of `enableTracking` in Vue.js 3's reactivity system?",
        "o": [
            "To re-enable dependency tracking after being paused",
            "To enable watchers",
            "To track non-reactive dependencies",
            "To create a tracking scope"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const status = ref(true);\nconst label = computed(() => status.value ? 'Online' : 'Offline');\nstatus.value = false;\nconsole.log(label.value);",
        "o": [
            "Offline",
            "Online",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for computed properties with side effects?",
        "o": [
            "Side effects may cause unexpected recomputations",
            "Computed properties cannot have side effects",
            "Side effects are automatically reactive",
            "Side effects disable caching"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const queue = reactive(new Set([1, 2]));\nqueue.delete(1);\nconsole.log(queue.size);",
        "o": [
            "1",
            "2",
            "0",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `onTrigger` in Vue.js 3 watchers?",
        "o": [
            "To define a callback when a reactive dependency triggers an update",
            "To manually trigger watchers",
            "To stop dependency triggers",
            "To check trigger status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ inner: { value: 'a' } });\nconst valRef = toRef(obj.inner, 'value');\nobj.inner = { value: 'b' };\nconsole.log(valRef.value);",
        "o": [
            "undefined",
            "a",
            "b",
            "No output"
        ]
    },
    {
        "q": "What issue arises when using `reactive` with non-enumerable properties in Vue.js 3?",
        "o": [
            "Non-enumerable properties are not reactive",
            "Non-enumerable properties become enumerable",
            "Non-enumerable properties cause errors",
            "Non-enumerable properties are always reactive"
        ]
    },
    {
        "q": "In Vue.js 3, what happens when you use `reactive` on a primitive value?",
        "o": [
            "It throws an error as reactive only works with objects",
            "It creates a reactive primitive",
            "It wraps the primitive in a ref",
            "It ignores the value and returns null"
        ]
    },
    {
        "q": "What is the output of the following code when `state.level` is updated?",
        "c": "const state = reactive({ level: 1 });\nwatchEffect(() => console.log(Math.floor(state.level)), { flush: 'post' });\nstate.level = 2.7;",
        "o": [
            "2",
            "1",
            "2.7",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of the `once` option in Vue.js 3 watchers?",
        "o": [
            "To run the watcher callback only once on the first change",
            "To run the watcher only once on creation",
            "To stop the watcher after creation",
            "To make the watcher synchronous"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const num = ref(2);\nconst squareRoot = computed(() => Math.sqrt(num.value));\nnum.value = 16;\nconsole.log(squareRoot.value);",
        "o": [
            "4",
            "2",
            "16",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` with a Proxy that has custom traps in Vue.js 3?",
        "o": [
            "Custom traps may interfere with Vue’s reactivity tracking",
            "Custom traps are ignored",
            "Custom traps make the Proxy non-reactive",
            "Custom traps are automatically reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ count: 0 });\nwatch(() => obj.count, (newVal) => console.log(newVal * 3));\nobj.count = 5;\nobj.count = 6;",
        "o": [
            "15, 18",
            "0, 5, 6",
            "6",
            "No output"
        ]
    },
    {
        "q": "What is the role of `resetTracking` in Vue.js 3’s reactivity system?",
        "o": [
            "To clear the current dependency tracking state",
            "To reset watchers to their initial state",
            "To enable deep tracking",
            "To stop all reactive effects"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const active = ref(false);\nconst indicator = computed(() => active.value ? 'ON' : 'OFF');\nactive.value = true;\nconsole.log(indicator.value);",
        "o": [
            "ON",
            "OFF",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for properties added to a reactive object via `Object.defineProperty`?",
        "o": [
            "They are not reactive unless explicitly made so",
            "They are automatically reactive",
            "They cause the object to lose reactivity",
            "They throw an error"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const map = reactive(new Map([['key', 10]]));\nmap.delete('key');\nconsole.log(map.size);",
        "o": [
            "0",
            "1",
            "10",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `computed` with an object containing `get` and `set` in Vue.js 3?",
        "o": [
            "To create a writable computed property",
            "To create a readonly computed property",
            "To watch computed changes",
            "To disable computed caching"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const source = reactive({ inner: { data: 0 } });\nconst dataRef = toRef(source.inner, 'data');\nsource.inner = { data: 9 };\nconsole.log(dataRef.value);",
        "o": [
            "undefined",
            "0",
            "9",
            "No output"
        ]
    },
    {
        "q": "What issue arises when using `watch` with a reactive object and not specifying `deep: true`?",
        "o": [
            "Nested property changes are not detected",
            "The watcher only tracks primitive values",
            "The watcher throws an error",
            "The watcher becomes synchronous"
        ]
    },
    {
        "q": "In Vue.js 3, what happens when you use `toRef` on a non-reactive object?",
        "o": [
            "The ref is non-reactive but tracks the property",
            "It throws an error",
            "It makes the entire object reactive",
            "It returns a computed property"
        ]
    },
    {
        "q": "What is the output of the following code when `state.data` changes?",
        "c": "const state = reactive({ data: 1 });\nwatchEffect(() => console.log(state.data.toString()), { flush: 'sync' });\nstate.data = 2;",
        "o": [
            "2",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of the `lazy` option in Vue.js 3 computed properties?",
        "o": [
            "To prevent the computed property from evaluating until accessed",
            "To make the computed property readonly",
            "To enable synchronous updates",
            "To disable caching"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const input = ref(0);\nconst tripled = computed(() => input.value * 3);\ninput.value = 4;\nconsole.log(tripled.value);",
        "o": [
            "12",
            "0",
            "4",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` with a WeakSet in Vue.js 3?",
        "o": [
            "WeakSet contents are not reactive",
            "WeakSet becomes fully reactive",
            "WeakSet cannot be used with reactive",
            "WeakSet causes memory leaks"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ value: 0 });\nwatch(() => obj.value, (val, oldVal) => console.log(val - oldVal));\nobj.value = 10;",
        "o": [
            "10",
            "0",
            "-10",
            "No output"
        ]
    },
    {
        "q": "What is the role of `effectScope().run` in Vue.js 3?",
        "o": [
            "To execute a function within a new effect scope",
            "To run watchers synchronously",
            "To dispose all effects",
            "To check scope activity"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const enabled = ref(true);\nconst text = computed(() => enabled.value ? 'Active' : 'Inactive');\nenabled.value = false;\nconsole.log(text.value);",
        "o": [
            "Inactive",
            "Active",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for properties added dynamically via `Object.defineProperties`?",
        "o": [
            "They are not reactive unless explicitly added with Vue.set",
            "They are automatically reactive",
            "They cause the object to lose reactivity",
            "They are readonly by default"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const list = reactive(new Set(['x', 'y']));\nlist.add('z');\nlist.delete('x');\nconsole.log(list.size);",
        "o": [
            "2",
            "3",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `watchPostEffect` in Vue.js 3?",
        "o": [
            "To create a watcher that runs after DOM updates",
            "To create a synchronous watcher",
            "To stop post-effect watchers",
            "To check post-effect status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ nested: { count: 5 } });\nconst countRef = toRef(obj.nested, 'count');\nobj.nested = { count: 8 };\nconsole.log(countRef.value);",
        "o": [
            "undefined",
            "5",
            "8",
            "No output"
        ]
    },
    {
        "q": "What issue arises when using `watch` with a getter that returns a new object each time?",
        "o": [
            "The watcher may trigger unnecessarily due to object reference changes",
            "The watcher only tracks primitive returns",
            "The watcher throws an error",
            "The watcher ignores new objects"
        ]
    },
    {
        "q": "In Vue.js 3, what is the primary limitation of using getter/setter-based reactivity as in Vue 2?",
        "o": [
            "It cannot detect property additions or deletions",
            "It is slower than Proxy-based reactivity",
            "It only works with refs",
            "It requires compile-time transformations"
        ]
    },
    {
        "q": "What is the output of the following code when the inner value is mutated?",
        "c": "const shallow = shallowRef({ greet: 'Hello' });\nwatchEffect(() => console.log(shallow.value.greet));\nshallow.value.greet = 'Hi';\ntriggerRef(shallow);",
        "o": [
            "Hi",
            "Hello",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a key difference between runtime reactivity in Vue.js and compile-time reactivity in frameworks like Svelte?",
        "o": [
            "Vue.js performs tracking during code execution, while Svelte transforms code at build time",
            "Vue.js requires a build step, while Svelte does not",
            "Vue.js uses getter/setters exclusively, while Svelte uses Proxies",
            "Vue.js cannot track local variables, while Svelte can"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({});\nconst proxy = reactive(obj);\nconsole.log(obj === proxy);",
        "o": [
            "true",
            "false",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a reactivity caveat when destructuring properties from a reactive object in Vue.js 3?",
        "o": [
            "The destructured variables lose reactivity",
            "Destructuring makes the properties readonly",
            "Destructuring triggers immediate effects",
            "Destructuring is not supported"
        ]
    },
    {
        "q": "What is the output of the following code after the set operation?",
        "c": "function useDebouncedRef(value, delay = 200) {\n  let timeout;\n  return customRef((track, trigger) => ({\n    get() { track(); return value; },\n    set(newValue) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => { value = newValue; trigger(); }, delay);\n    }\n  }));\n}\nconst debounced = useDebouncedRef(0);\ndebounced.value = 10;\nconsole.log(debounced.value);",
        "o": [
            "10",
            "0",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `markRaw` in Vue.js 3?",
        "o": [
            "To mark an object as non-reactive, preventing conversion to a proxy",
            "To create a raw copy of a reactive object",
            "To trigger raw updates in shallow refs",
            "To check if an object is raw"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = shallowReactive({ count: 1, nested: { value: 2 } });\nstate.nested.value = 3;\nconsole.log(state.nested.value);",
        "o": [
            "3",
            "2",
            "1",
            "undefined"
        ]
    },
    {
        "q": "Why was the Reactivity Transform feature in Vue.js made experimental and not pursued further?",
        "o": [
            "It did not fit well with the project's goals and introduced non-standard syntax",
            "It was slower than Proxy-based reactivity",
            "It only worked with local variables",
            "It required additional build tools"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const original = { count: 0 };\nconst reactiveObj = reactive(original);\nconsole.log(original === reactiveObj);",
        "o": [
            "false",
            "true",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is a unique use case for `shallowRef` in Vue.js 3?",
        "o": [
            "Integrating with external immutable data systems like Immer for undo/redo",
            "Creating deeply reactive primitives",
            "Automatically unwrapping refs in templates",
            "Watching non-reactive data"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const shallowMap = shallowReactive(new Map());\nshallowMap.set('key', { nested: 1 });\nshallowMap.get('key').nested = 2;\nconsole.log(shallowMap.get('key').nested);",
        "o": [
            "2",
            "1",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What caveat should be considered when using `customRef` in Vue.js 3 for parent-child component props?",
        "o": [
            "Returning new object types in the getter can cause unnecessary updates in child components",
            "Custom refs cannot be passed as props",
            "Setters are ignored in props",
            "Getters must be synchronous"
        ]
    },
    {
        "q": "In Vue.js 3, what happens when you attempt to nest a `reactive` object inside another `reactive` object?",
        "o": [
            "The nested object is automatically made reactive",
            "The nested object remains non-reactive",
            "It throws an error",
            "The outer object loses reactivity"
        ]
    },
    {
        "q": "What is the output of the following code when `state.items` is modified?",
        "c": "const state = reactive({ items: [0] });\nwatchEffect(() => console.log(state.items.join('-')), { flush: 'sync' });\nstate.items[0] = 1;",
        "o": [
            "1",
            "0",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of the `debug` option in Vue.js 3 computed properties?",
        "o": [
            "To enable logging for dependency tracking and triggering",
            "To disable computed caching",
            "To force synchronous evaluation",
            "To check computed validity"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const x = ref(5);\nconst y = ref(3);\nconst product = computed(() => x.value * y.value);\ny.value = 4;\nconsole.log(product.value);",
        "o": [
            "20",
            "15",
            "5",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when using `reactive` with a Map containing reactive objects as values?",
        "o": [
            "Changes to reactive objects inside the Map are tracked",
            "Map entries are non-reactive",
            "Maps cannot contain reactive objects",
            "Map keys become reactive"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const obj = reactive({ flag: false });\nwatch(() => obj.flag, (newVal) => console.log(newVal ? 'True' : 'False'));\nobj.flag = true;",
        "o": [
            "True",
            "False",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the role of `stop` method returned by `effectScope` in Vue.js 3?",
        "o": [
            "To stop all effects within the scope",
            "To pause effect tracking",
            "To restart stopped effects",
            "To check effect status"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const toggle = ref(false);\nconst state = computed(() => toggle.value ? 'Up' : 'Down');\ntoggle.value = true;\nconsole.log(state.value);",
        "o": [
            "Up",
            "Down",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3 handle reactivity for computed properties that depend on multiple refs?",
        "o": [
            "Updates when any dependent ref changes",
            "Only updates if all refs change",
            "Ignores multiple ref dependencies",
            "Requires manual triggering"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const set = reactive(new Set([1, 2, 3]));\nset.clear();\nconsole.log(set.size);",
        "o": [
            "0",
            "3",
            "1",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `watchSyncEffect` in Vue.js 3?",
        "o": [
            "To create a watcher that runs synchronously",
            "To create a post-effect watcher",
            "To stop synchronous effects",
            "To check effect synchronization"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const data = reactive({ inner: { val: 10 } });\nconst valRef = toRef(data.inner, 'val');\ndata.inner = { val: 20 };\nconsole.log(valRef.value);",
        "o": [
            "undefined",
            "10",
            "20",
            "No output"
        ]
    },
    {
        "q": "What issue arises when using `watchEffect` with a dependency that is conditionally accessed?",
        "o": [
            "The watcher may not track the dependency if not accessed initially",
            "Conditional access disables reactivity",
            "The watcher always tracks all dependencies",
            "Conditional access causes errors"
        ]
    },
    {
        "q": "In Vue.js 3, what is the behavior of `toRefs` when applied to a reactive object?",
        "o": [
            "It creates a shallow object with each property as a ref",
            "It makes the object non-reactive",
            "It creates a deep copy of refs",
            "It throws an error on non-reactive objects"
        ]
    },
    {
        "q": "What is the output of the following code when `obj.a` and `obj.b` are updated?",
        "c": "const obj = reactive({ a: 1, b: 2 });\nwatchEffect(() => console.log(obj.a - obj.b));\nobj.a = 5;\nobj.b = 3;",
        "o": [
            "2",
            "-1",
            "1",
            "No output"
        ]
    },
    {
        "q": "What is a key difference between `watch` and `watchEffect` in terms of dependency tracking?",
        "o": [
            "watchEffect automatically tracks dependencies, while watch requires explicit specification",
            "watch tracks dynamically, while watchEffect is static",
            "watchEffect only works with refs, watch with reactive",
            "watch is immediate by default, watchEffect is not"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const val = ref(10);\nconst halved = computed(() => val.value / 2);\nval.value = 20;\nconsole.log(halved.value);",
        "o": [
            "10",
            "5",
            "20",
            "undefined"
        ]
    },
    {
        "q": "What is a reactivity caveat when assigning a new array to a reactive property in Vue.js 3?",
        "o": [
            "The assignment is reactive if using array methods",
            "Direct assignment of new array is reactive",
            "New array must be wrapped in reactive",
            "Assignment breaks reactivity unless using Vue.set"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const state = reactive({ active: true });\nwatch(() => state.active, (val) => console.log(val));\nstate.active = false;",
        "o": [
            "false",
            "true",
            "undefined",
            "No output"
        ]
    },
    {
        "q": "What is the purpose of `unref` in Vue.js 3?",
        "o": [
            "To get the value of a ref or return the value if not a ref",
            "To make a value non-reactive",
            "To create a new ref",
            "To check reactivity"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const loading = ref(true);\nconst message = computed(() => loading.value ? 'Please wait' : 'Done');\nloading.value = false;\nconsole.log(message.value);",
        "o": [
            "Done",
            "Please wait",
            "true",
            "false"
        ]
    },
    {
        "q": "How does Vue.js 3's reactivity system treat `NaN` as a property value?",
        "o": [
            "NaN is treated as a changed value even if assigned NaN again",
            "NaN assignments do not trigger updates",
            "NaN breaks reactivity",
            "NaN is converted to null"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const collection = reactive(new Map([['a', 1], ['b', 2]]));\ncollection.delete('a');\nconsole.log(collection.size);",
        "o": [
            "1",
            "2",
            "0",
            "undefined"
        ]
    },
    {
        "q": "What is the purpose of `watchPreEffect` in Vue.js 3?",
        "o": [
            "To create a watcher that runs before DOM updates",
            "To create a post-DOM watcher",
            "To stop pre-effect watchers",
            "To synchronize effects"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "const parent = reactive({ child: { num: 1 } });\nconst numRef = toRef(parent.child, 'num');\nparent.child = { num: 4 };\nconsole.log(numRef.value);",
        "o": [
            "undefined",
            "1",
            "4",
            "No output"
        ]
    },
    {
        "q": "What issue can occur when a watcher modifies its own dependencies in Vue.js 3?",
        "o": [
            "It may cause an infinite loop",
            "The watcher stops automatically",
            "The dependency becomes non-reactive",
            "The watcher ignores self-changes"
        ]
    }
]