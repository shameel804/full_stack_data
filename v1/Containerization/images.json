[
    {
        "q": "What is a Docker image?",
        "o": [
            "A read-only template for creating containers",
            "A running instance of a container",
            "A virtual machine",
            "A database file"
        ]
    },
    {
        "q": "What is a Docker image composed of?",
        "o": [
            "A series of read-only layers",
            "A single binary file",
            "Source code only",
            "A text file"
        ]
    },
    {
        "q": "Which command lists local images?",
        "o": [
            "docker images",
            "docker list",
            "docker show",
            "docker ls"
        ]
    },
    {
        "q": "How do you download an image from a registry?",
        "o": [
            "docker pull",
            "docker get",
            "docker fetch",
            "docker download"
        ]
    },
    {
        "q": "What is the default tag if none is specified?",
        "o": [
            "latest",
            "stable",
            "src",
            "dev"
        ]
    },
    {
        "q": "Where are Docker images stored by default?",
        "o": [
            "/var/lib/docker",
            "/usr/local/docker",
            "/etc/docker",
            "/home/docker"
        ]
    },
    {
        "q": "What is an image layer?",
        "o": [
            "A filesystem delta",
            "A container process",
            "A text configuration",
            "A network interface"
        ]
    },
    {
        "q": "Are Docker images mutable?",
        "o": [
            "No, they are immutable",
            "Yes, always",
            "Only base layers",
            "Only metadata"
        ]
    },
    {
        "q": "What is a Docker registry?",
        "o": [
            "A repository for storing images",
            "A container orchestrator",
            "A network driver",
            "A log analyzer"
        ]
    },
    {
        "q": "What is the public implementation of a registry?",
        "o": [
            "Docker Hub",
            "Docker Local",
            "Docker Compose",
            "Docker Swarm"
        ]
    },
    {
        "q": "How do you tag an image?",
        "o": [
            "docker tag source target",
            "docker rename source target",
            "docker copy source target",
            "docker label source target"
        ]
    },
    {
        "q": "What is the format of an image name?",
        "o": [
            "repository:tag",
            "name:version",
            "repo-tag",
            "name.tag"
        ]
    },
    {
        "q": "Which command removes an image?",
        "o": [
            "docker rmi",
            "docker rm",
            "docker delete",
            "docker erase"
        ]
    },
    {
        "q": "What happens if you pull an existing image?",
        "o": [
            "Updates layers if changed",
            "Duplicates it",
            "Fails",
            "Overwrites completely"
        ]
    },
    {
        "q": "How do you see the history of an image?",
        "o": [
            "docker history",
            "docker log",
            "docker trace",
            "docker show"
        ]
    },
    {
        "q": "What is a base image?",
        "o": [
            "An image with no parent",
            "The latest image",
            "A custom image",
            "A small image"
        ]
    },
    {
        "q": "Which instruction defines the base image?",
        "o": [
            "FROM",
            "BASE",
            "START",
            "ROOT"
        ]
    },
    {
        "q": "What is a parent image?",
        "o": [
            "The image your image builds upon",
            "Your final image",
            "A sidecar image",
            "A helper image"
        ]
    },
    {
        "q": "What is the advantage of layers?",
        "o": [
            "Reuse and caching",
            "Speed only",
            "Security only",
            "Size increase"
        ]
    },
    {
        "q": "How do you push an image to a registry?",
        "o": [
            "docker push",
            "docker upload",
            "docker send",
            "docker save"
        ]
    },
    {
        "q": "What is a dangling image?",
        "o": [
            "An image with no repository reference",
            "A broken image",
            "A running image",
            "A pulled image"
        ]
    },
    {
        "q": "How are dangling images normally created?",
        "o": [
            "Overwriting a tag with a newer build",
            "Deleting a container",
            "Pulling an error",
            "System crash"
        ]
    },
    {
        "q": "Which command removes dangling images?",
        "o": [
            "docker image prune",
            "docker rm dangling",
            "docker clean images",
            "docker tidy"
        ]
    },
    {
        "q": "What is a multi-stage build?",
        "o": [
            "Using multiple FROM instructions to minimize size",
            "Building multiple images at once",
            "Building in parallel",
            "Building for multiple os"
        ]
    },
    {
        "q": "Why use multi-stage builds?",
        "o": [
            "To reduce final image size",
            "To increase build speed",
            "To add complexity",
            "To use more disk"
        ]
    },
    {
        "q": "Can you name a build stage?",
        "o": [
            "Yes, using AS name",
            "No, stages are numbered only",
            "Yes, using LABEL",
            "No, stages are anonymous"
        ]
    },
    {
        "q": "How do you copy from a previous stage?",
        "o": [
            "COPY --from=stage",
            "COPY stage",
            "FROM stage COPY",
            "IMPORT stage"
        ]
    },
    {
        "q": "What is 'scratch'?",
        "o": [
            "An empty base image",
            "A temp file",
            "A cache dir",
            "A script"
        ]
    },
    {
        "q": "When would you use 'FROM scratch'?",
        "o": [
            "For minimal binaries",
            "For web servers",
            "For databases",
            "Never"
        ]
    },
    {
        "q": "What is the size of 'scratch'?",
        "o": [
            "0 bytes",
            "1 KB",
            "1 MB",
            "4 KB"
        ]
    },
    {
        "q": "How do you inspect image metadata?",
        "o": [
            "docker inspect",
            "docker metadata",
            "docker info",
            "docker show"
        ]
    },
    {
        "q": "What does image ID represent?",
        "o": [
            "SHA256 hash of config",
            "Random string",
            "Date created",
            "File size"
        ]
    },
    {
        "q": "Are layers shared between images?",
        "o": [
            "Yes, if identical",
            "No, never",
            "Only for same repo",
            "Only in swarm"
        ]
    },
    {
        "q": "What is a manifest?",
        "o": [
            "Description of image and layers",
            "List of containers",
            "A log file",
            "A password file"
        ]
    },
    {
        "q": "How do you login to a registry?",
        "o": [
            "docker login",
            "docker auth",
            "docker signin",
            "docker connect"
        ]
    },
    {
        "q": "Where are registry credentials stored?",
        "o": [
            "~/.docker/config.json",
            "~/.docker/creds",
            "/etc/docker/auth",
            "In memory only"
        ]
    },
    {
        "q": "How do you logout from a registry?",
        "o": [
            "docker logout",
            "docker disconnect",
            "docker signout",
            "docker exit"
        ]
    },
    {
        "q": "Can you have multiple tags for one image ID?",
        "o": [
            "Yes",
            "No",
            "Only one",
            "Max two"
        ]
    },
    {
        "q": "How do you delete by image ID?",
        "o": [
            "docker rmi id",
            "docker delete id",
            "docker rm id",
            "docker clean id"
        ]
    },
    {
        "q": "What happens if you delete an image ID used by multiple tags?",
        "o": [
            "Untags it until last tag is removed",
            "Deletes all tags",
            "Error",
            "Warning"
        ]
    },
    {
        "q": "How do you save an image to a tar file?",
        "o": [
            "docker save",
            "docker export",
            "docker backup",
            "docker tar"
        ]
    },
    {
        "q": "How do you load an image from a tar file?",
        "o": [
            "docker load",
            "docker import",
            "docker restore",
            "docker unzip"
        ]
    },
    {
        "q": "What is the difference between save and export?",
        "o": [
            "Save images, export containers",
            "Save containers, export images",
            "No difference",
            "Save is faster"
        ]
    },
    {
        "q": "Which saves layer history?",
        "o": [
            "docker save",
            "docker export",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "Which creates a flat filesystem?",
        "o": [
            "docker export",
            "docker save",
            "Both",
            "Neither"
        ]
    },
    {
        "q": "What creates a digest?",
        "o": [
            "Content hash",
            "Timestamp",
            "User ID",
            "Random"
        ]
    },
    {
        "q": "Are digests immutable?",
        "o": [
            "Yes",
            "No",
            "Sometimes",
            "Maybe"
        ]
    },
    {
        "q": "Can you pull by digest?",
        "o": [
            "Yes",
            "No",
            "Only local",
            "Only remote"
        ]
    },
    {
        "q": "Why pull by digest?",
        "o": [
            "To guarantee exact content",
            "To be faster",
            "To be smaller",
            "To be secure"
        ]
    },
    {
        "q": "What is an Alpine image?",
        "o": [
            "A lightweight Linux distro",
            "A heavy image",
            "A Windows image",
            "A Mac image"
        ]
    },
    {
        "q": "Why use Alpine?",
        "o": [
            "Small size",
            "More tools",
            " Better GUI",
            "Faster CPU"
        ]
    },
    {
        "q": "What package manager does Alpine use?",
        "o": [
            "apk",
            "apt",
            "yum",
            "dnf"
        ]
    },
    {
        "q": "What is 'windowsservercore'?",
        "o": [
            "Base image for Windows containers",
            "Linux image",
            "Mac image",
            "Tool image"
        ]
    },
    {
        "q": "Can Linux images run on Windows directly?",
        "o": [
            "No, needs WSL or VM",
            "Yes",
            "Maybe",
            "Only small ones"
        ]
    },
    {
        "q": "What is a private registry?",
        "o": [
            "Internal image storage",
            "Public Hub",
            "Offline disk",
            "USB drive"
        ]
    },
    {
        "q": "How do you run a local registry?",
        "o": [
            "docker run registry",
            "docker start reg",
            "docker init registry",
            "registry start"
        ]
    },
    {
        "q": "What port does default registry use?",
        "o": [
            "5000",
            "8080",
            "3000",
            "80"
        ]
    },
    {
        "q": "How do you verify an image signature?",
        "o": [
            "Docker Content Trust",
            "Check MD5",
            "Check size",
            "Look at tag"
        ]
    },
    {
        "q": "What environment variable enables Content Trust?",
        "o": [
            "DOCKER_CONTENT_TRUST",
            "DOCKER_SIGN",
            "DOCKER_SECURE",
            "TRUST_DOCKER"
        ]
    },
    {
        "q": "What happens if Content Trust is on and image has no signature?",
        "o": [
            "Pull fails",
            "Pull warns",
            "Pull continues",
            "Pull asks"
        ]
    },
    {
        "q": "What is a 'slim' image variant?",
        "o": [
            "Minimized version of standard image",
            "Full version",
            "Debug version",
            "Old version"
        ]
    },
    {
        "q": "What is 'onbuild' variant?",
        "o": [
            "Includes ONBUILD triggers",
            "Builds instantly",
            "For CI only",
            "Deprecated"
        ]
    },
    {
        "q": "When does ONBUILD instruction execute?",
        "o": [
            "When used as base for another build",
            "During current build",
            "At runtime",
            "Never"
        ]
    },
    {
        "q": "What is the Copy-on-Write strategy?",
        "o": [
            "Copy file to upper layer before modify",
            "Modify in place",
            "Delete and recreate",
            "Append only"
        ]
    },
    {
        "q": "Where is the writeable layer?",
        "o": [
            "Topmost layer (container)",
            "Bottom layer",
            "Middle layer",
            "External drive"
        ]
    },
    {
        "q": "How do you clean up unused images?",
        "o": [
            "docker image prune",
            "docker clean",
            "docker rm unused",
            "docker wipe"
        ]
    },
    {
        "q": "What does -a flag do in image prune?",
        "o": [
            "Removes all unused, not just dangling",
            "Removes all",
            "Removes active",
            "Removes arrays"
        ]
    },
    {
        "q": "How do you see image size in list?",
        "o": [
            "Shown by default",
            "Use --size",
            "Use -s",
            "Use -v"
        ]
    },
    {
        "q": "How do you filter images list?",
        "o": [
            "--filter",
            "--select",
            "--where",
            "--grep"
        ]
    },
    {
        "q": "How do you filter by dangling status?",
        "o": [
            "-f dangling=true",
            "-f status=dangling",
            "--dangling",
            "--loose"
        ]
    },
    {
        "q": "How do you filter by reference?",
        "o": [
            "-f reference=pattern",
            "-f name=pattern",
            "-f tag=pattern",
            "--ref"
        ]
    },
    {
        "q": "Can you format the output of docker images?",
        "o": [
            "Yes, using --format",
            "No",
            "Only to JSON",
            "Only to XML"
        ]
    },
    {
        "q": "What Go template prints ID only?",
        "o": [
            "{{.ID}}",
            "{{.Id}}",
            "{{id}}",
            "{{hash}}"
        ]
    },
    {
        "q": "How do you flatten an image?",
        "o": [
            "Export then Import",
            "Save then Load",
            "Squash command",
            "Zip it"
        ]
    },
    {
        "q": "What is 'squash' (experimental)?",
        "o": [
            "Merges layers into one",
            "Deletes layers",
            "Compresses layers",
            "Encrypts layers"
        ]
    },
    {
        "q": "Why avoid very large images?",
        "o": [
            "Slow pull/push, storage cost",
            "They crash",
            "They are insecure",
            "They are forbidden"
        ]
    },
    {
        "q": "What is the benefit of small images?",
        "o": [
            "Faster deployment, less surface attack",
            "Look better",
            "Easier to name",
            "More layers"
        ]
    },
    {
        "q": "Which tool analyzes image contents?",
        "o": [
            "dive",
            "peek",
            "look",
            "scan"
        ]
    },
    {
        "q": "How do you remove intermediate containers after build?",
        "o": [
            "Default behavior (or --force-rm)",
            "Cannot remove",
            "Manual only",
            "Restart daemon"
        ]
    },
    {
        "q": "What is an untagged image?",
        "o": [
            "Image with <none>:<none>",
            "Image with name only",
            "Image with tag only",
            "Hidden image"
        ]
    },
    {
        "q": "Is an untagged image always dangling?",
        "o": [
            "Only if it has no children",
            "Yes always",
            "No never",
            "Depends on size"
        ]
    },
    {
        "q": "Can you restore a deleted image?",
        "o": [
            "No, unless backed up",
            "Yes from recycle bin",
            "Yes using undo",
            "Yes using restore"
        ]
    },
    {
        "q": "How do you modify an image?",
        "o": [
            "Run container, change, commit",
            "Edit binary",
            "Modify layer file",
            "Use editor"
        ]
    },
    {
        "q": "What does docker commit do?",
        "o": [
            "Creates new image from container changes",
            "Saves code",
            "Pushes to git",
            "Stops container"
        ]
    },
    {
        "q": "Is 'docker commit' recommended for production builds?",
        "o": [
            "No, use Dockerfile",
            "Yes",
            "Sometimes",
            "For bases only"
        ]
    },
    {
        "q": "Why prefer Dockerfile over commit?",
        "o": [
            "Reproducibility and version control",
            "Faster",
            "Smaller",
            "Easier"
        ]
    },
    {
        "q": "Can you add a comment to a commit?",
        "o": [
            "Yes, -m",
            "No",
            "Only author",
            "Only date"
        ]
    },
    {
        "q": "Can you change AUTHOR in commit?",
        "o": [
            "Yes, -a",
            "No",
            "Only in registry",
            "Only in Dockerfile"
        ]
    },
    {
        "q": "How do you search for images on Hub?",
        "o": [
            "docker search",
            "docker find",
            "docker lookup",
            "docker seek"
        ]
    },
    {
        "q": "How do you filter search results by stars?",
        "o": [
            "--filter stars=N",
            "--stars N",
            "-s N",
            "--min-stars N"
        ]
    },
    {
        "q": "How do you limit search results?",
        "o": [
            "--limit",
            "-l",
            "--max",
            "--count"
        ]
    },
    {
        "q": "What indicates an official image in search?",
        "o": [
            "OFFICIAL column [OK]",
            "Star count",
            "Name starts with docker",
            "Gold icon"
        ]
    },
    {
        "q": "What is the 'automated' column in search?",
        "o": [
            "Built automatically from source",
            "Bot account",
            "AI generated",
            "Scheduled"
        ]
    },
    {
        "q": "Can you tag a local image into a private registry repo?",
        "o": [
            "Yes, hostname:port/name:tag",
            "No",
            "Only public",
            "Only hub"
        ]
    },
    {
        "q": "What happens if you push 'name:tag' without registry host?",
        "o": [
            "Pushes to Docker Hub",
            "Error",
            "Pushes to local",
            "Discards"
        ]
    },
    {
        "q": "How do you build specific stage in multi-stage?",
        "o": [
            "--target stageName",
            "--stage stageName",
            "--stop-at stageName",
            "--only stageName"
        ]
    },
    {
        "q": "Can you COPY between external images in Dockerfile?",
        "o": [
            "Yes, COPY --from=image",
            "No",
            "Only local",
            "Only stages"
        ]
    },
    {
        "q": "What does 'distroless' mean?",
        "o": [
            "Images containing only app and dependencies, no shell",
            "No OS kernel",
            "No config",
            "No network"
        ]
    },
    {
        "q": "Why use distroless?",
        "o": [
            "Security and size",
            "Ease of debug",
            "Compatibility",
            "Speed"
        ]
    },
    {
        "q": "How do you debug distroless?",
        "o": [
            "Use debug image variant or ephemeral containers",
            "SSH",
            "docker exec bash",
            "Not possible"
        ]
    },
    {
        "q": "What command lists all local images with their digests?",
        "o": [
            "docker images --digests",
            "docker images -v",
            "docker list digests",
            "docker show sha"
        ]
    },
    {
        "q": "Which registry is used by default if none specified?",
        "o": [
            "docker.io (Docker Hub)",
            "gcr.io",
            "quay.io",
            "localhost"
        ]
    },
    {
        "q": "How do you tag an image for GCR (Google Container Registry)?",
        "o": [
            "gcr.io/project-id/image-name:tag",
            "docker.gcr/image:tag",
            "google.io/image:tag",
            "image:gcr"
        ]
    },
    {
        "q": "What is the structure of a multi-architecture image?",
        "o": [
            "Manifest list pointing to platform-specific manifests",
            "Single binary with all architectures",
            "Zipped file",
            "Folder structure"
        ]
    },
    {
        "q": "How do you create a multi-arch image?",
        "o": [
            "docker buildx build --platform ...",
            "docker build --arch ...",
            "docker multi-build",
            "Compile manually"
        ]
    },
    {
        "q": "What command inspects a manifest list?",
        "o": [
            "docker manifest inspect",
            "docker inspect manifest",
            "docker show list",
            "docker check manifest"
        ]
    },
    {
        "q": "How do you push a manifest list?",
        "o": [
            "docker manifest push",
            "docker push list",
            "docker upload manifest",
            "docker send list"
        ]
    },
    {
        "q": "What is a 'fat' manifest?",
        "o": [
            "Another name for manifest list",
            "A large image",
            "An uncompressed manifest",
            "A binary manifest"
        ]
    },
    {
        "q": "Which tool allows modifying image config without running it?",
        "o": [
            "crane (or similar registry tools)",
            "docker edit",
            "docker mod",
            "docker change"
        ]
    },
    {
        "q": "What is the OCI Image Spec?",
        "o": [
            "Open standard for container images",
            "Docker proprietary format",
            "Linux kernel spec",
            "Network protocol"
        ]
    },
    {
        "q": "What layer contains the container's changes?",
        "o": [
            "The thin read-write layer on top",
            "The bottom layer",
            "The shared layer",
            "All layers"
        ]
    },
    {
        "q": "Why is the read-write layer performance lower than volumes?",
        "o": [
            "CoW verification and storage driver overhead",
            "Network latency",
            "Encryption",
            "Compression"
        ]
    },
    {
        "q": "How can you view the size of the read-write layer?",
        "o": [
            "docker ps -s",
            "docker rw-size",
            "docker layer size",
            "docker inspect size"
        ]
    },
    {
        "q": "What does 'virtual size' mean in docker ps?",
        "o": [
            "Total size of image + rw layer",
            "Size of rw layer only",
            "Size in RAM",
            "Size on network"
        ]
    },
    {
        "q": "How do you avoid caching a specific build step?",
        "o": [
            "Use ARG with a changing value (like date) before it",
            "Use --no-cache",
            "Use CACHE=false",
            "Use SKIP instruction"
        ]
    },
    {
        "q": "What happens when you change a base image tag in Dockerfile?",
        "o": [
            "Cache is invalidated from FROM instruction down",
            "Only base layer updates",
            "Nothing happens until pull",
            "Build fails"
        ]
    },
    {
        "q": "Does 'COPY .' verify file checksums?",
        "o": [
            "Yes, triggers cache invalidation if content changes",
            "No, checks size only",
            "No, checks date only",
            "Yes, checks name only"
        ]
    },
    {
        "q": "How do you preserve file timestamps in COPY?",
        "o": [
            "Not supported by default (requires BuildKit)",
            "Use --preserve",
            "Use -t",
            "Automatic"
        ]
    },
    {
        "q": "What build option allows accessing secrets without saving them?",
        "o": [
            "--mount=type=secret",
            "--secret-file",
            "--env-secret",
            "--hidden-arg"
        ]
    },
    {
        "q": "How do you use a secret in RUN instruction?",
        "o": [
            "RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret",
            "RUN eco $SECRET",
            "RUN use-secret",
            "RUN import-secret"
        ]
    },
    {
        "q": "What is the benefit of 'COPY --link' (BuildKit)?",
        "o": [
            "Creates independent layers, better caching",
            "Links files",
            "Copies symlinks",
            "Faster I/O"
        ]
    },
    {
        "q": "How do you execute a build context from git?",
        "o": [
            "docker build https://github.com/user/repo.git",
            "docker build git:repo",
            "docker git build",
            "git clone | docker build"
        ]
    },
    {
        "q": "Can you build from a specific git branch?",
        "o": [
            "Yes, append #branch",
            "No",
            "Use --branch",
            "Use -b"
        ]
    },
    {
        "q": "How do you specify a subdirectory in git build context?",
        "o": [
            "append :subdirectory",
            "--dir",
            "--subdir",
            "Not possible"
        ]
    },
    {
        "q": "What is '.dockerignore'?",
        "o": [
            "File to exclude files from build context",
            "File to ignore errors",
            "File to ignore logs",
            "File to ignore updates"
        ]
    },
    {
        "q": "Why use .dockerignore?",
        "o": [
            "Faster context transfer, security, smaller cache",
            "Better syntax",
            "Required by daemon",
            "Cleaner code"
        ]
    },
    {
        "q": "Does .dockerignore apply to COPY instructions?",
        "o": [
            "Yes, ignored files cannot be copied",
            "No, only for context upload",
            "Only for ADD",
            "Only for RUN"
        ]
    },
    {
        "q": "How do you copy a file but exclude it in .dockerignore?",
        "o": [
            "You cannot (must use !exception in .dockerignore)",
            "Use --force",
            "Use -f",
            "Use ADD"
        ]
    },
    {
        "q": "What does 'SHELL' instruction do?",
        "o": [
            "Changes the default shell for RUN instructions",
            "Opens a terminal",
            "Sets login shell",
            "Creates a script"
        ]
    },
    {
        "q": "How do you set Windows shell to PowerShell?",
        "o": [
            "SHELL [\"powershell\", \"-command\"]",
            "SHELL powershell",
            "FROM powershell",
            "USE powershell"
        ]
    },
    {
        "q": "What is the default shell on Linux?",
        "o": [
            "[\"/bin/sh\", \"-c\"]",
            "[\"/bin/bash\", \"-c\"]",
            "zsh",
            "fish"
        ]
    },
    {
        "q": "How do you heredoc in Dockerfile?",
        "o": [
            "RUN <<EOF ... EOF",
            "RUN \"\"\" ... \"\"\"",
            "RUN ( ... )",
            "RUN { ... }"
        ]
    },
    {
        "q": "What requires BuildKit for heredocs?",
        "o": [
            "Yes, new syntax features require BuildKit",
            "No, standard feature",
            "Only for COPY",
            "Only for ADD"
        ]
    },
    {
        "q": "How do you create a file content directly in Dockerfile?",
        "o": [
            "COPY <<EOF /path/to/file",
            "RUN echo > file",
            "ADD content file",
            "WRITE file"
        ]
    },
    {
        "q": "What is an 'ephemeral' container?",
        "o": [
            "Temporary container for a short task",
            "Long running server",
            "Database container",
            "Backup container"
        ]
    },
    {
        "q": " How do you auto-remove container after exit?",
        "o": [
            "--rm",
            "--del",
            "--clean",
            "--temp"
        ]
    },
    {
        "q": "Which command saves an image to a tarball stream?",
        "o": [
            "docker save image > file.tar",
            "docker export image",
            "docker stream image",
            "docker dump"
        ]
    },
    {
        "q": "How do you list images showing only specific format?",
        "o": [
            "--format",
            "--show",
            "--view",
            "--print"
        ]
    },
    {
        "q": "How do you inspect image hierarchy locally?",
        "o": [
            "docker history",
            "docker tree",
            "docker graph",
            "docker deps"
        ]
    },
    {
        "q": "What signifies a missing layer in history?",
        "o": [
            "<missing>",
            "<null>",
            "<void>",
            "<empty>"
        ]
    },
    {
        "q": "Why do some layers show <missing>?",
        "o": [
            "They were built on another system (build history not preserved fully)",
            "They are potential errors",
            "They are secret",
            "They are deleted"
        ]
    },
    {
        "q": "How do you assign multiple tags to the same build?",
        "o": [
            "-t tag1 -t tag2",
            "--tag tag1,tag2",
            "tag1 tag2",
            "Cannot do it"
        ]
    },
    {
        "q": "What is the 'latest' tag best practice?",
        "o": [
            "Avoid in production (be specific)",
            "Always use it",
            "Use for backups only",
            "It is deprecated"
        ]
    },
    {
        "q": "Why avoid 'latest' in production?",
        "o": [
            "Unpredictable versioning and rollback issues",
            "It is slower",
            "It is insecure",
            "It takes more space"
        ]
    },
    {
        "q": "What is semantic versioning for tags?",
        "o": [
            "major.minor.patch",
            "date-time",
            "build-number",
            "hash"
        ]
    },
    {
        "q": "How do you ensure you are pulling the exact same image content?",
        "o": [
            "Pull by digest (sha256)",
            "Pull by tag",
            "Pull by name",
            "Pull by date"
        ]
    },
    {
        "q": "Can different tags point to the same digest?",
        "o": [
            "Yes",
            "No",
            "Only locally",
            "Only remotely"
        ]
    },
    {
        "q": "How do you retag an image locally?",
        "o": [
            "docker tag old new",
            "docker rename old new",
            "docker move old new",
            "docker switch old new"
        ]
    },
    {
        "q": " Does retagging duplicate the image data?",
        "o": [
            "No, creates a pointer/alias",
            "Yes",
            "Only metadata",
            "Only small layers"
        ]
    },
    {
        "q": "How do you push all tags of an image?",
        "o": [
            "docker push -a repo",
            "docker push --all-tags",
            "docker push *",
            "docker upload all"
        ]
    },
    {
        "q": "What registry auth method is most secure?",
        "o": [
            "Access Tokens",
            "Password",
            "None",
            "IP Allowlist"
        ]
    },
    {
        "q": "How do you use a credential helper?",
        "o": [
            "Configured in config.json (credsStore)",
            "Run helper manually",
            "Pass as flag",
            "Install plugin"
        ]
    },
    {
        "q": "What is a common credential helper on Mac?",
        "o": [
            "docker-credential-osxkeychain",
            "docker-pass",
            "docker-creds",
            "docker-keychain"
        ]
    },
    {
        "q": "What does 'FROM python:3.9-alpine' mean?",
        "o": [
            "Python 3.9 installed on Alpine Linux base",
            "Python source code",
            "Alpine installer",
            "Script"
        ]
    },
    {
        "q": " Which base image is best for compliance?",
        "o": [
            "Minimal, scanned, supported (e.g., UBI, Distroless)",
            "Latest Ubuntu",
            "Arch Linux",
            "Scratch"
        ]
    },
    {
        "q": "How do you scan an image for vulnerabilities locally?",
        "o": [
            "docker scan (or scout)",
            "docker security",
            "docker check",
            "docker audit"
        ]
    },
    {
        "q": "What is Docker Scout?",
        "o": [
            "Tool for analyzing image contents and security",
            "A monitoring tool",
            "A logging tool",
            "A network tool"
        ]
    },
    {
        "q": "How do you install certificates in an image?",
        "o": [
            "COPY cert.crt /usr/local/share/ca-certificates/ ; RUN update-ca-certificates",
            "ENV CERT=...",
            "Just COPY to /tmp",
            "Mount at runtime only"
        ]
    },
    {
        "q": "Why clean package manager cache in same RUN layer?",
        "o": [
            "To reduce layer size (files deleted in later layer still exist in history)",
            "To be polite",
            "To speed up build",
            "To prevent errors"
        ]
    },
    {
        "q": "Example of cleaning cache in apt?",
        "o": [
            "apt-get clean && rm -rf /var/lib/apt/lists/*",
            "apt-get remove",
            "apt-get purge",
            "rm cache"
        ]
    },
    {
        "q": "What implies using '&&' in RUN instructions?",
        "o": [
            "Chaining commands to create a single layer",
            "Logical AND",
            "Running in parallel",
            "Error handling"
        ]
    },
    {
        "q": "Why chain commands in RUN?",
        "o": [
            "Minimizing layers and size",
            "Readability",
            "It is required",
            "Faster execution"
        ]
    },
    {
        "q": "Can you use ARG in FROM?",
        "o": [
            "Yes",
            "No",
            "Only for tag",
            "Only for repo"
        ]
    },
    {
        "q": "Where must ARG be defined to be used in FROM?",
        "o": [
            "Before the first FROM",
            "After FROM",
            "Inside container",
            "Anywhere"
        ]
    },
    {
        "q": "Does ARG persist in the final image?",
        "o": [
            "No, only available during build",
            "Yes, as env var",
            "Yes, as file",
            "Yes, as label"
        ]
    },
    {
        "q": "How do you persist an ARG value?",
        "o": [
            "ARG name; ENV name=$name",
            "It persists automatically",
            "COPY name",
            "LABEL name=$name"
        ]
    },
    {
        "q": "What is the difference between ADD and COPY?",
        "o": [
            "ADD supports URLs and tar extraction, COPY only local files",
            "COPY supports URLs, ADD does not",
            "No difference",
            "ADD is deprecated"
        ]
    },
    {
        "q": "Which is preferred: ADD or COPY?",
        "o": [
            "COPY (more explicit)",
            "ADD (more features)",
            "Both equal",
            "Neither"
        ]
    },
    {
        "q": "When should you use ADD?",
        "o": [
            "Auto-extracting local tarballs",
            "Always",
            "Downloading large files",
            "Never"
        ]
    },
    {
        "q": "Why avoid ADD for remote URLs?",
        "o": [
            "Cannot delete in same layer (size issue), use curl/wget instead",
            "It fails often",
            "It is slow",
            "It is insecure"
        ]
    },
    {
        "q": "How do you extract a tarball into the image?",
        "o": [
            "ADD file.tar.gz /target",
            "COPY file.tar.gz /target",
            "RUN tar xf",
            "IMPORT file"
        ]
    },
    {
        "q": "Does COPY follow symlinks?",
        "o": [
            "Copies the file content by default",
            "Copies the link itself",
            "Fails",
            "Skips"
        ]
    },
    {
        "q": "How do you copy a directory?",
        "o": [
            "COPY src/ dest/",
            "COPY src dest",
            "COPY src/* dest",
            "COPY --recursive src dest"
        ]
    },
    {
        "q": "What happens if destination lacks trailing slash?",
        "o": [
            "Might be treated as a file renaming",
            "Always creates directory",
            "Error",
            "Warning"
        ]
    },
    {
        "q": "How do you change ownership of copied files?",
        "o": [
            "COPY --chown=user:group src dest",
            "RUN chown after copy",
            "USER before copy",
            "Not possible"
        ]
    },
    {
        "q": "Why use COPY --chown instead of RUN chown?",
        "o": [
            "Avoids duplicating data in layers",
            "Faster typing",
            "Less code",
            "More secure"
        ]
    },
    {
        "q": "Can you define default arguments for ENTRYPOINT?",
        "o": [
            "Yes, using CMD",
            "No",
            "Using ARGS",
            "Using FLAGS"
        ]
    },
    {
        "q": "What happens if user supplies args to docker run?",
        "o": [
            "Overrrides CMD, appended to ENTRYPOINT",
            "Overrides ENTRYPOINT",
            "Ignored",
            "Error"
        ]
    },
    {
        "q": "How do you override ENTRYPOINT at runtime?",
        "o": [
            "--entrypoint",
            "--cmd",
            "--run",
            "--exec"
        ]
    },
    {
        "q": "What is the exec form?",
        "o": [
            "[\"executable\", \"param1\"]",
            "executable param1",
            "RUN executable",
            "SHELL executable"
        ]
    },
    {
        "q": "What is the shell form?",
        "o": [
            "executable param1",
            "[\"executable\"]",
            "EXEC executable",
            "CALL executable"
        ]
    },
    {
        "q": "Why prefer exec form for ENTRYPOINT?",
        "o": [
            "Receive signals (PID 1), no subshell",
            "Easier syntax",
            "More flexible",
            "Variable expansion"
        ]
    },
    {
        "q": "Does shell form support variable expansion?",
        "o": [
            "Yes ($VAR work)",
            "No",
            "Only args",
            "Only env"
        ]
    },
    {
        "q": "Does exec form support variable expansion directly?",
        "o": [
            "No (must use shell explicitly)",
            "Yes",
            "Sometimes",
            "Always"
        ]
    },
    {
        "q": "How to use variables in exec form?",
        "o": [
            "[\"sh\", \"-c\", \"echo $VAR\"]",
            "[\"echo\", \"$VAR\"]",
            "[\"env\", \"$VAR\"]",
            "[\"print\", \"$VAR\"]"
        ]
    },
    {
        "q": "What is 'LABEL' used for?",
        "o": [
            "Adding metadata (maintainer, version, description)",
            "Tagging",
            "Naming",
            "Routing"
        ]
    },
    {
        "q": "How do you filter images by label?",
        "o": [
            "--filter label=key=value",
            "--label key=value",
            "-l key=value",
            "--with-label"
        ]
    },
    {
        "q": "What replaced MAINTAINER instruction?",
        "o": [
            "LABEL maintainer=...",
            "USER",
            "AUTHOR",
            "OWNER"
        ]
    },
    {
        "q": "How do you set multiple labels?",
        "o": [
            "LABEL k1=v1 k2=v2",
            "LABEL k1 v1 k2 v2",
            "Multiple LABEL instructions",
            "LABEL [k1=v1, k2=v2]"
        ]
    },
    {
        "q": "Why combine labels in one instruction?",
        "o": [
            "Reduces layers (historically, less relevant now)",
            "Required syntax",
            "Faster parsing",
            "Better sorting"
        ]
    },
    {
        "q": "What is the purpose of EXPOSE?",
        "o": [
            "Documentation of ports, used by -P",
            "Opens firewall",
            "Maps port automatically",
            "Starts service"
        ]
    },
    {
        "q": "Does EXPOSE actually publish the port?",
        "o": [
            "No, -p or -P is needed at runtime",
            "Yes",
            "Yes if privileged",
            "Yes on local"
        ]
    },
    {
        "q": "What protocol is default in EXPOSE?",
        "o": [
            "TCP",
            "UDP",
            "HTTP",
            "ICMP"
        ]
    },
    {
        "q": "How do you expose UDP?",
        "o": [
            "EXPOSE 80/udp",
            "EXPOSE udp:80",
            "EXPOSE -u 80",
            "UDP 80"
        ]
    },
    {
        "q": "What is 'WORKDIR'?",
        "o": [
            "Sets working directory for CMD, RUN, COPY, ADD",
            "Change dir on host",
            "Create dir only",
            "Mount volume"
        ]
    },
    {
        "q": "What happens if WORKDIR doesn't exist?",
        "o": [
            "It is created",
            "Error",
            "Falls back to /",
            "Warns"
        ]
    },
    {
        "q": "Is WORKDIR path absolute or relative?",
        "o": [
            "Can be either (relative to previous WORKDIR)",
            "Absolute only",
            "Relative only",
            "Home relative"
        ]
    },
    {
        "q": "Why prefer WORKDIR over RUN cd?",
        "o": [
            "RUN cd only affects that layer",
            "WORKDIR is faster",
            "WORKDIR is clearer",
            "RUN cd is banned"
        ]
    },
    {
        "q": "What is the purpose of USER instruction?",
        "o": [
            "Sets the user ID or name for following instructions",
            "Creates a new user",
            "Logs in a user",
            "Sets password"
        ]
    },
    {
        "q": "Does USER create the user if missing?",
        "o": [
            "No, user must exist in /etc/passwd",
            "Yes",
            "Yes, as root",
            "Yes, as guest"
        ]
    },
    {
        "q": "How do you run as a non-root user?",
        "o": [
            "Create user with RUN useradd, then USER <user>",
            "USER non-root",
            "RUN su user",
            "CMD user"
        ]
    },
    {
        "q": "What happens if you don't specify USER?",
        "o": [
            "Runs as root (ID 0)",
            "Runs as nobody",
            "Runs as docker",
            "Runs as daemon"
        ]
    },
    {
        "q": "Can you use UID instead of username in USER?",
        "o": [
            "Yes",
            "No",
            "Only for root",
            "Only for system users"
        ]
    },
    {
        "q": "Why use UID over username?",
        "o": [
            "Runtime doesn't need /etc/passwd to validate ID",
            "It is shorter",
            "It is more secure",
            "It is required"
        ]
    },
    {
        "q": "What is the 'VOLUME' instruction in Dockerfile?",
        "o": [
            "Creates a mount point with a generated name",
            "Mounts a host path",
            "Mounts a named volume",
            "Copies data"
        ]
    },
    {
        "q": "Can you map a VOLUME to a specific host path in Dockerfile?",
        "o": [
            "No, only at runtime",
            "Yes",
            "Using -v in Dockerfile",
            "Using BIND"
        ]
    },
    {
        "q": "What happens to data in a declared VOLUME if container is deleted?",
        "o": [
            "Persists in /var/lib/docker/volumes unless pruned",
            "Deleted",
            "Moved to temp",
            "Zipped"
        ]
    },
    {
        "q": "Does JSON format of VOLUME instruction exist?",
        "o": [
            "Yes, VOLUME [\"/data\"]",
            "No",
            "Only CSV",
            "Only XML"
        ]
    },
    {
        "q": "What instruction defines a health check?",
        "o": [
            "HEALTHCHECK",
            "CHECK",
            "TEST",
            "PROBE"
        ]
    },
    {
        "q": "What is the default interval for HEALTHCHECK?",
        "o": [
            "30s",
            "10s",
            "1m",
            "5m"
        ]
    },
    {
        "q": "How do you disable healthcheck from base image?",
        "o": [
            "HEALTHCHECK NONE",
            "HEALTHCHECK OFF",
            "NO_HEALTHCHECK",
            "SKIP_HEALTHCHECK"
        ]
    },
    {
        "q": "What exit code means 'unhealthy' in HEALTHCHECK command?",
        "o": [
            "1",
            "0",
            "2",
            "-1"
        ]
    },
    {
        "q": "What exit code means 'healthy'?",
        "o": [
            "0",
            "1",
            "OK",
            "True"
        ]
    },
    {
        "q": "How do you specify a timeout for health check?",
        "o": [
            "--timeout=3s",
            "-t 3s",
            "TIMEOUT 3s",
            "WAIT 3s"
        ]
    },
    {
        "q": "What is the 'start-period' in HEALTHCHECK?",
        "o": [
            "Time for container to bootstrap before counting failures",
            "Delay before start",
            "Time to wait for stop",
            "Time to build"
        ]
    },
    {
        "q": "What is the 'retries' option in HEALTHCHECK?",
        "o": [
            "Consecutive failures needed to report unhealthy",
            "Total retries allowed",
            "Retries on build",
            "Retries on push"
        ]
    },
    {
        "q": "What is the default stop signal?",
        "o": [
            "SIGTERM",
            "SIGKILL",
            "SIGSTOP",
            "SIGQUIT"
        ]
    },
    {
        "q": "How do you change the stop signal in Dockerfile?",
        "o": [
            "STOPSIGNAL signal",
            "SIGNAL stop",
            "STOP signal",
            "KILL signal"
        ]
    },
    {
        "q": "Why change STOPSIGNAL?",
        "o": [
            "Some apps handle other signals for graceful shutdown",
            "To be faster",
            "To be forceful",
            "To extend timeout"
        ]
    },
    {
        "q": "What is 'ONBUILD' instruction?",
        "o": [
            "Adds trigger instruction for when image is used as base",
            "Running on build",
            "Running on tag",
            "Running on push"
        ]
    },
    {
        "q": "Can ONBUILD instructions trigger other ONBUILD instructions?",
        "o": [
            "No (chained ONBUILD is not allowed)",
            "Yes",
            "Only one level",
            "Infinite loop"
        ]
    },
    {
        "q": "Is ONBUILD inherited by grandchildren?",
        "o": [
            "No, only child",
            "Yes",
            "Depends on version",
            "Depends on command"
        ]
    },
    {
        "q": "What happens if ONBUILD trigger fails?",
        "o": [
            "The child build fails",
            "Warning and continue",
            "Skipped",
            "Retried"
        ]
    },
    {
        "q": "Common use case for ONBUILD?",
        "o": [
            "Language stack images wrapping 'COPY . .' and 'RUN build'",
            "Base OS images",
            "Database images",
            "Web servers"
        ]
    },
    {
        "q": "What environment variable disables buildkit?",
        "o": [
            "DOCKER_BUILDKIT=0",
            "NO_BUILDKIT=1",
            "DISABLE_KIT=true",
            "BUILD_LEGACY=1"
        ]
    },
    {
        "q": "How to verify if an image is signed?",
        "o": [
            "docker trust inspect",
            "docker sign verify",
            "docker verify",
            "docker check sign"
        ]
    },
    {
        "q": "What is the key used for signing images?",
        "o": [
            "Root key (offline key) and tagging key",
            "SSH key",
            "TLS cert",
            "API key"
        ]
    },
    {
        "q": "How do you generate a new trust key?",
        "o": [
            "docker trust key generate",
            "docker keygen",
            "docker sign new",
            "docker trust init"
        ]
    },
    {
        "q": "What command revokes trust for an image?",
        "o": [
            "docker trust revoke",
            "docker unsign",
            "docker untrust",
            "docker ban"
        ]
    },
    {
        "q": "Where are trust keys stored locally?",
        "o": [
            "~/.docker/trust",
            "~/.ssh",
            "/etc/docker/keys",
            "/var/lib/docker/trust"
        ]
    },
    {
        "q": "What is 'notary'?",
        "o": [
            "Server for managing trusted collections",
            "A signing tool",
            "A certification authority",
            "A ledger"
        ]
    },
    {
        "q": "How do you add a signer to a repository?",
        "o": [
            "docker trust signer add",
            "docker add signer",
            "docker user add",
            "docker trust user"
        ]
    },
    {
        "q": "What is the role of a Repository Key?",
        "o": [
            "Signs tags in a specific repository",
            "Signs the root",
            "Signs the daemon",
            "Signs the network"
        ]
    },
    {
        "q": "How do you optimize layer ordering?",
        "o": [
            "Put frequently changing instructions last",
            "Put them first",
            "Random",
            "Alphabetical"
        ]
    },
    {
        "q": "Why combine 'apt-get update' and 'install'?",
        "o": [
            "To ensure installing latest package versions (avoid stale cache)",
            "To save space",
            "To save time",
            "To reduce text"
        ]
    },
    {
        "q": "What happens if you separate 'update' and 'install'?",
        "o": [
            "Update layer is cached, install might fail or use old packages",
            "Nothing bad",
            "Build fails",
            "Wait longer"
        ]
    },
    {
        "q": "How do you flatten a specific image to one layer?",
        "o": [
            "Build with --squash (experimental) or use tools like docker-squash",
            "docker flatten",
            "docker merge",
            "docker zip"
        ]
    },
    {
        "q": "Does reducing layers always reduce size?",
        "o": [
            "Not necessarily, but deduplicates files overwritten in layers",
            "Yes always",
            "No never",
            "Only for text files"
        ]
    },
    {
        "q": "What tool suggests Dockerfile best practices?",
        "o": [
            "Hadolint",
            "LintDocker",
            "DockCheck",
            "BuildCheck"
        ]
    },
    {
        "q": "How do you prevent secrets from leaking in history?",
        "o": [
            "Use build mounts or multi-stage builds, never COPY secrets",
            "Delete them in next layer",
            "Use .dockerignore",
            "Encrypt them"
        ]
    },
    {
        "q": "Can you inspect history of a remote image?",
        "o": [
            "No, must pull first",
            "Yes",
            "Only manifest",
            "Only tags"
        ]
    },
    {
        "q": "How do you view the full command in history (not truncated)?",
        "o": [
            "docker history --no-trunc",
            "docker history -f",
            "docker history --full",
            "docker history -v"
        ]
    },
    {
        "q": "What does '<missing>' mean in older Docker versions?",
        "o": [
            "Layer data is not on local disk but exists in parent",
            "Layer is corrupted",
            "Layer is waiting",
            "Layer is empty"
        ]
    },
    {
        "q": "How do you efficiently copy package.json first?",
        "o": [
            "COPY package.json . ; RUN npm install ; COPY . .",
            "COPY . . ; RUN npm install",
            "RUN npm install",
            "COPY package.json npm install"
        ]
    },
    {
        "q": "Why copy package.json separately?",
        "o": [
            "To cache dependencies layer if source code changes",
            "To check syntax",
            "To validate json",
            "To sort keys"
        ]
    },
    {
        "q": "What is the effect of changing a file in .dockerignore?",
        "o": [
            "Invalidates cache for ADD/COPY involving context",
            "None",
            "Rebuilds everything",
            "Updates ignore list only"
        ]
    },
    {
        "q": "Can you use wildcards in .dockerignore?",
        "o": [
            "Yes, Go filepath.Match rules",
            "No, exact match only",
            "Regex only",
            "Glob only"
        ]
    },
    {
        "q": "Can you excludes exceptions with '!' in .dockerignore?",
        "o": [
            "Yes",
            "No",
            "Only in .gitignore",
            "Only in .ignore"
        ]
    },
    {
        "q": "What is the 'builder' pattern (pre-multi-stage)?",
        "o": [
            "Two Dockerfiles: one for build, one for run, copy binary manually",
            "One Dockerfile",
            "Using Makefiles",
            "Using shell scripts"
        ]
    },
    {
        "q": "How do you pass build-time variables without persistence?",
        "o": [
            "--build-arg (if not ENV'd)",
            "ENV",
            "COPY file",
            "LABEL"
        ]
    },
    {
        "q": "Do build-args show up in docker history?",
        "o": [
            "Yes",
            "No",
            "Only if used",
            "Only if valid"
        ]
    },
    {
        "q": "How do you hide build-args from history?",
        "o": [
            "Use secrets mount (BuildKit)",
            "Delete history",
            "Use --no-history",
            "Encrypt args"
        ]
    },
    {
        "q": "What is 'kaniko'?",
        "o": [
            "Tool to build container images inside a container without daemon",
            "A registry",
            "An orchestrator",
            "A linter"
        ]
    },
    {
        "q": "Why use kaniko in Kubernetes?",
        "o": [
            "Secure building without privileged mode/docker socket",
            "Faster",
            "Simpler",
            "Cheaper"
        ]
    },
    {
        "q": "What is 'buildah'?",
        "o": [
            "Tool for building OCI images without daemon",
            "A storage driver",
            "A base image",
            "A plugin"
        ]
    },
    {
        "q": "What is 'podman' relation to images?",
        "o": [
            "Can build and manage images compatible with Docker",
            "Incompatible",
            "Uses different format",
            "Only runs, cannot build"
        ]
    },
    {
        "q": "Does Podman use a daemon?",
        "o": [
            "No, daemonless",
            "Yes",
            "Optional",
            "Only for root"
        ]
    },
    {
        "q": "Where does Podman store images?",
        "o": [
            "~/.local/share/containers (rootless)",
            "/var/lib/docker",
            "/tmp",
            "/opt"
        ]
    },
    {
        "q": "What is 'skopeo'?",
        "o": [
            "Tool to inspect/copy images between registries without pulling",
            "A scope",
            "A scanner",
            "A builder"
        ]
    },
    {
        "q": "Can skopeo copy between different registry types?",
        "o": [
            "Yes (docker-daemon, docker-archive, dir, oci, etc.)",
            "No",
            "Only http",
            "Only https"
        ]
    },
    {
        "q": "How do you save multiple images to one tar?",
        "o": [
            "docker save -o all.tar img1 img2",
            "Cannot do it",
            "docker zip",
            "docker combine"
        ]
    },
    {
        "q": "How do you load and see all images from a tar?",
        "o": [
            "docker load -i all.tar",
            "docker import all.tar",
            "docker restore all.tar",
            "docker open all.tar"
        ]
    },
    {
        "q": "What format is the tarball from docker save?",
        "o": [
            "Non-standard implementation specific (mostly)",
            "OCI layout",
            "ISO",
            "ZIP"
        ]
    },
    {
        "q": "Does 'docker import' create history?",
        "o": [
            "No, creates a single layer image",
            "Yes",
            "Depends on source",
            "Depends on size"
        ]
    },
    {
        "q": "When to use 'docker import'?",
        "o": [
            "Creating image from a filesystem tarball (not a docker save tar)",
            "Moving docker images",
            "Restoring backup",
            "Never"
        ]
    },
    {
        "q": "What happens if you run a container from an image with no CMD/ENTRYPOINT?",
        "o": [
            "Error, unless one is provided at runtime",
            "Runs generic shell",
            "Runs loop",
            "Exits immediately with success"
        ]
    },
    {
        "q": "Can you reset ENTRYPOINT to empty?",
        "o": [
            "Yes, --entrypoint=\"\"",
            "No",
            "--entrypoint none",
            "--no-entrypoint"
        ]
    },
    {
        "q": "Why reset ENTRYPOINT?",
        "o": [
            "To pass a different command to a container with a fixed ENTRYPOINT script",
            "To stop it",
            "To pause it",
            "To debug it"
        ]
    },
    {
        "q": "How do you view image build args of an existing image?",
        "o": [
            "docker image inspect --format '{{.Config.Labels}}' (if stored in label)",
            "docker history",
            "docker info",
            "Not possible if not labeled"
        ]
    },
    {
        "q": "What is the 'Cmd' field in inspect output?",
        "o": [
            "The default command to run",
            "The entrypoint",
            "The shell",
            "The creator"
        ]
    },
    {
        "q": "What is the 'Entrypoint' field in inspect output?",
        "o": [
            "The entrypoint executable",
            "The arguments",
            "The working dir",
            "The user"
        ]
    },
    {
        "q": "Does 'docker rmi' remove the parent image?",
        "o": [
            "No, unless it is unused and dangling (and prune is run)",
            "Yes",
            "Prompts user",
            "Always"
        ]
    },
    {
        "q": "Can you share layers between different registries?",
        "o": [
            "In theory yes if cross-mount is supported, usually specific to registry implementation",
            "No",
            "Always",
            "Via USB only"
        ]
    },
    {
        "q": "What is a 'foreign layer' (Windows)?",
        "o": [
            "Layer not stored in the registry but downloaded from Microsoft",
            "A layer from another country",
            "An encrypted layer",
            "A virus"
        ]
    },
    {
        "q": "Why exist foreign layers?",
        "o": [
            "License restrictions on distribution",
            "Size optimization",
            "Speed",
            "Security"
        ]
    },
    {
        "q": "How do you disable pulling foreign layers?",
        "o": [
            "configuration --allow-nondistributable-artifacts",
            "--no-foreign",
            "--local-only",
            "--restrict"
        ]
    },
    {
        "q": "What is 'docker manifest create'?",
        "o": [
            "Creates a local manifest list for multi-arch push",
            "Creates a file",
            "Creates a new image",
            "Creates a repo"
        ]
    },
    {
        "q": "How do you annotate a manifest list?",
        "o": [
            "docker manifest annotate",
            "docker note",
            "docker comment",
            "docker mark"
        ]
    },
    {
        "q": "Why annotate a manifest?",
        "o": [
            "To specify arch/os for an image variant",
            "To sign it",
            "To encrypt it",
            "To delete it"
        ]
    },
    {
        "q": "What is the 'variant' in manifest annotation?",
        "o": [
            "CPU variant (e.g., v7, v8 for arm)",
            "OS variant",
            "Color variant",
            "Size variant"
        ]
    },
    {
        "q": "Can you have Windows and Linux images in same manifest list?",
        "o": [
            "Yes",
            "No",
            "Only if WSL",
            "Only if experimental"
        ]
    },
    {
        "q": "What happens if you pull a multi-arch image on unsupported arch?",
        "o": [
            "Error: no matching manifest for linux/amd64...",
            "Runs slowly",
            "Emulates automatically",
            "Crashes host"
        ]
    },
    {
        "q": "How do you force pull a specific characteristic?",
        "o": [
            "--platform",
            "--arch",
            "--os",
            "--type"
        ]
    },
    {
        "q": "Does 'platform' flag trigger emulation?",
        "o": [
            "Yes (if QEMU is set up)",
            "No",
            "Only on Mac",
            "Only on Windows"
        ]
    },
    {
        "q": "What is 'binfmt_misc'?",
        "o": [
            "Kernel feature to execute binaries of different architectures",
            "A file format",
            "A bin folder",
            "A script"
        ]
    },
    {
        "q": "How do you enable QEMU for multi-arch builds?",
        "o": [
            "docker run --privileged --rm tonistiigi/binfmt --install all",
            "apt-get install qemu",
            "Enable in Docker Desktop settings",
            "Use VM"
        ]
    },
    {
        "q": "What is the purpose of FROM ... AS ...?",
        "o": [
            "Naming a build stage",
            "Renaming image",
            "Aliasing command",
            "Tagging"
        ]
    },
    {
        "q": "Can you copy from an external image using AS alias?",
        "o": [
            "No, AS is for internal stages (but you can name external image in FROM)",
            "Yes",
            "Maybe",
            "Only if trusted"
        ]
    },
    {
        "q": "How do you reference the previous stage without a name?",
        "o": [
            "--from=0 (index)",
            "--from=last",
            "--from=prev",
            "--from=back"
        ]
    },
    {
        "q": "Why name stages?",
        "o": [
            "Readability and robustness against reordering",
            "Required",
            "Faster",
            "Smaller"
        ]
    },
    {
        "q": "What happens if you use 'COPY --from=stage' where stage is undefined?",
        "o": [
            "Error: stage not found",
            "Copies from host",
            "Copies from base",
            "Creates empty file"
        ]
    },
    {
        "q": "Can you use 'COPY --from' with an external image?",
        "o": [
            "Yes, COPY --from=nginx:latest",
            "No",
            "Only if in same repo",
            "Only if locally present"
        ]
    },
    {
        "q": "What is the benefit of copying from external image?",
        "o": [
            "Avoiding installation tools (curl/wget) in target image",
            "Faster than build",
            "Safer",
            "Encryption"
        ]
    },
    {
        "q": "How do you stop a specific build stage from running?",
        "o": [
            "Build only up to a previous stage with --target",
            "Comment it out",
            "Use SKIP",
            "Use STOP"
        ]
    },
    {
        "q": "What is the default target stage?",
        "o": [
            "The last stage in Dockerfile",
            "The first stage",
            "The stage named 'default'",
            "Random"
        ]
    },
    {
        "q": "Can you have multiple FROM instructions without multi-stage?",
        "o": [
            "No (older versions), Yes (multi-stage)",
            "Yes always",
            "No never",
            "Only for different files"
        ]
    },
    {
        "q": "What happens to artifacts in intermediate stages?",
        "o": [
            "Discarded after build unless copied",
            "Saved to disk",
            "Uploaded",
            "Printed"
        ]
    },
    {
        "q": "How to debug a failing intermediate stage?",
        "o": [
            "Build targeting that stage: docker build --target stageName",
            "docker run stage",
            "docker debug stage",
            "docker inspect stage"
        ]
    },
    {
        "q": "What is 'buildx bake'?",
        "o": [
            "High-level build command using HCL/JSON/Compose files",
            "A cookie",
            "A test tool",
            "A cleaner"
        ]
    },
    {
        "q": " What file does 'docker buildx bake' look for by default?",
        "o": [
            "docker-bake.hcl or docker-bake.json or compose.yaml",
            "Makefile",
            "build.xml",
            "package.json"
        ]
    },
    {
        "q": "Can you build multiple targets in parallel with bake?",
        "o": [
            "Yes, automatically",
            "No",
            "Only sequentially",
            "Only on cloud"
        ]
    },
    {
        "q": "How do you define matrix builds in bake?",
        "o": [
            "Using matrix attribute in HCL",
            "Using loop",
            "Using array",
            "Using repeat"
        ]
    },
    {
        "q": "What is 'sbom' (Software Bill of Materials)?",
        "o": [
            "List of all components in the image",
            "Bill for cloud usage",
            "Build log",
            "Error report"
        ]
    },
    {
        "q": "How do you generate SBOM for an image?",
        "o": [
            "docker sbom (or scout sbom)",
            "docker list components",
            "docker manifest components",
            "docker scan bill"
        ]
    },
    {
        "q": "Why is SBOM important?",
        "o": [
            "Supply chain security and vulnerability management",
            "Performance tuning",
            "Cost analysis",
            "It is mandatory"
        ]
    },
    {
        "q": "What mechanism allows 'docker run -it ubuntu' to work immediately?",
        "o": [
            "Image pull (if missing) then container create/start",
            "Magic",
            "Kernel streaming",
            "Preloaded OS"
        ]
    },
    {
        "q": "Where is the image configuration JSON stored in the image?",
        "o": [
            "It is a blob referenced by the manifest",
            "In /etc/docker",
            "In root",
            "Attached to first layer"
        ]
    },
    {
        "q": "What is the 'Config' section in image JSON?",
        "o": [
            "Runtime configuration (Env, Cmd, User, etc.)",
            "Build history",
            "Layer hashes",
            "Signatures"
        ]
    },
    {
        "q": "What is the 'RootFS' section in image JSON?",
        "o": [
            "List of layer diffIDs",
            "File content",
            "Mount points",
            "Network config"
        ]
    },
    {
        "q": "How is DiffID different from Layer Digest?",
        "o": [
            "DiffID is uncompressed hash, Layer Digest is compressed (distribution) hash",
            "They are same",
            "DiffID is for files, Digest for metadata",
            "DiffID is random"
        ]
    },
    {
        "q": "Why use uncompressed hash for DiffID?",
        "o": [
            "To verify content on disk regardless of compression algo",
            "Faster",
            "Smaller",
            "Legacy"
        ]
    },
    {
        "q": "What is 'Attestations' in BuildKit?",
        "o": [
            "Metadata about how image was built (provenance, sbom)",
            "Signatures",
            "Tests",
            "Logs"
        ]
    },
    {
        "q": "Where are attestations stored?",
        "o": [
            "In the image manifest (as a separate artifact or attached)",
            "Local db",
            "In the cloud",
            "In header"
        ]
    },
    {
        "q": "How do you view attestations?",
        "o": [
            "docker buildx imagetools inspect",
            "docker inspect",
            "docker show attestation",
            "docker verify"
        ]
    },
    {
        "q": "What is 'SLSA' (Salsa)?",
        "o": [
            "Supply-chain Levels for Software Artifacts",
            "A dance",
            "A sauce",
            "A security tool"
        ]
    },
    {
        "q": "Does BuildKit support SLSA provenance?",
        "o": [
            "Yes",
            "No",
            "Only level 1",
            "Only level 4"
        ]
    },
    {
        "q": "How do you enable provenance generation?",
        "o": [
            "--provenance=true",
            "--slsa",
            "--secure-build",
            "--trace"
        ]
    },
    {
        "q": "What is the 'local' exporter in BuildKit?",
        "o": [
            "Exports build result files to client directory",
            "Exports to local registry",
            "Exports to variable",
            "Exports to null"
        ]
    },
    {
        "q": "What is the 'tar' exporter?",
        "o": [
            "Exports build result as a tarball",
            "Exports as zip",
            "Exports as iso",
            "Exports as raw"
        ]
    },
    {
        "q": "What is the 'image' exporter (default)?",
        "o": [
            "Exports to Docker daemon or registry",
            "Exports to file",
            "Exports to screen",
            "Exports to memory"
        ]
    },
    {
        "q": "What is the 'oci' exporter?",
        "o": [
            "Exports as OCI image layout tarball",
            "Exports as Docker tarball",
            "Exports as text",
            "Exports as binary"
        ]
    },
    {
        "q": "Can you write to multiple exporters at once?",
        "o": [
            "Yes (in bake or multiple --output)",
            "No",
            "Only similar types",
            "Only separate runs"
        ]
    },
    {
        "q": "How do you set a build argument globally for all stages?",
        "o": [
            "Define ARG before first FROM",
            "Define ARG in every stage",
            "Define ENV",
            "Use Global keyword"
        ]
    },
    {
        "q": "Does 'ARG' before FROM appear in the image env?",
        "o": [
            "No",
            "Yes",
            "Only if referenced",
            "Only if public"
        ]
    },
    {
        "q": "How do you use 'ONBUILD COPY'?",
        "o": [
            "ONBUILD COPY src dest",
            "COPY ONBUILD src dest",
            "TRIGGER COPY src dest",
            "ADD ONBUILD src dest"
        ]
    },
    {
        "q": "Why is 'ONBUILD COPY .' dangerous?",
        "o": [
            "It copies whatever happens to be in the child's context (unpredictable)",
            "It is slow",
            "It deletes files",
            "It crashes"
        ]
    },
    {
        "q": "What is the recommended replacement for ONBUILD pattern?",
        "o": [
            "Explicitly copying in child Dockerfile (or app templates)",
            "Multi-stage",
            "Scripts",
            "Macros"
        ]
    },
    {
        "q": "How do you prevent a layer from being cached?",
        "o": [
            "ADD a unique value (like timestamp) before it",
            "Use --no-cache-layer",
            "Mark as volatile",
            "Cannot do it"
        ]
    },
    {
        "q": "What is 'docker save' output format suitable for?",
        "o": [
            "Loading into another Docker daemon",
            "Running directly",
            "Reading with text editor",
            "Mounting as filesystem"
        ]
    },
    {
        "q": "Can you mount a 'docker save' tarball?",
        "o": [
            "Not directly, need to extract layers",
            "Yes with mount -o loop",
            "Yes with docker mount",
            "Yes with fuse"
        ]
    },
    {
        "q": "Tool to explore image layers via TUI?",
        "o": [
            "dive",
            "explore",
            "view",
            "inspect-ui"
        ]
    },
    {
        "q": "What does 'dive' show?",
        "o": [
            "Layer contents, wasted space, duplicate files",
            "Container logs",
            "Network traffic",
            "CPU usage"
        ]
    },
    {
        "q": "How to check efficiency of an image?",
        "o": [
            "Check size and 'dive' score",
            "Check build time",
            "Check run time",
            "Check creation date"
        ]
    },
    {
        "q": "What is 'wasted space' in image context?",
        "o": [
            "Files added in one layer and deleted/overwritten in a later layer",
            "Empty space on disk",
            "Swap space",
            "Cache space"
        ]
    },
    {
        "q": "Why does deleting a file in a later layer not recover space?",
        "o": [
            "The file persists in the lower read-only layer",
            "It does recover space",
            "Docker bug",
            "Filesystem limitation"
        ]
    },
    {
        "q": "How to truly delete a file to save space?",
        "o": [
            "Remove it in the SAME layer (RUN ... && rm ...)",
            "Remove in next layer",
            "Use .dockerignore",
            "Use DELETE instruction"
        ]
    },
    {
        "q": "What if you need to download, extract, and remove zip?",
        "o": [
            "Do all in one RUN instruction",
            "Three RUN instructions",
            "Use COPY",
            "Use ADD"
        ]
    },
    {
        "q": "How do you run a shell if ENTRYPOINT is set to executable?",
        "o": [
            "--entrypoint /bin/sh",
            "--cmd /bin/sh",
            "--shell",
            "Just run bash"
        ]
    },
    {
        "q": "What is the 'StopSignal' in image config?",
        "o": [
            "Signal sent to stop the container",
            "Signal to pause",
            "Signal to kill",
            "Signal to reboot"
        ]
    },
    {
        "q": "Can you build an image from a container?",
        "o": [
            "Yes, docker commit",
            "No",
            "Only if running",
            "Only if stopped"
        ]
    },
    {
        "q": "What metadata is lost during 'docker commit'?",
        "o": [
            "History of valid Dockerfile instructions (becomes just 'imported')",
            "Nothing",
            "Env vars",
            "Ports"
        ]
    },
    {
        "q": "How do you change the tag of an existing image without pulling?",
        "o": [
            "docker tag existing new",
            "docker rename",
            "docker mv",
            "docker edit"
        ]
    },
    {
        "q": "Does 'docker tag' create a copy?",
        "o": [
            "No, just an alias (Hard link logic)",
            "Yes",
            "Depends",
            "Maybe"
        ]
    },
    {
        "q": "What happens if you tag 'repo:latest' to 'repo:v1'?",
        "o": [
            "Both point to same Image ID",
            "Creates copy",
            "Deletes latest",
            "Moves latest"
        ]
    },
    {
        "q": "How do you remove a specific tag but keep image?",
        "o": [
            "docker rmi repo:tag",
            "docker untag repo:tag",
            "docker rm repo:tag",
            "docker delete tag"
        ]
    },
    {
        "q": "What happens if you 'docker rmi' the last tag of an image?",
        "o": [
            "The image (layers) is deleted",
            "Image becomes untagged (dangling) if containers exist, else deleted",
            "Error",
            "Nothing"
        ]
    },
    {
        "q": "Can you build an image from STDIN?",
        "o": [
            "Yes, docker build - < Dockerfile",
            "No",
            "Only from file",
            "Only from url"
        ]
    },
    {
        "q": "Can you build from a context tarball on STDIN?",
        "o": [
            "Yes, docker build - < context.tar.gz",
            "No",
            "Only zip",
            "Only folder"
        ]
    },
    {
        "q": "How do you tag an image during build?",
        "o": [
            "-t or --tag",
            "--name",
            "--label",
            "--id"
        ]
    },
    {
        "q": "Can you apply multiple tags during build?",
        "o": [
            "Yes, multiple -t flags",
            "No",
            "Only one",
            "Use comma"
        ]
    },
    {
        "q": "What is the 'garbage collection' of registry?",
        "o": [
            "Process to delete unreferenced blobs in registry storage",
            "Deleting local images",
            "Cleaning RAM",
            "Scanning virus"
        ]
    },
    {
        "q": "Does 'docker rmi' trigger registry GC?",
        "o": [
            "No, assumes local only",
            "Yes",
            "Sometimes",
            "If connected"
        ]
    },
    {
        "q": "What tool manages registry GC?",
        "o": [
            "Registry specific tool (e.g., registry garbage-collect)",
            "docker gc",
            "docker clean registry",
            "Manual delete"
        ]
    },
    {
        "q": "What is 'crane'?",
        "o": [
            "Tool for managing container images at remote registry",
            "A heavy machine",
            "A bird",
            "A builder"
        ]
    },
    {
        "q": "Can crane list tags without pulling?",
        "o": [
            "Yes, crane ls",
            "No",
            "Only headers",
            "Only counts"
        ]
    },
    {
        "q": "How do you verify if an image exists remotely?",
        "o": [
            "docker manifest inspect or crane manifest",
            "docker pull --dry-run",
            "docker check",
            "docker ping"
        ]
    },
    {
        "q": "What is 'ExposedPorts' in image config?",
        "o": [
            "Set of ports exposed",
            "List of open sockets",
            "Firewall rules",
            "NAT table"
        ]
    },
    {
        "q": "Is 'Env' list in image config ordered?",
        "o": [
            "No, usually processed as list",
            "Yes",
            "Alphabetical",
            "Random"
        ]
    },
    {
        "q": "Can you override ENV at runtime?",
        "o": [
            "Yes, -e",
            "No",
            "Only if authorized",
            "Only if empty"
        ]
    },
    {
        "q": "Does 'ENV' persist to child images?",
        "o": [
            "Yes",
            "No",
            "Only first generation",
            "Optional"
        ]
    },
    {
        "q": "What is 'Volumes' in image config?",
        "o": [
            "Map of volume mount points",
            "List of disks",
            "List of drivers",
            "Size info"
        ]
    },
    {
        "q": "Can an image define a volume that cannot be unmounted?",
        "o": [
            "Once defined, the directory is always a volume mount point",
            "No",
            "Yes",
            "Maybe"
        ]
    },
    {
        "q": "What happens if you write to a volume path in Dockerfile after VOLUME instruction?",
        "o": [
            "Changes might be discarded or create new volume depending on builder",
            "Works fine",
            "Fails",
            "Overwrites host"
        ]
    },
    {
        "q": "Best practice for VOLUME instruction location?",
        "o": [
            "Put it at the end",
            "Put it at the start",
            "Random",
            "Middle"
        ]
    },
    {
        "q": "Why put VOLUME at the end?",
        "o": [
            "To allow setup/population of that directory in previous steps",
            "To be faster",
            "To be clean",
            "Required"
        ]
    },
    {
        "q": "What is 'OnBuild' field in image config?",
        "o": [
            "List of triggered instructions",
            "Build logs",
            "Build date",
            "Builder info"
        ]
    },
    {
        "q": "Can you add a new layer to an image without rebuilding from Dockerfile?",
        "o": [
            "Yes, by committing a container",
            "No",
            "Only via API",
            "Only via registry"
        ]
    },
    {
        "q": "What happens to the CMD of base image?",
        "o": [
            "Inherited unless overridden",
            "Deleted",
            "Paused",
            "Merged"
        ]
    },
    {
        "q": "Can you have multiple CMD instructions?",
        "o": [
            "Only the last one takes effect",
            "Yes, they run in sequence",
            "No, error",
            "Yes, parallel"
        ]
    },
    {
        "q": "Can you combine CMD and ENTRYPOINT from base and child?",
        "o": [
            "Yes, child CMD args are passed to base ENTRYPOINT (if child has no ENTRYPOINT)",
            "No",
            "Override only",
            "Error"
        ]
    },
    {
        "q": "How to clear entrypoint from base image?",
        "o": [
            "ENTRYPOINT []",
            "ENTRYPOINT null",
            "ENTRYPOINT none",
            "CLEAR ENTRYPOINT"
        ]
    },
    {
        "q": "What is 'cross-building'?",
        "o": [
            "Building for architecture A on machine of architecture B",
            "Building on two machines",
            "Building two images",
            "Building Java"
        ]
    },
    {
        "q": "How does Docker Desktop handle cross-building?",
        "o": [
            "Uses QEMU emulation transparently",
            "Uses remote cluster",
            "Fails",
            "Uses magic"
        ]
    },
    {
        "q": "Is cross-building slower?",
        "o": [
            "Yes, emulation overhead",
            "No",
            "Faster",
            "Same"
        ]
    },
    {
        "q": "How to speed up cross-builds?",
        "o": [
            "Use native nodes (buildx drivers) or cross-compilation (Go, Rust)",
            "Use more RAM",
            "Use SSD",
            "Use GPU"
        ]
    },
    {
        "q": "What is 'xx' library?",
        "o": [
            "Docker helpers for cross-compilation",
            "A game",
            "A variable",
            "A tool"
        ]
    },
    {
        "q": "How do you detect current architecture in Dockerfile?",
        "o": [
            "TARGETARCH arg",
            "ARCH env",
            "uname -m",
            "ask user"
        ]
    },
    {
        "q": "What args are automatically available in BuildKit?",
        "o": [
            "TARGETOS, TARGETARCH, TARGETPLATFORM, BUILDPLATFORM, etc.",
            "None",
            "USER",
            "DATE"
        ]
    },
    {
        "q": "Do you need to define automatic args?",
        "o": [
            "Yes, ARG TARGETARCH",
            "No",
            "Only in ENV",
            "Only in LABEL"
        ]
    },
    {
        "q": "What is BUILDPLATFORM?",
        "o": [
            "Platform of the node performing the build",
            "Target platform",
            "Cloud platform",
            "Host OS"
        ]
    },
    {
        "q": "What is 'TARGETPLATFORM'?",
        "o": [
            "Platform of the build result (e.g. linux/arm64)",
            "Platform of builder",
            "Platform of cloud",
            "Platform of kernel"
        ]
    },
    {
        "q": "What happens if you run an arm64 image on amd64 host without emulation?",
        "o": [
            "Exec format error",
            "Runs slowly",
            "Runs fine",
            "Crashes docker"
        ]
    },
    {
        "q": "What is 'buildx inspect'?",
        "o": [
            "Shows information about a builder instance",
            "Inspects image",
            "Inspects container",
            "Inspects cache"
        ]
    },
    {
        "q": "How do you switch to a different builder instance?",
        "o": [
            "docker buildx use <name>",
            "docker switch <name>",
            "docker use <name>",
            "docker context use"
        ]
    },
    {
        "q": "What is the 'docker-container' driver in buildx?",
        "o": [
            "Runs BuildKit in a container (supports multi-arch, advanced caching)",
            "Runs in daemon",
            "Runs in k8s",
            "Runs in podman"
        ]
    },
    {
        "q": "What is the default driver for 'docker build' (classic)?",
        "o": [
            "docker driver (embedded in daemon)",
            "docker-container",
            "kubernetes",
            "remote"
        ]
    },
    {
        "q": "Limitation of the default 'docker' driver?",
        "o": [
            "Does not support multi-arch image output (manifest list) directly in one go",
            "Slower",
            "No caching",
            "No secrets"
        ]
    },
    {
        "q": "How do you prune build cache with buildx?",
        "o": [
            "docker buildx prune",
            "docker system prune",
            "docker builder prune",
            "docker cache prune"
        ]
    },
    {
        "q": "What is '--mount=type=cache'?",
        "o": [
            "Mounts a persistent cache directory for compilers/package managers",
            "Mounts host dir",
            "Mounts tmpfs",
            "Mounts secret"
        ]
    },
    {
        "q": "Is type=cache shared between builds?",
        "o": [
            "Yes, if id matches (or default)",
            "No",
            "Only in same repo",
            "Only in same day"
        ]
    },
    {
        "q": "How to lock cache to specific architecture?",
        "o": [
            "It is automatic (cache is namespaced by arch usually)",
            "Use --arch-lock",
            "Use --secure",
            "Cannot do it"
        ]
    },
    {
        "q": "What is '--mount=type=tmpfs' in RUN?",
        "o": [
            "Mounts a temporary filesystem in RAM (destroyed after step)",
            "Mounts disk",
            "Mounts cache",
            "Mounts file"
        ]
    },
    {
        "q": "What is the 'here-document' support in Dockerfile?",
        "o": [
            "Allows inline scripts (RUN <<EOF ... EOF)",
            "Documentation link",
            "Comments",
            "Variables"
        ]
    },
    {
        "q": "Does Dockerfile support HEREDOC for COPY?",
        "o": [
            "Yes (COPY <<EOF file.txt)",
            "No",
            "Only RUN",
            "Only ADD"
        ]
    },
    {
        "q": "What syntax directive is needed for HEREDOCs (in older versions)?",
        "o": [
            "# syntax=docker/dockerfile:1",
            "# enable heredoc",
            "# version 2",
            "# mode=advanced"
        ]
    },
    {
        "q": "What is '.dockerignore' syntax based on?",
        "o": [
            "Go's filepath.Match (plus ** support)",
            "Regex",
            "Bash",
            "Python"
        ]
    },
    {
        "q": "What is 'reproducible builds'?",
        "o": [
            "Producing bit-for-bit identical image given same source",
            "Building twice",
            "Building fast",
            "Building safely"
        ]
    },
    {
        "q": "Why use 'SOURCE_DATE_EPOCH'?",
        "o": [
            "To set fixed timestamps for files/layers for reproducibility",
            "To set timezone",
            "To set alarm",
            "To expire image"
        ]
    },
    {
        "q": "How do you strip timestamps from Gzip layer?",
        "o": [
            "Use --rewrite-timestamp or canonical gzip (BuildKit does this)",
            "Cannot do it",
            "Manually",
            "Use zip"
        ]
    },
    {
        "q": "What is 'overlay2'?",
        "o": [
            "Storage driver (union filesystem) used by most Linux installs",
            "Network driver",
            "Volume driver",
            "Log driver"
        ]
    },
    {
        "q": "How are layers represented in overlay2?",
        "o": [
            "Directories in /var/lib/docker/overlay2/...",
            "Zip files",
            "Tar files",
            "Database blobs"
        ]
    },
    {
        "q": "What is 'UpperDir', 'LowerDir', 'MergedDir'?",
        "o": [
            "Concepts of overlayfs (writable, read-only, unified view)",
            "Cloud regions",
            "Image tags",
            "Network zones"
        ]
    },
    {
        "q": "What is 'Copy-on-Write' (CoW)?",
        "o": [
            "Mechanism where file is copied to UpperDir only when modified",
            "Copying everything on start",
            "Copying on read",
            "Copying on delete"
        ]
    },
    {
        "q": "Does overlay2 support page cache sharing?",
        "o": [
            "Yes, multiple containers sharing image share memory for files",
            "No",
            "Only for text",
            "Only for libs"
        ]
    },
    {
        "q": "What is 'fuse-overlayfs'?",
        "o": [
            "User-space implementation of overlayfs (good for rootless)",
            "Kernel module",
            "Virus scanner",
            "Backup tool"
        ]
    },
    {
        "q": "What is 'vfs' storage driver?",
        "o": [
            "Naive driver, deep copies everything (slow, huge space)",
            "Virtual memory",
            "Very fast system",
            "Video file system"
        ]
    },
    {
        "q": "When to use 'vfs'?",
        "o": [
            "Debugging or when no CoW filesystem is available",
            "Production",
            "Always",
            "For databases"
        ]
    },
    {
        "q": "What is 'devicemapper' driver status?",
        "o": [
            "Deprecated and removed",
            "Recommended",
            "Default",
            "Experimental"
        ]
    },
    {
        "q": "What is 'btrfs' driver?",
        "o": [
            "Uses btrfs subvolumes and snapshots for layers",
            "A binary tool",
            "A tape driver",
            "A network protocol"
        ]
    },
    {
        "q": "What is 'zfs' driver?",
        "o": [
            "Uses ZFS datasets and clones",
            "Zip file system",
            "Zoom file system",
            "Zero file system"
        ]
    },
    {
        "q": "How do you check current storage driver?",
        "o": [
            "docker info",
            "docker storage",
            "docker driver",
            "docker df"
        ]
    },
    {
        "q": "Should you run database data on OverlayFS?",
        "o": [
            "No, use Volumes (bypass CoW overhead)",
            "Yes",
            "Maybe",
            "If small"
        ]
    },
    {
        "q": "What is 'init' process in a container?",
        "o": [
            "PID 1, responsible for reaping zombies and handling signals",
            "The start script",
            "The user",
            "The daemon"
        ]
    },
    {
        "q": "What happens if PID 1 exits?",
        "o": [
            "Container stops",
            "Container restarts",
            "Container pauses",
            "Container spawns new PID 1"
        ]
    },
    {
        "q": "What is 'tini'?",
        "o": [
            "A tiny init process included in Docker (--init)",
            "A tiny image",
            "A test tool",
            "A text editor"
        ]
    },
    {
        "q": "How do you use 'tini'?",
        "o": [
            "docker run --init",
            "RUN tini",
            "FROM tini",
            "CMD tini"
        ]
    },
    {
        "q": "Why do you need an init process?",
        "o": [
            "To prevent zombie processes accumulation",
            "To be faster",
            "To have logs",
            "To use network"
        ]
    },
    {
        "q": "What is a 'zombie process'?",
        "o": [
            "Process that has terminated but not been waited for by parent",
            "Virus",
            "Sleeping process",
            "Running process"
        ]
    },
    {
        "q": "What is 'docker diff'?",
        "o": [
            "Shows changes (added, modified, deleted) in container filesystem vs image",
            "Diffs two images",
            "Diffs two containers",
            "Diffs two files"
        ]
    },
    {
        "q": "What does key 'A' mean in docker diff?",
        "o": [
            "Added",
            "Archive",
            "Active",
            "Allow"
        ]
    },
    {
        "q": "What does key 'D' mean in docker diff?",
        "o": [
            "Deleted",
            "Done",
            "Directory",
            "Denied"
        ]
    },
    {
        "q": "What does key 'C' mean in docker diff?",
        "o": [
            "Changed",
            "Created",
            "Copy",
            "Container"
        ]
    },
    {
        "q": "What is 'distroless' image?",
        "o": [
            "Minimal image containing only application and runtime dependencies (no shell, no package manager)",
            "Image without Linux",
            "Image without kernel",
            "Image without networking"
        ]
    },
    {
        "q": "Benefit of distroless?",
        "o": [
            "Security (smaller attack surface) and Size",
            "Easier debugging",
            "More tools",
            "Better compatibility"
        ]
    },
    {
        "q": "How do you debug distroless?",
        "o": [
            "Use ephemeral debug container (kubectl debug or docker debug) that mounts tools",
            "docker exec bash",
            "ssh",
            "Check logs"
        ]
    },
    {
        "q": "What is 'scratch' image?",
        "o": [
            "Empty image (0 bytes), root of all images",
            "A draft",
            "A temp image",
            "A virus"
        ]
    },
    {
        "q": "When to use FROM scratch?",
        "o": [
            "Static Go/Rust binaries or minimal base images",
            "Node.js apps",
            "Python apps",
            "Web servers"
        ]
    },
    {
        "q": "Can you run shell commands in scratch?",
        "o": [
            "No, no shell exists",
            "Yes",
            "Only if installed",
            "Only sh"
        ]
    },
    {
        "q": "How do you add CA certificates to scratch?",
        "o": [
            "COPY /etc/ssl/certs /etc/ssl/certs from a builder stage",
            "RUN apt install ca-certificates",
            "Automatic",
            "Cannot use SSL"
        ]
    },
    {
        "q": "What is 'Alpine' image?",
        "o": [
            "Small distro based on musl libc and busybox",
            "A mountain",
            "A large distro",
            "A game"
        ]
    },
    {
        "q": "Downside of Alpine?",
        "o": [
            "Uses musl libc (compatibility issues with glibc binaries/libraries)",
            "Too large",
            "Slow",
            "Insecure"
        ]
    },
    {
        "q": "What is 'Wolfi'?",
        "o": [
            "Undistro tailored for securing software supply chain (chainguard)",
            "A wolf",
            "A kernel",
            "A tool"
        ]
    },
    {
        "q": "What is 'docker unshare'?",
        "o": [
            "Runs a command in a new user namespace (mapped to root)",
            "Unshares a network",
            "Unshares a volume",
            "Stops sharing"
        ]
    },
    {
        "q": "Useful case for 'docker unshare'?",
        "o": [
            "Fixing permission issues on bind-mounted files when using user namespaces",
            "Deleting files",
            "Moving files",
            "Copying files"
        ]
    },
    {
        "q": "What is 'rootless docker'?",
        "o": [
            "Running Docker daemon and containers as non-root user",
            "Running as root",
            "Running without daemon",
            "Running without OS"
        ]
    },
    {
        "q": "Benefit of rootless docker?",
        "o": [
            "Security (if daemon is compromised, attacker is not root on host)",
            "Speed",
            "Ease of use",
            "Features"
        ]
    },
    {
        "q": "Limitation of rootless docker?",
        "o": [
            "Cannot verify non-standard ports < 1024 without capability grants",
            "No network",
            "No volumes",
            "No images"
        ]
    },
    {
        "q": "How do you install rootless docker?",
        "o": [
            "Use dockerd-rootless-setuptool.sh",
            "apt-get install docker-rootless",
            "It is default",
            "Use snap"
        ]
    },
    {
        "q": "What is 'userns-remap'?",
        "o": [
            "Mapping container user IDs to high range non-privileged host IDs",
            "Remapping network",
            "Remapping storage",
            "Remapping memory"
        ]
    },
    {
        "q": "Does 'userns-remap' affect existing images?",
        "o": [
            "Yes, ownership of files in /var/lib/docker must match remapped range",
            "No",
            "Only new ones",
            "Only running ones"
        ]
    },
    {
        "q": "What is the OCI Image Spec?",
        "o": [
            "Standard for image format (manifest, config, layers)",
            "Standard for running",
            "Standard for networking",
            "Standard for logs"
        ]
    },
    {
        "q": "What is the OCI Runtime Spec?",
        "o": [
            "Standard for filesystem bundle and lifecycle of a container",
            "Standard for image",
            "Standard for build",
            "Standard for push"
        ]
    },
    {
        "q": "What is 'runc'?",
        "o": [
            "CLI tool for spawning and running containers per OCI spec",
            "A runner",
            "A builder",
            "A compiler"
        ]
    },
    {
        "q": "What is 'containerd'?",
        "o": [
            "Daemon managing complete container lifecycle (pull, execute, snapshot)",
            "A container",
            "A registry",
            "A network"
        ]
    },
    {
        "q": "What is the relationship between Docker and containerd?",
        "o": [
            "Docker uses containerd as the high-level runtime",
            "Docker replaces containerd",
            "They are competitors",
            "No relation"
        ]
    },
    {
        "q": "Can you use containerd without Docker?",
        "o": [
            "Yes (e.g. via ctr or nerdctl)",
            "No",
            "Only on Linux",
            "Only on Windows"
        ]
    },
    {
        "q": "What is 'nerdctl'?",
        "o": [
            "Docker-compatible CLI for containerd",
            "A nerd tool",
            "A control tool",
            "A fake docker"
        ]
    },
    {
        "q": "Feature of nerdctl over docker?",
        "o": [
            "Built-in support for lazy pulling (eStargz), IPFS",
            "Better UI",
            "More plugins",
            "Cheaper"
        ]
    },
    {
        "q": "What is 'lazy pulling'?",
        "o": [
            "Starting container before downloading entire image (fetching chunks on demand)",
            "Pulling slowly",
            "Pulling later",
            "Pulling separately"
        ]
    },
    {
        "q": "What is 'eStargz'?",
        "o": [
            "Overlayfs-compatible format allowing seeking/lazy pulling",
            "A star",
            "A zip",
            "A tar"
        ]
    },
    {
        "q": "How do you enable lazy pulling?",
        "o": [
            "Use compatible registry/runtime (containerd + stargz-snapshotter) and format",
            "docker pull --lazy",
            "docker run --lazy",
            "Config option"
        ]
    },
    {
        "q": "What is 'Nottable' (OCI Artifacts)?",
        "o": [
            "Storing non-image content (Helm charts, policy, etc.) in registries",
            "A table",
            "A note",
            "A list"
        ]
    },
    {
        "q": "How to push any file to registry as artifact?",
        "o": [
            "Using TOOLS like ORAS (OCI Registry as Storage)",
            "docker push file",
            "docker cp",
            "ftp"
        ]
    },
    {
        "q": "What is 'ORAS'?",
        "o": [
            "Tool to push/pull OCI artifacts",
            "Gold",
            "A cloud",
            "A platform"
        ]
    },
    {
        "q": "Can Docker pull OCI artifacts?",
        "o": [
            "Historically no, but support is increasing for various media types",
            "Yes always",
            "No never",
            "Only images"
        ]
    },
    {
        "q": "What defines the type of OCI artifact?",
        "o": [
            "The mediaType field in manifest/config",
            "The file extension",
            "The name",
            "The tag"
        ]
    },
    {
        "q": "What is 'singularity' definition file?",
        "o": [
            "Similar to Dockerfile but for Singularity containers (HPC)",
            "A text file",
            "A binary",
            "A script"
        ]
    },
    {
        "q": "Can Singularity run Docker images?",
        "o": [
            "Yes, converting them to SIF",
            "No",
            "Only tar",
            "Only iso"
        ]
    },
    {
        "q": "What is the size limit of a single layer?",
        "o": [
            "Depends on registry/config, typically 10GB-50GB, but technically large",
            "100MB",
            "1GB",
            "No limit"
        ]
    },
    {
        "q": "What is 'docker history --human'?",
        "o": [
            "Human readable sizes",
            "Human readable commands",
            "Human readable dates",
            "Human readable users"
        ]
    },
    {
        "q": "How do you check image architecture?",
        "o": [
            "docker inspect --format '{{.Architecture}}'",
            "docker arch",
            "docker run arch",
            "file image"
        ]
    },
    {
        "q": "What happens when you pull 'alpine'?",
        "o": [
            "Manifest list is checked, matching arch is pulled, layers extracted",
            "Magic",
            "Downloads exe",
            "Downloads zip"
        ]
    },
    {
        "q": "Can you manually construct an image layer tar?",
        "o": [
            "Yes, adhering to tar specification and whiteout rules",
            "No",
            "Only docker can",
            "Only containerd can"
        ]
    },
    {
        "q": "What is a 'whiteout' file?",
        "o": [
            "A special file .wh.<name> indicating <name> was deleted in this layer",
            "A clear file",
            "A white file",
            "A blank file"
        ]
    },
    {
        "q": "What is an 'opaque whiteout'?",
        "o": [
            ".wh..wh..opq indicating directory content replacement",
            "Total deletion",
            "Hidden file",
            "System file"
        ]
    },
    {
        "q": "How do you view whiteout files?",
        "o": [
            "Extract layer tar manually",
            "docker ls -a",
            "ls -a",
            "stat"
        ]
    },
    {
        "q": "Does COPY --link (BuildKit) merge layers?",
        "o": [
            "No, creates independent layers that can be rebased without breaking cache",
            "Yes",
            "Sometimes",
            "If small"
        ]
    },
    {
        "q": "Benefit of COPY --link?",
        "o": [
            "Better caching, independent of previous layers",
            "Smaller size",
            "Faster IO",
            "More secure"
        ]
    },
    {
        "q": "What is 'docker mod' (deprecated)?",
        "o": [
            "Did not exist, maybe referencing Image2Docker tools",
            "Tool",
            "Command",
            "Plugin"
        ]
    },
    {
        "q": "What is 'pack' CLI (Cloud Native Buildpacks)?",
        "o": [
            "Tool to build apps into images using Buildpacks (no Dockerfile)",
            "Packer",
            "Zipper",
            "Compressor"
        ]
    },
    {
        "q": "What is 'rebase' in Buildpacks?",
        "o": [
            "Swapping the run image (OS/runtime) layer without rebuilding app layer",
            "Git rebase",
            "Moving files",
            "Renaming"
        ]
    },
    {
        "q": "Advantage of Buildpacks over Dockerfile?",
        "o": [
            "Standardized build process, automatic patching via rebase, no Dockerfile maintenance",
            "Flexible",
            "Customizable",
            "Legacy"
        ]
    },
    {
        "q": "What is 'jib'?",
        "o": [
            "Google tool for building Java Docker images without Docker daemon",
            "A sail",
            "A boat",
            "A code"
        ]
    },
    {
        "q": "How does Jib work?",
        "o": [
            "Splits app into dependencies, resources, classes layers, pushes directly to registry",
            "Uses Dockerfile",
            "Uses VM",
            "Uses ISO"
        ]
    },
    {
        "q": "What is 'ko'?",
        "o": [
            "Tool for building Go container images",
            "Knock out",
            "Kick off",
            "Kernel object"
        ]
    },
    {
        "q": "Can you sign images with Cosign (Sigstore)?",
        "o": [
            "Yes",
            "No",
            "Only jars",
            "Only wars"
        ]
    },
    {
        "q": "Where does Cosign store signatures?",
        "o": [
            "In the registry as a related artifact (tag based or referrers API)",
            "Local db",
            "Blockchain",
            "Email"
        ]
    },
    {
        "q": "What is 'keyless signing'?",
        "o": [
            "Using OIDC identity (e.g. GitHub Actions) and transparency log ephemeral keys",
            "No security",
            "Public signing",
            "Anonymous"
        ]
    }
]